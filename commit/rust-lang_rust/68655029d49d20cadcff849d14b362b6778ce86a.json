{"sha": "68655029d49d20cadcff849d14b362b6778ce86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NjU1MDI5ZDQ5ZDIwY2FkY2ZmODQ5ZDE0YjM2MmI2Nzc4Y2U4NmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T09:30:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T09:30:34Z"}, "message": "Auto merge of #60730 - matthewjasper:optimize-false-edges, r=pnkfelix\n\nOptimize matches\n\nAttempt to fix or improve #60571\n\nThis is breaking some diagnostics because the MIR for match arms isn't in source order any more.\n\ncc @centril", "tree": {"sha": "0d6483fc8b901bfc4ae9d33875bda2a006fbb15e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d6483fc8b901bfc4ae9d33875bda2a006fbb15e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68655029d49d20cadcff849d14b362b6778ce86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68655029d49d20cadcff849d14b362b6778ce86a", "html_url": "https://github.com/rust-lang/rust/commit/68655029d49d20cadcff849d14b362b6778ce86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68655029d49d20cadcff849d14b362b6778ce86a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "374c63e0fc356eb61b1966cb6026a2a49fe9226d", "url": "https://api.github.com/repos/rust-lang/rust/commits/374c63e0fc356eb61b1966cb6026a2a49fe9226d", "html_url": "https://github.com/rust-lang/rust/commit/374c63e0fc356eb61b1966cb6026a2a49fe9226d"}, {"sha": "89ea69ab238d1d61d00a44e72061f6794d937255", "url": "https://api.github.com/repos/rust-lang/rust/commits/89ea69ab238d1d61d00a44e72061f6794d937255", "html_url": "https://github.com/rust-lang/rust/commit/89ea69ab238d1d61d00a44e72061f6794d937255"}], "stats": {"total": 1594, "additions": 856, "deletions": 738}, "files": [{"sha": "3d96acbe7be974eec52c719f5d3e83e7446c5487", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1196,9 +1196,9 @@ pub enum TerminatorKind<'tcx> {\n     FalseEdges {\n         /// The target normal control flow will take\n         real_target: BasicBlock,\n-        /// The list of blocks control flow could conceptually take, but won't\n-        /// in practice\n-        imaginary_targets: Vec<BasicBlock>,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice\n+        imaginary_target: BasicBlock,\n     },\n     /// A terminator for blocks that only take one path in reality, but where we\n     /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n@@ -1335,8 +1335,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n             FalseEdges {\n                 ref real_target,\n-                ref imaginary_targets,\n-            } => Some(real_target).into_iter().chain(&imaginary_targets[..]),\n+                ref imaginary_target,\n+            } => Some(real_target).into_iter().chain(slice::from_ref(imaginary_target)),\n         }\n     }\n \n@@ -1422,10 +1422,10 @@ impl<'tcx> TerminatorKind<'tcx> {\n             } => None.into_iter().chain(&mut targets[..]),\n             FalseEdges {\n                 ref mut real_target,\n-                ref mut imaginary_targets,\n+                ref mut imaginary_target,\n             } => Some(real_target)\n                 .into_iter()\n-                .chain(&mut imaginary_targets[..]),\n+                .chain(slice::from_mut(imaginary_target)),\n         }\n     }\n \n@@ -1722,12 +1722,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Assert { cleanup: None, .. } => vec![\"\".into()],\n             Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n             FalseEdges {\n-                ref imaginary_targets,\n                 ..\n             } => {\n-                let mut l = vec![\"real\".into()];\n-                l.resize(imaginary_targets.len() + 1, \"imaginary\".into());\n-                l\n+                vec![\"real\".into(), \"imaginary\".into()]\n             }\n             FalseUnwind {\n                 unwind: Some(_), ..\n@@ -3356,10 +3353,10 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Unreachable => Unreachable,\n             FalseEdges {\n                 real_target,\n-                ref imaginary_targets,\n+                imaginary_target,\n             } => FalseEdges {\n                 real_target,\n-                imaginary_targets: imaginary_targets.clone(),\n+                imaginary_target,\n             },\n             FalseUnwind {\n                 real_target,"}, {"sha": "9c2ab91fe2f8b2afdee21d50920e8125d75d1736", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -780,7 +780,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n             | TerminatorKind::Unreachable\n             | TerminatorKind::FalseEdges {\n                 real_target: _,\n-                imaginary_targets: _,\n+                imaginary_target: _,\n             }\n             | TerminatorKind::FalseUnwind {\n                 real_target: _,"}, {"sha": "286f3ac5ccdad87c379a75ca3072e4c64a02d707", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -244,7 +244,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             | TerminatorKind::Unreachable\n             | TerminatorKind::FalseEdges {\n                 real_target: _,\n-                imaginary_targets: _,\n+                imaginary_target: _,\n             }\n             | TerminatorKind::FalseUnwind {\n                 real_target: _,"}, {"sha": "ad79f2109207b5ac33512320af8d32f0c7706054", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1792,12 +1792,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::FalseEdges {\n                 real_target,\n-                ref imaginary_targets,\n+                imaginary_target,\n             } => {\n                 self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n-                for target in imaginary_targets {\n-                    self.assert_iscleanup(body, block_data, *target, is_cleanup);\n-                }\n+                self.assert_iscleanup(body, block_data, imaginary_target, is_cleanup);\n             }\n             TerminatorKind::FalseUnwind {\n                 real_target,"}, {"sha": "134ff52efe1e59574df7372a9b3a478d035cefff", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 200, "deletions": 173, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -143,19 +143,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n-        let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n+        let pre_binding_blocks: Vec<_> = (0..candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n \n-        // There's one more pre_binding block than there are candidates so that\n-        // every candidate can have a `next_candidate_pre_binding_block`.\n-        let outer_source_info = self.source_info(span);\n-        self.cfg.terminate(\n-            *pre_binding_blocks.last().unwrap(),\n-            outer_source_info,\n-            TerminatorKind::Unreachable,\n-        );\n-\n         let mut match_has_guard = false;\n \n         let mut candidate_pre_binding_blocks = pre_binding_blocks.iter();\n@@ -171,9 +162,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_candidates: Vec<_> = arm.patterns\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n-                    .zip(next_candidate_pre_binding_blocks.by_ref())\n                     .map(\n-                        |((pattern, pre_binding_block), next_candidate_pre_binding_block)| {\n+                        |(pattern, pre_binding_block)| {\n                             Candidate {\n                                 span: pattern.span,\n                                 match_pairs: vec![\n@@ -188,7 +178,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 },\n                                 pre_binding_block: *pre_binding_block,\n                                 next_candidate_pre_binding_block:\n-                                    *next_candidate_pre_binding_block,\n+                                    next_candidate_pre_binding_blocks.next().copied(),\n                             }\n                         },\n                     )\n@@ -216,31 +206,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .flat_map(|(_, candidates)| candidates)\n             .collect::<Vec<_>>();\n \n+        let outer_source_info = self.source_info(span);\n+\n         // this will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n-        let otherwise = self.match_candidates(\n+        self.match_candidates(\n             scrutinee_span,\n+            &mut Some(block),\n+            None,\n             candidates,\n-            block,\n             &mut fake_borrows,\n         );\n \n-        if !otherwise.is_empty() {\n-            // All matches are exhaustive. However, because some matches\n-            // only have exponentially-large exhaustive decision trees, we\n-            // sometimes generate an inexhaustive decision tree.\n-            //\n-            // In that case, the inexhaustive tips of the decision tree\n-            // can't be reached - terminate them with an `unreachable`.\n-            let mut otherwise = otherwise;\n-            otherwise.sort();\n-            otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-            for block in otherwise {\n-                self.cfg\n-                    .terminate(block, outer_source_info, TerminatorKind::Unreachable);\n-            }\n-        }\n-\n         // Step 4. Determine the fake borrows that are needed from the above\n         // places. Create the required temporaries for them.\n \n@@ -251,13 +228,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         // Step 5. Create everything else: the guards and the arms.\n-\n-        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, candidates)| {\n+        let arm_end_blocks: Vec<_> = arm_candidates.into_iter().map(|(arm, mut candidates)| {\n             let arm_source_info = self.source_info(arm.span);\n             let region_scope = (arm.scope, arm_source_info);\n             self.in_scope(region_scope, arm.lint_level, |this| {\n-                let arm_block = this.cfg.start_new_block();\n-\n                 let body = this.hir.mirror(arm.body.clone());\n                 let scope = this.declare_bindings(\n                     None,\n@@ -267,20 +241,36 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Some((Some(&scrutinee_place), scrutinee_span)),\n                 );\n \n-                if let Some(source_scope) = scope {\n-                    this.source_scope = source_scope;\n-                }\n-\n-                for candidate in candidates {\n-                    this.clear_top_scope(arm.scope);\n-                    this.bind_and_guard_matched_candidate(\n-                        candidate,\n+                let arm_block;\n+                if candidates.len() == 1 {\n+                    arm_block = this.bind_and_guard_matched_candidate(\n+                        candidates.pop().unwrap(),\n                         arm.guard.clone(),\n-                        arm_block,\n                         &fake_borrow_temps,\n                         scrutinee_span,\n                         region_scope,\n                     );\n+                } else {\n+                    arm_block = this.cfg.start_new_block();\n+                    for candidate in candidates {\n+                        this.clear_top_scope(arm.scope);\n+                        let binding_end = this.bind_and_guard_matched_candidate(\n+                            candidate,\n+                            arm.guard.clone(),\n+                            &fake_borrow_temps,\n+                            scrutinee_span,\n+                            region_scope,\n+                        );\n+                        this.cfg.terminate(\n+                            binding_end,\n+                            source_info,\n+                            TerminatorKind::Goto { target: arm_block },\n+                        );\n+                    }\n+                }\n+\n+                if let Some(source_scope) = scope {\n+                    this.source_scope = source_scope;\n                 }\n \n                 this.into(destination, arm_block, body)\n@@ -434,7 +424,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // since we don't call `match_candidates`, next fields are unused\n             otherwise_block: None,\n             pre_binding_block: block,\n-            next_candidate_pre_binding_block: block,\n+            next_candidate_pre_binding_block: None,\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n@@ -689,7 +679,7 @@ pub struct Candidate<'pat, 'tcx: 'pat> {\n \n     // ...and the blocks for add false edges between candidates\n     pre_binding_block: BasicBlock,\n-    next_candidate_pre_binding_block: BasicBlock,\n+    next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n@@ -725,29 +715,46 @@ pub struct MatchPair<'pat, 'tcx: 'pat> {\n \n #[derive(Clone, Debug, PartialEq)]\n enum TestKind<'tcx> {\n-    // test the branches of enum\n+    /// Test the branches of enum.\n     Switch {\n+        /// The enum being tested\n         adt_def: &'tcx ty::AdtDef,\n+        /// The set of variants that we should create a branch for. We also\n+        /// create an additional \"otherwise\" case.\n         variants: BitSet<VariantIdx>,\n     },\n \n-    // test the branches of enum\n+    /// Test what value an `integer`, `bool` or `char` has.\n     SwitchInt {\n+        /// The type of the value that we're testing.\n         switch_ty: Ty<'tcx>,\n+        /// The (ordered) set of values that we test for.\n+        ///\n+        /// For integers and `char`s we create a branch to each of the values in\n+        /// `options`, as well as an \"otherwise\" branch for all other values, even\n+        /// in the (rare) case that options is exhaustive.\n+        ///\n+        /// For `bool` we always generate two edges, one for `true` and one for\n+        /// `false`.\n         options: Vec<u128>,\n+        /// Reverse map used to ensure that the values in `options` are unique.\n         indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n \n-    // test for equality\n+    /// Test for equality with value, possibly after an unsizing coercion to\n+    /// `ty`,\n     Eq {\n         value: &'tcx ty::Const<'tcx>,\n+        // Integer types are handled by `SwitchInt`, and constants with ADT\n+        // types are converted back into patterns, so this can only be `&str`,\n+        // `&[T]`, `f32` or `f64`.\n         ty: Ty<'tcx>,\n     },\n \n-    // test whether the value falls within an inclusive or exclusive range\n+    /// Test whether the value falls within an inclusive or exclusive range\n     Range(PatternRange<'tcx>),\n \n-    // test length of the slice is equal to len\n+    /// Test length of the slice is equal to len\n     Len {\n         len: u64,\n         op: BinOp,\n@@ -777,11 +784,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// the value, we will generate a branch to the appropriate\n     /// prebinding block.\n     ///\n-    /// The return value is a list of \"otherwise\" blocks. These are\n-    /// points in execution where we found that *NONE* of the\n-    /// candidates apply. In principle, this means that the input\n-    /// list was not exhaustive, though at present we sometimes are\n-    /// not smart enough to recognize all exhaustive inputs.\n+    /// If we find that *NONE* of the candidates apply, we branch to the\n+    /// `otherwise_block`. In principle, this means that the input list was not\n+    /// exhaustive, though at present we sometimes are not smart enough to\n+    /// recognize all exhaustive inputs.\n     ///\n     /// It might be surprising that the input can be inexhaustive.\n     /// Indeed, initially, it is not, because all matches are\n@@ -795,13 +801,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n+        start_block: &mut Option<BasicBlock>,\n+        otherwise_block: Option<BasicBlock>,\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n-        mut block: BasicBlock,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n-    ) -> Vec<BasicBlock> {\n+    ) {\n         debug!(\n-            \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n-            span, block, candidates\n+            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n+            span,\n+            candidates,\n+            start_block,\n+            otherwise_block,\n         );\n \n         // Start by simplifying candidates. Once this process is complete, all\n@@ -824,52 +834,57 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let (matched_candidates, unmatched_candidates) = candidates.split_at_mut(fully_matched);\n \n+        let block: BasicBlock;\n+\n         if !matched_candidates.is_empty() {\n-            block = if let Some(last_otherwise_block) = self.select_matched_candidates(\n+            let otherwise_block = self.select_matched_candidates(\n                 matched_candidates,\n-                block,\n+                start_block,\n                 fake_borrows,\n-            ) {\n-                last_otherwise_block\n+            );\n+\n+            if let Some(last_otherwise_block) = otherwise_block {\n+                block = last_otherwise_block\n             } else {\n                 // Any remaining candidates are unreachable.\n                 if unmatched_candidates.is_empty() {\n-                    return Vec::new();\n-                } else {\n-                    self.cfg.start_new_block()\n+                    return;\n                 }\n+                block = self.cfg.start_new_block();\n             };\n+        } else {\n+            block = *start_block.get_or_insert_with(|| self.cfg.start_new_block());\n         }\n \n         // If there are no candidates that still need testing, we're\n         // done. Since all matches are exhaustive, execution should\n         // never reach this point.\n         if unmatched_candidates.is_empty() {\n-            return vec![block];\n+            let source_info = self.source_info(span);\n+            if let Some(otherwise) = otherwise_block {\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Goto { target: otherwise },\n+                );\n+            } else {\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Unreachable,\n+                )\n+            }\n+            return;\n         }\n \n-        // Test candidates where possible.\n-        let (otherwise, untested_candidates) = self.test_candidates(\n+        // Test for the remaining candidates.\n+        self.test_candidates(\n             span,\n             unmatched_candidates,\n             block,\n+            otherwise_block,\n             fake_borrows,\n         );\n-\n-        // If the target candidates were exhaustive, then we are done.\n-        // But for borrowck continue build decision tree.\n-        if untested_candidates.is_empty() {\n-            return otherwise;\n-        }\n-\n-        // Otherwise, let's process those remaining candidates.\n-        let join_block = self.join_otherwise_blocks(span, otherwise);\n-        self.match_candidates(\n-            span,\n-            untested_candidates,\n-            join_block,\n-            fake_borrows,\n-        )\n     }\n \n     /// Link up matched candidates. For example, if we have something like\n@@ -893,7 +908,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n-        block: BasicBlock,\n+        start_block: &mut Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) -> Option<BasicBlock> {\n         debug_assert!(\n@@ -941,31 +956,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             = matched_candidates.split_at_mut(fully_matched_with_guard + 1);\n \n         let first_candidate = &reachable_candidates[0];\n+        let first_prebinding_block = first_candidate.pre_binding_block;\n \n-        let candidate_source_info = self.source_info(first_candidate.span);\n-\n-        self.cfg.terminate(\n-            block,\n-            candidate_source_info,\n-            TerminatorKind::Goto {\n-                target: first_candidate.pre_binding_block,\n-            },\n-        );\n+        if let Some(start_block) = *start_block {\n+            let source_info = self.source_info(first_candidate.span);\n+            self.cfg.terminate(\n+                start_block,\n+                source_info,\n+                TerminatorKind::Goto { target: first_prebinding_block },\n+            );\n+        } else {\n+            *start_block = Some(first_prebinding_block);\n+        }\n \n         for window in reachable_candidates.windows(2) {\n             if let [first_candidate, second_candidate] = window {\n                 let source_info = self.source_info(first_candidate.span);\n                 if let Some(otherwise_block) = first_candidate.otherwise_block {\n-                    self.cfg.terminate(\n+                    self.false_edges(\n                         otherwise_block,\n+                        second_candidate.pre_binding_block,\n+                        first_candidate.next_candidate_pre_binding_block,\n                         source_info,\n-                        TerminatorKind::FalseEdges {\n-                            real_target: second_candidate.pre_binding_block,\n-                            imaginary_targets: vec![\n-                                first_candidate.next_candidate_pre_binding_block\n-                            ],\n-                        }\n-                    )\n+                    );\n                 } else {\n                     bug!(\"candidate other than the last has no guard\");\n                 }\n@@ -979,13 +992,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(otherwise) = candidate.otherwise_block {\n                 let source_info = self.source_info(candidate.span);\n                 let unreachable = self.cfg.start_new_block();\n-                self.cfg.terminate(\n+                self.false_edges(\n                     otherwise,\n+                    unreachable,\n+                    candidate.next_candidate_pre_binding_block,\n                     source_info,\n-                    TerminatorKind::FalseEdges {\n-                        real_target: unreachable,\n-                        imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n-                    }\n                 );\n                 self.cfg.terminate(unreachable, source_info, TerminatorKind::Unreachable);\n             }\n@@ -996,39 +1007,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if let Some(otherwise) = last_candidate.otherwise_block {\n             let source_info = self.source_info(last_candidate.span);\n             let block = self.cfg.start_new_block();\n-            self.cfg.terminate(\n+            self.false_edges(\n                 otherwise,\n+                block,\n+                last_candidate.next_candidate_pre_binding_block,\n                 source_info,\n-                TerminatorKind::FalseEdges {\n-                    real_target: block,\n-                    imaginary_targets: vec![last_candidate.next_candidate_pre_binding_block]\n-                }\n             );\n             Some(block)\n         } else {\n             None\n         }\n     }\n \n-    fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n-        let source_info = self.source_info(span);\n-        otherwise.sort();\n-        otherwise.dedup(); // variant switches can introduce duplicate target blocks\n-        if otherwise.len() == 1 {\n-            otherwise[0]\n-        } else {\n-            let join_block = self.cfg.start_new_block();\n-            for block in otherwise {\n-                self.cfg.terminate(\n-                    block,\n-                    source_info,\n-                    TerminatorKind::Goto { target: join_block },\n-                );\n-            }\n-            join_block\n-        }\n-    }\n-\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n@@ -1146,8 +1136,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n         mut candidates: &'b mut [&'c mut Candidate<'pat, 'tcx>],\n         block: BasicBlock,\n+        mut otherwise_block: Option<BasicBlock>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n-    ) -> (Vec<BasicBlock>, &'b mut [&'c mut Candidate<'pat, 'tcx>]) {\n+    ) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n@@ -1201,9 +1192,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             \"match_candidates: test={:?} match_pair={:?}\",\n             test, match_pair\n         );\n-        let target_blocks = self.perform_test(block, &match_place, &test);\n         let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n-        target_candidates.resize_with(target_blocks.len(), Default::default);\n+        target_candidates.resize_with(test.targets(), Default::default);\n \n         let total_candidate_count = candidates.len();\n \n@@ -1225,24 +1215,59 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n         debug!(\"untested_candidates: {}\", candidates.len());\n \n-        // For each outcome of test, process the candidates that still\n-        // apply. Collect a list of blocks where control flow will\n-        // branch if one of the `target_candidate` sets is not\n-        // exhaustive.\n-        let otherwise: Vec<_> = target_blocks\n-            .into_iter()\n-            .zip(target_candidates)\n-            .flat_map(|(target_block, mut target_candidates)| {\n-                self.match_candidates(\n+        // HACK(matthewjasper) This is a closure so that we can let the test\n+        // create its blocks before the rest of the match. This currently\n+        // improves the speed of llvm when optimizing long string literal\n+        // matches\n+        let make_target_blocks = move |this: &mut Self| -> Vec<BasicBlock> {\n+            // For each outcome of test, process the candidates that still\n+            // apply. Collect a list of blocks where control flow will\n+            // branch if one of the `target_candidate` sets is not\n+            // exhaustive.\n+            if !candidates.is_empty() {\n+                let remainder_start = &mut None;\n+                this.match_candidates(\n                     span,\n-                    &mut *target_candidates,\n-                    target_block,\n+                    remainder_start,\n+                    otherwise_block,\n+                    candidates,\n                     fake_borrows,\n-                )\n-            })\n-            .collect();\n+                );\n+                otherwise_block = Some(remainder_start.unwrap());\n+            };\n \n-        (otherwise, candidates)\n+            target_candidates.into_iter().map(|mut candidates| {\n+                if candidates.len() != 0 {\n+                    let candidate_start = &mut None;\n+                    this.match_candidates(\n+                        span,\n+                        candidate_start,\n+                        otherwise_block,\n+                        &mut *candidates,\n+                        fake_borrows,\n+                    );\n+                    candidate_start.unwrap()\n+                } else {\n+                    *otherwise_block.get_or_insert_with(|| {\n+                        let unreachable = this.cfg.start_new_block();\n+                        let source_info = this.source_info(span);\n+                        this.cfg.terminate(\n+                            unreachable,\n+                            source_info,\n+                            TerminatorKind::Unreachable,\n+                        );\n+                        unreachable\n+                    })\n+                }\n+            }).collect()\n+        };\n+\n+        self.perform_test(\n+            block,\n+            &match_place,\n+            &test,\n+            make_target_blocks,\n+        );\n     }\n \n     // Determine the fake borrows that are needed to ensure that the place\n@@ -1313,27 +1338,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         guard: Option<Guard<'tcx>>,\n-        arm_block: BasicBlock,\n         fake_borrows: &Vec<(&Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         region_scope: (region::Scope, SourceInfo),\n-    ) {\n+    ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n         let candidate_source_info = self.source_info(candidate.span);\n \n-        let mut block = self.cfg.start_new_block();\n-        self.cfg.terminate(\n-            candidate.pre_binding_block,\n-            candidate_source_info,\n-            TerminatorKind::FalseEdges {\n-                real_target: block,\n-                imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n-            },\n-        );\n-        self.ascribe_types(block, &candidate.ascriptions);\n+        let mut block = candidate.pre_binding_block;\n+\n+        // If we are adding our own statements, then we need a fresh block.\n+        let create_fresh_block = candidate.next_candidate_pre_binding_block.is_some()\n+            || !candidate.bindings.is_empty()\n+            || !candidate.ascriptions.is_empty()\n+            || guard.is_some();\n+\n+        if create_fresh_block {\n+            let fresh_block = self.cfg.start_new_block();\n+            self.false_edges(\n+                block,\n+                fresh_block,\n+                candidate.next_candidate_pre_binding_block,\n+                candidate_source_info,\n+            );\n+            block = fresh_block;\n+            self.ascribe_types(block, &candidate.ascriptions);\n+        } else {\n+            return block;\n+        }\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -1478,7 +1513,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // because that would be before we've checked the result\n             // from the guard.\n             //\n-            // But binding them on `arm_block` is *too late*, because\n+            // But binding them on the arm is *too late*, because\n             // then all of the candidates for a single arm would be\n             // bound in the same place, that would cause a case like:\n             //\n@@ -1554,22 +1589,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 by_value_bindings,\n             );\n \n-            self.cfg.terminate(\n-                post_guard_block,\n-                source_info,\n-                TerminatorKind::Goto { target: arm_block },\n-            );\n+            post_guard_block\n         } else {\n             assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            self.cfg.terminate(\n-                block,\n-                candidate_source_info,\n-                TerminatorKind::Goto { target: arm_block },\n-            );\n+            block\n         }\n     }\n "}, {"sha": "95e2e52092a91c138e1866944c3d96b3443ec414", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 270, "deletions": 199, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -15,8 +15,9 @@ use rustc::ty::{self, Ty, adjustment::{PointerCast}};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::layout::VariantIdx;\n use rustc::mir::*;\n-use rustc::hir::{RangeEnd, Mutability};\n-use syntax_pos::Span;\n+use rustc::hir::RangeEnd;\n+use syntax_pos::symbol::sym;\n+\n use std::cmp::Ordering;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -162,43 +163,51 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    /// Generates the code to perform a test.\n-    pub fn perform_test(&mut self,\n-                        block: BasicBlock,\n-                        place: &Place<'tcx>,\n-                        test: &Test<'tcx>)\n-                        -> Vec<BasicBlock> {\n+    pub fn perform_test(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        test: &Test<'tcx>,\n+        make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n+    ) {\n         debug!(\"perform_test({:?}, {:?}: {:?}, {:?})\",\n                block,\n                place,\n                place.ty(&self.local_decls, self.hir.tcx()),\n                test);\n+\n         let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n+                let target_blocks = make_target_blocks(self);\n                 // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = adt_def.variants.len();\n                 let used_variants = variants.count();\n-                let mut otherwise_block = None;\n-                let mut target_blocks = Vec::with_capacity(num_enum_variants);\n+                debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n+                let otherwise_block = *target_blocks.last().unwrap();\n                 let mut targets = Vec::with_capacity(used_variants + 1);\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx) {\n-                    target_blocks.push(if variants.contains(idx) {\n+                    if variants.contains(idx) {\n+                        debug_assert_ne!(\n+                            target_blocks[idx.index()],\n+                            otherwise_block,\n+                            \"no canididates for tested discriminant: {:?}\",\n+                            discr,\n+                        );\n                         values.push(discr.val);\n-                        let block = self.cfg.start_new_block();\n-                        targets.push(block);\n-                        block\n+                        targets.push(target_blocks[idx.index()]);\n                     } else {\n-                        *otherwise_block\n-                            .get_or_insert_with(|| self.cfg.start_new_block())\n-                    });\n+                        debug_assert_eq!(\n+                            target_blocks[idx.index()],\n+                            otherwise_block,\n+                            \"found canididates for untested discriminant: {:?}\",\n+                            discr,\n+                        );\n+                    }\n                 }\n-                targets.push(\n-                    otherwise_block\n-                        .unwrap_or_else(|| self.unreachable_block()),\n-                );\n+                targets.push(otherwise_block);\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n@@ -212,182 +221,97 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     values: From::from(values),\n                     targets,\n                 });\n-                target_blocks\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (ret, terminator) = if switch_ty.sty == ty::Bool {\n+                let target_blocks = make_target_blocks(self);\n+                let terminator = if switch_ty.sty == ty::Bool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n-                    let (true_bb, false_bb) = (self.cfg.start_new_block(),\n-                                               self.cfg.start_new_block());\n-                    let ret = match options[0] {\n-                        1 => vec![true_bb, false_bb],\n-                        0 => vec![false_bb, true_bb],\n-                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n-                    };\n-                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place.clone()),\n-                                              true_bb, false_bb))\n+                    if let [first_bb, second_bb] = *target_blocks {\n+                        let (true_bb, false_bb) = match options[0] {\n+                            1 => (first_bb, second_bb),\n+                            0 => (second_bb, first_bb),\n+                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n+                        };\n+                        TerminatorKind::if_(\n+                            self.hir.tcx(),\n+                            Operand::Copy(place.clone()),\n+                            true_bb,\n+                            false_bb,\n+                        )\n+                    } else {\n+                        bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n+                    }\n                 } else {\n-                    // The switch may be inexhaustive so we\n-                    // add a catch all block\n-                    let otherwise = self.cfg.start_new_block();\n-                    let targets: Vec<_> =\n-                        options.iter()\n-                               .map(|_| self.cfg.start_new_block())\n-                               .chain(Some(otherwise))\n-                               .collect();\n-                    (targets.clone(), TerminatorKind::SwitchInt {\n+                    // The switch may be inexhaustive so we have a catch all block\n+                    debug_assert_eq!(options.len() + 1, target_blocks.len());\n+                    TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place.clone()),\n                         switch_ty,\n                         values: options.clone().into(),\n-                        targets,\n-                    })\n+                        targets: target_blocks,\n+                    }\n                 };\n                 self.cfg.terminate(block, source_info, terminator);\n-                ret\n             }\n \n-            TestKind::Eq { value, mut ty } => {\n-                let val = Operand::Copy(place.clone());\n-                let mut expect = self.literal_operand(test.span, ty, value);\n-                // Use `PartialEq::eq` instead of `BinOp::Eq`\n-                // (the binop can only handle primitives)\n-                let fail = self.cfg.start_new_block();\n+            TestKind::Eq { value, ty } => {\n                 if !ty.is_scalar() {\n-                    // If we're using `b\"...\"` as a pattern, we need to insert an\n-                    // unsizing coercion, as the byte string has the type `&[u8; N]`.\n-                    //\n-                    // We want to do this even when the scrutinee is a reference to an\n-                    // array, so we can call `<[u8]>::eq` rather than having to find an\n-                    // `<[u8; N]>::eq`.\n-                    let unsize = |ty: Ty<'tcx>| match ty.sty {\n-                        ty::Ref(region, rty, _) => match rty.sty {\n-                            ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n-                            _ => None,\n-                        },\n-                        _ => None,\n-                    };\n-                    let opt_ref_ty = unsize(ty);\n-                    let opt_ref_test_ty = unsize(value.ty);\n-                    let mut place = place.clone();\n-                    match (opt_ref_ty, opt_ref_test_ty) {\n-                        // nothing to do, neither is an array\n-                        (None, None) => {},\n-                        (Some((region, elem_ty, _)), _) |\n-                        (None, Some((region, elem_ty, _))) => {\n-                            let tcx = self.hir.tcx();\n-                            // make both a slice\n-                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n-                            if opt_ref_ty.is_some() {\n-                                place = self.temp(ty, test.span);\n-                                self.cfg.push_assign(\n-                                    block, source_info, &place, Rvalue::Cast(\n-                                        CastKind::Pointer(PointerCast::Unsize), val, ty\n-                                    )\n-                                );\n-                            }\n-                            if opt_ref_test_ty.is_some() {\n-                                let array = self.literal_operand(\n-                                    test.span,\n-                                    value.ty,\n-                                    value,\n-                                );\n-\n-                                let slice = self.temp(ty, test.span);\n-                                self.cfg.push_assign(\n-                                    block, source_info, &slice, Rvalue::Cast(\n-                                        CastKind::Pointer(PointerCast::Unsize), array, ty\n-                                    )\n-                                );\n-                                expect = Operand::Move(slice);\n-                            }\n-                        },\n-                    }\n-                    let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n-                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n-\n-                    let re_erased = self.hir.tcx().lifetimes.re_erased;\n-                    // take the argument by reference\n-                    let tam = ty::TypeAndMut {\n+                    // Use `PartialEq::eq` instead of `BinOp::Eq`\n+                    // (the binop can only handle primitives)\n+                    self.non_scalar_compare(\n+                        block,\n+                        make_target_blocks,\n+                        source_info,\n+                        value,\n+                        place,\n                         ty,\n-                        mutbl: Mutability::MutImmutable,\n-                    };\n-                    let ref_ty = self.hir.tcx().mk_ref(re_erased, tam);\n-\n-                    // let lhs_ref_place = &lhs;\n-                    let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, place);\n-                    let lhs_ref_place = self.temp(ref_ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n-                    let val = Operand::Move(lhs_ref_place);\n-\n-                    // let rhs_place = rhs;\n-                    let rhs_place = self.temp(ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n-\n-                    // let rhs_ref_place = &rhs_place;\n-                    let ref_rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, rhs_place);\n-                    let rhs_ref_place = self.temp(ref_ty, test.span);\n-                    self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n-                    let expect = Operand::Move(rhs_ref_place);\n-\n-                    let bool_ty = self.hir.bool_ty();\n-                    let eq_result = self.temp(bool_ty, test.span);\n-                    let eq_block = self.cfg.start_new_block();\n-                    let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, source_info, TerminatorKind::Call {\n-                        func: Operand::Constant(box Constant {\n-                            span: test.span,\n-                            ty: mty,\n-\n-                            // FIXME(#54571): This constant comes from user\n-                            // input (a constant in a pattern).  Are\n-                            // there forms where users can add type\n-                            // annotations here?  For example, an\n-                            // associated constant? Need to\n-                            // experiment.\n-                            user_ty: None,\n-\n-                            literal: method,\n-                        }),\n-                        args: vec![val, expect],\n-                        destination: Some((eq_result.clone(), eq_block)),\n-                        cleanup: Some(cleanup),\n-                        from_hir_call: false,\n-                    });\n-\n-                    // check the result\n-                    let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, source_info,\n-                                       TerminatorKind::if_(self.hir.tcx(),\n-                                                           Operand::Move(eq_result),\n-                                                           block, fail));\n-                    vec![block, fail]\n+                    );\n                 } else {\n-                    let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n-                    vec![block, fail]\n+                    if let [success, fail] = *make_target_blocks(self) {\n+                        let val = Operand::Copy(place.clone());\n+                        let expect = self.literal_operand(test.span, ty, value);\n+                        self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n+                    } else {\n+                        bug!(\"`TestKind::Eq` should have two target blocks\");\n+                    }\n                 }\n             }\n \n             TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n+                let lower_bound_success = self.cfg.start_new_block();\n+                let target_blocks = make_target_blocks(self);\n+\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, ty, lo);\n                 let hi = self.literal_operand(test.span, ty, hi);\n                 let val = Operand::Copy(place.clone());\n \n-                let fail = self.cfg.start_new_block();\n-                let block = self.compare(block, fail, test.span, BinOp::Le, lo, val.clone());\n-                let block = match *end {\n-                    RangeEnd::Included => self.compare(block, fail, test.span, BinOp::Le, val, hi),\n-                    RangeEnd::Excluded => self.compare(block, fail, test.span, BinOp::Lt, val, hi),\n-                };\n-\n-                vec![block, fail]\n+                if let [success, fail] = *target_blocks {\n+                    self.compare(\n+                        block,\n+                        lower_bound_success,\n+                        fail,\n+                        source_info,\n+                        BinOp::Le,\n+                        lo,\n+                        val.clone(),\n+                    );\n+                    let op = match *end {\n+                        RangeEnd::Included => BinOp::Le,\n+                        RangeEnd::Excluded => BinOp::Lt,\n+                    };\n+                    self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n+                } else {\n+                    bug!(\"`TestKind::Range` should have two target blocks\");\n+                }\n             }\n \n             TestKind::Len { len, op } => {\n-                let (usize_ty, bool_ty) = (self.hir.usize_ty(), self.hir.bool_ty());\n-                let (actual, result) = (self.temp(usize_ty, test.span),\n-                                        self.temp(bool_ty, test.span));\n+                let target_blocks = make_target_blocks(self);\n+\n+                let usize_ty = self.hir.usize_ty();\n+                let actual = self.temp(usize_ty, test.span);\n \n                 // actual = len(place)\n                 self.cfg.push_assign(block, source_info,\n@@ -396,44 +320,165 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n \n-                // result = actual == expected OR result = actual < expected\n-                self.cfg.push_assign(block, source_info, &result,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Move(actual),\n-                                                      Operand::Move(expected)));\n-\n-                // branch based on result\n-                let (false_bb, true_bb) = (self.cfg.start_new_block(),\n-                                           self.cfg.start_new_block());\n-                self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n-                                                       true_bb, false_bb));\n-                vec![true_bb, false_bb]\n+                if let [true_bb, false_bb] = *target_blocks {\n+                    // result = actual == expected OR result = actual < expected\n+                    // branch based on result\n+                    self.compare(\n+                        block,\n+                        true_bb,\n+                        false_bb,\n+                        source_info,\n+                        op,\n+                        Operand::Move(actual),\n+                        Operand::Move(expected),\n+                    );\n+                } else {\n+                    bug!(\"`TestKind::Len` should have two target blocks\");\n+                }\n             }\n         }\n     }\n \n-    fn compare(&mut self,\n-               block: BasicBlock,\n-               fail_block: BasicBlock,\n-               span: Span,\n-               op: BinOp,\n-               left: Operand<'tcx>,\n-               right: Operand<'tcx>) -> BasicBlock {\n+    /// Compare using the provided built-in comparison operator\n+    fn compare(\n+        &mut self,\n+        block: BasicBlock,\n+        success_block: BasicBlock,\n+        fail_block: BasicBlock,\n+        source_info: SourceInfo,\n+        op: BinOp,\n+        left: Operand<'tcx>,\n+        right: Operand<'tcx>,\n+    ) {\n         let bool_ty = self.hir.bool_ty();\n-        let result = self.temp(bool_ty, span);\n+        let result = self.temp(bool_ty, source_info.span);\n \n         // result = op(left, right)\n-        let source_info = self.source_info(span);\n-        self.cfg.push_assign(block, source_info, &result,\n-                             Rvalue::BinaryOp(op, left, right));\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            &result,\n+            Rvalue::BinaryOp(op, left, right),\n+        );\n \n         // branch based on result\n-        let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, source_info,\n-                           TerminatorKind::if_(self.hir.tcx(), Operand::Move(result),\n-                                               target_block, fail_block));\n-        target_block\n+        self.cfg.terminate(\n+            block,\n+            source_info,\n+            TerminatorKind::if_(\n+                self.hir.tcx(),\n+                Operand::Move(result),\n+                success_block,\n+                fail_block,\n+            ),\n+        );\n+    }\n+\n+    /// Compare two `&T` values using `<T as std::compare::PartialEq>::eq`\n+    fn non_scalar_compare(\n+        &mut self,\n+        block: BasicBlock,\n+        make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n+        source_info: SourceInfo,\n+        value: &'tcx ty::Const<'tcx>,\n+        place: &Place<'tcx>,\n+        mut ty: Ty<'tcx>,\n+    ) {\n+        use rustc::middle::lang_items::EqTraitLangItem;\n+\n+        let mut expect = self.literal_operand(source_info.span, value.ty, value);\n+        let mut val = Operand::Copy(place.clone());\n+\n+        // If we're using `b\"...\"` as a pattern, we need to insert an\n+        // unsizing coercion, as the byte string has the type `&[u8; N]`.\n+        //\n+        // We want to do this even when the scrutinee is a reference to an\n+        // array, so we can call `<[u8]>::eq` rather than having to find an\n+        // `<[u8; N]>::eq`.\n+        let unsize = |ty: Ty<'tcx>| match ty.sty {\n+            ty::Ref(region, rty, _) => match rty.sty {\n+                ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let opt_ref_ty = unsize(ty);\n+        let opt_ref_test_ty = unsize(value.ty);\n+        match (opt_ref_ty, opt_ref_test_ty) {\n+            // nothing to do, neither is an array\n+            (None, None) => {},\n+            (Some((region, elem_ty, _)), _) |\n+            (None, Some((region, elem_ty, _))) => {\n+                let tcx = self.hir.tcx();\n+                // make both a slice\n+                ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                if opt_ref_ty.is_some() {\n+                    let temp = self.temp(ty, source_info.span);\n+                    self.cfg.push_assign(\n+                        block, source_info, &temp, Rvalue::Cast(\n+                            CastKind::Pointer(PointerCast::Unsize), val, ty\n+                        )\n+                    );\n+                    val = Operand::Move(temp);\n+                }\n+                if opt_ref_test_ty.is_some() {\n+                    let slice = self.temp(ty, source_info.span);\n+                    self.cfg.push_assign(\n+                        block, source_info, &slice, Rvalue::Cast(\n+                            CastKind::Pointer(PointerCast::Unsize), expect, ty\n+                        )\n+                    );\n+                    expect = Operand::Move(slice);\n+                }\n+            },\n+        }\n+\n+        let deref_ty = match ty.sty {\n+            ty::Ref(_, deref_ty, _) => deref_ty,\n+            _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n+        };\n+\n+        let eq_def_id = self.hir.tcx().require_lang_item(EqTraitLangItem);\n+        let (mty, method) = self.hir.trait_method(eq_def_id, sym::eq, deref_ty, &[deref_ty.into()]);\n+\n+        let bool_ty = self.hir.bool_ty();\n+        let eq_result = self.temp(bool_ty, source_info.span);\n+        let eq_block = self.cfg.start_new_block();\n+        let cleanup = self.diverge_cleanup();\n+        self.cfg.terminate(block, source_info, TerminatorKind::Call {\n+            func: Operand::Constant(box Constant {\n+                span: source_info.span,\n+                ty: mty,\n+\n+                // FIXME(#54571): This constant comes from user input (a\n+                // constant in a pattern).  Are there forms where users can add\n+                // type annotations here?  For example, an associated constant?\n+                // Need to experiment.\n+                user_ty: None,\n+\n+                literal: method,\n+            }),\n+            args: vec![val, expect],\n+            destination: Some((eq_result.clone(), eq_block)),\n+            cleanup: Some(cleanup),\n+            from_hir_call: false,\n+        });\n+\n+        if let [success_block, fail_block] = *make_target_blocks(self) {\n+            // check the result\n+            self.cfg.terminate(\n+                eq_block,\n+                source_info,\n+                TerminatorKind::if_(\n+                    self.hir.tcx(),\n+                    Operand::Move(eq_result),\n+                    success_block,\n+                    fail_block,\n+                ),\n+            );\n+        } else {\n+            bug!(\"`TestKind::Eq` should have two target blocks\")\n+        }\n     }\n \n     /// Given that we are performing `test` against `test_place`, this job\n@@ -755,6 +800,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n }\n \n+impl Test<'_> {\n+    pub(super) fn targets(&self) -> usize {\n+        match self.kind {\n+            TestKind::Eq { .. } | TestKind::Range(_) | TestKind::Len { .. } => {\n+                2\n+            }\n+            TestKind::Switch { adt_def, .. } => {\n+                // While the switch that we generate doesn't test for all\n+                // variants, we have a target for each variant and the\n+                // otherwise case, and we make sure that all of the cases not\n+                // specified have the same block.\n+                adt_def.variants.len() + 1\n+            }\n+            TestKind::SwitchInt { switch_ty, ref options, .. } => {\n+                if switch_ty.is_bool() {\n+                    // `bool` is special cased in `perform_test` to always\n+                    // branch to two blocks.\n+                    2\n+                } else {\n+                    options.len() + 1\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {\n     ty.is_integral() || ty.is_char() || ty.is_bool()\n }"}, {"sha": "011b3a868883788a5258a2d261e8504074e182d8", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -65,6 +65,39 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   })\n         );\n     }\n+\n+    /// Creates a false edge to `imaginary_target` and a real edge to\n+    /// real_target. If `imaginary_target` is none, or is the same as the real\n+    /// target, a Goto is generated instead to simplify the generated MIR.\n+    pub fn false_edges(\n+        &mut self,\n+        from_block: BasicBlock,\n+        real_target: BasicBlock,\n+        imaginary_target: Option<BasicBlock>,\n+        source_info: SourceInfo,\n+    )  {\n+        match imaginary_target {\n+            Some(target) if target != real_target => {\n+                self.cfg.terminate(\n+                    from_block,\n+                    source_info,\n+                    TerminatorKind::FalseEdges {\n+                        real_target,\n+                        imaginary_target: target,\n+                    },\n+                );\n+            }\n+            _ => {\n+                self.cfg.terminate(\n+                    from_block,\n+                    source_info,\n+                    TerminatorKind::Goto {\n+                        target: real_target\n+                    }\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {"}, {"sha": "3a48f35ad0fe27d4381a7035cb8b109e2a8aceff", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -892,17 +892,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn unreachable_block(&mut self) -> BasicBlock {\n-        match self.cached_unreachable_block {\n-            Some(ub) => ub,\n-            None => {\n-                let ub = self.cfg.start_new_block();\n-                self.cached_unreachable_block = Some(ub);\n-                ub\n-            }\n-        }\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "8c4acd70456b0b49650ae412e01bb3cb0ae6eaa7", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -802,11 +802,9 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n                     self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n                 }\n             }\n-            mir::TerminatorKind::FalseEdges { real_target, ref imaginary_targets } => {\n+            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n                 self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                for target in imaginary_targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n             }\n             mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n                 self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);"}, {"sha": "b6feac392f4832317941ce6ac96ff5dbdf4d8f6c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -167,11 +167,10 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n \n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n-                        method_name: &str,\n+                        method_name: Symbol,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n                         -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n-        let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssocKind::Method && item.ident.name == method_name {"}, {"sha": "f8e3fc2138d1ea7ee35d8f202f3ec5b5cd8d02bd", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -786,11 +786,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             }\n             TerminatorKind::Abort => { }\n             TerminatorKind::Unreachable => { }\n-            TerminatorKind::FalseEdges { ref mut real_target, ref mut imaginary_targets } => {\n+            TerminatorKind::FalseEdges { ref mut real_target, ref mut imaginary_target } => {\n                 *real_target = self.update_target(*real_target);\n-                for target in imaginary_targets {\n-                    *target = self.update_target(*target);\n-                }\n+                *imaginary_target = self.update_target(*imaginary_target);\n             }\n             TerminatorKind::FalseUnwind { real_target: _ , unwind: _ } =>\n                 // see the ordering of passes in the optimized_mir query."}, {"sha": "8a8cc5080a855bb85a5d8072f5e7895425bc55b1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1448,6 +1448,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             StatementKind::Assign(..) => {\n                 self.super_statement(statement, location);\n             }\n+            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+                self.not_const();\n+            }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |\n             StatementKind::SetDiscriminant { .. } |"}, {"sha": "b84bc31ec2ae2df1a4cdccef5f6ce8773860117a", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -211,6 +211,10 @@ fn check_statement(\n             check_rvalue(tcx, body, rval, span)\n         }\n \n+        StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+            Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n+        }\n+\n         StatementKind::FakeRead(_, place) => check_place(place, span),\n \n         // just an assignment"}, {"sha": "c25e65eadddc9772eca9ac0bca5f480bf350881b", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -249,6 +249,7 @@ symbols! {\n         eh_personality,\n         eh_unwind_resume,\n         enable,\n+        eq,\n         err,\n         Err,\n         Equal,"}, {"sha": "145d4ba6b4c5a283ee3e3a6dfa479ef61549596a", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -14,11 +14,11 @@ pub fn exhaustive_match(e: E, unit: ()) {\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: ]\n+// CHECK: [[B]]:\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n-// CHECK: [[B]]:\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n         E::A => unit,"}, {"sha": "87a9cf9490d86add3aa891682a43a18cb0f31f54", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -7,6 +7,7 @@ const fn f(x: usize) -> usize {\n     for i in 0..x {\n         //~^ ERROR E0015\n         //~| ERROR E0019\n+        //~| ERROR E0019\n         //~| ERROR E0080\n         sum += i;\n     }"}, {"sha": "0d6906086e9b1f24563b123336004502bda38846", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -4,5 +4,6 @@ fn main() {\n     [(); {while true {break}; 0}]; //~ ERROR constant contains unimplemented expression type\n     [(); { for _ in 0usize.. {}; 0}]; //~ ERROR calls in constants are limited to constant functions\n     //~^ ERROR constant contains unimplemented expression type\n+    //~| ERROR constant contains unimplemented expression type\n     //~| ERROR evaluation of constant value failed\n }"}, {"sha": "904d303d87e313527e26e777b9c1cda4e541e700", "filename": "src/test/mir-opt/const_prop/switch_int.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -13,26 +13,26 @@ fn main() {\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      switchInt(_1) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(_1) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.ConstProp.before.mir\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(const 1i32) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.ConstProp.after.mir\n // START rustc.main.SimplifyBranches-after-const-prop.before.mir\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      switchInt(const 1i32) -> [1i32: bb1, otherwise: bb2];\n+//      switchInt(const 1i32) -> [1i32: bb2, otherwise: bb1];\n //  }\n // END rustc.main.SimplifyBranches-after-const-prop.before.mir\n // START rustc.main.SimplifyBranches-after-const-prop.after.mir\n //  bb0: {\n //      ...\n //      _1 = const 1i32;\n-//      goto -> bb1;\n+//      goto -> bb2;\n //  }\n // END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "b39ad1bef8e348aa1ad1da61c7ca15c7c9d7bd55", "filename": "src/test/mir-opt/deaggregator_test_enum_2.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -21,36 +21,36 @@ fn main() {\n // END RUST SOURCE\n // START rustc.test1.Deaggregator.before.mir\n //  bb1: {\n-//      StorageLive(_4);\n-//      _4 = _2;\n-//      _0 = Foo::A(move _4,);\n-//      StorageDead(_4);\n-//      goto -> bb3;\n-//  }\n-//  bb2: {\n //      StorageLive(_5);\n //      _5 = _2;\n //      _0 = Foo::B(move _5,);\n //      StorageDead(_5);\n //      goto -> bb3;\n //  }\n-// END rustc.test1.Deaggregator.before.mir\n-// START rustc.test1.Deaggregator.after.mir\n-//  bb1: {\n+//  bb2: {\n //      StorageLive(_4);\n //      _4 = _2;\n-//      ((_0 as A).0: i32) = move _4;\n-//      discriminant(_0) = 0;\n+//      _0 = Foo::A(move _4,);\n //      StorageDead(_4);\n //      goto -> bb3;\n //  }\n-//  bb2: {\n+// END rustc.test1.Deaggregator.before.mir\n+// START rustc.test1.Deaggregator.after.mir\n+//  bb1: {\n //      StorageLive(_5);\n //      _5 = _2;\n //      ((_0 as B).0: i32) = move _5;\n //      discriminant(_0) = 1;\n //      StorageDead(_5);\n //      goto -> bb3;\n //  }\n+//  bb2: {\n+//      StorageLive(_4);\n+//      _4 = _2;\n+//      ((_0 as A).0: i32) = move _4;\n+//      discriminant(_0) = 0;\n+//      StorageDead(_4);\n+//      goto -> bb3;\n+//  }\n // END rustc.test1.Deaggregator.after.mir\n //"}, {"sha": "909f9b7b6b79ae4f64108bc566650a92aa128566", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -31,17 +31,17 @@ fn main() {\n //         switchInt(_4) -> [false: bb5, otherwise: bb4];\n //     }\n //     ...\n-//     bb7: {\n-//         _0 = ();\n-//         StorageDead(_4);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n-//     bb8: {\n+//     bb5: {\n //         _3 = ();\n //         StorageDead(_4);\n //         _1 = const true;\n //         _2 = ();\n //         goto -> bb2;\n //     }\n+//     bb6: {\n+//         _0 = ();\n+//         StorageDead(_4);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "9dde6d821f2bc6b53e6384907721a4756a4b4ebf", "filename": "src/test/mir-opt/issue-49232.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fissue-49232.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-49232.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -32,76 +32,58 @@ fn main() {\n //         falseUnwind -> [real: bb3, cleanup: bb4];\n //     }\n //     bb2: {\n-//         goto -> bb20;\n+//         goto -> bb14;\n //     }\n //     bb3: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         _3 = const true;\n //         FakeRead(ForMatchedPlace, _3);\n-//         switchInt(_3) -> [false: bb9, otherwise: bb8];\n+//         switchInt(_3) -> [false: bb5, otherwise: bb6];\n //     }\n //     bb4 (cleanup): {\n //         resume;\n //     }\n //     bb5: {\n-//         falseEdges -> [real: bb11, imaginary: bb6];\n+//         falseEdges -> [real: bb7, imaginary: bb6];\n //     }\n //     bb6: {\n-//         falseEdges -> [real: bb13, imaginary: bb7];\n+//         _0 = ();\n+//         goto -> bb8;\n //     }\n //     bb7: {\n-//         unreachable;\n-//     }\n-//     bb8: {\n-//         goto -> bb6;\n-//     }\n-//     bb9: {\n-//         goto -> bb5;\n-//     }\n-//     bb10: {\n //         _2 = const 4i32;\n-//         goto -> bb18;\n-//     }\n-//     bb11: {\n-//         goto -> bb10;\n-//     }\n-//     bb12: {\n-//         _0 = ();\n-//         goto -> bb14;\n-//     }\n-//     bb13: {\n //         goto -> bb12;\n //     }\n-//     bb14: {\n+//     bb8: {\n //         StorageDead(_3);\n-//         goto -> bb15;\n+//         goto -> bb9;\n //     }\n-//     bb15: {\n+//     bb9: {\n //         StorageDead(_2);\n //         goto -> bb2;\n //     }\n-//     bb16: {\n+//     bb10: {\n //         _4 = ();\n //         unreachable;\n //     }\n-//     bb17: {\n-//         goto -> bb18;\n+//     bb11: {\n+//         goto -> bb12;\n //     }\n-//     bb18: {\n+//     bb12: {\n //         FakeRead(ForLet, _2);\n //         StorageDead(_3);\n //         StorageLive(_6);\n //         _6 = &_2;\n-//         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb19, unwind: bb4];\n+//         _5 = const std::mem::drop::<&i32>(move _6) -> [return: bb13, unwind: bb4];\n //     }\n-//     bb19: {\n+//     bb13: {\n //         StorageDead(_6);\n //         _1 = ();\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }\n-//     bb20: {\n+//     bb14: {\n //         return;\n //     }\n // }"}, {"sha": "68ea60d92787cebb43e91783ebf5e3a59ba228e5", "filename": "src/test/mir-opt/loop_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Floop_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Floop_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -22,20 +22,21 @@ fn main() {\n //        resume;\n //    }\n //    ...\n-//    bb6: { // Entry into the loop\n+//    bb3: { // Entry into the loop\n //        _1 = ();\n //        StorageDead(_2);\n-//        goto -> bb7;\n+//        goto -> bb5;\n //    }\n-//    bb7: { // The loop_block\n-//        falseUnwind -> [real: bb8, cleanup: bb1];\n+//    ...\n+//    bb5: { // The loop_block\n+//        falseUnwind -> [real: bb6, cleanup: bb1];\n //    }\n-//    bb8: { // The loop body (body_block)\n+//    bb6: { // The loop body (body_block)\n //        StorageLive(_6);\n //        _6 = const 1i32;\n //        FakeRead(ForLet, _6);\n //        StorageDead(_6);\n-//        goto -> bb7;\n+//        goto -> bb5;\n //    }\n //    ...\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "a2bc238c68ad9e320697e11575c21fd90f45c966", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 66, "deletions": 84, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -42,55 +42,49 @@ fn main() {\n // let mut _0: i32;\n // let mut _3: &bool;                   // Temp for fake borrow of `items.0`\n // let mut _4: &bool;                   // Temp for fake borrow of `items.1`\n-// let _5: bool;                    // `a` in arm\n-// let _6: &bool;                   // `a` in guard\n-// let _7: std::string::String;     // `s` in arm\n-// let _8: &std::string::String;    // `s` in guard\n+// let _5: bool;                        // `a` in arm\n+// let _6: &bool;                       // `a` in guard\n+// let _7: std::string::String;         // `s` in arm\n+// let _8: &std::string::String;        // `s` in guard\n // let mut _9: bool;                    // `if cond { return 3 } else { a }`\n // let mut _10: bool;                   // `cond`\n // let mut _11: !;                      // `return 3`\n // let mut _12: bool;                   // `if cond { return 3 } else { a }`\n // let mut _13: bool;                   // `cond`\n // let mut _14: !;                      // `return 3`\n-// let _15: bool;                   // `b`\n-// let _16: std::string::String;    // `t`\n+// let _15: bool;                       // `b`\n+// let _16: std::string::String;        // `t`\n // scope 1 {\n // }\n // scope 2 {\n // }\n // bb0: {\n //     FakeRead(ForMatchedPlace, _2);\n-//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb7];\n+//     switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb5];\n // }\n // bb1 (cleanup): {\n //     resume;\n // }\n // bb2: {\n-//     falseEdges -> [real: bb10, imaginary: bb3];\n+//     falseEdges -> [real: bb8, imaginary: bb3];\n // }\n // bb3: {\n-//     falseEdges -> [real: bb21, imaginary: bb4];\n+//     falseEdges -> [real: bb17, imaginary: bb4];\n // }\n // bb4: {\n-//     falseEdges -> [real: bb31, imaginary: bb5];\n+//     falseEdges -> [real: bb25, imaginary: bb26];\n // }\n // bb5: {\n-//     falseEdges -> [real: bb32, imaginary: bb6];\n+//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb6];\n // }\n // bb6: {\n-//     unreachable;\n+//     switchInt((_2.0: bool)) -> [false: bb26, otherwise: bb4];\n // }\n-// bb7: {\n-//     switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb8];\n-// }\n-// bb8: {\n-//     switchInt((_2.0: bool)) -> [false: bb5, otherwise: bb4];\n-// }\n-// bb9: {                               // arm 1\n+// bb7: {                               // arm 1\n //     _0 = const 1i32;\n-//     drop(_7) -> [return: bb29, unwind: bb16];\n+//     drop(_7) -> [return: bb23, unwind: bb13];\n // }\n-// bb10: {                              // guard - first time\n+// bb8: {                               // guard - first time\n //     StorageLive(_6);\n //     _6 = &(_2.1: bool);\n //     StorageLive(_8);\n@@ -101,58 +95,52 @@ fn main() {\n //     StorageLive(_10);\n //     _10 = _1;\n //     FakeRead(ForMatchedPlace, _10);\n-//     switchInt(_10) -> [false: bb12, otherwise: bb11];\n+//     switchInt(_10) -> [false: bb10, otherwise: bb9];\n // }\n-// bb11: {\n-//     falseEdges -> [real: bb14, imaginary: bb12];\n+// bb9: {\n+//     falseEdges -> [real: bb11, imaginary: bb10];\n // }\n-// bb12: {\n-//     falseEdges -> [real: bb18, imaginary: bb13];\n-// }\n-// bb13: {\n-//     unreachable;\n+// bb10: {                              // `else` block - first time\n+//     _9 = (*_6);\n+//     StorageDead(_10);\n+//     FakeRead(ForMatchGuard, _3);\n+//     FakeRead(ForMatchGuard, _4);\n+//     FakeRead(ForGuardBinding, _6);\n+//     FakeRead(ForGuardBinding, _8);\n+//     switchInt(move _9) -> [false: bb16, otherwise: bb15];\n // }\n-// bb14: {                              // `return 3` - first time\n+// bb11: {                              // `return 3` - first time\n //     _0 = const 3i32;\n //     StorageDead(_10);\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb17;\n+//     goto -> bb14;\n // }\n-// bb15: {\n+// bb12: {\n //     return;\n // }\n-// bb16 (cleanup): {\n+// bb13 (cleanup): {\n //     drop(_2) -> bb1;\n // }\n-// bb17: {\n-//     drop(_2) -> [return: bb15, unwind: bb1];\n-// }\n-// bb18: {                              // `else` block - first time\n-//     _9 = (*_6);\n-//     StorageDead(_10);\n-//     FakeRead(ForMatchGuard, _3);\n-//     FakeRead(ForMatchGuard, _4);\n-//     FakeRead(ForGuardBinding, _6);\n-//     FakeRead(ForGuardBinding, _8);\n-//     switchInt(move _9) -> [false: bb20, otherwise: bb19];\n+// bb14: {\n+//     drop(_2) -> [return: bb12, unwind: bb1];\n // }\n-// bb19: {\n+// bb15: {\n //     StorageDead(_9);\n //     StorageLive(_5);\n //     _5 = (_2.1: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb20: {                              // guard otherwise case - first time\n+// bb16: {                              // guard otherwise case - first time\n //     StorageDead(_9);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb7, imaginary: bb3];\n+//     falseEdges -> [real: bb5, imaginary: bb3];\n // }\n-// bb21: {                              // guard - second time\n+// bb17: {                              // guard - second time\n //     StorageLive(_6);\n //     _6 = &(_2.0: bool);\n //     StorageLive(_8);\n@@ -163,80 +151,74 @@ fn main() {\n //     StorageLive(_13);\n //     _13 = _1;\n //     FakeRead(ForMatchedPlace, _13);\n-//     switchInt(_13) -> [false: bb23, otherwise: bb22];\n-// }\n-// bb22: {\n-//     falseEdges -> [real: bb25, imaginary: bb23];\n-// }\n-// bb23: {\n-//     falseEdges -> [real: bb26, imaginary: bb24];\n+//     switchInt(_13) -> [false: bb19, otherwise: bb18];\n // }\n-// bb24: {\n-//     unreachable;\n+// bb18: {\n+//     falseEdges -> [real: bb20, imaginary: bb19];\n // }\n-// bb25: {                              // `return 3` - second time\n-//     _0 = const 3i32;\n-//     StorageDead(_13);\n-//     StorageDead(_12);\n-//     StorageDead(_8);\n-//     StorageDead(_6);\n-//     goto -> bb17;\n-// }\n-// bb26: {                              // `else` block - second time\n+// bb19: {                              // `else` block - second time\n //     _12 = (*_6);\n //     StorageDead(_13);\n //     FakeRead(ForMatchGuard, _3);\n //     FakeRead(ForMatchGuard, _4);\n //     FakeRead(ForGuardBinding, _6);\n //     FakeRead(ForGuardBinding, _8);\n-//     switchInt(move _12) -> [false: bb28, otherwise: bb27];\n+//     switchInt(move _12) -> [false: bb22, otherwise: bb21];\n+// }\n+// bb20: {\n+//     _0 = const 3i32;\n+//     StorageDead(_13);\n+//     StorageDead(_12);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     goto -> bb14;\n // }\n-// bb27: {                              // Guard otherwise case - second time\n+// bb21: {                              // bindings for arm 1\n //     StorageDead(_12);\n //     StorageLive(_5);\n //     _5 = (_2.0: bool);\n //     StorageLive(_7);\n //     _7 = move (_2.2: std::string::String);\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb28: {                              // rest of arm 1\n+// bb22: {                              // Guard otherwise case - second time\n //     StorageDead(_12);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     falseEdges -> [real: bb8, imaginary: bb4];\n+//     falseEdges -> [real: bb6, imaginary: bb4];\n // }\n-// bb29: {\n+// bb23: {                              // rest of arm 1\n //     StorageDead(_7);\n //     StorageDead(_5);\n //     StorageDead(_8);\n //     StorageDead(_6);\n-//     goto -> bb34;\n+//     goto -> bb28;\n // }\n-// bb30: {                              // arm 2\n+// bb24: {                              // arm 2\n //     _0 = const 2i32;\n-//     drop(_16) -> [return: bb33, unwind: bb16];\n+//     drop(_16) -> [return: bb27, unwind: bb13];\n // }\n-// bb31: {                              // bindings for arm 2 - first pattern\n+// bb25: {                              // bindings for arm 2 - first pattern\n //     StorageLive(_15);\n //     _15 = (_2.1: bool);\n //     StorageLive(_16);\n //     _16 = move (_2.2: std::string::String);\n-//     goto -> bb30;\n+//     goto -> bb24;\n // }\n-// bb32: {                              // bindings for arm 2 - first pattern\n+// bb26: {                              // bindings for arm 2 - second pattern\n //     StorageLive(_15);\n //     _15 = (_2.1: bool);\n //     StorageLive(_16);\n //     _16 = move (_2.2: std::string::String);\n-//     goto -> bb30;\n+//     goto -> bb24;\n // }\n-// bb33: {                              // rest of arm 2\n+// bb27: {                              // rest of arm 2\n //     StorageDead(_16);\n //     StorageDead(_15);\n-//     goto -> bb34;\n+//     goto -> bb28;\n // }\n-// bb34: {                              // end of match\n-//     drop(_2) -> [return: bb15, unwind: bb1];\n+// bb28: {\n+//     drop(_2) -> [return: bb12, unwind: bb1];\n // }\n // END rustc.complicated_match.SimplifyCfg-initial.after.mir\n // START rustc.complicated_match.ElaborateDrops.after.mir"}, {"sha": "a62e1b21dd162604abb49b71f6f10befc5de5637", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 58, "deletions": 76, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -45,39 +45,37 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb6];\n+//      switchInt(move _3) -> [0isize: bb4, 1isize: bb2, otherwise: bb5];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n+//      falseEdges -> [real: bb6, imaginary: bb3]; //pre_binding1\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n+//      falseEdges -> [real: bb10, imaginary: bb4]; //pre_binding2\n //  }\n-//  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n+//  bb4: { //pre_binding3 and arm3\n+//      _1 = (const 3i32, const 3i32);\n+//      goto -> bb11;\n //  }\n //  bb5: {\n //      unreachable;\n //  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1 and guard\n+//  bb6: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &(((promoted[0]: std::option::Option<i32>) as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb8, unwind: bb1];\n+//      _7 = const guard() -> [return: bb7, unwind: bb1];\n //  }\n-//  bb8: { // end of guard\n+//  bb7: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _7) -> [false: bb9, otherwise: bb8];\n //  }\n-//  bb9: { // arm1\n+//  bb8: { // arm1\n //      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n@@ -87,28 +85,24 @@ fn main() {\n //      StorageDead(_8);\n //      StorageDead(_5);\n //      StorageDead(_6);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb10: { // to pre_binding2\n+//  bb9: { // to pre_binding2\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      falseEdges -> [real: bb3, imaginary: bb3];\n+//      goto -> bb3;\n //  }\n-//  bb11: { // arm2\n+//  bb10: { // arm2\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n //      StorageDead(_9);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb12: { // arm3\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n-//  }\n-//  bb13: {\n+//  bb11: { // arm3\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();\n@@ -122,39 +116,33 @@ fn main() {\n //      _2 = std::option::Option::<i32>::Some(const 42i32,);\n //      FakeRead(ForMatchedPlace, _2);\n //      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb6];\n+//      switchInt(move _3) -> [0isize: bb3, 1isize: bb2, otherwise: bb4];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3];\n+//      falseEdges -> [real: bb5, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4];\n+//      falseEdges -> [real: bb9, imaginary: bb10];\n //  }\n-//  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5];\n-//  }\n-//  bb5: {\n+//  bb4: { // to arm3 (can skip 2 since this is `Some`)\n //      unreachable;\n //  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1 and guard\n+//  bb5: { // binding1 and guard\n //      StorageLive(_6);\n //      _6 = &((_2 as Some).0: i32);\n //      _4 = &shallow _2;\n //      StorageLive(_7);\n-//      _7 = const guard() -> [return: bb8, unwind: bb1];\n+//      _7 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n-//  bb8: { // end of guard\n+//  bb6: { // end of guard\n //      FakeRead(ForMatchGuard, _4);\n //      FakeRead(ForGuardBinding, _6);\n-//      switchInt(move _7) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _7) -> [false: bb8, otherwise: bb7];\n //  }\n-//  bb9: { // arm1\n+//  bb7: {\n //      StorageDead(_7);\n //      StorageLive(_5);\n //      _5 = ((_2 as Some).0: i32);\n@@ -164,28 +152,28 @@ fn main() {\n //      StorageDead(_8);\n //      StorageDead(_5);\n //      StorageDead(_6);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//  bb8: { // to pre_binding3 (can skip 2 since this is `Some`)\n //      StorageDead(_7);\n //      StorageDead(_6);\n-//      falseEdges -> [real: bb4, imaginary: bb3];\n+//      falseEdges -> [real: bb10, imaginary: bb3];\n //  }\n-//  bb11: { // arm2\n+//  bb9: { // arm2\n //      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb12: { // binding3 and arm3\n+//  bb10: { // binding3 and arm3\n //      StorageLive(_9);\n //      _9 = ((_2 as Some).0: i32);\n //      StorageLive(_10);\n //      _10 = _9;\n //      _1 = (const 2i32, move _10);\n //      StorageDead(_10);\n //      StorageDead(_9);\n-//      goto -> bb13;\n+//      goto -> bb11;\n //  }\n-//  bb13: {\n+//  bb11: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();\n@@ -198,97 +186,91 @@ fn main() {\n //     ...\n //      _2 = std::option::Option::<i32>::Some(const 1i32,);\n //      FakeRead(ForMatchedPlace, _2);\n-//      _3 = discriminant(_2);\n-//      switchInt(move _3) -> [1isize: bb2, otherwise: bb3];\n+//      _4 = discriminant(_2);\n+//      switchInt(move _4) -> [1isize: bb2, otherwise: bb3];\n //  }\n //  bb1 (cleanup): {\n //      resume;\n //  }\n //  bb2: {\n-//      falseEdges -> [real: bb7, imaginary: bb3];\n+//      falseEdges -> [real: bb5, imaginary: bb3];\n //  }\n //  bb3: {\n-//      falseEdges -> [real: bb11, imaginary: bb4];\n+//      falseEdges -> [real: bb9, imaginary: bb4];\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb12, imaginary: bb5];\n+//      falseEdges -> [real: bb10, imaginary: bb14];\n //  }\n //  bb5: {\n-//      falseEdges -> [real: bb16, imaginary: bb6];\n-//  }\n-//  bb6: {\n-//      unreachable;\n-//  }\n-//  bb7: { // binding1: Some(w) if guard()\n //      StorageLive(_7);\n //      _7 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb8, unwind: bb1];\n+//      _8 = const guard() -> [return: bb6, unwind: bb1];\n //  }\n-//  bb8: { //end of guard1\n+//  bb6: { //end of guard1\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _7);\n-//      switchInt(move _8) -> [false: bb10, otherwise: bb9];\n+//      switchInt(move _8) -> [false: bb8, otherwise: bb7];\n //  }\n-//  bb9: {\n+//  bb7: {\n //      StorageDead(_8);\n //      StorageLive(_6);\n //      _6 = ((_2 as Some).0: i32);\n //      _1 = const 1i32;\n //      StorageDead(_6);\n //      StorageDead(_7);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb10: {\n+//  bb8: {\n //      StorageDead(_8);\n //      StorageDead(_7);\n //      falseEdges -> [real: bb3, imaginary: bb3];\n //  }\n-//  bb11: { // binding2 & arm2\n+//  bb9: { // binding2 & arm2\n //      StorageLive(_9);\n //      _9 = _2;\n //      _1 = const 2i32;\n //      StorageDead(_9);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb12: { // binding3: Some(y) if guard2(y)\n+//  bb10: { // binding3: Some(y) if guard2(y)\n //      StorageLive(_11);\n //      _11 = &((_2 as Some).0: i32);\n //      _5 = &shallow _2;\n //      StorageLive(_12);\n //      StorageLive(_13);\n //      _13 = (*_11);\n-//      _12 = const guard2(move _13) -> [return: bb13, unwind: bb1];\n+//      _12 = const guard2(move _13) -> [return: bb11, unwind: bb1];\n //  }\n-//  bb13: { // end of guard2\n+//  bb11: { // end of guard2\n //      StorageDead(_13);\n //      FakeRead(ForMatchGuard, _5);\n //      FakeRead(ForGuardBinding, _11);\n-//      switchInt(move _12) -> [false: bb15, otherwise: bb14];\n+//      switchInt(move _12) -> [false: bb13, otherwise: bb12];\n //  }\n-//  bb14: { // binding4 & arm4\n+//  bb12: { // binding4 & arm4\n //      StorageDead(_12);\n //      StorageLive(_10);\n //      _10 = ((_2 as Some).0: i32);\n //      _1 = const 3i32;\n //      StorageDead(_10);\n //      StorageDead(_11);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb15: {\n+//  bb13: {\n //      StorageDead(_12);\n //      StorageDead(_11);\n-//      falseEdges -> [real: bb5, imaginary: bb5];\n+//      falseEdges -> [real: bb14, imaginary: bb14];\n //  }\n-//  bb16: {\n+//  bb14: {\n //      StorageLive(_14);\n //      _14 = _2;\n //      _1 = const 4i32;\n //      StorageDead(_14);\n-//      goto -> bb17;\n+//      goto -> bb15;\n //  }\n-//  bb17: {\n+//  bb15: {\n //      StorageDead(_2);\n //      StorageDead(_1);\n //      _0 = ();"}, {"sha": "ef60a04d1bdfc69683e45a877611e3f680920076", "filename": "src/test/mir-opt/match_test.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fmatch_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -20,67 +20,61 @@ fn main() {\n // START rustc.main.SimplifyCfg-initial.after.mir\n //    bb0: {\n //        ...\n-//        switchInt(move _4) -> [false: bb6, otherwise: bb7];\n+//        switchInt(move _6) -> [false: bb6, otherwise: bb5];\n //    }\n //    bb1: {\n-//        falseEdges -> [real: bb10, imaginary: bb2];\n+//        falseEdges -> [real: bb9, imaginary: bb2];\n //    }\n //    bb2: {\n-//        falseEdges -> [real: bb13, imaginary: bb3];\n+//        falseEdges -> [real: bb12, imaginary: bb3];\n //    }\n //    bb3: {\n-//        falseEdges -> [real: bb14, imaginary: bb4];\n+//        falseEdges -> [real: bb13, imaginary: bb4];\n //    }\n //    bb4: {\n-//        falseEdges -> [real: bb15, imaginary: bb5];\n+//        _3 = const 3i32;\n+//        goto -> bb14;\n //    }\n //    bb5: {\n-//        unreachable;\n+//        _7 = Lt(_1, const 10i32);\n+//        switchInt(move _7) -> [false: bb6, otherwise: bb1];\n //    }\n //    bb6: {\n-//        _6 = Le(const 10i32, _1);\n-//        switchInt(move _6) -> [false: bb8, otherwise: bb9];\n+//        _4 = Le(const 10i32, _1);\n+//        switchInt(move _4) -> [false: bb8, otherwise: bb7];\n //    }\n //    bb7: {\n-//        _5 = Lt(_1, const 10i32);\n-//        switchInt(move _5) -> [false: bb6, otherwise: bb1];\n+//        _5 = Le(_1, const 20i32);\n+//        switchInt(move _5) -> [false: bb8, otherwise: bb2];\n //    }\n //    bb8: {\n //        switchInt(_1) -> [-1i32: bb3, otherwise: bb4];\n //    }\n //    bb9: {\n-//        _7 = Le(_1, const 20i32);\n-//        switchInt(move _7) -> [false: bb8, otherwise: bb2];\n-//    }\n-//    bb10: {\n //        _8 = &shallow _1;\n //        StorageLive(_9);\n //        _9 = _2;\n //        FakeRead(ForMatchGuard, _8);\n-//        switchInt(move _9) -> [false: bb12, otherwise: bb11];\n+//        switchInt(move _9) -> [false: bb11, otherwise: bb10];\n //    }\n-//    bb11: {\n+//    bb10: {\n //        StorageDead(_9);\n //        _3 = const 0i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb12: {\n+//    bb11: {\n //        StorageDead(_9);\n //        falseEdges -> [real: bb4, imaginary: bb2];\n //    }\n-//    bb13: {\n+//    bb12: {\n //        _3 = const 1i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb14: {\n+//    bb13: {\n //        _3 = const 2i32;\n-//        goto -> bb16;\n+//        goto -> bb14;\n //    }\n-//    bb15: {\n-//        _3 = const 3i32;\n-//        goto -> bb16;\n-//    }\n-//    bb16: {\n+//    bb14: {\n //        _0 = ();\n //        StorageDead(_2);\n //        StorageDead(_1);"}, {"sha": "fa0dbe51c5dc3115ca3ce287f330734bf42ace37", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -22,9 +22,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb6[0..=1]}\n-// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb6[0..=1]}\n-// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb6[0..=1]}\n+// | '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=1]}\n+// | '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=1]}\n+// | '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _2: &'_#3r usize;"}, {"sha": "0f9c6f62c2bd3608555650ef415b3db014af0e6e", "filename": "src/test/mir-opt/remove_fake_borrows.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -19,21 +19,19 @@ fn main() {\n // bb0: {\n //     FakeRead(ForMatchedPlace, _1);\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb5;\n+//     goto -> bb4;\n // }\n // bb2: {\n-//     goto -> bb8;\n+//     _0 = const 1i32;\n+//     goto -> bb7;\n // }\n // bb3: {\n-//     unreachable;\n-// }\n-// bb4: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb5: {\n+// bb4: {\n //     _4 = &shallow _1;\n //     _5 = &shallow ((_1 as Some).0: &'<empty> &'<empty> i32);\n //     _6 = &shallow (*((_1 as Some).0: &'<empty> &'<empty> i32));\n@@ -44,25 +42,21 @@ fn main() {\n //     FakeRead(ForMatchGuard, _5);\n //     FakeRead(ForMatchGuard, _6);\n //     FakeRead(ForMatchGuard, _7);\n-//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n-// bb6: {\n+// bb5: {\n //     StorageDead(_8);\n //     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb7: {\n+// bb6: {\n //     StorageDead(_8);\n //     goto -> bb2;\n // }\n-// bb8: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n-// }\n-// bb9: {\n+// bb7: {\n //     return;\n // }\n-// bb10 (cleanup): {\n+// bb8 (cleanup): {\n //     resume;\n // }\n // END rustc.match_guard.CleanupNonCodegenStatements.before.mir\n@@ -71,21 +65,19 @@ fn main() {\n // bb0: {\n //     nop;\n //     _3 = discriminant(_1);\n-//     switchInt(move _3) -> [1isize: bb4, otherwise: bb2];\n+//     switchInt(move _3) -> [1isize: bb3, otherwise: bb2];\n // }\n // bb1: {\n-//     goto -> bb5;\n+//     goto -> bb4;\n // }\n // bb2: {\n-//     goto -> bb8;\n+//     _0 = const 1i32;\n+//     goto -> bb7;\n // }\n // bb3: {\n-//     unreachable;\n-// }\n-// bb4: {\n //     switchInt((*(*((_1 as Some).0: &'<empty> &'<empty> i32)))) -> [0i32: bb1, otherwise: bb2];\n // }\n-// bb5: {\n+// bb4: {\n //     nop;\n //     nop;\n //     nop;\n@@ -96,25 +88,21 @@ fn main() {\n //     nop;\n //     nop;\n //     nop;\n-//     switchInt(move _8) -> [false: bb7, otherwise: bb6];\n+//     switchInt(move _8) -> [false: bb6, otherwise: bb5];\n // }\n-// bb6: {\n+// bb5: {\n //     StorageDead(_8);\n //     _0 = const 0i32;\n-//     goto -> bb9;\n+//     goto -> bb7;\n // }\n-// bb7: {\n+// bb6: {\n //     StorageDead(_8);\n //     goto -> bb2;\n // }\n-// bb8: {\n-//     _0 = const 1i32;\n-//     goto -> bb9;\n-// }\n-// bb9: {\n+// bb7: {\n //     return;\n // }\n-// bb10 (cleanup): {\n+// bb8 (cleanup): {\n //     resume;\n // }\n // END rustc.match_guard.CleanupNonCodegenStatements.after.mir"}, {"sha": "fc1a3bb1bf453fde84b2b91b76d9d6cb771bc7c6", "filename": "src/test/mir-opt/simple-match.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimple-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimple-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimple-match.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -0,0 +1,39 @@\n+// Test that we don't generate unnecessarily large MIR for very simple matches\n+\n+fn match_bool(x: bool) -> usize {\n+    match x {\n+        true => 10,\n+        _ => 20,\n+    }\n+}\n+\n+fn main() {}\n+\n+\n+// END RUST SOURCE\n+// START rustc.match_bool.mir_map.0.mir\n+// bb0: {\n+//     FakeRead(ForMatchedPlace, _1);\n+//     switchInt(_1) -> [false: bb3, otherwise: bb2];\n+// }\n+// bb1 (cleanup): {\n+//     resume;\n+// }\n+// bb2: {\n+//     falseEdges -> [real: bb4, imaginary: bb3];\n+// }\n+// bb3: {\n+//     _0 = const 20usize;\n+//     goto -> bb5;\n+// }\n+// bb4: {\n+//     _0 = const 10usize;\n+//     goto -> bb5;\n+// }\n+// bb5: {\n+//     goto -> bb6;\n+// }\n+// bb6: {\n+//     return;\n+// }\n+// END rustc.match_bool.mir_map.0.mir"}, {"sha": "471c1df3300f0f7b2f6796e8b49854b27e90a488", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -8,12 +8,12 @@ fn main() {\n // START rustc.main.SimplifyBranches-after-const-prop.before.mir\n // bb0: {\n //     ...\n-//     switchInt(const false) -> [false: bb3, otherwise: bb1];\n+//     switchInt(const false) -> [false: bb1, otherwise: bb2];\n // }\n // END rustc.main.SimplifyBranches-after-const-prop.before.mir\n // START rustc.main.SimplifyBranches-after-const-prop.after.mir\n // bb0: {\n //     ...\n-//     goto -> bb3;\n+//     goto -> bb1;\n // }\n // END rustc.main.SimplifyBranches-after-const-prop.after.mir"}, {"sha": "8624899a0abf25f34a4fc69ab298011ec8792668", "filename": "src/test/mir-opt/simplify_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -9,14 +9,14 @@ fn main() {\n // START rustc.main.SimplifyBranches-after-copy-prop.before.mir\n // bb0: {\n //     ...\n-//     switchInt(const false) -> [false: bb3, otherwise: bb1];\n+//     switchInt(const false) -> [false: bb1, otherwise: bb2];\n // }\n // bb1: {\n // END rustc.main.SimplifyBranches-after-copy-prop.before.mir\n // START rustc.main.SimplifyBranches-after-copy-prop.after.mir\n // bb0: {\n //     ...\n-//     goto -> bb3;\n+//     goto -> bb1;\n // }\n // bb1: {\n // END rustc.main.SimplifyBranches-after-copy-prop.after.mir"}, {"sha": "ca1496a6c8d9b6781357a32ee267ec7e2a52e038", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -2,22 +2,22 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:10:30\n    |\n LL |             1 => { addr.push(&mut x); }\n-   |                    ----      ^^^^^^ second mutable borrow occurs here\n-   |                    |\n-   |                    first borrow later used here\n+   |                              ^^^^^^ second mutable borrow occurs here\n LL |             2 => { addr.push(&mut x); }\n LL |             _ => { addr.push(&mut x); }\n-   |                              ------ first mutable borrow occurs here\n+   |                    ----      ------ first mutable borrow occurs here\n+   |                    |\n+   |                    first borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:11:30\n    |\n-LL |             1 => { addr.push(&mut x); }\n-   |                    ---- first borrow later used here\n LL |             2 => { addr.push(&mut x); }\n    |                              ^^^^^^ second mutable borrow occurs here\n LL |             _ => { addr.push(&mut x); }\n-   |                              ------ first mutable borrow occurs here\n+   |                    ----      ------ first mutable borrow occurs here\n+   |                    |\n+   |                    first borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:12:30"}, {"sha": "50757afaf5651422faf3c5ba7b748200f64a7db9", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -6,6 +6,7 @@ fn main() {\n         match &1 as *const i32 as usize {\n             //~^ ERROR casting pointers to integers in constants\n             //~| NOTE for more information, see\n+            //~| ERROR constant contains unimplemented expression type\n             0 => 42, //~ ERROR constant contains unimplemented expression type\n             //~^ NOTE \"pointer arithmetic or comparison\" needs an rfc before being allowed\n             //~| ERROR evaluation of constant value failed"}, {"sha": "167d5ad8d61fe8d277dbac7d3fb04f8a836728fd", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -8,18 +8,24 @@ LL |         match &1 as *const i32 as usize {\n    = help: add #![feature(const_raw_ptr_to_usize_cast)] to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/match-test-ptr-null.rs:9:13\n+  --> $DIR/match-test-ptr-null.rs:6:15\n+   |\n+LL |         match &1 as *const i32 as usize {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/match-test-ptr-null.rs:10:13\n    |\n LL |             0 => 42,\n    |             ^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/match-test-ptr-null.rs:9:13\n+  --> $DIR/match-test-ptr-null.rs:10:13\n    |\n LL |             0 => 42,\n    |             ^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0019, E0080, E0658.\n For more information about an error, try `rustc --explain E0019`."}, {"sha": "6ed3ac2356243186a78b8f0f73351e9daf38aed1", "filename": "src/test/ui/consts/const-match-pattern-arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1,13 +1,15 @@\n #![allow(warnings)]\n \n const x: bool = match Some(true) {\n+    //~^ ERROR: constant contains unimplemented expression type [E0019]\n     Some(value) => true,\n     //~^ ERROR: constant contains unimplemented expression type [E0019]\n     _ => false\n };\n \n const y: bool = {\n     match Some(true) {\n+    //~^ ERROR: constant contains unimplemented expression type [E0019]\n         Some(value) => true,\n         //~^ ERROR: constant contains unimplemented expression type [E0019]\n         _ => false"}, {"sha": "709b66b7bf016fd1ff9ae238ab7316698acc4f70", "filename": "src/test/ui/consts/const-match-pattern-arm.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-pattern-arm.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1,15 +1,27 @@\n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/const-match-pattern-arm.rs:4:5\n+  --> $DIR/const-match-pattern-arm.rs:3:23\n+   |\n+LL | const x: bool = match Some(true) {\n+   |                       ^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-match-pattern-arm.rs:5:5\n    |\n LL |     Some(value) => true,\n    |     ^^^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/const-match-pattern-arm.rs:11:9\n+  --> $DIR/const-match-pattern-arm.rs:11:11\n+   |\n+LL |     match Some(true) {\n+   |           ^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-match-pattern-arm.rs:13:9\n    |\n LL |         Some(value) => true,\n    |         ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0019`."}, {"sha": "75793c904838d021d8e2ec69e0625613c423c4de", "filename": "src/test/ui/consts/single_variant_match_ice.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -2,20 +2,21 @@ enum Foo {\n     Prob,\n }\n \n-const FOO: u32 = match Foo::Prob {\n-    Foo::Prob => 42, //~ ERROR unimplemented expression type\n+const FOO: u32 = match Foo::Prob { //~ ERROR unimplemented expression type\n+    Foo::Prob => 42,\n };\n \n-const BAR: u32 = match Foo::Prob {\n-    x => 42, //~ ERROR unimplemented expression type\n+const BAR: u32 = match Foo::Prob { //~ ERROR unimplemented expression type\n+    x => 42,\n };\n \n impl Foo {\n     pub const fn as_val(&self) -> u8 {\n         use self::Foo::*;\n \n         match *self {\n-            Prob => 0x1, //~ ERROR loops and conditional expressions are not stable in const fn\n+            //~^ ERROR loops and conditional expressions are not stable in const fn\n+            Prob => 0x1,\n         }\n     }\n }"}, {"sha": "851733726ac0f67131c80ff1f338f95589657ec3", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -1,20 +1,20 @@\n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/single_variant_match_ice.rs:6:5\n+  --> $DIR/single_variant_match_ice.rs:5:24\n    |\n-LL |     Foo::Prob => 42,\n-   |     ^^^^^^^^^\n+LL | const FOO: u32 = match Foo::Prob {\n+   |                        ^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/single_variant_match_ice.rs:10:5\n+  --> $DIR/single_variant_match_ice.rs:9:24\n    |\n-LL |     x => 42,\n-   |     ^\n+LL | const BAR: u32 = match Foo::Prob {\n+   |                        ^^^^^^^^^\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n-  --> $DIR/single_variant_match_ice.rs:18:13\n+  --> $DIR/single_variant_match_ice.rs:17:15\n    |\n-LL |             Prob => 0x1,\n-   |             ^^^^\n+LL |         match *self {\n+   |               ^^^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable"}, {"sha": "aa252efea464ba50b6e495db277c05fe349d5925", "filename": "src/test/ui/issues/issue-46843.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46843.rs?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -4,7 +4,9 @@ fn non_const() -> Thing {\n     Thing::This\n }\n \n-pub const Q: i32 = match non_const() { //~ ERROR E0015\n+pub const Q: i32 = match non_const() {\n+    //~^ ERROR E0015\n+    //~^^ ERROR unimplemented expression type\n     Thing::This => 1, //~ ERROR unimplemented expression type\n     Thing::That => 0\n };"}, {"sha": "92ee154552c68ca0e67f5256fc1b380d61843e41", "filename": "src/test/ui/issues/issue-46843.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46843.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -5,12 +5,18 @@ LL | pub const Q: i32 = match non_const() {\n    |                          ^^^^^^^^^^^\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/issue-46843.rs:8:5\n+  --> $DIR/issue-46843.rs:7:26\n+   |\n+LL | pub const Q: i32 = match non_const() {\n+   |                          ^^^^^^^^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/issue-46843.rs:10:5\n    |\n LL |     Thing::This => 1,\n    |     ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0015, E0019.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "13b6a7bbef3213291cbe82ad79445e3b3a545770", "filename": "src/test/ui/lifetimes/lifetime-errors/liveness-assign-imm-local-notes.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68655029d49d20cadcff849d14b362b6778ce86a/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr?ref=68655029d49d20cadcff849d14b362b6778ce86a", "patch": "@@ -28,16 +28,16 @@ LL |     let x;\n ...\n LL |             x = 1;\n    |             ^^^^^ cannot assign twice to immutable variable\n+LL |         } else {\n+LL |             x = 2;\n+   |             ----- first assignment to `x`\n \n error[E0384]: cannot assign twice to immutable variable `x`\n   --> $DIR/liveness-assign-imm-local-notes.rs:32:13\n    |\n LL |     let x;\n    |         - help: make this binding mutable: `mut x`\n ...\n-LL |             x = 1;\n-   |             ----- first assignment to `x`\n-LL |         } else {\n LL |             x = 2;\n    |             ^^^^^ cannot assign twice to immutable variable\n "}]}