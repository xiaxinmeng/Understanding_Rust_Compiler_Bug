{"sha": "872943c3172619afa275987c4ad3e2041ede9fa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Mjk0M2MzMTcyNjE5YWZhMjc1OTg3YzRhZDNlMjA0MWVkZTlmYTM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-28T06:52:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T10:04:24Z"}, "message": "Improve macro reexports.", "tree": {"sha": "834c54f834381a238cfddc793461650a267ed31f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834c54f834381a238cfddc793461650a267ed31f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/872943c3172619afa275987c4ad3e2041ede9fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/872943c3172619afa275987c4ad3e2041ede9fa3", "html_url": "https://github.com/rust-lang/rust/commit/872943c3172619afa275987c4ad3e2041ede9fa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/872943c3172619afa275987c4ad3e2041ede9fa3/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85f74c0eea3667e85720d6f427709873eb576b49", "url": "https://api.github.com/repos/rust-lang/rust/commits/85f74c0eea3667e85720d6f427709873eb576b49", "html_url": "https://github.com/rust-lang/rust/commit/85f74c0eea3667e85720d6f427709873eb576b49"}], "stats": {"total": 469, "additions": 241, "deletions": 228}, "files": [{"sha": "d3771b1755b1659d5b36c61d908a50981a4ba444", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -34,6 +34,10 @@ impl Idx for CrateNum {\n /// LOCAL_CRATE in their DefId.\n pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n \n+/// Virtual crate for builtin macros\n+// FIXME(jseyfried): this is also used for custom derives until proc-macro crates get `CrateNum`s.\n+pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(!0);\n+\n impl CrateNum {\n     pub fn new(x: usize) -> CrateNum {\n         assert!(x < (u32::MAX as usize));"}, {"sha": "04fcf7e84508e986c4b6c0151a65d39525513062", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -226,4 +226,8 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n+        self.insert_entry(macro_def.id, NotPresent);\n+    }\n }"}, {"sha": "db3c7d0450b3859c9b290e7329857a3c7f2e2955", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -211,6 +211,7 @@ pub trait CrateStore<'tcx> {\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n+    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -382,6 +383,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n+    fn load_macro(&self, did: DefId, sess: &Session) -> ast::MacroDef { bug!(\"load_macro\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -421,22 +423,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub enum LoadedMacros {\n-    MacroRules(Vec<ast::MacroDef>),\n-    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n-}\n-\n-impl LoadedMacros {\n-    pub fn is_proc_macros(&self) -> bool {\n-        match *self {\n-            LoadedMacros::ProcMacros(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros>;\n+                    -> Vec<(ast::Name, SyntaxExtension)>;\n     fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "e53f1a0633b6211c2e43c86d0c28446bdb394154", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 35, "deletions": 82, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -16,7 +16,7 @@ use schema::CrateRoot;\n \n use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{DepKind, LoadedMacros};\n+use rustc::middle::cstore::DepKind;\n use rustc::session::{config, Session};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n@@ -33,11 +33,11 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::parse;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n+use syntax::feature_gate::{self, emit_feature_err};\n use syntax::parse::token::{InternedString, intern};\n-use syntax_pos::{Span, DUMMY_SP, mk_sp};\n+use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n pub struct Library {\n@@ -518,91 +518,49 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn read_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate) -> LoadedMacros {\n-        let root = ekrate.metadata.get_root();\n-        let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut macro_rules = Vec::new();\n-\n-        for def in root.macro_defs.decode(&*ekrate.metadata) {\n-            // NB: Don't use parse::parse_tts_from_source_str because it parses with\n-            // quote_depth > 0.\n-            let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n-                                                          source_name.clone(),\n-                                                          def.body);\n-            let lo = p.span.lo;\n-            let body = match p.parse_all_token_trees() {\n-                Ok(body) => body,\n-                Err(mut err) => {\n-                    err.emit();\n-                    self.sess.abort_if_errors();\n-                    unreachable!();\n-                }\n-            };\n-            let local_span = mk_sp(lo, p.prev_span.hi);\n-\n-            // Mark the attrs as used\n-            for attr in &def.attrs {\n-                attr::mark_used(attr);\n-            }\n-\n-            macro_rules.push(ast::MacroDef {\n-                ident: ast::Ident::with_empty_ctxt(def.name),\n-                id: ast::DUMMY_NODE_ID,\n-                span: local_span,\n-                imported_from: Some(item.ident),\n-                allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n-                attrs: def.attrs,\n-                body: body,\n-            });\n-            self.sess.imported_macro_spans.borrow_mut()\n-                .insert(local_span, (def.name.as_str().to_string(), def.span));\n-        }\n-\n-        if let Some(id) = root.macro_derive_registrar {\n-            let dylib = match ekrate.dylib.clone() {\n-                Some(dylib) => dylib,\n-                None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n-            };\n-            if ekrate.target_only {\n-                let message = format!(\"proc-macro crate is not available for \\\n-                                       triple `{}` (only found {})\",\n-                                      config::host_triple(),\n-                                      self.sess.opts.target_triple);\n-                self.sess.span_fatal(item.span, &message);\n-            }\n-\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(macro_rules.len(), 0);\n-            LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n-        } else {\n-            LoadedMacros::MacroRules(macro_rules)\n-        }\n-    }\n-\n     /// Load custom derive macros.\n     ///\n     /// Note that this is intentionally similar to how we load plugins today,\n     /// but also intentionally separate. Plugins are likely always going to be\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, item: &ast::Item, index: DefIndex, svh: Svh, path: PathBuf)\n-                          -> Vec<(ast::Name, SyntaxExtension)> {\n+    fn load_derive_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate)\n+                          -> Option<Vec<(ast::Name, SyntaxExtension)>> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n \n+        let root = ekrate.metadata.get_root();\n+        let index = match root.macro_derive_registrar {\n+            Some(index) => index,\n+            None => return None,\n+        };\n+        if !self.sess.features.borrow().proc_macro {\n+            let issue = feature_gate::GateIssue::Language;\n+            let msg = \"loading custom derive macro crates is experimentally supported\";\n+            emit_feature_err(&self.sess.parse_sess, \"proc_macro\", item.span, issue, msg);\n+        }\n+\n+        if ekrate.target_only {\n+            let msg = format!(\"proc-macro crate is not available for triple `{}` (only found {})\",\n+                               config::host_triple(), self.sess.opts.target_triple);\n+            self.sess.span_fatal(item.span, &msg);\n+        }\n+        let path = match ekrate.dylib.clone() {\n+            Some(dylib) => dylib,\n+            None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n+        };\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n             Err(err) => self.sess.span_fatal(item.span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&svh, index);\n+        let sym = self.sess.generate_derive_registrar_symbol(&root.hash, index);\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n@@ -632,7 +590,7 @@ impl<'a> CrateLoader<'a> {\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n         mem::forget(lib);\n-        my_registrar.0\n+        Some(my_registrar.0)\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate\n@@ -971,24 +929,23 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     }\n \n     fn process_item(&mut self, item: &ast::Item, definitions: &Definitions, load_macros: bool)\n-                    -> Option<LoadedMacros> {\n+                    -> Vec<(ast::Name, SyntaxExtension)> {\n         match item.node {\n             ast::ItemKind::ExternCrate(_) => {}\n             ast::ItemKind::ForeignMod(ref fm) => {\n                 self.process_foreign_mod(item, fm);\n-                return None;\n+                return Vec::new();\n             }\n-            _ => return None,\n+            _ => return Vec::new(),\n         }\n \n         let info = self.extract_crate_info(item).unwrap();\n-        let loaded_macros = if load_macros {\n+        if load_macros {\n             let ekrate = self.read_extension_crate(item.span, &info);\n-            let loaded_macros = self.read_macros(item, &ekrate);\n \n             // If this is a proc-macro crate, return here to avoid registering.\n-            if loaded_macros.is_proc_macros() {\n-                return Some(loaded_macros);\n+            if let Some(custom_derives) = self.load_derive_macros(item, &ekrate) {\n+                return custom_derives;\n             }\n \n             // Register crate now to avoid double-reading metadata\n@@ -998,11 +955,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n                     self.register_crate(&None, ident, name, item.span, lib, dep_kind);\n                 }\n             }\n-\n-            Some(loaded_macros)\n-        } else {\n-            None\n-        };\n+        }\n \n         let (cnum, ..) = self.resolve_crate(\n             &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n@@ -1016,6 +969,6 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n         self.update_extern_crate(cnum, extern_crate, &mut FxHashSet());\n         self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n-        loaded_macros\n+        Vec::new()\n     }\n }"}, {"sha": "3113bfcb5b45218a7dabda02ffbc1fbedb9b5976", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, Exter\n use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n@@ -30,7 +31,8 @@ use rustc_back::PanicStrategy;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::token;\n+use syntax::parse::{token, new_parser_from_source_str};\n+use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -351,6 +353,43 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n+    fn load_macro(&self, id: DefId, sess: &Session) -> ast::MacroDef {\n+        let (name, def) = self.get_crate_data(id.krate).get_macro(id.index);\n+        let source_name = format!(\"<{} macros>\", name);\n+\n+        // NB: Don't use parse_tts_from_source_str because it parses with quote_depth > 0.\n+        let mut parser = new_parser_from_source_str(&sess.parse_sess, source_name, def.body);\n+\n+        let lo = parser.span.lo;\n+        let body = match parser.parse_all_token_trees() {\n+            Ok(body) => body,\n+            Err(mut err) => {\n+                err.emit();\n+                sess.abort_if_errors();\n+                unreachable!();\n+            }\n+        };\n+        let local_span = mk_sp(lo, parser.prev_span.hi);\n+\n+        // Mark the attrs as used\n+        for attr in &def.attrs {\n+            attr::mark_used(attr);\n+        }\n+\n+        sess.imported_macro_spans.borrow_mut()\n+            .insert(local_span, (def.name.as_str().to_string(), def.span));\n+\n+        ast::MacroDef {\n+            ident: ast::Ident::with_empty_ctxt(def.name),\n+            id: ast::DUMMY_NODE_ID,\n+            span: local_span,\n+            imported_from: None, // FIXME\n+            allow_internal_unstable: attr::contains_name(&def.attrs, \"allow_internal_unstable\"),\n+            attrs: def.attrs,\n+            body: body,\n+        }\n+    }\n+\n     fn maybe_get_item_ast<'a>(&'tcx self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)"}, {"sha": "64a90d56d5561e86456ddbe95ac6064bd3ebc720", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -468,6 +468,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n             EntryKind::Enum => Def::Enum(did),\n+            EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n             EntryKind::Impl(_) |\n@@ -1004,6 +1005,14 @@ impl<'a, 'tcx> CrateMetadata {\n         self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n     }\n \n+    pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n+        let entry = self.entry(id);\n+        match entry.kind {\n+            EntryKind::MacroDef(macro_def) => (self.item_name(&entry), macro_def.decode(self)),\n+            _ => bug!(),\n+        }\n+    }\n+\n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,"}, {"sha": "ac1f2afcb2adbeba5eefcb8476a57011051b98d7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -830,6 +830,34 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             },\n         }\n     }\n+\n+    /// Serialize the text of exported macros\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n+        let def_id = self.tcx.map.local_def_id(macro_def.id);\n+        let macro_def = MacroDef {\n+            name: macro_def.name,\n+            attrs: macro_def.attrs.to_vec(),\n+            span: macro_def.span,\n+            body: ::syntax::print::pprust::tts_to_string(&macro_def.body)\n+        };\n+        Entry {\n+            kind: EntryKind::MacroDef(self.lazy(&macro_def)),\n+            visibility: ty::Visibility::Public,\n+            def_key: self.encode_def_key(def_id),\n+\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+            ty: None,\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -964,6 +992,10 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_ty(self, ty);\n         self.index.encode_info_for_ty(ty);\n     }\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+        let def_id = self.index.tcx.map.local_def_id(macro_def.id);\n+        self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+    }\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n@@ -1043,6 +1075,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_items(&mut visitor);\n+        for macro_def in &krate.exported_macros {\n+            visitor.visit_macro_def(macro_def);\n+        }\n         visitor.index.into_items()\n     }\n \n@@ -1122,19 +1157,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             })\n             .map(|filemap| &**filemap))\n     }\n-\n-    /// Serialize the text of the exported macros\n-    fn encode_macro_defs(&mut self) -> LazySeq<MacroDef> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(tcx.map.krate().exported_macros.iter().map(|def| {\n-            MacroDef {\n-                name: def.name,\n-                attrs: def.attrs.to_vec(),\n-                span: def.span,\n-                body: ::syntax::print::pprust::tts_to_string(&def.body),\n-            }\n-        }))\n-    }\n }\n \n struct ImplVisitor<'a, 'tcx: 'a> {\n@@ -1228,11 +1250,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.encode_codemap();\n         let codemap_bytes = self.position() - i;\n \n-        // Encode macro definitions\n-        i = self.position();\n-        let macro_defs = self.encode_macro_defs();\n-        let macro_defs_bytes = self.position() - i;\n-\n         // Encode the def IDs of impls, for coherence checking.\n         i = self.position();\n         let impls = self.encode_impls();\n@@ -1279,7 +1296,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items_missing: lang_items_missing,\n             native_libraries: native_libraries,\n             codemap: codemap,\n-            macro_defs: macro_defs,\n             impls: impls,\n             reachable_ids: reachable_ids,\n             index: index,\n@@ -1300,7 +1316,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"       lang item bytes: {}\", lang_item_bytes);\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n-            println!(\"       macro def bytes: {}\", macro_defs_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"       reachable bytes: {}\", reachable_bytes);\n             println!(\"            item bytes: {}\", item_bytes);"}, {"sha": "1a74a925454770928ff937df59978be95e5e5e33", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -195,6 +195,7 @@ read_hir!(hir::Item);\n read_hir!(hir::ImplItem);\n read_hir!(hir::TraitItem);\n read_hir!(hir::ForeignItem);\n+read_hir!(hir::MacroDef);\n \n /// Leaks access to a value of type T without any tracking. This is\n /// suitable for ambiguous types like `usize`, which *could* represent"}, {"sha": "d7a5f7ad71544ed42ebc851cdb9594796fc45dec", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -177,7 +177,6 @@ pub struct CrateRoot {\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n-    pub macro_defs: LazySeq<MacroDef>,\n     pub impls: LazySeq<TraitImpls>,\n     pub reachable_ids: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n@@ -241,6 +240,7 @@ pub enum EntryKind<'tcx> {\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n+    MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),"}, {"sha": "0833f85c1f6a201cb0f904123b5b00eb6634a95d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 81, "deletions": 97, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -16,17 +16,15 @@\n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use {Module, ModuleS, ModuleKind};\n+use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use {NameBinding, NameBindingKind, ToNameBinding};\n-use Resolver;\n+use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::{DepKind, LoadedMacros};\n+use rustc::middle::cstore::DepKind;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, BUILTIN_MACROS_CRATE};\n use rustc::ty;\n-use rustc::util::nodemap::FxHashMap;\n \n use std::cell::Cell;\n use std::rc::Rc;\n@@ -38,10 +36,9 @@ use syntax::parse::token;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n-use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n@@ -227,7 +224,7 @@ impl<'b> Resolver<'b> {\n                 }\n \n                 let load_macros = legacy_imports != LegacyMacroImports::default();\n-                let loaded_macros =\n+                let proc_macros =\n                     self.crate_loader.process_item(item, &self.definitions, load_macros);\n \n                 // n.b. we don't need to look at the path option here, because cstore already did\n@@ -250,19 +247,25 @@ impl<'b> Resolver<'b> {\n                     self.populate_module_if_necessary(module);\n                     module\n                 } else {\n-                    // Define an empty module\n-                    let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                    let module = ModuleS::new(Some(parent), ModuleKind::Def(def, name));\n-                    let module = self.arenas.alloc_module(module);\n+                    // Define a module and populate it with proc macros.\n+                    let module_kind =\n+                        ModuleKind::Def(Def::Mod(self.definitions.local_def_id(item.id)), name);\n+                    let module = self.arenas.alloc_module(ModuleS::new(None, module_kind));\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n+                    for (name, ext) in proc_macros {\n+                        let def_id = DefId {\n+                            krate: BUILTIN_MACROS_CRATE,\n+                            index: DefIndex::new(self.macro_map.len()),\n+                        };\n+                        self.macro_map.insert(def_id, Rc::new(ext));\n+                        let vis = ty::Visibility::Public;\n+                        self.define(module, name, MacroNS, (Def::Macro(def_id), DUMMY_SP, vis));\n+                    }\n                     module\n                 };\n \n-                if let Some(loaded_macros) = loaded_macros {\n-                    self.import_extern_crate_macros(\n-                        item, module, loaded_macros, legacy_imports, expansion == Mark::root(),\n-                    );\n-                }\n+                let allow_shadowing = expansion == Mark::root();\n+                self.process_legacy_macro_imports(module, legacy_imports, allow_shadowing);\n             }\n \n             ItemKind::Mod(..) if item.ident == keywords::Invalid.ident() => {} // Crate root\n@@ -512,6 +515,31 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n+    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n+        let def_id = match def {\n+            Def::Macro(def_id) => def_id,\n+            _ => panic!(\"Expected Def::Macro(..)\"),\n+        };\n+        if let Some(ext) = self.macro_map.get(&def_id) {\n+            return ext.clone();\n+        }\n+\n+        let mut macro_rules = self.session.cstore.load_macro(def_id, &self.session);\n+        let mark = Mark::fresh();\n+        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n+            def_index: CRATE_DEF_INDEX,\n+            const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        });\n+        self.invocations.insert(mark, invocation);\n+        macro_rules.body = mark_tts(&macro_rules.body, mark);\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_rules));\n+        self.macro_map.insert(def_id, ext.clone());\n+        ext\n+    }\n+\n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n     pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n@@ -522,90 +550,46 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n-    fn import_extern_crate_macros(&mut self,\n-                                  extern_crate: &Item,\n-                                  module: Module<'b>,\n-                                  loaded_macros: LoadedMacros,\n-                                  legacy_imports: LegacyMacroImports,\n-                                  allow_shadowing: bool) {\n-        let import_macro = |this: &mut Self, name, ext: Rc<_>, span| {\n-            this.used_crates.insert(module.def_id().unwrap().krate);\n-            if let SyntaxExtension::NormalTT(..) = *ext {\n-                this.macro_names.insert(name);\n-            }\n-            if this.builtin_macros.insert(name, ext).is_some() && !allow_shadowing {\n-                let msg = format!(\"`{}` is already in scope\", name);\n-                let note =\n-                    \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-                this.session.struct_span_err(span, &msg).note(note).emit();\n-            }\n-        };\n-\n-        match loaded_macros {\n-            LoadedMacros::MacroRules(macros) => {\n-                let mark = Mark::fresh();\n-                if !macros.is_empty() {\n-                    let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-                        module: Cell::new(module),\n-                        def_index: CRATE_DEF_INDEX,\n-                        const_integer: false,\n-                        legacy_scope: Cell::new(LegacyScope::Empty),\n-                        expansion: Cell::new(LegacyScope::Empty),\n-                    });\n-                    self.invocations.insert(mark, invocation);\n-                }\n-\n-                let mut macros: FxHashMap<_, _> = macros.into_iter().map(|mut def| {\n-                    def.body = mark_tts(&def.body, mark);\n-                    let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                    (def.ident.name, (def, Rc::new(ext)))\n-                }).collect();\n+    fn legacy_import_macro(&mut self, name: Name, def: Def, span: Span, allow_shadowing: bool) {\n+        self.used_crates.insert(def.def_id().krate);\n+        self.macro_names.insert(name);\n+        if self.builtin_macros.insert(name, def.def_id()).is_some() && !allow_shadowing {\n+            let msg = format!(\"`{}` is already in scope\", name);\n+            let note =\n+                \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n+            self.session.struct_span_err(span, &msg).note(note).emit();\n+        }\n+    }\n \n-                if let Some(span) = legacy_imports.import_all {\n-                    for (&name, &(_, ref ext)) in macros.iter() {\n-                        import_macro(self, name, ext.clone(), span);\n-                    }\n+    fn process_legacy_macro_imports(&mut self,\n+                                    module: Module<'b>,\n+                                    legacy_imports: LegacyMacroImports,\n+                                    allow_shadowing: bool) {\n+        if let Some(span) = legacy_imports.import_all {\n+            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+            });\n+        } else {\n+            for (name, span) in legacy_imports.imports {\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                if let Success(binding) = result {\n+                    self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n                 } else {\n-                    for (name, span) in legacy_imports.imports {\n-                        if let Some(&(_, ref ext)) = macros.get(&name) {\n-                            import_macro(self, name, ext.clone(), span);\n-                        } else {\n-                            span_err!(self.session, span, E0469, \"imported macro not found\");\n-                        }\n-                    }\n-                }\n-                for (name, span) in legacy_imports.reexports {\n-                    if let Some((mut def, _)) = macros.remove(&name) {\n-                        def.id = self.next_node_id();\n-                        self.exported_macros.push(def);\n-                    } else {\n-                        span_err!(self.session, span, E0470, \"reexported macro not found\");\n-                    }\n+                    span_err!(self.session, span, E0469, \"imported macro not found\");\n                 }\n             }\n-\n-            LoadedMacros::ProcMacros(macros) => {\n-                if !self.session.features.borrow().proc_macro {\n-                    let sess = &self.session.parse_sess;\n-                    let issue = feature_gate::GateIssue::Language;\n-                    let msg =\n-                        \"loading custom derive macro crates is experimentally supported\";\n-                    emit_feature_err(sess, \"proc_macro\", extern_crate.span, issue, msg);\n-                }\n-                if !legacy_imports.imports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be selectively imported from, \\\n-                               must use `#[macro_use]`\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if !legacy_imports.reexports.is_empty() {\n-                    let msg = \"`proc-macro` crates cannot be reexported from\";\n-                    self.session.span_err(extern_crate.span, msg);\n-                }\n-                if let Some(span) = legacy_imports.import_all {\n-                    for (name, ext) in macros {\n-                        import_macro(self, name, Rc::new(ext), span);\n-                    }\n+        }\n+        for (name, span) in legacy_imports.reexports {\n+            self.used_crates.insert(module.def_id().unwrap().krate);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            if let Success(binding) = result {\n+                let def = binding.def();\n+                if let Def::Macro(DefId { krate: BUILTIN_MACROS_CRATE, .. }) = def {\n+                    self.session.span_err(span, \"`proc-macro` crates cannot be reexported from\");\n                 }\n+                self.macro_exports.push(Export { name: name, def: def });\n+            } else {\n+                span_err!(self.session, span, E0470, \"reexported macro not found\");\n             }\n         }\n     }"}, {"sha": "fe90cd34687c017aa3b5bba18e550d4a7a96f807", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -1111,8 +1111,10 @@ pub struct Resolver<'a> {\n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, Rc<SyntaxExtension>>,\n+    builtin_macros: FxHashMap<Name, DefId>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n+    macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_exports: Vec<Export>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1305,6 +1307,8 @@ impl<'a> Resolver<'a> {\n             macro_names: FxHashSet(),\n             builtin_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n+            macro_map: FxHashMap(),\n+            macro_exports: Vec::new(),\n             invocations: invocations,\n         }\n     }\n@@ -1323,13 +1327,6 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        // Collect `DefId`s for exported macro defs.\n-        for def in &krate.exported_macros {\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(def)\n-            })\n-        }\n-\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n "}, {"sha": "f9d91e3aa63fdb0faf3f18395e9dd46b2f317265", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -10,7 +10,8 @@\n \n use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n+use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n use std::cell::Cell;\n use std::rc::Rc;\n@@ -23,6 +24,7 @@ use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::Visitor;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -128,6 +130,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         if export {\n             def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n             self.exported_macros.push(def);\n         }\n     }\n@@ -136,7 +145,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.builtin_macros.insert(ident.name, ext);\n+        let def_id = DefId {\n+            krate: BUILTIN_MACROS_CRATE,\n+            index: DefIndex::new(self.macro_map.len()),\n+        };\n+        self.macro_map.insert(def_id, ext);\n+        self.builtin_macros.insert(ident.name, def_id);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -147,7 +161,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n             match self.builtin_macros.get(&name) {\n-                Some(ext) => match **ext {\n+                Some(&def_id) => match *self.get_macro(Def::Macro(def_id)) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -226,7 +240,7 @@ impl<'a> Resolver<'a> {\n         if let Some(scope) = possible_time_travel {\n             self.lexical_macro_resolutions.push((name, scope));\n         }\n-        self.builtin_macros.get(&name).cloned()\n+        self.builtin_macros.get(&name).cloned().map(|def_id| self.get_macro(Def::Macro(def_id)))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "5d66caec31b3ed9958883f7ce3bf67eaaf741295", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872943c3172619afa275987c4ad3e2041ede9fa3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=872943c3172619afa275987c4ad3e2041ede9fa3", "patch": "@@ -30,6 +30,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n+use std::mem;\n \n impl<'a> Resolver<'a> {\n     pub fn resolve_imports(&mut self) {\n@@ -772,6 +773,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         *module.globs.borrow_mut() = Vec::new();\n \n         let mut reexports = Vec::new();\n+        if module as *const _ == self.graph_root as *const _ {\n+            reexports = mem::replace(&mut self.macro_exports, Vec::new());\n+        }\n+\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             let binding = match resolution.binding {"}]}