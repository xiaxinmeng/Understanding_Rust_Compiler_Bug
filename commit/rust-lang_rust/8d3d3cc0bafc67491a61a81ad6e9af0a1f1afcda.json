{"sha": "8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "node_id": "C_kwDOAAsO6NoAKDhkM2QzY2MwYmFmYzY3NDkxYTYxYTgxYWQ2ZTlhZjBhMWYxYWZjZGE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-06-18T06:06:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-18T06:06:41Z"}, "message": "Rollup merge of #112667 - compiler-errors:wf-goal-is-clause, r=lcnr\n\nMove WF/ConstEvaluatable goal to clause\n\nIt can show up in a param-env, so I think it needs to be a clause kind.\n\nr? ```@lcnr``` or ```@oli-obk```", "tree": {"sha": "3b75f358e79c6414f3cd8e7d14ddb2092724fe26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b75f358e79c6414f3cd8e7d14ddb2092724fe26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkjp7xCRBK7hj4Ov3rIwAAKZwIAEbv3cy6OC8yLHq2HrEa3PhW\nRoceoPeoFbpnRWq2ftQdMDVeDjZnlnC74Zz3KoElPVPhUiQEkiyiyN1N2ZB1NOg4\nURSnXfsBv9bndXdC9hOfuyaVFko04MQF18Q2GBpF/W41ejiu16sXHdoAfqSOz2iU\n5TeZahr3w1f5zlfDMfvfx6WWZgXA9grqk2Ya2tjhEeCja2NuRK6uEwKPaYJJ1ULH\ndOJeNF+SN78rf3IllYwUm6Hlt/VJRYZhehyQfjoK5udjYvz/VfEzEmMvCrdchYRp\nJ5YVjdY9nxFM2cKjcUhwR7IF0JuM80z4jYlTmhwFnp4Il8swDJURdxDEq6cs88U=\n=iEFD\n-----END PGP SIGNATURE-----\n", "payload": "tree 3b75f358e79c6414f3cd8e7d14ddb2092724fe26\nparent 876f00a65585cce615115ff2e851a03ceb233abf\nparent 4343d360793e428460f69d6df81acf6944d48fe8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1687068401 +0200\ncommitter GitHub <noreply@github.com> 1687068401 +0200\n\nRollup merge of #112667 - compiler-errors:wf-goal-is-clause, r=lcnr\n\nMove WF/ConstEvaluatable goal to clause\n\nIt can show up in a param-env, so I think it needs to be a clause kind.\n\nr? ```@lcnr``` or ```@oli-obk```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "html_url": "https://github.com/rust-lang/rust/commit/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876f00a65585cce615115ff2e851a03ceb233abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/876f00a65585cce615115ff2e851a03ceb233abf", "html_url": "https://github.com/rust-lang/rust/commit/876f00a65585cce615115ff2e851a03ceb233abf"}, {"sha": "4343d360793e428460f69d6df81acf6944d48fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4343d360793e428460f69d6df81acf6944d48fe8", "html_url": "https://github.com/rust-lang/rust/commit/4343d360793e428460f69d6df81acf6944d48fe8"}], "stats": {"total": 1404, "additions": 719, "deletions": 685}, "files": [{"sha": "6ca702cfdfc3edc77e4492cd1ea19c47072b013d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -330,7 +330,8 @@ fn check_opaque_type_well_formed<'tcx>(\n     // Require the hidden type to be well-formed with only the generics of the opaque type.\n     // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n     // hidden type is well formed even without those bounds.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(definition_ty.into())));\n     ocx.register_obligation(Obligation::misc(tcx, definition_span, def_id, param_env, predicate));\n \n     // Check that all obligations are satisfied by the implementation's"}, {"sha": "33f75437478b517ac31766f02368c95b82f28f84", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -1419,9 +1419,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 //\n                 // See #91068 for an example.\n                 self.prove_predicates(\n-                    sig.inputs_and_output\n-                        .iter()\n-                        .map(|ty| ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()))),\n+                    sig.inputs_and_output.iter().map(|ty| {\n+                        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(\n+                            ty.into(),\n+                        )))\n+                    }),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -1850,7 +1852,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                 let array_ty = rvalue.ty(body.local_decls(), tcx);\n                 self.prove_predicate(\n-                    ty::PredicateKind::WellFormed(array_ty.into()),\n+                    ty::PredicateKind::Clause(ty::Clause::WellFormed(array_ty.into())),\n                     Locations::Single(location),\n                     ConstraintCategory::Boring,\n                 );"}, {"sha": "e4eb0e6abd435a5e8f1f8f83bee1748b51e0a52f", "filename": "compiler/rustc_hir_analysis/src/astconv/bounds.rs", "status": "added", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fbounds.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -0,0 +1,583 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_lint_defs::Applicability;\n+use rustc_middle::ty::{self as ty, Ty, TypeVisitableExt};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{ErrorGuaranteed, Span};\n+use rustc_trait_selection::traits;\n+\n+use crate::astconv::{AstConv, ConvertedBinding, ConvertedBindingKind};\n+use crate::bounds::Bounds;\n+use crate::errors::{MultipleRelaxedDefaultBounds, ValueOfAssociatedStructAlreadySpecified};\n+\n+use super::OnlySelfBounds;\n+\n+impl<'tcx> dyn AstConv<'tcx> + '_ {\n+    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n+    pub(crate) fn add_implicitly_sized(\n+        &self,\n+        bounds: &mut Bounds<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n+        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        // Try to find an unbound in bounds.\n+        let mut unbound = None;\n+        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n+            for ab in ast_bounds {\n+                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n+                    if unbound.is_none() {\n+                        unbound = Some(&ptr.trait_ref);\n+                    } else {\n+                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n+                    }\n+                }\n+            }\n+        };\n+        search_bounds(ast_bounds);\n+        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n+            for clause in where_clause {\n+                if let hir::WherePredicate::BoundPredicate(pred) = clause {\n+                    if pred.is_param_bound(self_ty.to_def_id()) {\n+                        search_bounds(pred.bounds);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let sized_def_id = tcx.lang_items().sized_trait();\n+        match (&sized_def_id, unbound) {\n+            (Some(sized_def_id), Some(tpb))\n+                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n+            {\n+                // There was in fact a `?Sized` bound, return without doing anything\n+                return;\n+            }\n+            (_, Some(_)) => {\n+                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n+                tcx.sess.span_warn(\n+                    span,\n+                    \"default bound relaxed for a type parameter, but \\\n+                        this does nothing because the given bound is not \\\n+                        a default; only `?Sized` is supported\",\n+                );\n+                // Otherwise, add implicitly sized if `Sized` is available.\n+            }\n+            _ => {\n+                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n+            }\n+        }\n+        if sized_def_id.is_none() {\n+            // No lang item for `Sized`, so we can't add it as a bound.\n+            return;\n+        }\n+        bounds.push_sized(tcx, self_ty, span);\n+    }\n+\n+    /// This helper takes a *converted* parameter type (`param_ty`)\n+    /// and an *unconverted* list of bounds:\n+    ///\n+    /// ```text\n+    /// fn foo<T: Debug>\n+    ///        ^  ^^^^^ `ast_bounds` parameter, in HIR form\n+    ///        |\n+    ///        `param_ty`, in ty form\n+    /// ```\n+    ///\n+    /// It adds these `ast_bounds` into the `bounds` structure.\n+    ///\n+    /// **A note on binders:** there is an implied binder around\n+    /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n+    /// for more details.\n+    #[instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n+    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: I,\n+        bounds: &mut Bounds<'tcx>,\n+        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+        only_self_bounds: OnlySelfBounds,\n+    ) {\n+        for ast_bound in ast_bounds {\n+            match ast_bound {\n+                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n+                    let (constness, polarity) = match modifier {\n+                        hir::TraitBoundModifier::MaybeConst => {\n+                            (ty::BoundConstness::ConstIfConst, ty::ImplPolarity::Positive)\n+                        }\n+                        hir::TraitBoundModifier::None => {\n+                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Positive)\n+                        }\n+                        hir::TraitBoundModifier::Negative => {\n+                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Negative)\n+                        }\n+                        hir::TraitBoundModifier::Maybe => continue,\n+                    };\n+                    let _ = self.instantiate_poly_trait_ref(\n+                        &poly_trait_ref.trait_ref,\n+                        poly_trait_ref.span,\n+                        constness,\n+                        polarity,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                        only_self_bounds,\n+                    );\n+                }\n+                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n+                    self.instantiate_lang_item_trait_ref(\n+                        lang_item,\n+                        span,\n+                        hir_id,\n+                        args,\n+                        param_ty,\n+                        bounds,\n+                        only_self_bounds,\n+                    );\n+                }\n+                hir::GenericBound::Outlives(lifetime) => {\n+                    let region = self.ast_region_to_region(lifetime, None);\n+                    bounds.push_region_bound(\n+                        self.tcx(),\n+                        ty::Binder::bind_with_vars(\n+                            ty::OutlivesPredicate(param_ty, region),\n+                            bound_vars,\n+                        ),\n+                        lifetime.ident.span,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Translates a list of bounds from the HIR into the `Bounds` data structure.\n+    /// The self-type for the bounds is given by `param_ty`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```ignore (illustrative)\n+    /// fn foo<T: Bar + Baz>() { }\n+    /// //     ^  ^^^^^^^^^ ast_bounds\n+    /// //     param_ty\n+    /// ```\n+    ///\n+    /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n+    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n+    /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n+    ///\n+    /// `span` should be the declaration size of the parameter.\n+    pub(crate) fn compute_bounds(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        only_self_bounds: OnlySelfBounds,\n+    ) -> Bounds<'tcx> {\n+        let mut bounds = Bounds::default();\n+        self.add_bounds(\n+            param_ty,\n+            ast_bounds.iter(),\n+            &mut bounds,\n+            ty::List::empty(),\n+            only_self_bounds,\n+        );\n+        debug!(?bounds);\n+\n+        bounds\n+    }\n+\n+    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n+    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n+    pub(crate) fn compute_bounds_that_match_assoc_item(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        assoc_name: Ident,\n+    ) -> Bounds<'tcx> {\n+        let mut result = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            if let Some(trait_ref) = ast_bound.trait_ref()\n+                && let Some(trait_did) = trait_ref.trait_def_id()\n+                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n+            {\n+                result.push(ast_bound.clone());\n+            }\n+        }\n+\n+        let mut bounds = Bounds::default();\n+        self.add_bounds(\n+            param_ty,\n+            result.iter(),\n+            &mut bounds,\n+            ty::List::empty(),\n+            OnlySelfBounds(true),\n+        );\n+        debug!(?bounds);\n+\n+        bounds\n+    }\n+\n+    /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n+    /// onto `bounds`.\n+    ///\n+    /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n+    /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n+    /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n+    #[instrument(level = \"debug\", skip(self, bounds, speculative, dup_bindings, path_span))]\n+    pub(super) fn add_predicates_for_ast_type_binding(\n+        &self,\n+        hir_ref_id: hir::HirId,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        binding: &ConvertedBinding<'_, 'tcx>,\n+        bounds: &mut Bounds<'tcx>,\n+        speculative: bool,\n+        dup_bindings: &mut FxHashMap<DefId, Span>,\n+        path_span: Span,\n+        constness: ty::BoundConstness,\n+        only_self_bounds: OnlySelfBounds,\n+        polarity: ty::ImplPolarity,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        // Given something like `U: SomeTrait<T = X>`, we want to produce a\n+        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+        // subtle in the event that `T` is defined in a supertrait of\n+        // `SomeTrait`, because in that case we need to upcast.\n+        //\n+        // That is, consider this case:\n+        //\n+        // ```\n+        // trait SubTrait: SuperTrait<i32> { }\n+        // trait SuperTrait<A> { type T; }\n+        //\n+        // ... B: SubTrait<T = foo> ...\n+        // ```\n+        //\n+        // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n+\n+        let tcx = self.tcx();\n+\n+        let return_type_notation =\n+            binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation;\n+\n+        let candidate = if return_type_notation {\n+            if self.trait_defines_associated_item_named(\n+                trait_ref.def_id(),\n+                ty::AssocKind::Fn,\n+                binding.item_name,\n+            ) {\n+                trait_ref\n+            } else {\n+                self.one_bound_for_assoc_method(\n+                    traits::supertraits(tcx, trait_ref),\n+                    trait_ref.print_only_trait_path(),\n+                    binding.item_name,\n+                    path_span,\n+                )?\n+            }\n+        } else if self.trait_defines_associated_item_named(\n+            trait_ref.def_id(),\n+            ty::AssocKind::Type,\n+            binding.item_name,\n+        ) {\n+            // Simple case: X is defined in the current trait.\n+            trait_ref\n+        } else {\n+            // Otherwise, we have to walk through the supertraits to find\n+            // those that do.\n+            self.one_bound_for_assoc_type(\n+                || traits::supertraits(tcx, trait_ref),\n+                trait_ref.skip_binder().print_only_trait_name(),\n+                binding.item_name,\n+                path_span,\n+                match binding.kind {\n+                    ConvertedBindingKind::Equality(term) => Some(term),\n+                    _ => None,\n+                },\n+            )?\n+        };\n+\n+        let (assoc_ident, def_scope) =\n+            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n+\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n+        // of calling `filter_by_name_and_kind`.\n+        let find_item_of_kind = |kind| {\n+            tcx.associated_items(candidate.def_id())\n+                .filter_by_name_unhygienic(assoc_ident.name)\n+                .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n+        };\n+        let assoc_item = if return_type_notation {\n+            find_item_of_kind(ty::AssocKind::Fn)\n+        } else {\n+            find_item_of_kind(ty::AssocKind::Type)\n+                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n+        }\n+        .expect(\"missing associated type\");\n+\n+        if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n+            tcx.sess\n+                .struct_span_err(\n+                    binding.span,\n+                    format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n+                )\n+                .span_label(binding.span, format!(\"private {}\", assoc_item.kind))\n+                .emit();\n+        }\n+        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n+\n+        if !speculative {\n+            dup_bindings\n+                .entry(assoc_item.def_id)\n+                .and_modify(|prev_span| {\n+                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                        span: binding.span,\n+                        prev_span: *prev_span,\n+                        item_name: binding.item_name,\n+                        def_path: tcx.def_path_str(assoc_item.container_id(tcx)),\n+                    });\n+                })\n+                .or_insert(binding.span);\n+        }\n+\n+        let projection_ty = if return_type_notation {\n+            let mut emitted_bad_param_err = false;\n+            // If we have an method return type bound, then we need to substitute\n+            // the method's early bound params with suitable late-bound params.\n+            let mut num_bound_vars = candidate.bound_vars().len();\n+            let substs =\n+                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n+                    let subst = match param.kind {\n+                        ty::GenericParamDefKind::Lifetime => ty::Region::new_late_bound(\n+                            tcx,\n+                            ty::INNERMOST,\n+                            ty::BoundRegion {\n+                                var: ty::BoundVar::from_usize(num_bound_vars),\n+                                kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                            },\n+                        )\n+                        .into(),\n+                        ty::GenericParamDefKind::Type { .. } => {\n+                            if !emitted_bad_param_err {\n+                                tcx.sess.emit_err(\n+                                    crate::errors::ReturnTypeNotationIllegalParam::Type {\n+                                        span: path_span,\n+                                        param_span: tcx.def_span(param.def_id),\n+                                    },\n+                                );\n+                                emitted_bad_param_err = true;\n+                            }\n+                            tcx.mk_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundTy {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into()\n+                        }\n+                        ty::GenericParamDefKind::Const { .. } => {\n+                            if !emitted_bad_param_err {\n+                                tcx.sess.emit_err(\n+                                    crate::errors::ReturnTypeNotationIllegalParam::Const {\n+                                        span: path_span,\n+                                        param_span: tcx.def_span(param.def_id),\n+                                    },\n+                                );\n+                                emitted_bad_param_err = true;\n+                            }\n+                            let ty = tcx\n+                                .type_of(param.def_id)\n+                                .no_bound_vars()\n+                                .expect(\"ct params cannot have early bound vars\");\n+                            tcx.mk_const(\n+                                ty::ConstKind::Bound(\n+                                    ty::INNERMOST,\n+                                    ty::BoundVar::from_usize(num_bound_vars),\n+                                ),\n+                                ty,\n+                            )\n+                            .into()\n+                        }\n+                    };\n+                    num_bound_vars += 1;\n+                    subst\n+                });\n+\n+            // Next, we need to check that the return-type notation is being used on\n+            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n+            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n+            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n+                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                alias_ty\n+            } else {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationOnNonRpitit {\n+                        span: binding.span,\n+                        ty: tcx.liberate_late_bound_regions(assoc_item.def_id, output),\n+                        fn_span: tcx.hir().span_if_local(assoc_item.def_id),\n+                        note: (),\n+                    },\n+                ));\n+            };\n+\n+            // Finally, move the fn return type's bound vars over to account for the early bound\n+            // params (and trait ref's late bound params). This logic is very similar to\n+            // `Predicate::subst_supertrait`, and it's no coincidence why.\n+            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n+            let subst_output = ty::EarlyBinder::bind(shifted_output).subst(tcx, substs);\n+\n+            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n+            ty::Binder::bind_with_vars(subst_output, bound_vars)\n+        } else {\n+            // Include substitutions for generic parameters of associated types\n+            candidate.map_bound(|trait_ref| {\n+                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n+                let item_segment = hir::PathSegment {\n+                    ident,\n+                    hir_id: binding.hir_id,\n+                    res: Res::Err,\n+                    args: Some(binding.gen_args),\n+                    infer_args: false,\n+                };\n+\n+                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n+                    path_span,\n+                    assoc_item.def_id,\n+                    &item_segment,\n+                    trait_ref.substs,\n+                );\n+\n+                debug!(?substs_trait_ref_and_assoc_item);\n+\n+                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n+            })\n+        };\n+\n+        if !speculative {\n+            // Find any late-bound regions declared in `ty` that are not\n+            // declared in the trait-ref or assoc_item. These are not well-formed.\n+            //\n+            // Example:\n+            //\n+            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n+            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n+            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n+                let late_bound_in_trait_ref =\n+                    tcx.collect_constrained_late_bound_regions(&projection_ty);\n+                let late_bound_in_ty =\n+                    tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n+                debug!(?late_bound_in_trait_ref);\n+                debug!(?late_bound_in_ty);\n+\n+                // FIXME: point at the type params that don't have appropriate lifetimes:\n+                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n+                //                         ----  ----     ^^^^^^^\n+                self.validate_late_bound_regions(\n+                    late_bound_in_trait_ref,\n+                    late_bound_in_ty,\n+                    |br_name| {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            binding.span,\n+                            E0582,\n+                            \"binding for associated type `{}` references {}, \\\n+                             which does not appear in the trait input types\",\n+                            binding.item_name,\n+                            br_name\n+                        )\n+                    },\n+                );\n+            }\n+        }\n+\n+        match binding.kind {\n+            ConvertedBindingKind::Equality(..) if return_type_notation => {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationEqualityBound { span: binding.span },\n+                ));\n+            }\n+            ConvertedBindingKind::Equality(mut term) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n+                // the \"projection predicate\" for:\n+                //\n+                // `<T as Iterator>::Item = u32`\n+                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n+                let def_kind = tcx.def_kind(assoc_item_def_id);\n+                match (def_kind, term.unpack()) {\n+                    (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n+                    | (hir::def::DefKind::AssocConst, ty::TermKind::Const(_)) => (),\n+                    (_, _) => {\n+                        let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n+                        let expected = tcx.def_descr(assoc_item_def_id);\n+                        let mut err = tcx.sess.struct_span_err(\n+                            binding.span,\n+                            format!(\"expected {expected} bound, found {got}\"),\n+                        );\n+                        err.span_note(\n+                            tcx.def_span(assoc_item_def_id),\n+                            format!(\"{expected} defined here\"),\n+                        );\n+\n+                        if let hir::def::DefKind::AssocConst = def_kind\n+                          && let Some(t) = term.ty() && (t.is_enum() || t.references_error())\n+                          && tcx.features().associated_const_equality {\n+                            err.span_suggestion(\n+                                binding.span,\n+                                \"if equating a const, try wrapping with braces\",\n+                                format!(\"{} = {{ const }}\", binding.item_name),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                        let reported = err.emit();\n+                        term = match def_kind {\n+                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n+                            hir::def::DefKind::AssocConst => tcx\n+                                .const_error(\n+                                    tcx.type_of(assoc_item_def_id)\n+                                        .subst(tcx, projection_ty.skip_binder().substs),\n+                                    reported,\n+                                )\n+                                .into(),\n+                            _ => unreachable!(),\n+                        };\n+                    }\n+                }\n+                bounds.push_projection_bound(\n+                    tcx,\n+                    projection_ty\n+                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n+                    binding.span,\n+                );\n+            }\n+            ConvertedBindingKind::Constraint(ast_bounds) => {\n+                // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n+                //\n+                // `<T as Iterator>::Item: Debug`\n+                //\n+                // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n+                // parameter to have a skipped binder.\n+                //\n+                // NOTE: If `only_self_bounds` is true, do NOT expand this associated\n+                // type bound into a trait predicate, since we only want to add predicates\n+                // for the `Self` type.\n+                if !only_self_bounds.0 {\n+                    let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n+                    self.add_bounds(\n+                        param_ty,\n+                        ast_bounds.iter(),\n+                        bounds,\n+                        projection_ty.bound_vars(),\n+                        only_self_bounds,\n+                    );\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "d6645b784c4392dc7b0314a83c1c81c0f47f6a09", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 571, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -2,6 +2,7 @@\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n+mod bounds;\n mod errors;\n pub mod generics;\n mod lint;\n@@ -11,8 +12,7 @@ use crate::astconv::generics::{check_generic_arg_count, create_substs_for_generi\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n-    AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n-    TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n+    AmbiguousLifetimeBound, TraitObjectDeclaredWithNoTraits, TypeofReservedKeywordUsed,\n };\n use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n@@ -885,571 +885,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .is_some()\n     }\n \n-    /// Sets `implicitly_sized` to true on `Bounds` if necessary\n-    pub(crate) fn add_implicitly_sized(\n-        &self,\n-        bounds: &mut Bounds<'tcx>,\n-        self_ty: Ty<'tcx>,\n-        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n-        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n-        span: Span,\n-    ) {\n-        let tcx = self.tcx();\n-\n-        // Try to find an unbound in bounds.\n-        let mut unbound = None;\n-        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n-            for ab in ast_bounds {\n-                if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n-                    if unbound.is_none() {\n-                        unbound = Some(&ptr.trait_ref);\n-                    } else {\n-                        tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n-                    }\n-                }\n-            }\n-        };\n-        search_bounds(ast_bounds);\n-        if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n-            for clause in where_clause {\n-                if let hir::WherePredicate::BoundPredicate(pred) = clause {\n-                    if pred.is_param_bound(self_ty.to_def_id()) {\n-                        search_bounds(pred.bounds);\n-                    }\n-                }\n-            }\n-        }\n-\n-        let sized_def_id = tcx.lang_items().sized_trait();\n-        match (&sized_def_id, unbound) {\n-            (Some(sized_def_id), Some(tpb))\n-                if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n-            {\n-                // There was in fact a `?Sized` bound, return without doing anything\n-                return;\n-            }\n-            (_, Some(_)) => {\n-                // There was a `?Trait` bound, but it was not `?Sized`; warn.\n-                tcx.sess.span_warn(\n-                    span,\n-                    \"default bound relaxed for a type parameter, but \\\n-                        this does nothing because the given bound is not \\\n-                        a default; only `?Sized` is supported\",\n-                );\n-                // Otherwise, add implicitly sized if `Sized` is available.\n-            }\n-            _ => {\n-                // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n-            }\n-        }\n-        if sized_def_id.is_none() {\n-            // No lang item for `Sized`, so we can't add it as a bound.\n-            return;\n-        }\n-        bounds.push_sized(tcx, self_ty, span);\n-    }\n-\n-    /// This helper takes a *converted* parameter type (`param_ty`)\n-    /// and an *unconverted* list of bounds:\n-    ///\n-    /// ```text\n-    /// fn foo<T: Debug>\n-    ///        ^  ^^^^^ `ast_bounds` parameter, in HIR form\n-    ///        |\n-    ///        `param_ty`, in ty form\n-    /// ```\n-    ///\n-    /// It adds these `ast_bounds` into the `bounds` structure.\n-    ///\n-    /// **A note on binders:** there is an implied binder around\n-    /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n-    /// for more details.\n-    #[instrument(level = \"debug\", skip(self, ast_bounds, bounds))]\n-    pub(crate) fn add_bounds<'hir, I: Iterator<Item = &'hir hir::GenericBound<'hir>>>(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: I,\n-        bounds: &mut Bounds<'tcx>,\n-        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n-        only_self_bounds: OnlySelfBounds,\n-    ) {\n-        for ast_bound in ast_bounds {\n-            match ast_bound {\n-                hir::GenericBound::Trait(poly_trait_ref, modifier) => {\n-                    let (constness, polarity) = match modifier {\n-                        hir::TraitBoundModifier::MaybeConst => {\n-                            (ty::BoundConstness::ConstIfConst, ty::ImplPolarity::Positive)\n-                        }\n-                        hir::TraitBoundModifier::None => {\n-                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Positive)\n-                        }\n-                        hir::TraitBoundModifier::Negative => {\n-                            (ty::BoundConstness::NotConst, ty::ImplPolarity::Negative)\n-                        }\n-                        hir::TraitBoundModifier::Maybe => continue,\n-                    };\n-                    let _ = self.instantiate_poly_trait_ref(\n-                        &poly_trait_ref.trait_ref,\n-                        poly_trait_ref.span,\n-                        constness,\n-                        polarity,\n-                        param_ty,\n-                        bounds,\n-                        false,\n-                        only_self_bounds,\n-                    );\n-                }\n-                &hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n-                    self.instantiate_lang_item_trait_ref(\n-                        lang_item,\n-                        span,\n-                        hir_id,\n-                        args,\n-                        param_ty,\n-                        bounds,\n-                        only_self_bounds,\n-                    );\n-                }\n-                hir::GenericBound::Outlives(lifetime) => {\n-                    let region = self.ast_region_to_region(lifetime, None);\n-                    bounds.push_region_bound(\n-                        self.tcx(),\n-                        ty::Binder::bind_with_vars(\n-                            ty::OutlivesPredicate(param_ty, region),\n-                            bound_vars,\n-                        ),\n-                        lifetime.ident.span,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Translates a list of bounds from the HIR into the `Bounds` data structure.\n-    /// The self-type for the bounds is given by `param_ty`.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```ignore (illustrative)\n-    /// fn foo<T: Bar + Baz>() { }\n-    /// //     ^  ^^^^^^^^^ ast_bounds\n-    /// //     param_ty\n-    /// ```\n-    ///\n-    /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n-    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n-    /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n-    ///\n-    /// `span` should be the declaration size of the parameter.\n-    pub(crate) fn compute_bounds(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        only_self_bounds: OnlySelfBounds,\n-    ) -> Bounds<'tcx> {\n-        let mut bounds = Bounds::default();\n-        self.add_bounds(\n-            param_ty,\n-            ast_bounds.iter(),\n-            &mut bounds,\n-            ty::List::empty(),\n-            only_self_bounds,\n-        );\n-        debug!(?bounds);\n-\n-        bounds\n-    }\n-\n-    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n-    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n-    pub(crate) fn compute_bounds_that_match_assoc_item(\n-        &self,\n-        param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n-        assoc_name: Ident,\n-    ) -> Bounds<'tcx> {\n-        let mut result = Vec::new();\n-\n-        for ast_bound in ast_bounds {\n-            if let Some(trait_ref) = ast_bound.trait_ref()\n-                && let Some(trait_did) = trait_ref.trait_def_id()\n-                && self.tcx().trait_may_define_assoc_item(trait_did, assoc_name)\n-            {\n-                result.push(ast_bound.clone());\n-            }\n-        }\n-\n-        let mut bounds = Bounds::default();\n-        self.add_bounds(\n-            param_ty,\n-            result.iter(),\n-            &mut bounds,\n-            ty::List::empty(),\n-            OnlySelfBounds(true),\n-        );\n-        debug!(?bounds);\n-\n-        bounds\n-    }\n-\n-    /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n-    /// onto `bounds`.\n-    ///\n-    /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n-    /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n-    /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n-    #[instrument(level = \"debug\", skip(self, bounds, speculative, dup_bindings, path_span))]\n-    fn add_predicates_for_ast_type_binding(\n-        &self,\n-        hir_ref_id: hir::HirId,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        binding: &ConvertedBinding<'_, 'tcx>,\n-        bounds: &mut Bounds<'tcx>,\n-        speculative: bool,\n-        dup_bindings: &mut FxHashMap<DefId, Span>,\n-        path_span: Span,\n-        constness: ty::BoundConstness,\n-        only_self_bounds: OnlySelfBounds,\n-        polarity: ty::ImplPolarity,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        // Given something like `U: SomeTrait<T = X>`, we want to produce a\n-        // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n-        // subtle in the event that `T` is defined in a supertrait of\n-        // `SomeTrait`, because in that case we need to upcast.\n-        //\n-        // That is, consider this case:\n-        //\n-        // ```\n-        // trait SubTrait: SuperTrait<i32> { }\n-        // trait SuperTrait<A> { type T; }\n-        //\n-        // ... B: SubTrait<T = foo> ...\n-        // ```\n-        //\n-        // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n-\n-        let tcx = self.tcx();\n-\n-        let return_type_notation =\n-            binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation;\n-\n-        let candidate = if return_type_notation {\n-            if self.trait_defines_associated_item_named(\n-                trait_ref.def_id(),\n-                ty::AssocKind::Fn,\n-                binding.item_name,\n-            ) {\n-                trait_ref\n-            } else {\n-                self.one_bound_for_assoc_method(\n-                    traits::supertraits(tcx, trait_ref),\n-                    trait_ref.print_only_trait_path(),\n-                    binding.item_name,\n-                    path_span,\n-                )?\n-            }\n-        } else if self.trait_defines_associated_item_named(\n-            trait_ref.def_id(),\n-            ty::AssocKind::Type,\n-            binding.item_name,\n-        ) {\n-            // Simple case: X is defined in the current trait.\n-            trait_ref\n-        } else {\n-            // Otherwise, we have to walk through the supertraits to find\n-            // those that do.\n-            self.one_bound_for_assoc_type(\n-                || traits::supertraits(tcx, trait_ref),\n-                trait_ref.skip_binder().print_only_trait_name(),\n-                binding.item_name,\n-                path_span,\n-                match binding.kind {\n-                    ConvertedBindingKind::Equality(term) => Some(term),\n-                    _ => None,\n-                },\n-            )?\n-        };\n-\n-        let (assoc_ident, def_scope) =\n-            tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n-\n-        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n-        // of calling `filter_by_name_and_kind`.\n-        let find_item_of_kind = |kind| {\n-            tcx.associated_items(candidate.def_id())\n-                .filter_by_name_unhygienic(assoc_ident.name)\n-                .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n-        };\n-        let assoc_item = if return_type_notation {\n-            find_item_of_kind(ty::AssocKind::Fn)\n-        } else {\n-            find_item_of_kind(ty::AssocKind::Type)\n-                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n-        }\n-        .expect(\"missing associated type\");\n-\n-        if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n-            tcx.sess\n-                .struct_span_err(\n-                    binding.span,\n-                    format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n-                )\n-                .span_label(binding.span, format!(\"private {}\", assoc_item.kind))\n-                .emit();\n-        }\n-        tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);\n-\n-        if !speculative {\n-            dup_bindings\n-                .entry(assoc_item.def_id)\n-                .and_modify(|prev_span| {\n-                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n-                        span: binding.span,\n-                        prev_span: *prev_span,\n-                        item_name: binding.item_name,\n-                        def_path: tcx.def_path_str(assoc_item.container_id(tcx)),\n-                    });\n-                })\n-                .or_insert(binding.span);\n-        }\n-\n-        let projection_ty = if return_type_notation {\n-            let mut emitted_bad_param_err = false;\n-            // If we have an method return type bound, then we need to substitute\n-            // the method's early bound params with suitable late-bound params.\n-            let mut num_bound_vars = candidate.bound_vars().len();\n-            let substs =\n-                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n-                    let subst = match param.kind {\n-                        GenericParamDefKind::Lifetime => ty::Region::new_late_bound(\n-                            tcx,\n-                            ty::INNERMOST,\n-                            ty::BoundRegion {\n-                                var: ty::BoundVar::from_usize(num_bound_vars),\n-                                kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n-                            },\n-                        )\n-                        .into(),\n-                        GenericParamDefKind::Type { .. } => {\n-                            if !emitted_bad_param_err {\n-                                tcx.sess.emit_err(\n-                                    crate::errors::ReturnTypeNotationIllegalParam::Type {\n-                                        span: path_span,\n-                                        param_span: tcx.def_span(param.def_id),\n-                                    },\n-                                );\n-                                emitted_bad_param_err = true;\n-                            }\n-                            tcx.mk_bound(\n-                                ty::INNERMOST,\n-                                ty::BoundTy {\n-                                    var: ty::BoundVar::from_usize(num_bound_vars),\n-                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n-                                },\n-                            )\n-                            .into()\n-                        }\n-                        GenericParamDefKind::Const { .. } => {\n-                            if !emitted_bad_param_err {\n-                                tcx.sess.emit_err(\n-                                    crate::errors::ReturnTypeNotationIllegalParam::Const {\n-                                        span: path_span,\n-                                        param_span: tcx.def_span(param.def_id),\n-                                    },\n-                                );\n-                                emitted_bad_param_err = true;\n-                            }\n-                            let ty = tcx\n-                                .type_of(param.def_id)\n-                                .no_bound_vars()\n-                                .expect(\"ct params cannot have early bound vars\");\n-                            tcx.mk_const(\n-                                ty::ConstKind::Bound(\n-                                    ty::INNERMOST,\n-                                    ty::BoundVar::from_usize(num_bound_vars),\n-                                ),\n-                                ty,\n-                            )\n-                            .into()\n-                        }\n-                    };\n-                    num_bound_vars += 1;\n-                    subst\n-                });\n-\n-            // Next, we need to check that the return-type notation is being used on\n-            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n-            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n-            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n-                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n-            {\n-                alias_ty\n-            } else {\n-                return Err(self.tcx().sess.emit_err(\n-                    crate::errors::ReturnTypeNotationOnNonRpitit {\n-                        span: binding.span,\n-                        ty: tcx.liberate_late_bound_regions(assoc_item.def_id, output),\n-                        fn_span: tcx.hir().span_if_local(assoc_item.def_id),\n-                        note: (),\n-                    },\n-                ));\n-            };\n-\n-            // Finally, move the fn return type's bound vars over to account for the early bound\n-            // params (and trait ref's late bound params). This logic is very similar to\n-            // `Predicate::subst_supertrait`, and it's no coincidence why.\n-            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n-            let subst_output = ty::EarlyBinder::bind(shifted_output).subst(tcx, substs);\n-\n-            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n-            ty::Binder::bind_with_vars(subst_output, bound_vars)\n-        } else {\n-            // Include substitutions for generic parameters of associated types\n-            candidate.map_bound(|trait_ref| {\n-                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n-                let item_segment = hir::PathSegment {\n-                    ident,\n-                    hir_id: binding.hir_id,\n-                    res: Res::Err,\n-                    args: Some(binding.gen_args),\n-                    infer_args: false,\n-                };\n-\n-                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n-                    path_span,\n-                    assoc_item.def_id,\n-                    &item_segment,\n-                    trait_ref.substs,\n-                );\n-\n-                debug!(?substs_trait_ref_and_assoc_item);\n-\n-                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n-            })\n-        };\n-\n-        if !speculative {\n-            // Find any late-bound regions declared in `ty` that are not\n-            // declared in the trait-ref or assoc_item. These are not well-formed.\n-            //\n-            // Example:\n-            //\n-            //     for<'a> <T as Iterator>::Item = &'a str // <-- 'a is bad\n-            //     for<'a> <T as FnMut<(&'a u32,)>>::Output = &'a str // <-- 'a is ok\n-            if let ConvertedBindingKind::Equality(ty) = binding.kind {\n-                let late_bound_in_trait_ref =\n-                    tcx.collect_constrained_late_bound_regions(&projection_ty);\n-                let late_bound_in_ty =\n-                    tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n-                debug!(?late_bound_in_trait_ref);\n-                debug!(?late_bound_in_ty);\n-\n-                // FIXME: point at the type params that don't have appropriate lifetimes:\n-                // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n-                //                         ----  ----     ^^^^^^^\n-                self.validate_late_bound_regions(\n-                    late_bound_in_trait_ref,\n-                    late_bound_in_ty,\n-                    |br_name| {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            binding.span,\n-                            E0582,\n-                            \"binding for associated type `{}` references {}, \\\n-                             which does not appear in the trait input types\",\n-                            binding.item_name,\n-                            br_name\n-                        )\n-                    },\n-                );\n-            }\n-        }\n-\n-        match binding.kind {\n-            ConvertedBindingKind::Equality(..) if return_type_notation => {\n-                return Err(self.tcx().sess.emit_err(\n-                    crate::errors::ReturnTypeNotationEqualityBound { span: binding.span },\n-                ));\n-            }\n-            ConvertedBindingKind::Equality(mut term) => {\n-                // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n-                // the \"projection predicate\" for:\n-                //\n-                // `<T as Iterator>::Item = u32`\n-                let assoc_item_def_id = projection_ty.skip_binder().def_id;\n-                let def_kind = tcx.def_kind(assoc_item_def_id);\n-                match (def_kind, term.unpack()) {\n-                    (hir::def::DefKind::AssocTy, ty::TermKind::Ty(_))\n-                    | (hir::def::DefKind::AssocConst, ty::TermKind::Const(_)) => (),\n-                    (_, _) => {\n-                        let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n-                        let expected = tcx.def_descr(assoc_item_def_id);\n-                        let mut err = tcx.sess.struct_span_err(\n-                            binding.span,\n-                            format!(\"expected {expected} bound, found {got}\"),\n-                        );\n-                        err.span_note(\n-                            tcx.def_span(assoc_item_def_id),\n-                            format!(\"{expected} defined here\"),\n-                        );\n-\n-                        if let hir::def::DefKind::AssocConst = def_kind\n-                          && let Some(t) = term.ty() && (t.is_enum() || t.references_error())\n-                          && tcx.features().associated_const_equality {\n-                            err.span_suggestion(\n-                                binding.span,\n-                                \"if equating a const, try wrapping with braces\",\n-                                format!(\"{} = {{ const }}\", binding.item_name),\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                        let reported = err.emit();\n-                        term = match def_kind {\n-                            hir::def::DefKind::AssocTy => tcx.ty_error(reported).into(),\n-                            hir::def::DefKind::AssocConst => tcx\n-                                .const_error(\n-                                    tcx.type_of(assoc_item_def_id)\n-                                        .subst(tcx, projection_ty.skip_binder().substs),\n-                                    reported,\n-                                )\n-                                .into(),\n-                            _ => unreachable!(),\n-                        };\n-                    }\n-                }\n-                bounds.push_projection_bound(\n-                    tcx,\n-                    projection_ty\n-                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n-                    binding.span,\n-                );\n-            }\n-            ConvertedBindingKind::Constraint(ast_bounds) => {\n-                // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n-                //\n-                // `<T as Iterator>::Item: Debug`\n-                //\n-                // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n-                // parameter to have a skipped binder.\n-                //\n-                // NOTE: If `only_self_bounds` is true, do NOT expand this associated\n-                // type bound into a trait predicate, since we only want to add predicates\n-                // for the `Self` type.\n-                if !only_self_bounds.0 {\n-                    let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n-                    self.add_bounds(\n-                        param_ty,\n-                        ast_bounds.iter(),\n-                        bounds,\n-                        projection_ty.bound_vars(),\n-                        only_self_bounds,\n-                    );\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     fn ast_path_to_ty(\n         &self,\n         span: Span,\n@@ -1527,15 +962,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Clause::TypeOutlives(_) => {\n                         // Do nothing, we deal with regions separately\n                     }\n-                    ty::Clause::RegionOutlives(_) | ty::Clause::ConstArgHasType(..) => bug!(),\n+                    ty::Clause::RegionOutlives(_)\n+                    | ty::Clause::ConstArgHasType(..)\n+                    | ty::Clause::WellFormed(_)\n+                    | ty::Clause::ConstEvaluatable(_) => bug!(),\n                 },\n-                ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::AliasRelate(..)\n+                ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(_, _, _)\n                 | ty::PredicateKind::Subtype(_)\n                 | ty::PredicateKind::Coerce(_)\n-                | ty::PredicateKind::ConstEvaluatable(_)\n                 | ty::PredicateKind::ConstEquate(_, _)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(_)\n                 | ty::PredicateKind::Ambiguous => bug!(),"}, {"sha": "c09734d6e6983de46966c710b9b18297b24d0560", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -439,7 +439,8 @@ fn check_opaque_meets_bounds<'tcx>(\n     // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n     // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n     // hidden type is well formed even without those bounds.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_ty.into()));\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(hidden_ty.into())));\n     ocx.register_obligation(Obligation::new(tcx, misc_cause, param_env, predicate));\n \n     // Check that all obligations are satisfied by the implementation's"}, {"sha": "838b212ef878210f0c07a1fe69e840e1acaa15e7", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -321,7 +321,9 @@ fn compare_method_predicate_entailment<'tcx>(\n             infcx.tcx,\n             ObligationCause::dummy(),\n             param_env,\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(\n+                unnormalized_impl_fty.into(),\n+            ))),\n         ));\n     }\n "}, {"sha": "73a7ba005b33017a67fbed6da79ba886202c5c8c", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n             self.tcx(),\n             cause,\n             param_env,\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)),\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(arg))),\n         ));\n     }\n }\n@@ -1032,9 +1032,9 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                     tcx,\n                     cause,\n                     wfcx.param_env,\n-                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n+                    ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(\n                         ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n-                    )),\n+                    ))),\n                 ));\n             }\n         }\n@@ -1876,7 +1876,8 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n             // We lower empty bounds like `Vec<dyn Copy>:` as\n             // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n             // regular WF checking\n-            if let ty::PredicateKind::WellFormed(..) = pred.kind().skip_binder() {\n+            if let ty::PredicateKind::Clause(ty::Clause::WellFormed(..)) = pred.kind().skip_binder()\n+            {\n                 continue;\n             }\n             // Match the existing behavior."}, {"sha": "c67f82968f06a91faa63ca75799a7713ae9211b0", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -219,7 +219,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Gen\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let predicate = ty::Binder::bind_with_vars(\n-                            ty::PredicateKind::WellFormed(ty.into()),\n+                            ty::PredicateKind::Clause(ty::Clause::WellFormed(ty.into())),\n                             bound_vars,\n                         );\n                         predicates.insert((predicate.to_predicate(tcx), span));\n@@ -353,7 +353,7 @@ fn const_evaluatable_predicates_of(\n             if let ty::ConstKind::Unevaluated(_) = ct.kind() {\n                 let span = self.tcx.def_span(c.def_id);\n                 self.preds.insert((\n-                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct))\n+                    ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ct)))\n                         .to_predicate(self.tcx),\n                     span,\n                 ));"}, {"sha": "f2618b3daf1477cd1d284649b705fa4903ce761e", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -79,7 +79,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n                 self.tcx,\n                 cause,\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(tcx_ty.into()),\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(tcx_ty.into())),\n             ));\n \n             for error in ocx.select_all_or_error() {"}, {"sha": "201cb94f0b31969115b479dd6d94ff10ec370fcb", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -542,12 +542,12 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n         | ty::PredicateKind::AliasRelate(..)\n-        | ty::PredicateKind::WellFormed(_)\n+        | ty::PredicateKind::Clause(ty::Clause::WellFormed(_))\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)\n         | ty::PredicateKind::ObjectSafe(_)\n         | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,"}, {"sha": "79c56490f3c1a6cb43709f4a9ebf0e2c70420988", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -55,13 +55,13 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                     | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                    | ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n                     | ty::PredicateKind::AliasRelate(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)\n                     | ty::PredicateKind::Coerce(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                     | ty::PredicateKind::ConstEquate(..)\n                     | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),"}, {"sha": "34f98f4310ee4dec019e7224e96970d784187e2b", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx,\n             cause,\n             self.param_env,\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)),\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(arg))),\n         ));\n     }\n \n@@ -668,10 +668,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::AliasRelate(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..)\n                 // N.B., this predicate is created by breaking down a\n                 // `ClosureType: FnFoo()` predicate, where"}, {"sha": "2135643cbeb932eb1d1868bd56129a2d3ff9cf27", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(arg, ty)) => {\n                 vec![ty.into(), arg.into()]\n             }\n-            ty::PredicateKind::ConstEvaluatable(e) => vec![e.into()],\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(e)) => vec![e.into()],\n             _ => return false,\n         };\n "}, {"sha": "cca97d1051720cb1a129b34d4dfcf4732105d2fc", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tcx,\n             obligation.cause,\n             self.param_env,\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(method_ty.into())),\n+            ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(method_ty.into()))),\n         ));\n \n         let callee = MethodCallee { def_id, substs, sig: fn_sig };"}, {"sha": "91347c01327c3fdc95d9676ca83b5acb2ff46b98", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -838,11 +838,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::AliasRelate(..)"}, {"sha": "66e771b794aad2f6a64965ea8ef2d76d6072e85e", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -696,7 +696,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 // Don't point out the span of `WellFormed` predicates.\n-                if !matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) {\n+                if !matches!(\n+                    p.kind().skip_binder(),\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..) | ty::Clause::Trait(..))\n+                ) {\n                     continue;\n                 };\n "}, {"sha": "152c56572b6914f3f173218368497b64d763be3d", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -417,7 +417,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n                 self.tcx(),\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::Binder::dummy(ty::PredicateKind::WellFormed(b_ty.into())),\n+                ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(b_ty.into()))),\n             ));\n         }\n "}, {"sha": "c1f0b9253a5e8386280d828fd2eb33ccb8f95c39", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -29,11 +29,11 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,"}, {"sha": "5622062ef7ef73c0b3aaac02e96c1f6ceeff000a", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -227,7 +227,7 @@ impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n                 debug!(?data, ?obligations, \"super_predicates\");\n                 self.extend_deduped(obligations);\n             }\n-            ty::PredicateKind::WellFormed(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(..)) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n@@ -249,7 +249,7 @@ impl<'tcx, O: Elaboratable<'tcx>> Elaborator<'tcx, O> {\n             ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::PredicateKind::ConstEvaluatable(..) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..)) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }"}, {"sha": "785adc0b4fb693fa03c9b18474d685ac0fb4e375", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -1610,13 +1610,13 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Clause(Clause::Projection(..)) |\n                     AliasRelate(..) |\n                     // Ignore bounds that a user can't type\n-                    WellFormed(..) |\n+                    Clause(Clause::WellFormed(..)) |\n+                    // FIXME(generic_const_exprs): `ConstEvaluatable` can be written\n+                    Clause(Clause::ConstEvaluatable(..)) |\n                     ObjectSafe(..) |\n                     ClosureKind(..) |\n                     Subtype(..) |\n                     Coerce(..) |\n-                    // FIXME(generic_const_exprs): `ConstEvaluatable` can be written\n-                    ConstEvaluatable(..) |\n                     ConstEquate(..) |\n                     Ambiguous |\n                     TypeWellFormedFromEnv(..) => continue,"}, {"sha": "684af1abdf6f671ccaab5e9ab107f27de895fb07", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -270,14 +270,14 @@ impl FlagComputation {\n                 self.add_alias_ty(projection_ty);\n                 self.add_term(term);\n             }\n-            ty::PredicateKind::WellFormed(arg) => {\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                 self.add_substs(slice::from_ref(&arg));\n             }\n             ty::PredicateKind::ObjectSafe(_def_id) => {}\n             ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(uv)) => {\n                 self.add_const(uv);\n             }\n             ty::PredicateKind::ConstEquate(expected, found) => {"}, {"sha": "e516e843d06c799e85bcdd9d51b5d6bf079f1ca2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -523,7 +523,7 @@ impl<'tcx> Predicate<'tcx> {\n             ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n                 tcx.trait_is_coinductive(data.def_id())\n             }\n-            ty::PredicateKind::WellFormed(_) => true,\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(_)) => true,\n             _ => false,\n         }\n     }\n@@ -536,7 +536,7 @@ impl<'tcx> Predicate<'tcx> {\n     #[inline]\n     pub fn allow_normalization(self) -> bool {\n         match self.kind().skip_binder() {\n-            PredicateKind::WellFormed(_) => false,\n+            PredicateKind::Clause(Clause::WellFormed(_)) => false,\n             PredicateKind::Clause(Clause::Trait(_))\n             | PredicateKind::Clause(Clause::RegionOutlives(_))\n             | PredicateKind::Clause(Clause::TypeOutlives(_))\n@@ -547,7 +547,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(_, _, _)\n             | PredicateKind::Subtype(_)\n             | PredicateKind::Coerce(_)\n-            | PredicateKind::ConstEvaluatable(_)\n+            | PredicateKind::Clause(Clause::ConstEvaluatable(_))\n             | PredicateKind::ConstEquate(_, _)\n             | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(_) => true,\n@@ -584,6 +584,12 @@ pub enum Clause<'tcx> {\n     /// Ensures that a const generic argument to a parameter `const N: u8`\n     /// is of type `u8`.\n     ConstArgHasType(Const<'tcx>, Ty<'tcx>),\n+\n+    /// No syntax: `T` well-formed.\n+    WellFormed(GenericArg<'tcx>),\n+\n+    /// Constant initializer must evaluate successfully.\n+    ConstEvaluatable(ty::Const<'tcx>),\n }\n \n impl<'tcx> Binder<'tcx, Clause<'tcx>> {\n@@ -610,9 +616,6 @@ pub enum PredicateKind<'tcx> {\n     /// Prove a clause\n     Clause(Clause<'tcx>),\n \n-    /// No syntax: `T` well-formed.\n-    WellFormed(GenericArg<'tcx>),\n-\n     /// Trait must be object-safe.\n     ObjectSafe(DefId),\n \n@@ -638,9 +641,6 @@ pub enum PredicateKind<'tcx> {\n     /// logic.\n     Coerce(CoercePredicate<'tcx>),\n \n-    /// Constant initializer must evaluate successfully.\n-    ConstEvaluatable(ty::Const<'tcx>),\n-\n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(Const<'tcx>, Const<'tcx>),\n \n@@ -1324,11 +1324,11 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n-            | PredicateKind::WellFormed(..)\n+            | PredicateKind::Clause(Clause::WellFormed(..))\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::Clause(Clause::TypeOutlives(..))\n-            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::Clause(Clause::ConstEvaluatable(..))\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n@@ -1345,11 +1345,11 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n-            | PredicateKind::WellFormed(..)\n+            | PredicateKind::Clause(Clause::WellFormed(..))\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::Clause(Clause::TypeOutlives(..))\n-            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::Clause(Clause::ConstEvaluatable(..))\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n@@ -1367,10 +1367,10 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n-            | PredicateKind::WellFormed(..)\n+            | PredicateKind::Clause(Clause::WellFormed(..))\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n-            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::Clause(Clause::ConstEvaluatable(..))\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n@@ -1384,10 +1384,8 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n-            | PredicateKind::WellFormed(..)\n             | PredicateKind::ObjectSafe(..)\n             | PredicateKind::ClosureKind(..)\n-            | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n             | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,"}, {"sha": "4bfed74f7054d3115343b0db63a7eb6cebfdc884", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -2877,7 +2877,7 @@ define_print_and_forward_display! {\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n                 p!(\"the constant `\", print(ct), \"` has type `\", print(ty), \"`\")\n             },\n-            ty::PredicateKind::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => p!(print(arg), \" well-formed\"),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")\n             }\n@@ -2886,7 +2886,7 @@ define_print_and_forward_display! {\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind)\n             ),\n-            ty::PredicateKind::ConstEvaluatable(ct) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ct)) => {\n                 p!(\"the constant `\", print(ct), \"` can be evaluated\")\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => {"}, {"sha": "a4a2fec07ec3a403ed67eff10ec00f2127c546f7", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -179,6 +179,10 @@ impl<'tcx> fmt::Debug for ty::Clause<'tcx> {\n             ty::Clause::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::Clause::TypeOutlives(ref pair) => pair.fmt(f),\n             ty::Clause::Projection(ref pair) => pair.fmt(f),\n+            ty::Clause::WellFormed(ref data) => write!(f, \"WellFormed({:?})\", data),\n+            ty::Clause::ConstEvaluatable(ct) => {\n+                write!(f, \"ConstEvaluatable({ct:?})\")\n+            }\n         }\n     }\n }\n@@ -189,16 +193,12 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::Clause(ref a) => a.fmt(f),\n             ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n             ty::PredicateKind::Coerce(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }\n             ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateKind::ConstEvaluatable(ct) => {\n-                write!(f, \"ConstEvaluatable({ct:?})\")\n-            }\n             ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)"}, {"sha": "0809919016852b6f2e0a1b4da7356d11c2733a89", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -182,8 +182,8 @@ where\n                 ct.visit_with(self)?;\n                 ty.visit_with(self)\n             }\n-            ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n-            ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ct)) => ct.visit_with(self),\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => arg.visit_with(self),\n \n             ty::PredicateKind::ObjectSafe(_)\n             | ty::PredicateKind::ClosureKind(_, _, _)"}, {"sha": "8625958ff5a2c4759fedab8e51b4a5c4573b79b5", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -319,14 +319,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                     self.compute_object_safe_goal(trait_def_id)\n                 }\n-                ty::PredicateKind::WellFormed(arg) => {\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                     self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n                 }\n                 ty::PredicateKind::Ambiguous => {\n                     self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n                 }\n                 // FIXME: implement this predicate :)\n-                ty::PredicateKind::ConstEvaluatable(_) => {\n+                ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(_)) => {\n                     self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 ty::PredicateKind::ConstEquate(_, _) => {"}, {"sha": "65c8d9c8f697967a60baacf05b0c44a5c4836e0d", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -119,10 +119,8 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                     )\n                                 }\n                                 ty::PredicateKind::Clause(_)\n-                                | ty::PredicateKind::WellFormed(_)\n                                 | ty::PredicateKind::ObjectSafe(_)\n                                 | ty::PredicateKind::ClosureKind(_, _, _)\n-                                | ty::PredicateKind::ConstEvaluatable(_)\n                                 | ty::PredicateKind::Ambiguous => {\n                                     FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,"}, {"sha": "56fde8cd70cb37fa09e001a09b8f5c082994588b", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -826,14 +826,14 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 // we start out with a `ParamEnv` with no inference variables,\n                 // and these don't correspond to adding any new bounds to\n                 // the `ParamEnv`.\n-                ty::PredicateKind::WellFormed(..)\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 // FIXME(generic_const_exprs): you can absolutely add this as a where clauses\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::Coerce(..) => {}\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"predicate should only exist in the environment: {bound_predicate:?}\")"}, {"sha": "f8789b554b1ad70c89b10b3e571d14876b88654e", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -207,7 +207,7 @@ fn satisfied_from_param_env<'tcx>(\n \n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::ConstEvaluatable(ce) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ce)) => {\n                 let b_ct = tcx.expand_abstract_consts(ce);\n                 let mut v = Visitor { ct, infcx, param_env, single_match };\n                 let _ = b_ct.visit_with(&mut v);"}, {"sha": "398ec28a42638cead2da9708baa048729487f8af", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -1048,7 +1048,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         self.report_closure_error(&obligation, closure_def_id, found_kind, kind)\n                     }\n \n-                    ty::PredicateKind::WellFormed(ty) => {\n+                    ty::PredicateKind::Clause(ty::Clause::WellFormed(ty)) => {\n                         match self.tcx.sess.opts.unstable_opts.trait_solver {\n                             TraitSolver::Classic => {\n                                 // WF predicates cannot themselves make\n@@ -1069,7 +1069,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         }\n                     }\n \n-                    ty::PredicateKind::ConstEvaluatable(..) => {\n+                    ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..)) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -2415,7 +2415,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateKind::WellFormed(arg) => {\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if arg.references_error()\n@@ -2487,7 +2487,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::ConstEvaluatable(data) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(data)) => {\n                 if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n@@ -3325,7 +3325,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n \n         match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::ConstEvaluatable(ct) => {\n+            ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ct)) => {\n                 let ty::ConstKind::Unevaluated(uv) = ct.kind() else {\n                     bug!(\"const evaluatable failed for non-unevaluated const `{ct:?}`\");\n                 };"}, {"sha": "6e4bda3df03e720c739b879bfd8b009d53494c90", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -354,12 +354,12 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::Clause(ty::Clause::WellFormed(_))\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(_)\n                 | ty::PredicateKind::Coerce(_)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..) => {\n                     let pred =\n                         ty::Binder::dummy(infcx.instantiate_binder_with_placeholders(binder));\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::WellFormed(arg) => {\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                     match wf::obligations(\n                         self.selcx.infcx,\n                         obligation.param_env,\n@@ -498,7 +498,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::ConstEvaluatable(uv) => {\n+                ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(uv)) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.selcx.infcx,\n                         uv,"}, {"sha": "8c42df6e012d3ae664f86e402719eb1c3b187028", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -310,15 +310,15 @@ fn predicate_references_self<'tcx>(\n \n         ty::PredicateKind::AliasRelate(..) => bug!(\"`AliasRelate` not allowed as assumption\"),\n \n-        ty::PredicateKind::WellFormed(..)\n+        ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n         | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::Coerce(..)\n         // FIXME(generic_const_exprs): this can mention `Self`\n-        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n@@ -361,11 +361,11 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::Ambiguous"}, {"sha": "7405ca31cdeadf3362a114ea5b965ee6a0860bbf", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -67,7 +67,8 @@ fn relate_mir_and_user_ty<'tcx>(\n     ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n \n     // FIXME(#104764): We should check well-formedness before normalization.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(user_ty.into())));\n     ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n     Ok(())\n }\n@@ -119,7 +120,9 @@ fn relate_mir_and_user_substs<'tcx>(\n         let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n \n         ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(\n+            impl_self_ty.into(),\n+        )));\n         ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n \n@@ -134,7 +137,7 @@ fn relate_mir_and_user_substs<'tcx>(\n     // them?  This would only be relevant if some input\n     // type were ill-formed but did not appear in `ty`,\n     // which...could happen with normalization...\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(ty.into())));\n     ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n     Ok(())\n }"}, {"sha": "8761f4fea6c2c7a335c5819a09a55e218e6d08ef", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -130,14 +130,14 @@ pub fn compute_implied_outlives_bounds_inner<'tcx>(\n                 | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n \n                 // We need to search through *all* WellFormed predicates\n-                ty::PredicateKind::WellFormed(arg) => {\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                     wf_args.push(arg);\n                 }\n "}, {"sha": "ca2ae9b523509a27996bf3f48ce06ceb3f23c9ef", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -674,7 +674,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::WellFormed(arg) => {\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n                     // So, there is a bit going on here. First, `WellFormed` predicates\n                     // are coinductive, like trait predicates with auto traits.\n                     // This means that we need to detect if we have recursively\n@@ -862,7 +862,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::ConstEvaluatable(uv) => {\n+                ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(uv)) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.infcx,\n                         uv,"}, {"sha": "676978fabe4d18a0f5548116c80a753a25e38e08", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -160,11 +160,11 @@ pub fn predicate_obligations<'tcx>(\n             wf.compute(ct.into());\n             wf.compute(ty.into());\n         }\n-        ty::PredicateKind::WellFormed(arg) => {\n+        ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => {\n             wf.compute(arg);\n         }\n \n-        ty::PredicateKind::ConstEvaluatable(ct) => {\n+        ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(ct)) => {\n             wf.compute(ct.into());\n         }\n \n@@ -386,7 +386,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         cause,\n                         depth,\n                         param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)),\n+                        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(arg))),\n                     )\n                 }),\n         );\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         cause.clone(),\n                         depth,\n                         param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(arg)),\n+                        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(arg))),\n                     )\n                 }),\n         );\n@@ -521,8 +521,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 let obligations = self.nominal_obligations(uv.def, uv.substs);\n                                 self.out.extend(obligations);\n \n-                                let predicate =\n-                                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                                let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                    ty::Clause::ConstEvaluatable(ct),\n+                                ));\n                                 let cause = self.cause(traits::WellFormed(None));\n                                 self.out.push(traits::Obligation::with_depth(\n                                     self.tcx(),\n@@ -541,7 +542,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 cause,\n                                 self.recursion_depth,\n                                 self.param_env,\n-                                ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n+                                ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                    ty::Clause::WellFormed(ct.into()),\n+                                )),\n                             ));\n                         }\n                         ty::ConstKind::Expr(_) => {\n@@ -552,8 +555,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             // the future we may allow directly lowering to `ConstKind::Expr` in which case\n                             // we would not be proving bounds we should.\n \n-                            let predicate =\n-                                ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct));\n+                            let predicate = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                                ty::Clause::ConstEvaluatable(ct),\n+                            ));\n                             let cause = self.cause(traits::WellFormed(None));\n                             self.out.push(traits::Obligation::with_depth(\n                                 self.tcx(),\n@@ -784,7 +788,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         cause,\n                         self.recursion_depth,\n                         param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())),\n+                        ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::WellFormed(\n+                            ty.into(),\n+                        ))),\n                     ));\n                 }\n             }\n@@ -969,11 +975,11 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::AliasRelate(..)"}, {"sha": "1d4219bc0c0b1e57e0cfc9aaef456ffc32fa662e", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         predicate.lower_into(interner),\n                     ))\n                 }\n-                ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+                ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => match arg.unpack() {\n                     ty::GenericArgKind::Type(ty) => chalk_ir::DomainGoal::WellFormed(\n                         chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n                     ),\n@@ -137,7 +137,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n@@ -192,7 +192,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(arg)) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind() {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n@@ -231,7 +231,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n             | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n@@ -672,15 +672,15 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => {\n                 Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n-            ty::PredicateKind::WellFormed(_ty) => None,\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(_ty)) => None,\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n@@ -807,7 +807,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n                 ))\n             }\n             ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_predicate)) => None,\n-            ty::PredicateKind::WellFormed(_ty) => None,\n+            ty::PredicateKind::Clause(ty::Clause::WellFormed(_ty)) => None,\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n@@ -816,7 +816,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {"}, {"sha": "7f6d53fe860434299e3fc40840404c9ceef64b85", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -62,12 +62,12 @@ fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n         | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n         | ty::PredicateKind::AliasRelate(..)\n-        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::Clause(ty::Clause::WellFormed(..))\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::Coerce(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,"}, {"sha": "29c11e1f3359da5e85a1810925d0cd2635dedcc5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -344,8 +344,8 @@ pub(crate) fn clean_predicate<'tcx>(\n             Some(clean_projection_predicate(bound_predicate.rebind(pred), cx))\n         }\n         // FIXME(generic_const_exprs): should this do something?\n-        ty::PredicateKind::ConstEvaluatable(..) => None,\n-        ty::PredicateKind::WellFormed(..) => None,\n+        ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..)) => None,\n+        ty::PredicateKind::Clause(ty::Clause::WellFormed(..)) => None,\n         ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n         ty::PredicateKind::Subtype(..)"}, {"sha": "860a489494c88be5af1521775b8469cc93a75bf4", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=8d3d3cc0bafc67491a61a81ad6e9af0a1f1afcda", "patch": "@@ -33,8 +33,8 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: &Msrv)\n                     | ty::Clause::Trait(..)\n                     | ty::Clause::ConstArgHasType(..),\n                 )\n-                | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Clause(ty::Clause::WellFormed(_))\n+                | ty::PredicateKind::Clause(ty::Clause::ConstEvaluatable(..))\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateKind::AliasRelate(..) => panic!(\"alias relate predicate on function: {predicate:#?}\"),"}]}