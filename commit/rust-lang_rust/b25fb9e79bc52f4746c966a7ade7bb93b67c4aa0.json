{"sha": "b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWZiOWU3OWJjNTJmNDc0NmM5NjZhN2FkZTdiYjkzYjY3YzRhYTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-07T07:15:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-07T07:15:29Z"}, "message": "Rollup merge of #69706 - cuviper:subslice-methods, r=Centril\n\nUse subslice patterns in slice methods\n\nFor all of the methods that pick off the first or last element, we can\nuse subslice patterns to implement them directly, rather than relying on\ndeeper indexing function calls. At a minimum, this means the generated\ncode will rely less on inlining for performance, but in some cases it\nalso optimizes better.", "tree": {"sha": "16bec1ee2458b9dfcaeb11e9937d2082df491d0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16bec1ee2458b9dfcaeb11e9937d2082df491d0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeY0oRCRBK7hj4Ov3rIwAAdHIIAKJ+J79Upsaisu1SsXTK9Ya/\nZ2KwFAZv53ko0tt0ZH4paXdGPFon/dggfDU5xG0JL6ZXWwjEBUEO7avqMI5/JPxb\nEwi87kMtsBrPljDUlXs4jWKJjtFN30FvhdQKW1VFK3w5uecd6yyLFdA5hlg57YDb\niLZE6lDsTYJB7MUrYGgbBmZqh/4TVzHg3kgB0HvE8Z1cNp2rjElIDdcQObJT9ywE\nA+Ghc7aYtJZhPl9VYqVP3v1g5C0hGeoykmMmo5anCrDA8/muS/+4qtD6FpkDVgkn\nKjfBHSXXrdsGMbODoTGmeLHSGaXZDHvcRzXNcgsy9r4NWZxo3EHpDu9/rkm2cDU=\n=Ulh7\n-----END PGP SIGNATURE-----\n", "payload": "tree 16bec1ee2458b9dfcaeb11e9937d2082df491d0f\nparent ba1f6cbb00511becb2ab0f99d1e06388ad3dbf95\nparent 53be0ccbc913f05c81f1762fd60512e3f57ab5c7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583565329 +0100\ncommitter GitHub <noreply@github.com> 1583565329 +0100\n\nRollup merge of #69706 - cuviper:subslice-methods, r=Centril\n\nUse subslice patterns in slice methods\n\nFor all of the methods that pick off the first or last element, we can\nuse subslice patterns to implement them directly, rather than relying on\ndeeper indexing function calls. At a minimum, this means the generated\ncode will rely less on inlining for performance, but in some cases it\nalso optimizes better.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0", "html_url": "https://github.com/rust-lang/rust/commit/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1f6cbb00511becb2ab0f99d1e06388ad3dbf95", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1f6cbb00511becb2ab0f99d1e06388ad3dbf95", "html_url": "https://github.com/rust-lang/rust/commit/ba1f6cbb00511becb2ab0f99d1e06388ad3dbf95"}, {"sha": "53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/53be0ccbc913f05c81f1762fd60512e3f57ab5c7", "html_url": "https://github.com/rust-lang/rust/commit/53be0ccbc913f05c81f1762fd60512e3f57ab5c7"}], "stats": {"total": 30, "additions": 8, "deletions": 22}, "files": [{"sha": "0e12e6360da9512363d87f7631939a89161e1024", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b25fb9e79bc52f4746c966a7ade7bb93b67c4aa0", "patch": "@@ -103,7 +103,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first(&self) -> Option<&T> {\n-        self.get(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n@@ -121,7 +121,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n-        self.get_mut(0)\n+        if let [first, ..] = self { Some(first) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -139,7 +139,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n-        if self.is_empty() { None } else { Some((&self[0], &self[1..])) }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -159,12 +159,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            let split = self.split_at_mut(1);\n-            Some((&mut split.0[0], split.1))\n-        }\n+        if let [first, tail @ ..] = self { Some((first, tail)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -182,8 +177,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n-        let len = self.len();\n-        if len == 0 { None } else { Some((&self[len - 1], &self[..(len - 1)])) }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n@@ -203,13 +197,7 @@ impl<T> [T] {\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n-        let len = self.len();\n-        if len == 0 {\n-            None\n-        } else {\n-            let split = self.split_at_mut(len - 1);\n-            Some((&mut split.1[0], split.0))\n-        }\n+        if let [init @ .., last] = self { Some((last, init)) } else { None }\n     }\n \n     /// Returns the last element of the slice, or `None` if it is empty.\n@@ -226,8 +214,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last(&self) -> Option<&T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n@@ -245,8 +232,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n-        let last_idx = self.len().checked_sub(1)?;\n-        self.get_mut(last_idx)\n+        if let [.., last] = self { Some(last) } else { None }\n     }\n \n     /// Returns a reference to an element or subslice depending on the type of"}]}