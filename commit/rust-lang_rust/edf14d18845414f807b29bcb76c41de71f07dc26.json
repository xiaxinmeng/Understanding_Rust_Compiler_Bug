{"sha": "edf14d18845414f807b29bcb76c41de71f07dc26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZjE0ZDE4ODQ1NDE0ZjgwN2IyOWJjYjc2YzQxZGU3MWYwN2RjMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-27T15:16:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-27T15:47:58Z"}, "message": "extract `places_conflict` into its own module", "tree": {"sha": "24ad0ace093c35f1d6f02ff2ce65f023416e5317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ad0ace093c35f1d6f02ff2ce65f023416e5317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edf14d18845414f807b29bcb76c41de71f07dc26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edf14d18845414f807b29bcb76c41de71f07dc26", "html_url": "https://github.com/rust-lang/rust/commit/edf14d18845414f807b29bcb76c41de71f07dc26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edf14d18845414f807b29bcb76c41de71f07dc26/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "142c98dd5a9fbd60c13e62a5c1358a40ee622dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/142c98dd5a9fbd60c13e62a5c1358a40ee622dbb", "html_url": "https://github.com/rust-lang/rust/commit/142c98dd5a9fbd60c13e62a5c1358a40ee622dbb"}], "stats": {"total": 741, "additions": 379, "deletions": 362}, "files": [{"sha": "29cec8867acc472f0f1967762160c90662b60fc7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=edf14d18845414f807b29bcb76c41de71f07dc26", "patch": "@@ -60,6 +60,7 @@ mod flows;\n mod location;\n mod path_utils;\n crate mod place_ext;\n+mod places_conflict;\n mod prefixes;\n mod used_muts;\n \n@@ -1307,7 +1308,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // that is merged.\n         let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n-        if places_conflict(self.tcx, self.mir, place, root_place, sd) {\n+        if places_conflict::places_conflict(self.tcx, self.mir, place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead\n             // of just a span here.\n@@ -1398,7 +1399,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         for i in flow_state.ever_inits.iter_incoming() {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n-            if places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n+            if places_conflict::places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n                 self.report_illegal_reassignment(context, (place, span), init.span, err_place);\n                 break;\n             }"}, {"sha": "8ae98bde003441452bae85e8a9a2f9e551e979f1", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 9, "deletions": 360, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=edf14d18845414f807b29bcb76c41de71f07dc26", "patch": "@@ -8,22 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Returns true if the borrow represented by `kind` is\n-/// allowed to be split into separate Reservation and\n-/// Activation phases.\n-use borrow_check::ArtificialField;\n use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseUse};\n-use borrow_check::{Context, Overlap};\n-use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::places_conflict;\n+use borrow_check::Context;\n+use borrow_check::ShallowOrDeep;\n use dataflow::indexes::BorrowIndex;\n-use rustc::hir;\n use rustc::mir::{BasicBlock, Location, Mir, Place};\n-use rustc::mir::{Projection, ProjectionElem, BorrowKind};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{ProjectionElem, BorrowKind};\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n-use rustc_data_structures::small_vec::SmallVec;\n-use std::iter;\n \n+/// Returns true if the borrow represented by `kind` is\n+/// allowed to be split into separate Reservation and\n+/// Activation phases.\n pub(super) fn allow_two_phase_borrow<'a, 'tcx, 'gcx: 'tcx>(\n     tcx: &TyCtxt<'a, 'gcx, 'tcx>,\n     kind: BorrowKind\n@@ -64,7 +61,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     for i in candidates {\n         let borrowed = &borrow_set[i];\n \n-        if places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n+        if places_conflict::places_conflict(tcx, mir, &borrowed.borrowed_place, place, access) {\n             debug!(\n                 \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                 i, borrowed, place, access\n@@ -77,354 +74,6 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     }\n }\n \n-pub(super) fn places_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n-    borrow_place: &Place<'tcx>,\n-    access_place: &Place<'tcx>,\n-    access: ShallowOrDeep,\n-) -> bool {\n-    debug!(\n-        \"places_conflict({:?},{:?},{:?})\",\n-        borrow_place, access_place, access\n-    );\n-\n-    let borrow_components = place_elements(borrow_place);\n-    let access_components = place_elements(access_place);\n-    debug!(\n-        \"places_conflict: components {:?} / {:?}\",\n-        borrow_components, access_components\n-    );\n-\n-    let borrow_components = borrow_components\n-        .into_iter()\n-        .map(Some)\n-        .chain(iter::repeat(None));\n-    let access_components = access_components\n-        .into_iter()\n-        .map(Some)\n-        .chain(iter::repeat(None));\n-    // The borrowck rules for proving disjointness are applied from the \"root\" of the\n-    // borrow forwards, iterating over \"similar\" projections in lockstep until\n-    // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n-    // a monoid and report a conflict if the product ends up not being `Disjoint`.\n-    //\n-    // At each step, if we didn't run out of borrow or place, we know that our elements\n-    // have the same type, and that they only overlap if they are the identical.\n-    //\n-    // For example, if we are comparing these:\n-    // BORROW:  (*x1[2].y).z.a\n-    // ACCESS:  (*x1[i].y).w.b\n-    //\n-    // Then our steps are:\n-    //       x1         |   x1          -- places are the same\n-    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-    //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n-    //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n-    //\n-    // Because `zip` does potentially bad things to the iterator inside, this loop\n-    // also handles the case where the access might be a *prefix* of the borrow, e.g.\n-    //\n-    // BORROW:  (*x1[2].y).z.a\n-    // ACCESS:  x1[i].y\n-    //\n-    // Then our steps are:\n-    //       x1         |   x1          -- places are the same\n-    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n-    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n-    //\n-    // -- here we run out of access - the borrow can access a part of it. If this\n-    // is a full deep access, then we *know* the borrow conflicts with it. However,\n-    // if the access is shallow, then we can proceed:\n-    //\n-    //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n-    //                                     are disjoint\n-    //\n-    // Our invariant is, that at each step of the iteration:\n-    //  - If we didn't run out of access to match, our borrow and access are comparable\n-    //    and either equal or disjoint.\n-    //  - If we did run out of accesss, the borrow can access a part of it.\n-    for (borrow_c, access_c) in borrow_components.zip(access_components) {\n-        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n-        match (borrow_c, access_c) {\n-            (None, _) => {\n-                // If we didn't run out of access, the borrow can access all of our\n-                // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n-                // so we have a conflict.\n-                //\n-                // If we did, then we still know that the borrow can access a *part*\n-                // of our place that our access cares about (a borrow of `a.b.c`\n-                // with an access to `a.b`), so we still have a conflict.\n-                //\n-                // FIXME: Differs from AST-borrowck; includes drive-by fix\n-                // to #38899. Will probably need back-compat mode flag.\n-                debug!(\"places_conflict: full borrow, CONFLICT\");\n-                return true;\n-            }\n-            (Some(borrow_c), None) => {\n-                // We know that the borrow can access a part of our place. This\n-                // is a conflict if that is a part our access cares about.\n-\n-                let (base, elem) = match borrow_c {\n-                    Place::Projection(box Projection { base, elem }) => (base, elem),\n-                    _ => bug!(\"place has no base?\"),\n-                };\n-                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n-\n-                match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n-                            // The discriminant and array length are like\n-                            // additional fields on the type; they do not\n-                            // overlap any existing data there. Furthermore,\n-                            // they cannot actually be a prefix of any\n-                            // borrowed place (at least in MIR as it is\n-                            // currently.)\n-                            //\n-                            // e.g. a (mutable) borrow of `a[5]` while we read the\n-                            // array length of `a`.\n-                            debug!(\"places_conflict: implicit field\");\n-                            return false;\n-                        }\n-\n-                    (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n-                        // prefix thereof - the shallow access can't touch anything behind\n-                        // the pointer.\n-                        debug!(\"places_conflict: shallow access behind ptr\");\n-                        return false;\n-                    }\n-                    (\n-                        ProjectionElem::Deref,\n-                        ty::TyRef( _, _, hir::MutImmutable),\n-                        _,\n-                    ) => {\n-                        // the borrow goes through a dereference of a shared reference.\n-                        //\n-                        // I'm not sure why we are tracking these borrows - shared\n-                        // references can *always* be aliased, which means the\n-                        // permission check already account for this borrow.\n-                        debug!(\"places_conflict: behind a shared ref\");\n-                        return false;\n-                    }\n-\n-                    (ProjectionElem::Deref, _, Deep)\n-                        | (ProjectionElem::Field { .. }, _, _)\n-                        | (ProjectionElem::Index { .. }, _, _)\n-                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                        | (ProjectionElem::Subslice { .. }, _, _)\n-                        | (ProjectionElem::Downcast { .. }, _, _) => {\n-                            // Recursive case. This can still be disjoint on a\n-                            // further iteration if this a shallow access and\n-                            // there's a deref later on, e.g. a borrow\n-                            // of `*x.y` while accessing `x`.\n-                        }\n-                }\n-            }\n-            (Some(borrow_c), Some(access_c)) => {\n-                match place_element_conflict(tcx, mir, &borrow_c, access_c) {\n-                    Overlap::Arbitrary => {\n-                        // We have encountered different fields of potentially\n-                        // the same union - the borrow now partially overlaps.\n-                        //\n-                        // There is no *easy* way of comparing the fields\n-                        // further on, because they might have different types\n-                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n-                        // `.y` come from different structs).\n-                        //\n-                        // We could try to do some things here - e.g. count\n-                        // dereferences - but that's probably not a good\n-                        // idea, at least for now, so just give up and\n-                        // report a conflict. This is unsafe code anyway so\n-                        // the user could always use raw pointers.\n-                        debug!(\"places_conflict: arbitrary -> conflict\");\n-                        return true;\n-                    }\n-                    Overlap::EqualOrDisjoint => {\n-                        // This is the recursive case - proceed to the next element.\n-                    }\n-                    Overlap::Disjoint => {\n-                        // We have proven the borrow disjoint - further\n-                        // projections will remain disjoint.\n-                        debug!(\"places_conflict: disjoint\");\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    unreachable!(\"iter::repeat returned None\")\n-}\n-\n-/// Return all the prefixes of `place` in reverse order, including\n-/// downcasts.\n-fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> SmallVec<[&'a Place<'tcx>; 8]> {\n-    let mut result = SmallVec::new();\n-    let mut place = place;\n-    loop {\n-        result.push(place);\n-        match place {\n-            Place::Projection(interior) => {\n-                place = &interior.base;\n-            }\n-            Place::Local(_) | Place::Static(_) => {\n-                result.reverse();\n-                return result;\n-            }\n-        }\n-    }\n-}\n-\n-// Given that the bases of `elem1` and `elem2` are always either equal\n-// or disjoint (and have the same type!), return the overlap situation\n-// between `elem1` and `elem2`.\n-fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n-    elem1: &Place<'tcx>,\n-    elem2: &Place<'tcx>\n-) -> Overlap {\n-    match (elem1, elem2) {\n-        (Place::Local(l1), Place::Local(l2)) => {\n-            if l1 == l2 {\n-                // the same local - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different locals - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n-                Overlap::Disjoint\n-            }\n-        }\n-        (Place::Static(static1), Place::Static(static2)) => {\n-            if static1.def_id != static2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) ==\n-                        Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n-            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n-            Overlap::Disjoint\n-        }\n-        (Place::Projection(pi1), Place::Projection(pi2)) => {\n-            match (&pi1.elem, &pi2.elem) {\n-                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n-                    // derefs (e.g. `*x` vs. `*x`) - recur.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n-                    if f1 == f2 {\n-                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n-                        match ty.sty {\n-                            ty::TyAdt(def, _) if def.is_union() => {\n-                                // Different fields of a union, we are basically stuck.\n-                                debug!(\"place_element_conflict: STUCK-UNION\");\n-                                Overlap::Arbitrary\n-                            }\n-                            _ => {\n-                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n-                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                                Overlap::Disjoint\n-                            }\n-                        }\n-                    }\n-                }\n-                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n-                    // different variants are treated as having disjoint fields,\n-                    // even if they occupy the same \"space\", because it's\n-                    // impossible for 2 variants of the same enum to exist\n-                    // (and therefore, to be borrowed) at the same time.\n-                    //\n-                    // Note that this is different from unions - we *do* allow\n-                    // this code to compile:\n-                    //\n-                    // ```\n-                    // fn foo(x: &mut Result<i32, i32>) {\n-                    //     let mut v = None;\n-                    //     if let Ok(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     // here, you would *think* that the\n-                    //     // *entirety* of `x` would be borrowed,\n-                    //     // but in fact only the `Ok` variant is,\n-                    //     // so the `Err` variant is *entirely free*:\n-                    //     if let Err(ref mut a) = *x {\n-                    //         v = Some(a);\n-                    //     }\n-                    //     drop(v);\n-                    // }\n-                    // ```\n-                    if v1 == v2 {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n-                        Overlap::Disjoint\n-                    }\n-                }\n-                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n-                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (\n-                    ProjectionElem::ConstantIndex { .. },\n-                    ProjectionElem::ConstantIndex { .. },\n-                )\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n-                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                    // (if the indexes differ) or equal (if they are the same), so this\n-                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    //\n-                    // Note that by construction, MIR at borrowck can't subdivide\n-                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                    // are only present in slice patterns, and we \"merge together\" nested\n-                    // slice patterns. That means we don't have to think about these. It's\n-                    // probably a good idea to assert this somewhere, but I'm too lazy.\n-                    //\n-                    // FIXME(#8636) we might want to return Disjoint if\n-                    // both projections are constant and disjoint.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n-                    Overlap::EqualOrDisjoint\n-                }\n-\n-                (ProjectionElem::Deref, _)\n-                | (ProjectionElem::Field(..), _)\n-                | (ProjectionElem::Index(..), _)\n-                | (ProjectionElem::ConstantIndex { .. }, _)\n-                | (ProjectionElem::Subslice { .. }, _)\n-                | (ProjectionElem::Downcast(..), _) => bug!(\n-                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-                    elem1,\n-                    elem2\n-                ),\n-            }\n-        }\n-        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n-            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-            elem1,\n-            elem2\n-        ),\n-    }\n-}\n-\n pub(super) fn is_active<'tcx>(\n     dominators: &Dominators<BasicBlock>,\n     borrow_data: &BorrowData<'tcx>,"}, {"sha": "d9397a39072b0b6f44bf9f291d2853ed1bfc248a", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf14d18845414f807b29bcb76c41de71f07dc26/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=edf14d18845414f807b29bcb76c41de71f07dc26", "patch": "@@ -0,0 +1,367 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::ArtificialField;\n+use borrow_check::Overlap;\n+use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use rustc::hir;\n+use rustc::mir::{Mir, Place};\n+use rustc::mir::{Projection, ProjectionElem};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::small_vec::SmallVec;\n+use std::iter;\n+\n+pub(super) fn places_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    borrow_place: &Place<'tcx>,\n+    access_place: &Place<'tcx>,\n+    access: ShallowOrDeep,\n+) -> bool {\n+    debug!(\n+        \"places_conflict({:?},{:?},{:?})\",\n+        borrow_place, access_place, access\n+    );\n+\n+    let borrow_components = place_elements(borrow_place);\n+    let access_components = place_elements(access_place);\n+    debug!(\n+        \"places_conflict: components {:?} / {:?}\",\n+        borrow_components, access_components\n+    );\n+\n+    let borrow_components = borrow_components\n+        .into_iter()\n+        .map(Some)\n+        .chain(iter::repeat(None));\n+    let access_components = access_components\n+        .into_iter()\n+        .map(Some)\n+        .chain(iter::repeat(None));\n+    // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+    // borrow forwards, iterating over \"similar\" projections in lockstep until\n+    // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+    // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+    //\n+    // At each step, if we didn't run out of borrow or place, we know that our elements\n+    // have the same type, and that they only overlap if they are the identical.\n+    //\n+    // For example, if we are comparing these:\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  (*x1[i].y).w.b\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+    //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+    //\n+    // Because `zip` does potentially bad things to the iterator inside, this loop\n+    // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+    //\n+    // BORROW:  (*x1[2].y).z.a\n+    // ACCESS:  x1[i].y\n+    //\n+    // Then our steps are:\n+    //       x1         |   x1          -- places are the same\n+    //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+    //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+    //\n+    // -- here we run out of access - the borrow can access a part of it. If this\n+    // is a full deep access, then we *know* the borrow conflicts with it. However,\n+    // if the access is shallow, then we can proceed:\n+    //\n+    //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+    //                                     are disjoint\n+    //\n+    // Our invariant is, that at each step of the iteration:\n+    //  - If we didn't run out of access to match, our borrow and access are comparable\n+    //    and either equal or disjoint.\n+    //  - If we did run out of accesss, the borrow can access a part of it.\n+    for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+        debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n+        match (borrow_c, access_c) {\n+            (None, _) => {\n+                // If we didn't run out of access, the borrow can access all of our\n+                // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                // so we have a conflict.\n+                //\n+                // If we did, then we still know that the borrow can access a *part*\n+                // of our place that our access cares about (a borrow of `a.b.c`\n+                // with an access to `a.b`), so we still have a conflict.\n+                //\n+                // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                // to #38899. Will probably need back-compat mode flag.\n+                debug!(\"places_conflict: full borrow, CONFLICT\");\n+                return true;\n+            }\n+            (Some(borrow_c), None) => {\n+                // We know that the borrow can access a part of our place. This\n+                // is a conflict if that is a part our access cares about.\n+\n+                let (base, elem) = match borrow_c {\n+                    Place::Projection(box Projection { base, elem }) => (base, elem),\n+                    _ => bug!(\"place has no base?\"),\n+                };\n+                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+\n+                match (elem, &base_ty.sty, access) {\n+                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"places_conflict: implicit field\");\n+                            return false;\n+                        }\n+\n+                    (ProjectionElem::Deref, _, Shallow(None)) => {\n+                        // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                        // prefix thereof - the shallow access can't touch anything behind\n+                        // the pointer.\n+                        debug!(\"places_conflict: shallow access behind ptr\");\n+                        return false;\n+                    }\n+                    (\n+                        ProjectionElem::Deref,\n+                        ty::TyRef( _, _, hir::MutImmutable),\n+                        _,\n+                    ) => {\n+                        // the borrow goes through a dereference of a shared reference.\n+                        //\n+                        // I'm not sure why we are tracking these borrows - shared\n+                        // references can *always* be aliased, which means the\n+                        // permission check already account for this borrow.\n+                        debug!(\"places_conflict: behind a shared ref\");\n+                        return false;\n+                    }\n+\n+                    (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                }\n+            }\n+            (Some(borrow_c), Some(access_c)) => {\n+                match place_element_conflict(tcx, mir, &borrow_c, access_c) {\n+                    Overlap::Arbitrary => {\n+                        // We have encountered different fields of potentially\n+                        // the same union - the borrow now partially overlaps.\n+                        //\n+                        // There is no *easy* way of comparing the fields\n+                        // further on, because they might have different types\n+                        // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                        // `.y` come from different structs).\n+                        //\n+                        // We could try to do some things here - e.g. count\n+                        // dereferences - but that's probably not a good\n+                        // idea, at least for now, so just give up and\n+                        // report a conflict. This is unsafe code anyway so\n+                        // the user could always use raw pointers.\n+                        debug!(\"places_conflict: arbitrary -> conflict\");\n+                        return true;\n+                    }\n+                    Overlap::EqualOrDisjoint => {\n+                        // This is the recursive case - proceed to the next element.\n+                    }\n+                    Overlap::Disjoint => {\n+                        // We have proven the borrow disjoint - further\n+                        // projections will remain disjoint.\n+                        debug!(\"places_conflict: disjoint\");\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    unreachable!(\"iter::repeat returned None\")\n+}\n+\n+/// Return all the prefixes of `place` in reverse order, including\n+/// downcasts.\n+fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> SmallVec<[&'a Place<'tcx>; 8]> {\n+    let mut result = SmallVec::new();\n+    let mut place = place;\n+    loop {\n+        result.push(place);\n+        match place {\n+            Place::Projection(interior) => {\n+                place = &interior.base;\n+            }\n+            Place::Local(_) | Place::Static(_) => {\n+                result.reverse();\n+                return result;\n+            }\n+        }\n+    }\n+}\n+\n+// Given that the bases of `elem1` and `elem2` are always either equal\n+// or disjoint (and have the same type!), return the overlap situation\n+// between `elem1` and `elem2`.\n+fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    elem1: &Place<'tcx>,\n+    elem2: &Place<'tcx>\n+) -> Overlap {\n+    match (elem1, elem2) {\n+        (Place::Local(l1), Place::Local(l2)) => {\n+            if l1 == l2 {\n+                // the same local - base case, equal\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // different locals - base case, disjoint\n+                debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+        }\n+        (Place::Static(static1), Place::Static(static2)) => {\n+            if static1.def_id != static2.def_id {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                Overlap::Disjoint\n+            } else if tcx.is_static(static1.def_id) ==\n+                        Some(hir::Mutability::MutMutable) {\n+                // We ignore mutable statics - they can only be unsafe code.\n+                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                Overlap::EqualOrDisjoint\n+            }\n+        }\n+        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+            Overlap::Disjoint\n+        }\n+        (Place::Projection(pi1), Place::Projection(pi2)) => {\n+            match (&pi1.elem, &pi2.elem) {\n+                (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                    // derefs (e.g. `*x` vs. `*x`) - recur.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+                (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                    if f1 == f2 {\n+                        // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        match ty.sty {\n+                            ty::TyAdt(def, _) if def.is_union() => {\n+                                // Different fields of a union, we are basically stuck.\n+                                debug!(\"place_element_conflict: STUCK-UNION\");\n+                                Overlap::Arbitrary\n+                            }\n+                            _ => {\n+                                // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                Overlap::Disjoint\n+                            }\n+                        }\n+                    }\n+                }\n+                (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                    // different variants are treated as having disjoint fields,\n+                    // even if they occupy the same \"space\", because it's\n+                    // impossible for 2 variants of the same enum to exist\n+                    // (and therefore, to be borrowed) at the same time.\n+                    //\n+                    // Note that this is different from unions - we *do* allow\n+                    // this code to compile:\n+                    //\n+                    // ```\n+                    // fn foo(x: &mut Result<i32, i32>) {\n+                    //     let mut v = None;\n+                    //     if let Ok(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     // here, you would *think* that the\n+                    //     // *entirety* of `x` would be borrowed,\n+                    //     // but in fact only the `Ok` variant is,\n+                    //     // so the `Err` variant is *entirely free*:\n+                    //     if let Err(ref mut a) = *x {\n+                    //         v = Some(a);\n+                    //     }\n+                    //     drop(v);\n+                    // }\n+                    // ```\n+                    if v1 == v2 {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                | (\n+                    ProjectionElem::ConstantIndex { .. },\n+                    ProjectionElem::ConstantIndex { .. },\n+                )\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                    // (if the indexes differ) or equal (if they are the same), so this\n+                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                    //\n+                    // Note that by construction, MIR at borrowck can't subdivide\n+                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                    // are only present in slice patterns, and we \"merge together\" nested\n+                    // slice patterns. That means we don't have to think about these. It's\n+                    // probably a good idea to assert this somewhere, but I'm too lazy.\n+                    //\n+                    // FIXME(#8636) we might want to return Disjoint if\n+                    // both projections are constant and disjoint.\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                    Overlap::EqualOrDisjoint\n+                }\n+\n+                (ProjectionElem::Deref, _)\n+                | (ProjectionElem::Field(..), _)\n+                | (ProjectionElem::Index(..), _)\n+                | (ProjectionElem::ConstantIndex { .. }, _)\n+                | (ProjectionElem::Subslice { .. }, _)\n+                | (ProjectionElem::Downcast(..), _) => bug!(\n+                    \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                    elem1,\n+                    elem2\n+                ),\n+            }\n+        }\n+        (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+            \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+            elem1,\n+            elem2\n+        ),\n+    }\n+}"}]}