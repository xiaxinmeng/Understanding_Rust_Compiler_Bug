{"sha": "f0764433f7551afe4ba29c409abad48e121ab69f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzY0NDMzZjc1NTFhZmU0YmEyOWM0MDlhYmFkNDhlMTIxYWI2OWY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2018-08-17T15:23:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-17T15:23:40Z"}, "message": "Rollup merge of #53358 - SimonSapin:int-bytes, r=shepmaster\n\n`{to,from}_{ne,le,be}_bytes` for unsigned integer types\n\nSame as https://github.com/rust-lang/rust/pull/51919 did for signed integers.\n\nTracking issue: https://github.com/rust-lang/rust/issues/52963", "tree": {"sha": "bed8b8c4747d9808235edc60be62b938b43aeaf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bed8b8c4747d9808235edc60be62b938b43aeaf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0764433f7551afe4ba29c409abad48e121ab69f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbduh9CRBK7hj4Ov3rIwAAdHIIAG1+ndPCw5DcG9eT7sQKskhf\nM6snOJclKsRiFqmYjJ5mvQyEfDV0MFqQsPVx4l8mJ3SyHMOLbuuMwWAsJ4aIXBlY\nxt2OeI3p0MfO+oECzqNPMIdYTEgavDYR6Du/qhlidSAKe+y3iD1IRrFWezBfLdGi\n2hiQu70x7PlMwYVyG89uNi3E7zqlJUprnI0esyb7fUnvx3Kk4aqvBGSjGhxxRQFH\nWmRoW+1kk3sn84gqf25+/RcrXB8BA4tS5dYYoMJXg/ewOB53tcMGx/A5/fvY12En\ncNlVMTrGTyK94ICzeRqQKSdSnOSh4jWYDdkuYdv0PwhQ5A7DnkQx3C5FgFifYT4=\n=f5Ju\n-----END PGP SIGNATURE-----\n", "payload": "tree bed8b8c4747d9808235edc60be62b938b43aeaf6\nparent 18122e0db06cb0411d994fe24e4dbbf3b8d35180\nparent f5556a6a28683e3dd0f039948964a5361a70a498\nauthor Corey Farwell <coreyf@rwell.org> 1534519420 -0700\ncommitter GitHub <noreply@github.com> 1534519420 -0700\n\nRollup merge of #53358 - SimonSapin:int-bytes, r=shepmaster\n\n`{to,from}_{ne,le,be}_bytes` for unsigned integer types\n\nSame as https://github.com/rust-lang/rust/pull/51919 did for signed integers.\n\nTracking issue: https://github.com/rust-lang/rust/issues/52963\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0764433f7551afe4ba29c409abad48e121ab69f", "html_url": "https://github.com/rust-lang/rust/commit/f0764433f7551afe4ba29c409abad48e121ab69f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0764433f7551afe4ba29c409abad48e121ab69f/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18122e0db06cb0411d994fe24e4dbbf3b8d35180", "url": "https://api.github.com/repos/rust-lang/rust/commits/18122e0db06cb0411d994fe24e4dbbf3b8d35180", "html_url": "https://github.com/rust-lang/rust/commit/18122e0db06cb0411d994fe24e4dbbf3b8d35180"}, {"sha": "f5556a6a28683e3dd0f039948964a5361a70a498", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5556a6a28683e3dd0f039948964a5361a70a498", "html_url": "https://github.com/rust-lang/rust/commit/f5556a6a28683e3dd0f039948964a5361a70a498"}], "stats": {"total": 108, "additions": 90, "deletions": 18}, "files": [{"sha": "37856dc546935d3421153e26db476eba5437a166", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 90, "deletions": 18, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f0764433f7551afe4ba29c409abad48e121ab69f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0764433f7551afe4ba29c409abad48e121ab69f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f0764433f7551afe4ba29c409abad48e121ab69f", "patch": "@@ -1891,7 +1891,7 @@ $EndFeature, \"\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = 0x12345678i32.to_be_bytes();\n+        /// let bytes = 0x12_34_56_78_i32.to_be_bytes();\n         /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n@@ -1908,7 +1908,7 @@ $EndFeature, \"\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = 0x12345678i32.to_le_bytes();\n+        /// let bytes =  0x12_34_56_78_i32.to_le_bytes();\n         /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n@@ -3568,47 +3568,119 @@ $EndFeature, \"\n             }\n         }\n \n-        /// Return the memory representation of this integer as a byte array.\n+        /// Return the memory representation of this integer as a byte array in\n+        /// big-endian (network) byte order.\n+        ///\n+        /// # Examples\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// let bytes =  0x12_34_56_78_i32.to_be_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// little-endian byte order.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = 0x1234_5678_u32.to_be().to_bytes();\n-        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// let bytes =  0x12_34_56_78_i32.to_le_bytes();\n+        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// native byte order.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+        /// instead.\n+        ///\n+        /// [`to_be_bytes`]: #method.to_be_bytes\n+        /// [`to_le_bytes`]: #method.to_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n+        /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte array.\n+        /// Create an integer value from its representation as a byte array in\n+        /// big endian.\n+        ///\n+        /// # Examples\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use [`to_be`] or [`to_le`] after this.\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x12_34_56_78);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its representation as a byte array in\n+        /// little endian.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let int = u32::from_be(u32::from_bytes([0x12, 0x34, 0x56, 0x78]));\n-        /// assert_eq!(int, 0x1234_5678_u32);\n+        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x78_56_34_12);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte\n+        /// array in native endianness.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+        /// appropriate instead.\n+        ///\n+        /// [`from_be_bytes`]: #method.from_be_bytes\n+        /// [`from_le_bytes`]: #method.from_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n+        /// assert_eq!(int, i32::min_value());\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }"}]}