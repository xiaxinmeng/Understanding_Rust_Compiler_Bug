{"sha": "3ea6f774460fa3009ac02d2ef9869d330bef4f49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYTZmNzc0NDYwZmEzMDA5YWMwMmQyZWY5ODY5ZDMzMGJlZjRmNDk=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-11-10T21:32:24Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-11-10T21:32:24Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "29654d7db80886fdc2ed505dc5538fe28f6dd176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29654d7db80886fdc2ed505dc5538fe28f6dd176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea6f774460fa3009ac02d2ef9869d330bef4f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea6f774460fa3009ac02d2ef9869d330bef4f49", "html_url": "https://github.com/rust-lang/rust/commit/3ea6f774460fa3009ac02d2ef9869d330bef4f49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea6f774460fa3009ac02d2ef9869d330bef4f49/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6294300b8ec9b9eec0ec7fb0435aff93a299ed63", "url": "https://api.github.com/repos/rust-lang/rust/commits/6294300b8ec9b9eec0ec7fb0435aff93a299ed63", "html_url": "https://github.com/rust-lang/rust/commit/6294300b8ec9b9eec0ec7fb0435aff93a299ed63"}, {"sha": "dd826b4626c00da53f76f00f02f03556803e9cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd826b4626c00da53f76f00f02f03556803e9cdb", "html_url": "https://github.com/rust-lang/rust/commit/dd826b4626c00da53f76f00f02f03556803e9cdb"}], "stats": {"total": 2212, "additions": 1839, "deletions": 373}, "files": [{"sha": "a3f114e0bb34f4e64c8eb233afa49b344d106f33", "filename": ".github/PULL_REQUEST_TEMPLATE.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/.github%2FPULL_REQUEST_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/.github%2FPULL_REQUEST_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FPULL_REQUEST_TEMPLATE.md?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,8 +1,8 @@\n Thank you for making Clippy better!\n \n We're collecting our changelog from pull request descriptions.\n-If your PR only updates to the latest nightly, you can leave the\n-`changelog` entry as `none`. Otherwise, please write a short comment\n+If your PR only includes internal changes, you can just write\n+`changelog: none`. Otherwise, please write a short comment\n explaining your change.\n \n If your PR fixes an issue, you can add \"fixes #issue_number\" into this\n@@ -28,5 +28,5 @@ Delete this line and everything above before opening your PR.\n \n ---\n \n-*Please keep the line below*\n-changelog: none\n+*Please write a short comment explaining your change (or \"none\" for internal only changes)*\n+changelog:"}, {"sha": "816d25bcd93eb1fe5628ceeb530ea04248f8d402", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1787,6 +1787,7 @@ Released 2018-09-13\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n [`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n [`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\n+[`let_underscore_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_drop\n [`let_underscore_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_lock\n [`let_underscore_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_must_use\n [`let_unit_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n@@ -1956,6 +1957,7 @@ Released 2018-09-13\n [`string_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add\n [`string_add_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add_assign\n [`string_extend_chars`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_extend_chars\n+[`string_from_utf8_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_from_utf8_as_bytes\n [`string_lit_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_lit_as_bytes\n [`string_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_to_string\n [`struct_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools"}, {"sha": "1da626b505dfb9e1da2978c909a392acba24dcc7", "filename": "README.md", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -7,28 +7,22 @@ A collection of lints to catch common mistakes and improve your [Rust](https://g\n \n [There are over 400 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n-We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n-\n-* `clippy::all` (everything that is on by default: all the categories below except for `nursery`, `pedantic`, and `cargo`)\n-* `clippy::correctness` (code that is just **outright wrong** or **very very useless**, causes hard errors by default)\n-* `clippy::style` (code that should be written in a more idiomatic way)\n-* `clippy::complexity` (code that does something simple but in a complex way)\n-* `clippy::perf` (code that can be written in a faster way)\n-* `clippy::pedantic` (lints which are rather strict, off by default)\n-* `clippy::nursery` (new lints that aren't quite ready yet, off by default)\n-* `clippy::cargo` (checks against the cargo manifest, off by default)\n+Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n+You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n+\n+Category | Description | Default level\n+-- | -- | --\n+`clippy::all` | all lints that are on by default (correctness, style, complexity, perf) | **warn/deny**\n+`clippy::correctness` | code that is outright wrong or very useless | **deny**\n+`clippy::style` | code that should be written in a more idiomatic way | **warn**\n+`clippy::complexity` | code that does something simple but in a complex way | **warn**\n+`clippy::perf` | code that can be written to run faster | **warn**\n+`clippy::pedantic` | lints which are rather strict or might have false positives | allow\n+`clippy::nursery` | new lints that are still under development | allow\n+`clippy::cargo` | lints for the cargo manifest | allow\n \n More to come, please [file an issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n \n-Only the following of those categories are enabled by default:\n-\n-* `clippy::style`\n-* `clippy::correctness`\n-* `clippy::complexity`\n-* `clippy::perf`\n-\n-Other categories need to be enabled in order for their lints to be executed.\n-\n The [lint list](https://rust-lang.github.io/rust-clippy/master/index.html) also contains \"restriction lints\", which are\n for things which are usually not considered \"bad\", but may be useful to turn on in specific cases. These should be used\n very selectively, if at all."}, {"sha": "ca819663fded8f172236bf8eaf05aa43953856c1", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -65,8 +65,8 @@ declare_clippy_lint! {\n     /// use std::cell::RefCell;\n     ///\n     /// async fn foo(x: &RefCell<u32>) {\n-    ///   let b = x.borrow_mut()();\n-    ///   *ref += 1;\n+    ///   let mut y = x.borrow_mut();\n+    ///   *y += 1;\n     ///   bar.await;\n     /// }\n     /// ```\n@@ -77,8 +77,8 @@ declare_clippy_lint! {\n     ///\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   {\n-    ///     let b = x.borrow_mut();\n-    ///     *ref += 1;\n+    ///      let mut y = x.borrow_mut();\n+    ///      *y += 1;\n     ///   }\n     ///   bar.await;\n     /// }"}, {"sha": "0d294761af5ab9a844b48e3495a01ef57b661ab7", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -23,6 +23,21 @@ declare_clippy_lint! {\n     /// [package]\n     /// name = \"clippy\"\n     /// version = \"0.0.212\"\n+    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n+    /// repository = \"https://github.com/rust-lang/rust-clippy\"\n+    /// readme = \"README.md\"\n+    /// license = \"MIT OR Apache-2.0\"\n+    /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n+    /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n+    /// ```\n+    ///\n+    /// Should include an authors field like:\n+    ///\n+    /// ```toml\n+    /// # This `Cargo.toml` includes all common metadata\n+    /// [package]\n+    /// name = \"clippy\"\n+    /// version = \"0.0.212\"\n     /// authors = [\"Someone <someone@rust-lang.org>\"]\n     /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n     /// repository = \"https://github.com/rust-lang/rust-clippy\""}, {"sha": "71a30d1c33d4f385bfd918058ede1a3df2fd4049", "filename": "clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -92,13 +92,8 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                         |db| {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.maybe_note_obligation_cause_for_async_await(\n-                                        db,\n-                                        &obligation,\n-                                    );\n-                                    if let Trait(trait_pred, _) =\n-                                        obligation.predicate.skip_binders()\n-                                    {\n+                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n+                                    if let Trait(trait_pred, _) = obligation.predicate.skip_binders() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "6a5a77f8690a9be9b17c526c23e884cd1be6fa77", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::{is_must_use_func_call, is_must_use_ty, match_type, paths, span_lint_and_help};\n+use crate::utils::{implements_trait, is_must_use_func_call, is_must_use_ty, match_type, paths, span_lint_and_help};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `let _ = <expr>`\n@@ -58,7 +58,48 @@ declare_clippy_lint! {\n     \"non-binding let on a synchronization lock\"\n }\n \n-declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `let _ = <expr>`\n+    /// where expr has a type that implements `Drop`\n+    ///\n+    /// **Why is this bad?** This statement immediately drops the initializer\n+    /// expression instead of extending its lifetime to the end of the scope, which\n+    /// is often not intended. To extend the expression's lifetime to the end of the\n+    /// scope, use an underscore-prefixed name instead (i.e. _var). If you want to\n+    /// explicitly drop the expression, `std::mem::drop` conveys your intention\n+    /// better and is less error-prone.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// struct Droppable;\n+    /// impl Drop for Droppable {\n+    ///     fn drop(&mut self) {}\n+    /// }\n+    /// {\n+    ///     let _ = Droppable;\n+    ///     //               ^ dropped here\n+    ///     /* more code */\n+    /// }\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// {\n+    ///     let _droppable = Droppable;\n+    ///     /* more code */\n+    ///     // dropped at end of scope\n+    /// }\n+    /// ```\n+    pub LET_UNDERSCORE_DROP,\n+    pedantic,\n+    \"non-binding let on a type that implements `Drop`\"\n+}\n+\n+declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n \n const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n     &paths::MUTEX_GUARD,\n@@ -84,6 +125,15 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n \n                     GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n                 });\n+                let implements_drop = cx.tcx.lang_items().drop_trait().map_or(false, |drop_trait|\n+                    init_ty.walk().any(|inner| match inner.unpack() {\n+                        GenericArgKind::Type(inner_ty) => {\n+                            implements_trait(cx, inner_ty, drop_trait, &[])\n+                        },\n+\n+                        GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n+                    })\n+                );\n                 if contains_sync_guard {\n                     span_lint_and_help(\n                         cx,\n@@ -94,6 +144,16 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"consider using an underscore-prefixed named \\\n                             binding or dropping explicitly with `std::mem::drop`\"\n                     )\n+                } else if implements_drop {\n+                    span_lint_and_help(\n+                        cx,\n+                        LET_UNDERSCORE_DROP,\n+                        local.span,\n+                        \"non-binding `let` on a type that implements `Drop`\",\n+                        None,\n+                        \"consider using an underscore-prefixed named \\\n+                            binding or dropping explicitly with `std::mem::drop`\"\n+                    )\n                 } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n                         cx,"}, {"sha": "20b38cbb6d0d550ac9ad68892dcc28eb2dad0c3c", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -622,6 +622,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n+        &let_underscore::LET_UNDERSCORE_DROP,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n         &lifetimes::EXTRA_UNUSED_LIFETIMES,\n@@ -832,6 +833,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n         &strings::STRING_ADD,\n         &strings::STRING_ADD_ASSIGN,\n+        &strings::STRING_FROM_UTF8_AS_BYTES,\n         &strings::STRING_LIT_AS_BYTES,\n         &suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         &suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n@@ -1239,6 +1241,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&infinite_iter::MAYBE_INFINITE_ITER),\n         LintId::of(&items_after_statements::ITEMS_AFTER_STATEMENTS),\n         LintId::of(&large_stack_arrays::LARGE_STACK_ARRAYS),\n+        LintId::of(&let_underscore::LET_UNDERSCORE_DROP),\n         LintId::of(&literal_representation::LARGE_DIGIT_GROUPS),\n         LintId::of(&literal_representation::UNREADABLE_LITERAL),\n         LintId::of(&loops::EXPLICIT_INTO_ITER_LOOP),\n@@ -1527,6 +1530,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n+        LintId::of(&strings::STRING_FROM_UTF8_AS_BYTES),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(&swap::ALMOST_SWAPPED),\n@@ -1752,6 +1756,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n+        LintId::of(&strings::STRING_FROM_UTF8_AS_BYTES),\n         LintId::of(&swap::MANUAL_SWAP),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),"}, {"sha": "b246245af24ceb8b641f48b50d74bccec64c83ba", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -4,10 +4,10 @@ use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    indent_of, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment,\n-    match_trait_method, match_type, match_var, multispan_sugg, qpath_res, single_segment_path, snippet,\n-    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n-    span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n+    last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, qpath_res, single_segment_path,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -543,17 +543,15 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n         if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.kind {\n-            // also check for empty `loop {}` statements\n-            // TODO(issue #6161): Enable for no_std crates (outside of #[panic_handler])\n-            if block.stmts.is_empty() && block.expr.is_none() && !is_no_std_crate(cx.tcx.hir().krate()) {\n-                span_lint_and_help(\n-                    cx,\n-                    EMPTY_LOOP,\n-                    expr.span,\n-                    \"empty `loop {}` wastes CPU cycles\",\n-                    None,\n-                    \"You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\",\n-                );\n+            // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n+            if block.stmts.is_empty() && block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n+                let msg = \"empty `loop {}` wastes CPU cycles\";\n+                let help = if is_no_std_crate(cx.tcx.hir().krate()) {\n+                    \"you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\"\n+                } else {\n+                    \"you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\"\n+                };\n+                span_lint_and_help(cx, EMPTY_LOOP, expr.span, msg, None, help);\n             }\n \n             // extract the expression from the first statement (if any) in a block"}, {"sha": "7b3b450ef93e943fad6882126463f32a42617ebd", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::paths::FUTURE_FROM_GENERATOR;\n-use crate::utils::{match_function_call, snippet_block, snippet_opt, span_lint_and_then};\n+use crate::utils::{match_function_call, position_before_rarrow, snippet_block, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n                     |diag| {\n                         if_chain! {\n                             if let Some(header_snip) = snippet_opt(cx, header_span);\n-                            if let Some(ret_pos) = header_snip.rfind(\"->\");\n+                            if let Some(ret_pos) = position_before_rarrow(header_snip.clone());\n                             if let Some((ret_sugg, ret_snip)) = suggested_ret(cx, output);\n                             then {\n                                 let help = format!(\"make the function `async` and {}\", ret_sugg);\n@@ -194,7 +194,7 @@ fn suggested_ret(cx: &LateContext<'_>, output: &Ty<'_>) -> Option<(&'static str,\n         },\n         _ => {\n             let sugg = \"return the output of the future directly\";\n-            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\"-> {}\", snip)))\n+            snippet_opt(cx, output.span).map(|snip| (sugg, format!(\" -> {}\", snip)))\n         },\n     }\n }"}, {"sha": "9a00608ce3947842bfcf0a1657da3d2b1774c18f", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -80,9 +80,11 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n                                     let obj_ty = cx.typeck_results().expr_ty(&obj[0]);\n-                                    if let ty::Ref(_, ty, _) = obj_ty.kind() {\n-                                        let copy = is_copy(cx, ty);\n-                                        lint(cx, e.span, args[0].span, copy);\n+                                    if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n+                                        if matches!(mutability, Mutability::Not) {\n+                                            let copy = is_copy(cx, ty);\n+                                            lint(cx, e.span, args[0].span, copy);\n+                                        }\n                                     } else {\n                                         lint_needless_cloning(cx, e.span, args[0].span);\n                                     }"}, {"sha": "b6fb3d06934ed40a5fcbb011f810813a4b1d9c08", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 46, "deletions": 50, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1797,12 +1797,20 @@ fn lint_or_fun_call<'tcx>(\n         cx: &LateContext<'tcx>,\n         name: &str,\n         method_span: Span,\n-        fun_span: Span,\n         self_expr: &hir::Expr<'_>,\n         arg: &'tcx hir::Expr<'_>,\n-        or_has_args: bool,\n         span: Span,\n+        // None if lambda is required\n+        fun_span: Option<Span>,\n     ) {\n+        // (path, fn_has_argument, methods, suffix)\n+        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n+\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n                 let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n@@ -1818,32 +1826,32 @@ fn lint_or_fun_call<'tcx>(\n             }\n         }\n \n-        // (path, fn_has_argument, methods, suffix)\n-        let know_types: &[(&[_], _, &[_], _)] = &[\n-            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n-        ];\n-\n         if_chain! {\n-            if know_types.iter().any(|k| k.2.contains(&name));\n+            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n             if is_lazyness_candidate(cx, arg);\n             if !contains_return(&arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n \n             if poss.contains(&name);\n \n             then {\n-                let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n-                    (true, _) => format!(\"|_| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-                    (false, false) => format!(\"|| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-                    (false, true) => snippet_with_macro_callsite(cx, fun_span, \"..\"),\n+                let sugg: Cow<'_, str> = {\n+                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n+                        (false, Some(fun_span)) => (fun_span, false),\n+                        _ => (arg.span, true),\n+                    };\n+                    let snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n+                    if use_lambda {\n+                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n+                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                    } else {\n+                        snippet\n+                    }\n                 };\n                 let span_replace_word = method_span.with_hi(span.hi());\n                 span_lint_and_sugg(\n@@ -1864,28 +1872,13 @@ fn lint_or_fun_call<'tcx>(\n             hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n-                    check_general_case(\n-                        cx,\n-                        name,\n-                        method_span,\n-                        fun.span,\n-                        &args[0],\n-                        &args[1],\n-                        or_has_args,\n-                        expr.span,\n-                    );\n+                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n+                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, span, ref or_args, _) => check_general_case(\n-                cx,\n-                name,\n-                method_span,\n-                span,\n-                &args[0],\n-                &args[1],\n-                !or_args.is_empty(),\n-                expr.span,\n-            ),\n+            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n+                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n+            },\n             _ => {},\n         }\n     }\n@@ -3901,21 +3894,24 @@ fn lint_from_iter(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<\n     let ty = cx.typeck_results().expr_ty(expr);\n     let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n \n-    let from_iter_id = get_trait_def_id(cx, &paths::FROM_ITERATOR).unwrap();\n-    let iter_id = get_trait_def_id(cx, &paths::ITERATOR).unwrap();\n+    if_chain! {\n+        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n+        if let Some(iter_id) = get_trait_def_id(cx, &paths::ITERATOR);\n \n-    if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]) {\n-        // `expr` implements `FromIterator` trait\n-        let iter_expr = snippet(cx, args[0].span, \"..\");\n-        span_lint_and_sugg(\n-            cx,\n-            FROM_ITER_INSTEAD_OF_COLLECT,\n-            expr.span,\n-            \"usage of `FromIterator::from_iter`\",\n-            \"use `.collect()` instead of `::from_iter()`\",\n-            format!(\"{}.collect()\", iter_expr),\n-            Applicability::MaybeIncorrect,\n-        );\n+        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        then {\n+            // `expr` implements `FromIterator` trait\n+            let iter_expr = snippet(cx, args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                FROM_ITER_INSTEAD_OF_COLLECT,\n+                expr.span,\n+                \"usage of `FromIterator::from_iter`\",\n+                \"use `.collect()` instead of `::from_iter()`\",\n+                format!(\"{}.collect()\", iter_expr),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n     }\n }\n "}, {"sha": "a867bdb326d722dfc0c089fda2fa6f8b6adc71d2", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -33,6 +33,17 @@ pub(super) fn lint<'tcx>(\n                 } else {\n                     \"unnecessary closure used to substitute value for `Result::Err`\"\n                 };\n+                let applicability = if body\n+                    .params\n+                    .iter()\n+                    // bindings are checked to be unused above\n+                    .all(|param| matches!(param.pat.kind, hir::PatKind::Binding(..) | hir::PatKind::Wild))\n+                {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    // replacing the lambda may break type inference\n+                    Applicability::MaybeIncorrect\n+                };\n \n                 span_lint_and_sugg(\n                     cx,\n@@ -46,7 +57,7 @@ pub(super) fn lint<'tcx>(\n                         simplify_using,\n                         snippet(cx, body_expr.span, \"..\"),\n                     ),\n-                    Applicability::MachineApplicable,\n+                    applicability,\n                 );\n             }\n         }"}, {"sha": "6b0d198edcffa647112af10cceccea3a3304f2d2", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 135, "deletions": 35, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -5,11 +5,15 @@\n use std::ptr;\n \n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{\n+    BodyId, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n+};\n use rustc_infer::traits::specialization_graph;\n use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{AssocKind, Ty};\n+use rustc_middle::ty::{self, AssocKind, Const, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -36,14 +40,17 @@ declare_clippy_lint! {\n     /// `std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\n     /// and this lint should be suppressed.\n     ///\n-    /// When an enum has variants with interior mutability, use of its non interior mutable\n-    /// variants can generate false positives. See issue\n-    /// [#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n+    /// Even though the lint avoids triggering on a constant whose type has enums that have variants\n+    /// with interior mutability, and its value uses non interior mutable variants (see\n+    /// [#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n+    /// [#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\n+    /// it complains about associated constants without default values only based on its types;\n+    /// which might not be preferable.\n+    /// There're other enums plus associated constants cases that the lint cannot handle.\n     ///\n     /// Types that have underlying or potential interior mutability trigger the lint whether\n     /// the interior mutable field is used or not. See issues\n     /// [#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n-    /// [#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -105,6 +112,79 @@ declare_clippy_lint! {\n     \"referencing `const` with interior mutability\"\n }\n \n+fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n+    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n+    // 'unfrozen'. However, this code causes a false negative in which\n+    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n+    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n+    // since it works when a pointer indirection involves (`Cell<*const T>`).\n+    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n+    // but I'm not sure whether it's a decent way, if possible.\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+}\n+\n+fn is_value_unfrozen_raw<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    result: Result<ConstValue<'tcx>, ErrorHandled>,\n+    ty: Ty<'tcx>,\n+) -> bool {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: &'tcx Const<'tcx>) -> bool {\n+        match val.ty.kind() {\n+            // the fact that we have to dig into every structs to search enums\n+            // leads us to the point checking `UnsafeCell` directly is the only option.\n+            ty::Adt(ty_def, ..) if Some(ty_def.did) == cx.tcx.lang_items().unsafe_cell_type() => true,\n+            ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n+                let val = cx.tcx.destructure_const(cx.param_env.and(val));\n+                val.fields.iter().any(|field| inner(cx, field))\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    result.map_or_else(\n+        |err| {\n+            // Consider `TooGeneric` cases as being unfrozen.\n+            // This causes a false positive where an assoc const whose type is unfrozen\n+            // have a value that is a frozen variant with a generic param (an example is\n+            // `declare_interior_mutable_const::enums::BothOfCellAndGeneric::GENERIC_VARIANT`).\n+            // However, it prevents a number of false negatives that is, I think, important:\n+            // 1. assoc consts in trait defs referring to consts of themselves\n+            //    (an example is `declare_interior_mutable_const::traits::ConcreteTypes::ANOTHER_ATOMIC`).\n+            // 2. a path expr referring to assoc consts whose type is doesn't have\n+            //    any frozen variants in trait defs (i.e. without substitute for `Self`).\n+            //    (e.g. borrowing `borrow_interior_mutable_const::trait::ConcreteTypes::ATOMIC`)\n+            // 3. similar to the false positive above;\n+            //    but the value is an unfrozen variant, or the type has no enums. (An example is\n+            //    `declare_interior_mutable_const::enums::BothOfCellAndGeneric::UNFROZEN_VARIANT`\n+            //    and `declare_interior_mutable_const::enums::BothOfCellAndGeneric::NO_ENUM`).\n+            // One might be able to prevent these FNs correctly, and replace this with `false`;\n+            // e.g. implementing `has_frozen_variant` described above, and not running this function\n+            // when the type doesn't have any frozen variants would be the 'correct' way for the 2nd\n+            // case (that actually removes another suboptimal behavior (I won't say 'false positive') where,\n+            // similar to 2., but with the a frozen variant) (e.g. borrowing\n+            // `borrow_interior_mutable_const::enums::AssocConsts::TO_BE_FROZEN_VARIANT`).\n+            // I chose this way because unfrozen enums as assoc consts are rare (or, hopefully, none).\n+            err == ErrorHandled::TooGeneric\n+        },\n+        |val| inner(cx, Const::from_value(cx.tcx, val, ty)),\n+    )\n+}\n+\n+fn is_value_unfrozen_poly<'tcx>(cx: &LateContext<'tcx>, body_id: BodyId, ty: Ty<'tcx>) -> bool {\n+    let result = cx.tcx.const_eval_poly(body_id.hir_id.owner.to_def_id());\n+    is_value_unfrozen_raw(cx, result, ty)\n+}\n+\n+fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: DefId, ty: Ty<'tcx>) -> bool {\n+    let substs = cx.typeck_results().node_substs(hir_id);\n+\n+    let result = cx\n+        .tcx\n+        .const_eval_resolve(cx.param_env, ty::WithOptConstParam::unknown(def_id), substs, None, None);\n+    is_value_unfrozen_raw(cx, result, ty)\n+}\n+\n #[derive(Copy, Clone)]\n enum Source {\n     Item { item: Span },\n@@ -130,19 +210,7 @@ impl Source {\n     }\n }\n \n-fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n-    // Ignore types whose layout is unknown since `is_freeze` reports every generic types as `!Freeze`,\n-    // making it indistinguishable from `UnsafeCell`. i.e. it isn't a tool to prove a type is\n-    // 'unfrozen'. However, this code causes a false negative in which\n-    // a type contains a layout-unknown type, but also a unsafe cell like `const CELL: Cell<T>`.\n-    // Yet, it's better than `ty.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_PROJECTION)`\n-    // since it works when a pointer indirection involves (`Cell<*const T>`).\n-    // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n-    // but I'm not sure whether it's a decent way, if possible.\n-    if cx.tcx.layout_of(cx.param_env.and(ty)).is_err() || ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env) {\n-        return;\n-    }\n-\n+fn lint(cx: &LateContext<'_>, source: Source) {\n     let (lint, msg, span) = source.lint();\n     span_lint_and_then(cx, lint, span, msg, |diag| {\n         if span.from_expansion() {\n@@ -165,24 +233,44 @@ declare_lint_pass!(NonCopyConst => [DECLARE_INTERIOR_MUTABLE_CONST, BORROW_INTER\n \n impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx Item<'_>) {\n-        if let ItemKind::Const(hir_ty, ..) = &it.kind {\n+        if let ItemKind::Const(hir_ty, body_id) = it.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            verify_ty_bound(cx, ty, Source::Item { item: it.span });\n+\n+            if is_unfrozen(cx, ty) && is_value_unfrozen_poly(cx, body_id, ty) {\n+                lint(cx, Source::Item { item: it.span });\n+            }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx TraitItem<'_>) {\n-        if let TraitItemKind::Const(hir_ty, ..) = &trait_item.kind {\n+        if let TraitItemKind::Const(hir_ty, body_id_opt) = &trait_item.kind {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n             // Normalize assoc types because ones originated from generic params\n             // bounded other traits could have their bound.\n             let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-            verify_ty_bound(cx, normalized, Source::Assoc { item: trait_item.span });\n+            if is_unfrozen(cx, normalized)\n+                // When there's no default value, lint it only according to its type;\n+                // in other words, lint consts whose value *could* be unfrozen, not definitely is.\n+                // This feels inconsistent with how the lint treats generic types,\n+                // which avoids linting types which potentially become unfrozen.\n+                // One could check whether a unfrozen type have a *frozen variant*\n+                // (like `body_id_opt.map_or_else(|| !has_frozen_variant(...), ...)`),\n+                // and do the same as the case of generic types at impl items.\n+                // Note that it isn't sufficient to check if it has an enum\n+                // since all of that enum's variants can be unfrozen:\n+                // i.e. having an enum doesn't necessary mean a type has a frozen variant.\n+                // And, implementing it isn't a trivial task; it'll probably end up\n+                // re-implementing the trait predicate evaluation specific to `Freeze`.\n+                && body_id_opt.map_or(true, |body_id| is_value_unfrozen_poly(cx, body_id, normalized))\n+            {\n+                lint(cx, Source::Assoc { item: trait_item.span });\n+            }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n-        if let ImplItemKind::Const(hir_ty, ..) = &impl_item.kind {\n+        if let ImplItemKind::Const(hir_ty, body_id) = &impl_item.kind {\n             let item_hir_id = cx.tcx.hir().get_parent_node(impl_item.hir_id);\n             let item = cx.tcx.hir().expect_item(item_hir_id);\n \n@@ -209,24 +297,34 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                                 ),\n                             ))\n                             .is_err();\n+                            // If there were a function like `has_frozen_variant` described above,\n+                            // we should use here as a frozen variant is a potential to be frozen\n+                            // similar to unknown layouts.\n+                            // e.g. `layout_of(...).is_err() || has_frozen_variant(...);`\n                         then {\n                             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                             let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                            verify_ty_bound(\n-                                cx,\n-                                normalized,\n-                                Source::Assoc {\n-                                    item: impl_item.span,\n-                                },\n-                            );\n+                            if is_unfrozen(cx, normalized)\n+                                && is_value_unfrozen_poly(cx, *body_id, normalized)\n+                            {\n+                                lint(\n+                                   cx,\n+                                   Source::Assoc {\n+                                       item: impl_item.span,\n+                                    },\n+                                );\n+                            }\n                         }\n                     }\n                 },\n                 ItemKind::Impl { of_trait: None, .. } => {\n                     let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                     // Normalize assoc types originated from generic params.\n                     let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                    verify_ty_bound(cx, normalized, Source::Assoc { item: impl_item.span });\n+\n+                    if is_unfrozen(cx, ty) && is_value_unfrozen_poly(cx, *body_id, normalized) {\n+                        lint(cx, Source::Assoc { item: impl_item.span });\n+                    }\n                 },\n                 _ => (),\n             }\n@@ -241,8 +339,8 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             // Make sure it is a const item.\n-            match qpath_res(cx, qpath, expr.hir_id) {\n-                Res::Def(DefKind::Const | DefKind::AssocConst, _) => {},\n+            let item_def_id = match qpath_res(cx, qpath, expr.hir_id) {\n+                Res::Def(DefKind::Const | DefKind::AssocConst, did) => did,\n                 _ => return,\n             };\n \n@@ -319,7 +417,9 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                 cx.typeck_results().expr_ty(dereferenced_expr)\n             };\n \n-            verify_ty_bound(cx, ty, Source::Expr { expr: expr.span });\n+            if is_unfrozen(cx, ty) && is_value_unfrozen_expr(cx, expr.hir_id, item_def_id, ty) {\n+                lint(cx, Source::Expr { expr: expr.span });\n+            }\n         }\n     }\n }"}, {"sha": "35a1310d68b849b6cb2dc062480d1be17295963f", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,9 +1,10 @@\n-use crate::utils::{in_macro, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet_opt, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, UnOp};\n+use rustc_ast::ast::{Expr, ExprKind, Mutability, UnOp};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::BytePos;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n@@ -42,17 +43,45 @@ impl EarlyLintPass for DerefAddrOf {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.kind;\n-            if let ExprKind::AddrOf(_, _, ref addrof_target) = without_parens(deref_target).kind;\n+            if let ExprKind::AddrOf(_, ref mutability, ref addrof_target) = without_parens(deref_target).kind;\n             if !in_macro(addrof_target.span);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n+                let sugg = if e.span.from_expansion() {\n+                    if let Ok(macro_source) = cx.sess.source_map().span_to_snippet(e.span) {\n+                        // Remove leading whitespace from the given span\n+                        // e.g: ` $visitor` turns into `$visitor`\n+                        let trim_leading_whitespaces = |span| {\n+                            snippet_opt(cx, span).and_then(|snip| {\n+                                #[allow(clippy::cast_possible_truncation)]\n+                                snip.find(|c: char| !c.is_whitespace()).map(|pos| {\n+                                    span.lo() + BytePos(pos as u32)\n+                                })\n+                            }).map_or(span, |start_no_whitespace| e.span.with_lo(start_no_whitespace))\n+                        };\n+\n+                        let rpos = if *mutability == Mutability::Mut {\n+                            macro_source.rfind(\"mut\").expect(\"already checked this is a mutable reference\") + \"mut\".len()\n+                        } else {\n+                            macro_source.rfind('&').expect(\"already checked this is a reference\") + \"&\".len()\n+                        };\n+                        #[allow(clippy::cast_possible_truncation)]\n+                        let span_after_ref = e.span.with_lo(BytePos(e.span.lo().0 + rpos as u32));\n+                        let span = trim_leading_whitespaces(span_after_ref);\n+                        snippet_with_applicability(cx, span, \"_\", &mut applicability)\n+                    } else {\n+                        snippet_with_applicability(cx, e.span, \"_\", &mut applicability)\n+                    }\n+                } else {\n+                    snippet_with_applicability(cx, addrof_target.span, \"_\", &mut applicability)\n+                }.to_string();\n                 span_lint_and_sugg(\n                     cx,\n                     DEREF_ADDROF,\n                     e.span,\n                     \"immediately dereferencing a reference\",\n                     \"try this\",\n-                    format!(\"{}\", snippet_with_applicability(cx, addrof_target.span, \"_\", &mut applicability)),\n+                    sugg,\n                     applicability,\n                 );\n             }"}, {"sha": "ede37624f71a4f1e7364cf4ae70af461c74dacf3", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,5 +1,5 @@\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -9,7 +9,10 @@ use rustc_span::sym;\n use if_chain::if_chain;\n \n use crate::utils::SpanlessEq;\n-use crate::utils::{get_parent_expr, is_allowed, is_type_diagnostic_item, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    get_parent_expr, is_allowed, is_type_diagnostic_item, match_function_call, method_calls, paths, span_lint,\n+    span_lint_and_sugg,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for string appends of the form `x = x + y` (without\n@@ -174,16 +177,75 @@ fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n     }\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Check if the string is transformed to byte array and casted back to string.\n+    ///\n+    /// **Why is this bad?** It's unnecessary, the string can be used directly.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = std::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]).unwrap();\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let _ = &\"Hello World!\"[6..11];\n+    /// ```\n+    pub STRING_FROM_UTF8_AS_BYTES,\n+    complexity,\n+    \"casting string slices to byte slices and back\"\n+}\n+\n // Max length a b\"foo\" string can take\n const MAX_LENGTH_BYTE_STRING_LIT: usize = 32;\n \n-declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES]);\n+declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES, STRING_FROM_UTF8_AS_BYTES]);\n \n impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use crate::utils::{snippet, snippet_with_applicability};\n         use rustc_ast::LitKind;\n \n+        if_chain! {\n+            // Find std::str::converts::from_utf8\n+            if let Some(args) = match_function_call(cx, e, &paths::STR_FROM_UTF8);\n+\n+            // Find string::as_bytes\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, ref args) = args[0].kind;\n+            if let ExprKind::Index(ref left, ref right) = args.kind;\n+            let (method_names, expressions, _) = method_calls(left, 1);\n+            if method_names.len() == 1;\n+            if expressions.len() == 1;\n+            if expressions[0].len() == 1;\n+            if method_names[0] == sym!(as_bytes);\n+\n+            // Check for slicer\n+            if let ExprKind::Struct(ref path, _, _) = right.kind;\n+            if let QPath::LangItem(LangItem::Range, _) = path;\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let string_expression = &expressions[0][0];\n+\n+                let snippet_app = snippet_with_applicability(\n+                    cx,\n+                    string_expression.span, \"..\",\n+                    &mut applicability,\n+                );\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    STRING_FROM_UTF8_AS_BYTES,\n+                    e.span,\n+                    \"calling a slice of `as_bytes()` with `from_utf8` should be not necessary\",\n+                    \"try\",\n+                    format!(\"Some(&{}[{}])\", snippet_app, snippet(cx, right.span, \"..\")),\n+                    applicability\n+                )\n+            }\n+        }\n+\n         if_chain! {\n             if let ExprKind::MethodCall(path, _, args, _) = &e.kind;\n             if path.ident.name == sym!(as_bytes);"}, {"sha": "73e3a04aec98798f93600e88ae791e3d7e6cc47c", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n-    span_lint_and_sugg,\n+    differing_macro_contexts, in_macro, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet,\n+    snippet_with_macro_callsite, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -92,8 +92,11 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n                 };\n \n                 let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n+                let differing_contexts = differing_macro_contexts(expr.span, err_arg.span);\n \n-                let origin_snippet = if err_arg.span.from_expansion() {\n+                let origin_snippet = if in_macro(expr.span) && in_macro(err_arg.span) && differing_contexts {\n+                    snippet(cx, err_arg.span.ctxt().outer_expn_data().call_site, \"_\")\n+                } else if err_arg.span.from_expansion() && !in_macro(expr.span) {\n                     snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n                 } else {\n                     snippet(cx, err_arg.span, \"_\")"}, {"sha": "f0e10e374e1182bc472c3f54b0209371ccc4543d", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -553,7 +553,7 @@ impl Types {\n                                     hir_ty.span,\n                                     \"`Vec<T>` is already on the heap, the boxing is unnecessary.\",\n                                     \"try\",\n-                                    format!(\"Vec<{}>\", ty_ty),\n+                                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n                                     Applicability::MachineApplicable,\n                                 );\n                                 return; // don't recurse into the type"}, {"sha": "f61fd2ecd735d915964c5b3ce80bfaa6da56e29e", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -7,7 +7,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n \n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{position_before_rarrow, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n@@ -120,26 +120,13 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n     let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        fn_source\n-            .rfind(\"->\")\n-            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-                let mut rpos = rpos;\n-                let chars: Vec<char> = fn_source.chars().collect();\n-                while rpos > 1 {\n-                    if let Some(c) = chars.get(rpos - 1) {\n-                        if c.is_whitespace() {\n-                            rpos -= 1;\n-                            continue;\n-                        }\n-                    }\n-                    break;\n-                }\n-                (\n-                    #[allow(clippy::cast_possible_truncation)]\n-                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                    Applicability::MachineApplicable,\n-                )\n-            })\n+        position_before_rarrow(fn_source).map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+            (\n+                #[allow(clippy::cast_possible_truncation)]\n+                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                Applicability::MachineApplicable,\n+            )\n+        })\n     } else {\n         (ty.span, Applicability::MaybeIncorrect)\n     };"}, {"sha": "8fe5ddee1ca8d8cf11d4ad300904cae10cc82ddf", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::utils::is_ctor_or_promotable_const_function;\n+use crate::utils::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;\n@@ -96,6 +96,11 @@ fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, ex\n             let call_found = match &expr.kind {\n                 // ignore enum and struct constructors\n                 ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n+                ExprKind::Index(obj, _) => {\n+                    let ty = self.cx.typeck_results().expr_ty(obj);\n+                    is_type_diagnostic_item(self.cx, ty, sym!(hashmap_type))\n+                        || match_type(self.cx, ty, &paths::BTREEMAP)\n+                },\n                 ExprKind::MethodCall(..) => true,\n                 _ => false,\n             };"}, {"sha": "cba3a0502499531c99da4bc2b89b32e105ca1fd6", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -468,6 +468,13 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n         .map_or(false, |(entry_fn_def_id, _)| def_id == entry_fn_def_id.to_def_id())\n }\n \n+/// Returns `true` if the expression is in the program's `#[panic_handler]`.\n+pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n+    Some(def_id) == cx.tcx.lang_items().panic_impl()\n+}\n+\n /// Gets the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n@@ -659,6 +666,35 @@ pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n     snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n+/// Returns the positon just before rarrow\n+///\n+/// ```rust,ignore\n+/// fn into(self) -> () {}\n+///              ^\n+/// // in case of unformatted code\n+/// fn into2(self)-> () {}\n+///               ^\n+/// fn into3(self)   -> () {}\n+///               ^\n+/// ```\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn position_before_rarrow(s: String) -> Option<usize> {\n+    s.rfind(\"->\").map(|rpos| {\n+        let mut rpos = rpos;\n+        let chars: Vec<char> = s.chars().collect();\n+        while rpos > 1 {\n+            if let Some(c) = chars.get(rpos - 1) {\n+                if c.is_whitespace() {\n+                    rpos -= 1;\n+                    continue;\n+                }\n+            }\n+            break;\n+        }\n+        rpos\n+    })\n+}\n+\n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n ///\n /// ```rust,ignore"}, {"sha": "2be5ff93f86959efd637996f0805417359260170", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -122,6 +122,7 @@ pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n+pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];"}, {"sha": "4f1b56ed9bee5ca5092ab0639e4a19a5992b6701", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1117,6 +1117,13 @@ vec![\n         deprecation: None,\n         module: \"returns\",\n     },\n+    Lint {\n+        name: \"let_underscore_drop\",\n+        group: \"pedantic\",\n+        desc: \"non-binding let on a type that implements `Drop`\",\n+        deprecation: None,\n+        module: \"let_underscore\",\n+    },\n     Lint {\n         name: \"let_underscore_lock\",\n         group: \"correctness\",\n@@ -2258,6 +2265,13 @@ vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"string_from_utf8_as_bytes\",\n+        group: \"complexity\",\n+        desc: \"casting string slices to byte slices and back\",\n+        deprecation: None,\n+        module: \"strings\",\n+    },\n     Lint {\n         name: \"string_lit_as_bytes\",\n         group: \"nursery\","}, {"sha": "2289f7875f04c7007e54cdf1666b5fc820cc01aa", "filename": "tests/ui/borrow_interior_mutable_const/auxiliary/helper.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fauxiliary%2Fhelper.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,16 @@\n+// this file solely exists to test constants defined in foreign crates.\n+// As the most common case is the `http` crate, it replicates `http::HeadewrName`'s structure.\n+\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+use std::sync::atomic::AtomicUsize;\n+\n+enum Private<T> {\n+    ToBeUnfrozen(T),\n+    Frozen(usize),\n+}\n+\n+pub struct Wrapper(Private<AtomicUsize>);\n+\n+pub const WRAPPED_PRIVATE_UNFROZEN_VARIANT: Wrapper = Wrapper(Private::ToBeUnfrozen(AtomicUsize::new(6)));\n+pub const WRAPPED_PRIVATE_FROZEN_VARIANT: Wrapper = Wrapper(Private::Frozen(7));"}, {"sha": "5027db44561798d1ba05fe0e692af592da2612b5", "filename": "tests/ui/borrow_interior_mutable_const/enums.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,101 @@\n+// aux-build:helper.rs\n+\n+#![warn(clippy::borrow_interior_mutable_const)]\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+// this file (mostly) replicates its `declare` counterpart. Please see it for more discussions.\n+\n+extern crate helper;\n+\n+use std::cell::Cell;\n+use std::sync::atomic::AtomicUsize;\n+\n+enum OptionalCell {\n+    Unfrozen(Cell<bool>),\n+    Frozen,\n+}\n+\n+const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true));\n+const FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+fn borrow_optional_cell() {\n+    let _ = &UNFROZEN_VARIANT; //~ ERROR interior mutability\n+    let _ = &FROZEN_VARIANT;\n+}\n+\n+trait AssocConsts {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell;\n+    const TO_BE_FROZEN_VARIANT: OptionalCell;\n+\n+    const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    fn function() {\n+        // This is the \"suboptimal behavior\" mentioned in `is_value_unfrozen`\n+        // caused by a similar reason to unfrozen types without any default values\n+        // get linted even if it has frozen variants'.\n+        let _ = &Self::TO_BE_FROZEN_VARIANT; //~ ERROR interior mutable\n+\n+        // The lint ignores default values because an impl of this trait can set\n+        // an unfrozen variant to `DEFAULTED_ON_FROZEN_VARIANT` and use the default impl for `function`.\n+        let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl AssocConsts for u64 {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const TO_BE_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    fn function() {\n+        let _ = &<Self as AssocConsts>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &<Self as AssocConsts>::TO_BE_FROZEN_VARIANT;\n+        let _ = &Self::DEFAULTED_ON_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT;\n+    }\n+}\n+\n+trait AssocTypes {\n+    type ToBeUnfrozen;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+\n+    // there's no need to test here because it's the exactly same as `trait::AssocTypes`\n+    fn function();\n+}\n+\n+impl AssocTypes for u64 {\n+    type ToBeUnfrozen = AtomicUsize;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen> = None;\n+\n+    fn function() {\n+        let _ = &<Self as AssocTypes>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+        let _ = &<Self as AssocTypes>::TO_BE_FROZEN_VARIANT;\n+    }\n+}\n+\n+enum BothOfCellAndGeneric<T> {\n+    Unfrozen(Cell<*const T>),\n+    Generic(*const T),\n+    Frozen(usize),\n+}\n+\n+impl<T> BothOfCellAndGeneric<T> {\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Frozen(5);\n+\n+    fn function() {\n+        let _ = &Self::UNFROZEN_VARIANT; //~ ERROR interior mutability\n+        let _ = &Self::GENERIC_VARIANT; //~ ERROR interior mutability\n+        let _ = &Self::FROZEN_VARIANT;\n+    }\n+}\n+\n+fn main() {\n+    // constants defined in foreign crates\n+    let _ = &helper::WRAPPED_PRIVATE_UNFROZEN_VARIANT; //~ ERROR interior mutability\n+    let _ = &helper::WRAPPED_PRIVATE_FROZEN_VARIANT;\n+}"}, {"sha": "654a1ee7df659a402e4fb4404f43c65f00603cfe", "filename": "tests/ui/borrow_interior_mutable_const/enums.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fenums.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,75 @@\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:22:14\n+   |\n+LL |     let _ = &UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |              ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:37:18\n+   |\n+LL |         let _ = &Self::TO_BE_FROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:41:18\n+   |\n+LL |         let _ = &Self::DEFAULTED_ON_FROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:50:18\n+   |\n+LL |         let _ = &<Self as AssocConsts>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:52:18\n+   |\n+LL |         let _ = &Self::DEFAULTED_ON_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:74:18\n+   |\n+LL |         let _ = &<Self as AssocTypes>::TO_BE_UNFROZEN_VARIANT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:91:18\n+   |\n+LL |         let _ = &Self::UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:92:18\n+   |\n+LL |         let _ = &Self::GENERIC_VARIANT; //~ ERROR interior mutability\n+   |                  ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/enums.rs:99:14\n+   |\n+LL |     let _ = &helper::WRAPPED_PRIVATE_UNFROZEN_VARIANT; //~ ERROR interior mutability\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "ea25729d11d4db08ae7c57c96bb0bf9bf09b05ff", "filename": "tests/ui/borrow_interior_mutable_const/others.rs", "status": "renamed", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -19,33 +19,7 @@ const NO_ANN: &dyn Display = &70;\n static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n const ONCE_INIT: Once = Once::new();\n \n-trait Trait<T> {\n-    type AssocType;\n-\n-    const ATOMIC: AtomicUsize;\n-    const INPUT: T;\n-    const ASSOC: Self::AssocType;\n-\n-    fn function() {\n-        let _ = &Self::INPUT;\n-        let _ = &Self::ASSOC;\n-    }\n-}\n-\n-impl Trait<u32> for u64 {\n-    type AssocType = AtomicUsize;\n-\n-    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n-    const INPUT: u32 = 10;\n-    const ASSOC: Self::AssocType = AtomicUsize::new(11);\n-\n-    fn function() {\n-        let _ = &Self::INPUT;\n-        let _ = &Self::ASSOC; //~ ERROR interior mutability\n-    }\n-}\n-\n-// This is just a pointer that can be safely dereferended,\n+// This is just a pointer that can be safely dereferenced,\n // it's semantically the same as `&'static T`;\n // but it isn't allowed to make a static reference from an arbitrary integer value at the moment.\n // For more information, please see the issue #5918.\n@@ -100,7 +74,7 @@ fn main() {\n     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n-    let _ = &*ATOMIC_TUPLE.1; //~ ERROR interior mutability\n+    let _ = &*ATOMIC_TUPLE.1;\n     let _ = &ATOMIC_TUPLE.2;\n     let _ = (&&&&ATOMIC_TUPLE).0;\n     let _ = (&&&&ATOMIC_TUPLE).2;\n@@ -124,9 +98,6 @@ fn main() {\n     assert_eq!(STATIC_TUPLE.0.load(Ordering::SeqCst), 3);\n     assert!(STATIC_TUPLE.1.is_empty());\n \n-    u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n-    assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n-\n     assert_eq!(NO_ANN.to_string(), \"70\"); // should never lint this.\n \n     let _ = &CELL_REF.0;", "previous_filename": "tests/ui/borrow_interior_mutable_const.rs"}, {"sha": "9a908cf30e945cc100e1a98126448250704031f0", "filename": "tests/ui/borrow_interior_mutable_const/others.stderr", "status": "renamed", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,139 +1,115 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:44:18\n-   |\n-LL |         let _ = &Self::ASSOC; //~ ERROR interior mutability\n-   |                  ^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:80:5\n+  --> $DIR/others.rs:54:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n    |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:81:16\n+  --> $DIR/others.rs:55:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:84:22\n+  --> $DIR/others.rs:58:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:85:25\n+  --> $DIR/others.rs:59:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:86:27\n+  --> $DIR/others.rs:60:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:87:26\n+  --> $DIR/others.rs:61:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:98:14\n+  --> $DIR/others.rs:72:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:99:14\n+  --> $DIR/others.rs:73:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:100:19\n+  --> $DIR/others.rs:74:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:101:14\n+  --> $DIR/others.rs:75:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:102:13\n+  --> $DIR/others.rs:76:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:108:13\n+  --> $DIR/others.rs:82:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:113:5\n+  --> $DIR/others.rs:87:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:114:16\n+  --> $DIR/others.rs:88:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:127:5\n-   |\n-LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n-   |     ^^^^^^^^^^^\n-   |\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/borrow_interior_mutable_const.rs:128:16\n-   |\n-LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n-   |                ^^^^^^^^^^^\n-   |\n-   = help: assign this const to a local or static variable, and use the variable here\n-\n-error: aborting due to 17 previous errors\n+error: aborting due to 14 previous errors\n ", "previous_filename": "tests/ui/borrow_interior_mutable_const.stderr"}, {"sha": "06b5d62e8f9a816706e03fb174c9a28a5e95189f", "filename": "tests/ui/borrow_interior_mutable_const/traits.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,202 @@\n+#![warn(clippy::borrow_interior_mutable_const)]\n+#![allow(clippy::declare_interior_mutable_const)]\n+\n+// this file replicates its `declare` counterpart. Please see it for more discussions.\n+\n+use std::borrow::Cow;\n+use std::cell::Cell;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+trait ConcreteTypes {\n+    const ATOMIC: AtomicUsize;\n+    const STRING: String;\n+\n+    fn function() {\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::STRING;\n+    }\n+}\n+\n+impl ConcreteTypes for u64 {\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(9);\n+    const STRING: String = String::new();\n+\n+    fn function() {\n+        // Lint this again since implementers can choose not to borrow it.\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::STRING;\n+    }\n+}\n+\n+// a helper trait used below\n+trait ConstDefault {\n+    const DEFAULT: Self;\n+}\n+\n+trait GenericTypes<T, U> {\n+    const TO_REMAIN_GENERIC: T;\n+    const TO_BE_CONCRETE: U;\n+\n+    fn function() {\n+        let _ = &Self::TO_REMAIN_GENERIC;\n+    }\n+}\n+\n+impl<T: ConstDefault> GenericTypes<T, AtomicUsize> for Vec<T> {\n+    const TO_REMAIN_GENERIC: T = T::DEFAULT;\n+    const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11);\n+\n+    fn function() {\n+        let _ = &Self::TO_REMAIN_GENERIC;\n+        let _ = &Self::TO_BE_CONCRETE; //~ ERROR interior mutable\n+    }\n+}\n+\n+// a helper type used below\n+pub struct Wrapper<T>(T);\n+\n+trait AssocTypes {\n+    type ToBeFrozen;\n+    type ToBeUnfrozen;\n+    type ToBeGenericParam;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen;\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen>;\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam>;\n+\n+    fn function() {\n+        let _ = &Self::TO_BE_FROZEN;\n+        let _ = &Self::WRAPPED_TO_BE_UNFROZEN;\n+    }\n+}\n+\n+impl<T: ConstDefault> AssocTypes for Vec<T> {\n+    type ToBeFrozen = u16;\n+    type ToBeUnfrozen = AtomicUsize;\n+    type ToBeGenericParam = T;\n+\n+    const TO_BE_FROZEN: Self::ToBeFrozen = 12;\n+    const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13);\n+    const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14));\n+    const WRAPPED_TO_BE_GENERIC_PARAM: Wrapper<Self::ToBeGenericParam> = Wrapper(T::DEFAULT);\n+\n+    fn function() {\n+        let _ = &Self::TO_BE_FROZEN;\n+        let _ = &Self::TO_BE_UNFROZEN; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_TO_BE_UNFROZEN; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_TO_BE_GENERIC_PARAM;\n+    }\n+}\n+\n+// a helper trait used below\n+trait AssocTypesHelper {\n+    type NotToBeBounded;\n+    type ToBeBounded;\n+\n+    const NOT_TO_BE_BOUNDED: Self::NotToBeBounded;\n+}\n+\n+trait AssocTypesFromGenericParam<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded;\n+    const BOUNDED: T::ToBeBounded;\n+\n+    fn function() {\n+        let _ = &Self::NOT_BOUNDED;\n+        let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl<T> AssocTypesFromGenericParam<T> for Vec<T>\n+where\n+    T: AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const NOT_BOUNDED: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED: T::ToBeBounded = AtomicUsize::new(15);\n+\n+    fn function() {\n+        let _ = &Self::NOT_BOUNDED;\n+        let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+    }\n+}\n+\n+trait SelfType: Sized {\n+    const SELF: Self;\n+    const WRAPPED_SELF: Option<Self>;\n+\n+    fn function() {\n+        let _ = &Self::SELF;\n+        let _ = &Self::WRAPPED_SELF;\n+    }\n+}\n+\n+impl SelfType for u64 {\n+    const SELF: Self = 16;\n+    const WRAPPED_SELF: Option<Self> = Some(20);\n+\n+    fn function() {\n+        let _ = &Self::SELF;\n+        let _ = &Self::WRAPPED_SELF;\n+    }\n+}\n+\n+impl SelfType for AtomicUsize {\n+    const SELF: Self = AtomicUsize::new(17);\n+    const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21));\n+\n+    fn function() {\n+        let _ = &Self::SELF; //~ ERROR interior mutable\n+        let _ = &Self::WRAPPED_SELF; //~ ERROR interior mutable\n+    }\n+}\n+\n+trait BothOfCellAndGeneric<T> {\n+    const DIRECT: Cell<T>;\n+    const INDIRECT: Cell<*const T>;\n+\n+    fn function() {\n+        let _ = &Self::DIRECT;\n+        let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+    }\n+}\n+\n+impl<T: ConstDefault> BothOfCellAndGeneric<T> for Vec<T> {\n+    const DIRECT: Cell<T> = Cell::new(T::DEFAULT);\n+    const INDIRECT: Cell<*const T> = Cell::new(std::ptr::null());\n+\n+    fn function() {\n+        let _ = &Self::DIRECT;\n+        let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+    }\n+}\n+\n+struct Local<T>(T);\n+\n+impl<T> Local<T>\n+where\n+    T: ConstDefault + AssocTypesHelper<ToBeBounded = AtomicUsize>,\n+{\n+    const ATOMIC: AtomicUsize = AtomicUsize::new(18);\n+    const COW: Cow<'static, str> = Cow::Borrowed(\"tuvwxy\");\n+\n+    const GENERIC_TYPE: T = T::DEFAULT;\n+\n+    const ASSOC_TYPE: T::NotToBeBounded = T::NOT_TO_BE_BOUNDED;\n+    const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19);\n+\n+    fn function() {\n+        let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+        let _ = &Self::COW;\n+        let _ = &Self::GENERIC_TYPE;\n+        let _ = &Self::ASSOC_TYPE;\n+        let _ = &Self::BOUNDED_ASSOC_TYPE; //~ ERROR interior mutable\n+    }\n+}\n+\n+fn main() {\n+    u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+    assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+}"}, {"sha": "8f26403abd3ee0444c0f05a52e4cad2677f0b065", "filename": "tests/ui/borrow_interior_mutable_const/traits.stderr", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Ftraits.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,123 @@\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:15:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::borrow-interior-mutable-const` implied by `-D warnings`\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:26:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:51:18\n+   |\n+LL |         let _ = &Self::TO_BE_CONCRETE; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:86:18\n+   |\n+LL |         let _ = &Self::TO_BE_UNFROZEN; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:87:18\n+   |\n+LL |         let _ = &Self::WRAPPED_TO_BE_UNFROZEN; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:109:18\n+   |\n+LL |         let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:122:18\n+   |\n+LL |         let _ = &Self::BOUNDED; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:151:18\n+   |\n+LL |         let _ = &Self::SELF; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:152:18\n+   |\n+LL |         let _ = &Self::WRAPPED_SELF; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:162:18\n+   |\n+LL |         let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:172:18\n+   |\n+LL |         let _ = &Self::INDIRECT; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:191:18\n+   |\n+LL |         let _ = &Self::ATOMIC; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:195:18\n+   |\n+LL |         let _ = &Self::BOUNDED_ASSOC_TYPE; //~ ERROR interior mutable\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:200:5\n+   |\n+LL |     u64::ATOMIC.store(5, Ordering::SeqCst); //~ ERROR interior mutability\n+   |     ^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: a `const` item with interior mutability should not be borrowed\n+  --> $DIR/traits.rs:201:16\n+   |\n+LL |     assert_eq!(u64::ATOMIC.load(Ordering::SeqCst), 9); //~ ERROR interior mutability\n+   |                ^^^^^^^^^^^\n+   |\n+   = help: assign this const to a local or static variable, and use the variable here\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "0eb7bb12b3546e85ad492460d28736886f1bd02b", "filename": "tests/ui/crashes/ice-360.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fcrashes%2Fice-360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fcrashes%2Fice-360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-360.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -19,7 +19,7 @@ LL |         loop {}\n    |         ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n-   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+   = help: you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f44518694b89c309bc4ae14326f112367a878ac5", "filename": "tests/ui/declare_interior_mutable_const/enums.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,123 @@\n+#![warn(clippy::declare_interior_mutable_const)]\n+\n+use std::cell::Cell;\n+use std::sync::atomic::AtomicUsize;\n+\n+enum OptionalCell {\n+    Unfrozen(Cell<bool>),\n+    Frozen,\n+}\n+\n+// a constant with enums should be linted only when the used variant is unfrozen (#3962).\n+const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true)); //~ ERROR interior mutable\n+const FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+const fn unfrozen_variant() -> OptionalCell {\n+    OptionalCell::Unfrozen(Cell::new(false))\n+}\n+\n+const fn frozen_variant() -> OptionalCell {\n+    OptionalCell::Frozen\n+}\n+\n+const UNFROZEN_VARIANT_FROM_FN: OptionalCell = unfrozen_variant(); //~ ERROR interior mutable\n+const FROZEN_VARIANT_FROM_FN: OptionalCell = frozen_variant();\n+\n+enum NestedInnermost {\n+    Unfrozen(AtomicUsize),\n+    Frozen,\n+}\n+\n+struct NestedInner {\n+    inner: NestedInnermost,\n+}\n+\n+enum NestedOuter {\n+    NestedInner(NestedInner),\n+    NotNested(usize),\n+}\n+\n+struct NestedOutermost {\n+    outer: NestedOuter,\n+}\n+\n+// a constant with enums should be linted according to its value, no matter how structs involve.\n+const NESTED_UNFROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+    outer: NestedOuter::NestedInner(NestedInner {\n+        inner: NestedInnermost::Unfrozen(AtomicUsize::new(2)),\n+    }),\n+}; //~ ERROR interior mutable\n+const NESTED_FROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+    outer: NestedOuter::NestedInner(NestedInner {\n+        inner: NestedInnermost::Frozen,\n+    }),\n+};\n+\n+trait AssocConsts {\n+    // When there's no default value, lint it only according to its type.\n+    // Further details are on the corresponding code (`NonCopyConst::check_trait_item`).\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+\n+    // Lint default values accordingly.\n+    const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false)); //~ ERROR interior mutable\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+}\n+\n+// The lint doesn't trigger for an assoc constant in a trait impl with an unfrozen type even if it\n+// has enums. Further details are on the corresponding code in 'NonCopyConst::check_impl_item'.\n+impl AssocConsts for u64 {\n+    const TO_BE_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+    const TO_BE_FROZEN_VARIANT: OptionalCell = OptionalCell::Frozen;\n+\n+    // even if this sets an unfrozen variant, the lint ignores it.\n+    const DEFAULTED_ON_FROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false));\n+}\n+\n+// At first, I thought I'd need to check every patterns in `trait.rs`; but, what matters\n+// here are values; and I think substituted generics at definitions won't appear in MIR.\n+trait AssocTypes {\n+    type ToBeUnfrozen;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen>;\n+}\n+\n+impl AssocTypes for u64 {\n+    type ToBeUnfrozen = AtomicUsize;\n+\n+    const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+    const TO_BE_FROZEN_VARIANT: Option<Self::ToBeUnfrozen> = None;\n+}\n+\n+// Use raw pointers since direct generics have a false negative at the type level.\n+enum BothOfCellAndGeneric<T> {\n+    Unfrozen(Cell<*const T>),\n+    Generic(*const T),\n+    Frozen(usize),\n+}\n+\n+impl<T> BothOfCellAndGeneric<T> {\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+\n+    // This is a false positive. The argument about this is on `is_value_unfrozen_raw`\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Frozen(5);\n+\n+    // This is what is likely to be a false negative when one tries to fix\n+    // the `GENERIC_VARIANT` false positive.\n+    const NO_ENUM: Cell<*const T> = Cell::new(std::ptr::null()); //~ ERROR interior mutable\n+}\n+\n+// associated types here is basically the same as the one above.\n+trait BothOfCellAndGenericWithAssocType {\n+    type AssocType;\n+\n+    const UNFROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> =\n+        BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+    const GENERIC_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+    const FROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Frozen(5);\n+}\n+\n+fn main() {}"}, {"sha": "84198d5461578ca4c1ff4e95ca895be899db748e", "filename": "tests/ui/declare_interior_mutable_const/enums.stderr", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fenums.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,89 @@\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:12:1\n+   |\n+LL | const UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(true)); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:23:1\n+   |\n+LL | const UNFROZEN_VARIANT_FROM_FN: OptionalCell = unfrozen_variant(); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:45:1\n+   |\n+LL |   const NESTED_UNFROZEN_VARIANT: NestedOutermost = NestedOutermost {\n+   |   ^----\n+   |   |\n+   |  _make this a static item (maybe with lazy_static)\n+   | |\n+LL | |     outer: NestedOuter::NestedInner(NestedInner {\n+LL | |         inner: NestedInnermost::Unfrozen(AtomicUsize::new(2)),\n+LL | |     }),\n+LL | | }; //~ ERROR interior mutable\n+   | |__^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:59:5\n+   |\n+LL |     const TO_BE_UNFROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:60:5\n+   |\n+LL |     const TO_BE_FROZEN_VARIANT: OptionalCell; //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:63:5\n+   |\n+LL |     const DEFAULTED_ON_UNFROZEN_VARIANT: OptionalCell = OptionalCell::Unfrozen(Cell::new(false)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:89:5\n+   |\n+LL |     const TO_BE_UNFROZEN_VARIANT: Option<Self::ToBeUnfrozen> = Some(Self::ToBeUnfrozen::new(4)); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:101:5\n+   |\n+LL |     const UNFROZEN_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mut...\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:104:5\n+   |\n+LL |     const GENERIC_VARIANT: BothOfCellAndGeneric<T> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:110:5\n+   |\n+LL |     const NO_ENUM: Cell<*const T> = Cell::new(std::ptr::null()); //~ ERROR interior mutable\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:117:5\n+   |\n+LL | /     const UNFROZEN_VARIANT: BothOfCellAndGeneric<Self::AssocType> =\n+LL | |         BothOfCellAndGeneric::Unfrozen(Cell::new(std::ptr::null())); //~ ERROR interior mutable\n+   | |____________________________________________________________________^\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/enums.rs:119:5\n+   |\n+LL |     const GENERIC_VARIANT: BothOfCellAndGeneric<Self::AssocType> = BothOfCellAndGeneric::Generic(std::ptr::null()); //~ ERROR interior mu...\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "48c5e9537d6d088111316151823a6c838e55e5c4", "filename": "tests/ui/declare_interior_mutable_const/others.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,34 @@\n+#![warn(clippy::declare_interior_mutable_const)]\n+\n+use std::borrow::Cow;\n+use std::cell::Cell;\n+use std::fmt::Display;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Once;\n+\n+const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+//~^ ERROR interior mutable\n+\n+macro_rules! declare_const {\n+    ($name:ident: $ty:ty = $e:expr) => {\n+        const $name: $ty = $e;\n+    };\n+}\n+declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+\n+// const ATOMIC_REF: &AtomicUsize = &AtomicUsize::new(7); // This will simply trigger E0492.\n+\n+const INTEGER: u8 = 8;\n+const STRING: String = String::new();\n+const STR: &str = \"012345\";\n+const COW: Cow<str> = Cow::Borrowed(\"abcdef\");\n+//^ note: a const item of Cow is used in the `postgres` package.\n+\n+const NO_ANN: &dyn Display = &70;\n+\n+static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n+//^ there should be no lints on this line\n+\n+fn main() {}"}, {"sha": "6153c96edc4f425e254084377242028e490203cb", "filename": "tests/ui/declare_interior_mutable_const/others.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Fothers.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,39 @@\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:9:1\n+   |\n+LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:10:1\n+   |\n+LL | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:11:1\n+   |\n+LL | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | make this a static item (maybe with lazy_static)\n+\n+error: a `const` item should never be interior mutable\n+  --> $DIR/others.rs:16:9\n+   |\n+LL |         const $name: $ty = $e;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n+   | ------------------------------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "535147ccc645121259280495102cb985c4905d15", "filename": "tests/ui/declare_interior_mutable_const/traits.rs", "status": "renamed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -2,37 +2,13 @@\n \n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::fmt::Display;\n use std::sync::atomic::AtomicUsize;\n-use std::sync::Once;\n-\n-const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n-const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n-const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n-//~^ ERROR interior mutable\n \n macro_rules! declare_const {\n     ($name:ident: $ty:ty = $e:expr) => {\n         const $name: $ty = $e;\n     };\n }\n-declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n-\n-// const ATOMIC_REF: &AtomicUsize = &AtomicUsize::new(7); // This will simply trigger E0492.\n-\n-const INTEGER: u8 = 8;\n-const STRING: String = String::new();\n-const STR: &str = \"012345\";\n-const COW: Cow<str> = Cow::Borrowed(\"abcdef\");\n-//^ note: a const item of Cow is used in the `postgres` package.\n-\n-const NO_ANN: &dyn Display = &70;\n-\n-static STATIC_TUPLE: (AtomicUsize, String) = (ATOMIC, STRING);\n-//^ there should be no lints on this line\n-\n-#[allow(clippy::declare_interior_mutable_const)]\n-const ONCE_INIT: Once = Once::new();\n \n // a constant whose type is a concrete type should be linted at the definition site.\n trait ConcreteTypes {", "previous_filename": "tests/ui/declare_interior_mutable_const.rs"}, {"sha": "bb77f39b62c1f668a2729b871c728ecb66567816", "filename": "tests/ui/declare_interior_mutable_const/traits.stderr", "status": "renamed", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeclare_interior_mutable_const%2Ftraits.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,48 +1,13 @@\n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:9:1\n-   |\n-LL | const ATOMIC: AtomicUsize = AtomicUsize::new(5); //~ ERROR interior mutable\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-   |\n-   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:10:1\n-   |\n-LL | const CELL: Cell<usize> = Cell::new(6); //~ ERROR interior mutable\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:11:1\n-   |\n-LL | const ATOMIC_TUPLE: ([AtomicUsize; 1], Vec<AtomicUsize>, u8) = ([ATOMIC], Vec::new(), 7);\n-   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   | |\n-   | make this a static item (maybe with lazy_static)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n-   |\n-LL |         const $name: $ty = $e;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL | declare_const!(_ONCE: Once = Once::new()); //~ ERROR interior mutable\n-   | ------------------------------------------ in this macro invocation\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:39:5\n+  --> $DIR/traits.rs:15:5\n    |\n LL |     const ATOMIC: AtomicUsize; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::declare-interior-mutable-const` implied by `-D warnings`\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:16:9\n+  --> $DIR/traits.rs:9:9\n    |\n LL |         const $name: $ty = $e;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,58 +18,58 @@ LL |     declare_const!(ANOTHER_ATOMIC: AtomicUsize = Self::ATOMIC); //~ ERROR i\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:67:5\n+  --> $DIR/traits.rs:43:5\n    |\n LL |     const TO_BE_CONCRETE: AtomicUsize = AtomicUsize::new(11); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:92:5\n+  --> $DIR/traits.rs:68:5\n    |\n LL |     const TO_BE_UNFROZEN: Self::ToBeUnfrozen = AtomicUsize::new(13); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:93:5\n+  --> $DIR/traits.rs:69:5\n    |\n LL |     const WRAPPED_TO_BE_UNFROZEN: Wrapper<Self::ToBeUnfrozen> = Wrapper(AtomicUsize::new(14)); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:112:5\n+  --> $DIR/traits.rs:88:5\n    |\n LL |     const BOUNDED: T::ToBeBounded; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:140:5\n+  --> $DIR/traits.rs:116:5\n    |\n LL |     const SELF: Self = AtomicUsize::new(17); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:141:5\n+  --> $DIR/traits.rs:117:5\n    |\n LL |     const WRAPPED_SELF: Option<Self> = Some(AtomicUsize::new(21)); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:149:5\n+  --> $DIR/traits.rs:125:5\n    |\n LL |     const INDIRECT: Cell<*const T>; //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:165:5\n+  --> $DIR/traits.rs:141:5\n    |\n LL |     const ATOMIC: AtomicUsize = AtomicUsize::new(18); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: a `const` item should never be interior mutable\n-  --> $DIR/declare_interior_mutable_const.rs:171:5\n+  --> $DIR/traits.rs:147:5\n    |\n LL |     const BOUNDED_ASSOC_TYPE: T::ToBeBounded = AtomicUsize::new(19); //~ ERROR interior mutable\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 11 previous errors\n ", "previous_filename": "tests/ui/declare_interior_mutable_const.stderr"}, {"sha": "0795900558b695824bdead9959b7201313b13034", "filename": "tests/ui/deref_addrof.fixed", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![warn(clippy::deref_addrof)]\n \n fn get_number() -> usize {\n     10\n@@ -10,7 +11,6 @@ fn get_reference(n: &usize) -> &usize {\n \n #[allow(clippy::many_single_char_names, clippy::double_parens)]\n #[allow(unused_variables, unused_parens)]\n-#[warn(clippy::deref_addrof)]\n fn main() {\n     let a = 10;\n     let aref = &a;\n@@ -37,3 +37,27 @@ fn main() {\n \n     let b = *aref;\n }\n+\n+#[rustfmt::skip]\n+macro_rules! m {\n+    ($visitor: expr) => {\n+        $visitor\n+    };\n+}\n+\n+#[rustfmt::skip]\n+macro_rules! m_mut {\n+    ($visitor: expr) => {\n+        $visitor\n+    };\n+}\n+\n+pub struct S;\n+impl S {\n+    pub fn f(&self) -> &Self {\n+        m!(self)\n+    }\n+    pub fn f_mut(&self) -> &Self {\n+        m_mut!(self)\n+    }\n+}"}, {"sha": "60c4318601bc881799a07d7e6e7ffdcbd3886957", "filename": "tests/ui/deref_addrof.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![warn(clippy::deref_addrof)]\n \n fn get_number() -> usize {\n     10\n@@ -10,7 +11,6 @@ fn get_reference(n: &usize) -> &usize {\n \n #[allow(clippy::many_single_char_names, clippy::double_parens)]\n #[allow(unused_variables, unused_parens)]\n-#[warn(clippy::deref_addrof)]\n fn main() {\n     let a = 10;\n     let aref = &a;\n@@ -37,3 +37,27 @@ fn main() {\n \n     let b = **&aref;\n }\n+\n+#[rustfmt::skip]\n+macro_rules! m {\n+    ($visitor: expr) => {\n+        *& $visitor\n+    };\n+}\n+\n+#[rustfmt::skip]\n+macro_rules! m_mut {\n+    ($visitor: expr) => {\n+        *& mut $visitor\n+    };\n+}\n+\n+pub struct S;\n+impl S {\n+    pub fn f(&self) -> &Self {\n+        m!(self)\n+    }\n+    pub fn f_mut(&self) -> &Self {\n+        m_mut!(self)\n+    }\n+}"}, {"sha": "e85b30fa56eb884ff719241f62e659a57b3cc7fd", "filename": "tests/ui/deref_addrof.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fderef_addrof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -48,5 +48,27 @@ error: immediately dereferencing a reference\n LL |     let b = **&aref;\n    |              ^^^^^^ help: try this: `aref`\n \n-error: aborting due to 8 previous errors\n+error: immediately dereferencing a reference\n+  --> $DIR/deref_addrof.rs:44:9\n+   |\n+LL |         *& $visitor\n+   |         ^^^^^^^^^^^ help: try this: `$visitor`\n+...\n+LL |         m!(self)\n+   |         -------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: immediately dereferencing a reference\n+  --> $DIR/deref_addrof.rs:51:9\n+   |\n+LL |         *& mut $visitor\n+   |         ^^^^^^^^^^^^^^^ help: try this: `$visitor`\n+...\n+LL |         m_mut!(self)\n+   |         ------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "555f3d3d884a9d6d6a5f4f7520d4b152a53cfd24", "filename": "tests/ui/empty_loop.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_loop.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -5,23 +5,23 @@ LL |     loop {}\n    |     ^^^^^^^\n    |\n    = note: `-D clippy::empty-loop` implied by `-D warnings`\n-   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+   = help: you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\n \n error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:11:9\n    |\n LL |         loop {}\n    |         ^^^^^^^\n    |\n-   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+   = help: you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\n \n error: empty `loop {}` wastes CPU cycles\n   --> $DIR/empty_loop.rs:15:9\n    |\n LL |         'inner: loop {}\n    |         ^^^^^^^^^^^^^^^\n    |\n-   = help: You should either use `panic!()` or add `std::thread::sleep(..);` to the loop body.\n+   = help: you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4553d3ec505a33846cce213690a5a6905ef3330c", "filename": "tests/ui/empty_loop_no_std.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_loop_no_std.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -10,13 +10,18 @@ use core::panic::PanicInfo;\n \n #[start]\n fn main(argc: isize, argv: *const *const u8) -> isize {\n+    // This should trigger the lint\n     loop {}\n }\n \n #[panic_handler]\n fn panic(_info: &PanicInfo) -> ! {\n+    // This should NOT trigger the lint\n     loop {}\n }\n \n #[lang = \"eh_personality\"]\n-extern \"C\" fn eh_personality() {}\n+extern \"C\" fn eh_personality() {\n+    // This should also trigger the lint\n+    loop {}\n+}"}, {"sha": "520248fcb689c4e52b3a39c65873f0e2fc4d547d", "filename": "tests/ui/empty_loop_no_std.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop_no_std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fempty_loop_no_std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_loop_no_std.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,19 @@\n+error: empty `loop {}` wastes CPU cycles\n+  --> $DIR/empty_loop_no_std.rs:14:5\n+   |\n+LL |     loop {}\n+   |     ^^^^^^^\n+   |\n+   = note: `-D clippy::empty-loop` implied by `-D warnings`\n+   = help: you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\n+\n+error: empty `loop {}` wastes CPU cycles\n+  --> $DIR/empty_loop_no_std.rs:26:5\n+   |\n+LL |     loop {}\n+   |     ^^^^^^^\n+   |\n+   = help: you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "514502416192640890c0c436981abcdb800f4d5e", "filename": "tests/ui/filter_methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ffilter_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ffilter_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_methods.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::all, clippy::pedantic)]\n+#![allow(clippy::clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n \n fn main() {"}, {"sha": "119226813793c172aba83986b6f15830039a6e5f", "filename": "tests/ui/filter_methods.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ffilter_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ffilter_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_methods.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,5 +1,5 @@\n error: called `filter(..).map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:5:21\n+  --> $DIR/filter_methods.rs:6:21\n    |\n LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x * 2).collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     let _: Vec<_> = vec![5; 6].into_iter().filter(|&x| x == 0).map(|x| x *\n    = help: this is more succinctly expressed by calling `.filter_map(..)` instead\n \n error: called `filter(..).flat_map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:7:21\n+  --> $DIR/filter_methods.rs:8:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n    |  _____________________^\n@@ -20,7 +20,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n error: called `filter_map(..).flat_map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:13:21\n+  --> $DIR/filter_methods.rs:14:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n    |  _____________________^\n@@ -32,7 +32,7 @@ LL | |         .flat_map(|x| x.checked_mul(2))\n    = help: this is more succinctly expressed by calling `.flat_map(..)` and filtering by returning `iter::empty()`\n \n error: called `filter_map(..).map(..)` on an `Iterator`\n-  --> $DIR/filter_methods.rs:19:21\n+  --> $DIR/filter_methods.rs:20:21\n    |\n LL |       let _: Vec<_> = vec![5_i8; 6]\n    |  _____________________^"}, {"sha": "98593edb9c591216f7f5380b99917489811e8fef", "filename": "tests/ui/let_underscore_drop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Flet_underscore_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Flet_underscore_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_underscore_drop.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,19 @@\n+#![warn(clippy::let_underscore_drop)]\n+\n+struct Droppable;\n+\n+impl Drop for Droppable {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let unit = ();\n+    let boxed = Box::new(());\n+    let droppable = Droppable;\n+    let optional = Some(Droppable);\n+\n+    let _ = ();\n+    let _ = Box::new(());\n+    let _ = Droppable;\n+    let _ = Some(Droppable);\n+}"}, {"sha": "66069e0c5e13f00a8d524c99351a2f7363da0c89", "filename": "tests/ui/let_underscore_drop.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Flet_underscore_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Flet_underscore_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_underscore_drop.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,27 @@\n+error: non-binding `let` on a type that implements `Drop`\n+  --> $DIR/let_underscore_drop.rs:16:5\n+   |\n+LL |     let _ = Box::new(());\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::let-underscore-drop` implied by `-D warnings`\n+   = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n+\n+error: non-binding `let` on a type that implements `Drop`\n+  --> $DIR/let_underscore_drop.rs:17:5\n+   |\n+LL |     let _ = Droppable;\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n+\n+error: non-binding `let` on a type that implements `Drop`\n+  --> $DIR/let_underscore_drop.rs:18:5\n+   |\n+LL |     let _ = Some(Droppable);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "5184f6fdb88b3991850aead57bf02ea0a75b46cf", "filename": "tests/ui/manual_async_fn.fixed", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -7,7 +7,19 @@ use std::future::Future;\n \n async fn fut() -> i32 { 42 }\n \n-async fn empty_fut()  {}\n+#[rustfmt::skip]\n+async fn fut2() -> i32 { 42 }\n+\n+#[rustfmt::skip]\n+async fn fut3() -> i32 { 42 }\n+\n+async fn empty_fut() {}\n+\n+#[rustfmt::skip]\n+async fn empty_fut2() {}\n+\n+#[rustfmt::skip]\n+async fn empty_fut3() {}\n \n async fn core_fut() -> i32 { 42 }\n "}, {"sha": "68c0e591f0b6eed6b4ffd5eeb1b8bd0fde47bae1", "filename": "tests/ui/manual_async_fn.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -9,10 +9,30 @@ fn fut() -> impl Future<Output = i32> {\n     async { 42 }\n }\n \n+#[rustfmt::skip]\n+fn fut2() ->impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+#[rustfmt::skip]\n+fn fut3()-> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n fn empty_fut() -> impl Future<Output = ()> {\n     async {}\n }\n \n+#[rustfmt::skip]\n+fn empty_fut2() ->impl Future<Output = ()> {\n+    async {}\n+}\n+\n+#[rustfmt::skip]\n+fn empty_fut3()-> impl Future<Output = ()> {\n+    async {}\n+}\n+\n fn core_fut() -> impl core::future::Future<Output = i32> {\n     async move { 42 }\n }"}, {"sha": "fdd43db3255ee5991fe49597ded05698fbae3f64", "filename": "tests/ui/manual_async_fn.stderr", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmanual_async_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -15,22 +15,82 @@ LL | fn fut() -> impl Future<Output = i32> { 42 }\n    |                                       ^^^^^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:12:1\n+  --> $DIR/manual_async_fn.rs:13:1\n+   |\n+LL | fn fut2() ->impl Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn fut2() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn fut2() ->impl Future<Output = i32> { 42 }\n+   |                                       ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:18:1\n+   |\n+LL | fn fut3()-> impl Future<Output = i32> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and return the output of the future directly\n+   |\n+LL | async fn fut3() -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn fut3()-> impl Future<Output = i32> { 42 }\n+   |                                       ^^^^^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:22:1\n    |\n LL | fn empty_fut() -> impl Future<Output = ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: make the function `async` and remove the return type\n    |\n-LL | async fn empty_fut()  {\n+LL | async fn empty_fut() {\n    | ^^^^^^^^^^^^^^^^^^^^\n help: move the body of the async block to the enclosing function\n    |\n LL | fn empty_fut() -> impl Future<Output = ()> {}\n    |                                            ^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:16:1\n+  --> $DIR/manual_async_fn.rs:27:1\n+   |\n+LL | fn empty_fut2() ->impl Future<Output = ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL | async fn empty_fut2() {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn empty_fut2() ->impl Future<Output = ()> {}\n+   |                                            ^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:32:1\n+   |\n+LL | fn empty_fut3()-> impl Future<Output = ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: make the function `async` and remove the return type\n+   |\n+LL | async fn empty_fut3() {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+help: move the body of the async block to the enclosing function\n+   |\n+LL | fn empty_fut3()-> impl Future<Output = ()> {}\n+   |                                            ^^\n+\n+error: this function can be simplified using the `async fn` syntax\n+  --> $DIR/manual_async_fn.rs:36:1\n    |\n LL | fn core_fut() -> impl core::future::Future<Output = i32> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -45,7 +105,7 @@ LL | fn core_fut() -> impl core::future::Future<Output = i32> { 42 }\n    |                                                          ^^^^^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:38:5\n+  --> $DIR/manual_async_fn.rs:58:5\n    |\n LL |     fn inh_fut() -> impl Future<Output = i32> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -65,7 +125,7 @@ LL |             let c = 21;\n  ...\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:73:1\n+  --> $DIR/manual_async_fn.rs:93:1\n    |\n LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -80,7 +140,7 @@ LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ { 42 }\n    |                                                      ^^^^^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:82:1\n+  --> $DIR/manual_async_fn.rs:102:1\n    |\n LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -94,5 +154,5 @@ help: move the body of the async block to the enclosing function\n LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b { 42 }\n    |                                                                                    ^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "ce92b3c0c30394bbe7a7995bc45a4b25d1481dbe", "filename": "tests/ui/map_clone.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::iter_cloned_collect)]\n #![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n+#![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::redundant_closure_for_method_calls)]\n #![allow(clippy::many_single_char_names)]\n@@ -44,4 +45,12 @@ fn main() {\n         let v = vec![&mut d];\n         let _: Vec<u32> = v.into_iter().map(|&mut x| x).collect();\n     }\n+\n+    // Issue #6299\n+    {\n+        let mut aa = 5;\n+        let mut bb = 3;\n+        let items = vec![&mut aa, &mut bb];\n+        let _: Vec<_> = items.into_iter().map(|x| x.clone()).collect();\n+    }\n }"}, {"sha": "324c776c3c9aa8e1915ec11db0b9ec2333223158", "filename": "tests/ui/map_clone.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -2,6 +2,7 @@\n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::iter_cloned_collect)]\n #![allow(clippy::clone_on_copy, clippy::redundant_clone)]\n+#![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::redundant_closure_for_method_calls)]\n #![allow(clippy::many_single_char_names)]\n@@ -44,4 +45,12 @@ fn main() {\n         let v = vec![&mut d];\n         let _: Vec<u32> = v.into_iter().map(|&mut x| x).collect();\n     }\n+\n+    // Issue #6299\n+    {\n+        let mut aa = 5;\n+        let mut bb = 3;\n+        let items = vec![&mut aa, &mut bb];\n+        let _: Vec<_> = items.into_iter().map(|x| x.clone()).collect();\n+    }\n }"}, {"sha": "d84a5bf8d4de6f3bc3543b4861543e19a92264f9", "filename": "tests/ui/map_clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,37 +1,37 @@\n error: you are using an explicit closure for copying elements\n-  --> $DIR/map_clone.rs:10:22\n+  --> $DIR/map_clone.rs:11:22\n    |\n LL |     let _: Vec<i8> = vec![5_i8; 6].iter().map(|x| *x).collect();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![5_i8; 6].iter().copied()`\n    |\n    = note: `-D clippy::map-clone` implied by `-D warnings`\n \n error: you are using an explicit closure for cloning elements\n-  --> $DIR/map_clone.rs:11:26\n+  --> $DIR/map_clone.rs:12:26\n    |\n LL |     let _: Vec<String> = vec![String::new()].iter().map(|x| x.clone()).collect();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `cloned` method: `vec![String::new()].iter().cloned()`\n \n error: you are using an explicit closure for copying elements\n-  --> $DIR/map_clone.rs:12:23\n+  --> $DIR/map_clone.rs:13:23\n    |\n LL |     let _: Vec<u32> = vec![42, 43].iter().map(|&x| x).collect();\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `vec![42, 43].iter().copied()`\n \n error: you are using an explicit closure for copying elements\n-  --> $DIR/map_clone.rs:14:26\n+  --> $DIR/map_clone.rs:15:26\n    |\n LL |     let _: Option<u64> = Some(&16).map(|b| *b);\n    |                          ^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&16).copied()`\n \n error: you are using an explicit closure for copying elements\n-  --> $DIR/map_clone.rs:15:25\n+  --> $DIR/map_clone.rs:16:25\n    |\n LL |     let _: Option<u8> = Some(&1).map(|x| x.clone());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling the dedicated `copied` method: `Some(&1).copied()`\n \n error: you are needlessly cloning iterator elements\n-  --> $DIR/map_clone.rs:26:29\n+  --> $DIR/map_clone.rs:27:29\n    |\n LL |     let _ = std::env::args().map(|v| v.clone());\n    |                             ^^^^^^^^^^^^^^^^^^^ help: remove the `map` call"}, {"sha": "a7ab5a12cb7655e0a2ed5e7f81359715122de928", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::all, clippy::pedantic)]\n+#![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n "}, {"sha": "e364a05f3760525532babb874cd193d7ced8fef0", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::all, clippy::pedantic)]\n+#![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n "}, {"sha": "d4e27f9aa07501638bf529c6886a96d9072e017d", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,37 +1,37 @@\n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:14:46\n+  --> $DIR/map_flatten.rs:15:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:15:46\n+  --> $DIR/map_flatten.rs:16:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:16:46\n+  --> $DIR/map_flatten.rs:17:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:17:46\n+  --> $DIR/map_flatten.rs:18:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:20:46\n+  --> $DIR/map_flatten.rs:21:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:23:39\n+  --> $DIR/map_flatten.rs:24:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`"}, {"sha": "20e5016bc17a08086610e45d052cca0b00de92fd", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -70,6 +70,15 @@ fn or_fun_call() {\n     let opt = Some(1);\n     let hello = \"Hello\";\n     let _ = opt.ok_or(format!(\"{} world.\", hello));\n+\n+    // index\n+    let map = HashMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or_else(|| map[&1]);\n+    let map = BTreeMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or_else(|| map[&1]);\n+    // don't lint index vec\n+    let vec = vec![1];\n+    let _ = Some(1).unwrap_or(vec[1]);\n }\n \n struct Foo(u8);"}, {"sha": "e7192deeebb3632b0d8b3166f6baee6674f51d69", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -70,6 +70,15 @@ fn or_fun_call() {\n     let opt = Some(1);\n     let hello = \"Hello\";\n     let _ = opt.ok_or(format!(\"{} world.\", hello));\n+\n+    // index\n+    let map = HashMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or(map[&1]);\n+    let map = BTreeMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or(map[&1]);\n+    // don't lint index vec\n+    let vec = vec![1];\n+    let _ = Some(1).unwrap_or(vec[1]);\n }\n \n struct Foo(u8);"}, {"sha": "d0c4df0e0081761eb36a7820db58db9aa3a40d17", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -78,17 +78,29 @@ error: use of `unwrap_or` followed by a function call\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:76:21\n+   |\n+LL |     let _ = Some(1).unwrap_or(map[&1]);\n+   |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n+\n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:78:21\n+   |\n+LL |     let _ = Some(1).unwrap_or(map[&1]);\n+   |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n+\n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:93:35\n+  --> $DIR/or_fun_call.rs:102:35\n    |\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:97:10\n+  --> $DIR/or_fun_call.rs:106:10\n    |\n LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "6e665cdd5630243264972ad317b061689176d3dd", "filename": "tests/ui/string_from_utf8_as_bytes.fixed", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_from_utf8_as_bytes.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+#![warn(clippy::string_from_utf8_as_bytes)]\n+\n+fn main() {\n+    let _ = Some(&\"Hello World!\"[6..11]);\n+}"}, {"sha": "670d206d3679c17cf6fded4040e49e83b2b2f736", "filename": "tests/ui/string_from_utf8_as_bytes.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_from_utf8_as_bytes.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,6 @@\n+// run-rustfix\n+#![warn(clippy::string_from_utf8_as_bytes)]\n+\n+fn main() {\n+    let _ = std::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]);\n+}"}, {"sha": "bf5e5d33e8f9ab287f124f7ecb083c92dc327eb0", "filename": "tests/ui/string_from_utf8_as_bytes.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fstring_from_utf8_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_from_utf8_as_bytes.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,10 @@\n+error: calling a slice of `as_bytes()` with `from_utf8` should be not necessary\n+  --> $DIR/string_from_utf8_as_bytes.rs:5:13\n+   |\n+LL |     let _ = std::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(&\"Hello World!\"[6..11])`\n+   |\n+   = note: `-D clippy::string-from-utf8-as-bytes` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "aa43e69f79e8b0bd40a36c5c299c820f361dc6f7", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -78,12 +78,46 @@ fn nested_error() -> Result<i32, i32> {\n     Ok(1)\n }\n \n+// Bad suggestion when in macro (see #6242)\n+macro_rules! try_validation {\n+    ($e: expr) => {{\n+        match $e {\n+            Ok(_) => 0,\n+            Err(_) => return Err(1),\n+        }\n+    }};\n+}\n+\n+macro_rules! ret_one {\n+    () => {\n+        1\n+    };\n+}\n+\n+macro_rules! try_validation_in_macro {\n+    ($e: expr) => {{\n+        match $e {\n+            Ok(_) => 0,\n+            Err(_) => return Err(ret_one!()),\n+        }\n+    }};\n+}\n+\n+fn calling_macro() -> Result<i32, i32> {\n+    // macro\n+    try_validation!(Ok::<_, i32>(5));\n+    // `Err` arg is another macro\n+    try_validation_in_macro!(Ok::<_, i32>(5));\n+    Ok(5)\n+}\n+\n fn main() {\n     basic_test().unwrap();\n     into_test().unwrap();\n     negative_test().unwrap();\n     closure_matches_test().unwrap();\n     closure_into_test().unwrap();\n+    calling_macro().unwrap();\n \n     // We don't want to lint in external macros\n     try_err!();"}, {"sha": "df3a9dc5367f3861a266f44e77da87818c514481", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -78,12 +78,46 @@ fn nested_error() -> Result<i32, i32> {\n     Ok(1)\n }\n \n+// Bad suggestion when in macro (see #6242)\n+macro_rules! try_validation {\n+    ($e: expr) => {{\n+        match $e {\n+            Ok(_) => 0,\n+            Err(_) => Err(1)?,\n+        }\n+    }};\n+}\n+\n+macro_rules! ret_one {\n+    () => {\n+        1\n+    };\n+}\n+\n+macro_rules! try_validation_in_macro {\n+    ($e: expr) => {{\n+        match $e {\n+            Ok(_) => 0,\n+            Err(_) => Err(ret_one!())?,\n+        }\n+    }};\n+}\n+\n+fn calling_macro() -> Result<i32, i32> {\n+    // macro\n+    try_validation!(Ok::<_, i32>(5));\n+    // `Err` arg is another macro\n+    try_validation_in_macro!(Ok::<_, i32>(5));\n+    Ok(5)\n+}\n+\n fn main() {\n     basic_test().unwrap();\n     into_test().unwrap();\n     negative_test().unwrap();\n     closure_matches_test().unwrap();\n     closure_into_test().unwrap();\n+    calling_macro().unwrap();\n \n     // We don't want to lint in external macros\n     try_err!();"}, {"sha": "3905ed2476b0852883cae0a23393d7780afa27c0", "filename": "tests/ui/try_err.stderr", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Ftry_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -29,28 +29,50 @@ LL |                 Err(err)?;\n    |                 ^^^^^^^^^ help: try this: `return Err(err.into())`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:106:9\n+  --> $DIR/try_err.rs:86:23\n+   |\n+LL |             Err(_) => Err(1)?,\n+   |                       ^^^^^^^ help: try this: `return Err(1)`\n+...\n+LL |     try_validation!(Ok::<_, i32>(5));\n+   |     --------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:101:23\n+   |\n+LL |             Err(_) => Err(ret_one!())?,\n+   |                       ^^^^^^^^^^^^^^^^ help: try this: `return Err(ret_one!())`\n+...\n+LL |     try_validation_in_macro!(Ok::<_, i32>(5));\n+   |     ------------------------------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:140:9\n    |\n LL |         Err(foo!())?;\n    |         ^^^^^^^^^^^^ help: try this: `return Err(foo!())`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:113:9\n+  --> $DIR/try_err.rs:147:9\n    |\n LL |         Err(io::ErrorKind::WriteZero)?\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Err(io::ErrorKind::WriteZero.into()))`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:115:9\n+  --> $DIR/try_err.rs:149:9\n    |\n LL |         Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\"))?\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\")))`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:123:9\n+  --> $DIR/try_err.rs:157:9\n    |\n LL |         Err(io::ErrorKind::NotFound)?\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Some(Err(io::ErrorKind::NotFound.into())))`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 10 previous errors\n "}, {"sha": "2e923bc97a2ef9036bc6309f24a1fe85437e70e2", "filename": "tests/ui/unnecessary_lazy_eval_unfixable.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval_unfixable.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,18 @@\n+#![warn(clippy::unnecessary_lazy_evaluations)]\n+\n+struct Deep(Option<usize>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: usize,\n+}\n+\n+fn main() {\n+    // fix will break type inference\n+    let _ = Ok(1).unwrap_or_else(|()| 2);\n+    mod e {\n+        pub struct E;\n+    }\n+    let _ = Ok(1).unwrap_or_else(|e::E| 2);\n+    let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n+}"}, {"sha": "581d641cbf54bae9401667832921742285982ff7", "filename": "tests/ui/unnecessary_lazy_eval_unfixable.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -0,0 +1,22 @@\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval_unfixable.rs:12:13\n+   |\n+LL |     let _ = Ok(1).unwrap_or_else(|()| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |\n+   = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval_unfixable.rs:16:13\n+   |\n+LL |     let _ = Ok(1).unwrap_or_else(|e::E| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval_unfixable.rs:17:13\n+   |\n+LL |     let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "4fa28b525c3c29f93694c2c89b538bef630774cd", "filename": "tests/ui/vec_box_sized.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.fixed?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -35,4 +35,18 @@ mod should_not_trigger {\n     }\n }\n \n+mod inner_mod {\n+    mod inner {\n+        pub struct S;\n+    }\n+\n+    mod inner2 {\n+        use super::inner::S;\n+\n+        pub fn f() -> Vec<S> {\n+            vec![]\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "7dc735cd90be7d43f2343d8dfb605edca3e53c5d", "filename": "tests/ui/vec_box_sized.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.rs?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -35,4 +35,18 @@ mod should_not_trigger {\n     }\n }\n \n+mod inner_mod {\n+    mod inner {\n+        pub struct S;\n+    }\n+\n+    mod inner2 {\n+        use super::inner::S;\n+\n+        pub fn f() -> Vec<Box<S>> {\n+            vec![]\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "57e2f1fdf9a7449407850a5a25f48d01b97de3f8", "filename": "tests/ui/vec_box_sized.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ea6f774460fa3009ac02d2ef9869d330bef4f49/tests%2Fui%2Fvec_box_sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.stderr?ref=3ea6f774460fa3009ac02d2ef9869d330bef4f49", "patch": "@@ -18,5 +18,11 @@ error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n LL |     struct B(Vec<Vec<Box<(u32)>>>);\n    |                  ^^^^^^^^^^^^^^^ help: try: `Vec<u32>`\n \n-error: aborting due to 3 previous errors\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+  --> $DIR/vec_box_sized.rs:46:23\n+   |\n+LL |         pub fn f() -> Vec<Box<S>> {\n+   |                       ^^^^^^^^^^^ help: try: `Vec<S>`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "319de217e0d90170c1bcf7545aef25e1caff11d5", "filename": "util/dev", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6294300b8ec9b9eec0ec7fb0435aff93a299ed63/util%2Fdev", "raw_url": "https://github.com/rust-lang/rust/raw/6294300b8ec9b9eec0ec7fb0435aff93a299ed63/util%2Fdev", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdev?ref=6294300b8ec9b9eec0ec7fb0435aff93a299ed63", "patch": "@@ -1,7 +0,0 @@\n-#!/bin/sh\n-CARGO_TARGET_DIR=$(pwd)/target/\n-export CARGO_TARGET_DIR\n-\n-echo 'Deprecated! `util/dev` usage is deprecated, please use `cargo dev` instead.'\n-\n-cd clippy_dev && cargo run -- \"$@\""}]}