{"sha": "c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NGJkYTEwNzU3NTdjZDAwZjcyYTkxOGUyZDdmZGFmNDdmODVjMmQ=", "commit": {"author": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-07T06:12:56Z"}, "committer": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-07T06:12:56Z"}, "message": "Add suggestion", "tree": {"sha": "d28384914262e40c2552d66b129c54df45a84869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28384914262e40c2552d66b129c54df45a84869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "html_url": "https://github.com/rust-lang/rust/commit/c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6eef82c684268bd719d3ced4f4cca69b014aaff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6eef82c684268bd719d3ced4f4cca69b014aaff", "html_url": "https://github.com/rust-lang/rust/commit/b6eef82c684268bd719d3ced4f4cca69b014aaff"}], "stats": {"total": 165, "additions": 126, "deletions": 39}, "files": [{"sha": "5056876f3ad539d484ab58725028fcb19e50a21a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 100, "deletions": 31, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "patch": "@@ -764,23 +764,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n                     // ```\n \n-                    let closure_args_span = found_did.and_then(|did| self.tcx.hir.get_if_local(did))\n+                    let (closure_span, closure_args) = found_did\n+                        .and_then(|did| self.tcx.hir.get_if_local(did))\n                         .and_then(|node| {\n                             if let hir::map::NodeExpr(\n-                                &hir::Expr { node: hir::ExprClosure(_, _, _, span, _), .. }) = node\n+                                &hir::Expr {\n+                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n+                                    ..\n+                                }) = node\n                             {\n-                                Some(span)\n+                                let ty_snips = decl.inputs.iter()\n+                                    .map(|ty| {\n+                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n+                                            .and_then(|snip| {\n+                                                // filter out dummy spans\n+                                                if snip == \",\" || snip == \"|\" {\n+                                                    None\n+                                                } else {\n+                                                    Some(snip)\n+                                                }\n+                                            })\n+                                    })\n+                                    .collect::<Vec<Option<String>>>();\n+\n+                                let body = self.tcx.hir.body(id);\n+                                let pat_snips = body.arguments.iter()\n+                                    .map(|arg|\n+                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n+                                    .collect::<Option<Vec<String>>>();\n+\n+                                Some((span, pat_snips, ty_snips))\n                             } else {\n                                 None\n                             }\n-                        });\n+                        })\n+                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n+                        .unwrap_or((None, None));\n+                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n \n                     self.report_arg_count_mismatch(\n                         span,\n-                        closure_args_span.or(found_span),\n+                        closure_span.or(found_span),\n                         expected_ty_count,\n                         expected_tuple,\n                         found_ty_count,\n+                        closure_args,\n                         found_trait_ty.is_closure()\n                     )\n                 }\n@@ -803,44 +831,85 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_arg_count_mismatch(&self,\n-                                 span: Span,\n-                                 found_span: Option<Span>,\n-                                 expected: usize,\n-                                 expected_tuple: Option<usize>,\n-                                 found: usize,\n-                                 is_closure: bool)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected: usize,\n+        expected_tuple: Option<usize>,\n+        found: usize,\n+        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n+        is_closure: bool\n+    ) -> DiagnosticBuilder<'tcx> {\n+        use std::borrow::Cow;\n+\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n-        let tuple_or_args = |tuple, args|  if let Some(n) = tuple {\n-            format!(\"a {}-tuple\", n)\n-        } else {\n-            format!(\n+        let args_str = |n| format!(\n                 \"{} argument{}\",\n-                args,\n-                if args == 1 { \"\" } else { \"s\" }\n-            )\n-        };\n-\n-        let found_str = tuple_or_args(None, found);\n-        let expected_str = tuple_or_args(expected_tuple, expected);\n+                n,\n+                if n == 1 { \"\" } else { \"s\" }\n+            );\n \n         let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n-            \"{} takes {} but {} {} required\",\n+            \"{} takes {}, but {} {} required\",\n             kind,\n-            found_str,\n-            expected_str,\n-            if expected_tuple.is_some() || expected == 1 { \"is\" } else { \"are\" });\n+            if expected_tuple.is_some() {\n+                Cow::from(\"multiple arguments\")\n+            } else {\n+                Cow::from(args_str(found))\n+            },\n+            if expected_tuple.is_some() {\n+                Cow::from(\"a tuple argument\")\n+            } else {\n+                Cow::from(args_str(expected))\n+            },\n+            if expected == 1 { \"is\" } else { \"are\" });\n \n         err.span_label(\n             span,\n-            format!(\"expected {} that takes {}\", kind, expected_str)\n+            format!(\n+                \"expected {} that takes {}{}\",\n+                kind,\n+                args_str(expected),\n+                if let Some(n) = expected_tuple {\n+                    assert!(expected == 1);\n+                    Cow::from(format!(\", a {}-tuple\", n))\n+                } else {\n+                    Cow::from(\"\")\n+                }\n+            )\n         );\n \n         if let Some(span) = found_span {\n-            err.span_label(span, format!(\"takes {}\", found_str));\n+            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n+                if expected_tuple != found || pats.len() != found {\n+                    err.span_label(span, format!(\"takes {}\", args_str(found)));\n+                } else {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        pats.join(\", \"),\n+\n+                        // add type annotations if available\n+                        if tys.iter().any(|ty| ty.is_some()) {\n+                            Cow::from(format!(\n+                                \": ({})\",\n+                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n+                                    ty\n+                                } else {\n+                                    \"_\".to_string()\n+                                }).collect::<Vec<String>>().join(\", \")\n+                            ))\n+                        } else {\n+                            Cow::from(\"\")\n+                        },\n+                    );\n+\n+                    err.span_suggestion(span, \"consider changing to\", sugg);\n+                }\n+            } else {\n+                err.span_label(span, format!(\"takes {}\", args_str(found)));\n+            }\n         }\n \n         err"}, {"sha": "5d2d1d2b04c50c2c033470036afcc657249b0897", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "patch": "@@ -18,4 +18,6 @@ fn main() {\n     f(|| panic!());\n \n     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n }"}, {"sha": "24860faf2d5280f63f16b4950b4a1e5e51667b9a", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c74bda1075757cd00f72a918e2d7fdaf47f85c2d/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=c74bda1075757cd00f72a918e2d7fdaf47f85c2d", "patch": "@@ -1,12 +1,12 @@\n-error[E0593]: closure takes 0 arguments but 2 arguments are required\n+error[E0593]: closure takes 0 arguments, but 2 arguments are required\n   --> $DIR/closure-arg-count.rs:15:15\n    |\n 15 |     [1, 2, 3].sort_by(|| panic!());\n    |               ^^^^^^^ -- takes 0 arguments\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 1 argument but 2 arguments are required\n+error[E0593]: closure takes 1 argument, but 2 arguments are required\n   --> $DIR/closure-arg-count.rs:16:15\n    |\n 16 |     [1, 2, 3].sort_by(|tuple| panic!());\n@@ -23,15 +23,15 @@ error[E0308]: mismatched types\n    = note: expected type `&{integer}`\n               found type `(_, _)`\n \n-error[E0593]: closure takes 1 argument but 2 arguments are required\n+error[E0593]: closure takes 1 argument, but 2 arguments are required\n   --> $DIR/closure-arg-count.rs:17:15\n    |\n 17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n    |               ^^^^^^^ ----------------- takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 0 arguments but 1 argument is required\n+error[E0593]: closure takes 0 arguments, but 1 argument is required\n   --> $DIR/closure-arg-count.rs:18:5\n    |\n 18 |     f(|| panic!());\n@@ -41,13 +41,29 @@ error[E0593]: closure takes 0 arguments but 1 argument is required\n    |\n    = note: required by `f`\n \n-error[E0593]: closure takes 2 arguments but a 2-tuple is required\n+error[E0593]: closure takes multiple arguments, but a tuple argument is required\n   --> $DIR/closure-arg-count.rs:20:53\n    |\n 20 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n-   |                                                     ^^^ ------ takes 2 arguments\n+   |                                                     ^^^ ------ help: consider changing to: `|(i, x)|`\n    |                                                     |\n-   |                                                     expected closure that takes a 2-tuple\n+   |                                                     expected closure that takes 1 argument, a 2-tuple\n \n-error: aborting due to 6 previous errors\n+error[E0593]: closure takes multiple arguments, but a tuple argument is required\n+  --> $DIR/closure-arg-count.rs:21:53\n+   |\n+21 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+   |                                                     ^^^ ------------- help: consider changing to: `|(i, x): (usize, _)|`\n+   |                                                     |\n+   |                                                     expected closure that takes 1 argument, a 2-tuple\n+\n+error[E0593]: closure takes multiple arguments, but a tuple argument is required\n+  --> $DIR/closure-arg-count.rs:22:53\n+   |\n+22 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n+   |                                                     ^^^ --------- takes 3 arguments\n+   |                                                     |\n+   |                                                     expected closure that takes 1 argument, a 2-tuple\n+\n+error: aborting due to 8 previous errors\n "}]}