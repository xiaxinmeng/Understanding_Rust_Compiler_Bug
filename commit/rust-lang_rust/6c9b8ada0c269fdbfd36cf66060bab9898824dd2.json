{"sha": "6c9b8ada0c269fdbfd36cf66060bab9898824dd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOWI4YWRhMGMyNjlmZGJmZDM2Y2Y2NjA2MGJhYjk4OTg4MjRkZDI=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-25T04:53:35Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-25T21:50:48Z"}, "message": "Precompute the associated items\n\nThe associated_items(def_id) call\nallocates internally.\nPreviously, we'd have called it for\neach pair, so we'd have had O(n^2)\nmany calls. By precomputing the\nassociated items, we avoid\nrepeating so many allocations.\n\nThe only instance where this precomputation\nwould be a regression is if there's only\none inherent impl block for the type,\nas the inner loop then doesn't run.\nIn that instance, we just early return.\n\nAlso, use SmallVec to avoid doing an\nallocation at all if the number is small\n(the case for most impl blocks out there).", "tree": {"sha": "650ae8e3a19d851b51d9cee191e9083895328426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/650ae8e3a19d851b51d9cee191e9083895328426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9b8ada0c269fdbfd36cf66060bab9898824dd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9b8ada0c269fdbfd36cf66060bab9898824dd2", "html_url": "https://github.com/rust-lang/rust/commit/6c9b8ada0c269fdbfd36cf66060bab9898824dd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9b8ada0c269fdbfd36cf66060bab9898824dd2/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a21c2eb1213715b26ae61944cb5edea897d77ebd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a21c2eb1213715b26ae61944cb5edea897d77ebd", "html_url": "https://github.com/rust-lang/rust/commit/a21c2eb1213715b26ae61944cb5edea897d77ebd"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "ce157f809ef875019f4eb113903830d07e3215aa", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c9b8ada0c269fdbfd36cf66060bab9898824dd2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9b8ada0c269fdbfd36cf66060bab9898824dd2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=6c9b8ada0c269fdbfd36cf66060bab9898824dd2", "patch": "@@ -2,8 +2,9 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n+use smallvec::SmallVec;\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -18,10 +19,11 @@ struct InherentOverlapChecker<'tcx> {\n impl InherentOverlapChecker<'tcx> {\n     /// Checks whether any associated items in impls 1 and 2 share the same identifier and\n     /// namespace.\n-    fn impls_have_common_items(&self, impl1: DefId, impl2: DefId) -> bool {\n-        let impl_items1 = self.tcx.associated_items(impl1);\n-        let impl_items2 = self.tcx.associated_items(impl2);\n-\n+    fn impls_have_common_items(\n+        &self,\n+        impl_items1: &ty::AssociatedItems<'_>,\n+        impl_items2: &ty::AssociatedItems<'_>,\n+    ) -> bool {\n         let mut impl_items1 = &impl_items1;\n         let mut impl_items2 = &impl_items2;\n \n@@ -121,9 +123,20 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                 let ty_def_id = self.tcx.hir().local_def_id(item.hir_id);\n                 let impls = self.tcx.inherent_impls(ty_def_id);\n \n-                for (i, &impl1_def_id) in impls.iter().enumerate() {\n-                    for &impl2_def_id in &impls[(i + 1)..] {\n-                        if self.impls_have_common_items(impl1_def_id, impl2_def_id) {\n+                // If there is only one inherent impl block,\n+                // there is nothing to overlap check it with\n+                if impls.len() <= 1 {\n+                    return;\n+                }\n+\n+                let impls_items = impls\n+                    .iter()\n+                    .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n+                    .collect::<SmallVec<[_; 8]>>();\n+\n+                for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n+                    for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n+                        if self.impls_have_common_items(impl_items1, impl_items2) {\n                             self.check_for_overlapping_inherent_impls(impl1_def_id, impl2_def_id);\n                         }\n                     }"}]}