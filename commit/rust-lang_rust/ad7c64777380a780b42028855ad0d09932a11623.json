{"sha": "ad7c64777380a780b42028855ad0d09932a11623", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkN2M2NDc3NzM4MGE3ODBiNDIwMjg4NTVhZDBkMDk5MzJhMTE2MjM=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-09-16T01:27:28Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-05T19:38:12Z"}, "message": "Add a special macro nonterminal $crate", "tree": {"sha": "e07587239681150b7c9a9d4464411d18eed31714", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e07587239681150b7c9a9d4464411d18eed31714"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad7c64777380a780b42028855ad0d09932a11623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7c64777380a780b42028855ad0d09932a11623", "html_url": "https://github.com/rust-lang/rust/commit/ad7c64777380a780b42028855ad0d09932a11623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad7c64777380a780b42028855ad0d09932a11623/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e5924b79915326d81db2aebfe73d2a20b8506f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e5924b79915326d81db2aebfe73d2a20b8506f1", "html_url": "https://github.com/rust-lang/rust/commit/5e5924b79915326d81db2aebfe73d2a20b8506f1"}], "stats": {"total": 162, "additions": 153, "deletions": 9}, "files": [{"sha": "30b9d6c63c5bb127db68bb38141011e850ed0f3c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -166,6 +166,9 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 }\n             }\n \n+            // Special macro vars are like keywords\n+            token::SpecialVarNt(_) => \"kw-2\",\n+\n             token::Lifetime(..) => \"lifetime\",\n             token::DocComment(..) => \"doccomment\",\n             token::Underscore | token::Eof | token::Interpolated(..) |"}, {"sha": "55aa73b4faaee097104d3bfa51e5978ed2655cca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -884,6 +884,7 @@ impl TokenTree {\n         match *self {\n             TtToken(_, token::DocComment(_)) => 2,\n             TtToken(_, token::SubstNt(..)) => 2,\n+            TtToken(_, token::SpecialVarNt(..)) => 2,\n             TtToken(_, token::MatchNt(..)) => 3,\n             TtDelimited(_, ref delimed) => {\n                 delimed.tts.len() + 2\n@@ -925,6 +926,12 @@ impl TokenTree {\n                          TtToken(sp, token::Ident(name, name_st))];\n                 v[index]\n             }\n+            (&TtToken(sp, token::SpecialVarNt(var)), _) => {\n+                let v = [TtToken(sp, token::Dollar),\n+                         TtToken(sp, token::Ident(token::str_to_ident(var.as_str()),\n+                                                  token::Plain))];\n+                v[index]\n+            }\n             (&TtToken(sp, token::MatchNt(name, kind, name_st, kind_st)), _) => {\n                 let v = [TtToken(sp, token::SubstNt(name, name_st)),\n                          TtToken(sp, token::Colon),"}, {"sha": "325d8aa594a32409eca15ff124599954eaac746c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -432,7 +432,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n     }\n \n     let mut new_items = match it.node {\n-        ast::ItemMac(..) => expand_item_mac(it, fld),\n+        ast::ItemMac(..) => expand_item_mac(it, None, fld),\n         ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             let valid_ident =\n                 it.ident.name != parse::token::special_idents::invalid.name;\n@@ -529,8 +529,9 @@ fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n-                       -> SmallVector<P<ast::Item>> {\n+pub fn expand_item_mac(it: P<ast::Item>,\n+                       imported_from: Option<ast::Ident>,\n+                       fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -611,7 +612,8 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                     });\n                     // DON'T mark before expansion.\n                     let MacroDef { name, ext }\n-                        = macro_rules::add_new_extension(fld.cx, it.span, it.ident, tts);\n+                        = macro_rules::add_new_extension(fld.cx, it.span, it.ident,\n+                                                         imported_from, tts);\n \n                     fld.cx.syntax_env.insert(intern(name.as_slice()), ext);\n                     if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n@@ -1190,7 +1192,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n                                                          expander.cx.cfg(),\n                                                          expander.cx.parse_sess())\n                     .expect(\"expected a serialized item\");\n-            expand_item_mac(item, &mut expander);\n+            expand_item_mac(item, Some(crate_name), &mut expander);\n         }\n     }\n "}, {"sha": "a278604b167565659813da0374ef278d356ecd49", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -110,6 +110,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n+    imported_from: Option<Ident>,\n     lhses: Vec<Rc<NamedMatch>>,\n     rhses: Vec<Rc<NamedMatch>>,\n }\n@@ -123,6 +124,7 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n+                          self.imported_from,\n                           arg,\n                           self.lhses[],\n                           self.rhses[])\n@@ -133,6 +135,7 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: Ident,\n+                          imported_from: Option<Ident>,\n                           arg: &[ast::TokenTree],\n                           lhses: &[Rc<NamedMatch>],\n                           rhses: &[Rc<NamedMatch>])\n@@ -156,6 +159,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n             };\n             // `None` is because we're not interpolating\n             let mut arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                            None,\n                                             None,\n                                             arg.iter()\n                                                .map(|x| (*x).clone())\n@@ -177,6 +181,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                            Some(named_matches),\n+                                           imported_from,\n                                            rhs);\n                 let p = Parser::new(cx.parse_sess(), cx.cfg(), box trncbr);\n                 // Let the context choose how to interpret the result.\n@@ -209,6 +214,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               name: Ident,\n+                              imported_from: Option<Ident>,\n                               arg: Vec<ast::TokenTree> )\n                               -> MacroDef {\n \n@@ -246,6 +252,7 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                   None,\n                                    None,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n@@ -266,6 +273,7 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n \n     let exp = box MacroRulesMacroExpander {\n         name: name,\n+        imported_from: imported_from,\n         lhses: lhses,\n         rhses: rhses,\n     };"}, {"sha": "e4e6f5ac6b0f0f0c4953b6ab426eb8cb914d2e31", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -15,7 +15,7 @@ use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{Eof, DocComment, Interpolated, MatchNt, SubstNt};\n-use parse::token::{Token, NtIdent};\n+use parse::token::{Token, NtIdent, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n \n@@ -39,6 +39,10 @@ pub struct TtReader<'a> {\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n+    imported_from: Option<Ident>,\n+\n+    // Some => return imported_from as the next token\n+    crate_name_next: Option<Span>,\n     repeat_idx: Vec<uint>,\n     repeat_len: Vec<uint>,\n     /* cached: */\n@@ -53,6 +57,7 @@ pub struct TtReader<'a> {\n /// should) be none.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n                          interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                         imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree> )\n                          -> TtReader<'a> {\n     let mut r = TtReader {\n@@ -71,6 +76,8 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n             None => HashMap::new(),\n             Some(x) => x,\n         },\n+        imported_from: imported_from,\n+        crate_name_next: None,\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n         desugar_doc_comments: false,\n@@ -162,6 +169,14 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         sp: r.cur_span.clone(),\n     };\n     loop {\n+        match r.crate_name_next.take() {\n+            None => (),\n+            Some(sp) => {\n+                r.cur_span = sp;\n+                r.cur_tok = token::Ident(r.imported_from.unwrap(), token::Plain);\n+                return ret_val;\n+            },\n+        }\n         let should_pop = match r.stack.last() {\n             None => {\n                 assert_eq!(ret_val.tok, token::Eof);\n@@ -307,6 +322,18 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                    sep: None\n                 });\n             }\n+            TtToken(sp, token::SpecialVarNt(SpecialMacroVar::CrateMacroVar)) => {\n+                r.stack.last_mut().unwrap().idx += 1;\n+\n+                if r.imported_from.is_some() {\n+                    r.cur_span = sp;\n+                    r.cur_tok = token::ModSep;\n+                    r.crate_name_next = Some(sp);\n+                    return ret_val;\n+                }\n+\n+                // otherwise emit nothing and proceed to the next token\n+            }\n             TtToken(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "3e4f2c8d4e237319958f397598f2bbabe07090e0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -291,7 +291,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n     Parser::new(sess, cfg, box trdr)\n }\n "}, {"sha": "f513692c31d34d2fa438faff9c10e053f757f59e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -75,8 +75,8 @@ use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::*;\n-use parse::token::{self, MatchNt, SubstNt, InternedString};\n-use parse::token::{keywords, special_idents};\n+use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n+use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n use print::pprust;\n use ptr::P;\n@@ -2747,6 +2747,9 @@ impl<'a> Parser<'a> {\n                                    op: repeat,\n                                    num_captures: name_num\n                                }))\n+                } else if p.token.is_keyword_allow_following_colon(keywords::Crate) {\n+                    p.bump();\n+                    TtToken(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar))\n                 } else {\n                     // A nonterminal that matches or not\n                     let namep = match p.token { token::Ident(_, p) => p, _ => token::Plain };"}, {"sha": "a653190cffdefd479a1a1e0f01f308f6b51ea488", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -61,6 +61,21 @@ pub enum IdentStyle {\n     Plain,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+pub enum SpecialMacroVar {\n+    /// `$crate` will be filled in with the name of the crate a macro was\n+    /// imported from, if any.\n+    CrateMacroVar,\n+}\n+\n+impl SpecialMacroVar {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            SpecialMacroVar::CrateMacroVar => \"crate\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n@@ -143,6 +158,8 @@ pub enum Token {\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n     SubstNt(ast::Ident, IdentStyle),\n+    /// A macro variable with special meaning.\n+    SpecialVarNt(SpecialMacroVar),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -265,6 +282,13 @@ impl Token {\n         }\n     }\n \n+    pub fn is_keyword_allow_following_colon(&self, kw: keywords::Keyword) -> bool {\n+        match *self {\n+            Ident(sid, _) => { kw.to_name() == sid.name }\n+            _ => { false }\n+        }\n+    }\n+\n     /// Returns `true` if the token is either a special identifier, or a strict\n     /// or reserved keyword.\n     #[allow(non_upper_case_globals)]"}, {"sha": "27db49b65ce19c7b690ec937e4c63a6265f1e7ff", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -272,6 +272,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s.as_str()),\n \n+        token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n+\n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)  => expr_to_string(&**e),\n             token::NtMeta(ref e)  => meta_item_to_string(&**e),"}, {"sha": "20df664c3c6adb7f9a78fd8a21007a52ccf4ccc5", "filename": "src/test/auxiliary/macro_crate_nonterminal.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! increment {\n+    ($x:expr) => ($crate::increment($x))\n+}\n+\n+pub fn check_local() {\n+    assert_eq!(increment!(3), 4);\n+}"}, {"sha": "cf9a53f27be5dc4f99fdcd9adc71e39c337a389b", "filename": "src/test/run-pass/macro-crate-nonterminal-renamed.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_nonterminal.rs\n+// ignore-stage1\n+\n+#![feature(phase)]\n+\n+#[phase(plugin, link)]\n+extern crate \"macro_crate_nonterminal\" as new_name;\n+\n+pub fn main() {\n+    new_name::check_local();\n+    assert_eq!(increment!(5), 6);\n+}"}, {"sha": "8abf534ab12498cee9354f4611f0a6445e9c909a", "filename": "src/test/run-pass/macro-crate-nonterminal.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad7c64777380a780b42028855ad0d09932a11623/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs?ref=ad7c64777380a780b42028855ad0d09932a11623", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_nonterminal.rs\n+// ignore-stage1\n+\n+#![feature(phase)]\n+\n+#[phase(plugin, link)]\n+extern crate macro_crate_nonterminal;\n+\n+pub fn main() {\n+    macro_crate_nonterminal::check_local();\n+    assert_eq!(increment!(5), 6);\n+}"}]}