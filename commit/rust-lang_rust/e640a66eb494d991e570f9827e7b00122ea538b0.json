{"sha": "e640a66eb494d991e570f9827e7b00122ea538b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDBhNjZlYjQ5NGQ5OTFlNTcwZjk4MjdlN2IwMDEyMmVhNTM4YjA=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-13T17:17:42Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-15T00:40:04Z"}, "message": "Make most forms of explicit self work. By-value not implemented. Work on #2585.", "tree": {"sha": "08f1842c77d3f1219d98340158a36a35bda861e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08f1842c77d3f1219d98340158a36a35bda861e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e640a66eb494d991e570f9827e7b00122ea538b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e640a66eb494d991e570f9827e7b00122ea538b0", "html_url": "https://github.com/rust-lang/rust/commit/e640a66eb494d991e570f9827e7b00122ea538b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e640a66eb494d991e570f9827e7b00122ea538b0/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c16ff516d97bb4a69ad965b93e6db61343be381", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c16ff516d97bb4a69ad965b93e6db61343be381", "html_url": "https://github.com/rust-lang/rust/commit/4c16ff516d97bb4a69ad965b93e6db61343be381"}], "stats": {"total": 169, "additions": 86, "deletions": 83}, "files": [{"sha": "39e116990dd238a8c7c233ae03be8325c976a568", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -600,7 +600,7 @@ enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n     sty_value,                          // by-value self: `self`\n-    sty_region(@region, mutability),    // by-region self: `&self`\n+    sty_region(mutability),             // by-region self: `&self`\n     sty_box(mutability),                // by-managed-pointer self: `@self`\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }"}, {"sha": "feb19d6780c3560d43959f01b8ec09bc0ef2c020", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -2300,29 +2300,7 @@ class parser {\n                     self.bump();\n                     let mutability = self.parse_mutability();\n                     self.expect_self_ident();\n-\n-                    // Parse an explicit region, if possible.\n-                    let region_name;\n-                    match copy self.token {\n-                        token::BINOP(token::SLASH) => {\n-                            self.bump();\n-                            match copy self.token {\n-                                token::IDENT(sid, false) => {\n-                                    self.bump();\n-                                    region_name = some(self.get_str(sid));\n-                                }\n-                                _ => {\n-                                    region_name = none;\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            region_name = none;\n-                        }\n-                    }\n-\n-                    let region = self.region_from_name(region_name);\n-                    self_ty = sty_region(region, mutability);\n+                    self_ty = sty_region(mutability);\n                 } else {\n                     self_ty = sty_by_ref;\n                 }"}, {"sha": "379982f4a2dd30bb2f33d5fcb8547121e2b15c49", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -598,22 +598,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n         '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n-        '&' => {\n-            let mutability = get_mutability(string[1]);\n-\n-            let region;\n-            let region_doc =\n-                ebml::get_doc(self_type_doc,\n-                              tag_item_trait_method_self_ty_region);\n-            let region_string = str::from_bytes(ebml::doc_data(region_doc));\n-            if region_string == ~\"\" {\n-                region = ast::re_anon;\n-            } else {\n-                region = ast::re_named(@region_string);\n-            }\n-\n-            return ast::sty_region(@{ id: 0, node: region }, mutability);\n-        }\n+        '&' => { return ast::sty_region(get_mutability(string[1])); }\n         _ => {\n             fail fmt!{\"unknown self type code: `%c`\", self_ty_kind as char};\n         }"}, {"sha": "47414e48462e8272b6351bc61b8b78e15142bc4a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -500,7 +500,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n         sty_static =>       { ch = 's' as u8; }\n         sty_by_ref =>       { ch = 'r' as u8; }\n         sty_value =>        { ch = 'v' as u8; }\n-        sty_region(_, _) => { ch = '&' as u8; }\n+        sty_region(_) =>    { ch = '&' as u8; }\n         sty_box(_) =>       { ch = '@' as u8; }\n         sty_uniq(_) =>      { ch = '~' as u8; }\n     }\n@@ -509,27 +509,17 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     // Encode mutability.\n     match self_type {\n         sty_static | sty_by_ref | sty_value => { /* No-op. */ }\n-        sty_region(_, m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n+        sty_region(m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n             ebml_w.writer.write(&[ 'i' as u8 ]);\n         }\n-        sty_region(_, m_mutbl) | sty_box(m_mutbl) | sty_uniq(m_mutbl) => {\n+        sty_region(m_mutbl) | sty_box(m_mutbl) | sty_uniq(m_mutbl) => {\n             ebml_w.writer.write(&[ 'm' as u8 ]);\n         }\n-        sty_region(_, m_const) | sty_box(m_const) | sty_uniq(m_const) => {\n+        sty_region(m_const) | sty_box(m_const) | sty_uniq(m_const) => {\n             ebml_w.writer.write(&[ 'c' as u8 ]);\n         }\n     }\n \n-    // Encode the region.\n-    match self_type {\n-        sty_region(region, _) => {\n-            encode_region(ebml_w, *region);\n-        }\n-        sty_static | sty_by_ref | sty_value | sty_box(*) | sty_uniq(*) => {\n-            // Nothing to do.\n-        }\n-    }\n-\n     ebml_w.end_tag();\n }\n "}, {"sha": "20e005d7c54f97a46c063c9cfd61419ad3270bd4", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -26,9 +26,23 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     for vec::each(methods) |m| {\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n+            let self_ty = ty::node_id_to_type(ccx.tcx, m.self_id);\n             let self_arg = match m.self_ty.node {\n               ast::sty_static => { no_self }\n-              _ => { impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)) }\n+              ast::sty_box(_) => {\n+                impl_self(ty::mk_imm_box(ccx.tcx, self_ty))\n+              }\n+              ast::sty_uniq(_) => {\n+                impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n+              }\n+              // XXX: Is this right at all?\n+              ast::sty_region(*) => {\n+                impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n+              }\n+              ast::sty_value => {\n+                ccx.sess.unimpl(~\"by value self type not implemented\");\n+              }\n+              ast::sty_by_ref => { impl_self(self_ty) }\n             };\n \n             trans_fn(ccx,"}, {"sha": "5cb886a36f06d34d8ad0ee9989a922cf73613e1a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -80,6 +80,7 @@ import std::map::str_hash;\n type self_info = {\n     self_ty: ty::t,\n     node_id: ast::node_id,\n+    explicit_self: ast::self_ty_\n };\n \n type fn_ctxt_ =\n@@ -367,14 +368,20 @@ fn check_fn(ccx: @crate_ctxt,\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method,\n                 self_info: self_info) {\n+\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_info));\n }\n \n-fn check_class_member(ccx: @crate_ctxt, class_t: self_info,\n+fn check_class_member(ccx: @crate_ctxt, self_ty: ty::t,\n+                      node_id: ast::node_id,\n                       cm: @ast::class_member) {\n     match cm.node {\n       ast::instance_var(_,t,_,_,_) => (),\n-      ast::class_method(m) => check_method(ccx, m, class_t)\n+      ast::class_method(m) => {\n+        let class_t = {self_ty: self_ty, node_id: node_id,\n+                       explicit_self: m.self_ty.node};\n+        check_method(ccx, m, class_t)\n+      }\n     }\n }\n \n@@ -404,9 +411,11 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                 id: ast::node_id, span: span) {\n     let tcx = ccx.tcx;\n-    let class_t = {self_ty: ty::node_id_to_type(tcx, id), node_id: id};\n+    let self_ty = ty::node_id_to_type(tcx, id);\n \n     do option::iter(struct_def.ctor) |ctor| {\n+        let class_t = {self_ty: self_ty, node_id: id,\n+                       explicit_self: ast::sty_by_ref};\n         // typecheck the ctor\n         check_bare_fn(ccx, ctor.node.dec,\n                       ctor.node.body, ctor.node.id,\n@@ -416,6 +425,8 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     }\n \n     do option::iter(struct_def.dtor) |dtor| {\n+        let class_t = {self_ty: self_ty, node_id: id,\n+                       explicit_self: ast::sty_by_ref};\n         // typecheck the dtor\n         check_bare_fn(ccx, ast_util::dtor_dec(),\n                       dtor.node.body, dtor.node.id,\n@@ -426,7 +437,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n \n     // typecheck the members\n     for struct_def.members.each |m| {\n-        check_class_member(ccx, class_t, m);\n+        check_class_member(ccx, self_ty, id, m);\n     }\n     // Check that there's at least one field\n     let (fields,_) = split_class_items(struct_def.members);\n@@ -450,9 +461,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n         debug!{\"item_impl %s with id %d rp %b\",\n                *it.ident, it.id, rp};\n-        let self_info = {self_ty: ccx.to_ty(rscope::type_rscope(rp), ty),\n-                         node_id: it.id };\n-        for ms.each |m| { check_method(ccx, m, self_info);}\n+        let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n+        for ms.each |m| {\n+            let self_info = {self_ty: self_ty, node_id: it.id,\n+                             explicit_self: m.self_ty.node };\n+            check_method(ccx, m, self_info)\n+        }\n       }\n       ast::item_trait(_, _, trait_methods) => {\n         for trait_methods.each |trait_method| {\n@@ -463,7 +477,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n               }\n               provided(m) => {\n                 let self_info = {self_ty: ty::mk_self(ccx.tcx),\n-                                 node_id: it.id};\n+                                 node_id: it.id,\n+                                 explicit_self: m.self_ty.node};\n                 check_method(ccx, m, self_info);\n               }\n             }\n@@ -742,7 +757,8 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n+fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id, require_rp: bool)\n+                                        -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n     let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n@@ -778,6 +794,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n          raw_ty: ity.ty}\n     };\n \n+    let rp = rp || require_rp;\n     let self_r = if rp {some(fcx.infcx.next_region_var_nb())} else {none};\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n@@ -2216,7 +2233,10 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_self(_) => {\n         match fcx.self_info {\n           some(self_info) => {\n-            return no_params(self_info.self_ty);\n+            let self_region = fcx.in_scope_regions.find(ty::br_self);\n+            return no_params(method::transform_self_type_for_method(\n+                fcx.tcx(), self_region,\n+                self_info.self_ty, self_info.explicit_self));\n           }\n           none => {\n               fcx.ccx.tcx.sess.span_bug(sp, ~\"def_self with no self_info\");"}, {"sha": "c5d3dd765abd4dd09fd77ec5bbd7180325124b09", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -20,28 +20,30 @@ type candidate = {\n     entry: method_map_entry\n };\n \n-fn transform_self_type_for_method(fcx: @fn_ctxt,\n-                                  impl_ty: ty::t,\n-                                  method_info: MethodInfo)\n+fn transform_self_type_for_method\n+    (tcx: ty::ctxt,\n+     self_region: option<ty::region>,\n+     impl_ty: ty::t,\n+     self_type: ast::self_ty_)\n                                -> ty::t {\n-    match method_info.self_type {\n+    match self_type {\n       sty_static => {\n-        fcx.tcx().sess.bug(~\"calling transform_self_type_for_method on \\\n-                             static method\");\n+        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n+                       static method\");\n       }\n       sty_by_ref | sty_value => {\n         impl_ty\n       }\n-      sty_region(r, mutability) => {\n-        // XXX: dummy_sp is unfortunate here.\n-        let region = ast_region_to_region(fcx, fcx, dummy_sp(), r);\n-        mk_rptr(fcx.ccx.tcx, region, { ty: impl_ty, mutbl: mutability })\n+      sty_region(mutability) => {\n+        mk_rptr(tcx,\n+                self_region.expect(~\"self region missing for &self param\"),\n+                { ty: impl_ty, mutbl: mutability })\n       }\n       sty_box(mutability) => {\n-        mk_box(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+        mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n       }\n       sty_uniq(mutability) => {\n-        mk_uniq(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+        mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n       }\n     }\n }\n@@ -368,14 +370,17 @@ class lookup {\n         // Check whether this impl has a method with the right name.\n         for im.methods.find(|m| m.ident == self.m_name).each |m| {\n \n+            let need_rp = match m.self_type { ast::sty_region(_) => true,\n+                                              _ => false };\n+\n             // determine the `self` of the impl with fresh\n             // variables for each parameter:\n             let {substs: impl_substs, ty: impl_ty} =\n-                impl_self_ty(self.fcx, im.did);\n+                impl_self_ty(self.fcx, im.did, need_rp);\n \n-            let impl_ty = transform_self_type_for_method(self.fcx,\n-                                                         impl_ty,\n-                                                         *m);\n+            let impl_ty = transform_self_type_for_method(\n+                self.tcx(), impl_substs.self_r,\n+                impl_ty, m.self_type);\n \n             // Depending on our argument, we find potential\n             // matches either by checking subtypability or"}, {"sha": "75f5ca3cbd8034412d1c5a4c7b94ea3edab19c83", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -22,6 +22,17 @@ fn replace_bound_regions_in_fn_ty(\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n \n+    match self_info {\n+      some({explicit_self: ast::sty_region(m), _}) => {\n+        let region = ty::re_bound(ty::br_self);\n+        let ty = ty::mk_rptr(tcx, region,\n+                             { ty: ty::mk_self(tcx), mutbl: m });\n+        vec::push(all_tys, ty);\n+      }\n+      _ => {}\n+    }\n+\n+\n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n     debug!{\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n@@ -50,7 +61,7 @@ fn replace_bound_regions_in_fn_ty(\n     // Glue updated self_ty back together with its original node_id.\n     let new_self_info = match self_info {\n         some(s) => match check t_self {\n-          some(t) => some({self_ty: t, node_id: s.node_id})\n+          some(t) => some({self_ty: t with s})\n           // this 'none' case shouldn't happen\n         },\n         none => none"}, {"sha": "d509b26b8417ae8e1765347e7022d9220d1a95ef", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e640a66eb494d991e570f9827e7b00122ea538b0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e640a66eb494d991e570f9827e7b00122ea538b0", "patch": "@@ -146,7 +146,7 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                         // check whether the type unifies with the type\n                         // that the impl is for, and continue if not\n                         let {substs: substs, ty: for_ty} =\n-                            impl_self_ty(fcx, im.did);\n+                            impl_self_ty(fcx, im.did, false);\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         match fcx.mk_subty(ty, for_ty) {\n                           result::err(_) => again,"}]}