{"sha": "01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZDJiNGFiNmJkYjMzZTg2NzhjNDM2MTJiODFkYmJiYWQzMmNjOTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-16T01:23:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-21T08:42:24Z"}, "message": "port compiletest to use JSON output\n\nThis uncovered a lot of bugs in compiletest and also some shortcomings\nof our existing JSON output. We had to add information to the JSON\noutput, such as suggested text and macro backtraces. We also had to fix\nvarious bugs in the existing tests.\n\nJoint work with jntrnr.", "tree": {"sha": "52555f0d2ff0853d7bcfdb22bc02b9c150807397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52555f0d2ff0853d7bcfdb22bc02b9c150807397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "html_url": "https://github.com/rust-lang/rust/commit/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95545e7adcf1715eff2a31a53fe25ce2b012e62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/95545e7adcf1715eff2a31a53fe25ce2b012e62b", "html_url": "https://github.com/rust-lang/rust/commit/95545e7adcf1715eff2a31a53fe25ce2b012e62b"}], "stats": {"total": 1080, "additions": 606, "deletions": 474}, "files": [{"sha": "02b95f5b1a9276ecd6aa7d1ce23f3cf41f3e98e7", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -128,7 +128,7 @@ DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_const_eval\n \n \n-TOOL_DEPS_compiletest := test getopts log\n+TOOL_DEPS_compiletest := test getopts log serialize\n TOOL_DEPS_rustdoc := rustdoc\n TOOL_DEPS_rustc := rustc_driver\n TOOL_DEPS_rustbook := std rustdoc"}, {"sha": "69274689e5c5706cba843cd120b376be0cdf6b9e", "filename": "src/compiletest/json.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Fcompiletest%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Fcompiletest%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fjson.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use errors::{Error, ErrorKind};\n+use rustc_serialize::json;\n+use std::str::FromStr;\n+\n+// These structs are a subset of the ones found in\n+// `syntax::errors::json`.\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+struct Diagnostic {\n+    message: String,\n+    code: Option<DiagnosticCode>,\n+    level: String,\n+    spans: Vec<DiagnosticSpan>,\n+    children: Vec<Diagnostic>,\n+    rendered: Option<String>,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Clone)]\n+struct DiagnosticSpan {\n+    file_name: String,\n+    line_start: usize,\n+    line_end: usize,\n+    column_start: usize,\n+    column_end: usize,\n+    expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Clone)]\n+struct DiagnosticSpanMacroExpansion {\n+    /// span where macro was applied to generate this code\n+    span: DiagnosticSpan,\n+\n+    /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n+    macro_decl_name: String,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, Clone)]\n+struct DiagnosticCode {\n+    /// The code itself.\n+    code: String,\n+    /// An explanation for the code.\n+    explanation: Option<String>,\n+}\n+\n+pub fn parse_output(file_name: &str, output: &str) -> Vec<Error> {\n+    output.lines()\n+          .flat_map(|line| parse_line(file_name, line))\n+          .collect()\n+}\n+\n+fn parse_line(file_name: &str, line: &str) -> Vec<Error> {\n+    // The compiler sometimes intermingles non-JSON stuff into the\n+    // output.  This hack just skips over such lines. Yuck.\n+    if line.chars().next() == Some('{') {\n+        match json::decode::<Diagnostic>(line) {\n+            Ok(diagnostic) => {\n+                let mut expected_errors = vec![];\n+                push_expected_errors(&mut expected_errors, &diagnostic, file_name);\n+                expected_errors\n+            }\n+            Err(error) => {\n+                println!(\"failed to decode compiler output as json: `{}`\", error);\n+                panic!(\"failed to decode compiler output as json\");\n+            }\n+        }\n+    } else {\n+        vec![]\n+    }\n+}\n+\n+fn push_expected_errors(expected_errors: &mut Vec<Error>,\n+                        diagnostic: &Diagnostic,\n+                        file_name: &str) {\n+    // We only consider messages pertaining to the current file.\n+    let matching_spans =\n+        || diagnostic.spans.iter().filter(|span| span.file_name == file_name);\n+    let with_code =\n+        |span: &DiagnosticSpan, text: &str| match diagnostic.code {\n+            Some(ref code) =>\n+                // FIXME(#33000) -- it'd be better to use a dedicated\n+                // UI harness than to include the line/col number like\n+                // this, but some current tests rely on it.\n+                //\n+                // Note: Do NOT include the filename. These can easily\n+                // cause false matches where the expected message\n+                // appears in the filename, and hence the message\n+                // changes but the test still passes.\n+                format!(\"{}:{}: {}:{}: {} [{}]\",\n+                        span.line_start, span.column_start,\n+                        span.line_end, span.column_end,\n+                        text, code.code.clone()),\n+            None =>\n+                // FIXME(#33000) -- it'd be better to use a dedicated UI harness\n+                format!(\"{}:{}: {}:{}: {}\",\n+                        span.line_start, span.column_start,\n+                        span.line_end, span.column_end,\n+                        text),\n+        };\n+\n+    // Convert multi-line messages into multiple expected\n+    // errors. We expect to replace these with something\n+    // more structured shortly anyhow.\n+    let mut message_lines = diagnostic.message.lines();\n+    if let Some(first_line) = message_lines.next() {\n+        for span in matching_spans() {\n+            let msg = with_code(span, first_line);\n+            let kind = ErrorKind::from_str(&diagnostic.level).ok();\n+            expected_errors.push(\n+                Error {\n+                    line_num: span.line_start,\n+                    kind: kind,\n+                    msg: msg,\n+                }\n+            );\n+        }\n+    }\n+    for next_line in message_lines {\n+        for span in matching_spans() {\n+            expected_errors.push(\n+                Error {\n+                    line_num: span.line_start,\n+                    kind: None,\n+                    msg: with_code(span, next_line),\n+                }\n+            );\n+        }\n+    }\n+\n+    // If the message has a suggestion, register that.\n+    if let Some(ref rendered) = diagnostic.rendered {\n+        let start_line = matching_spans().map(|s| s.line_start).min().expect(\"\\\n+            every suggestion should have at least one span\");\n+        for (index, line) in rendered.lines().enumerate() {\n+            expected_errors.push(\n+                Error {\n+                    line_num: start_line + index,\n+                    kind: Some(ErrorKind::Suggestion),\n+                    msg: line.to_string()\n+                }\n+            );\n+        }\n+    }\n+\n+    // Add notes for the backtrace\n+    for span in matching_spans() {\n+        for frame in &span.expansion {\n+            push_backtrace(expected_errors,\n+                           frame,\n+                           file_name);\n+        }\n+    }\n+\n+    // Flatten out the children.\n+    for child in &diagnostic.children {\n+        push_expected_errors(expected_errors, child, file_name);\n+    }\n+}\n+\n+fn push_backtrace(expected_errors: &mut Vec<Error>,\n+                  expansion: &DiagnosticSpanMacroExpansion,\n+                  file_name: &str) {\n+    if expansion.span.file_name == file_name {\n+        expected_errors.push(\n+            Error {\n+                line_num: expansion.span.line_start,\n+                kind: Some(ErrorKind::Note),\n+                msg: format!(\"in this expansion of {}\", expansion.macro_decl_name),\n+            }\n+        );\n+    }\n+\n+    for previous_expansion in &expansion.span.expansion {\n+        push_backtrace(expected_errors, previous_expansion, file_name);\n+    }\n+}"}, {"sha": "35aa827782ddfee63bcd845734811e3a0562de64", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -1394,6 +1394,56 @@ impl CodeMap {\n     pub fn count_lines(&self) -> usize {\n         self.files.borrow().iter().fold(0, |a, f| a + f.count_lines())\n     }\n+\n+    pub fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n+        let mut last_span = DUMMY_SP;\n+        let mut span = span;\n+        let mut result = vec![];\n+        loop {\n+            let span_name_span = self.with_expn_info(span.expn_id, |expn_info| {\n+                expn_info.map(|ei| {\n+                    let (pre, post) = match ei.callee.format {\n+                        MacroAttribute(..) => (\"#[\", \"]\"),\n+                        MacroBang(..) => (\"\", \"!\"),\n+                    };\n+                    let macro_decl_name = format!(\"{}{}{}\",\n+                                                  pre,\n+                                                  ei.callee.name(),\n+                                                  post);\n+                    let def_site_span = ei.callee.span;\n+                    (ei.call_site, macro_decl_name, def_site_span)\n+                })\n+            });\n+\n+            match span_name_span {\n+                None => break,\n+                Some((call_site, macro_decl_name, def_site_span)) => {\n+                    // Don't print recursive invocations\n+                    if !call_site.source_equal(&last_span) {\n+                        result.push(MacroBacktrace {\n+                            call_site: call_site,\n+                            macro_decl_name: macro_decl_name,\n+                            def_site_span: def_site_span,\n+                        });\n+                    }\n+                    last_span = span;\n+                    span = call_site;\n+                }\n+            }\n+        }\n+        result\n+    }\n+}\n+\n+pub struct MacroBacktrace {\n+    /// span where macro was applied to generate this code\n+    pub call_site: Span,\n+\n+    /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n+    pub macro_decl_name: String,\n+\n+    /// span where macro was defined (if known)\n+    pub def_site_span: Option<Span>,\n }\n \n // _____________________________________________________________________________"}, {"sha": "0b5234769b219d6f83484b3dcd89870919d24aa2", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -577,46 +577,17 @@ impl EmitterWriter {\n     fn print_macro_backtrace(&mut self,\n                              sp: Span)\n                              -> io::Result<()> {\n-        let mut last_span = codemap::DUMMY_SP;\n-        let mut span = sp;\n-\n-        loop {\n-            let span_name_span = self.cm.with_expn_info(span.expn_id, |expn_info| {\n-                expn_info.map(|ei| {\n-                    let (pre, post) = match ei.callee.format {\n-                        codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n-                        codemap::MacroBang(..) => (\"\", \"!\"),\n-                    };\n-                    let macro_decl_name = format!(\"in this expansion of {}{}{}\",\n-                                                  pre,\n-                                                  ei.callee.name(),\n-                                                  post);\n-                    let def_site_span = ei.callee.span;\n-                    (ei.call_site, macro_decl_name, def_site_span)\n-                })\n-            });\n-            let (macro_decl_name, def_site_span) = match span_name_span {\n-                None => break,\n-                Some((sp, macro_decl_name, def_site_span)) => {\n-                    span = sp;\n-                    (macro_decl_name, def_site_span)\n-                }\n-            };\n-\n-            // Don't print recursive invocations\n-            if !span.source_equal(&last_span) {\n-                let mut diag_string = macro_decl_name;\n-                if let Some(def_site_span) = def_site_span {\n-                    diag_string.push_str(&format!(\" (defined in {})\",\n-                                                  self.cm.span_to_filename(def_site_span)));\n-                }\n-\n-                let snippet = self.cm.span_to_string(span);\n-                print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n+        for trace in self.cm.macro_backtrace(sp) {\n+            let mut diag_string =\n+                format!(\"in this expansion of {}\", trace.macro_decl_name);\n+            if let Some(def_site_span) = trace.def_site_span {\n+                diag_string.push_str(\n+                    &format!(\" (defined in {})\",\n+                        self.cm.span_to_filename(def_site_span)));\n             }\n-            last_span = span;\n+            let snippet = self.cm.span_to_string(sp);\n+            print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n         }\n-\n         Ok(())\n     }\n }"}, {"sha": "5a195e9f0788b46828e75a43b69537a26af64cb2", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 167, "deletions": 84, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -20,13 +20,14 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{self, Span, MultiSpan, CodeMap};\n+use codemap::{self, Span, MacroBacktrace, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n \n use std::rc::Rc;\n use std::io::{self, Write};\n+use std::vec;\n \n use rustc_serialize::json::as_json;\n \n@@ -84,8 +85,12 @@ struct Diagnostic<'a> {\n     /// \"error: internal compiler error\", \"error\", \"warning\", \"note\", \"help\".\n     level: &'static str,\n     spans: Vec<DiagnosticSpan>,\n-    /// Assocaited diagnostic messages.\n+    /// Associated diagnostic messages.\n     children: Vec<Diagnostic<'a>>,\n+    /// The message as rustc would render it. Currently this is only\n+    /// `Some` for \"suggestions\", but eventually it will include all\n+    /// snippets.\n+    rendered: Option<String>,\n }\n \n #[derive(RustcEncodable)]\n@@ -101,16 +106,39 @@ struct DiagnosticSpan {\n     column_end: usize,\n     /// Source text from the start of line_start to the end of line_end.\n     text: Vec<DiagnosticSpanLine>,\n+    /// If we are suggesting a replacement, this will contain text\n+    /// that should be sliced in atop this span. You may prefer to\n+    /// load the fully rendered version from the parent `Diagnostic`,\n+    /// however.\n+    suggested_replacement: Option<String>,\n+    /// Macro invocations that created the code at this span, if any.\n+    expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n #[derive(RustcEncodable)]\n struct DiagnosticSpanLine {\n     text: String,\n+\n     /// 1-based, character offset in self.text.\n     highlight_start: usize,\n+\n     highlight_end: usize,\n }\n \n+#[derive(RustcEncodable)]\n+struct DiagnosticSpanMacroExpansion {\n+    /// span where macro was applied to generate this code; note that\n+    /// this may itself derive from a macro (if\n+    /// `span.expansion.is_some()`)\n+    span: DiagnosticSpan,\n+\n+    /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n+    macro_decl_name: String,\n+\n+    /// span where macro was defined (if known)\n+    def_site_span: Option<DiagnosticSpan>,\n+}\n+\n #[derive(RustcEncodable)]\n struct DiagnosticCode {\n     /// The code itself.\n@@ -132,6 +160,7 @@ impl<'a> Diagnostic<'a> {\n             level: level.to_str(),\n             spans: msp.map_or(vec![], |msp| DiagnosticSpan::from_multispan(msp, je)),\n             children: vec![],\n+            rendered: None,\n         }\n     }\n \n@@ -146,6 +175,7 @@ impl<'a> Diagnostic<'a> {\n             level: level.to_str(),\n             spans: DiagnosticSpan::from_render_span(span, je),\n             children: vec![],\n+            rendered: je.render(span),\n         }\n     }\n \n@@ -160,6 +190,7 @@ impl<'a> Diagnostic<'a> {\n             children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n             }).collect(),\n+            rendered: None,\n         }\n     }\n \n@@ -173,37 +204,93 @@ impl<'a> Diagnostic<'a> {\n                      .or_else(|| db.span.as_ref().map(|s| DiagnosticSpan::from_multispan(s, je)))\n                      .unwrap_or(vec![]),\n             children: vec![],\n+            rendered: db.render_span.as_ref()\n+                                    .and_then(|rsp| je.render(rsp)),\n         }\n     }\n }\n \n impl DiagnosticSpan {\n+    fn from_span(span: Span, suggestion: Option<&String>, je: &JsonEmitter)\n+                 -> DiagnosticSpan {\n+        // obtain the full backtrace from the `macro_backtrace`\n+        // helper; in some ways, it'd be better to expand the\n+        // backtrace ourselves, but the `macro_backtrace` helper makes\n+        // some decision, such as dropping some frames, and I don't\n+        // want to duplicate that logic here.\n+        let backtrace = je.cm.macro_backtrace(span).into_iter();\n+        DiagnosticSpan::from_span_and_backtrace(span, suggestion, backtrace, je)\n+    }\n+\n+    fn from_span_and_backtrace(span: Span,\n+                               suggestion: Option<&String>,\n+                               mut backtrace: vec::IntoIter<MacroBacktrace>,\n+                               je: &JsonEmitter)\n+                               -> DiagnosticSpan {\n+        let start = je.cm.lookup_char_pos(span.lo);\n+        let end = je.cm.lookup_char_pos(span.hi);\n+        let backtrace_step =\n+            backtrace.next()\n+                     .map(|bt| {\n+                         let call_site =\n+                             Self::from_span_and_backtrace(bt.call_site,\n+                                                           None,\n+                                                           backtrace,\n+                                                           je);\n+                         let def_site_span =\n+                             bt.def_site_span\n+                               .map(|sp| {\n+                                   Self::from_span_and_backtrace(sp,\n+                                                                 None,\n+                                                                 vec![].into_iter(),\n+                                                                 je)\n+                               });\n+                         Box::new(DiagnosticSpanMacroExpansion {\n+                             span: call_site,\n+                             macro_decl_name: bt.macro_decl_name,\n+                             def_site_span: def_site_span,\n+                         })\n+                     });\n+        DiagnosticSpan {\n+            file_name: start.file.name.clone(),\n+            byte_start: span.lo.0,\n+            byte_end: span.hi.0,\n+            line_start: start.line,\n+            line_end: end.line,\n+            column_start: start.col.0 + 1,\n+            column_end: end.col.0 + 1,\n+            text: DiagnosticSpanLine::from_span(span, je),\n+            suggested_replacement: suggestion.cloned(),\n+            expansion: backtrace_step,\n+        }\n+    }\n+\n     fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n-        msp.spans.iter().map(|span| {\n-            let start = je.cm.lookup_char_pos(span.lo);\n-            let end = je.cm.lookup_char_pos(span.hi);\n-            DiagnosticSpan {\n-                file_name: start.file.name.clone(),\n-                byte_start: span.lo.0,\n-                byte_end: span.hi.0,\n-                line_start: start.line,\n-                line_end: end.line,\n-                column_start: start.col.0 + 1,\n-                column_end: end.col.0 + 1,\n-                text: DiagnosticSpanLine::from_span(span, je),\n-            }\n-        }).collect()\n+        msp.spans.iter().map(|&span| Self::from_span(span, None, je)).collect()\n+    }\n+\n+    fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n+                       -> Vec<DiagnosticSpan> {\n+        assert_eq!(suggestion.msp.spans.len(), suggestion.substitutes.len());\n+        suggestion.msp.spans.iter()\n+                            .zip(&suggestion.substitutes)\n+                            .map(|(&span, suggestion)| {\n+                                DiagnosticSpan::from_span(span, Some(suggestion), je)\n+                            })\n+                            .collect()\n     }\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            RenderSpan::FullSpan(ref msp) |\n-            // FIXME(#30701) handle Suggestion properly\n-            RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n+            RenderSpan::FileLine(ref msp) |\n+            RenderSpan::FullSpan(ref msp) => {\n                 DiagnosticSpan::from_multispan(msp, je)\n             }\n+            RenderSpan::Suggestion(ref suggestion) => {\n+                DiagnosticSpan::from_suggestion(suggestion, je)\n+            }\n             RenderSpan::EndSpan(ref msp) => {\n-                msp.spans.iter().map(|span| {\n+                msp.spans.iter().map(|&span| {\n                     let end = je.cm.lookup_char_pos(span.hi);\n                     DiagnosticSpan {\n                         file_name: end.file.name.clone(),\n@@ -214,37 +301,11 @@ impl DiagnosticSpan {\n                         column_start: end.col.0 + 1,\n                         column_end: end.col.0 + 1,\n                         text: DiagnosticSpanLine::from_span_end(span, je),\n+                        suggested_replacement: None,\n+                        expansion: None,\n                     }\n                 }).collect()\n             }\n-            RenderSpan::FileLine(ref msp) => {\n-                msp.spans.iter().map(|span| {\n-                    let start = je.cm.lookup_char_pos(span.lo);\n-                    let end = je.cm.lookup_char_pos(span.hi);\n-                    DiagnosticSpan {\n-                        file_name: start.file.name.clone(),\n-                        byte_start: span.lo.0,\n-                        byte_end: span.hi.0,\n-                        line_start: start.line,\n-                        line_end: end.line,\n-                        column_start: 0,\n-                        column_end: 0,\n-                        text: DiagnosticSpanLine::from_span(span, je),\n-                    }\n-                }).collect()\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! get_lines_for_span {\n-    ($span: ident, $je: ident) => {\n-        match $je.cm.span_to_lines(*$span) {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                debug!(\"unprintable span\");\n-                return Vec::new();\n-            }\n         }\n     }\n }\n@@ -265,45 +326,49 @@ impl DiagnosticSpanLine {\n     /// Create a list of DiagnosticSpanLines from span - each line with any part\n     /// of `span` gets a DiagnosticSpanLine, with the highlight indicating the\n     /// `span` within the line.\n-    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = get_lines_for_span!(span, je);\n-\n-        let mut result = Vec::new();\n-        let fm = &*lines.file;\n-\n-        for line in &lines.lines {\n-            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n-                                                              line.line_index,\n-                                                              line.start_col.0 + 1,\n-                                                              line.end_col.0 + 1));\n-        }\n-\n-        result\n+    fn from_span(span: Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        je.cm.span_to_lines(span)\n+             .map(|lines| {\n+                 let fm = &*lines.file;\n+                 lines.lines\n+                      .iter()\n+                      .map(|line| {\n+                          DiagnosticSpanLine::line_from_filemap(fm,\n+                                                                line.line_index,\n+                                                                line.start_col.0 + 1,\n+                                                                line.end_col.0 + 1)\n+                      })\n+                     .collect()\n+             })\n+            .unwrap_or(vec![])\n     }\n \n     /// Create a list of DiagnosticSpanLines from span - the result covers all\n     /// of `span`, but the highlight is zero-length and at the end of `span`.\n-    fn from_span_end(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = get_lines_for_span!(span, je);\n-\n-        let mut result = Vec::new();\n-        let fm = &*lines.file;\n-\n-        for (i, line) in lines.lines.iter().enumerate() {\n-            // Invariant - CodeMap::span_to_lines will not return extra context\n-            // lines - the last line returned is the last line of `span`.\n-            let highlight = if i == lines.lines.len() - 1 {\n-                (line.end_col.0 + 1, line.end_col.0 + 1)\n-            } else {\n-                (0, 0)\n-            };\n-            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n-                                                              line.line_index,\n-                                                              highlight.0,\n-                                                              highlight.1));\n-        }\n-\n-        result\n+    fn from_span_end(span: Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        je.cm.span_to_lines(span)\n+             .map(|lines| {\n+                 let fm = &*lines.file;\n+                 lines.lines.iter()\n+                            .enumerate()\n+                            .map(|(i, line)| {\n+                                // Invariant - CodeMap::span_to_lines\n+                                // will not return extra context lines\n+                                // - the last line returned is the last\n+                                // line of `span`.\n+                                let highlight = if i == lines.lines.len() - 1 {\n+                                    (line.end_col.0 + 1, line.end_col.0 + 1)\n+                                } else {\n+                                    (0, 0)\n+                                };\n+                                DiagnosticSpanLine::line_from_filemap(fm,\n+                                                                      line.line_index,\n+                                                                      highlight.0,\n+                                                                      highlight.1)\n+                            })\n+                            .collect()\n+             })\n+            .unwrap_or(vec![])\n     }\n }\n \n@@ -322,3 +387,21 @@ impl DiagnosticCode {\n         })\n     }\n }\n+\n+impl JsonEmitter {\n+    fn render(&self, render_span: &RenderSpan) -> Option<String> {\n+        match *render_span {\n+            RenderSpan::FileLine(_) |\n+            RenderSpan::FullSpan(_) => {\n+                None\n+            }\n+            RenderSpan::Suggestion(ref suggestion) => {\n+                Some(suggestion.splice_lines(&self.cm))\n+            }\n+            RenderSpan::EndSpan(_) => {\n+                None\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "68fba56427cc50f59617b761f90cee277945f71f", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -28,8 +28,8 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n pub fn f1_int_int() {\n     f1(2i32, 4i32);\n     //~^ ERROR mismatched types\n-    //~| expected u32\n-    //~| found i32\n+    //~| expected `u32`\n+    //~| found `i32`\n }\n \n pub fn f1_int_uint() {"}, {"sha": "2a6c71dbe39232abb0412ef6ff1e0f633cb31585", "filename": "src/test/compile-fail/block-must-not-have-result-do.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,9 +11,5 @@\n fn main() {\n     loop {\n         true //~  ERROR mismatched types\n-             //~| expected ()\n-             //~| found bool\n-             //~| expected ()\n-             //~| found bool\n     }\n }"}, {"sha": "8728685fc8b026e4f8cf4f4559278eb96c119e5c", "filename": "src/test/compile-fail/block-must-not-have-result-res.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -13,10 +13,6 @@ struct r;\n impl Drop for r {\n     fn drop(&mut self) {\n         true //~  ERROR mismatched types\n-             //~| expected ()\n-             //~| found bool\n-             //~| expected ()\n-             //~| found bool\n     }\n }\n "}, {"sha": "af42d5c275c75a49055a0339bd40323ff20ee50e", "filename": "src/test/compile-fail/cast-as-bool.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-as-bool.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,6 +11,5 @@\n fn main() {\n     let u = 5 as bool;\n     //~^ ERROR cannot cast as `bool`\n-    //~^^ HELP compare with zero instead\n-    //~^^^ HELP run `rustc --explain E0054` to see a detailed explanation\n+    //~| HELP compare with zero instead\n }"}, {"sha": "b81617abcf4b0618c159b42429947885c4a696b3", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -60,12 +60,10 @@ fn main()\n     //~^^ HELP through a usize first\n     let _ = 3 as bool;\n     //~^ ERROR cannot cast as `bool`\n-    //~^^ HELP compare with zero\n-    //~^^^ HELP run `rustc --explain E0054` to see a detailed explanation\n+    //~| HELP compare with zero\n     let _ = E::A as bool;\n     //~^ ERROR cannot cast as `bool`\n-    //~^^ HELP compare with zero\n-    //~^^^ HELP run `rustc --explain E0054` to see a detailed explanation\n+    //~| HELP compare with zero\n     let _ = 0x61u32 as char; //~ ERROR only `u8` can be cast\n \n     let _ = false as f32;\n@@ -92,9 +90,8 @@ fn main()\n     let _ = v as *const [u8]; //~ ERROR cannot cast\n     let _ = fat_v as *const Foo;\n     //~^ ERROR the trait bound `[u8]: std::marker::Sized` is not satisfied\n-    //~^^ HELP run `rustc --explain E0277` to see a detailed explanation\n-    //~^^^ NOTE `[u8]` does not have a constant size known at compile-time\n-    //~^^^^ NOTE required for the cast to the object type `Foo`\n+    //~| NOTE `[u8]` does not have a constant size known at compile-time\n+    //~| NOTE required for the cast to the object type `Foo`\n     let _ = foo as *const str; //~ ERROR casting\n     let _ = foo as *mut str; //~ ERROR casting\n     let _ = main as *mut str; //~ ERROR casting\n@@ -107,9 +104,8 @@ fn main()\n     let a : *const str = \"hello\";\n     let _ = a as *const Foo;\n     //~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n-    //~^^ HELP run `rustc --explain E0277` to see a detailed explanation\n-    //~^^^ NOTE `str` does not have a constant size known at compile-time\n-    //~^^^^ NOTE required for the cast to the object type `Foo`\n+    //~| NOTE `str` does not have a constant size known at compile-time\n+    //~| NOTE required for the cast to the object type `Foo`\n \n     // check no error cascade\n     let _ = main.f as *const u32; //~ ERROR attempted access of field"}, {"sha": "7fd1b17f2966c9c1baae5155e76c9426f1aa0845", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -20,7 +20,7 @@ impl<T: MyTrait> !Send for TestType<T> {}\n //~^ ERROR conflicting implementations of trait `std::marker::Send`\n \n unsafe impl<T:'static> Send for TestType<T> {}\n-//~^ ERROR error: conflicting implementations of trait `std::marker::Send`\n+//~^ ERROR conflicting implementations of trait `std::marker::Send`\n \n impl !Send for TestType<i32> {}\n "}, {"sha": "2e110cb3d0bc88f16f89d6bb4742b5513c7cf8d5", "filename": "src/test/compile-fail/consider-removing-last-semi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconsider-removing-last-semi.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n fn f() -> String {  //~ ERROR E0269\n-                    //~^ HELP detailed explanation\n     0u8;\n     \"bla\".to_string();  //~ HELP consider removing this semicolon\n }\n \n fn g() -> String {  //~ ERROR E0269\n-                    //~^ HELP detailed explanation\n     \"this won't work\".to_string();\n     \"removeme\".to_string(); //~ HELP consider removing this semicolon\n }"}, {"sha": "05733762d37ad1f637e49ad6bd433196dad89378", "filename": "src/test/compile-fail/empty-struct-unit-pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-unit-pat.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -37,11 +37,11 @@ fn main() {\n     // }\n     match e2 {\n         Empty2(..) => () //~ ERROR `Empty2` does not name a tuple variant or a tuple struct\n-            //~^ ERROR hard error\n+            //~^ WARNING hard error\n     }\n     match xe2 {\n         XEmpty2(..) => () //~ ERROR `XEmpty2` does not name a tuple variant or a tuple struct\n-            //~^ ERROR hard error\n+            //~^ WARNING hard error\n     }\n     // Rejected by parser as yet\n     // match e4 {\n@@ -53,11 +53,11 @@ fn main() {\n     // }\n     match e4 {\n         E::Empty4(..) => () //~ ERROR `E::Empty4` does not name a tuple variant or a tuple struct\n-            //~^ ERROR hard error\n+            //~^ WARNING hard error\n     }\n     match xe4 {\n         XE::XEmpty4(..) => (), //~ ERROR `XE::XEmpty4` does not name a tuple variant or a tuple\n-            //~^ ERROR hard error\n+            //~^ WARNING hard error\n         _ => {},\n     }\n }"}, {"sha": "a01db18a34a7fcfc4aff97615c98c3a9ad67e19d", "filename": "src/test/compile-fail/integer-literal-suffix-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finteger-literal-suffix-inference.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -143,7 +143,7 @@ fn main() {\n     id_i64(a16);\n     //~^ ERROR mismatched types\n     //~| expected `i64`\n-    //~| found i16\n+    //~| found `i16`\n     id_i64(a32);\n     //~^ ERROR mismatched types\n     //~| expected `i64`"}, {"sha": "998576097a0a06887275de88b1d82149f2fcae6e", "filename": "src/test/compile-fail/issue-11714.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11714.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n fn blah() -> i32 { //~ ERROR not all control paths return a value\n-    //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n     1\n \n     ; //~ HELP consider removing this semicolon:"}, {"sha": "de578257e46848201f1421a7468aca877eb1846e", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -36,5 +36,4 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n-//~| HELP run `rustc --explain E0308` to see a detailed explanation\n }"}, {"sha": "c771970650d31e2bee64641e787dabc1c188d04f", "filename": "src/test/compile-fail/issue-13428.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13428.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,7 +11,6 @@\n // Regression test for #13428\n \n fn foo() -> String {  //~ ERROR not all control paths return a value\n-    //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n     format!(\"Hello {}\",\n             \"world\")\n     // Put the trailing semicolon on its own line to test that the\n@@ -20,7 +19,6 @@ fn foo() -> String {  //~ ERROR not all control paths return a value\n }\n \n fn bar() -> String {  //~ ERROR not all control paths return a value\n-    //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n     \"foobar\".to_string()\n     ;   //~ HELP consider removing this semicolon\n }"}, {"sha": "8d98fe313349b89a59614394ce2e9f562046beac", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -17,7 +17,7 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected `[_; 2]`\n     //~| found `[_; 0]`\n-    //~| expected array with a fixed size of 2 elements\n+    //~| expected an array with a fixed size of 2 elements\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "dd7e8a869eca9c3c9d0119f70a03cf281aed76e4", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -19,7 +19,6 @@ struct List<'a, T: ListItem<'a>> {\n //~^ ERROR the parameter type `T` may not live long enough\n //~| HELP consider adding an explicit lifetime bound\n //~| NOTE ...so that the reference type `&'a [T]` does not outlive the data it points at\n-//~| HELP run `rustc --explain E0309` to see a detailed explanation\n }\n impl<'a, T: ListItem<'a>> Collection for List<'a, T> {\n     fn len(&self) -> usize {"}, {"sha": "9affb44b7445c7d07736851368efa81e3e7ddc9d", "filename": "src/test/compile-fail/issue-19707.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19707.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -13,10 +13,8 @@\n \n type foo = fn(&u8, &u8) -> &u8; //~ ERROR missing lifetime specifier\n //~^ HELP the signature does not say whether it is borrowed from argument 1 or argument 2\n-//~^^ HELP run `rustc --explain E0106` to see a detailed explanation\n \n fn bar<F: Fn(&u8, &u8) -> &u8>(f: &F) {} //~ ERROR missing lifetime specifier\n //~^ HELP the signature does not say whether it is borrowed from argument 1 or argument 2\n-//~^^ HELP run `rustc --explain E0106` to see a detailed explanation\n \n fn main() {}"}, {"sha": "9df63583998692931f52c1496887aa130881e382", "filename": "src/test/compile-fail/issue-20862.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-20862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-20862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20862.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -10,11 +10,7 @@\n \n fn foo(x: i32) {\n     |y| x + y\n-//~^ ERROR: mismatched types:\n-//~| expected `()`,\n-//~|     found closure\n-//~| (expected (),\n-//~|     found closure) [E0308]\n+//~^ ERROR: mismatched types\n }\n \n fn main() {"}, {"sha": "2bc9ec3289a5d4afa3f1e90321693d3658f46578", "filename": "src/test/compile-fail/issue-21221-1.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21221-1.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -55,7 +55,6 @@ impl Mul for Foo {\n //~| HELP `mul1::Mul`\n //~| HELP `mul2::Mul`\n //~| HELP `std::ops::Mul`\n-//~| HELP run `rustc --explain E0405` to see a detailed explanation\n //~| HELP you can import several candidates into scope (`use ...;`):\n }\n \n@@ -77,22 +76,19 @@ fn getMul() -> Mul {\n //~| HELP `mul3::Mul`\n //~| HELP `mul4::Mul`\n //~| HELP and 2 other candidates\n-//~| HELP run `rustc --explain E0412` to see a detailed explanation\n //~| HELP you can import several candidates into scope (`use ...;`):\n }\n \n // Let's also test what happens if the trait doesn't exist:\n impl ThisTraitReallyDoesntExistInAnyModuleReally for Foo {\n //~^ ERROR trait `ThisTraitReallyDoesntExistInAnyModuleReally` is not in scope\n-//~^^ HELP run `rustc --explain E0405` to see a detailed explanation\n-//~^^^ HELP no candidates by the name of `ThisTraitReallyDoesntExistInAnyModuleReally` found\n+//~| HELP no candidates by the name of `ThisTraitReallyDoesntExistInAnyModuleReally` found\n }\n \n // Let's also test what happens if there's just one alternative:\n impl Div for Foo {\n //~^ ERROR trait `Div` is not in scope\n //~| HELP `use std::ops::Div;`\n-//~| HELP run `rustc --explain E0405` to see a detailed explanation\n }\n \n fn main() {"}, {"sha": "861acf62d0b58f70e9484a44e54f052264aa6316", "filename": "src/test/compile-fail/issue-21221-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21221-2.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -28,4 +28,3 @@ struct Foo;\n impl T for Foo { }\n //~^ ERROR trait `T` is not in scope\n //~| HELP you can import it into scope: `use foo::bar::T;`.\n-//~| HELP run `rustc --explain E0405` to see a detailed explanation"}, {"sha": "05786e69cefd231e2984ee2ad28dfd9f9eab85f0", "filename": "src/test/compile-fail/issue-21221-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21221-3.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -25,7 +25,6 @@ struct Foo;\n impl OuterTrait for Foo {}\n //~^ ERROR trait `OuterTrait` is not in scope\n //~| HELP you can import it into scope: `use issue_21221_3::outer::OuterTrait;`.\n-//~| HELP run `rustc --explain E0405` to see a detailed explanation\n fn main() {\n     println!(\"Hello, world!\");\n }"}, {"sha": "bcbee16cdcf321f27260056c017b1f9b7e95f95c", "filename": "src/test/compile-fail/issue-21221-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21221-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21221-4.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -20,7 +20,6 @@ struct Foo;\n impl T for Foo {}\n //~^ ERROR trait `T` is not in scope\n //~| HELP you can import it into scope: `use issue_21221_4::T;`.\n-//~| HELP run `rustc --explain E0405` to see a detailed explanation\n \n fn main() {\n     println!(\"Hello, world!\");"}, {"sha": "1d0473ec4b6510ea58ec5922041b8b654cadaac0", "filename": "src/test/compile-fail/issue-21600.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21600.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -23,8 +23,6 @@ fn main() {\n         call_it(|| x.gen());\n         call_it(|| x.gen_mut()); //~ ERROR cannot borrow data mutably in a captured outer\n         //~^ ERROR cannot borrow data mutably in a captured outer\n-        //~^^ HELP run `rustc --explain E0387` to see a detailed explanation\n-        //~^^^ HELP run `rustc --explain E0387` to see a detailed explanation\n-        //~^^^^ HELP consider changing this closure to take self by mutable reference\n+        //~| HELP consider changing this closure to take self by mutable reference\n     });\n }"}, {"sha": "99035209e14bc48aa4482f681a2ddf3d5f27796b", "filename": "src/test/compile-fail/issue-21659-show-relevant-trait-impls-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-1.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -36,5 +36,4 @@ fn main() {\n     //~| help: the following implementations were found:\n     //~| help:   <Bar as Foo<i32>>\n     //~| help:   <Bar as Foo<u8>>\n-    //~| help: run `rustc --explain E0277`\n }"}, {"sha": "2009c32c854365a6bb91973f8f101d9d2b97e5e4", "filename": "src/test/compile-fail/issue-21659-show-relevant-trait-impls-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21659-show-relevant-trait-impls-2.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -43,5 +43,4 @@ fn main() {\n     //~| help:   <Bar as Foo<i32>>\n     //~| help:   <Bar as Foo<u8>>\n     //~| help: and 2 others\n-    //~| help: run `rustc --explain E0277`\n }"}, {"sha": "06b058cbfe1795a5e7ef5b52cd301b8e40731b1d", "filename": "src/test/compile-fail/issue-24036.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24036.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -14,7 +14,6 @@ fn closure_to_loc() {\n     //~^ ERROR mismatched types\n     //~| NOTE no two closures, even if identical, have the same type\n     //~| HELP consider boxing your closure and/or using it as a trait object\n-    //~| HELP run `rustc --explain E0308` to see a detailed explanation\n }\n \n fn closure_from_match() {\n@@ -27,7 +26,6 @@ fn closure_from_match() {\n     //~^^^^^^ ERROR match arms have incompatible types\n     //~| NOTE no two closures, even if identical, have the same type\n     //~| HELP consider boxing your closure and/or using it as a trait object\n-    //~| HELP run `rustc --explain E0308` to see a detailed explanation\n }\n \n fn main() { }"}, {"sha": "a2831fd2b5ac846aeb6304fc934c2987ac03bbad", "filename": "src/test/compile-fail/issue-24446.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24446.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,10 +11,6 @@\n fn main() {\n     static foo: Fn() -> u32 = || -> u32 {\n         //~^ ERROR: mismatched types:\n-        //~| expected `std::ops::Fn() -> u32 + 'static`,\n-        //~| found closure\n-        //~| (expected trait std::ops::Fn,\n-        //~| found closure)\n         0\n     };\n }"}, {"sha": "f918f0aed7a1098cdab57754bbed8b2a69a1df47", "filename": "src/test/compile-fail/issue-26638.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,18 +11,15 @@\n fn parse_type(iter: Box<Iterator<Item=&str>+'static>) -> &str { iter.next() }\n //~^ ERROR missing lifetime specifier [E0106]\n //~^^ HELP 2 elided lifetimes\n-//~^^^ HELP run `rustc --explain E0106` to see a detailed explanation\n \n fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n //~^ ERROR missing lifetime specifier [E0106]\n //~^^ HELP lifetime cannot be derived\n-//~^^^ HELP run `rustc --explain E0106` to see a detailed explanation\n-//~^^^^ HELP consider giving it an explicit bounded or 'static lifetime\n+//~^^^ HELP consider giving it an explicit bounded or 'static lifetime\n \n fn parse_type_3() -> &str { unimplemented!() }\n //~^ ERROR missing lifetime specifier [E0106]\n //~^^ HELP no value for it to be borrowed from\n-//~^^^ HELP run `rustc --explain E0106` to see a detailed explanation\n-//~^^^^ HELP consider giving it a 'static lifetime\n+//~^^^ HELP consider giving it a 'static lifetime\n \n fn main() {}"}, {"sha": "ae1320c821f8c96ec43abc5f57884a851939addc", "filename": "src/test/compile-fail/issue-30123.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-30123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-30123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30123.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -15,5 +15,5 @@ use issue_30123_aux::*;\n \n fn main() {\n     let ug = Graph::<i32, i32>::new_undirected();\n-    //~^ ERR no associated item named `new_undirected` found for type\n+    //~^ ERROR no associated item named `new_undirected` found for type\n }"}, {"sha": "26508a47224253462be8ff723601771a5af4383f", "filename": "src/test/compile-fail/issue-30302.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30302.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -18,10 +18,8 @@ fn is_empty<T>(s: Stack<T>) -> bool {\n         Nil => true,\n //~^ WARN pattern binding `Nil` is named the same as one of the variants of the type `Stack`\n //~| HELP consider making the path in the pattern qualified: `Stack::Nil`\n-//~| HELP run `rustc --explain E0170` to see a detailed explanation\n         _ => false\n //~^ ERROR unreachable pattern\n-//~| HELP run `rustc --explain E0001` to see a detailed explanation\n     }\n }\n "}, {"sha": "f9d11f3a171c2118c294044f03c75740ebc41fc1", "filename": "src/test/compile-fail/issue-32709.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "previous_filename": "src/test/compile-fail/symbol-names/issue-32709.rs"}, {"sha": "7928c04b9df87b5f3130ea6158933a6a010ada15", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -13,10 +13,6 @@ trait A {\n         || self.b()\n         //~^ ERROR no method named `b` found for type `&Self` in the current scope\n         //~| ERROR mismatched types\n-        //~| expected `()`\n-        //~| found closure\n-        //~| expected ()\n-        //~| found closure\n     }\n }\n fn main() {}"}, {"sha": "66ed817ffa82637ac093bf2c6a01ff67402c62db", "filename": "src/test/compile-fail/issue-6702.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -16,5 +16,4 @@ struct Monster {\n fn main() {\n     let _m = Monster(); //~ ERROR `Monster` is the name of a struct or\n     //~^ HELP did you mean to write: `Monster { /* fields */ }`?\n-    //~| HELP run `rustc --explain E0423` to see a detailed explanation\n }"}, {"sha": "60caca3da57edecfdd1528e3e80698d7317e3dd3", "filename": "src/test/compile-fail/keyword-false-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-false-as-identifier.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test -- FIXME #33010\n+\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py false'\n \n fn main() {"}, {"sha": "716a0ebf21cecc1baea852473cfdc83695653668", "filename": "src/test/compile-fail/keyword-true-as-identifier.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-true-as-identifier.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test -- FIXME #33010\n+\n // This file was auto-generated using 'src/etc/generate-keyword-tests.py true'\n \n fn main() {"}, {"sha": "7355c70ff95e8af82e8477d9eca2a58538bbb791", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -11,15 +11,13 @@\n // Lifetime annotation needed because we have no arguments.\n fn f() -> &isize {    //~ ERROR missing lifetime specifier\n //~^ HELP there is no value for it to be borrowed from\n-//~| HELP run `rustc --explain E0106` to see a detailed explanation\n //~| HELP consider giving it a 'static lifetime\n     panic!()\n }\n \n // Lifetime annotation needed because we have two by-reference parameters.\n fn g(_x: &isize, _y: &isize) -> &isize {    //~ ERROR missing lifetime specifier\n //~^ HELP the signature does not say whether it is borrowed from `_x` or `_y`\n-//~| HELP run `rustc --explain E0106` to see a detailed explanation\n     panic!()\n }\n \n@@ -31,13 +29,11 @@ struct Foo<'a> {\n // and one on the reference.\n fn h(_x: &Foo) -> &isize { //~ ERROR missing lifetime specifier\n //~^ HELP the signature does not say which one of `_x`'s 2 elided lifetimes it is borrowed from\n-//~| HELP run `rustc --explain E0106` to see a detailed explanation\n     panic!()\n }\n \n fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n //~^ HELP this function's return type contains a borrowed value\n-//~| HELP run `rustc --explain E0106` to see a detailed explanation\n //~| HELP consider giving it an explicit bounded or 'static lifetime\n     panic!()\n }"}, {"sha": "19e253e3b8e53c26f6897a84a31a124716fdaa82", "filename": "src/test/compile-fail/lint-change-warnings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -27,5 +27,5 @@ fn bar() {\n \n #[forbid(warnings)]\n fn baz() {\n-    while true {} //~ ERROR: warnings\n+    while true {} //~ ERROR: infinite\n }"}, {"sha": "ad5e3aa3f0606c50bd2ffe1c6248b5b5c4b9dc88", "filename": "src/test/compile-fail/lint-malformed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-malformed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-malformed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-malformed.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny = \"foo\"] //~ ERR malformed lint attribute\n-#![allow(bar = \"baz\")] //~ ERR malformed lint attribute\n+#![deny = \"foo\"] //~ ERROR malformed lint attribute\n+#![allow(bar = \"baz\")] //~ ERROR malformed lint attribute\n \n fn main() { }"}, {"sha": "1498ed4d17ed71513f9d72c0aa49292bb60dc42c", "filename": "src/test/compile-fail/lint-removed-allow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -14,4 +14,4 @@\n #[deny(raw_pointer_derive)]\n #[allow(renamed_and_removed_lints)]\n #[deny(unused_variables)]\n-fn main() { let unused = (); } //~ ERR unused\n+fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "aa7f535aa64b733849a6aba2e92a1ab6a8be815d", "filename": "src/test/compile-fail/lint-removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -15,4 +15,4 @@\n \n #[deny(raw_pointer_derive)] //~ WARN raw_pointer_derive has been removed\n #[deny(unused_variables)]\n-fn main() { let unused = (); } //~ ERR unused\n+fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "ea26c3656e6911fa1daa742cdab1cf50bfdaa786", "filename": "src/test/compile-fail/lint-renamed-allow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -14,4 +14,4 @@\n #[deny(unknown_features)]\n #[allow(renamed_and_removed_lints)]\n #[deny(unused)]\n-fn main() { let unused = (); } //~ ERR unused\n+fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "9e10ddf89ac33143887eaee31d55eec38c15a271", "filename": "src/test/compile-fail/lint-renamed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-renamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-renamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-renamed.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -10,4 +10,4 @@\n \n #[deny(unknown_features)] //~ WARN lint unknown_features has been renamed to unused_features\n #[deny(unused)]\n-fn main() { let unused = (); } //~ ERR unused\n+fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "2de8d849d1915c3c67e4014a8da67c94e5625bee", "filename": "src/test/compile-fail/lint-unknown-lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-unknown-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Flint-unknown-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-lint.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -10,4 +10,4 @@\n \n #![allow(not_a_real_lint)] //~ WARN unknown lint\n #![deny(unused)]\n-fn main() { let unused = (); } //~ ERR unused variable\n+fn main() { let unused = (); } //~ ERROR unused variable"}, {"sha": "03733cc2eb59600003c05546b0349a8e8ebfe279", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -12,19 +12,15 @@\n \n macro_rules! test { () => { fn foo() -> i32 { 1; } } }\n                                            //~^ ERROR not all control paths return a value\n-                                           //~^^ HELP consider removing this semicolon\n-                                           //~^^^ HELP run `rustc --explain E0269` to see a\n+                                           //~| HELP consider removing this semicolon\n \n fn no_return() -> i32 {} //~ ERROR  not all control paths return a value\n-                         //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n \n fn bar(x: u32) -> u32 { //~ ERROR  not all control paths return a value\n-                        //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n     x * 2; //~ HELP consider removing this semicolon\n }\n \n fn baz(x: u64) -> u32 { //~ ERROR  not all control paths return a value\n-                        //~^ HELP run `rustc --explain E0269` to see a detailed explanation\n     x * 2;\n }\n "}, {"sha": "815f75266322354be33e7e7d0742778020d17d98", "filename": "src/test/compile-fail/ref-suggestion.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -14,14 +14,12 @@ fn main() {\n     //~^ HELP use a `ref` binding as shown\n     //~| SUGGESTION let ref y = x;\n     x; //~ ERROR use of moved value\n-    //~^ HELP run `rustc --explain E0382` to see a detailed explanation\n \n     let x = vec![1];\n     let mut y = x;\n     //~^ HELP use a `ref` binding as shown\n     //~| SUGGESTION let ref mut y = x;\n     x; //~ ERROR use of moved value\n-    //~^ HELP run `rustc --explain E0382` to see a detailed explanation\n \n     let x = (Some(vec![1]), ());\n \n@@ -32,5 +30,4 @@ fn main() {\n         _ => {},\n     }\n     x; //~ ERROR use of partially moved value\n-    //~^ HELP run `rustc --explain E0382` to see a detailed explanation\n }"}, {"sha": "8dd9994b234bac1a99aebfdecf5fbb2781d075eb", "filename": "src/test/compile-fail/substs-ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsubsts-ppaux.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -28,7 +28,7 @@ fn foo<'z>() where &'z (): Sized {\n     //[verbose]~| found `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n     //[normal]~^^^^ ERROR mismatched types\n     //[normal]~| expected `()`\n-    //[normal]~| found  `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n+    //[normal]~| found `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n \n \n     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;"}, {"sha": "1d04679fd11e799dd9ebb620163e378d939b02e6", "filename": "src/test/compile-fail/suggest-path-instead-of-mod-dot-item.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-path-instead-of-mod-dot-item.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -27,54 +27,46 @@ fn h1() -> i32 {\n     a.I\n         //~^ ERROR E0425\n         //~| HELP To reference an item from the `a` module, use `a::I`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h2() -> i32 {\n     a.g()\n         //~^ ERROR E0425\n         //~| HELP To call a function from the `a` module, use `a::g(..)`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h3() -> i32 {\n     a.b.J\n         //~^ ERROR E0425\n         //~| HELP To reference an item from the `a` module, use `a::b`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h4() -> i32 {\n     a::b.J\n         //~^ ERROR E0425\n         //~| HELP To reference an item from the `a::b` module, use `a::b::J`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h5() -> i32 {\n     a.b.f()\n         //~^ ERROR E0425\n         //~| HELP To reference an item from the `a` module, use `a::b`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h6() -> i32 {\n     a::b.f()\n         //~^ ERROR E0425\n         //~| HELP To call a function from the `a::b` module, use `a::b::f(..)`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h7() {\n     a::b\n         //~^ ERROR E0425\n         //~| HELP Module `a::b` cannot be the value of an expression\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }\n \n fn h8() -> i32 {\n     a::b()\n         //~^ ERROR E0425\n         //~| HELP No function corresponds to `a::b(..)`\n-        //~| HELP run `rustc --explain E0425` to see a detailed explanation\n }"}, {"sha": "9cf65a9d00d07366a3d44f87eae122c00ebeb63b", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -74,7 +74,7 @@ trait Trait {\n \n impl Trait for usize {\n     fn method<G: Getter<usize>>(&self) {}\n-    //~^ G : Getter<usize>` appears on the impl method but not on the corresponding trait method\n+    //~^ ERROR `G: Getter<usize>` appears on the impl method\n }\n \n fn main() {}"}, {"sha": "fc2ed83b2724d0a2d0be5e9b2b04ab1ca592fb28", "filename": "src/test/compile-fail/trait-object-reference-without-parens-suggestion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -13,10 +13,8 @@ fn main() {\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &(Copy + 'static);\n-    //~| HELP run `rustc --explain E0178` to see a detailed explanation\n     let _: &'static Copy + 'static;\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &'static (Copy + 'static);\n-    //~| HELP run `rustc --explain E0178` to see a detailed explanation\n }"}, {"sha": "a8ff1bae7a71a7ebe1a114721776811cf99bc7ba", "filename": "src/test/compile-fail/trait-suggest-where-clause.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -16,13 +16,11 @@ fn check<T: Iterator, U: ?Sized>() {\n     // suggest a where-clause, if needed\n     mem::size_of::<U>();\n     //~^ ERROR `U: std::marker::Sized` is not satisfied\n-    //~| HELP E0277\n     //~| HELP consider adding a `where U: std::marker::Sized` bound\n     //~| NOTE required by `std::mem::size_of`\n \n     mem::size_of::<Misc<U>>();\n     //~^ ERROR `U: std::marker::Sized` is not satisfied\n-    //~| HELP E0277\n     //~| HELP consider adding a `where U: std::marker::Sized` bound\n     //~| NOTE required because it appears within the type `Misc<U>`\n     //~| NOTE required by `std::mem::size_of`\n@@ -31,34 +29,29 @@ fn check<T: Iterator, U: ?Sized>() {\n \n     <u64 as From<T>>::from;\n     //~^ ERROR `u64: std::convert::From<T>` is not satisfied\n-    //~| HELP E0277\n     //~| HELP consider adding a `where u64: std::convert::From<T>` bound\n     //~| NOTE required by `std::convert::From::from`\n \n     <u64 as From<<T as Iterator>::Item>>::from;\n     //~^ ERROR `u64: std::convert::From<<T as std::iter::Iterator>::Item>` is not satisfied\n-    //~| HELP E0277\n     //~| HELP consider adding a `where u64:\n     //~| NOTE required by `std::convert::From::from`\n \n     // ... but not if there are inference variables\n \n     <Misc<_> as From<T>>::from;\n     //~^ ERROR `Misc<_>: std::convert::From<T>` is not satisfied\n-    //~| HELP E0277\n     //~| NOTE required by `std::convert::From::from`\n \n     // ... and also not if the error is not related to the type\n \n     mem::size_of::<[T]>();\n     //~^ ERROR `[T]: std::marker::Sized` is not satisfied\n-    //~| HELP E0277\n     //~| NOTE `[T]` does not have a constant size\n     //~| NOTE required by `std::mem::size_of`\n \n     mem::size_of::<[&U]>();\n     //~^ ERROR `[&U]: std::marker::Sized` is not satisfied\n-    //~| HELP E0277\n     //~| NOTE `[&U]` does not have a constant size\n     //~| NOTE required by `std::mem::size_of`\n }"}, {"sha": "e81ae5d743939276ec3bb78eae3be3cca259ece9", "filename": "src/test/compile-fail/type-mismatch-same-crate-name.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -24,10 +24,8 @@ fn main() {\n     {\n         extern crate crate_a1 as a;\n         a::try_foo(foo2); //~ ERROR mismatched types\n-                          //~^ HELP run\n-                          //~^^ NOTE Perhaps two different versions of crate `crate_a1`\n+                          //~^ NOTE Perhaps two different versions of crate `crate_a1`\n         a::try_bar(bar2); //~ ERROR mismatched types\n-                          //~^ HELP run\n-                          //~^^ NOTE Perhaps two different versions of crate `crate_a1`\n+                          //~^ NOTE Perhaps two different versions of crate `crate_a1`\n     }\n }"}, {"sha": "862d842d62c2316abdd7a1584fe5744a09182920", "filename": "src/test/compile-fail/variance-unused-type-param.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -16,18 +16,15 @@\n struct SomeStruct<A> { x: u32 }\n //~^ ERROR parameter `A` is never used\n //~| HELP PhantomData\n-//~| HELP run `rustc --explain E0392` to see a detailed explanation\n \n enum SomeEnum<A> { Nothing }\n //~^ ERROR parameter `A` is never used\n //~| HELP PhantomData\n-//~| HELP run `rustc --explain E0392` to see a detailed explanation\n \n // Here T might *appear* used, but in fact it isn't.\n enum ListCell<T> {\n //~^ ERROR parameter `T` is never used\n //~| HELP PhantomData\n-//~| HELP run `rustc --explain E0392` to see a detailed explanation\n     Cons(Box<ListCell<T>>),\n     Nil\n }"}, {"sha": "8caf2e0c0a47732cb6991a18deed40722ea131d0", "filename": "src/test/parse-fail/column-offset-1-based.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fcolumn-offset-1-based.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-# //~ ERROR 13:1: 13:2 error: expected `[`, found `<eof>`\n+# //~ ERROR 13:1: 13:2: expected `[`, found `<eof>`"}, {"sha": "5cc14dfef0ec6ae2a626a2f33be64c4d54dc8eac", "filename": "src/test/parse-fail/keyword-do-as-identifier.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/95545e7adcf1715eff2a31a53fe25ce2b012e62b/src%2Ftest%2Fparse-fail%2Fkeyword-do-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95545e7adcf1715eff2a31a53fe25ce2b012e62b/src%2Ftest%2Fparse-fail%2Fkeyword-do-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-do-as-identifier.rs?ref=95545e7adcf1715eff2a31a53fe25ce2b012e62b", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    let do = \"bar\"; //~ error: ident\n-}"}, {"sha": "e80feb66d60716a1d4b3fe540353d7bb7d53a94f", "filename": "src/test/parse-fail/keyword-priv-as-identifier.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95545e7adcf1715eff2a31a53fe25ce2b012e62b/src%2Ftest%2Fparse-fail%2Fkeyword-priv-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95545e7adcf1715eff2a31a53fe25ce2b012e62b/src%2Ftest%2Fparse-fail%2Fkeyword-priv-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fkeyword-priv-as-identifier.rs?ref=95545e7adcf1715eff2a31a53fe25ce2b012e62b", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py priv'\n-\n-fn main() {\n-    let priv = \"foo\"; //~ error: ident\n-}"}, {"sha": "30bcafd104945cfa5e775fe59a56aef81665b215", "filename": "src/test/run-make/json-errors/Makefile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2FMakefile?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -6,5 +6,4 @@ all:\n \tcp foo.rs $(TMPDIR)\n \tcd $(TMPDIR)\n \t-$(RUSTC) -Z unstable-options --error-format=json foo.rs 2>$(LOG)\n-\tgrep -q '{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\\\nAn unresolved name was used. Example of erroneous codes.*\"},\"level\":\"error\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19,\"text\":\\[{\"text\":\"    let x = 42 + y;\",\"highlight_start\":18,\"highlight_end\":19}\\]}\\],\"children\":\\[\\]}' $(LOG)\n-\tgrep -q '{\"message\":\".*\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\\\nYou tried.*\"},\"level\":\"error\",\"spans\":\\[{.*}\\],\"children\":\\[{\"message\":\"the .*\",\"code\":null,\"level\":\"help\",\"spans\":\\[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":0,\"column_end\":0,\"text\":\\[{.*}\\]}\\],\"children\":\\[\\]},{\"message\":\"  <u8 as std::ops::Add>\",\"code\":null,\"level\":\"help\",' $(LOG)\n+\tdiff foo.json $(LOG)"}, {"sha": "bde669ab0f7f99b6f19076013da9def608a54098", "filename": "src/test/run-make/json-errors/foo.json", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fjson-errors%2Ffoo.json?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -0,0 +1,4 @@\n+{\"message\":\"unresolved name `y`\",\"code\":{\"code\":\"E0425\",\"explanation\":\"\\nAn unresolved name was used. Example of erroneous codes:\\n\\n```compile_fail\\nsomething_that_doesnt_exist::foo;\\n// error: unresolved name `something_that_doesnt_exist::foo`\\n\\n// or:\\n\\ntrait Foo {\\n    fn bar() {\\n        Self; // error: unresolved name `Self`\\n    }\\n}\\n\\n// or:\\n\\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\\n```\\n\\nPlease verify that the name wasn't misspelled and ensure that the\\nidentifier being referred to is valid for the given situation. Example:\\n\\n```\\nenum something_that_does_exist {\\n    Foo,\\n}\\n```\\n\\nOr:\\n\\n```\\nmod something_that_does_exist {\\n    pub static foo : i32 = 0i32;\\n}\\n\\nsomething_that_does_exist::foo; // ok!\\n```\\n\\nOr:\\n\\n```\\nlet unknown_variable = 12u32;\\nlet x = unknown_variable; // ok!\\n```\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":496,\"byte_end\":497,\"line_start\":12,\"line_end\":12,\"column_start\":18,\"column_end\":19,\"text\":[{\"text\":\"    let x = 42 + y;\",\"highlight_start\":18,\"highlight_end\":19}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}\n+{\"message\":\"mismatched types:\\n expected `u8`,\\n    found `i32`\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\\nAnother situation in which this occurs is when you attempt to use the `try!`\\nmacro inside a function that does not return a `Result<T, E>`:\\n\\n```compile_fail\\nuse std::fs::File;\\n\\nfn main() {\\n    let mut f = try!(File::create(\\\"foo.txt\\\"));\\n}\\n```\\n\\nThis code gives an error like this:\\n\\n```text\\n<std macros>:5:8: 6:42 error: mismatched types:\\n expected `()`,\\n     found `core::result::Result<_, _>`\\n (expected (),\\n     found enum `core::result::Result`) [E0308]\\n```\\n\\n`try!` returns a `Result<T, E>`, and so the function must. But `main()` has\\n`()` as its return type, hence the error.\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":511,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":12,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":12,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}\n+{\"message\":\"the trait bound `u8: std::ops::Add<i32>` is not satisfied\",\"code\":{\"code\":\"E0277\",\"explanation\":\"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n```compile_fail\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n```\\n\\n\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[{\"message\":\"the following implementations were found:\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <u8 as std::ops::Add>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <&'a u8 as std::ops::Add<u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <u8 as std::ops::Add<&'a u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null},{\"message\":\"  <&'b u8 as std::ops::Add<&'a u8>>\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"foo.rs\",\"byte_start\":504,\"byte_end\":516,\"line_start\":14,\"line_end\":14,\"column_start\":5,\"column_end\":17,\"text\":[{\"text\":\"    42u8 + 42i32;\",\"highlight_start\":5,\"highlight_end\":17}],\"suggested_replacement\":null,\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":null}\n+{\"message\":\"aborting due to 2 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":null}"}, {"sha": "c3da891933f6df1bb7fcf054063a6afa036d1032", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -28,7 +28,9 @@ pub enum ErrorKind {\n impl FromStr for ErrorKind {\n     type Err = ();\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match &s.trim_right_matches(':') as &str {\n+        let s = s.to_uppercase();\n+        let part0: &str = s.split(':').next().unwrap();\n+        match part0 {\n             \"HELP\" => Ok(ErrorKind::Help),\n             \"ERROR\" => Ok(ErrorKind::Error),\n             \"NOTE\" => Ok(ErrorKind::Note),\n@@ -52,7 +54,8 @@ impl fmt::Display for ErrorKind {\n     }\n }\n \n-pub struct ExpectedError {\n+#[derive(Debug)]\n+pub struct Error {\n     pub line_num: usize,\n     /// What kind of message we expect (e.g. warning, error, suggestion).\n     /// `None` if not specified or unknown message kind.\n@@ -73,7 +76,7 @@ enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n ///\n /// If cfg is not None (i.e., in an incremental test), then we look\n /// for `//[X]~` instead, where `X` is the current `cfg`.\n-pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<ExpectedError> {\n+pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n \n     // `last_nonfollow_error` tracks the most recently seen\n@@ -113,23 +116,38 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n                   line_num: usize,\n                   line: &str,\n                   tag: &str)\n-                  -> Option<(WhichLine, ExpectedError)> {\n+                  -> Option<(WhichLine, Error)> {\n     let start = match line.find(tag) { Some(i) => i, None => return None };\n     let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n         (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n     };\n     let kind_start = start + tag.len() + adjusts + (follow as usize);\n-    let kind = line[kind_start..].split_whitespace()\n-                                 .next()\n-                                 .expect(\"Encountered unexpected empty comment\")\n-                                 .parse::<ErrorKind>()\n-                                 .ok();\n-    let letters = line[kind_start..].chars();\n-    let msg = letters.skip_while(|c| c.is_whitespace())\n-                     .skip_while(|c| !c.is_whitespace())\n-                     .collect::<String>().trim().to_owned();\n+    let (kind, msg);\n+    match\n+        line[kind_start..].split_whitespace()\n+                          .next()\n+                          .expect(\"Encountered unexpected empty comment\")\n+                          .parse::<ErrorKind>()\n+    {\n+        Ok(k) => {\n+            // If we find `//~ ERROR foo` or something like that:\n+            kind = Some(k);\n+            let letters = line[kind_start..].chars();\n+            msg = letters.skip_while(|c| c.is_whitespace())\n+                         .skip_while(|c| !c.is_whitespace())\n+                         .collect::<String>();\n+        }\n+        Err(_) => {\n+            // Otherwise we found `//~ foo`:\n+            kind = None;\n+            let letters = line[kind_start..].chars();\n+            msg = letters.skip_while(|c| c.is_whitespace())\n+                         .collect::<String>();\n+        }\n+    }\n+    let msg = msg.trim().to_owned();\n \n     let (which, line_num) = if follow {\n         assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n@@ -145,7 +163,7 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n \n     debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n            line_num, tag, which, kind, msg);\n-    Some((which, ExpectedError { line_num: line_num,\n-                                 kind: kind,\n-                                 msg: msg, }))\n+    Some((which, Error { line_num: line_num,\n+                         kind: kind,\n+                         msg: msg, }))\n }"}, {"sha": "8e999139a249b2c7d60d674a147a07c00174599b", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -21,6 +21,7 @@\n extern crate libc;\n extern crate test;\n extern crate getopts;\n+extern crate serialize as rustc_serialize;\n \n #[macro_use]\n extern crate log;\n@@ -40,6 +41,7 @@ use util::logv;\n \n pub mod procsrv;\n pub mod util;\n+mod json;\n pub mod header;\n pub mod runtest;\n pub mod common;"}, {"sha": "8770d4b1f4255ccea83114fb63265e701ca857c0", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 113, "deletions": 179, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d2b4ab6bdb33e8678c43612b81dbbbad32cc93/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=01d2b4ab6bdb33e8678c43612b81dbbbad32cc93", "patch": "@@ -12,7 +12,8 @@ use common::Config;\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n use common::{Incremental};\n-use errors::{self, ErrorKind};\n+use errors::{self, ErrorKind, Error};\n+use json;\n use header::TestProps;\n use header;\n use procsrv;\n@@ -26,7 +27,7 @@ use std::fs::{self, File};\n use std::io::BufReader;\n use std::io::prelude::*;\n use std::net::TcpStream;\n-use std::path::{Path, PathBuf, Component};\n+use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n \n pub fn run(config: Config, testpaths: &TestPaths) {\n@@ -944,7 +945,7 @@ fn check_error_patterns(revision: Option<&str>,\n                        testpaths.file.display()));\n     }\n     let mut next_err_idx = 0;\n-    let mut next_err_pat = &props.error_patterns[next_err_idx];\n+    let mut next_err_pat = props.error_patterns[next_err_idx].trim();\n     let mut done = false;\n     for line in output_to_check.lines() {\n         if line.contains(next_err_pat) {\n@@ -955,7 +956,7 @@ fn check_error_patterns(revision: Option<&str>,\n                 done = true;\n                 break;\n             }\n-            next_err_pat = &props.error_patterns[next_err_idx];\n+            next_err_pat = props.error_patterns[next_err_idx].trim();\n         }\n     }\n     if done { return; }\n@@ -998,208 +999,110 @@ fn check_forbid_output(revision: Option<&str>,\n }\n \n fn check_expected_errors(revision: Option<&str>,\n-                         expected_errors: Vec<errors::ExpectedError>,\n+                         expected_errors: Vec<errors::Error>,\n                          testpaths: &TestPaths,\n                          proc_res: &ProcRes) {\n-    // true if we found the error in question\n-    let mut found_flags = vec![false; expected_errors.len()];\n-\n     if proc_res.status.success() {\n         fatal_proc_rec(revision, \"process did not return an error status\", proc_res);\n     }\n \n-    let prefixes = expected_errors.iter().map(|ee| {\n-        let expected = format!(\"{}:{}:\", testpaths.file.display(), ee.line_num);\n-        // On windows just translate all '\\' path separators to '/'\n-        expected.replace(r\"\\\", \"/\")\n-    }).collect::<Vec<String>>();\n+    let file_name =\n+        format!(\"{}\", testpaths.file.display())\n+        .replace(r\"\\\", \"/\"); // on windows, translate all '\\' path separators to '/'\n \n     // If the testcase being checked contains at least one expected \"help\"\n     // message, then we'll ensure that all \"help\" messages are expected.\n     // Otherwise, all \"help\" messages reported by the compiler will be ignored.\n     // This logic also applies to \"note\" messages.\n-    let (expect_help, expect_note) =\n-        expected_errors.iter()\n-                        .fold((false, false),\n-                              |(acc_help, acc_note), ee|\n-                                  (acc_help || ee.kind == Some(ErrorKind::Help),\n-                                   acc_note || ee.kind == Some(ErrorKind::Note)));\n-\n-    // Scan and extract our error/warning messages,\n-    // which look like:\n-    //    filename:line1:col1: line2:col2: *error:* msg\n-    //    filename:line1:col1: line2:col2: *warning:* msg\n-    // where line1:col1: is the starting point, line2:col2:\n-    // is the ending point, and * represents ANSI color codes.\n-    //\n-    // This pattern is ambiguous on windows, because filename may contain\n-    // a colon, so any path prefix must be detected and removed first.\n+    let expect_help = expected_errors.iter().any(|ee| ee.kind == Some(ErrorKind::Help));\n+    let expect_note = expected_errors.iter().any(|ee| ee.kind == Some(ErrorKind::Note));\n+\n+    // Parse the JSON output from the compiler and extract out the messages.\n+    let actual_errors = json::parse_output(&file_name, &proc_res.stderr);\n     let mut unexpected = 0;\n     let mut not_found = 0;\n-    for line in proc_res.stderr.lines() {\n-        let mut was_expected = false;\n-        let mut prev = 0;\n-        for (i, ee) in expected_errors.iter().enumerate() {\n-            if !found_flags[i] {\n-                debug!(\"prefix={} ee.kind={:?} ee.msg={} line={}\",\n-                       prefixes[i],\n-                       ee.kind,\n-                       ee.msg,\n-                       line);\n-                // Suggestions have no line number in their output, so take on the line number of\n-                // the previous expected error\n-                if ee.kind == Some(ErrorKind::Suggestion) {\n-                    assert!(expected_errors[prev].kind == Some(ErrorKind::Help),\n-                            \"SUGGESTIONs must be preceded by a HELP\");\n-                    if line.contains(&ee.msg) {\n-                        found_flags[i] = true;\n-                        was_expected = true;\n-                        break;\n-                    }\n-                }\n-                if\n-                    (prefix_matches(line, &prefixes[i]) || continuation(line)) &&\n-                    (ee.kind.is_none() || line.contains(&ee.kind.as_ref().unwrap().to_string())) &&\n-                    line.contains(&ee.msg)\n-                {\n-                    found_flags[i] = true;\n-                    was_expected = true;\n-                    break;\n-                }\n+    let mut found = vec![false; expected_errors.len()];\n+    for actual_error in &actual_errors {\n+        let opt_index =\n+            expected_errors\n+            .iter()\n+            .enumerate()\n+            .position(|(index, expected_error)| {\n+                !found[index] &&\n+                    actual_error.line_num == expected_error.line_num &&\n+                    (expected_error.kind.is_none() ||\n+                     actual_error.kind == expected_error.kind) &&\n+                    actual_error.msg.contains(&expected_error.msg)\n+            });\n+\n+        match opt_index {\n+            Some(index) => {\n+                // found a match, everybody is happy\n+                assert!(!found[index]);\n+                found[index] = true;\n             }\n-            prev = i;\n-        }\n-\n-        // ignore this msg which gets printed at the end\n-        if line.contains(\"aborting due to\") {\n-            was_expected = true;\n-        }\n \n-        if !was_expected && is_unexpected_compiler_message(line, expect_help, expect_note) {\n-            error(revision, &format!(\"unexpected compiler message: '{}'\", line));\n-            unexpected += 1;\n+            None => {\n+                if is_unexpected_compiler_message(actual_error,\n+                                                  expect_help,\n+                                                  expect_note) {\n+                    error(revision,\n+                          &format!(\"{}:{}: unexpected {:?}: '{}'\",\n+                                   file_name,\n+                                   actual_error.line_num,\n+                                   actual_error.kind.as_ref()\n+                                                    .map_or(String::from(\"message\"),\n+                                                            |k| k.to_string()),\n+                                   actual_error.msg));\n+                    unexpected += 1;\n+                }\n+            }\n         }\n     }\n \n-    for (i, &flag) in found_flags.iter().enumerate() {\n-        if !flag {\n-            let ee = &expected_errors[i];\n-            error(revision, &format!(\"expected {} on line {} not found: {}\",\n-                                     ee.kind.as_ref()\n-                                            .map_or(\"message\".into(),\n-                                                    |k| k.to_string()),\n-                                     ee.line_num, ee.msg));\n+    // anything not yet found is a problem\n+    for (index, expected_error) in expected_errors.iter().enumerate() {\n+        if !found[index] {\n+            error(revision,\n+                  &format!(\"{}:{}: expected {} not found: {}\",\n+                           file_name,\n+                           expected_error.line_num,\n+                           expected_error.kind.as_ref()\n+                                              .map_or(\"message\".into(),\n+                                                      |k| k.to_string()),\n+                           expected_error.msg));\n             not_found += 1;\n         }\n     }\n \n     if unexpected > 0 || not_found > 0 {\n-        fatal_proc_rec(\n-            revision,\n-            &format!(\"{} unexpected errors found, {} expected errors not found\",\n-                     unexpected, not_found),\n-            proc_res);\n-    }\n-\n-    fn prefix_matches(line: &str, prefix: &str) -> bool {\n-        use std::ascii::AsciiExt;\n-        // On windows just translate all '\\' path separators to '/'\n-        let line = line.replace(r\"\\\", \"/\");\n-        if cfg!(windows) {\n-            line.to_ascii_lowercase().starts_with(&prefix.to_ascii_lowercase())\n-        } else {\n-            line.starts_with(prefix)\n-        }\n-    }\n-\n-    // A multi-line error will have followup lines which start with a space\n-    // or open paren.\n-    fn continuation( line: &str) -> bool {\n-        line.starts_with(\" \") || line.starts_with(\"(\")\n-    }\n-}\n-\n-fn is_unexpected_compiler_message(line: &str, expect_help: bool, expect_note: bool) -> bool {\n-    let mut c = Path::new(line).components();\n-    let line = match c.next() {\n-        Some(Component::Prefix(_)) => c.as_path().to_str().unwrap(),\n-        _ => line,\n-    };\n-\n-    let mut i = 0;\n-    return scan_until_char(line, ':', &mut i) &&\n-        scan_char(line, ':', &mut i) &&\n-        scan_integer(line, &mut i) &&\n-        scan_char(line, ':', &mut i) &&\n-        scan_integer(line, &mut i) &&\n-        scan_char(line, ':', &mut i) &&\n-        scan_char(line, ' ', &mut i) &&\n-        scan_integer(line, &mut i) &&\n-        scan_char(line, ':', &mut i) &&\n-        scan_integer(line, &mut i) &&\n-        scan_char(line, ' ', &mut i) &&\n-        (scan_string(line, \"error\", &mut i) ||\n-         scan_string(line, \"warning\", &mut i) ||\n-         (expect_help && scan_string(line, \"help\", &mut i)) ||\n-         (expect_note && scan_string(line, \"note\", &mut i))\n-        );\n-}\n-\n-fn scan_until_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n-    if *idx >= haystack.len() {\n-        return false;\n-    }\n-    let opt = haystack[(*idx)..].find(needle);\n-    if opt.is_none() {\n-        return false;\n-    }\n-    *idx = opt.unwrap();\n-    return true;\n-}\n-\n-fn scan_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n-    if *idx >= haystack.len() {\n-        return false;\n-    }\n-    let ch = haystack[*idx..].chars().next().unwrap();\n-    if ch != needle {\n-        return false;\n-    }\n-    *idx += ch.len_utf8();\n-    return true;\n-}\n-\n-fn scan_integer(haystack: &str, idx: &mut usize) -> bool {\n-    let mut i = *idx;\n-    while i < haystack.len() {\n-        let ch = haystack[i..].chars().next().unwrap();\n-        if ch < '0' || '9' < ch {\n-            break;\n-        }\n-        i += ch.len_utf8();\n-    }\n-    if i == *idx {\n-        return false;\n+        error(revision,\n+              &format!(\"{} unexpected errors found, {} expected errors not found\",\n+                       unexpected, not_found));\n+        print!(\"status: {}\\ncommand: {}\\n\",\n+               proc_res.status, proc_res.cmdline);\n+        println!(\"actual errors (from JSON output): {:#?}\\n\", actual_errors);\n+        println!(\"expected errors (from test file): {:#?}\\n\", expected_errors);\n+        panic!();\n     }\n-    *idx = i;\n-    return true;\n }\n \n-fn scan_string(haystack: &str, needle: &str, idx: &mut usize) -> bool {\n-    let mut haystack_i = *idx;\n-    let mut needle_i = 0;\n-    while needle_i < needle.len() {\n-        if haystack_i >= haystack.len() {\n-            return false;\n-        }\n-        let ch = haystack[haystack_i..].chars().next().unwrap();\n-        haystack_i += ch.len_utf8();\n-        if !scan_char(needle, ch, &mut needle_i) {\n-            return false;\n-        }\n+/// Returns true if we should report an error about `actual_error`,\n+/// which did not match any of the expected error. We always require\n+/// errors/warnings to be explicitly listed, but only require\n+/// helps/notes if there are explicit helps/notes given.\n+fn is_unexpected_compiler_message(actual_error: &Error,\n+                                  expect_help: bool,\n+                                  expect_note: bool)\n+                                  -> bool {\n+    match actual_error.kind {\n+        Some(ErrorKind::Help) => expect_help,\n+        Some(ErrorKind::Note) => expect_note,\n+        Some(ErrorKind::Error) => true,\n+        Some(ErrorKind::Warning) => true,\n+        Some(ErrorKind::Suggestion) => false,\n+        None => false\n     }\n-    *idx = haystack_i;\n-    return true;\n }\n \n struct ProcArgs {\n@@ -1444,6 +1347,37 @@ fn make_compile_args<F>(config: &Config,\n                         \"-L\".to_owned(),\n                         config.build_base.to_str().unwrap().to_owned(),\n                         format!(\"--target={}\", target));\n+\n+    match config.mode {\n+        CompileFail |\n+        ParseFail |\n+        Incremental => {\n+            // If we are extracting and matching errors in the new\n+            // fashion, then you want JSON mode. Old-skool error\n+            // patterns still match the raw compiler output.\n+            if props.error_patterns.is_empty() {\n+                args.extend([\"--error-format\",\n+                             \"json\",\n+                             \"-Z\",\n+                             \"unstable-options\"]\n+                            .iter()\n+                            .map(|s| s.to_string()));\n+            }\n+        }\n+\n+        RunFail |\n+        RunPass |\n+        RunPassValgrind |\n+        Pretty |\n+        DebugInfoGdb |\n+        DebugInfoLldb |\n+        Codegen |\n+        Rustdoc |\n+        CodegenUnits => {\n+            // do not use JSON output\n+        }\n+    }\n+\n     args.extend_from_slice(&extras);\n     if !props.no_prefer_dynamic {\n         args.push(\"-C\".to_owned());"}]}