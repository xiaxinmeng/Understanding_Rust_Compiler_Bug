{"sha": "802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMmVhNWQ1N2U4Y2Q0Y2QxMmUxYTBlMjVjNDQ2YjkwYmU0YTZhMDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-08T15:15:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-08T16:22:07Z"}, "message": "refactor categorization out of borrowck into its own module.\n\nfirst step towards #3148 and #3024.", "tree": {"sha": "4b534889c51e4aaa5dac9c287473801a5ee74955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b534889c51e4aaa5dac9c287473801a5ee74955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "html_url": "https://github.com/rust-lang/rust/commit/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c517383ef57f96ce1a97babc627d03329ac5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c517383ef57f96ce1a97babc627d03329ac5e6", "html_url": "https://github.com/rust-lang/rust/commit/52c517383ef57f96ce1a97babc627d03329ac5e6"}], "stats": {"total": 864, "additions": 494, "deletions": 370}, "files": [{"sha": "b00a8c31ef09c5cf5f608fdb206571a87bbf4991", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 45, "deletions": 202, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -230,6 +230,7 @@ import util::common::indenter;\n import ty::to_str;\n import driver::session::session;\n import dvec::{dvec, extensions};\n+import mem_categorization::*;\n \n export check_crate, root_map, mutbl_map;\n \n@@ -241,7 +242,6 @@ fn check_crate(tcx: ty::ctxt,\n     let bccx = borrowck_ctxt_(@{tcx: tcx,\n                                 method_map: method_map,\n                                 last_use_map: last_use_map,\n-                                binding_map: int_hash(),\n                                 root_map: root_map(),\n                                 mutbl_map: int_hash(),\n                                 mut loaned_paths_same: 0,\n@@ -282,7 +282,6 @@ fn check_crate(tcx: ty::ctxt,\n type borrowck_ctxt_ = {tcx: ty::ctxt,\n                        method_map: typeck::method_map,\n                        last_use_map: liveness::last_use_map,\n-                       binding_map: binding_map,\n                        root_map: root_map,\n                        mutbl_map: mutbl_map,\n \n@@ -313,10 +312,6 @@ type root_map_key = {id: ast::node_id, derefs: uint};\n // this is used in trans for optimization purposes.\n type mutbl_map = std::map::hashmap<ast::node_id, ()>;\n \n-// maps from each binding's id to the mutability of the location it\n-// points at.  See gather_loan.rs for more detail (search for binding_map)\n-type binding_map = std::map::hashmap<ast::node_id, ast::mutability>;\n-\n // Errors that can occur\"]\n enum bckerr_code {\n     err_mut_uniq,\n@@ -334,64 +329,6 @@ type bckerr = {cmt: cmt, code: bckerr_code};\n // shorthand for something that fails with `bckerr` or succeeds with `T`\n type bckres<T> = result<T, bckerr>;\n \n-enum categorization {\n-    cat_rvalue,                     // result of eval'ing some misc expr\n-    cat_special(special_kind),      //\n-    cat_local(ast::node_id),        // local variable\n-    cat_binding(ast::node_id),      // pattern binding\n-    cat_arg(ast::node_id),          // formal argument\n-    cat_stack_upvar(cmt),           // upvar in stack closure\n-    cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n-    cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n-    cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n-}\n-\n-// different kinds of pointers:\n-enum ptr_kind {uniq_ptr, gc_ptr, region_ptr(ty::region), unsafe_ptr}\n-\n-// I am coining the term \"components\" to mean \"pieces of a data\n-// structure accessible without a dereference\":\n-enum comp_kind {\n-    comp_tuple,                  // elt in a tuple\n-    comp_variant(ast::def_id),   // internals to a variant of given enum\n-    comp_field(ast::ident,       // name of field\n-               ast::mutability), // declared mutability of field\n-    comp_index(ty::t,            // type of vec/str/etc being deref'd\n-               ast::mutability)  // mutability of vec content\n-}\n-\n-// We pun on *T to mean both actual deref of a ptr as well\n-// as accessing of components:\n-enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n-\n-// different kinds of expressions we might evaluate\n-enum special_kind {\n-    sk_method,\n-    sk_static_item,\n-    sk_self,\n-    sk_heap_upvar\n-}\n-\n-// a complete categorization of a value indicating where it originated\n-// and how it is located, as well as the mutability of the memory in\n-// which the value is stored.\n-type cmt = @{id: ast::node_id,        // id of expr/pat producing this value\n-             span: span,              // span of same expr/pat\n-             cat: categorization,     // categorization of expr\n-             lp: option<@loan_path>,  // loan path for expr, if any\n-             mutbl: ast::mutability,  // mutability of expr as lvalue\n-             ty: ty::t};              // type of the expr\n-\n-// a loan path is like a category, but it exists only when the data is\n-// interior to the stack frame.  loan paths are used as the key to a\n-// map indicating what is borrowed at any point in time.\n-enum loan_path {\n-    lp_local(ast::node_id),\n-    lp_arg(ast::node_id),\n-    lp_deref(@loan_path, ptr_kind),\n-    lp_comp(@loan_path, comp_kind)\n-}\n-\n /// a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n@@ -429,38 +366,42 @@ fn root_map() -> root_map {\n // ___________________________________________________________________________\n // Misc\n \n-trait ast_node {\n-    fn id() -> ast::node_id;\n-    fn span() -> span;\n-}\n+impl borrowck_ctxt {\n+    fn is_subregion_of(r_sub: ty::region, r_sup: ty::region) -> bool {\n+        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+    }\n \n-impl of ast_node for @ast::expr {\n-    fn id() -> ast::node_id { self.id }\n-    fn span() -> span { self.span }\n-}\n+    fn cat_expr(expr: @ast::expr) -> cmt {\n+        cat_expr(self.tcx, self.method_map, expr)\n+    }\n \n-impl of ast_node for @ast::pat {\n-    fn id() -> ast::node_id { self.id }\n-    fn span() -> span { self.span }\n-}\n+    fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n+        cat_borrow_of_expr(self.tcx, self.method_map, expr)\n+    }\n \n-trait get_type_for_node {\n-    fn ty<N: ast_node>(node: N) -> ty::t;\n-}\n+    fn cat_def(id: ast::node_id,\n+               span: span,\n+               ty: ty::t,\n+               def: ast::def) -> cmt {\n+        cat_def(self.tcx, self.method_map, id, span, ty, def)\n+    }\n \n-impl methods of get_type_for_node for ty::ctxt {\n-    fn ty<N: ast_node>(node: N) -> ty::t {\n-        ty::node_id_to_type(self, node.id())\n+    fn cat_variant<N: ast_node>(arg: N,\n+                                enum_did: ast::def_id,\n+                                cmt: cmt) -> cmt {\n+        cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n     }\n-}\n \n-impl borrowck_ctxt {\n-    fn is_subregion_of(r_sub: ty::region, r_sup: ty::region) -> bool {\n-        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n+        return @{cat:cat_discr(cmt, alt_id) with *cmt};\n+    }\n+\n+    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cat_pattern(cmt, pat, op);\n     }\n-}\n \n-impl error_methods for borrowck_ctxt {\n     fn report_if_err(bres: bckres<()>) {\n         match bres {\n           ok(()) => (),\n@@ -494,118 +435,6 @@ impl error_methods for borrowck_ctxt {\n           _ => ()\n         }\n     }\n-}\n-\n-impl to_str_methods for borrowck_ctxt {\n-    fn cat_to_repr(cat: categorization) -> ~str {\n-        match cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static_item\",\n-          cat_special(sk_self) => ~\"self\",\n-          cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n-          cat_stack_upvar(_) => ~\"stack-upvar\",\n-          cat_rvalue => ~\"rvalue\",\n-          cat_local(node_id) => fmt!{\"local(%d)\", node_id},\n-          cat_binding(node_id) => fmt!{\"binding(%d)\", node_id},\n-          cat_arg(node_id) => fmt!{\"arg(%d)\", node_id},\n-          cat_deref(cmt, derefs, ptr) => {\n-            fmt!{\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n-                 self.ptr_sigil(ptr), derefs}\n-          }\n-          cat_comp(cmt, comp) => {\n-            fmt!{\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)}\n-          }\n-          cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n-        }\n-    }\n-\n-    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n-        match mutbl {\n-          m_mutbl => ~\"mutable\",\n-          m_const => ~\"const\",\n-          m_imm => ~\"immutable\"\n-        }\n-    }\n-\n-    fn ptr_sigil(ptr: ptr_kind) -> ~str {\n-        match ptr {\n-          uniq_ptr => ~\"~\",\n-          gc_ptr => ~\"@\",\n-          region_ptr(_) => ~\"&\",\n-          unsafe_ptr => ~\"*\"\n-        }\n-    }\n-\n-    fn comp_to_repr(comp: comp_kind) -> ~str {\n-        match comp {\n-          comp_field(fld, _) => *fld,\n-          comp_index(*) => ~\"[]\",\n-          comp_tuple => ~\"()\",\n-          comp_variant(_) => ~\"<enum>\"\n-        }\n-    }\n-\n-    fn lp_to_str(lp: @loan_path) -> ~str {\n-        match *lp {\n-          lp_local(node_id) => {\n-            fmt!{\"local(%d)\", node_id}\n-          }\n-          lp_arg(node_id) => {\n-            fmt!{\"arg(%d)\", node_id}\n-          }\n-          lp_deref(lp, ptr) => {\n-            fmt!{\"%s->(%s)\", self.lp_to_str(lp),\n-                 self.ptr_sigil(ptr)}\n-          }\n-          lp_comp(lp, comp) => {\n-            fmt!{\"%s.%s\", self.lp_to_str(lp),\n-                 self.comp_to_repr(comp)}\n-          }\n-        }\n-    }\n-\n-    fn cmt_to_repr(cmt: cmt) -> ~str {\n-        fmt!{\"{%s id:%d m:%s lp:%s ty:%s}\",\n-             self.cat_to_repr(cmt.cat),\n-             cmt.id,\n-             self.mut_to_str(cmt.mutbl),\n-             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(p) ),\n-             ty_to_str(self.tcx, cmt.ty)}\n-    }\n-\n-    fn cmt_to_str(cmt: cmt) -> ~str {\n-        let mut_str = self.mut_to_str(cmt.mutbl);\n-        match cmt.cat {\n-          cat_special(sk_method) => ~\"method\",\n-          cat_special(sk_static_item) => ~\"static item\",\n-          cat_special(sk_self) => ~\"self reference\",\n-          cat_special(sk_heap_upvar) => {\n-              ~\"captured outer variable in a heap closure\"\n-          }\n-          cat_rvalue => ~\"non-lvalue\",\n-          cat_local(_) => mut_str + ~\" local variable\",\n-          cat_binding(_) => ~\"pattern binding\",\n-          cat_arg(_) => ~\"argument\",\n-          cat_deref(_, _, pk) => fmt!{\"dereference of %s %s pointer\",\n-                                      mut_str, self.ptr_sigil(pk)},\n-          cat_stack_upvar(_) => {\n-            ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n-          }\n-          cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n-          cat_comp(_, comp_tuple) => ~\"tuple content\",\n-          cat_comp(_, comp_variant(_)) => ~\"enum content\",\n-          cat_comp(_, comp_index(t, _)) => {\n-            match ty::get(t).struct {\n-              ty::ty_evec(*) => mut_str + ~\" vec content\",\n-              ty::ty_estr(*) => mut_str + ~\" str content\",\n-              _ => mut_str + ~\" indexed content\"\n-            }\n-          }\n-          cat_discr(cmt, _) => {\n-            self.cmt_to_str(cmt)\n-          }\n-        }\n-    }\n \n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n         match code {\n@@ -640,8 +469,22 @@ impl to_str_methods for borrowck_ctxt {\n         }\n     }\n \n-    fn region_to_str(r: ty::region) -> ~str {\n-        region_to_str(self.tcx, r)\n+    fn cmt_to_str(cmt: cmt) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cmt_to_str(cmt)\n+    }\n+\n+    fn cmt_to_repr(cmt: cmt) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.cmt_to_repr(cmt)\n+    }\n+\n+    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n+        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n+                                           method_map: self.method_map};\n+        mc.mut_to_str(mutbl)\n     }\n }\n "}, {"sha": "d0ec0518458789b109f6b76f0427ff222e487b96", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -8,7 +8,6 @@\n // 4. moves to dnot affect things loaned out in any way\n \n import dvec::{dvec, extensions};\n-import categorization::public_methods;\n \n export check_loans;\n "}, {"sha": "ee09584bb9fb73d794b7f14b8c5ce4f2715d75c0", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 47, "deletions": 153, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -6,7 +6,7 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-import categorization::{public_methods, opt_deref_kind};\n+import mem_categorization::{opt_deref_kind};\n import loan::public_methods;\n import preserve::{public_methods, preserve_condition, pc_ok, pc_if_pure};\n import ty::ty_region;\n@@ -406,163 +406,57 @@ impl methods for gather_loan_ctxt {\n         }\n     }\n \n-    fn gather_pat(cmt: cmt, pat: @ast::pat,\n+    fn gather_pat(discr_cmt: cmt, root_pat: @ast::pat,\n                   arm_id: ast::node_id, alt_id: ast::node_id) {\n-\n-        // Here, `cmt` is the categorization for the value being\n-        // matched and pat is the pattern it is being matched against.\n-        //\n-        // In general, the way that this works is that we walk down\n-        // the pattern, constructing a cmt that represents the path\n-        // that will be taken to reach the value being matched.\n-        //\n-        // When we encounter named bindings, we take the cmt that has\n-        // been built up and pass it off to guarantee_valid() so that\n-        // we can be sure that the binding will remain valid for the\n-        // duration of the arm.\n-        //\n-        // The correspondence between the id in the cmt and which\n-        // pattern is being referred to is somewhat...subtle.  In\n-        // general, the id of the cmt is the id of the node that\n-        // produces the value.  For patterns, that's actually the\n-        // *subpattern*, generally speaking.\n-        //\n-        // To see what I mean about ids etc, consider:\n-        //\n-        //     let x = @@3;\n-        //     match x {\n-        //       @@y { ... }\n-        //     }\n-        //\n-        // Here the cmt for `y` would be something like\n-        //\n-        //     local(x)->@->@\n-        //\n-        // where the id of `local(x)` is the id of the `x` that appears\n-        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n-        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n-\n-        debug!{\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n-               pat.id, pprust::pat_to_str(pat),\n-               self.bccx.cmt_to_repr(cmt), arm_id, alt_id};\n-        let _i = indenter();\n-\n-        let tcx = self.tcx();\n-        match pat.node {\n-          ast::pat_wild => {\n-            // _\n-          }\n-\n-          ast::pat_enum(_, none) => {\n-            // variant(*)\n-          }\n-          ast::pat_enum(_, some(subpats)) => {\n-            // variant(x, y, z)\n-            let enum_did = match self.bccx.tcx.def_map\n-.find(pat.id) {\n-              some(ast::def_variant(enum_did, _)) => enum_did,\n-              e => tcx.sess.span_bug(pat.span,\n-                                     fmt!{\"resolved to %?, \\\n-                                               not variant\", e})\n-            };\n-\n-            for subpats.each |subpat| {\n-                let subcmt = self.bccx.cat_variant(subpat, enum_did, cmt);\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_ident(bm, id, o_pat) if !self.pat_is_variant(pat) => {\n-            match bm {\n-              ast::bind_by_value => {\n-                // copying does not borrow anything, so no check is required\n-              }\n-              ast::bind_by_ref(mutbl) => {\n-                // ref x or ref x @ p --- creates a ptr which must\n-                // remain valid for the scope of the alt\n-\n-                // find the region of the resulting pointer (note that\n-                // the type of such a pattern will *always* be a\n-                // region pointer)\n-                let scope_r = ty_region(tcx.ty(pat));\n-\n-                // if the scope of the region ptr turns out to be\n-                // specific to this arm, wrap the categorization with\n-                // a cat_discr() node.  There is a detailed discussion\n-                // of the function of this node in method preserve():\n-                let arm_scope = ty::re_scope(arm_id);\n-                if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                    let cmt_discr = self.bccx.cat_discr(cmt, alt_id);\n-                    self.guarantee_valid(cmt_discr, mutbl, scope_r);\n-                } else {\n-                    self.guarantee_valid(cmt, mutbl, scope_r);\n+        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n+            match pat.node {\n+              ast::pat_ident(bm, id, o_pat) if !self.pat_is_variant(pat) => {\n+                match bm {\n+                  ast::bind_by_value => {\n+                    // copying does not borrow anything, so no check\n+                    // is required\n+                  }\n+                  ast::bind_by_ref(mutbl) => {\n+                    // ref x or ref x @ p --- creates a ptr which must\n+                    // remain valid for the scope of the alt\n+\n+                    // find the region of the resulting pointer (note that\n+                    // the type of such a pattern will *always* be a\n+                    // region pointer)\n+                    let scope_r = ty_region(self.tcx().ty(pat));\n+\n+                    // if the scope of the region ptr turns out to be\n+                    // specific to this arm, wrap the categorization with\n+                    // a cat_discr() node.  There is a detailed discussion\n+                    // of the function of this node in method preserve():\n+                    let arm_scope = ty::re_scope(arm_id);\n+                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                        let cmt_discr = self.bccx.cat_discr(cmt, alt_id);\n+                        self.guarantee_valid(cmt_discr, mutbl, scope_r);\n+                    } else {\n+                        self.guarantee_valid(cmt, mutbl, scope_r);\n+                    }\n+                  }\n+                  ast::bind_by_implicit_ref => {\n+                    // Note: there is a discussion of the function of\n+                    // cat_discr in the method preserve():\n+                    let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n+                    let arm_scope = ty::re_scope(arm_id);\n+\n+                    // We used to remember the mutability of the location\n+                    // that this binding refers to and use it later when\n+                    // categorizing the binding.  This hack is being\n+                    // removed in favor of ref mode bindings.\n+                    //\n+                    // self.bccx.binding_map.insert(pat.id, cmt1.mutbl);\n+\n+                    self.guarantee_valid(cmt1, m_const, arm_scope);\n+                  }\n                 }\n               }\n-              ast::bind_by_implicit_ref => {\n-                // Note: there is a discussion of the function of\n-                // cat_discr in the method preserve():\n-                let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n-                let arm_scope = ty::re_scope(arm_id);\n-\n-                // Remember the mutability of the location that this\n-                // binding refers to.  This will be used later when\n-                // categorizing the binding.  This is a bit of a hack that\n-                // would be better fixed by #2329; in that case we could\n-                // allow the user to specify if they want an imm, const,\n-                // or mut binding, or else just reflect the mutability\n-                // through the type of the region pointer.\n-                self.bccx.binding_map.insert(pat.id, cmt1.mutbl);\n-\n-                self.guarantee_valid(cmt1, m_const, arm_scope);\n-              }\n-            }\n-            for o_pat.each |p| {\n-                self.gather_pat(cmt, p, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_ident(*) => {\n-              // nullary variant: ignore.\n-              assert self.pat_is_variant(pat);\n-          }\n-\n-          ast::pat_rec(field_pats, _) => {\n-            // {f1: p1, ..., fN: pN}\n-            for field_pats.each |fp| {\n-                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n-                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n-            }\n-          }\n-\n-          ast::pat_struct(_, field_pats, _) => {\n-            // {f1: p1, ..., fN: pN}\n-            for field_pats.each |fp| {\n-                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n-                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n-            }\n-          }\n \n-          ast::pat_tup(subpats) => {\n-            // (p1, ..., pN)\n-            for subpats.each |subpat| {\n-                let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n+              _ => {}\n             }\n-          }\n-\n-          ast::pat_box(subpat) | ast::pat_uniq(subpat) => {\n-            // @p1, ~p1\n-            match self.bccx.cat_deref(subpat, cmt, 0u, true) {\n-              some(subcmt) => {\n-                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n-              }\n-              none => {\n-                tcx.sess.span_bug(pat.span, ~\"Non derefable type\");\n-              }\n-            }\n-          }\n-\n-          ast::pat_lit(_) | ast::pat_range(_, _) => { /*always ok*/ }\n         }\n     }\n "}, {"sha": "9d6629d8edc7fb0a3860a3760bfd69e01377d117", "filename": "src/rustc/middle/mem_categorization.rs", "status": "renamed", "additions": 376, "deletions": 13, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -36,8 +36,70 @@\n  * then an index to jump forward to the relevant item.\n  */\n \n-export public_methods;\n-export opt_deref_kind;\n+import syntax::ast;\n+import syntax::ast::{m_imm, m_const, m_mutbl};\n+import syntax::codemap::span;\n+import syntax::print::pprust;\n+import util::ppaux::{ty_to_str, region_to_str};\n+import util::common::indenter;\n+\n+enum categorization {\n+    cat_rvalue,                     // result of eval'ing some misc expr\n+    cat_special(special_kind),      //\n+    cat_local(ast::node_id),        // local variable\n+    cat_binding(ast::node_id),      // pattern binding\n+    cat_arg(ast::node_id),          // formal argument\n+    cat_stack_upvar(cmt),           // upvar in stack closure\n+    cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n+    cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n+    cat_discr(cmt, ast::node_id),   // match discriminant (see preserve())\n+}\n+\n+// different kinds of pointers:\n+enum ptr_kind {uniq_ptr, gc_ptr, region_ptr(ty::region), unsafe_ptr}\n+\n+// I am coining the term \"components\" to mean \"pieces of a data\n+// structure accessible without a dereference\":\n+enum comp_kind {\n+    comp_tuple,                  // elt in a tuple\n+    comp_variant(ast::def_id),   // internals to a variant of given enum\n+    comp_field(ast::ident,       // name of field\n+               ast::mutability), // declared mutability of field\n+    comp_index(ty::t,            // type of vec/str/etc being deref'd\n+               ast::mutability)  // mutability of vec content\n+}\n+\n+// different kinds of expressions we might evaluate\n+enum special_kind {\n+    sk_method,\n+    sk_static_item,\n+    sk_self,\n+    sk_heap_upvar\n+}\n+\n+// a complete categorization of a value indicating where it originated\n+// and how it is located, as well as the mutability of the memory in\n+// which the value is stored.\n+type cmt = @{id: ast::node_id,        // id of expr/pat producing this value\n+             span: span,              // span of same expr/pat\n+             cat: categorization,     // categorization of expr\n+             lp: option<@loan_path>,  // loan path for expr, if any\n+             mutbl: ast::mutability,  // mutability of expr as lvalue\n+             ty: ty::t};              // type of the expr\n+\n+// a loan path is like a category, but it exists only when the data is\n+// interior to the stack frame.  loan paths are used as the key to a\n+// map indicating what is borrowed at any point in time.\n+enum loan_path {\n+    lp_local(ast::node_id),\n+    lp_arg(ast::node_id),\n+    lp_deref(@loan_path, ptr_kind),\n+    lp_comp(@loan_path, comp_kind)\n+}\n+\n+// We pun on *T to mean both actual deref of a ptr as well\n+// as accessing of components:\n+enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n \n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n@@ -93,7 +155,86 @@ fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     }\n }\n \n-impl public_methods for borrowck_ctxt {\n+fn cat_borrow_of_expr(\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    expr: @ast::expr) -> cmt {\n+\n+    let mcx = &mem_categorization_ctxt {\n+        tcx: tcx, method_map: method_map\n+    };\n+    return mcx.cat_borrow_of_expr(expr);\n+}\n+\n+fn cat_expr(\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    expr: @ast::expr) -> cmt {\n+\n+    let mcx = &mem_categorization_ctxt {\n+        tcx: tcx, method_map: method_map\n+    };\n+    return mcx.cat_expr(expr);\n+}\n+\n+fn cat_def(\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    expr_id: ast::node_id,\n+    expr_span: span,\n+    expr_ty: ty::t,\n+    def: ast::def) -> cmt {\n+\n+    let mcx = &mem_categorization_ctxt {\n+        tcx: tcx, method_map: method_map\n+    };\n+    return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n+}\n+\n+fn cat_variant<N: ast_node>(\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    arg: N,\n+    enum_did: ast::def_id,\n+    cmt: cmt) -> cmt {\n+\n+    let mcx = &mem_categorization_ctxt {\n+        tcx: tcx, method_map: method_map\n+    };\n+    return mcx.cat_variant(arg, enum_did, cmt);\n+}\n+\n+trait ast_node {\n+    fn id() -> ast::node_id;\n+    fn span() -> span;\n+}\n+\n+impl of ast_node for @ast::expr {\n+    fn id() -> ast::node_id { self.id }\n+    fn span() -> span { self.span }\n+}\n+\n+impl of ast_node for @ast::pat {\n+    fn id() -> ast::node_id { self.id }\n+    fn span() -> span { self.span }\n+}\n+\n+trait get_type_for_node {\n+    fn ty<N: ast_node>(node: N) -> ty::t;\n+}\n+\n+impl methods of get_type_for_node for ty::ctxt {\n+    fn ty<N: ast_node>(node: N) -> ty::t {\n+        ty::node_id_to_type(self, node.id())\n+    }\n+}\n+\n+struct mem_categorization_ctxt {\n+    tcx: ty::ctxt;\n+    method_map: typeck::method_map;\n+}\n+\n+impl &mem_categorization_ctxt {\n     fn cat_borrow_of_expr(expr: @ast::expr) -> cmt {\n         // a borrowed expression must be either an @, ~, or a @vec, ~vec\n         let expr_ty = ty::expr_ty(self.tcx, expr);\n@@ -276,13 +417,14 @@ impl public_methods for borrowck_ctxt {\n             // implicit-by-ref bindings are \"special\" since they are\n             // implicit pointers.\n \n-            // lookup the mutability for this binding that we found in\n-            // gather_loans when we categorized it\n-            let mutbl = self.binding_map.get(pid);\n+            // Technically, the mutability is not always imm, but we\n+            // (choose to be) unsound for the moment since these\n+            // implicit refs are going away and it reduces external\n+            // dependencies.\n \n             @{id:id, span:span,\n               cat:cat_binding(pid), lp:none,\n-              mutbl:mutbl, ty:expr_ty}\n+              mutbl:m_imm, ty:expr_ty}\n           }\n         }\n     }\n@@ -303,10 +445,6 @@ impl public_methods for borrowck_ctxt {\n           mutbl:m_imm, ty:expr_ty}\n     }\n \n-    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n-        return @{cat:cat_discr(cmt, alt_id) with *cmt};\n-    }\n-\n     /// inherited mutability: used in cases where the mutability of a\n     /// component is inherited from the base it is a part of. For\n     /// example, a record field is mutable if it is declared mutable\n@@ -446,9 +584,7 @@ impl public_methods for borrowck_ctxt {\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(elt)}\n     }\n-}\n \n-impl private_methods for borrowck_ctxt {\n     fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n         @{id:expr.id, span:expr.span,\n           cat:cat_special(sk_method), lp:none,\n@@ -473,6 +609,233 @@ impl private_methods for borrowck_ctxt {\n             }\n         }\n     }\n+\n+    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+\n+        op(cmt, pat);\n+\n+        // Here, `cmt` is the categorization for the value being\n+        // matched and pat is the pattern it is being matched against.\n+        //\n+        // In general, the way that this works is that we walk down\n+        // the pattern, constructing a cmt that represents the path\n+        // that will be taken to reach the value being matched.\n+        //\n+        // When we encounter named bindings, we take the cmt that has\n+        // been built up and pass it off to guarantee_valid() so that\n+        // we can be sure that the binding will remain valid for the\n+        // duration of the arm.\n+        //\n+        // The correspondence between the id in the cmt and which\n+        // pattern is being referred to is somewhat...subtle.  In\n+        // general, the id of the cmt is the id of the node that\n+        // produces the value.  For patterns, that's actually the\n+        // *subpattern*, generally speaking.\n+        //\n+        // To see what I mean about ids etc, consider:\n+        //\n+        //     let x = @@3;\n+        //     match x {\n+        //       @@y { ... }\n+        //     }\n+        //\n+        // Here the cmt for `y` would be something like\n+        //\n+        //     local(x)->@->@\n+        //\n+        // where the id of `local(x)` is the id of the `x` that appears\n+        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n+        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n+\n+        debug!{\"cat_pattern: id=%d pat=%s cmt=%s\",\n+               pat.id, pprust::pat_to_str(pat),\n+               self.cmt_to_repr(cmt)};\n+        let _i = indenter();\n+\n+        let tcx = self.tcx;\n+        match pat.node {\n+          ast::pat_wild => {\n+            // _\n+          }\n+\n+          ast::pat_enum(_, none) => {\n+            // variant(*)\n+          }\n+          ast::pat_enum(_, some(subpats)) => {\n+            // variant(x, y, z)\n+            let enum_did = match self.tcx.def_map.find(pat.id) {\n+              some(ast::def_variant(enum_did, _)) => enum_did,\n+              e => tcx.sess.span_bug(pat.span,\n+                                     fmt!{\"resolved to %?, not variant\", e})\n+            };\n+\n+            for subpats.each |subpat| {\n+                let subcmt = self.cat_variant(subpat, enum_did, cmt);\n+                self.cat_pattern(subcmt, subpat, op);\n+            }\n+          }\n+\n+          ast::pat_ident(_, _, some(subpat)) => {\n+              self.cat_pattern(cmt, subpat, op);\n+          }\n+\n+          ast::pat_ident(_, _, none) => {\n+              // nullary variant or identifier: ignore\n+          }\n+\n+          ast::pat_rec(field_pats, _) => {\n+            // {f1: p1, ..., fN: pN}\n+            for field_pats.each |fp| {\n+                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident);\n+                self.cat_pattern(cmt_field, fp.pat, op);\n+            }\n+          }\n+\n+          ast::pat_struct(_, field_pats, _) => {\n+            // {f1: p1, ..., fN: pN}\n+            for field_pats.each |fp| {\n+                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident);\n+                self.cat_pattern(cmt_field, fp.pat, op);\n+            }\n+          }\n+\n+          ast::pat_tup(subpats) => {\n+            // (p1, ..., pN)\n+            for subpats.each |subpat| {\n+                let subcmt = self.cat_tuple_elt(subpat, cmt);\n+                self.cat_pattern(subcmt, subpat, op);\n+            }\n+          }\n+\n+          ast::pat_box(subpat) | ast::pat_uniq(subpat) => {\n+            // @p1, ~p1\n+            match self.cat_deref(subpat, cmt, 0u, true) {\n+              some(subcmt) => {\n+                self.cat_pattern(subcmt, subpat, op);\n+              }\n+              none => {\n+                tcx.sess.span_bug(pat.span, ~\"Non derefable type\");\n+              }\n+            }\n+          }\n+\n+          ast::pat_lit(_) | ast::pat_range(_, _) => { /*always ok*/ }\n+        }\n+    }\n+\n+    fn cat_to_repr(cat: categorization) -> ~str {\n+        match cat {\n+          cat_special(sk_method) => ~\"method\",\n+          cat_special(sk_static_item) => ~\"static_item\",\n+          cat_special(sk_self) => ~\"self\",\n+          cat_special(sk_heap_upvar) => ~\"heap-upvar\",\n+          cat_stack_upvar(_) => ~\"stack-upvar\",\n+          cat_rvalue => ~\"rvalue\",\n+          cat_local(node_id) => fmt!{\"local(%d)\", node_id},\n+          cat_binding(node_id) => fmt!{\"binding(%d)\", node_id},\n+          cat_arg(node_id) => fmt!{\"arg(%d)\", node_id},\n+          cat_deref(cmt, derefs, ptr) => {\n+            fmt!{\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n+                 self.ptr_sigil(ptr), derefs}\n+          }\n+          cat_comp(cmt, comp) => {\n+            fmt!{\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)}\n+          }\n+          cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n+        }\n+    }\n+\n+    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n+        match mutbl {\n+          m_mutbl => ~\"mutable\",\n+          m_const => ~\"const\",\n+          m_imm => ~\"immutable\"\n+        }\n+    }\n+\n+    fn ptr_sigil(ptr: ptr_kind) -> ~str {\n+        match ptr {\n+          uniq_ptr => ~\"~\",\n+          gc_ptr => ~\"@\",\n+          region_ptr(_) => ~\"&\",\n+          unsafe_ptr => ~\"*\"\n+        }\n+    }\n+\n+    fn comp_to_repr(comp: comp_kind) -> ~str {\n+        match comp {\n+          comp_field(fld, _) => *fld,\n+          comp_index(*) => ~\"[]\",\n+          comp_tuple => ~\"()\",\n+          comp_variant(_) => ~\"<enum>\"\n+        }\n+    }\n+\n+    fn lp_to_str(lp: @loan_path) -> ~str {\n+        match *lp {\n+          lp_local(node_id) => {\n+            fmt!{\"local(%d)\", node_id}\n+          }\n+          lp_arg(node_id) => {\n+            fmt!{\"arg(%d)\", node_id}\n+          }\n+          lp_deref(lp, ptr) => {\n+            fmt!{\"%s->(%s)\", self.lp_to_str(lp),\n+                 self.ptr_sigil(ptr)}\n+          }\n+          lp_comp(lp, comp) => {\n+            fmt!{\"%s.%s\", self.lp_to_str(lp),\n+                 self.comp_to_repr(comp)}\n+          }\n+        }\n+    }\n+\n+    fn cmt_to_repr(cmt: cmt) -> ~str {\n+        fmt!{\"{%s id:%d m:%s lp:%s ty:%s}\",\n+             self.cat_to_repr(cmt.cat),\n+             cmt.id,\n+             self.mut_to_str(cmt.mutbl),\n+             cmt.lp.map_default(~\"none\", |p| self.lp_to_str(p) ),\n+             ty_to_str(self.tcx, cmt.ty)}\n+    }\n+\n+    fn cmt_to_str(cmt: cmt) -> ~str {\n+        let mut_str = self.mut_to_str(cmt.mutbl);\n+        match cmt.cat {\n+          cat_special(sk_method) => ~\"method\",\n+          cat_special(sk_static_item) => ~\"static item\",\n+          cat_special(sk_self) => ~\"self reference\",\n+          cat_special(sk_heap_upvar) => {\n+              ~\"captured outer variable in a heap closure\"\n+          }\n+          cat_rvalue => ~\"non-lvalue\",\n+          cat_local(_) => mut_str + ~\" local variable\",\n+          cat_binding(_) => ~\"pattern binding\",\n+          cat_arg(_) => ~\"argument\",\n+          cat_deref(_, _, pk) => fmt!{\"dereference of %s %s pointer\",\n+                                      mut_str, self.ptr_sigil(pk)},\n+          cat_stack_upvar(_) => {\n+            ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n+          }\n+          cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n+          cat_comp(_, comp_tuple) => ~\"tuple content\",\n+          cat_comp(_, comp_variant(_)) => ~\"enum content\",\n+          cat_comp(_, comp_index(t, _)) => {\n+            match ty::get(t).struct {\n+              ty::ty_evec(*) => mut_str + ~\" vec content\",\n+              ty::ty_estr(*) => mut_str + ~\" str content\",\n+              _ => mut_str + ~\" indexed content\"\n+            }\n+          }\n+          cat_discr(cmt, _) => {\n+            self.cmt_to_str(cmt)\n+          }\n+        }\n+    }\n+\n+    fn region_to_str(r: ty::region) -> ~str {\n+        region_to_str(self.tcx, r)\n+    }\n }\n \n fn field_mutbl(tcx: ty::ctxt,", "previous_filename": "src/rustc/middle/borrowck/categorization.rs"}, {"sha": "506ed5902e87d6617673b57cf13ec3d8cfa17acc", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -171,7 +171,12 @@ fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n             }\n           }\n         };\n+      }\n \n+      ast::expr_addr_of(_, operand) => {\n+        // FIXME(#3148) -- in some cases, we need to capture a dependency\n+        // between the regions found in operand the resulting region type.\n+        // See #3148 for more details.\n       }\n \n       _ => ()"}, {"sha": "4e12528b968bb644a808a33c884875be7f2a59b4", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -77,10 +77,10 @@ mod middle {\n     mod borrowck {\n         mod check_loans;\n         mod gather_loans;\n-        mod categorization;\n         mod loan;\n         mod preserve;\n     }\n+    mod mem_categorization;\n     mod liveness;\n     mod block_use;\n     mod kind;"}, {"sha": "698d49c7319483d394edfb1d37fe69b63a81803e", "filename": "src/test/run-pass/region-return-interior-of-option-in-self.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-return-interior-of-option-in-self.rs?ref=802ea5d57e8cd4cd12e1a0e25c446b90be4a6a06", "patch": "@@ -0,0 +1,20 @@\n+// xfail-test (#3148)\n+\n+struct cell<T> {\n+    value: T;\n+}\n+\n+struct cells<T> {\n+    vals: ~[option<cell<T>>];\n+}\n+\n+impl<T> &cells<T> {\n+    fn get(idx: uint) -> &self/T {\n+        match self.vals[idx] {\n+          some(ref v) => &v.value,\n+          none => fail\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}