{"sha": "09ef31caa0c2eafb113198ad60445e8aebddbf2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWYzMWNhYTBjMmVhZmIxMTMxOThhZDYwNDQ1ZThhZWJkZGJmMmU=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2010-12-30T16:21:37Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2010-12-30T16:21:37Z"}, "message": "Record the ast of uses and imports.", "tree": {"sha": "ad2e03b11bc6d0ada27821bba7257ca28466b7a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad2e03b11bc6d0ada27821bba7257ca28466b7a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ef31caa0c2eafb113198ad60445e8aebddbf2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ef31caa0c2eafb113198ad60445e8aebddbf2e", "html_url": "https://github.com/rust-lang/rust/commit/09ef31caa0c2eafb113198ad60445e8aebddbf2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ef31caa0c2eafb113198ad60445e8aebddbf2e/comments", "author": null, "committer": null, "parents": [{"sha": "ad19961c471ebf78f54879e0dace21252aba72d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad19961c471ebf78f54879e0dace21252aba72d7", "html_url": "https://github.com/rust-lang/rust/commit/ad19961c471ebf78f54879e0dace21252aba72d7"}], "stats": {"total": 80, "additions": 59, "deletions": 21}, "files": [{"sha": "aa28e7c45bdc4c76e2bcea4644add810bec9c345", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09ef31caa0c2eafb113198ad60445e8aebddbf2e/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ef31caa0c2eafb113198ad60445e8aebddbf2e/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=09ef31caa0c2eafb113198ad60445e8aebddbf2e", "patch": "@@ -39,6 +39,20 @@ tag def {\n type crate = spanned[crate_];\n type crate_ = rec(_mod module);\n \n+type use_node = spanned[use_node_];\n+type use_node_ = rec(ident name, vec[@meta_item] metadata);\n+\n+type import_node = spanned[import_node_];\n+type import_node_ = rec(vec[ident] identifiers);\n+\n+tag use_or_import {\n+    use_or_import_use(@use_node);\n+    use_or_import_import(@import_node);\n+}\n+\n+type meta_item = spanned[meta_item_];\n+type meta_item_ = rec(ident name, str value);\n+\n type block = spanned[block_];\n type block_ = rec(vec[@stmt] stmts,\n                   option.t[@expr] expr,"}, {"sha": "0e08a8bf3524cb65a8cceaa2015965b4f528ea30", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/09ef31caa0c2eafb113198ad60445e8aebddbf2e/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ef31caa0c2eafb113198ad60445e8aebddbf2e/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=09ef31caa0c2eafb113198ad60445e8aebddbf2e", "patch": "@@ -1533,90 +1533,114 @@ impure fn parse_item(parser p) -> @ast.item {\n     fail;\n }\n \n-impure fn parse_meta_item(parser p) {\n+impure fn parse_meta_item(parser p) -> @ast.meta_item {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n     auto ident = parse_ident(p);\n     expect(p, token.EQ);\n     alt (p.peek()) {\n         case (token.LIT_STR(?s)) {\n             p.bump();\n+            ret @spanned(lo, hi, rec(name = ident, value = s));\n         }\n         case (_) {\n             p.err(\"Metadata items must be string literals\");\n         }\n     }\n+    fail;\n }\n \n-impure fn parse_meta(parser p) {\n+impure fn parse_meta(parser p) -> vec[@ast.meta_item] {\n     auto pf = parse_meta_item;\n-    parse_seq[()](token.LPAREN, token.RPAREN, some(token.COMMA), pf, p);\n+    ret parse_seq[@ast.meta_item](token.LPAREN, token.RPAREN,\n+                                   some(token.COMMA), pf, p).node;\n }\n \n-impure fn parse_optional_meta(parser p) {\n+impure fn parse_optional_meta(parser p) -> vec[@ast.meta_item] {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n     alt (p.peek()) {\n         case (token.LPAREN) {\n             ret parse_meta(p);\n         }\n         case (_) {\n-            ret;\n+            let vec[@ast.meta_item] v = vec();\n+            ret v;\n         }\n     }\n }\n \n-impure fn parse_rest_import_name(parser p, ast.ident id) {\n+impure fn parse_use(parser p) -> @ast.use_node {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+    expect(p, token.USE);\n+    auto ident = parse_ident(p);\n+    auto metadata = parse_optional_meta(p);\n+    expect(p, token.SEMI);\n+    ret @spanned(lo, hi, rec(name = ident, metadata = metadata));\n+}\n+\n+impure fn parse_rest_import_name(parser p, ast.ident id) -> @ast.import_node {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+    let vec[ast.ident] identifiers = vec();\n+    identifiers += id;\n     while (p.peek() != token.SEMI) {\n         expect(p, token.DOT);\n-        parse_ident(p);\n+        auto i = parse_ident(p);\n+        identifiers += i;\n     }\n+    p.bump();\n+    ret @spanned(lo, hi, rec(identifiers = identifiers));\n }\n \n-impure fn parse_full_import_name(parser p) {\n+impure fn parse_full_import_name(parser p) -> @ast.import_node {\n     alt (p.peek()) {\n         case (token.IDENT(?ident)) {\n             p.bump();\n-            parse_rest_import_name(p, ident);\n+            ret parse_rest_import_name(p, ident);\n         }\n         case (_) {\n             p.err(\"expecting an identifier\");\n         }\n     }\n+    fail;\n }\n \n-impure fn parse_import(parser p) {\n+impure fn parse_import(parser p) -> @ast.import_node {\n+    expect(p, token.IMPORT);\n     alt (p.peek()) {\n         case (token.IDENT(?ident)) {\n             p.bump();\n             alt (p.peek()) {\n                 case (token.EQ) {\n                     p.bump();\n-                    parse_full_import_name(p);\n+                    ret parse_full_import_name(p);\n                 }\n                 case (_) {\n-                    parse_rest_import_name(p, ident);\n+                    ret parse_rest_import_name(p, ident);\n                 }\n             }\n         }\n         case (_) {\n             p.err(\"expecting an identifier\");\n         }\n     }\n+    fail;\n }\n \n-impure fn parse_use_and_imports(parser p) {\n+impure fn parse_use_and_imports(parser p) -> vec[ast.use_or_import] {\n+    let vec[ast.use_or_import] items = vec();\n     while (true) {\n         alt (p.peek()) {\n             case (token.USE) {\n-                p.bump();\n-                auto ident = parse_ident(p);\n-                parse_optional_meta(p);\n-                expect(p, token.SEMI);\n+                items += vec(ast.use_or_import_use(parse_use(p)));\n             }\n             case (token.IMPORT) {\n-                p.bump();\n-                parse_import(p);\n-                expect(p, token.SEMI);\n+                items += vec(ast.use_or_import_import(parse_import(p)));\n             }\n             case (_) {\n-                ret;\n+                ret items;\n             }\n         }\n     }"}]}