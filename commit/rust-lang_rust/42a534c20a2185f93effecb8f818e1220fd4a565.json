{"sha": "42a534c20a2185f93effecb8f818e1220fd4a565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYTUzNGMyMGEyMTg1ZjkzZWZmZWNiOGY4MThlMTIyMGZkNGE1NjU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-06T11:50:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-06T11:50:31Z"}, "message": "miri: monomorphize types iff they came from MIR.", "tree": {"sha": "caa0f1acdc9ae0afc560fc5e759e43f378593030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caa0f1acdc9ae0afc560fc5e759e43f378593030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42a534c20a2185f93effecb8f818e1220fd4a565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42a534c20a2185f93effecb8f818e1220fd4a565", "html_url": "https://github.com/rust-lang/rust/commit/42a534c20a2185f93effecb8f818e1220fd4a565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42a534c20a2185f93effecb8f818e1220fd4a565/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe58398314f0647573cba4ad4ccb5331aaa85062", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe58398314f0647573cba4ad4ccb5331aaa85062", "html_url": "https://github.com/rust-lang/rust/commit/fe58398314f0647573cba4ad4ccb5331aaa85062"}], "stats": {"total": 376, "additions": 134, "deletions": 242}, "files": [{"sha": "f5b7d6a673b881d9fd315373d9c5306e16652a9c", "filename": "src/librustc/mir/interpret/const_eval.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fconst_eval.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -1,4 +1,5 @@\n-use ty::{self, TyCtxt, Ty, Instance, layout};\n+use ty::{self, TyCtxt, Ty, Instance};\n+use ty::layout::{self, LayoutOf};\n use mir;\n \n use syntax::ast::Mutability;\n@@ -29,9 +30,12 @@ pub fn eval_body<'a, 'tcx>(\n         if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n             return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n         }\n-        let mir = ecx.load_mir(instance.def)?;\n+        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n+        let instance_ty =\n+            ecx.monomorphize(instance.def.def_ty(tcx), instance.substs);\n         if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n-            let layout = ecx.type_layout_with_substs(mir.return_ty(), instance.substs)?;\n+            let mir = ecx.load_mir(instance.def)?;\n+            let layout = ecx.layout_of(instance_ty)?;\n             assert!(!layout.is_unsized());\n             let ptr = ecx.memory.allocate(\n                 layout.size.bytes(),\n@@ -68,8 +72,7 @@ pub fn eval_body<'a, 'tcx>(\n             )?;\n         }\n         let value = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-        let ret_ty = ecx.monomorphize(mir.return_ty(), instance.substs);\n-        Ok((value, ret_ty))\n+        Ok((value, instance_ty))\n     })();\n     (try, ecx)\n }\n@@ -226,16 +229,14 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         match intrinsic_name {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_align = ecx.type_align(elem_ty)?;\n+                let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n                 let align_val = PrimVal::from_u128(elem_align as u128);\n                 ecx.write_primval(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                let size = ecx.type_size(ty)?.expect(\n-                    \"size_of intrinsic called on unsized value\",\n-                ) as u128;\n+                let size = ecx.layout_of(ty)?.size.bytes() as u128;\n                 ecx.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n             }\n "}, {"sha": "fa09f8743526212872cc96c0b175e9ef0545681c", "filename": "src/librustc/mir/interpret/eval_context.rs", "status": "modified", "additions": 71, "deletions": 174, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Feval_context.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -228,19 +228,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n-        let substs = self.substs();\n-        self.alloc_ptr_with_substs(ty, substs)\n-    }\n+        let layout = self.layout_of(ty)?;\n+        assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n-    pub fn alloc_ptr_with_substs(\n-        &mut self,\n-        ty: Ty<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n-        let size = self.type_size_with_substs(ty, substs)?.expect(\n-            \"cannot alloc memory for unsized type\",\n-        );\n-        let align = self.type_align_with_substs(ty, substs)?;\n+        let size = layout.size.bytes();\n+        let align = layout.align.abi();\n         self.memory.allocate(size, align, Some(MemoryKind::Stack))\n     }\n \n@@ -357,7 +349,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ty: ty::Ty<'tcx>,\n         value: Value,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let layout = self.type_layout(ty)?;\n+        let layout = self.layout_of(ty)?;\n         if !layout.is_unsized() {\n             Ok(layout.size_and_align())\n         } else {\n@@ -381,19 +373,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let (unsized_size, unsized_align) = match ty.sty {\n-                        ty::TyAdt(def, substs) => {\n-                            let last_field = def.struct_variant().fields.last().unwrap();\n-                            let field_ty = self.field_ty(substs, last_field);\n-                            self.size_and_align_of_dst(field_ty, value)?\n-                        }\n-                        ty::TyTuple(ref types, _) => {\n-                            let field_ty = types.last().unwrap();\n-                            let field_ty = self.tcx.fully_normalize_monormophic_ty(field_ty);\n-                            self.size_and_align_of_dst(field_ty, value)?\n-                        }\n-                        _ => bug!(\"We already checked that we know this type\"),\n-                    };\n+                    let field_ty = layout.field(&self, layout.fields.count() - 1)?.ty;\n+                    let (unsized_size, unsized_align) =\n+                        self.size_and_align_of_dst(field_ty, value)?;\n \n                     // FIXME (#26403, #27023): We should be adding padding\n                     // to `sized_size` (to accommodate the `unsized_align`\n@@ -439,59 +421,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    /// Returns the normalized type of a struct field\n-    fn field_ty(&self, param_substs: &Substs<'tcx>, f: &ty::FieldDef) -> ty::Ty<'tcx> {\n-        self.tcx.fully_normalize_monormophic_ty(\n-            &f.ty(self.tcx, param_substs),\n-        )\n-    }\n-\n-    pub fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n-        self.type_size_with_substs(ty, self.substs())\n-    }\n-\n-    pub fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n-        self.type_align_with_substs(ty, self.substs())\n-    }\n-\n-    pub(super) fn type_size_with_substs(\n-        &self,\n-        ty: Ty<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n-    ) -> EvalResult<'tcx, Option<u64>> {\n-        let layout = self.type_layout_with_substs(ty, substs)?;\n-        if layout.is_unsized() {\n-            Ok(None)\n-        } else {\n-            Ok(Some(layout.size.bytes()))\n-        }\n-    }\n-\n-    pub(super) fn type_align_with_substs(\n-        &self,\n-        ty: Ty<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n-    ) -> EvalResult<'tcx, u64> {\n-        self.type_layout_with_substs(ty, substs).map(|layout| {\n-            layout.align.abi()\n-        })\n-    }\n-\n-    pub fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        self.type_layout_with_substs(ty, self.substs())\n-    }\n-\n-    pub(super) fn type_layout_with_substs(\n-        &self,\n-        ty: Ty<'tcx>,\n-        substs: &'tcx Substs<'tcx>,\n-    ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        // TODO(solson): Is this inefficient? Needs investigation.\n-        let ty = self.monomorphize(ty, substs);\n-\n-        self.layout_of(ty)\n-    }\n-\n     pub fn push_stack_frame(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -680,11 +609,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     _ => (dest, None)\n                 };\n \n-                let layout = self.type_layout(dest_ty)?;\n+                let layout = self.layout_of(dest_ty)?;\n                 for (i, operand) in operands.iter().enumerate() {\n                     let value = self.eval_operand(operand)?;\n                     // Ignore zero-sized fields.\n-                    if !self.type_layout(value.ty)?.is_zst() {\n+                    if !self.layout_of(value.ty)?.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let (field_dest, _) = self.place_field(dest, mir::Field::new(field_index), layout)?;\n                         self.write_value(value, field_dest)?;\n@@ -702,9 +631,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         )\n                     }\n                 };\n-                let elem_size = self.type_size(elem_ty)?.expect(\n-                    \"repeat element type must be sized\",\n-                );\n+                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 let value = self.eval_operand(operand)?.value;\n \n                 let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n@@ -750,16 +677,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n+                let ty = self.monomorphize(ty, self.substs());\n                 M::box_alloc(self, ty, dest)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let size = self.type_size(ty)?.expect(\n-                    \"SizeOf nullary MIR operator called for unsized type\",\n-                );\n+                let ty = self.monomorphize(ty, self.substs());\n+                let layout = self.layout_of(ty)?;\n+                assert!(!layout.is_unsized(),\n+                        \"SizeOf nullary MIR operator called for unsized type\");\n                 self.write_primval(\n                     dest,\n-                    PrimVal::from_u128(size as u128),\n+                    PrimVal::from_u128(layout.size.bytes() as u128),\n                     dest_ty,\n                 )?;\n             }\n@@ -806,7 +735,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n \n                     ReifyFnPointer => {\n-                        match self.operand_ty(operand).sty {\n+                        match self.eval_operand(operand)?.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n                                 let instance = self.resolve(def_id, substs)?;\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n@@ -832,7 +761,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n \n                     ClosureFnPointer => {\n-                        match self.operand_ty(operand).sty {\n+                        match self.eval_operand(operand)?.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let substs = self.tcx.trans_apply_param_substs(self.substs(), &substs);\n                                 let instance = ty::Instance::resolve_closure(\n@@ -889,27 +818,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    /// Returns the field type and whether the field is packed\n-    pub fn get_field_ty(\n-        &self,\n-        ty: Ty<'tcx>,\n-        field_index: usize,\n-    ) -> EvalResult<'tcx, TyAndPacked<'tcx>> {\n-        let layout = self.type_layout(ty)?.field(self, field_index)?;\n-        Ok(TyAndPacked {\n-            ty: layout.ty,\n-            packed: layout.is_packed()\n-        })\n-    }\n-\n-    pub fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n-        Ok(self.type_layout(ty)?.fields.offset(field_index))\n-    }\n-\n-    pub fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n-        Ok(self.type_layout(ty)?.fields.count() as u64)\n-    }\n-\n     pub(super) fn eval_operand_to_primval(\n         &mut self,\n         op: &mir::Operand<'tcx>,\n@@ -929,13 +837,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n         use mir::Operand::*;\n+        let ty = self.monomorphize(op.ty(self.mir(), self.tcx), self.substs());\n         match *op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n             Move(ref place) => {\n                 Ok(ValTy {\n                     value: self.eval_and_read_place(place)?,\n-                    ty: self.operand_ty(op),\n+                    ty\n                 })\n             },\n \n@@ -956,7 +865,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n                 Ok(ValTy {\n                     value,\n-                    ty: self.operand_ty(op),\n+                    ty,\n                 })\n             }\n         }\n@@ -967,7 +876,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         place: Place,\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, u128> {\n-        let layout = self.type_layout(ty)?;\n+        let layout = self.layout_of(ty)?;\n         //trace!(\"read_discriminant_value {:#?}\", layout);\n \n         match layout.variants {\n@@ -1024,7 +933,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         dest: Place,\n         variant_index: usize,\n     ) -> EvalResult<'tcx> {\n-        let layout = self.type_layout(dest_ty)?;\n+        let layout = self.layout_of(dest_ty)?;\n \n         match layout.variants {\n             layout::Variants::Single { index } => {\n@@ -1066,15 +975,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Value::ByRef(self.tcx.interpret_interner.borrow().get_cached(gid).expect(\"global not cached\"))\n     }\n \n-    pub fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n-    }\n-\n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let size = self.type_size(ty)?.expect(\n-            \"cannot copy from an unsized type\",\n-        );\n-        let align = self.type_align(ty)?;\n+        let layout = self.layout_of(ty)?;\n+        assert!(!layout.is_unsized(), \"cannot copy from an unsized type\");\n+        let size = layout.size.bytes();\n+        let align = layout.align.abi();\n         self.memory.copy(src, dest, size, align, false)?;\n         Ok(())\n     }\n@@ -1094,8 +999,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n-                        let substs = self.stack[frame].instance.substs;\n-                        let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n+                        let ptr = self.alloc_ptr(ty)?;\n                         self.stack[frame].locals[local.index() - 1] =\n                             Some(Value::by_ref(ptr.into())); // it stays live\n                         self.write_value_to_ptr(val, ptr.into(), ty)?;\n@@ -1265,7 +1169,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             }\n             Value::ByVal(primval) => {\n-                let layout = self.type_layout(dest_ty)?;\n+                let layout = self.layout_of(dest_ty)?;\n                 if layout.is_zst() {\n                     assert!(primval.is_undef());\n                     Ok(())\n@@ -1278,7 +1182,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             Value::ByValPair(a, b) => {\n                 let ptr = dest.to_ptr()?;\n-                let mut layout = self.type_layout(dest_ty)?;\n+                let mut layout = self.layout_of(dest_ty)?;\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n                 let mut packed = layout.is_packed();\n                 'outer: loop {\n@@ -1360,7 +1264,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::TyAdt(def, _) if def.is_box() => PrimValKind::Ptr,\n \n             ty::TyAdt(..) => {\n-                match self.type_layout(ty)?.abi {\n+                match self.layout_of(ty)?.abi {\n                     layout::Abi::Scalar(ref scalar) => {\n                         use ty::layout::Primitive::*;\n                         match scalar.value {\n@@ -1487,7 +1391,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n                 }\n \n-                if let layout::Abi::Scalar(ref scalar) = self.type_layout(ty)?.abi {\n+                if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n                     let mut signed = false;\n                     if let layout::Int(_, s) = scalar.value {\n                         signed = s;\n@@ -1580,69 +1484,62 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n+        dst: Place,\n+        dst_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        match (&src_ty.sty, &dest_ty.sty) {\n+        let src_layout = self.layout_of(src_ty)?;\n+        let dst_layout = self.layout_of(dst_ty)?;\n+        match (&src_ty.sty, &dst_ty.sty) {\n             (&ty::TyRef(_, ref s), &ty::TyRef(_, ref d)) |\n             (&ty::TyRef(_, ref s), &ty::TyRawPtr(ref d)) |\n             (&ty::TyRawPtr(ref s), &ty::TyRawPtr(ref d)) => {\n-                self.unsize_into_ptr(src, src_ty, dest, dest_ty, s.ty, d.ty)\n+                self.unsize_into_ptr(src, src_ty, dst, dst_ty, s.ty, d.ty)\n             }\n-            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n                 if def_a.is_box() || def_b.is_box() {\n                     if !def_a.is_box() || !def_b.is_box() {\n-                        panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dest_ty);\n+                        panic!(\"invalid unsizing between {:?} -> {:?}\", src_ty, dst_ty);\n                     }\n                     return self.unsize_into_ptr(\n                         src,\n                         src_ty,\n-                        dest,\n-                        dest_ty,\n+                        dst,\n+                        dst_ty,\n                         src_ty.boxed_ty(),\n-                        dest_ty.boxed_ty(),\n+                        dst_ty.boxed_ty(),\n                     );\n                 }\n                 if self.ty_to_primval_kind(src_ty).is_ok() {\n                     // TODO: We ignore the packed flag here\n-                    let sty = self.get_field_ty(src_ty, 0)?.ty;\n-                    let dty = self.get_field_ty(dest_ty, 0)?.ty;\n-                    return self.unsize_into(src, sty, dest, dty);\n+                    let sty = src_layout.field(&self, 0)?.ty;\n+                    let dty = dst_layout.field(&self, 0)?.ty;\n+                    return self.unsize_into(src, sty, dst, dty);\n                 }\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n \n                 assert_eq!(def_a, def_b);\n \n-                let src_fields = def_a.variants[0].fields.iter();\n-                let dst_fields = def_b.variants[0].fields.iter();\n-                let iter = src_fields.zip(dst_fields).enumerate();\n-\n-                //let src = adt::MaybeSizedValue::sized(src);\n-                //let dst = adt::MaybeSizedValue::sized(dst);\n-\n                 let src_ptr = match src {\n                     Value::ByRef(PtrAndAlign { ptr, aligned: true }) => ptr,\n                     // the entire struct is just a pointer\n                     Value::ByVal(_) => {\n-                        for (i, (src_f, dst_f)) in iter {\n-                            let src_fty = self.field_ty(substs_a, src_f);\n-                            let dst_fty = self.field_ty(substs_b, dst_f);\n-                            if self.type_size(dst_fty)? == Some(0) {\n+                        for i in 0..src_layout.fields.count() {\n+                            let src_field = src_layout.field(&self, i)?;\n+                            let dst_field = dst_layout.field(&self, i)?;\n+                            if dst_layout.is_zst() {\n                                 continue;\n                             }\n-                            let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n-                            let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n-                            assert_eq!(src_field_offset, 0);\n-                            assert_eq!(dst_field_offset, 0);\n-                            assert_eq!(self.type_size(src_fty)?, self.type_size(src_ty)?);\n-                            assert_eq!(self.type_size(dst_fty)?, self.type_size(dest_ty)?);\n+                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(src_field.size, src_layout.size);\n+                            assert_eq!(dst_field.size, dst_layout.size);\n                             return self.unsize_into(\n                                 src,\n-                                src_fty,\n-                                dest,\n-                                dst_fty,\n+                                src_field.ty,\n+                                dst,\n+                                dst_field.ty,\n                             );\n                         }\n                         bug!(\"by val unsize into where the value doesn't cover the entire type\")\n@@ -1652,25 +1549,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n \n                 // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr()?;\n-                for (i, (src_f, dst_f)) in iter {\n-                    let src_fty = self.field_ty(substs_a, src_f);\n-                    let dst_fty = self.field_ty(substs_b, dst_f);\n-                    if self.type_size(dst_fty)? == Some(0) {\n+                let dst = self.force_allocation(dst)?.to_ptr()?;\n+                for i in 0..src_layout.fields.count() {\n+                    let src_field = src_layout.field(&self, i)?;\n+                    let dst_field = dst_layout.field(&self, i)?;\n+                    if dst_field.is_zst() {\n                         continue;\n                     }\n-                    let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n-                    let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n+                    let src_field_offset = src_layout.fields.offset(i).bytes();\n+                    let dst_field_offset = dst_layout.fields.offset(i).bytes();\n                     let src_f_ptr = src_ptr.offset(src_field_offset, &self)?;\n-                    let dst_f_ptr = dest.offset(dst_field_offset, &self)?;\n-                    if src_fty == dst_fty {\n-                        self.copy(src_f_ptr, dst_f_ptr.into(), src_fty)?;\n+                    let dst_f_ptr = dst.offset(dst_field_offset, &self)?;\n+                    if src_field.ty == dst_field.ty {\n+                        self.copy(src_f_ptr, dst_f_ptr.into(), src_field.ty)?;\n                     } else {\n                         self.unsize_into(\n                             Value::by_ref(src_f_ptr),\n-                            src_fty,\n+                            src_field.ty,\n                             Place::from_ptr(dst_f_ptr),\n-                            dst_fty,\n+                            dst_field.ty,\n                         )?;\n                     }\n                 }\n@@ -1680,7 +1577,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 bug!(\n                     \"unsize_into: invalid conversion: {:?} -> {:?}\",\n                     src_ty,\n-                    dest_ty\n+                    dst_ty\n                 )\n             }\n         }"}, {"sha": "7a5f3e80dc9fa149b4d7b1998d0a8f5d0e75a37c", "filename": "src/librustc/mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fplace.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -1,6 +1,6 @@\n use mir;\n use ty::{self, Ty};\n-use ty::layout::TyLayout;\n+use ty::layout::{LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::{EvalResult, EvalContext, MemoryPointer, PrimVal, Value, Pointer, Machine, PtrAndAlign, ValTy};\n@@ -134,7 +134,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let base_ty = self.place_ty(&proj.base);\n         match proj.elem {\n             Field(field, _) => {\n-                let base_layout = self.type_layout(base_ty)?;\n+                let base_layout = self.layout_of(base_ty)?;\n                 let field_index = field.index();\n                 let field = base_layout.field(&self, field_index)?;\n                 let offset = base_layout.fields.offset(field_index);\n@@ -317,9 +317,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n-        let elem_size = self.type_size(elem_ty)?.expect(\n-            \"slice element must be sized\",\n-        );\n+        let elem_size = self.layout_of(elem_ty)?.size.bytes();\n         assert!(\n             n < len,\n             \"Tried to access element {} of array/slice with length {}\",\n@@ -354,7 +352,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use mir::ProjectionElem::*;\n         let (ptr, extra) = match *proj_elem {\n             Field(field, _) => {\n-                let layout = self.type_layout(base_ty)?;\n+                let layout = self.layout_of(base_ty)?;\n                 return Ok(self.place_field(base, field, layout)?.0);\n             }\n \n@@ -394,9 +392,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\n-                    \"sequence element must be sized\",\n-                );\n+                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -415,9 +411,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\n-                    \"slice element must be sized\",\n-                );\n+                let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n                 // sublicing arrays produces arrays"}, {"sha": "a23d54e79f1aecf53630c6cf61b4bec59375195b", "filename": "src/librustc/mir/interpret/step.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fstep.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -6,7 +6,7 @@ use hir;\n use mir::visit::{Visitor, PlaceContext};\n use mir;\n use ty::{self, Instance};\n-use ty::subst::Substs;\n+use ty::layout::LayoutOf;\n use middle::const_val::ConstVal;\n \n use super::{EvalResult, EvalContext, StackPopCleanup, PtrAndAlign, GlobalId, Place,\n@@ -158,7 +158,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         instance: Instance<'tcx>,\n         span: Span,\n         mutability: Mutability,\n-        orig_substs: &'tcx Substs<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         debug!(\"global_item: {:?}\", instance);\n         let cid = GlobalId {\n@@ -172,8 +171,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             M::global_item_with_linkage(self, cid.instance, mutability)?;\n             return Ok(false);\n         }\n-        let mir = self.load_mir(instance.def)?;\n-        let layout = self.type_layout_with_substs(mir.return_ty(), orig_substs)?;\n+        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n+        let instance_ty =\n+            self.monomorphize(instance.def.def_ty(self.tcx), instance.substs);\n+        let layout = self.layout_of(instance_ty)?;\n         assert!(!layout.is_unsized());\n         let ptr = self.memory.allocate(\n             layout.size.bytes(),\n@@ -200,6 +201,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let cleanup = StackPopCleanup::MarkStatic(mutability);\n         let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n         trace!(\"pushing stack frame for global: {}\", name);\n+        let mir = self.load_mir(instance.def)?;\n         self.push_stack_frame(\n             instance,\n             span,\n@@ -254,7 +256,6 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                         instance,\n                         constant.span,\n                         Mutability::Immutable,\n-                        this.instance.substs,\n                     )\n                 }\n                 mir::Literal::Value { .. } => Ok(false),\n@@ -267,9 +268,8 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                         return Ok(false);\n                     }\n                     let mir = &this.mir.promoted[index];\n-                    let layout = this.ecx.type_layout_with_substs(\n-                        mir.return_ty(),\n-                        this.instance.substs)?;\n+                    let ty = this.ecx.monomorphize(mir.return_ty(), this.instance.substs);\n+                    let layout = this.ecx.layout_of(ty)?;\n                     assert!(!layout.is_unsized());\n                     let ptr = this.ecx.memory.allocate(\n                         layout.size.bytes(),\n@@ -320,7 +320,6 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                                 } else {\n                                     Mutability::Immutable\n                                 },\n-                                this.instance.substs,\n                             )\n                         } else {\n                             bug!(\"static def id doesn't point to static\");\n@@ -340,7 +339,6 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                             } else {\n                                 Mutability::Immutable\n                             },\n-                            this.instance.substs,\n                         )\n                     } else {\n                         bug!(\"static found but isn't a static: {:?}\", def);"}, {"sha": "7597a7e2e0ca8aa5934de45f8fbed65c15b3a555", "filename": "src/librustc/mir/interpret/terminator/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fterminator%2Fmod.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -1,5 +1,6 @@\n use mir;\n use ty::{self, TypeVariants};\n+use ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n@@ -64,13 +65,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     None => None,\n                 };\n \n-                let func_ty = self.operand_ty(func);\n-                let (fn_def, sig) = match func_ty.sty {\n+                let func = self.eval_operand(func)?;\n+                let (fn_def, sig) = match func.ty.sty {\n                     ty::TyFnPtr(sig) => {\n-                        let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n+                        let fn_ptr = self.value_to_primval(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        let instance_ty = instance.def.def_ty(self.tcx);\n-                        let instance_ty = self.monomorphize(instance_ty, instance.substs);\n+                        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n+                        let instance_ty =\n+                            self.monomorphize(instance.def.def_ty(self.tcx), instance.substs);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n                                 let real_sig = instance_ty.fn_sig(self.tcx);\n@@ -86,10 +88,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n                     ty::TyFnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n-                        func_ty.fn_sig(self.tcx),\n+                        func.ty.fn_sig(self.tcx),\n                     ),\n                     _ => {\n-                        let msg = format!(\"can't handle callee of type {:?}\", func_ty);\n+                        let msg = format!(\"can't handle callee of type {:?}\", func.ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n@@ -214,7 +216,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 if check_ty_compat(sig.output(), real_sig.output()) && real_sig.inputs_and_output.len() == 3 => {\n                 // First argument of real_sig must be a ZST\n                 let fst_ty = real_sig.inputs_and_output[0];\n-                if self.type_layout(fst_ty)?.is_zst() {\n+                if self.layout_of(fst_ty)?.is_zst() {\n                     // Second argument must be a tuple matching the argument list of sig\n                     let snd_ty = real_sig.inputs_and_output[1];\n                     match snd_ty.sty {\n@@ -249,7 +251,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     _ => return err!(Unreachable),\n                 };\n                 let ty = sig.output();\n-                let layout = self.type_layout(ty)?;\n+                let layout = self.layout_of(ty)?;\n                 M::call_intrinsic(self, instance, args, ret, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n@@ -319,7 +321,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n \n                         // unpack and write all other args\n-                        let layout = self.type_layout(args[1].ty)?;\n+                        let layout = self.layout_of(args[1].ty)?;\n                         if let ty::TyTuple(..) = args[1].ty.sty {\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 match args[1].value {\n@@ -405,7 +407,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n-                let ty = self.get_field_ty(args[0].ty, 0)?.ty; // TODO: packed flag is ignored\n+                let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n                 args[0].ty = ty;\n                 args[0].value = ptr.to_value();\n                 // recurse with concrete function"}, {"sha": "47ac2875995756587c0f3c72cf0f9fc4ee20bc03", "filename": "src/librustc/mir/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ftraits.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -1,5 +1,5 @@\n use ty::{self, Ty};\n-use ty::layout::{Size, Align};\n+use ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n use super::{EvalResult, EvalContext, eval_context, MemoryPointer, Value, PrimVal,\n@@ -19,10 +19,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, MemoryPointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n-        let size = self.type_size(trait_ref.self_ty())?.expect(\n-            \"can't create a vtable for an unsized type\",\n-        );\n-        let align = self.type_align(trait_ref.self_ty())?;\n+        let layout = self.layout_of(trait_ref.self_ty())?;\n+        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+        let size = layout.size.bytes();\n+        let align = layout.align.abi();\n \n         let ptr_size = self.memory.pointer_size();\n         let methods = self.tcx.vtable_methods(trait_ref);"}, {"sha": "3480bbc8f11e1ad97cdfb7ad0f796918a6f25e65", "filename": "src/librustc/mir/interpret/validation.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc%2Fmir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalidation.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -2,6 +2,7 @@ use hir::{self, Mutability};\n use hir::Mutability::*;\n use mir::{self, ValidationOp, ValidationOperand};\n use ty::{self, Ty, TypeFoldable, TyCtxt};\n+use ty::layout::LayoutOf;\n use ty::subst::{Substs, Subst};\n use traits;\n use infer::InferCtxt;\n@@ -433,7 +434,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         query: ValidationQuery<'tcx>,\n         mode: ValidationMode,\n     ) -> EvalResult<'tcx> {\n-        let mut layout = self.type_layout(query.ty)?;\n+        let mut layout = self.layout_of(query.ty)?;\n         layout.ty = query.ty;\n \n         // TODO: Maybe take visibility/privacy into account.\n@@ -530,23 +531,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             let (ptr, extra) = self.force_allocation(query.place.1)?.to_ptr_extra_aligned();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Places?\n-            let len = match self.type_size(query.ty)? {\n-                Some(size) => {\n-                    assert_eq!(extra, PlaceExtra::None, \"Got a fat ptr to a sized type\");\n-                    size\n-                }\n-                None => {\n-                    // The only unsized typ we concider \"owning\" is TyStr.\n-                    assert_eq!(\n-                        query.ty.sty,\n-                        TyStr,\n-                        \"Found a surprising unsized owning type\"\n-                    );\n-                    // The extra must be the length, in bytes.\n-                    match extra {\n-                        PlaceExtra::Length(len) => len,\n-                        _ => bug!(\"TyStr must have a length as extra\"),\n-                    }\n+            let layout = self.layout_of(query.ty)?;\n+            let len = if !layout.is_unsized() {\n+                assert_eq!(extra, PlaceExtra::None, \"Got a fat ptr to a sized type\");\n+                layout.size.bytes()\n+            } else {\n+                // The only unsized typ we concider \"owning\" is TyStr.\n+                assert_eq!(\n+                    query.ty.sty,\n+                    TyStr,\n+                    \"Found a surprising unsized owning type\"\n+                );\n+                // The extra must be the length, in bytes.\n+                match extra {\n+                    PlaceExtra::Length(len) => len,\n+                    _ => bug!(\"TyStr must have a length as extra\"),\n                 }\n             };\n             // Handle locking"}, {"sha": "d9a757f4bb1ddb549b47288168d08c08524ae7f9", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a534c20a2185f93effecb8f818e1220fd4a565/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=42a534c20a2185f93effecb8f818e1220fd4a565", "patch": "@@ -844,7 +844,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n         },\n         TyArray(elem_ty, n) => {\n             let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-            let size = ecx.type_size(elem_ty).unwrap().unwrap();\n+            let size = ecx.layout_of(elem_ty).unwrap().size.bytes();\n             let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n                 ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n                     (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n@@ -868,8 +868,9 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n                 ConstVal::Aggregate(Tuple(v)) => v,\n                 _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n             };\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n             for (i, elem) in vec.into_iter().enumerate() {\n-                let offset = ecx.get_field_offset(miri_ty, i).unwrap();\n+                let offset = layout.fields.offset(i);\n                 let ptr = miri_val.offset(offset.bytes(), &ecx).unwrap();\n                 check_ctfe_against_miri(ecx, ptr, elem.ty, elem.val);\n             }\n@@ -895,7 +896,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n                 },\n                 ctfe => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n             };\n-            let layout = ecx.type_layout(miri_ty).unwrap();\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n             for &(name, elem) in vec.into_iter() {\n                 let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n                 let (place, _) = ecx.place_field("}]}