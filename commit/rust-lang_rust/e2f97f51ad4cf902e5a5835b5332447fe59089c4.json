{"sha": "e2f97f51ad4cf902e5a5835b5332447fe59089c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZjk3ZjUxYWQ0Y2Y5MDJlNWE1ODM1YjUzMzI0NDdmZTU5MDg5YzQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T17:24:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T23:24:24Z"}, "message": "Register new snapshots\n\nConflicts:\n\tsrc/librbml/lib.rs\n\tsrc/libserialize/json_stage0.rs\n\tsrc/libserialize/serialize_stage0.rs\n\tsrc/libsyntax/ast.rs\n\tsrc/libsyntax/ext/deriving/generic/mod.rs\n\tsrc/libsyntax/parse/token.rs", "tree": {"sha": "6158174fbd2ae40d72c113d398ff192a936804f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6158174fbd2ae40d72c113d398ff192a936804f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2f97f51ad4cf902e5a5835b5332447fe59089c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f97f51ad4cf902e5a5835b5332447fe59089c4", "html_url": "https://github.com/rust-lang/rust/commit/e2f97f51ad4cf902e5a5835b5332447fe59089c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2f97f51ad4cf902e5a5835b5332447fe59089c4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "html_url": "https://github.com/rust-lang/rust/commit/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09"}], "stats": {"total": 6513, "additions": 94, "deletions": 6419}, "files": [{"sha": "ff9b2de3ccf00f14f87ed62608c2dafa2e91c418", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -16,14 +16,8 @@\n extern crate test;\n extern crate getopts;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate log;\n-\n extern crate regex;\n \n use std::os;"}, {"sha": "d5a814d83e48209642930daad2d86f27163c423d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -65,36 +65,16 @@\n \n #![no_std]\n #![allow(unknown_features)]\n-#![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n-#![feature(associated_types)]\n+#![feature(lang_items, phase, unsafe_destructor)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n-\n extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n // Heaps provided for low-level allocation strategies\n "}, {"sha": "82dfa41d9d850af00b636cb70f19c06fa397973d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -21,42 +21,18 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, slicing_syntax)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n #![no_std]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n \n extern crate unicode;\n extern crate alloc;\n \n #[cfg(test)] extern crate test;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n pub use binary_heap::BinaryHeap;\n pub use bitv::Bitv;\n@@ -73,8 +49,7 @@ pub use vec_map::VecMap;\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n pub mod binary_heap;"}, {"sha": "68e2482964dbb87c3152b8435e92ea02c8cd183e", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -8,21 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Creates a `std::vec::Vec` containing the arguments.\n-// NOTE: remove after the next snapshot\n-#[cfg(stage0)]\n-macro_rules! vec {\n-    ($($e:expr),*) => ({\n-        // leading _ to allow empty construction without a warning.\n-        let mut _temp = ::vec::Vec::new();\n-        $(_temp.push($e);)*\n-        _temp\n-    });\n-    ($($e:expr),+,) => (vec!($($e),+))\n-}\n-\n /// Creates a `Vec` containing the arguments.\n-#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! vec {\n     ($($x:expr),*) => ({"}, {"sha": "fdd758cedac835e6bd5f89e4e065f5244be474f8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -27,9 +27,6 @@ use slice::SliceExt;\n use slice;\n use str::{self, StrExt, Utf8Error};\n \n-// NOTE: for old macros; remove after the next snapshot\n-#[cfg(stage0)] use result::Result::Err;\n-\n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;"}, {"sha": "4b598fd50339f01c4faf117dde14e895cc8db4f1", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -56,29 +56,25 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![no_std]\n-#![allow(unknown_features, raw_pointer_deriving)]\n-#![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n+#![allow(unknown_features, raw_pointer_derive)]\n+#![feature(intrinsics, lang_items)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n-#![feature(default_type_params, unboxed_closures, associated_types)]\n+#![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n #[path = \"num/float_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod float_macros;\n \n #[path = \"num/int_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod int_macros;\n \n #[path = \"num/uint_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;"}, {"sha": "d01621fc6d8d6f36d2765d3b3f4ce60547665ead", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -142,16 +142,9 @@ macro_rules! debug_assert_eq {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n }\n \n-#[cfg(stage0)]\n-#[macro_export]\n-macro_rules! try {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-}\n-\n /// Short circuiting evaluation on Err\n ///\n /// `libstd` contains a more general `try!` macro that uses `FromError`.\n-#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! try {\n     ($e:expr) => ({"}, {"sha": "9be7917e0a0ef1422f5c9e9aba57580e9f3e8bb9", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -14,8 +14,7 @@ use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::kinds::Copy;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod int_macros;\n \n mod i8;\n@@ -24,8 +23,7 @@ mod i32;\n mod i64;\n mod int;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod uint_macros;\n \n mod u8;"}, {"sha": "f38440d86c6e855a4f171443d9397469adb9d1b3", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -21,7 +21,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(unboxed_closures, associated_types)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "47cc072a636a147fe81e5b69b537bd28da6cca21", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,8 +23,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(globs, slicing_syntax)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "f50e24c6354f184ea6a344be5abe6361c8125482", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -85,8 +85,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, slicing_syntax)]\n-#![feature(unboxed_closures)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "83bad70e7b117b05f67ff3a4157e2d21279713be", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -271,8 +271,7 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(globs, slicing_syntax)]\n-#![feature(unboxed_closures)]\n+#![feature(slicing_syntax)]\n \n use self::LabelText::*;\n "}, {"sha": "1aaa0528a6856c823fdd679fc8bcc865a6ea9ea1", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(globs)]\n #![crate_name = \"libc\"]\n #![experimental]\n #![no_std] // we don't need std, and we can't have std, since it doesn't exist\n@@ -76,7 +75,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(missing_docs)]\n #![allow(non_snake_case)]\n-#![allow(raw_pointer_deriving)]\n+#![allow(raw_pointer_derive)]\n \n extern crate core;\n "}, {"sha": "08b01e956e1ac83c073524226f8ca2ef5200d41d", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -163,7 +163,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, unboxed_closures, slicing_syntax)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -182,8 +182,7 @@ use regex::Regex;\n \n use directive::LOG_LEVEL_NAMES;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod macros;\n \n mod directive;"}, {"sha": "9e5fcdc8df553d64fa844176c7b6de1fbabbfd2a", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,35 +23,14 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, phase, globs)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n #![no_std]\n #![experimental]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n extern crate core;\n \n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate std;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate std;\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n use core::prelude::*;\n "}, {"sha": "a66d1dd08c1eb6aac528aa7723cde4a25d46e884", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 471, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -24,19 +24,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax, globs)]\n-#![feature(unboxed_closures, associated_types)]\n-#![allow(missing_docs)]\n+#![feature(slicing_syntax)]\n \n extern crate serialize;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[macro_use] extern crate log;\n \n #[cfg(test)] extern crate test;\n \n@@ -424,263 +415,6 @@ pub mod reader {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<'doc> serialize::Decoder<Error> for Decoder<'doc> {\n-        fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n-        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n-        fn read_uint(&mut self) -> DecodeResult<uint> {\n-            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n-            if v > (::std::uint::MAX as u64) {\n-                Err(IntTooBig(v as uint))\n-            } else {\n-                Ok(v as uint)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n-        }\n-        fn read_i8 (&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n-        }\n-        fn read_int(&mut self) -> DecodeResult<int> {\n-            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n-            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as uint))\n-            } else {\n-                Ok(v as int)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsBool))) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(try!(self.next_doc(EsF64)));\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(try!(self.next_doc(EsF32)));\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(try!(self.next_doc(EsStr)).as_str())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum({:?})\", name);\n-            try!(self._check_label(name));\n-\n-            let doc = try!(self.next_doc(EsEnum));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str],\n-                                   mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={:?}\", idx);\n-\n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_variant_arg(idx={:?})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n-                                          mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = try!(self._next_uint(EsEnumVid));\n-            debug!(\"  idx={:?}\", idx);\n-\n-            let doc = try!(self.next_doc(EsEnumBody));\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = try!(f(self, idx));\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: uint,\n-                                                f: F)\n-                                                -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-                debug!(\"read_enum_struct_variant_arg(name={:?}, idx={:?})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_struct(name={:?})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_struct_field(name={:?}, idx={:?})\", name, idx);\n-            try!(self._check_label(name));\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, \\\n-                                          found tuple of length `{}`\", tuple_len, len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_arg(idx={:?})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_struct(name={:?})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self,\n-                                       idx: uint,\n-                                       f: F)\n-                                       -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={:?})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n-            F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => {\n-                            Err(Expected(format!(\"Expected None or Some\")))\n-                        }\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = try!(d._next_uint(EsVecLen));\n-                debug!(\"  len={:?}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_seq_elt(idx={:?})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = try!(d._next_uint(EsMapLen));\n-                debug!(\"  len={:?}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map_elt_key(idx={:?})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n-        {\n-            debug!(\"read_map_elt_val(idx={:?})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     impl<'doc> serialize::Decoder for Decoder<'doc> {\n         type Error = Error;\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n@@ -1137,209 +871,6 @@ pub mod writer {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    impl<'a, W: Writer + Seek> serialize::Encoder<io::IoError> for Encoder<'a, W> {\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n-            self.wr_tagged_u64(EsUint as uint, v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            self.wr_tagged_u64(EsU64 as uint, v)\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            self.wr_tagged_u32(EsU32 as uint, v)\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            self.wr_tagged_u16(EsU16 as uint, v)\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_u8(EsU8 as uint, v)\n-        }\n-\n-        fn emit_int(&mut self, v: int) -> EncodeResult {\n-            self.wr_tagged_i64(EsInt as uint, v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            self.wr_tagged_i64(EsI64 as uint, v)\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            self.wr_tagged_i32(EsI32 as uint, v)\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            self.wr_tagged_i16(EsI16 as uint, v)\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_i8(EsI8 as uint, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_u32(EsChar as uint, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as uint, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_label(name));\n-            try!(self.start_tag(EsEnum as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self,\n-                                _: &str,\n-                                v_id: uint,\n-                                _: uint,\n-                                f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n-            try!(self.start_tag(EsEnumBody as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: uint,\n-                                       cnt: uint,\n-                                       f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self,\n-                                             _: &str,\n-                                             idx: uint,\n-                                             f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self._emit_label(name));\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsVec as uint));\n-            try!(self._emit_tagged_uint(EsVecLen, len));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsVecElt as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsMap as uint));\n-            try!(self._emit_tagged_uint(EsMapLen, len));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n-            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-\n-            try!(self.start_tag(EsMapKey as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n-        {\n-            try!(self.start_tag(EsMapVal as uint));\n-            try!(f(self));\n-            self.end_tag()\n-        }\n-    }\n-    #[cfg(not(stage0))]\n     impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n         type Error = io::IoError;\n "}, {"sha": "c039abc9aff2a8955134bfbcd8181f2a46b85ae9", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,9 +23,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, slicing_syntax, globs)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "0aebbf2970fceff2eff38f967bdee35cfcf800c5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -22,13 +22,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;\n@@ -40,22 +36,8 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n extern crate collections;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "9e71c867efa09473242fd17cfcdc5a696bccbb74", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -675,14 +675,14 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n     let path = item_path(item_doc).init().to_vec();\n-    match decode_inlined_item.call_mut((cdata, tcx, path, item_doc)) {\n+    match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::found(ii),\n         Err(path) => {\n             match item_parent_item(item_doc) {\n                 Some(did) => {\n                     let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n-                    match decode_inlined_item.call_mut((cdata, tcx, path, parent_item)) {\n+                    match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::found_parent(did, ii),\n                         Err(_) => csearch::not_found\n                     }"}, {"sha": "28ad36194ef9a0104d986c09beb08caaf4bc7513", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -953,7 +953,7 @@ fn encode_inlined_item(ecx: &EncodeContext,\n                        ii: InlinedItemRef) {\n     let mut eii = ecx.encode_inlined_item.borrow_mut();\n     let eii: &mut EncodeInlinedItem = &mut *eii;\n-    eii.call_mut((ecx, rbml_w, ii))\n+    eii(ecx, rbml_w, ii)\n }\n \n const FN_FAMILY: char = 'f';"}, {"sha": "32ce131c57a3cb1eab725ae13c5df991e405505c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -263,14 +263,6 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n-#[cfg(stage0)]\n-impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n-    fn emit_def_id(&mut self, did: ast::DefId) {\n-        did.encode(self).ok().unwrap()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::DefId) {\n         did.encode(self).ok().unwrap()\n@@ -283,21 +275,6 @@ trait def_id_decoder_helpers {\n                          cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n-#[cfg(stage0)]\n-impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        did.tr(dcx)\n-    }\n-\n-    fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        decoder::translate_def_id(cdata, did)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();"}, {"sha": "bd96a8a0f2cd78f980ea42ecb19fcb9749f59321", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination(substs={})\",\n                        substs.repr(self.tcx));\n \n-                callback.call_mut((substs,));\n+                callback(substs);\n             }\n \n             Some((space, index, &param_ty)) => {"}, {"sha": "15c2845882c39bb6dce3f988031cfe52b2ca6342", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n             _ => {\n                 debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n                        r.repr(self.tcx()), self.current_depth);\n-                self.fld_r.call_mut((r, self.current_depth))\n+                (self.fld_r)(r, self.current_depth)\n             }\n         }\n     }"}, {"sha": "ca39477fbdcb2e9d700d5602f491d7a253108c13", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -28,22 +28,11 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(globs, phase, macro_rules, slicing_syntax)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#![feature(slicing_syntax)]\n \n extern crate syntax;\n extern crate serialize;\n+#[macro_use] extern crate log;\n \n pub mod abi;\n pub mod archive;"}, {"sha": "26bcd5f4c10cd3b82c702dd34fb13e7cb09a2f89", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -17,28 +17,13 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n #![allow(non_camel_case_types)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "4164a8551cc3c9ddcaab011fb9cd4cd742997aa6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -22,11 +22,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;\n@@ -41,22 +39,8 @@ extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n pub use syntax::diagnostic;\n "}, {"sha": "0bed754aa3c1bf8cb351377baab05543ae2cb067", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -21,10 +21,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(globs)]\n #![feature(link_args)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n \n extern crate libc;\n "}, {"sha": "653cdb1c42c6236f1e9650c0d56a315b80ca6a79", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -16,26 +16,11 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(globs, phase, slicing_syntax)]\n+#![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(associated_types)]\n-#![feature(old_orphan_check)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n extern crate rustc;\n "}, {"sha": "b6f90a4c2f52a9ac7420b588f9f3727051fb87eb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -22,13 +22,9 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(unknown_features)]\n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;\n@@ -40,21 +36,8 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n pub use rustc::session;\n pub use rustc::metadata;"}, {"sha": "42134789546958bbb3d2a47d835bfc0e6126a4bc", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -16,8 +16,7 @@ pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n mod doc;"}, {"sha": "ae8731dfa476b1e4e20ab0c101f6826906d25b97", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -71,27 +71,13 @@ This API is completely unstable and subject to change.\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(default_type_params, globs, macro_rules, phase, quote)]\n+#![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate syntax;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate syntax;\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n \n extern crate arena;\n extern crate rustc;"}, {"sha": "6c6c7c4d378373cdeb94607e8025c126a71df452", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -16,12 +16,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(globs, macro_rules, phase, slicing_syntax)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n \n extern crate arena;\n extern crate getopts;\n@@ -32,14 +27,7 @@ extern crate rustc_driver;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[macro_use] extern crate log;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n@@ -56,8 +44,7 @@ use rustc::session::search_paths::SearchPaths;\n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod externalfiles;\n \n pub mod clean;"}, {"sha": "f2d79b133469958d48a5a3d8b3519871b5f494c0", "filename": "src/libserialize/collection_impls_stage0.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fcollection_impls_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fcollection_impls_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls_stage0.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations of serialization for structures found in libcollections\n-\n-use std::uint;\n-use std::default::Default;\n-use std::hash::{Hash, Hasher};\n-\n-use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n-use collections::enum_set::{EnumSet, CLike};\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E>\n-> Encodable<S, E> for DList<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n-    fn decode(d: &mut D) -> Result<DList<T>, E> {\n-        d.read_seq(|d, len| {\n-            let mut list = DList::new();\n-            for i in range(0u, len) {\n-                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(list)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E>\n-> Encodable<S, E> for RingBuf<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n-    fn decode(d: &mut D) -> Result<RingBuf<T>, E> {\n-        d.read_seq(|d, len| {\n-            let mut deque: RingBuf<T> = RingBuf::new();\n-            for i in range(0u, len) {\n-                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(deque)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    K: Encodable<S, E> + PartialEq + Ord,\n-    V: Encodable<S, E> + PartialEq\n-> Encodable<S, E> for BTreeMap<K, V> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    K: Decodable<D, E> + PartialEq + Ord,\n-    V: Decodable<D, E> + PartialEq\n-> Decodable<D, E> for BTreeMap<K, V> {\n-    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, E> {\n-        d.read_map(|d, len| {\n-            let mut map = BTreeMap::new();\n-            for i in range(0u, len) {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + PartialEq + Ord\n-> Encodable<S, E> for BTreeSet<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + PartialEq + Ord\n-> Decodable<D, E> for BTreeSet<T> {\n-    fn decode(d: &mut D) -> Result<BTreeSet<T>, E> {\n-        d.read_seq(|d, len| {\n-            let mut set = BTreeSet::new();\n-            for i in range(0u, len) {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(set)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + CLike\n-> Encodable<S, E> for EnumSet<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        let mut bits = 0;\n-        for item in self.iter() {\n-            bits |= item.to_uint();\n-        }\n-        s.emit_uint(bits)\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + CLike\n-> Decodable<D, E> for EnumSet<T> {\n-    fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n-        let bits = try!(d.read_uint());\n-        let mut set = EnumSet::new();\n-        for bit in range(0, uint::BITS) {\n-            if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_uint(1 << bit));\n-            }\n-        }\n-        Ok(set)\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    K: Encodable<S, E> + Hash<X> + Eq,\n-    V: Encodable<S, E>,\n-    X,\n-    H: Hasher<X>\n-> Encodable<S, E> for HashMap<K, V, H> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    K: Decodable<D, E> + Hash<S> + Eq,\n-    V: Decodable<D, E>,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable<D, E> for HashMap<K, V, H> {\n-    fn decode(d: &mut D) -> Result<HashMap<K, V, H>, E> {\n-        d.read_map(|d, len| {\n-            let hasher = Default::default();\n-            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n-            for i in range(0u, len) {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + Hash<X> + Eq,\n-    X,\n-    H: Hasher<X>\n-> Encodable<S, E> for HashSet<T, H> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n-                i += 1;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + Hash<S> + Eq,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable<D, E> for HashSet<T, H> {\n-    fn decode(d: &mut D) -> Result<HashSet<T, H>, E> {\n-        d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n-            for i in range(0u, len) {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(set)\n-        })\n-    }\n-}\n-\n-impl<\n-    E,\n-    S: Encoder<E>,\n-    V: Encodable<S, E>\n-> Encodable<S, E> for VecMap<V> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        e.emit_map(self.len(), |e| {\n-                for (i, (key, val)) in self.iter().enumerate() {\n-                    try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                    try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n-                }\n-                Ok(())\n-            })\n-    }\n-}\n-\n-impl<\n-    E,\n-    D: Decoder<E>,\n-    V: Decodable<D, E>\n-> Decodable<D, E> for VecMap<V> {\n-    fn decode(d: &mut D) -> Result<VecMap<V>, E> {\n-        d.read_map(|d, len| {\n-            let mut map = VecMap::new();\n-            for i in range(0u, len) {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n-                map.insert(key, val);\n-            }\n-            Ok(map)\n-        })\n-    }\n-}"}, {"sha": "1c2855f67452973fe95f2d3e2625050dbb19c119", "filename": "src/libserialize/json_stage0.rs", "status": "removed", "additions": 0, "deletions": 3864, "changes": 3864, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fjson_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fjson_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_stage0.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09"}, {"sha": "3dfed466e60a9eea66d87cceb39f3c7579103382", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,48 +23,23 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n-#![feature(unboxed_closures)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n \n // test harness access\n-#[cfg(test)]\n-extern crate test;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] extern crate test;\n+#[macro_use] extern crate log;\n \n extern crate unicode;\n-\n extern crate collections;\n \n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n \n-#[cfg(stage0)]\n-#[path = \"serialize_stage0.rs\"]\n-mod serialize;\n-#[cfg(not(stage0))]\n mod serialize;\n-\n-#[cfg(stage0)]\n-#[path = \"collection_impls_stage0.rs\"]\n-mod collection_impls;\n-#[cfg(not(stage0))]\n mod collection_impls;\n \n pub mod base64;\n pub mod hex;\n-\n-#[cfg(stage0)]\n-#[path = \"json_stage0.rs\"]\n-pub mod json;\n-#[cfg(not(stage0))]\n pub mod json;\n \n mod rustc_serialize {"}, {"sha": "87ff5922c1a7edec4e2df2ddc5ccfdc15136e0d1", "filename": "src/libserialize/serialize_stage0.rs", "status": "removed", "additions": 0, "deletions": 630, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1,630 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Support code for encoding and decoding types.\n-\n-/*\n-Core encoding and decoding interfaces.\n-*/\n-\n-use std::ops::FullRange;\n-use std::path;\n-use std::rc::Rc;\n-use std::cell::{Cell, RefCell};\n-use std::sync::Arc;\n-\n-pub trait Encoder<E> {\n-    // Primitive types:\n-    fn emit_nil(&mut self) -> Result<(), E>;\n-    fn emit_uint(&mut self, v: uint) -> Result<(), E>;\n-    fn emit_u64(&mut self, v: u64) -> Result<(), E>;\n-    fn emit_u32(&mut self, v: u32) -> Result<(), E>;\n-    fn emit_u16(&mut self, v: u16) -> Result<(), E>;\n-    fn emit_u8(&mut self, v: u8) -> Result<(), E>;\n-    fn emit_int(&mut self, v: int) -> Result<(), E>;\n-    fn emit_i64(&mut self, v: i64) -> Result<(), E>;\n-    fn emit_i32(&mut self, v: i32) -> Result<(), E>;\n-    fn emit_i16(&mut self, v: i16) -> Result<(), E>;\n-    fn emit_i8(&mut self, v: i8) -> Result<(), E>;\n-    fn emit_bool(&mut self, v: bool) -> Result<(), E>;\n-    fn emit_f64(&mut self, v: f64) -> Result<(), E>;\n-    fn emit_f32(&mut self, v: f32) -> Result<(), E>;\n-    fn emit_char(&mut self, v: char) -> Result<(), E>;\n-    fn emit_str(&mut self, v: &str) -> Result<(), E>;\n-\n-    // Compound types:\n-    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_enum_variant<F>(&mut self, v_name: &str,\n-                            v_id: uint,\n-                            len: uint,\n-                            f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n-                                   v_id: uint,\n-                                   len: uint,\n-                                   f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_enum_struct_variant_field<F>(&mut self,\n-                                         f_name: &str,\n-                                         f_idx: uint,\n-                                         f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    // Specialized types:\n-    fn emit_option<F>(&mut self, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_option_none(&mut self) -> Result<(), E>;\n-    fn emit_option_some<F>(&mut self, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnMut(&mut Self) -> Result<(), E>;\n-    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-}\n-\n-pub trait Decoder<E> {\n-    // Primitive types:\n-    fn read_nil(&mut self) -> Result<(), E>;\n-    fn read_uint(&mut self) -> Result<uint, E>;\n-    fn read_u64(&mut self) -> Result<u64, E>;\n-    fn read_u32(&mut self) -> Result<u32, E>;\n-    fn read_u16(&mut self) -> Result<u16, E>;\n-    fn read_u8(&mut self) -> Result<u8, E>;\n-    fn read_int(&mut self) -> Result<int, E>;\n-    fn read_i64(&mut self) -> Result<i64, E>;\n-    fn read_i32(&mut self) -> Result<i32, E>;\n-    fn read_i16(&mut self) -> Result<i16, E>;\n-    fn read_i8(&mut self) -> Result<i8, E>;\n-    fn read_bool(&mut self) -> Result<bool, E>;\n-    fn read_f64(&mut self) -> Result<f64, E>;\n-    fn read_f32(&mut self) -> Result<f32, E>;\n-    fn read_char(&mut self) -> Result<char, E>;\n-    fn read_str(&mut self) -> Result<String, E>;\n-\n-    // Compound types:\n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, uint) -> Result<T, E>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, uint) -> Result<T, E>;\n-    fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            &f_name: &str,\n-                                            f_idx: uint,\n-                                            f: F)\n-                                            -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_struct_field<T, F>(&mut self,\n-                               f_name: &str,\n-                               f_idx: uint,\n-                               f: F)\n-                               -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    // Specialized types:\n-    fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, bool) -> Result<T, E>;\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n-    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    // Failure\n-    fn error(&mut self, err: &str) -> E;\n-}\n-\n-pub trait Encodable<S:Encoder<E>, E> {\n-    fn encode(&self, s: &mut S) -> Result<(), E>;\n-}\n-\n-pub trait Decodable<D:Decoder<E>, E> {\n-    fn decode(d: &mut D) -> Result<Self, E>;\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for uint {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_uint(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for uint {\n-    fn decode(d: &mut D) -> Result<uint, E> {\n-        d.read_uint()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for u8 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_u8(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for u8 {\n-    fn decode(d: &mut D) -> Result<u8, E> {\n-        d.read_u8()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for u16 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_u16(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for u16 {\n-    fn decode(d: &mut D) -> Result<u16, E> {\n-        d.read_u16()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for u32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_u32(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for u32 {\n-    fn decode(d: &mut D) -> Result<u32, E> {\n-        d.read_u32()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for u64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_u64(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for u64 {\n-    fn decode(d: &mut D) -> Result<u64, E> {\n-        d.read_u64()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for int {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_int(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for int {\n-    fn decode(d: &mut D) -> Result<int, E> {\n-        d.read_int()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for i8 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_i8(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for i8 {\n-    fn decode(d: &mut D) -> Result<i8, E> {\n-        d.read_i8()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for i16 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_i16(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for i16 {\n-    fn decode(d: &mut D) -> Result<i16, E> {\n-        d.read_i16()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for i32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_i32(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for i32 {\n-    fn decode(d: &mut D) -> Result<i32, E> {\n-        d.read_i32()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for i64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_i64(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n-    fn decode(d: &mut D) -> Result<i64, E> {\n-        d.read_i64()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for str {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self)\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for String {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self.index(&FullRange))\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for String {\n-    fn decode(d: &mut D) -> Result<String, E> {\n-        d.read_str()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for f32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_f32(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for f32 {\n-    fn decode(d: &mut D) -> Result<f32, E> {\n-        d.read_f32()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for f64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_f64(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for f64 {\n-    fn decode(d: &mut D) -> Result<f64, E> {\n-        d.read_f64()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for bool {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_bool(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for bool {\n-    fn decode(d: &mut D) -> Result<bool, E> {\n-        d.read_bool()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for char {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_char(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for char {\n-    fn decode(d: &mut D) -> Result<char, E> {\n-        d.read_char()\n-    }\n-}\n-\n-impl<E, S:Encoder<E>> Encodable<S, E> for () {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_nil()\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for () {\n-    fn decode(d: &mut D) -> Result<(), E> {\n-        d.read_nil()\n-    }\n-}\n-\n-impl<'a, E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for &'a T {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for Box<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<T> {\n-    fn decode(d: &mut D) -> Result<Box<T>, E> {\n-        Ok(box try!(Decodable::decode(d)))\n-    }\n-}\n-\n-impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<[T]> {\n-    fn decode(d: &mut D) -> Result<Box<[T]>, E> {\n-        let v: Vec<T> = try!(Decodable::decode(d));\n-        Ok(v.into_boxed_slice())\n-    }\n-}\n-\n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n-    #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n-    #[inline]\n-    fn decode(d: &mut D) -> Result<Rc<T>, E> {\n-        Ok(Rc::new(try!(Decodable::decode(d))))\n-    }\n-}\n-\n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Vec<T> {\n-    fn decode(d: &mut D) -> Result<Vec<T>, E> {\n-        d.read_seq(|d, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for i in range(0, len) {\n-                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            Ok(v)\n-        })\n-    }\n-}\n-\n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Option<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_option(|s| {\n-            match *self {\n-                None => s.emit_option_none(),\n-                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n-            }\n-        })\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n-    fn decode(d: &mut D) -> Result<Option<T>, E> {\n-        d.read_option(|d, b| {\n-            if b {\n-                Ok(Some(try!(Decodable::decode(d))))\n-            } else {\n-                Ok(None)\n-            }\n-        })\n-    }\n-}\n-\n-macro_rules! peel {\n-    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n-}\n-\n-/// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n-macro_rules! count_idents {\n-    () => { 0u };\n-    ($_i:ident $(, $rest:ident)*) => { 1 + count_idents!($($rest),*) }\n-}\n-\n-macro_rules! tuple {\n-    () => ();\n-    ( $($name:ident,)+ ) => (\n-        impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n-            #[allow(non_snake_case)]\n-            fn decode(d: &mut D) -> Result<($($name,)*), E> {\n-                let len: uint = count_idents!($($name),*);\n-                d.read_tuple(len, |d| {\n-                    let mut i = 0;\n-                    let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name,E> {\n-                        Decodable::decode(d)\n-                    })),)*);\n-                    return Ok(ret);\n-                })\n-            }\n-        }\n-        impl<E, S:Encoder<E>,$($name:Encodable<S, E>),*> Encodable<S, E> for ($($name,)*) {\n-            #[allow(non_snake_case)]\n-            fn encode(&self, s: &mut S) -> Result<(), E> {\n-                let ($(ref $name,)*) = *self;\n-                let mut n = 0;\n-                $(let $name = $name; n += 1;)*\n-                s.emit_tuple(n, |s| {\n-                    let mut i = 0;\n-                    $(try!(s.emit_tuple_arg({ i+=1; i-1 }, |s| $name.encode(s)));)*\n-                    Ok(())\n-                })\n-            }\n-        }\n-        peel! { $($name,)* }\n-    )\n-}\n-\n-tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n-\n-impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n-    fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(path::posix::Path::new(bytes))\n-    }\n-}\n-\n-impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n-    fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(path::windows::Path::new(bytes))\n-    }\n-}\n-\n-impl<E, S: Encoder<E>, T: Encodable<S, E> + Copy> Encodable<S, E> for Cell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        self.get().encode(s)\n-    }\n-}\n-\n-impl<E, D: Decoder<E>, T: Decodable<D, E> + Copy> Decodable<D, E> for Cell<T> {\n-    fn decode(d: &mut D) -> Result<Cell<T>, E> {\n-        Ok(Cell::new(try!(Decodable::decode(d))))\n-    }\n-}\n-\n-// FIXME: #15036\n-// Should use `try_borrow`, returning a\n-// `encoder.error(\"attempting to Encode borrowed RefCell\")`\n-// from `encode` when `try_borrow` returns `None`.\n-\n-impl<E, S: Encoder<E>, T: Encodable<S, E>> Encodable<S, E> for RefCell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        self.borrow().encode(s)\n-    }\n-}\n-\n-impl<E, D: Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for RefCell<T> {\n-    fn decode(d: &mut D) -> Result<RefCell<T>, E> {\n-        Ok(RefCell::new(try!(Decodable::decode(d))))\n-    }\n-}\n-\n-impl<E, S:Encoder<E>, T:Encodable<S, E>> Encodable<S, E> for Arc<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n-    fn decode(d: &mut D) -> Result<Arc<T>, E> {\n-        Ok(Arc::new(try!(Decodable::decode(d))))\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-\n-pub trait EncoderHelpers<E> {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F) -> Result<(), E> where\n-        F: FnMut(&mut Self, &T) -> Result<(), E>;\n-}\n-\n-impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), E> where\n-        F: FnMut(&mut S, &T) -> Result<(), E>,\n-    {\n-        self.emit_seq(v.len(), |this| {\n-            for (i, e) in v.iter().enumerate() {\n-                try!(this.emit_seq_elt(i, |this| {\n-                    f(this, e)\n-                }));\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T, F>(&mut self, f: F) -> Result<Vec<T>, E> where\n-        F: FnMut(&mut Self) -> Result<T, E>;\n-}\n-\n-impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, E> where F:\n-        FnMut(&mut D) -> Result<T, E>,\n-    {\n-        self.read_seq(|this, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for i in range(0, len) {\n-                v.push(try!(this.read_seq_elt(i, |this| f(this))));\n-            }\n-            Ok(v)\n-        })\n-    }\n-}"}, {"sha": "e598923f11c36f738d8df0d292dfef0099b8f1d7", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -22,9 +22,6 @@ use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n-// NOTE: for old macros; remove after the next snapshot\n-#[cfg(stage0)] use result::Result::{Ok, Err};\n-\n use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n \n // Future Optimization (FIXME!)"}, {"sha": "74c503e6f2ba8e26c3d6defd7e4e3d2184a7cd7c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,9 +23,6 @@ use slice::{SliceExt};\n use slice;\n use vec::Vec;\n \n-// NOTE: for old macros; remove after the next snapshot\n-#[cfg(stage0)] use result::Result::Err;\n-\n /// Wraps a Reader and buffers input from it\n ///\n /// It can be excessively inefficient to work directly with a `Reader`. For"}, {"sha": "5de66c02b53f85cfd6df38a93bf10d992052fc63", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -285,8 +285,7 @@ pub mod stdio;\n pub mod timer;\n pub mod util;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod test;\n \n /// The default buffer size for various I/O operations"}, {"sha": "25cc574bb5db4faeab751c5c07a10e45b1d86d3a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -104,42 +104,24 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, linkage, thread_local, asm)]\n-#![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n+#![feature(linkage, thread_local, asm)]\n+#![feature(phase, lang_items, unsafe_destructor)]\n #![feature(slicing_syntax, unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n \n // Don't link to std. We are std.\n #![no_std]\n \n #![deny(missing_docs)]\n \n-#![reexport_test_harness_main = \"test_main\"]\n-\n-#[cfg(all(test, stage0))]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(all(test, not(stage0)))]\n+#[cfg(test)]\n #[macro_use]\n extern crate log;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate core;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n #[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n-    unreachable, unimplemented, write, writeln)]\n+                 unreachable, unimplemented, write, writeln)]\n extern crate core;\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate \"collections\" as core_collections;\n-\n-#[cfg(not(stage0))]\n #[macro_use]\n #[macro_reexport(vec)]\n extern crate \"collections\" as core_collections;\n@@ -190,18 +172,10 @@ pub use unicode::char;\n \n /* Exported macros */\n \n-#[cfg(stage0)]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n-pub mod macros_stage0;\n-\n-#[cfg(not(stage0))]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod macros;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod bitflags;\n \n mod rtdeps;\n@@ -214,18 +188,15 @@ pub mod prelude;\n /* Primitive types */\n \n #[path = \"num/float_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod float_macros;\n \n #[path = \"num/int_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod int_macros;\n \n #[path = \"num/uint_macros.rs\"]\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n@@ -253,8 +224,7 @@ pub mod num;\n \n /* Runtime and platform support */\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod thread_local;\n \n pub mod dynamic_lib;"}, {"sha": "48d62e73e13edeba26b4b7f7907dc6a23716bb65", "filename": "src/libstd/macros_stage0.rs", "status": "removed", "additions": 0, "deletions": 648, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fmacros_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09/src%2Flibstd%2Fmacros_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros_stage0.rs?ref=5c3ddcb15dc8b40fa780a38fd7494b9b5b991d09", "patch": "@@ -1,648 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Standard library macros\n-//!\n-//! This modules contains a set of macros which are exported from the standard\n-//! library. Each macro is available for use when linking against the standard\n-//! library.\n-\n-#![experimental]\n-\n-/// The entry point for panic of Rust tasks.\n-///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n-/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n-/// the value which is transmitted.\n-///\n-/// The multi-argument form of this macro panics with a string and has the\n-/// `format!` syntax for building a string.\n-///\n-/// # Example\n-///\n-/// ```should_fail\n-/// # #![allow(unreachable_code)]\n-/// panic!();\n-/// panic!(\"this is a terrible mistake!\");\n-/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n-/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n-/// ```\n-#[macro_export]\n-macro_rules! panic {\n-    () => ({\n-        panic!(\"explicit panic\")\n-    });\n-    ($msg:expr) => ({\n-        // static requires less code at runtime, more constant data\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        // The leading _'s are to avoid dead code warnings if this is\n-        // used inside a dead function. Just `#[allow(dead_code)]` is\n-        // insufficient, since the user may have\n-        // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n-        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n-\n-    });\n-}\n-\n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// assert!(true);\n-/// # fn some_computation() -> bool { true }\n-/// assert!(some_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! assert {\n-    ($cond:expr) => (\n-        if !$cond {\n-            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n-        }\n-    );\n-    ($cond:expr, $($arg:expr),+) => (\n-        if !$cond {\n-            panic!($($arg),+)\n-        }\n-    );\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! assert_eq {\n-    ($left:expr , $right:expr) => ({\n-        match (&($left), &($right)) {\n-            (left_val, right_val) => {\n-                // check both directions of equality....\n-                if !((*left_val == *right_val) &&\n-                     (*right_val == *left_val)) {\n-                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n-                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n-                }\n-            }\n-        }\n-    })\n-}\n-\n-/// Ensure that a boolean expression is `true` at runtime.\n-///\n-/// This will invoke the `panic!` macro if the provided expression cannot be\n-/// evaluated to `true` at runtime.\n-///\n-/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n-/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n-/// checks that are too expensive to be present in a release build but may be\n-/// helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// // the panic message for these assertions is the stringified value of the\n-/// // expression given.\n-/// debug_assert!(true);\n-/// # fn some_expensive_computation() -> bool { true }\n-/// debug_assert!(some_expensive_computation());\n-///\n-/// // assert with a custom message\n-/// # let x = true;\n-/// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n-/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n-}\n-\n-/// Asserts that two expressions are equal to each other, testing equality in\n-/// both directions.\n-///\n-/// On panic, this macro will print the values of the expressions.\n-///\n-/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n-/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n-/// useful for checks that are too expensive to be present in a release build\n-/// but may be helpful during development.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n-/// debug_assert_eq!(a, b);\n-/// ```\n-#[macro_export]\n-macro_rules! debug_assert_eq {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n-}\n-\n-/// A utility macro for indicating unreachable code.\n-///\n-/// This is useful any time that the compiler can't determine that some code is unreachable. For\n-/// example:\n-///\n-/// * Match arms with guard conditions.\n-/// * Loops that dynamically terminate.\n-/// * Iterators that dynamically terminate.\n-///\n-/// # Panics\n-///\n-/// This will always panic.\n-///\n-/// # Examples\n-///\n-/// Match arms:\n-///\n-/// ```rust\n-/// fn foo(x: Option<int>) {\n-///     match x {\n-///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n-///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n-///         Some(_)           => unreachable!(), // compile error if commented out\n-///         None              => println!(\"None\")\n-///     }\n-/// }\n-/// ```\n-///\n-/// Iterators:\n-///\n-/// ```rust\n-/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n-///     for i in std::iter::count(0_u32, 1) {\n-///         if 3*i < i { panic!(\"u32 overflow\"); }\n-///         if x < 3*i { return i-1; }\n-///     }\n-///     unreachable!();\n-/// }\n-/// ```\n-#[macro_export]\n-macro_rules! unreachable {\n-    () => ({\n-        panic!(\"internal error: entered unreachable code\")\n-    });\n-    ($msg:expr) => ({\n-        unreachable!(\"{}\", $msg)\n-    });\n-    ($fmt:expr, $($arg:tt)*) => ({\n-        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n-    });\n-}\n-\n-/// A standardised placeholder for marking unfinished code. It panics with the\n-/// message `\"not yet implemented\"` when executed.\n-#[macro_export]\n-macro_rules! unimplemented {\n-    () => (panic!(\"not yet implemented\"))\n-}\n-\n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// format!(\"test\");\n-/// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! format {\n-    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n-}\n-\n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n-}\n-\n-/// Equivalent to the `write!` macro, except that a newline is appended after\n-/// the message is written.\n-#[macro_export]\n-#[stable]\n-macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n-}\n-\n-/// Equivalent to the `println!` macro except that a newline is not printed at\n-/// the end of the message.\n-#[macro_export]\n-#[stable]\n-macro_rules! print {\n-    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n-}\n-\n-/// Macro for printing to a task's stdout handle.\n-///\n-/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n-/// The syntax of this macro is the same as that used for `format!`. For more\n-/// information, see `std::fmt` and `std::io::stdio`.\n-///\n-/// # Example\n-///\n-/// ```\n-/// println!(\"hello there!\");\n-/// println!(\"format {} arguments\", \"some\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! println {\n-    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n-}\n-\n-/// Helper macro for unwrapping `Result` values while returning early with an\n-/// error if the value of the expression is `Err`. For more information, see\n-/// `std::io`.\n-#[macro_export]\n-macro_rules! try {\n-    ($expr:expr) => ({\n-        match $expr {\n-            Ok(val) => val,\n-            Err(err) => return Err(::std::error::FromError::from_error(err))\n-        }\n-    })\n-}\n-\n-/// Create a `std::vec::Vec` containing the arguments.\n-#[macro_export]\n-macro_rules! vec {\n-    ($($x:expr),*) => ({\n-        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        ::std::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n-/// A macro to select an event from a number of receivers.\n-///\n-/// This macro is used to wait for the first event to occur on a number of\n-/// receivers. It places no restrictions on the types of receivers given to\n-/// this macro, this can be viewed as a heterogeneous select.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::thread::Thread;\n-/// use std::sync::mpsc::channel;\n-///\n-/// let (tx1, rx1) = channel();\n-/// let (tx2, rx2) = channel();\n-/// # fn long_running_task() {}\n-/// # fn calculate_the_answer() -> int { 42i }\n-///\n-/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n-/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n-///\n-/// select! (\n-///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n-///     answer = rx2.recv() => {\n-///         println!(\"the answer was: {}\", answer.unwrap());\n-///     }\n-/// )\n-/// ```\n-///\n-/// For more information about select, see the `std::sync::mpsc::Select` structure.\n-#[macro_export]\n-#[experimental]\n-macro_rules! select {\n-    (\n-        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n-    ) => ({\n-        use std::sync::mpsc::Select;\n-        let sel = Select::new();\n-        $( let mut $rx = sel.handle(&$rx); )+\n-        unsafe {\n-            $( $rx.add(); )+\n-        }\n-        let ret = sel.wait();\n-        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n-        { unreachable!() }\n-    })\n-}\n-\n-// When testing the standard library, we link to the liblog crate to get the\n-// logging macros. In doing so, the liblog crate was linked against the real\n-// version of libstd, and uses a different std::fmt module than the test crate\n-// uses. To get around this difference, we redefine the log!() macro here to be\n-// just a dumb version of what it should be.\n-#[cfg(test)]\n-macro_rules! log {\n-    ($lvl:expr, $($args:tt)*) => (\n-        if log_enabled!($lvl) { println!($($args)*) }\n-    )\n-}\n-\n-/// Built-in macros to the compiler itself.\n-///\n-/// These macros do not have any corresponding definition with a `macro_rules!`\n-/// macro, but are documented here. Their implementations can be found hardcoded\n-/// into libsyntax itself.\n-#[cfg(dox)]\n-pub mod builtin {\n-    /// The core macro for formatted string creation & output.\n-    ///\n-    /// This macro produces a value of type `fmt::Arguments`. This value can be\n-    /// passed to the functions in `std::fmt` for performing useful functions.\n-    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n-    /// proxied through this one.\n-    ///\n-    /// For more information, see the documentation in `std::fmt`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n-    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n-    ///\n-    /// ```\n-    #[macro_export]\n-    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n-        /* compiler built-in */\n-    }) }\n-\n-    /// Inspect an environment variable at compile time.\n-    ///\n-    /// This macro will expand to the value of the named environment variable at\n-    /// compile time, yielding an expression of type `&'static str`.\n-    ///\n-    /// If the environment variable is not defined, then a compilation error\n-    /// will be emitted.  To not emit a compile error, use the `option_env!`\n-    /// macro instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let path: &'static str = env!(\"PATH\");\n-    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n-\n-    /// Optionally inspect an environment variable at compile time.\n-    ///\n-    /// If the named environment variable is present at compile time, this will\n-    /// expand into an expression of type `Option<&'static str>` whose value is\n-    /// `Some` of the value of the environment variable. If the environment\n-    /// variable is not present, then this will expand to `None`.\n-    ///\n-    /// A compile time error is never emitted when using this macro regardless\n-    /// of whether the environment variable is present or not.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n-    /// println!(\"the secret key might be: {}\", key);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n-\n-    /// Concatenate literals into a static byte slice.\n-    ///\n-    /// This macro takes any number of comma-separated literal expressions,\n-    /// yielding an expression of type `&'static [u8]` which is the\n-    /// concatenation (left to right) of all the literals in their byte format.\n-    ///\n-    /// This extension currently only supports string literals, character\n-    /// literals, and integers less than 256. The byte slice returned is the\n-    /// utf8-encoding of strings and characters.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n-    /// assert_eq!(rust[1], b'u');\n-    /// assert_eq!(rust[4], 255);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n-\n-    /// Concatenate identifiers into one identifier.\n-    ///\n-    /// This macro takes any number of comma-separated identifiers, and\n-    /// concatenates them all into one, yielding an expression which is a new\n-    /// identifier. Note that hygiene makes it such that this macro cannot\n-    /// capture local variables, and macros are only allowed in item,\n-    /// statement or expression position, meaning this macro may be difficult to\n-    /// use in some situations.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(concat_idents)]\n-    ///\n-    /// # fn main() {\n-    /// fn foobar() -> int { 23 }\n-    ///\n-    /// let f = concat_idents!(foo, bar);\n-    /// println!(\"{}\", f());\n-    /// # }\n-    /// ```\n-    #[macro_export]\n-    macro_rules! concat_idents {\n-        ($($e:ident),*) => ({ /* compiler built-in */ })\n-    }\n-\n-    /// Concatenates literals into a static string slice.\n-    ///\n-    /// This macro takes any number of comma-separated literals, yielding an\n-    /// expression of type `&'static str` which represents all of the literals\n-    /// concatenated left-to-right.\n-    ///\n-    /// Integer and floating point literals are stringified in order to be\n-    /// concatenated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let s = concat!(\"test\", 10i, 'b', true);\n-    /// assert_eq!(s, \"test10btrue\");\n-    /// ```\n-    #[macro_export]\n-    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n-\n-    /// A macro which expands to the line number on which it was invoked.\n-    ///\n-    /// The expanded expression has type `uint`, and the returned line is not\n-    /// the invocation of the `line!()` macro itself, but rather the first macro\n-    /// invocation leading up to the invocation of the `line!()` macro.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let current_line = line!();\n-    /// println!(\"defined on line: {}\", current_line);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! line { () => ({ /* compiler built-in */ }) }\n-\n-    /// A macro which expands to the column number on which it was invoked.\n-    ///\n-    /// The expanded expression has type `uint`, and the returned column is not\n-    /// the invocation of the `column!()` macro itself, but rather the first macro\n-    /// invocation leading up to the invocation of the `column!()` macro.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let current_col = column!();\n-    /// println!(\"defined on column: {}\", current_col);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! column { () => ({ /* compiler built-in */ }) }\n-\n-    /// A macro which expands to the file name from which it was invoked.\n-    ///\n-    /// The expanded expression has type `&'static str`, and the returned file\n-    /// is not the invocation of the `file!()` macro itself, but rather the\n-    /// first macro invocation leading up to the invocation of the `file!()`\n-    /// macro.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let this_file = file!();\n-    /// println!(\"defined in file: {}\", this_file);\n-    /// ```\n-    #[macro_export]\n-    macro_rules! file { () => ({ /* compiler built-in */ }) }\n-\n-    /// A macro which stringifies its argument.\n-    ///\n-    /// This macro will yield an expression of type `&'static str` which is the\n-    /// stringification of all the tokens passed to the macro. No restrictions\n-    /// are placed on the syntax of the macro invocation itself.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let one_plus_one = stringify!(1 + 1);\n-    /// assert_eq!(one_plus_one, \"1 + 1\");\n-    /// ```\n-    #[macro_export]\n-    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n-\n-    /// Includes a utf8-encoded file as a string.\n-    ///\n-    /// This macro will yield an expression of type `&'static str` which is the\n-    /// contents of the filename specified. The file is located relative to the\n-    /// current file (similarly to how modules are found),\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust,ignore\n-    /// let secret_key = include_str!(\"secret-key.ascii\");\n-    /// ```\n-    #[macro_export]\n-    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n-\n-    /// Includes a file as a byte slice.\n-    ///\n-    /// This macro will yield an expression of type `&'static [u8]` which is\n-    /// the contents of the filename specified. The file is located relative to\n-    /// the current file (similarly to how modules are found),\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust,ignore\n-    /// let secret_key = include_bytes!(\"secret-key.bin\");\n-    /// ```\n-    #[macro_export]\n-    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n-\n-    /// Deprecated alias for `include_bytes!()`.\n-    #[macro_export]\n-    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */}) }\n-\n-    /// Expands to a string that represents the current module path.\n-    ///\n-    /// The current module path can be thought of as the hierarchy of modules\n-    /// leading back up to the crate root. The first component of the path\n-    /// returned is the name of the crate currently being compiled.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// mod test {\n-    ///     pub fn foo() {\n-    ///         assert!(module_path!().ends_with(\"test\"));\n-    ///     }\n-    /// }\n-    ///\n-    /// test::foo();\n-    /// ```\n-    #[macro_export]\n-    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n-\n-    /// Boolean evaluation of configuration flags.\n-    ///\n-    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n-    /// boolean expression evaluation of configuration flags. This frequently\n-    /// leads to less duplicated code.\n-    ///\n-    /// The syntax given to this macro is the same syntax as the `cfg`\n-    /// attribute.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let my_directory = if cfg!(windows) {\n-    ///     \"windows-specific-directory\"\n-    /// } else {\n-    ///     \"unix-directory\"\n-    /// };\n-    /// ```\n-    #[macro_export]\n-    macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n-}"}, {"sha": "b64da403c8be33bbf84bd337fcbdb6af76d3f7d9", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -28,9 +28,6 @@ mod imp {\n     use mem;\n     use os::errno;\n \n-    // NOTE: for old macros; remove after the next snapshot\n-    #[cfg(stage0)] use result::Result::Err;\n-\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n                   target_arch = \"x86\","}, {"sha": "2d54fc36ca873fc0ebc1dd3fcb739655465bea03", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -39,8 +39,7 @@ pub use alloc::heap;\n pub mod backtrace;\n \n // Internals\n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n mod macros;\n \n // These should be refactored/moved/made private over time"}, {"sha": "c11162c09bc64efc68baf9e41885e96e6796909d", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -40,8 +40,7 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod scoped;\n \n // Sure wish we had macro hygiene, no?"}, {"sha": "a651d927c1431fd601caedb5d73f566104accbfc", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -19,9 +19,6 @@ use option::Option::{Some, None};\n use num::Int;\n use result::Result::Ok;\n \n-// NOTE: for old macros; remove after the next snapshot\n-#[cfg(stage0)] use result::Result::Err;\n-\n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;\n /// The number of nanoseconds in a millisecond."}, {"sha": "45233dd522587250d8030a7dd86156c1600d2955", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -195,28 +195,12 @@ impl Name {\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n-#[cfg(stage0)]\n-impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(token::get_ident(*self).get())\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Encodable for Ident {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(token::get_ident(*self).get())\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D: Decoder<E>, E> Decodable<D, E> for Ident {\n-    fn decode(d: &mut D) -> Result<Ident, E> {\n-        Ok(str_to_ident(try!(d.read_str()).index(&FullRange)))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n         Ok(str_to_ident(try!(d.read_str()).index(&FullRange)))"}, {"sha": "31fe23847d9a8c412820ca399637f42c8d24d6a3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -120,30 +120,13 @@ impl PartialEq for Span {\n \n impl Eq for Span {}\n \n-#[cfg(stage0)]\n-impl<S:Encoder<E>, E> Encodable<S, E> for Span {\n-    /* Note #1972 -- spans are encoded but not decoded */\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_nil()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Encodable for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_nil()\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder<E>, E> Decodable<D, E> for Span {\n-    fn decode(_d: &mut D) -> Result<Span, E> {\n-        Ok(DUMMY_SP)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Decodable for Span {\n     fn decode<D: Decoder>(_d: &mut D) -> Result<Span, D::Error> {\n         Ok(DUMMY_SP)"}, {"sha": "50b3559f369fb2f33540ebccca3e7b2b384bb2eb", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -602,7 +602,7 @@ impl<'a> MethodDef<'a> {\n         };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc = &mut *f;\n-        f.call_mut((cx, trait_.span, &substructure))\n+        f(cx, trait_.span, &substructure)\n     }\n \n     fn get_ret_ty(&self,\n@@ -1365,8 +1365,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n             }\n         },\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f.call_mut((cx, trait_span, (all_args.index(&FullRange), tuple),\n-                                      substructure.nonself_args)),\n+            enum_nonmatch_f(cx, trait_span, (all_args.index(&FullRange), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")\n         }\n@@ -1405,8 +1405,8 @@ pub fn cs_same_method<F>(f: F,\n             f(cx, trait_span, called)\n         },\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f.call_mut((cx, trait_span, (all_self_args.index(&FullRange), tuple),\n-                                     substructure.nonself_args)),\n+            enum_nonmatch_f(cx, trait_span, (all_self_args.index(&FullRange), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")\n         }"}, {"sha": "43a0e0606f8bb421a25ec5385f6a7d0cfdecc2be", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -73,7 +73,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                     MetaWord(ref tname) => {\n                         macro_rules! expand {\n                             ($func:path) => ($func(cx, titem.span, &**titem, item,\n-                                                   |i| push.call_mut((i,))))\n+                                                   |i| push(i)))\n                         }\n \n                         match tname.get() {"}, {"sha": "38a369bdb57f450ff1e7ae584cb489879650c928", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -44,7 +44,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"non_ascii_idents\", Active),\n     (\"thread_local\", Active),\n     (\"link_args\", Active),\n-    (\"phase\", Active),  // NOTE(stage0): switch to Removed after next snapshot\n+    (\"phase\", Removed),\n     (\"plugin_registrar\", Active),\n     (\"log_syntax\", Active),\n     (\"trace_macros\", Active),"}, {"sha": "9e14f9dd1eaae3a0209539edd8e1df3ecb43c0fe", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -23,25 +23,15 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n+#![feature(slicing_syntax)]\n #![feature(quote, unsafe_destructor)]\n-#![feature(unboxed_closures)]\n-#![feature(old_orphan_check)]\n-#![feature(associated_types)]\n \n extern crate arena;\n extern crate fmt_macros;\n extern crate serialize;\n extern crate term;\n extern crate libc;\n-\n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[macro_use] extern crate log;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "707e540a17bfe7c51d5893d7bb9f0ab7d9d5a852", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -82,31 +82,12 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Encoder<E>, T: Encodable<S, E>, E> Encodable<S, E> for OwnedSlice<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-       self.as_slice().encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: Encodable> Encodable for OwnedSlice<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n        self.as_slice().encode(s)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D: Decoder<E>, T: Decodable<D, E>, E> Decodable<D, E> for OwnedSlice<T> {\n-    fn decode(d: &mut D) -> Result<OwnedSlice<T>, E> {\n-        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n-            Ok(t) => t,\n-            Err(e) => return Err(e)\n-        }))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: Decodable> Decodable for OwnedSlice<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<OwnedSlice<T>, D::Error> {\n         Ok(OwnedSlice::from_vec(match Decodable::decode(d) {"}, {"sha": "3335566801acb74f4fda3854dc99ba8de800e172", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -24,8 +24,7 @@ use std::num::Int;\n use std::str;\n use std::iter;\n \n-#[cfg_attr(stage0, macro_escape)]\n-#[cfg_attr(not(stage0), macro_use)]\n+#[macro_use]\n pub mod parser;\n \n pub mod lexer;"}, {"sha": "bdf9610469793e9fa5d8367b7d34e7cc523c8b17", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -684,29 +684,12 @@ impl<'a> PartialEq<InternedString > for &'a str {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n-    fn decode(d: &mut D) -> Result<InternedString, E> {\n-        Ok(get_name(get_ident_interner().intern(\n-                    try!(d.read_str()).index(&FullRange))))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n         Ok(get_name(get_ident_interner().intern(try!(d.read_str()).index(&FullRange))))\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self.string.index(&FullRange))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self.string.index(&FullRange))"}, {"sha": "8abb46011e65ce85b37f18248981d8cec7d34f2c", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -111,28 +111,12 @@ impl<S, T: Hash<S>> Hash<S> for P<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<E, D: Decoder<E>, T: 'static + Decodable<D, E>> Decodable<D, E> for P<T> {\n-    fn decode(d: &mut D) -> Result<P<T>, E> {\n-        Decodable::decode(d).map(P)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: 'static + Decodable> Decodable for P<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<E, S: Encoder<E>, T: Encodable<S, E>> Encodable<S, E> for P<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: Encodable> Encodable for P<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)"}, {"sha": "c953f591d805864b8993fd75d8095b915772fca6", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -48,17 +48,10 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax, globs)]\n-\n+#![feature(slicing_syntax)]\n #![deny(missing_docs)]\n \n-#[cfg(stage0)]\n-#[phase(plugin, link)]\n-extern crate log;\n-\n-#[cfg(not(stage0))]\n-#[macro_use]\n-extern crate log;\n+#[macro_use] extern crate log;\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]"}, {"sha": "a791221663031d92ec2e4ffbe75f9b18fd3fe2e5", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -30,11 +30,7 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(unknown_features)]\n-#![feature(asm, globs, slicing_syntax)]\n-#![feature(unboxed_closures, default_type_params)]\n-#![feature(old_orphan_check)]\n+#![feature(asm, slicing_syntax)]\n \n extern crate getopts;\n extern crate regex;"}, {"sha": "db98b429e40678bd4c140545cca1f3bca8e3fc6f", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -28,8 +28,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n-#![feature(globs, macro_rules, slicing_syntax, unboxed_closures)]\n-#![feature(associated_types)]\n+#![feature(slicing_syntax)]\n \n extern crate core;\n "}, {"sha": "d6134898cbdc8833c69392a798d283771d032f80", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e2f97f51ad4cf902e5a5835b5332447fe59089c4/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=e2f97f51ad4cf902e5a5835b5332447fe59089c4", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-06 340ac04\n+  freebsd-x86_64 5413b8931d7076e90c873e0cc7a43e0793c2b17a\n+  linux-i386 cacb8e3ad15937916e455d8f63e740c30a807b10\n+  linux-x86_64 e4a7f73959130671a5eb9107d593d37b43e571b0\n+  macos-i386 da6b0b7d12964e815175eb1fe5fc495098ca3125\n+  macos-x86_64 edf8a109e175be6e5bc44484261d2248946f1dd1\n+  winnt-i386 34fc7d9905d5845cdc7901f661d43a463534a20d\n+  winnt-x86_64 99580840f5763f517f47cd55ff373e4d116b018d\n+\n S 2015-01-04 b2085d9\n   freebsd-x86_64 50ccb6bf9c0645d0746a5167493a39b2be40c2d4\n   linux-i386 b880b98d832c9a049b8ef6a50df50061e363de5a"}]}