{"sha": "04b80a5f5d0ac06a49b7937362235f9a23513b0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YjgwYTVmNWQwYWMwNmE0OWI3OTM3MzYyMjM1ZjlhMjM1MTNiMGM=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-05T13:58:34Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-10T11:12:29Z"}, "message": "Drop length from Token::String\n\nIt was always set to the string's length", "tree": {"sha": "4c430d9bb0fad61cd33f9beeba15a34b8c4b507e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c430d9bb0fad61cd33f9beeba15a34b8c4b507e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b80a5f5d0ac06a49b7937362235f9a23513b0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b80a5f5d0ac06a49b7937362235f9a23513b0c", "html_url": "https://github.com/rust-lang/rust/commit/04b80a5f5d0ac06a49b7937362235f9a23513b0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b80a5f5d0ac06a49b7937362235f9a23513b0c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5879146392fc929bbcaa84fc7e3bcdeed284062e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5879146392fc929bbcaa84fc7e3bcdeed284062e", "html_url": "https://github.com/rust-lang/rust/commit/5879146392fc929bbcaa84fc7e3bcdeed284062e"}], "stats": {"total": 27, "additions": 15, "deletions": 12}, "files": [{"sha": "5e23288f55417d548b3347ea320b69ecb90896c5", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/04b80a5f5d0ac06a49b7937362235f9a23513b0c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b80a5f5d0ac06a49b7937362235f9a23513b0c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=04b80a5f5d0ac06a49b7937362235f9a23513b0c", "patch": "@@ -163,7 +163,7 @@ pub enum Token {\n     // In practice a string token contains either a `&'static str` or a\n     // `String`. `Cow` is overkill for this because we never modify the data,\n     // but it's more convenient than rolling our own more specialized type.\n-    String(Cow<'static, str>, isize),\n+    String(Cow<'static, str>),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -194,7 +194,7 @@ impl Token {\n impl fmt::Display for Token {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n+            Token::String(ref s) => write!(f, \"STR({},{})\", s, s.len()),\n             Token::Break(_) => f.write_str(\"BREAK\"),\n             Token::Begin(_) => f.write_str(\"BEGIN\"),\n             Token::End => f.write_str(\"END\"),\n@@ -358,16 +358,17 @@ impl Printer {\n         self.right_total += b.blank_space;\n     }\n \n-    fn scan_string(&mut self, s: Cow<'static, str>, len: isize) {\n+    fn scan_string(&mut self, s: Cow<'static, str>) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp String('{}')/print Vec<{},{}>\",\n                    s, self.left, self.right);\n-            self.print_string(s, len);\n+            self.print_string(s);\n         } else {\n             debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                    s, self.left, self.right);\n             self.advance_right();\n-            self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n+            let len = s.len() as isize;\n+            self.buf[self.right] = BufEntry { token: Token::String(s), size: len };\n             self.right_total += len;\n             self.check_stream();\n         }\n@@ -430,7 +431,8 @@ impl Printer {\n \n             let len = match left {\n                 Token::Break(b) => b.blank_space,\n-                Token::String(_, len) => {\n+                Token::String(ref s) => {\n+                    let len = s.len() as isize;\n                     assert_eq!(len, left_size);\n                     len\n                 }\n@@ -554,7 +556,8 @@ impl Printer {\n         }\n     }\n \n-    fn print_string(&mut self, s: Cow<'static, str>, len: isize) {\n+    fn print_string(&mut self, s: Cow<'static, str>) {\n+        let len = s.len() as isize;\n         debug!(\"print String({})\", s);\n         // assert!(len <= space);\n         self.space -= len;\n@@ -582,9 +585,10 @@ impl Printer {\n             Token::Begin(b) => self.print_begin(b, l),\n             Token::End => self.print_end(),\n             Token::Break(b) => self.print_break(b, l),\n-            Token::String(s, len) => {\n+            Token::String(s) => {\n+                let len = s.len() as isize;\n                 assert_eq!(len, l);\n-                self.print_string(s, len);\n+                self.print_string(s);\n             }\n             Token::Eof => panic!(), // Eof should never get here.\n         }\n@@ -628,8 +632,7 @@ impl Printer {\n \n     pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n         let s = wrd.into();\n-        let len = s.len() as isize;\n-        self.scan_string(s, len)\n+        self.scan_string(s)\n     }\n \n     fn spaces(&mut self, n: usize) {"}, {"sha": "e9cc89f95bbb9db7fc121cf986282d7975e846e1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04b80a5f5d0ac06a49b7937362235f9a23513b0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b80a5f5d0ac06a49b7937362235f9a23513b0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=04b80a5f5d0ac06a49b7937362235f9a23513b0c", "patch": "@@ -532,7 +532,7 @@ pub trait PrintState<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let twice = match self.writer().last_token() {\n-                    pp::Token::String(s, _) => \";\" == s,\n+                    pp::Token::String(s) => \";\" == s,\n                     pp::Token::Begin(_) => true,\n                     pp::Token::End => true,\n                     _ => false"}]}