{"sha": "ce4664956f98e55842c0fd3472c12c087b4532c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNDY2NDk1NmY5OGU1NTg0MmMwZmQzNDcyYzEyYzA4N2I0NTMyYzM=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-10-28T14:43:08Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-07T19:13:19Z"}, "message": "Clean up", "tree": {"sha": "7e27494437e5b4a888439f67896de491e8fd0143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e27494437e5b4a888439f67896de491e8fd0143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce4664956f98e55842c0fd3472c12c087b4532c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4664956f98e55842c0fd3472c12c087b4532c3", "html_url": "https://github.com/rust-lang/rust/commit/ce4664956f98e55842c0fd3472c12c087b4532c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce4664956f98e55842c0fd3472c12c087b4532c3/comments", "author": null, "committer": null, "parents": [{"sha": "0a843df26498e1270dc270174e2609ea47e9f44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a843df26498e1270dc270174e2609ea47e9f44c", "html_url": "https://github.com/rust-lang/rust/commit/0a843df26498e1270dc270174e2609ea47e9f44c"}], "stats": {"total": 58, "additions": 26, "deletions": 32}, "files": [{"sha": "19131a68d869d7f6c20ff6a5ea76fc85a44ff964", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ce4664956f98e55842c0fd3472c12c087b4532c3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4664956f98e55842c0fd3472c12c087b4532c3/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ce4664956f98e55842c0fd3472c12c087b4532c3", "patch": "@@ -878,18 +878,11 @@ fn cast_float_to_int(bcx: &Builder,\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n     fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128) {\n-        let f_min = if signed {\n-            let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n-            assert_eq!(rounded_min.status, Status::OK);\n-            rounded_min.value\n-        } else {\n-            F::ZERO\n-        };\n-\n+        let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n+        assert_eq!(rounded_min.status, Status::OK);\n         let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n         assert!(rounded_max.value.is_finite());\n-\n-        (f_min.to_bits(), rounded_max.value.to_bits())\n+        (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n     }\n     fn int_max(signed: bool, int_ty: Type) -> u128 {\n         let shift_amount = 128 - int_ty.int_width();\n@@ -906,11 +899,6 @@ fn cast_float_to_int(bcx: &Builder,\n             0\n         }\n     }\n-    let (f_min, f_max) = match float_ty.float_width() {\n-        32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n-        64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n-        n => bug!(\"unsupported float width {}\", n),\n-    };\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n             32 => C_u32(bcx.ccx, bits as u32),\n@@ -919,6 +907,11 @@ fn cast_float_to_int(bcx: &Builder,\n         };\n         consts::bitcast(bits_llval, float_ty)\n     };\n+    let (f_min, f_max) = match float_ty.float_width() {\n+        32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n+        64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n+        n => bug!(\"unsupported float width {}\", n),\n+    };\n     let f_min = float_bits_to_llval(f_min);\n     let f_max = float_bits_to_llval(f_max);\n     // To implement saturation, we perform the following steps:\n@@ -935,45 +928,46 @@ fn cast_float_to_int(bcx: &Builder,\n     // undef does not introduce any non-determinism either.\n     // More importantly, the above procedure correctly implements saturating conversion.\n     // Proof (sketch):\n-    // If x is NaN, 0 is trivially returned.\n+    // If x is NaN, 0 is returned by definition.\n     // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n     // This yields three cases to consider:\n     // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n     //     saturating conversion for inputs in that range.\n     // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n     //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n-    //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value is correct.\n+    //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value of int_ty::MAX\n+    //     is correct.\n     // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n-    //     int_ty::MIN and therefore the return value of int_ty::MIN is immediately correct.\n+    //     int_ty::MIN and therefore the return value of int_ty::MIN is correct.\n     // QED.\n \n     // Step 1 was already performed above.\n \n-    // Step 2: We use two comparisons and two selects, with s1 being the result:\n-    //     %less = fcmp ult %x, %f_min\n+    // Step 2: We use two comparisons and two selects, with %s1 being the result:\n+    //     %less_or_nan = fcmp ult %x, %f_min\n     //     %greater = fcmp olt %x, %f_max\n-    //     %s0 = select %less, int_ty::MIN, %fptosi_result\n+    //     %s0 = select %less_or_nan, int_ty::MIN, %fptosi_result\n     //     %s1 = select %greater, int_ty::MAX, %s0\n-    // Note that %less uses an *unordered* comparison. This comparison is true if the operands are\n-    // not comparable (i.e., if x is NaN). The unordered comparison ensures that s1 becomes\n-    // int_ty::MIN if x is NaN.\n-    // Performance note: It can be lowered to a flipped comparison and a negation (and the negation\n-    // can be merged into the select), so it not necessarily any more expensive than a ordered\n-    // (\"normal\") comparison. Whether these optimizations will be performed is ultimately up to the\n-    // backend but at least x86 does that.\n-    let less = bcx.fcmp(llvm::RealULT, x, f_min);\n+    // Note that %less_or_nan uses an *unordered* comparison. This comparison is true if the\n+    // operands are not comparable (i.e., if x is NaN). The unordered comparison ensures that s1\n+    // becomes int_ty::MIN if x is NaN.\n+    // Performance note: Unordered comparison can be lowered to a \"flipped\" comparison and a\n+    // negation, and the negation can be merged into the select. Therefore, it not necessarily any\n+    // more expensive than a ordered (\"normal\") comparison. Whether these optimizations will be\n+    // performed is ultimately up to the backend, but at least x86 does perform them.\n+    let less_or_nan = bcx.fcmp(llvm::RealULT, x, f_min);\n     let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n-    let int_max = C_big_integral(int_ty, int_max(signed, int_ty) as u128);\n+    let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n     let int_min = C_big_integral(int_ty, int_min(signed, int_ty) as u128);\n-    let s0 = bcx.select(less, int_min, fptosui_result);\n+    let s0 = bcx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bcx.select(greater, int_max, s0);\n \n     // Step 3: NaN replacement.\n     // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n     // Therefore we only need to execute this step for signed integer types.\n     if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), s1, C_big_integral(int_ty, 0))\n+        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), s1, C_uint(int_ty, 0))\n     } else {\n         s1\n     }"}]}