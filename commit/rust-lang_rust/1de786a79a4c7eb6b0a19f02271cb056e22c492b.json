{"sha": "1de786a79a4c7eb6b0a19f02271cb056e22c492b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZTc4NmE3OWE0YzdlYjZiMGExOWYwMjI3MWNiMDU2ZTIyYzQ5MmI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-05T16:02:37Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-07T00:04:06Z"}, "message": "Implement vertical alignment for comments after list structure", "tree": {"sha": "e3f40336e0250c0293bf2d20f13a55ebb830052a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3f40336e0250c0293bf2d20f13a55ebb830052a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1de786a79a4c7eb6b0a19f02271cb056e22c492b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1de786a79a4c7eb6b0a19f02271cb056e22c492b", "html_url": "https://github.com/rust-lang/rust/commit/1de786a79a4c7eb6b0a19f02271cb056e22c492b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1de786a79a4c7eb6b0a19f02271cb056e22c492b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dd8d6d097b52a34991cc032f94be4f03583d0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd8d6d097b52a34991cc032f94be4f03583d0e1", "html_url": "https://github.com/rust-lang/rust/commit/2dd8d6d097b52a34991cc032f94be4f03583d0e1"}], "stats": {"total": 138, "additions": 117, "deletions": 21}, "files": [{"sha": "b05983975174ebfbac85265c9bc65c62df69666d", "filename": "src/lists.rs", "status": "modified", "additions": 117, "deletions": 21, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1de786a79a4c7eb6b0a19f02271cb056e22c492b/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1de786a79a4c7eb6b0a19f02271cb056e22c492b/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=1de786a79a4c7eb6b0a19f02271cb056e22c492b", "patch": "@@ -17,7 +17,7 @@ use {Indent, Shape};\n use comment::{find_comment_end, rewrite_comment, FindUncommented};\n use config::{Config, IndentStyle};\n use rewrite::RewriteContext;\n-use utils::mk_sp;\n+use utils::{first_line_width, last_line_width, mk_sp};\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n /// Formatting tactic for lists. This will be cast down to a\n@@ -86,8 +86,12 @@ pub struct ListItem {\n }\n \n impl ListItem {\n+    pub fn inner_as_ref(&self) -> &str {\n+        self.item.as_ref().map_or(\"\", |s| &*s)\n+    }\n+\n     pub fn is_multiline(&self) -> bool {\n-        self.item.as_ref().map_or(false, |s| s.contains('\\n')) || self.pre_comment.is_some() ||\n+        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some() ||\n             self.post_comment\n                 .as_ref()\n                 .map_or(false, |s| s.contains('\\n'))\n@@ -167,7 +171,9 @@ where\n     // will be a trailing separator.\n     let trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n     let mut result = String::new();\n+    let cloned_items = items.clone();\n     let mut iter = items.into_iter().enumerate().peekable();\n+    let mut item_max_width: Option<usize> = None;\n \n     let mut line_len = 0;\n     let indent_str = &formatting.shape.indent.to_string(formatting.config);\n@@ -238,6 +244,7 @@ where\n             } else {\n                 result.push(' ');\n             }\n+            item_max_width = None;\n         }\n \n         result.push_str(&inner_item[..]);\n@@ -261,43 +268,132 @@ where\n         }\n \n         if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n-            // 1 = space between item and comment.\n-            let width = formatting\n-                .shape\n-                .width\n-                .checked_sub(item_last_line_width + 1)\n-                .unwrap_or(1);\n-            let mut offset = formatting.shape.indent;\n-            offset.alignment += item_last_line_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n-\n-            debug!(\"Width = {}, offset = {:?}\", width, offset);\n-            // Use block-style only for the last item or multiline comments.\n-            let block_style = !formatting.ends_with_newline && last ||\n-                comment.trim().contains('\\n') ||\n-                comment.trim().len() > width;\n-\n-            let formatted_comment = try_opt!(rewrite_comment(\n+            let block_style = !formatting.ends_with_newline && last;\n+            let mut formatted_comment = try_opt!(rewrite_post_comment(\n+                formatting.config,\n+                formatting.shape,\n                 comment,\n+                &cloned_items,\n+                inner_item,\n+                i,\n+                &mut item_max_width,\n+                item_last_line_width,\n+                last,\n                 block_style,\n-                Shape::legacy(width, offset),\n-                formatting.config,\n             ));\n \n             if !formatted_comment.starts_with('\\n') {\n-                result.push(' ');\n+                let mut comment_alignment =\n+                    post_comment_alignment(item_max_width, inner_item.len());\n+                if first_line_width(&formatted_comment) + last_line_width(&result) +\n+                    comment_alignment + 1 > formatting.config.max_width()\n+                {\n+                    item_max_width = None;\n+                    formatted_comment = try_opt!(rewrite_post_comment(\n+                        formatting.config,\n+                        formatting.shape,\n+                        comment,\n+                        &cloned_items,\n+                        inner_item,\n+                        i,\n+                        &mut item_max_width,\n+                        item_last_line_width,\n+                        last,\n+                        block_style,\n+                    ));\n+                    comment_alignment = post_comment_alignment(item_max_width, inner_item.len());\n+                }\n+                for _ in 0..(comment_alignment + 1) {\n+                    result.push(' ');\n+                }\n+                // An additional space for the missing trailing comma\n+                if last && item_max_width.is_some() && !separate {\n+                    result.push(' ');\n+                }\n+            }\n+            if formatted_comment.contains('\\n') {\n+                item_max_width = None;\n             }\n             result.push_str(&formatted_comment);\n+        } else {\n+            item_max_width = None;\n         }\n \n         if !last && tactic == DefinitiveListTactic::Vertical && item.new_lines {\n+            item_max_width = None;\n             result.push('\\n');\n         }\n     }\n \n     Some(result)\n }\n \n+fn rewrite_post_comment<I, T>(\n+    config: &Config,\n+    shape: Shape,\n+    comment: &str,\n+    cloned_items: &I,\n+    inner_item: &str,\n+    i: usize,\n+    mut item_max_width: &mut Option<usize>,\n+    item_last_line_width: usize,\n+    last: bool,\n+    block_style: bool,\n+) -> Option<String>\n+where\n+    I: IntoIterator<Item = T> + Clone,\n+    T: AsRef<ListItem>,\n+{\n+    if item_max_width.is_none() && !last && !inner_item.contains('\\n') {\n+        *item_max_width = Some(max_width_of_item_with_post_comment(cloned_items, i));\n+    }\n+    let overhead = if let &mut Some(max_width) = item_max_width {\n+        max_width + 2\n+    } else {\n+        // 1 = space between item and comment.\n+        item_last_line_width + 1\n+    };\n+    let width = shape.width.checked_sub(overhead).unwrap_or(1);\n+    let offset = shape.indent + overhead;\n+\n+    debug!(\"Width = {}, offset = {:?}\", width, offset);\n+    // Use block-style only for the last item or multiline comments.\n+    let block_style = block_style || comment.trim().contains('\\n') || comment.trim().len() > width;\n+\n+    rewrite_comment(comment, block_style, Shape::legacy(width, offset), config)\n+}\n+\n+fn max_width_of_item_with_post_comment<I, T>(items: &I, i: usize) -> usize\n+where\n+    I: IntoIterator<Item = T> + Clone,\n+    T: AsRef<ListItem>,\n+{\n+    let mut max_width = 0;\n+    let mut first = true;\n+    for item in items.clone().into_iter().skip(i) {\n+        let item = item.as_ref();\n+        if !first && (item.is_multiline() || !item.post_comment.is_some()) {\n+            return max_width;\n+        }\n+        let inner_item_width = item.inner_as_ref().len();\n+        if max_width < inner_item_width {\n+            max_width = inner_item_width;\n+        }\n+        if item.new_lines {\n+            return max_width;\n+        }\n+        first = false;\n+    }\n+    max_width\n+}\n+\n+fn post_comment_alignment(item_max_width: Option<usize>, inner_item_len: usize) -> usize {\n+    item_max_width\n+        .and_then(|max_line_width| max_line_width.checked_sub(inner_item_len))\n+        .unwrap_or(0)\n+}\n+\n pub struct ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator,"}]}