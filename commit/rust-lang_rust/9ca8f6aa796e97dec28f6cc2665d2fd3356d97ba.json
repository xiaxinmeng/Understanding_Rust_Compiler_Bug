{"sha": "9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYThmNmFhNzk2ZTk3ZGVjMjhmNmNjMjY2NWQyZmQzMzU2ZDk3YmE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-28T12:35:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-28T12:35:36Z"}, "message": "Rollup merge of #59320 - alexcrichton:wasm-clang, r=sanxiyn\n\nrustc: Allow using `clang` for wasm32 targets\n\nThis commit adds support code for using `clang` directly to link the\nwasm32-unknown-unknown target. Currently the target is only really\nconfigured to link with LLD directly, but this ensures that `clang` can\nbe configured as well.\n\nWhile not immediately useful in the near term it's likely that more\nwasm32 targets will pop up over time with Clang's new native support for\nWebAssembly in the 8.0.0 release. Getting support into rustc early\nshould make it easier to experiment with these targets and try out\nvarious changes here and there.", "tree": {"sha": "9abdb75936b6c2606c98db7b8fa876e3bebbd021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9abdb75936b6c2606c98db7b8fa876e3bebbd021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnL+ZCRBK7hj4Ov3rIwAAdHIIALEm3esWmDpbHggo27XJffiX\nXQmyFSZbLDiCklflNFd8LTIprDCBtr49w6DwALX30t1htOK2c+3koleQtfLXAeOw\nxcBB0uV0s7eipRuQWjyqlDIgm2a9/x2nkojVigG6YeQji4noPWl+glivS3c561/5\nQl1+jipXSZwDwcyRmEojiOJofgjAYsj2Qb04IzLvpQGUrm/69BXNSpaqXmFo+udL\n+zLHDF+KIjH3t9VAyUDNSiVTsc3KaAZAkDO91pSQzxF2SNMB1Pug16rf2je5TzRv\ngcq3fIGkDmHQj/SbAipY8ut7rh1CXCSAN+S2gM2Rmf7q4wmUSKXgMBddVYMIp6M=\n=nNrn\n-----END PGP SIGNATURE-----\n", "payload": "tree 9abdb75936b6c2606c98db7b8fa876e3bebbd021\nparent f6d2a3feb7ed7934e47b353dc91bd5e70c1dacdf\nparent 0e945411f2f54fdb3404b382844b9818ecc10b89\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553776536 +0100\ncommitter GitHub <noreply@github.com> 1553776536 +0100\n\nRollup merge of #59320 - alexcrichton:wasm-clang, r=sanxiyn\n\nrustc: Allow using `clang` for wasm32 targets\n\nThis commit adds support code for using `clang` directly to link the\nwasm32-unknown-unknown target. Currently the target is only really\nconfigured to link with LLD directly, but this ensures that `clang` can\nbe configured as well.\n\nWhile not immediately useful in the near term it's likely that more\nwasm32 targets will pop up over time with Clang's new native support for\nWebAssembly in the 8.0.0 release. Getting support into rustc early\nshould make it easier to experiment with these targets and try out\nvarious changes here and there.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "html_url": "https://github.com/rust-lang/rust/commit/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d2a3feb7ed7934e47b353dc91bd5e70c1dacdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d2a3feb7ed7934e47b353dc91bd5e70c1dacdf", "html_url": "https://github.com/rust-lang/rust/commit/f6d2a3feb7ed7934e47b353dc91bd5e70c1dacdf"}, {"sha": "0e945411f2f54fdb3404b382844b9818ecc10b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e945411f2f54fdb3404b382844b9818ecc10b89", "html_url": "https://github.com/rust-lang/rust/commit/0e945411f2f54fdb3404b382844b9818ecc10b89"}], "stats": {"total": 281, "additions": 174, "deletions": 107}, "files": [{"sha": "c99fc17dd89a18b80553b27720d8150aa6d776e1", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 21, "deletions": 56, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "patch": "@@ -160,7 +160,16 @@ impl<'a> GccLinker<'a> {\n     }\n \n     fn takes_hints(&self) -> bool {\n-        !self.sess.target.target.options.is_like_osx\n+        // Really this function only returns true if the underlying linker\n+        // configured for a compiler is binutils `ld.bfd` and `ld.gold`. We\n+        // don't really have a foolproof way to detect that, so rule out some\n+        // platforms where currently this is guaranteed to *not* be the case:\n+        //\n+        // * On OSX they have their own linker, not binutils'\n+        // * For WebAssembly the only functional linker is LLD, which doesn't\n+        //   support hint flags\n+        !self.sess.target.target.options.is_like_osx &&\n+            self.sess.target.target.arch != \"wasm32\"\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -375,6 +384,13 @@ impl<'a> Linker for GccLinker<'a> {\n             return\n         }\n \n+        // Symbol visibility takes care of this for the WebAssembly.\n+        // Additionally the only known linker, LLD, doesn't support the script\n+        // arguments just yet\n+        if self.sess.target.target.arch == \"wasm32\" {\n+            return;\n+        }\n+\n         let mut arg = OsString::new();\n         let path = tmpdir.join(\"list\");\n \n@@ -441,13 +457,13 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn group_start(&mut self) {\n-        if !self.sess.target.target.options.is_like_osx {\n+        if self.takes_hints() {\n             self.linker_arg(\"--start-group\");\n         }\n     }\n \n     fn group_end(&mut self) {\n-        if !self.sess.target.target.options.is_like_osx {\n+        if self.takes_hints() {\n             self.linker_arg(\"--end-group\");\n         }\n     }\n@@ -862,59 +878,7 @@ pub struct WasmLd<'a> {\n }\n \n impl<'a> WasmLd<'a> {\n-    fn new(mut cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n-        // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n-        // using threads causing weird hangs and bugs. Disable it entirely as\n-        // this isn't yet the bottleneck of compilation at all anyway.\n-        cmd.arg(\"--no-threads\");\n-\n-        // By default LLD only gives us one page of stack (64k) which is a\n-        // little small. Default to a larger stack closer to other PC platforms\n-        // (1MB) and users can always inject their own link-args to override this.\n-        cmd.arg(\"-z\").arg(\"stack-size=1048576\");\n-\n-        // By default LLD's memory layout is:\n-        //\n-        // 1. First, a blank page\n-        // 2. Next, all static data\n-        // 3. Finally, the main stack (which grows down)\n-        //\n-        // This has the unfortunate consequence that on stack overflows you\n-        // corrupt static data and can cause some exceedingly weird bugs. To\n-        // help detect this a little sooner we instead request that the stack is\n-        // placed before static data.\n-        //\n-        // This means that we'll generate slightly larger binaries as references\n-        // to static data will take more bytes in the ULEB128 encoding, but\n-        // stack overflow will be guaranteed to trap as it underflows instead of\n-        // corrupting static data.\n-        cmd.arg(\"--stack-first\");\n-\n-        // FIXME we probably shouldn't pass this but instead pass an explicit\n-        // whitelist of symbols we'll allow to be undefined. Unfortunately\n-        // though we can't handle symbols like `log10` that LLVM injects at a\n-        // super late date without actually parsing object files. For now let's\n-        // stick to this and hopefully fix it before stabilization happens.\n-        cmd.arg(\"--allow-undefined\");\n-\n-        // For now we just never have an entry symbol\n-        cmd.arg(\"--no-entry\");\n-\n-        // Rust code should never have warnings, and warnings are often\n-        // indicative of bugs, let's prevent them.\n-        cmd.arg(\"--fatal-warnings\");\n-\n-        // The symbol visibility story is a bit in flux right now with LLD.\n-        // It's... not entirely clear to me what's going on, but this looks to\n-        // make everything work when `export_symbols` isn't otherwise called for\n-        // things like executables.\n-        cmd.arg(\"--export-dynamic\");\n-\n-        // LLD only implements C++-like demangling, which doesn't match our own\n-        // mangling scheme. Tell LLD to not demangle anything and leave it up to\n-        // us to demangle these symbols later.\n-        cmd.arg(\"--no-demangle\");\n-\n+    fn new(cmd: Command, sess: &'a Session, info: &'a LinkerInfo) -> WasmLd<'a> {\n         WasmLd { cmd, sess, info }\n     }\n }\n@@ -1010,6 +974,7 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n \n     fn build_dylib(&mut self, _out_filename: &Path) {\n+        self.cmd.arg(\"--no-entry\");\n     }\n \n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {"}, {"sha": "401b81ee987234625f2968694704e94e34590e82", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "patch": "@@ -66,6 +66,7 @@ mod l4re_base;\n mod fuchsia_base;\n mod redox_base;\n mod riscv_base;\n+mod wasm32_base;\n \n #[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, Hash,\n          RustcEncodable, RustcDecodable)]"}, {"sha": "c7e75b4fa090377e058389e3a1aa20c98611b7d0", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "patch": "@@ -0,0 +1,123 @@\n+use std::collections::BTreeMap;\n+use super::{LldFlavor, TargetOptions, PanicStrategy, LinkerFlavor};\n+\n+pub fn options() -> TargetOptions {\n+    let mut lld_args = Vec::new();\n+    let mut clang_args = Vec::new();\n+    let mut arg = |arg: &str| {\n+        lld_args.push(arg.to_string());\n+        clang_args.push(format!(\"-Wl,{}\", arg));\n+    };\n+\n+    // There have been reports in the wild (rustwasm/wasm-bindgen#119) of\n+    // using threads causing weird hangs and bugs. Disable it entirely as\n+    // this isn't yet the bottleneck of compilation at all anyway.\n+    //\n+    // FIXME: we should file an upstream issue with LLD about this\n+    arg(\"--no-threads\");\n+\n+    // By default LLD only gives us one page of stack (64k) which is a\n+    // little small. Default to a larger stack closer to other PC platforms\n+    // (1MB) and users can always inject their own link-args to override this.\n+    arg(\"-z\");\n+    arg(\"stack-size=1048576\");\n+\n+    // By default LLD's memory layout is:\n+    //\n+    // 1. First, a blank page\n+    // 2. Next, all static data\n+    // 3. Finally, the main stack (which grows down)\n+    //\n+    // This has the unfortunate consequence that on stack overflows you\n+    // corrupt static data and can cause some exceedingly weird bugs. To\n+    // help detect this a little sooner we instead request that the stack is\n+    // placed before static data.\n+    //\n+    // This means that we'll generate slightly larger binaries as references\n+    // to static data will take more bytes in the ULEB128 encoding, but\n+    // stack overflow will be guaranteed to trap as it underflows instead of\n+    // corrupting static data.\n+    arg(\"--stack-first\");\n+\n+    // FIXME we probably shouldn't pass this but instead pass an explicit\n+    // whitelist of symbols we'll allow to be undefined. We don't currently have\n+    // a mechanism of knowing, however, which symbols are intended to be\n+    // imported from the environment and which are intended to be imported from\n+    // other objects linked elsewhere. This is a coarse approximation but is\n+    // sure to hide some bugs and frustrate someone at some point, so we should\n+    // ideally work towards a world where we can explicitly list symbols that\n+    // are supposed to be imported and have all other symbols generate errors if\n+    // they remain undefined.\n+    arg(\"--allow-undefined\");\n+\n+    // Rust code should never have warnings, and warnings are often\n+    // indicative of bugs, let's prevent them.\n+    arg(\"--fatal-warnings\");\n+\n+    // LLD only implements C++-like demangling, which doesn't match our own\n+    // mangling scheme. Tell LLD to not demangle anything and leave it up to\n+    // us to demangle these symbols later. Currently rustc does not perform\n+    // further demangling, but tools like twiggy and wasm-bindgen are intended\n+    // to do so.\n+    arg(\"--no-demangle\");\n+\n+    // The symbol visibility story is a bit in flux right now with LLD.\n+    // It's... not entirely clear to me what's going on, but this looks to\n+    // make everything work when `export_symbols` isn't otherwise called for\n+    // things like executables.\n+    //\n+    // This is really only here to get things working. If it can be removed and\n+    // basic tests still work, then sounds like it should be removed!\n+    arg(\"--export-dynamic\");\n+\n+    let mut pre_link_args = BTreeMap::new();\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Wasm), lld_args);\n+    pre_link_args.insert(LinkerFlavor::Gcc, clang_args);\n+\n+    TargetOptions {\n+        // we allow dynamic linking, but only cdylibs. Basically we allow a\n+        // final library artifact that exports some symbols (a wasm module) but\n+        // we don't allow intermediate `dylib` crate types\n+        dynamic_linking: true,\n+        only_cdylib: true,\n+\n+        // This means we'll just embed a `start` function in the wasm module\n+        executables: true,\n+\n+        // relatively self-explanatory!\n+        exe_suffix: \".wasm\".to_string(),\n+        dll_prefix: String::new(),\n+        dll_suffix: \".wasm\".to_string(),\n+        linker_is_gnu: false,\n+\n+        max_atomic_width: Some(64),\n+\n+        // Unwinding doesn't work right now, so the whole target unconditionally\n+        // defaults to panic=abort. Note that this is guaranteed to change in\n+        // the future once unwinding is implemented. Don't rely on this as we're\n+        // basically guaranteed to change it once WebAssembly supports\n+        // exceptions.\n+        panic_strategy: PanicStrategy::Abort,\n+\n+        // Wasm doesn't have atomics yet, so tell LLVM that we're in a single\n+        // threaded model which will legalize atomics to normal operations.\n+        singlethread: true,\n+\n+        // no dynamic linking, no need for default visibility!\n+        default_hidden_visibility: true,\n+\n+        // we use the LLD shipped with the Rust toolchain by default\n+        linker: Some(\"rust-lld\".to_owned()),\n+        lld_flavor: LldFlavor::Wasm,\n+\n+        // No need for indirection here, simd types can always be passed by\n+        // value as the whole module either has simd or not, which is different\n+        // from x86 (for example) where programs can have functions that don't\n+        // enable simd features.\n+        simd_types_indirect: false,\n+\n+        pre_link_args,\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "909527d2b612064d502c7e0bbf86fad4dd70bfcf", "filename": "src/librustc_target/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 29, "deletions": 51, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs?ref=9ca8f6aa796e97dec28f6cc2665d2fd3356d97ba", "patch": "@@ -1,70 +1,48 @@\n-// The wasm32-unknown-unknown target is currently an experimental version of a\n-// wasm-based target which does *not* use the Emscripten toolchain. Instead\n-// this toolchain is based purely on LLVM's own toolchain, using LLVM's native\n-// WebAssembly backend as well as LLD for a native linker.\n-//\n-// There's some trickery below on crate types supported and various defaults\n-// (aka panic=abort by default), but otherwise this is in general a relatively\n-// standard target.\n-\n-use super::{LldFlavor, LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+//! A \"bare wasm\" target representing a WebAssembly output that makes zero\n+//! assumptions about its environment.\n+//!\n+//! The `wasm32-unknown-unknown` target is intended to encapsulate use cases\n+//! that do not rely on any imported functionality. The binaries generated are\n+//! entirely self-contained by default when using the standard library. Although\n+//! the standard library is available, most of it returns an error immediately\n+//! (e.g. trying to create a TCP stream or something like that).\n+//!\n+//! This target is more or less managed by the Rust and WebAssembly Working\n+//! Group nowadays at https://github.com/rustwasm.\n+\n+use super::{LldFlavor, LinkerFlavor, Target};\n+use super::wasm32_base;\n \n pub fn target() -> Result<Target, String> {\n-    let opts = TargetOptions {\n-        // we allow dynamic linking, but only cdylibs. Basically we allow a\n-        // final library artifact that exports some symbols (a wasm module) but\n-        // we don't allow intermediate `dylib` crate types\n-        dynamic_linking: true,\n-        only_cdylib: true,\n-\n-        // This means we'll just embed a `start` function in the wasm module\n-        executables: true,\n-\n-        // relatively self-explanatory!\n-        exe_suffix: \".wasm\".to_string(),\n-        dll_prefix: String::new(),\n-        dll_suffix: \".wasm\".to_string(),\n-        linker_is_gnu: false,\n-\n-        max_atomic_width: Some(64),\n-\n-        // Unwinding doesn't work right now, so the whole target unconditionally\n-        // defaults to panic=abort. Note that this is guaranteed to change in\n-        // the future once unwinding is implemented. Don't rely on this.\n-        panic_strategy: PanicStrategy::Abort,\n-\n-        // Wasm doesn't have atomics yet, so tell LLVM that we're in a single\n-        // threaded model which will legalize atomics to normal operations.\n-        singlethread: true,\n+    let mut options = wasm32_base::options();\n+    let clang_args = options.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap();\n \n-        // no dynamic linking, no need for default visibility!\n-        default_hidden_visibility: true,\n+    // Make sure clang uses LLD as its linker and is configured appropriately\n+    // otherwise\n+    clang_args.push(\"--target=wasm32-unknown-unknown\".to_string());\n \n-        // we use the LLD shipped with the Rust toolchain by default\n-        linker: Some(\"rust-lld\".to_owned()),\n-        lld_flavor: LldFlavor::Wasm,\n+    // Disable attempting to link crt1.o since it typically isn't present and\n+    // isn't needed currently.\n+    clang_args.push(\"-nostdlib\".to_string());\n \n-        // No need for indirection here, simd types can always be passed by\n-        // value as the whole module either has simd or not, which is different\n-        // from x86 (for example) where programs can have functions that don't\n-        // enable simd features.\n-        simd_types_indirect: false,\n+    // For now this target just never has an entry symbol no matter the output\n+    // type, so unconditionally pass this.\n+    clang_args.push(\"-Wl,--no-entry\".to_string());\n+    options.pre_link_args.get_mut(&LinkerFlavor::Lld(LldFlavor::Wasm))\n+        .unwrap()\n+        .push(\"--no-entry\".to_string());\n \n-        .. Default::default()\n-    };\n     Ok(Target {\n         llvm_target: \"wasm32-unknown-unknown\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n         target_c_int_width: \"32\".to_string(),\n-        // This is basically guaranteed to change in the future, don't rely on\n-        // this. Use `not(target_os = \"emscripten\")` for now.\n         target_os: \"unknown\".to_string(),\n         target_env: String::new(),\n         target_vendor: \"unknown\".to_string(),\n         data_layout: \"e-m:e-p:32:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"wasm32\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Wasm),\n-        options: opts,\n+        options,\n     })\n }"}]}