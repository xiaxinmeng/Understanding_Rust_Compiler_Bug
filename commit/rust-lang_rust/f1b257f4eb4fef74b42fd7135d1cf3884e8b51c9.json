{"sha": "f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "node_id": "C_kwDOAAsO6NoAKGYxYjI1N2Y0ZWI0ZmVmNzRiNDJmZDcxMzVkMWNmMzg4NGU4YjUxYzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T20:12:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T20:12:21Z"}, "message": "Auto merge of #14041 - jonas-schievink:record-lit-signature-help, r=Veykril\n\nfeat: show signature help when typing record literal\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/13910\n\n![Screenshot_20230127_191848](https://user-images.githubusercontent.com/1786438/215165358-8e51cd1a-d7c3-4c9d-a2d8-c22638bcf500.png)", "tree": {"sha": "2f68b5c653f2be5d7035aaf8b2661da070f7f053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f68b5c653f2be5d7035aaf8b2661da070f7f053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "html_url": "https://github.com/rust-lang/rust/commit/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "261afbdd885973f3402a2e7ee7c5e000568b6cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/261afbdd885973f3402a2e7ee7c5e000568b6cc6", "html_url": "https://github.com/rust-lang/rust/commit/261afbdd885973f3402a2e7ee7c5e000568b6cc6"}, {"sha": "cad4cb38cdbf033fb5d7a6c726d86a15e2f4e436", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad4cb38cdbf033fb5d7a6c726d86a15e2f4e436", "html_url": "https://github.com/rust-lang/rust/commit/cad4cb38cdbf033fb5d7a6c726d86a15e2f4e436"}], "stats": {"total": 203, "additions": 196, "deletions": 7}, "files": [{"sha": "a666562f1010c2d02e23c6378be8422b51829aea", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 196, "deletions": 7, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=f1b257f4eb4fef74b42fd7135d1cf3884e8b51c9", "patch": "@@ -4,13 +4,15 @@\n use std::collections::BTreeSet;\n \n use either::Either;\n-use hir::{AssocItem, GenericParam, HasAttrs, HirDisplay, Semantics, Trait};\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n+use hir::{\n+    AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n+};\n+use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -37,14 +39,18 @@ impl SignatureHelp {\n     }\n \n     fn push_call_param(&mut self, param: &str) {\n-        self.push_param('(', param);\n+        self.push_param(\"(\", param);\n     }\n \n     fn push_generic_param(&mut self, param: &str) {\n-        self.push_param('<', param);\n+        self.push_param(\"<\", param);\n+    }\n+\n+    fn push_record_field(&mut self, param: &str) {\n+        self.push_param(\"{ \", param);\n     }\n \n-    fn push_param(&mut self, opening_delim: char, param: &str) {\n+    fn push_param(&mut self, opening_delim: &str, param: &str) {\n         if !self.signature.ends_with(opening_delim) {\n             self.signature.push_str(\", \");\n         }\n@@ -85,14 +91,23 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_generics(&sema, garg_list, token);\n                 },\n+                ast::RecordExpr(record) => {\n+                    let cursor_outside = record.record_expr_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_lit(&sema, record, token);\n+                },\n                 _ => (),\n             }\n         }\n \n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n') {\n+            if expr.syntax().text().contains_char('\\n')\n+                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            {\n                 return None;\n             }\n         }\n@@ -368,6 +383,86 @@ fn add_assoc_type_bindings(\n     }\n }\n \n+fn signature_help_for_record_lit(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordExpr,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let arg_list = record\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::RecordExpr::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let active_parameter = arg_list\n+        .record_expr_field_list()?\n+        .fields()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: Some(active_parameter),\n+    };\n+\n+    let fields;\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&record.path()?)?;\n+    if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        fields = variant.fields(db);\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} {{ \", en.name(db), variant.name(db));\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} {{ \", it.name(db));\n+            }\n+            hir::Adt::Union(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"union {} {{ \", it.name(db));\n+            }\n+            _ => return None,\n+        }\n+    }\n+\n+    let mut fields =\n+        fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n+    let mut buf = String::new();\n+    for field in record.record_expr_field_list()?.fields() {\n+        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+        let name = field.name(db);\n+        format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+\n+        if let Some(field) = fields.get_mut(&name) {\n+            *field = None;\n+        }\n+    }\n+    for (name, field) in fields {\n+        let Some(field) = field else { continue };\n+        format_to!(buf, \"{name}: {}\", field.ty(db).display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\" }\");\n+    Some(res)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -1405,4 +1500,98 @@ fn take<C, Error>(\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn record_literal() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_literal_nonexistent_field() {\n+        check(\n+            r#\"\n+struct Strukt {\n+    a: u8,\n+}\n+fn f() {\n+    Strukt {\n+        b: 8,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { a: u8 }\n+                                -----\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_variant_record_literal() {\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 ^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {0:0,$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 -----\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_literal_self() {\n+        check(\n+            r#\"\n+struct S { t: u8 }\n+impl S {\n+    fn new() -> Self {\n+        Self { $0 }\n+    }\n+}\n+        \"#,\n+            expect![[r#\"\n+                struct S { t: u8 }\n+                           ^^^^^\n+            \"#]],\n+        );\n+    }\n }"}]}