{"sha": "8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "node_id": "C_kwDOAAsO6NoAKDhlM2JiYWE1N2IxMjkwNGI4OGZmMTdmZmNhM2JjM2U0NGViZjc3MmM", "commit": {"author": {"name": "soruh", "email": "mail@soruh.de", "date": "2022-06-15T00:41:28Z"}, "committer": {"name": "soruh", "email": "mail@soruh.de", "date": "2022-06-15T00:41:28Z"}, "message": "instanciate_empty_structs", "tree": {"sha": "df0607122d27a41666882609eabfcf96789e02ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df0607122d27a41666882609eabfcf96789e02ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "html_url": "https://github.com/rust-lang/rust/commit/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c/comments", "author": {"login": "soruh", "id": 33131839, "node_id": "MDQ6VXNlcjMzMTMxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/33131839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soruh", "html_url": "https://github.com/soruh", "followers_url": "https://api.github.com/users/soruh/followers", "following_url": "https://api.github.com/users/soruh/following{/other_user}", "gists_url": "https://api.github.com/users/soruh/gists{/gist_id}", "starred_url": "https://api.github.com/users/soruh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soruh/subscriptions", "organizations_url": "https://api.github.com/users/soruh/orgs", "repos_url": "https://api.github.com/users/soruh/repos", "events_url": "https://api.github.com/users/soruh/events{/privacy}", "received_events_url": "https://api.github.com/users/soruh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "soruh", "id": 33131839, "node_id": "MDQ6VXNlcjMzMTMxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/33131839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soruh", "html_url": "https://github.com/soruh", "followers_url": "https://api.github.com/users/soruh/followers", "following_url": "https://api.github.com/users/soruh/following{/other_user}", "gists_url": "https://api.github.com/users/soruh/gists{/gist_id}", "starred_url": "https://api.github.com/users/soruh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soruh/subscriptions", "organizations_url": "https://api.github.com/users/soruh/orgs", "repos_url": "https://api.github.com/users/soruh/repos", "events_url": "https://api.github.com/users/soruh/events{/privacy}", "received_events_url": "https://api.github.com/users/soruh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65874dfff205335840cc9265ba06d74f234b719d", "url": "https://api.github.com/repos/rust-lang/rust/commits/65874dfff205335840cc9265ba06d74f234b719d", "html_url": "https://github.com/rust-lang/rust/commit/65874dfff205335840cc9265ba06d74f234b719d"}], "stats": {"total": 183, "additions": 179, "deletions": 4}, "files": [{"sha": "fc17c5626e1a861b74c11e3c99b224803f2a26b8", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "patch": "@@ -1,3 +1,4 @@\n+use ide_db::imports::import_assets::item_for_path_search;\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::ast::{self, AstNode, HasName, HasVisibility, StructKind};\n@@ -7,6 +8,58 @@ use crate::{\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n+// TODO: how to depupicate with `ide-diagnostics/mssing_fields`\n+pub fn use_trivial_constructor(\n+    db: &ide_db::RootDatabase,\n+    path: ast::Path,\n+    ty: &hir::Type,\n+) -> Option<ast::Expr> {\n+    match ty.as_adt() {\n+        Some(hir::Adt::Enum(x)) => {\n+            let variants = x.variants(db);\n+\n+            if variants.len() == 1 {\n+                let variant = variants[0];\n+\n+                if variant.fields(db).is_empty() {\n+                    let path = ast::make::path_qualified(\n+                        path,\n+                        syntax::ast::make::path_segment(ast::make::name_ref(\n+                            &variant.name(db).to_smol_str(),\n+                        )),\n+                    );\n+\n+                    use hir::StructKind::*;\n+                    let is_record = match variant.kind(db) {\n+                        Record => true,\n+                        Tuple => false,\n+                        Unit => false,\n+                    };\n+\n+                    return Some(if is_record {\n+                        ast::Expr::RecordExpr(syntax::ast::make::record_expr(\n+                            path,\n+                            ast::make::record_expr_field_list(std::iter::empty()),\n+                        ))\n+                    } else {\n+                        syntax::ast::make::expr_path(path)\n+                    });\n+                }\n+            }\n+        }\n+        Some(hir::Adt::Struct(x)) => {\n+            let fields = x.fields(db);\n+\n+            if fields.is_empty() {\n+                return Some(syntax::ast::make::expr_path(path));\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    None\n+}\n+\n // Assist: generate_new\n //\n // Adds a new inherent impl for a type.\n@@ -48,11 +101,54 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n         let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n \n+        let current_module = ctx.sema.scope(strukt.syntax()).unwrap().module();\n+\n+        let trivial_constructors = field_list\n+            .fields()\n+            .map(|f| {\n+                let ty = ctx.sema.resolve_type(&f.ty()?)?;\n+\n+                let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n+\n+                let type_path = current_module\n+                    .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+\n+                let expr = use_trivial_constructor(\n+                    &ctx.sema.db,\n+                    ide_db::helpers::mod_path_to_ast(&type_path),\n+                    &ty,\n+                )?;\n+\n+                Some(format!(\"{}: {}\", f.name()?.syntax(), expr))\n+            })\n+            .collect::<Vec<_>>();\n+\n+        dbg!(&trivial_constructors);\n+\n         let params = field_list\n             .fields()\n-            .filter_map(|f| Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax())))\n+            .enumerate()\n+            .filter_map(|(i, f)| {\n+                if trivial_constructors[i].is_none() {\n+                    Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax()))\n+                } else {\n+                    None\n+                }\n+            })\n+            .format(\", \");\n+\n+        let fields = field_list\n+            .fields()\n+            .enumerate()\n+            .filter_map(|(i, f)| {\n+                let contructor = trivial_constructors[i].clone();\n+                if contructor.is_some() {\n+                    contructor\n+                } else {\n+                    Some(f.name()?.to_string())\n+                }\n+            })\n             .format(\", \");\n-        let fields = field_list.fields().filter_map(|f| f.name()).format(\", \");\n \n         format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n "}, {"sha": "ff7d8de8fdc6ab75e4ecf40aa1f048f212e3b83c", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=8e3bbaa57b12904b88ff17ffca3bc3e44ebf772c", "patch": "@@ -3,7 +3,10 @@ use hir::{\n     db::{AstDatabase, HirDatabase},\n     known, AssocItem, HirDisplay, InFile, Type,\n };\n-use ide_db::{assists::Assist, famous_defs::FamousDefs, source_change::SourceChange, FxHashMap};\n+use ide_db::{\n+    assists::Assist, famous_defs::FamousDefs, imports::import_assets::item_for_path_search,\n+    source_change::SourceChange, FxHashMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n@@ -14,6 +17,58 @@ use text_edit::TextEdit;\n \n use crate::{fix, Diagnostic, DiagnosticsContext};\n \n+// TODO: how to depupicate with `ide-assists/generate_new`\n+pub fn use_trivial_constructor(\n+    db: &ide_db::RootDatabase,\n+    path: ast::Path,\n+    ty: &hir::Type,\n+) -> Option<ast::Expr> {\n+    match ty.as_adt() {\n+        Some(hir::Adt::Enum(x)) => {\n+            let variants = x.variants(db);\n+\n+            if variants.len() == 1 {\n+                let variant = variants[0];\n+\n+                if variant.fields(db).is_empty() {\n+                    let path = ast::make::path_qualified(\n+                        path,\n+                        syntax::ast::make::path_segment(ast::make::name_ref(\n+                            &variant.name(db).to_smol_str(),\n+                        )),\n+                    );\n+\n+                    use hir::StructKind::*;\n+                    let is_record = match variant.kind(db) {\n+                        Record => true,\n+                        Tuple => false,\n+                        Unit => false,\n+                    };\n+\n+                    return Some(if is_record {\n+                        ast::Expr::RecordExpr(syntax::ast::make::record_expr(\n+                            path,\n+                            ast::make::record_expr_field_list(std::iter::empty()),\n+                        ))\n+                    } else {\n+                        syntax::ast::make::expr_path(path)\n+                    });\n+                }\n+            }\n+        }\n+        Some(hir::Adt::Struct(x)) => {\n+            let fields = x.fields(db);\n+\n+            if fields.is_empty() {\n+                return Some(syntax::ast::make::expr_path(path));\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    None\n+}\n+\n // Diagnostic: missing-fields\n //\n // This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.\n@@ -55,6 +110,11 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n \n     let root = ctx.sema.db.parse_or_expand(d.file)?;\n \n+    let current_module = match &d.field_list_parent {\n+        Either::Left(ptr) => ctx.sema.scope(ptr.to_node(&root).syntax()).unwrap().module(),\n+        Either::Right(ptr) => ctx.sema.scope(ptr.to_node(&root).syntax()).unwrap().module(),\n+    };\n+\n     let build_text_edit = |parent_syntax, new_syntax: &SyntaxNode, old_syntax| {\n         let edit = {\n             let mut builder = TextEdit::builder();\n@@ -110,7 +170,26 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         Some(generate_fill_expr(ty))\n                     }\n                 } else {\n-                    Some(generate_fill_expr(ty))\n+                    let expr = (|| -> Option<ast::Expr> {\n+                        let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n+\n+                        let type_path = current_module.find_use_path(\n+                            ctx.sema.db,\n+                            item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                        )?;\n+\n+                        use_trivial_constructor(\n+                            &ctx.sema.db,\n+                            ide_db::helpers::mod_path_to_ast(&type_path),\n+                            &ty,\n+                        )\n+                    })();\n+\n+                    if expr.is_some() {\n+                        expr\n+                    } else {\n+                        Some(generate_fill_expr(ty))\n+                    }\n                 };\n                 let field = make::record_expr_field(\n                     make::name_ref(&f.name(ctx.sema.db).to_smol_str()),"}]}