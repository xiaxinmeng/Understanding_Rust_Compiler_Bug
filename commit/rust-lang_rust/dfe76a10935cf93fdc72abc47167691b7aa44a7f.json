{"sha": "dfe76a10935cf93fdc72abc47167691b7aa44a7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZTc2YTEwOTM1Y2Y5M2ZkYzcyYWJjNDcxNjc2OTFiN2FhNDRhN2Y=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-10-08T16:09:23Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-10-08T19:34:30Z"}, "message": "Split non-CAS atomic support off into target_has_atomic_load_store", "tree": {"sha": "55ae88ab33ff728145f86709b9527ba191069063", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55ae88ab33ff728145f86709b9527ba191069063"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfe76a10935cf93fdc72abc47167691b7aa44a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe76a10935cf93fdc72abc47167691b7aa44a7f", "html_url": "https://github.com/rust-lang/rust/commit/dfe76a10935cf93fdc72abc47167691b7aa44a7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfe76a10935cf93fdc72abc47167691b7aa44a7f/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59a31c8c676bdc9f50490d5798b1b4e884b7d7ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/59a31c8c676bdc9f50490d5798b1b4e884b7d7ae", "html_url": "https://github.com/rust-lang/rust/commit/59a31c8c676bdc9f50490d5798b1b4e884b7d7ae"}], "stats": {"total": 225, "additions": 127, "deletions": 98}, "files": [{"sha": "2e3b8f25adf31a354393cd65171d8d4ce7c0d380", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -154,7 +154,7 @@ mod boxed {\n #[cfg(test)]\n mod tests;\n pub mod collections;\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "19b13852c78ac96174c0104f2178a161cb89f597", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 92, "deletions": 70, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -113,8 +113,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n \n@@ -160,14 +160,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -177,14 +177,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -193,7 +193,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -202,10 +202,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -304,7 +304,7 @@ pub enum Ordering {\n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -313,7 +313,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -462,7 +462,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -500,7 +500,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -551,7 +551,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -607,7 +607,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -658,7 +658,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -700,7 +700,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -753,7 +753,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -794,13 +794,13 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -951,7 +951,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -987,7 +987,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1029,7 +1029,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1089,7 +1089,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1110,7 +1110,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1126,16 +1126,17 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n-    ($stable:meta,\n+    ($cfg_cas:meta,\n+     $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1356,7 +1357,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1396,7 +1397,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1454,7 +1455,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1506,7 +1507,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1544,7 +1545,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1576,7 +1577,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1611,7 +1612,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1647,7 +1648,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1682,7 +1683,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1717,7 +1718,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1767,7 +1768,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1828,7 +1829,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1880,7 +1881,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1890,8 +1891,9 @@ assert_eq!(min_foo, 12);\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1906,8 +1908,9 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1922,8 +1925,9 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1938,8 +1942,9 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1954,8 +1959,9 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1970,8 +1976,9 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1986,8 +1993,12 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2002,8 +2013,12 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2018,8 +2033,9 @@ atomic_int! {\n     \"AtomicU64::new(0)\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2034,8 +2050,9 @@ atomic_int! {\n     \"AtomicI128::new(0)\",\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2050,20 +2067,24 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2078,8 +2099,9 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2096,7 +2118,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -2130,7 +2152,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -2143,7 +2165,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -2156,7 +2178,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2168,7 +2190,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n@@ -2193,7 +2215,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2218,7 +2240,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2230,7 +2252,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2242,7 +2264,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2254,7 +2276,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2267,7 +2289,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2280,7 +2302,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2293,7 +2315,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2306,7 +2328,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),\n@@ -2504,23 +2526,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "e1b8e5fa1c74add9ce8191b69be087811747611a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -1514,22 +1514,25 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n-            let s = i.to_string();\n-            ret.insert((\n-                sym::target_has_atomic,\n-                Some(Symbol::intern(&s)),\n-            ));\n-            if &s == wordsz {\n+            let mut insert_atomic = |s| {\n                 ret.insert((\n-                    sym::target_has_atomic,\n-                    Some(Symbol::intern(\"ptr\")),\n+                    sym::target_has_atomic_load_store,\n+                    Some(Symbol::intern(s)),\n                 ));\n+                if atomic_cas {\n+                    ret.insert((\n+                        sym::target_has_atomic,\n+                        Some(Symbol::intern(s))\n+                    ));\n+                }\n+            };\n+            let s = i.to_string();\n+            insert_atomic(&s);\n+            if &s == wordsz {\n+              insert_atomic(\"ptr\");\n             }\n         }\n     }\n-    if atomic_cas {\n-        ret.insert((sym::target_has_atomic, Some(Symbol::intern(\"cas\"))));\n-    }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }"}, {"sha": "24c693790e84bcf239a57e3bff233604b595e36d", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -12,7 +12,9 @@ use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n use crate::ptr::{Unique, NonNull};\n use crate::rc::Rc;\n-use crate::sync::{Arc, Mutex, RwLock, atomic};\n+use crate::sync::{Arc, Mutex, RwLock};\n+#[cfg(not(bootstrap))]\n+use crate::sync::atomic;\n use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n@@ -240,49 +242,49 @@ impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicIsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI128 {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_hastarget_has_atomic_load_store_atomic = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU128 {}\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicBool {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n "}, {"sha": "b611351d5c4e17d4d4be427577a635fde30ed451", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -29,6 +29,7 @@ const GATED_CFGS: &[(Symbol, Symbol, GateFn)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n     (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n ];"}, {"sha": "5b060828812e581a1eb53886013d8ce2954222b8", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -658,6 +658,7 @@ symbols! {\n         suggestion,\n         target_feature,\n         target_has_atomic,\n+        target_has_atomic_load_store,\n         target_thread_local,\n         task,\n         tbm_target_feature,"}, {"sha": "9868fc1d41700ab5b1f66d2b80a5edf2614f4b9c", "filename": "src/test/run-make-fulldeps/target-without-atomic-cas/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/dfe76a10935cf93fdc72abc47167691b7aa44a7f/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile?ref=dfe76a10935cf93fdc72abc47167691b7aa44a7f", "patch": "@@ -2,4 +2,4 @@\n \n # The target used below doesn't support atomic CAS operations. Verify that's the case\n all:\n-\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"cas\"'\n+\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"ptr\"'"}]}