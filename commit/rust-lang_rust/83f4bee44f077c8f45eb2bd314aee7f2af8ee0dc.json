{"sha": "83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZjRiZWU0NGYwNzdjOGY0NWViMmJkMzE0YWVlN2YyYWY4ZWUwZGM=", "commit": {"author": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2013-08-07T18:48:10Z"}, "committer": {"name": "Florian Zeitz", "email": "florob@babelmonkeys.de", "date": "2013-08-21T09:50:07Z"}, "message": "Add Unicode decomposition mappings to std::unicode", "tree": {"sha": "613182897f6b20a1017c65cffe83ba35f6daffec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613182897f6b20a1017c65cffe83ba35f6daffec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "html_url": "https://github.com/rust-lang/rust/commit/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/comments", "author": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Florob", "id": 133684, "node_id": "MDQ6VXNlcjEzMzY4NA==", "avatar_url": "https://avatars.githubusercontent.com/u/133684?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Florob", "html_url": "https://github.com/Florob", "followers_url": "https://api.github.com/users/Florob/followers", "following_url": "https://api.github.com/users/Florob/following{/other_user}", "gists_url": "https://api.github.com/users/Florob/gists{/gist_id}", "starred_url": "https://api.github.com/users/Florob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Florob/subscriptions", "organizations_url": "https://api.github.com/users/Florob/orgs", "repos_url": "https://api.github.com/users/Florob/repos", "events_url": "https://api.github.com/users/Florob/events{/privacy}", "received_events_url": "https://api.github.com/users/Florob/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d856b129b7af6e78f1a04d6e942997559d06f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d856b129b7af6e78f1a04d6e942997559d06f8", "html_url": "https://github.com/rust-lang/rust/commit/d4d856b129b7af6e78f1a04d6e942997559d06f8"}], "stats": {"total": 2228, "additions": 2196, "deletions": 32}, "files": [{"sha": "48c14c0cd710837349dd5bff9a007d219f78f9d4", "filename": "src/etc/unicode.py", "status": "modified", "additions": 99, "deletions": 31, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "patch": "@@ -178,50 +178,118 @@ def emit_property_module_old(f, mod, tbl):\n         f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\")\n \n+def format_table_content(f, content, indent):\n+    line = \" \"*indent\n+    first = True\n+    for chunk in content.split(\",\"):\n+        if len(line) + len(chunk) < 98:\n+            if first:\n+                line += chunk\n+            else:\n+                line += \", \" + chunk\n+            first = False\n+        else:\n+            f.write(line + \",\\n\")\n+            line = \" \"*indent + chunk\n+    f.write(line)\n+\n def emit_decomp_module(f, canon, compat):\n     canon_keys = canon.keys()\n     canon_keys.sort()\n \n     compat_keys = compat.keys()\n     compat_keys.sort()\n-    f.write(\"mod decompose {\\n\\n\");\n-    f.write(\"    export canonical, compatibility;\\n\\n\")\n-    f.write(\"    fn canonical(c: char, i: block(char)) \"\n-            + \"{ d(c, i, false); }\\n\\n\")\n-    f.write(\"    fn compatibility(c: char, i: block(char)) \"\n+    f.write(\"pub mod decompose {\\n\");\n+    f.write(\"    use option::Option;\\n\");\n+    f.write(\"    use option::{Some, None};\\n\");\n+    f.write(\"    use vec::ImmutableVector;\\n\");\n+    f.write(\"\"\"\n+    fn bsearch_table(c: char, r: &'static [(char, &'static [char])]) -> Option<&'static [char]> {\n+        use cmp::{Equal, Less, Greater};\n+        match r.bsearch(|&(val, _)| {\n+            if c == val { Equal }\n+            else if val < c { Less }\n+            else { Greater }\n+        }) {\n+            Some(idx) => {\n+                let (_, result) = r[idx];\n+                Some(result)\n+            }\n+            None => None\n+        }\n+    }\\n\\n\n+\"\"\")\n+    f.write(\"    // Canonical decompositions\\n\")\n+    f.write(\"    static canonical_table : &'static [(char, &'static [char])] = &[\\n\")\n+    data = \"\"\n+    first = True\n+    for char in canon_keys:\n+        if not first:\n+            data += \",\"\n+        first = False\n+        data += \"(%s,&[\" % escape_char(char)\n+        first2 = True\n+        for d in canon[char]:\n+            if not first2:\n+                data += \",\"\n+            first2 = False\n+            data += escape_char(d)\n+        data += \"])\"\n+    format_table_content(f, data, 8)\n+    f.write(\"\\n    ];\\n\\n\")\n+    f.write(\"    // Compatibility decompositions\\n\")\n+    f.write(\"    static compatibility_table : &'static [(char, &'static [char])] = &[\\n\")\n+    data = \"\"\n+    first = True\n+    for char in compat_keys:\n+        if not first:\n+            data += \",\"\n+        first = False\n+        data += \"(%s,&[\" % escape_char(char)\n+        first2 = True\n+        for d in compat[char]:\n+            if not first2:\n+                data += \",\"\n+            first2 = False\n+            data += escape_char(d)\n+        data += \"])\"\n+    format_table_content(f, data, 8)\n+    f.write(\"\\n    ];\\n\\n\")\n+    f.write(\"    pub fn canonical(c: char, i: &fn(char)) \"\n+        + \"{ d(c, i, false); }\\n\\n\")\n+    f.write(\"    pub fn compatibility(c: char, i: &fn(char)) \"\n             +\"{ d(c, i, true); }\\n\\n\")\n-    f.write(\"    fn d(c: char, i: block(char), k: bool) {\\n\")\n+    f.write(\"    fn d(c: char, i: &fn(char), k: bool) {\\n\")\n+    f.write(\"        use iterator::Iterator;\\n\");\n \n-    f.write(\"        if c <= '\\\\x7f' { i(c); ret; }\\n\")\n+    f.write(\"        if c <= '\\\\x7f' { i(c); return; }\\n\")\n \n     # First check the canonical decompositions\n-    f.write(\"        // Canonical decomposition\\n\")\n-    f.write(\"        alt c {\\n\")\n-    for char in canon_keys:\n-        f.write(\"          %s {\\n\" % escape_char(char))\n-        for d in canon[char]:\n-            f.write(\"            d(%s, i, k);\\n\"\n-                    % escape_char(d))\n-        f.write(\"          }\\n\")\n-\n-    f.write(\"          _ { }\\n\")\n-    f.write(\"        }\\n\\n\")\n+    f.write(\"\"\"\n+        match bsearch_table(c, canonical_table) {\n+            Some(canon) => {\n+                for x in canon.iter() {\n+                    d(*x, |b| i(b), k);\n+                }\n+                return;\n+            }\n+            None => ()\n+        }\\n\\n\"\"\")\n \n     # Bottom out if we're not doing compat.\n-    f.write(\"        if !k { i(c); ret; }\\n\\n \")\n+    f.write(\"        if !k { i(c); return; }\\n\")\n \n     # Then check the compatibility decompositions\n-    f.write(\"        // Compatibility decomposition\\n\")\n-    f.write(\"        alt c {\\n\")\n-    for char in compat_keys:\n-        f.write(\"          %s {\\n\" % escape_char(char))\n-        for d in compat[char]:\n-            f.write(\"            d(%s, i, k);\\n\"\n-                    % escape_char(d))\n-        f.write(\"          }\\n\")\n-\n-    f.write(\"          _ { }\\n\")\n-    f.write(\"        }\\n\\n\")\n+    f.write(\"\"\"\n+        match bsearch_table(c, compatibility_table) {\n+            Some(compat) => {\n+                for x in compat.iter() {\n+                    d(*x, |b| i(b), k);\n+                }\n+                return;\n+            }\n+            None => ()\n+        }\\n\\n\"\"\")\n \n     # Finally bottom out.\n     f.write(\"        i(c);\\n\")\n@@ -256,7 +324,7 @@ def emit_decomp_module(f, canon, compat):\n \n emit_property_module(rf, \"general_category\", gencats)\n \n-#emit_decomp_module(rf, canon_decomp, compat_decomp)\n+emit_decomp_module(rf, canon_decomp, compat_decomp)\n \n derived = load_derived_core_properties(\"DerivedCoreProperties.txt\")\n emit_property_module(rf, \"derived_property\", derived)"}, {"sha": "e2612e0e09b46370c47b1bea5c4a917bc38c1fb6", "filename": "src/libstd/char.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc", "patch": "@@ -13,7 +13,7 @@\n use option::{None, Option, Some};\n use int;\n use str::StrSlice;\n-use unicode::{derived_property, general_category};\n+use unicode::{derived_property, general_category, decompose};\n \n #[cfg(test)] use str::OwnedStr;\n \n@@ -202,6 +202,51 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     }\n }\n \n+// Constants from Unicode 6.2.0 Section 3.12 Conjoining Jamo Behavior\n+static S_BASE: uint = 0xAC00;\n+static L_BASE: uint = 0x1100;\n+static V_BASE: uint = 0x1161;\n+static T_BASE: uint = 0x11A7;\n+static L_COUNT: uint = 19;\n+static V_COUNT: uint = 21;\n+static T_COUNT: uint = 28;\n+static N_COUNT: uint = (V_COUNT * T_COUNT);\n+static S_COUNT: uint = (L_COUNT * N_COUNT);\n+\n+// Decompose a precomposed Hangul syllable\n+fn decompose_hangul(s: char, f: &fn(char)) {\n+    let si = s as uint - S_BASE;\n+\n+    let li = si / N_COUNT;\n+    f((L_BASE + li) as char);\n+\n+    let vi = (si % N_COUNT) / T_COUNT;\n+    f((V_BASE + vi) as char);\n+\n+    let ti = si % T_COUNT;\n+    if ti > 0 {\n+        f((T_BASE + ti) as char);\n+    }\n+}\n+\n+/// Returns the canonical decompostion of a character\n+pub fn decompose_canonical(c: char, f: &fn(char)) {\n+    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n+        decompose::canonical(c, f);\n+    } else {\n+        decompose_hangul(c, f);\n+    }\n+}\n+\n+/// Returns the compatibility decompostion of a character\n+pub fn decompose_compatible(c: char, f: &fn(char)) {\n+    if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n+        decompose::compatibility(c, f);\n+    } else {\n+        decompose_hangul(c, f);\n+    }\n+}\n+\n ///\n /// Return the hexadecimal unicode escape of a char.\n ///"}, {"sha": "587b5a79838bc8194a95747e904de416fc80ed39", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 2051, "deletions": 0, "changes": 2051, "blob_url": "https://github.com/rust-lang/rust/blob/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=83f4bee44f077c8f45eb2bd314aee7f2af8ee0dc"}]}