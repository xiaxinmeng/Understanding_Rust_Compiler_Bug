{"sha": "ffc111889e93bcd38222d9d74a70fdc26a78fcb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYzExMTg4OWU5M2JjZDM4MjIyZDlkNzRhNzBmZGMyNmE3OGZjYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T21:07:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-12T21:07:19Z"}, "message": "auto merge of #19569 : murphm8/rust/ring_buf_insert, r=Gankro\n\nThis is a first pass at insert on RingBuf. I tried to keep it as simple as possible. I'm not sure of the performance implications of doing one copy vs. copying multiple times but moving a smaller amount of memory. I chose to stick with one copy, even if the amount of memory I have to move is larger.\r\n\r\nI believe this is part of #18424 \r\n\r\n@Gankro mentioned this was missing.", "tree": {"sha": "1bb8cdc9400a4a53c1c7f97e676efa4bbf69a0ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bb8cdc9400a4a53c1c7f97e676efa4bbf69a0ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffc111889e93bcd38222d9d74a70fdc26a78fcb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc111889e93bcd38222d9d74a70fdc26a78fcb5", "html_url": "https://github.com/rust-lang/rust/commit/ffc111889e93bcd38222d9d74a70fdc26a78fcb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffc111889e93bcd38222d9d74a70fdc26a78fcb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9146a919b616e39e528e4d7100d16eef52f1f852", "url": "https://api.github.com/repos/rust-lang/rust/commits/9146a919b616e39e528e4d7100d16eef52f1f852", "html_url": "https://github.com/rust-lang/rust/commit/9146a919b616e39e528e4d7100d16eef52f1f852"}, {"sha": "40f28c70d653d980521c31d5444485b39e12e75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/40f28c70d653d980521c31d5444485b39e12e75e", "html_url": "https://github.com/rust-lang/rust/commit/40f28c70d653d980521c31d5444485b39e12e75e"}], "stats": {"total": 268, "additions": 267, "deletions": 1}, "files": [{"sha": "6f396f539403f08782784e3f8b35b0d67558c83f", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 267, "deletions": 1, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/ffc111889e93bcd38222d9d74a70fdc26a78fcb5/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffc111889e93bcd38222d9d74a70fdc26a78fcb5/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=ffc111889e93bcd38222d9d74a70fdc26a78fcb5", "patch": "@@ -99,6 +99,21 @@ impl<T> RingBuf<T> {\n     /// Returns the index in the underlying buffer for a given logical element index.\n     #[inline]\n     fn wrap_index(&self, idx: uint) -> uint { wrap_index(idx, self.cap) }\n+\n+    /// Copies a contiguous block of memory len long from src to dst\n+    #[inline]\n+    fn copy(&self, dst: uint, src: uint, len: uint) {\n+        unsafe {\n+            debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                          self.cap);\n+            debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                          self.cap);\n+            ptr::copy_memory(\n+                self.ptr.offset(dst as int),\n+                self.ptr.offset(src as int) as *const T,\n+                len);\n+        }\n+    }\n }\n \n impl<T> RingBuf<T> {\n@@ -648,6 +663,213 @@ impl<T> RingBuf<T> {\n             unsafe { Some(self.buffer_read(head)) }\n         }\n     }\n+\n+    /// Inserts an element at position `i` within the ringbuf. Whichever\n+    /// end is closer to the insertion point will be moved to make room,\n+    /// and all the affected elements will be moved to new positions.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `i` is greater than ringbuf's length\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(10i);\n+    /// buf.push_back(12);\n+    /// buf.insert(1,11);\n+    /// assert_eq!(Some(&11), buf.get(1));\n+    /// ```\n+    pub fn insert(&mut self, i: uint, t: T) {\n+        assert!(i <= self.len(), \"index out of bounds\");\n+        if self.is_full() {\n+            self.reserve(1);\n+            debug_assert!(!self.is_full());\n+        }\n+\n+        // Move the least number of elements in the ring buffer and insert\n+        // the given object\n+        //\n+        // At most len/2 - 1 elements will be moved. O(min(n, n-i))\n+        //\n+        // There are three main cases:\n+        //  Elements are contiguous\n+        //      - special case when tail is 0\n+        //  Elements are discontiguous and the insert is in the tail section\n+        //  Elements are discontiguous and the insert is in the head section\n+        //\n+        // For each of those there are two more cases:\n+        //  Insert is closer to tail\n+        //  Insert is closer to head\n+        //\n+        // Key: H - self.head\n+        //      T - self.tail\n+        //      o - Valid element\n+        //      I - Insertion element\n+        //      A - The element that should be after the insertion point\n+        //      M - Indicates element was moved\n+\n+        let idx = self.wrap_index(self.tail + i);\n+\n+        let distance_to_tail = i;\n+        let distance_to_head = self.len() - i;\n+\n+        let contiguous = self.tail <= self.head;\n+\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+            (true, true, _) if i == 0 => {\n+                // push_front\n+                //\n+                //       T\n+                //       I             H\n+                //      [A o o o o o o . . . . . . . . .]\n+                //\n+                //                       H         T\n+                //      [A o o o o o o o . . . . . I]\n+                //\n+\n+                self.tail = self.wrap_index(self.tail - 1);\n+            },\n+            (true, true, _) => {\n+                // contiguous, insert closer to tail:\n+                //\n+                //             T   I         H\n+                //      [. . . o o A o o o o . . . . . .]\n+                //\n+                //           T               H\n+                //      [. . o o I A o o o o . . . . . .]\n+                //           M M\n+                //\n+                // contiguous, insert closer to tail and tail is 0:\n+                //\n+                //\n+                //       T   I         H\n+                //      [o o A o o o o . . . . . . . . .]\n+                //\n+                //                       H             T\n+                //      [o I A o o o o o . . . . . . . o]\n+                //       M                             M\n+\n+                let old_tail = self.tail;\n+                self.tail = self.wrap_index(self.tail - 1);\n+\n+                self.copy(self.tail, old_tail, 1);\n+                self.copy(old_tail, old_tail + 1, i);\n+            },\n+            (true, false, _) => {\n+                //  contiguous, insert closer to head:\n+                //\n+                //             T       I     H\n+                //      [. . . o o o o A o o . . . . . .]\n+                //\n+                //             T               H\n+                //      [. . . o o o o I A o o . . . . .]\n+                //                       M M M\n+\n+                let old_head = self.head;\n+                self.head = self.wrap_index(self.head + 1);\n+                self.copy(idx + 1, idx, old_head - idx);\n+            },\n+            (false, true, true) => {\n+                // discontiguous, tail section, insert closer to tail:\n+                //\n+                //                   H         T   I\n+                //      [o o o o o o . . . . . o o A o o]\n+                //\n+                //                   H       T\n+                //      [o o o o o o . . . . o o I A o o]\n+                //                           M M\n+\n+                let old_tail = self.tail;\n+                self.tail = self.tail - 1;\n+                self.copy(self.tail, old_tail, i);\n+            },\n+            (false, false, true) => {\n+                // discontiguous, tail section, insert closer to head:\n+                //\n+                //           H             T         I\n+                //      [o o . . . . . . . o o o o o A o]\n+                //\n+                //             H           T\n+                //      [o o o . . . . . . o o o o o I A]\n+                //       M M M                         M\n+\n+                let old_head = self.head;\n+                self.head = self.head + 1;\n+\n+                // copy elements up to new head\n+                self.copy(1, 0, old_head);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(0, self.cap - 1, 1);\n+\n+                // move elements from idx to end forward not including ^ element\n+                self.copy(idx + 1, idx, self.cap - 1 - idx);\n+            },\n+            (false, true, false) if idx == 0 => {\n+                // discontiguous, head section, insert is closer to tail,\n+                // and is at index zero in the internal buffer:\n+                //\n+                //       I                   H     T\n+                //      [A o o o o o o o o o . . . o o o]\n+                //\n+                //                           H   T\n+                //      [A o o o o o o o o o . . o o o I]\n+                //                               M M M\n+\n+                let old_tail = self.tail;\n+                self.tail = self.tail - 1;\n+                // copy elements up to new tail\n+                self.copy(old_tail - 1, old_tail, i);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(self.cap - 1, 0, 1);\n+            },\n+            (false, true, false) => {\n+                // discontiguous, head section, insert closer to tail:\n+                //\n+                //             I             H     T\n+                //      [o o o A o o o o o o . . . o o o]\n+                //\n+                //                           H   T\n+                //      [o o I A o o o o o o . . o o o o]\n+                //       M M                     M M M M\n+\n+                let old_tail = self.tail;\n+                self.tail = self.tail - 1;\n+                // copy elements up to new tail\n+                self.copy(old_tail - 1, old_tail, i);\n+\n+                // copy last element into empty spot at bottom of buffer\n+                self.copy(self.cap - 1, 0, 1);\n+\n+                // move elements from idx-1 to end forward not including ^ element\n+                self.copy(0, 1, idx - 1);\n+            }\n+            (false, false, false) => {\n+                // discontiguous, head section, insert closer to head:\n+                //\n+                //               I     H           T\n+                //      [o o o o A o o . . . . . . o o o]\n+                //\n+                //                     H           T\n+                //      [o o o o I A o o . . . . . o o o]\n+                //                 M M M\n+\n+                let old_head = self.head;\n+                self.head = self.head + 1;\n+                self.copy(idx + 1, idx, old_head - idx);\n+            }\n+        }\n+\n+        // tail might've been changed so we need to recalculate\n+        let new_idx = self.wrap_index(self.tail + i);\n+        unsafe {\n+            self.buffer_write(new_idx, t);\n+        }\n+    }\n }\n \n /// Returns the index in the underlying buffer for a given logical element index.\n@@ -878,6 +1100,7 @@ impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n \n #[cfg(test)]\n mod tests {\n+    use core::iter;\n     use self::Taggy::*;\n     use self::Taggypar::*;\n     use std::fmt::Show;\n@@ -1102,7 +1325,6 @@ mod tests {\n         })\n     }\n \n-\n     #[deriving(Clone, PartialEq, Show)]\n     enum Taggy {\n         One(int),\n@@ -1666,4 +1888,48 @@ mod tests {\n         assert_eq!(ring.get_mut(1), Some(&mut 2));\n         assert_eq!(ring.get_mut(2), None);\n     }\n+\n+    #[test]\n+    fn test_insert() {\n+        // This test checks that every single combination of tail position, length, and\n+        // insertion position is tested. Capacity 7 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(7);\n+        // can't guarantee we got 7, so have to get what we got.\n+        // 7 would be great, but we will definitely get 2^k - 1, for k >= 3, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+\n+        // len is the length *after* insertion\n+        for len in range(1, cap) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, cap) {\n+                for to_insert in range(0, len) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in range(0, len) {\n+                        if i != to_insert {\n+                            tester.push_back(i);\n+                        }\n+                    }\n+                    tester.insert(to_insert, to_insert);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_front() {\n+        let mut ring = RingBuf::new();\n+        ring.push_back(10i);\n+        ring.push_back(20i);\n+        assert_eq!(ring.front(), Some(&10));\n+        ring.pop_front();\n+        assert_eq!(ring.front(), Some(&20));\n+        ring.pop_front();\n+        assert_eq!(ring.front(), None);\n+    }\n }"}]}