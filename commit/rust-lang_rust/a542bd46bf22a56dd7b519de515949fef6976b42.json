{"sha": "a542bd46bf22a56dd7b519de515949fef6976b42", "node_id": "C_kwDOAAsO6NoAKGE1NDJiZDQ2YmYyMmE1NmRkN2I1MTlkZTUxNTk0OWZlZjY5NzZiNDI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-20T15:30:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-20T15:30:08Z"}, "message": "Split out some hover functions", "tree": {"sha": "820e9a99622726329410db202a94777f3b84ca01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/820e9a99622726329410db202a94777f3b84ca01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a542bd46bf22a56dd7b519de515949fef6976b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a542bd46bf22a56dd7b519de515949fef6976b42", "html_url": "https://github.com/rust-lang/rust/commit/a542bd46bf22a56dd7b519de515949fef6976b42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a542bd46bf22a56dd7b519de515949fef6976b42/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5b1e3f2ae5c397eb98d86228186a8e533243bfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b1e3f2ae5c397eb98d86228186a8e533243bfe", "html_url": "https://github.com/rust-lang/rust/commit/c5b1e3f2ae5c397eb98d86228186a8e533243bfe"}], "stats": {"total": 310, "additions": 230, "deletions": 80}, "files": [{"sha": "4a76ac9320d08d8eae328bec71470523761e35c6", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 61, "deletions": 51, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=a542bd46bf22a56dd7b519de515949fef6976b42", "patch": "@@ -86,30 +86,38 @@ pub struct HoverResult {\n // image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]\n pub(crate) fn hover(\n     db: &RootDatabase,\n-    file_range: FileRange,\n+    frange @ FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     let sema = &hir::Semantics::new(db);\n-    let mut res = hover_impl(sema, file_range, config)?;\n+    let file = sema.parse(file_id).syntax().clone();\n+    let mut res = if range.is_empty() {\n+        hover_simple(sema, FilePosition { file_id, offset: range.start() }, file, config)\n+    } else {\n+        hover_ranged(sema, frange, file, config)\n+    }?;\n+\n     if let HoverDocFormat::PlainText = config.format {\n         res.info.markup = remove_markdown(res.info.markup.as_str()).into();\n     }\n     Some(res)\n }\n \n-fn hover_impl(\n+fn hover_simple(\n     sema: &Semantics<'_, RootDatabase>,\n-    FileRange { file_id, range }: FileRange,\n+    FilePosition { file_id, offset }: FilePosition,\n+    file: SyntaxNode,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let file = sema.parse(file_id).syntax().clone();\n-    if !range.is_empty() {\n-        return hover_ranged(&file, range, sema, config);\n-    }\n-    let offset = range.start();\n-\n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        IDENT\n+        | INT_NUMBER\n+        | LIFETIME_IDENT\n+        | T![self]\n+        | T![super]\n+        | T![crate]\n+        | T![Self]\n+        | T![_] => 4,\n         // index and prefix ops\n         T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n         kind if kind.is_keyword() => 2,\n@@ -142,19 +150,18 @@ fn hover_impl(\n     } else {\n         sema.descend_into_macros_with_same_text(original_token.clone())\n     };\n+    let descended = || descended.iter();\n \n-    // try lint hover\n-    let result = descended\n-        .iter()\n+    let result = descended()\n+        // try lint hover\n         .find_map(|token| {\n             // FIXME: Definition should include known lints and the like instead of having this special case here\n             let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;\n             render::try_for_lint(&attr, token)\n         })\n-        // try item definitions\n+        // try definitions\n         .or_else(|| {\n-            descended\n-                .iter()\n+            descended()\n                 .filter_map(|token| {\n                     let node = token.parent()?;\n                     let class = IdentClass::classify_token(sema, token)?;\n@@ -175,10 +182,12 @@ fn hover_impl(\n                 })\n         })\n         // try keywords\n-        .or_else(|| descended.iter().find_map(|token| render::keyword(sema, config, token)))\n-        // try rest item hover\n+        .or_else(|| descended().find_map(|token| render::keyword(sema, config, token)))\n+        // try _ hovers\n+        .or_else(|| descended().find_map(|token| render::underscore(sema, config, token)))\n+        // try rest pattern hover\n         .or_else(|| {\n-            descended.iter().find_map(|token| {\n+            descended().find_map(|token| {\n                 if token.kind() != DOT2 {\n                     return None;\n                 }\n@@ -201,39 +210,13 @@ fn hover_impl(\n         })\n         // fallback to type hover if there aren't any other suggestions\n         // this finds its own range instead of using the closest token's range\n-        .or_else(|| {\n-            descended.iter().find_map(|token| hover_type_fallback(sema, config, token, token))\n-        })\n-}\n-\n-pub(crate) fn hover_for_definition(\n-    sema: &Semantics<'_, RootDatabase>,\n-    file_id: FileId,\n-    definition: Definition,\n-    node: &SyntaxNode,\n-    config: &HoverConfig,\n-) -> Option<HoverResult> {\n-    let famous_defs = match &definition {\n-        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n-        _ => None,\n-    };\n-    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n-        HoverResult {\n-            markup: render::process_markup(sema.db, definition, &markup, config),\n-            actions: show_implementations_action(sema.db, definition)\n-                .into_iter()\n-                .chain(show_fn_references_action(sema.db, definition))\n-                .chain(runnable_action(sema, definition, file_id))\n-                .chain(goto_type_action_for_def(sema.db, definition))\n-                .collect(),\n-        }\n-    })\n+        .or_else(|| descended().find_map(|token| hover_type_fallback(sema, config, token, token)))\n }\n \n fn hover_ranged(\n-    file: &SyntaxNode,\n-    range: syntax::TextRange,\n     sema: &Semantics<'_, RootDatabase>,\n+    FileRange { range, .. }: FileRange,\n+    file: SyntaxNode,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     // FIXME: make this work in attributes\n@@ -248,7 +231,7 @@ fn hover_ranged(\n         }\n         _ => None,\n     };\n-    let res = res.or_else(|| render::type_info(sema, config, &expr_or_pat));\n+    let res = res.or_else(|| render::type_info_of(sema, config, &expr_or_pat));\n     res.map(|it| {\n         let range = match expr_or_pat {\n             Either::Left(it) => it.syntax().text_range(),\n@@ -258,6 +241,33 @@ fn hover_ranged(\n     })\n }\n \n+pub(crate) fn hover_for_definition(\n+    sema: &Semantics<'_, RootDatabase>,\n+    file_id: FileId,\n+    definition: Definition,\n+    node: &SyntaxNode,\n+    config: &HoverConfig,\n+) -> Option<HoverResult> {\n+    let famous_defs = match &definition {\n+        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n+        _ => None,\n+    };\n+    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n+        HoverResult {\n+            markup: render::process_markup(sema.db, definition, &markup, config),\n+            actions: [\n+                show_implementations_action(sema.db, definition),\n+                show_fn_references_action(sema.db, definition),\n+                runnable_action(sema, definition, file_id),\n+                goto_type_action_for_def(sema.db, definition),\n+            ]\n+            .into_iter()\n+            .flatten()\n+            .collect(),\n+        }\n+    })\n+}\n+\n fn hover_type_fallback(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n@@ -282,7 +292,7 @@ fn hover_type_fallback(\n         }\n     };\n \n-    let res = render::type_info(sema, config, &expr_or_pat)?;\n+    let res = render::type_info_of(sema, config, &expr_or_pat)?;\n \n     let range = sema\n         .original_range_opt(&node)"}, {"sha": "22611cfb892f8de5a174a3829934f78c855ffd6e", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 79, "deletions": 29, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=a542bd46bf22a56dd7b519de515949fef6976b42", "patch": "@@ -29,7 +29,7 @@ use crate::{\n     HoverAction, HoverConfig, HoverResult, Markup,\n };\n \n-pub(super) fn type_info(\n+pub(super) fn type_info_of(\n     sema: &Semantics<'_, RootDatabase>,\n     _config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n@@ -38,34 +38,7 @@ pub(super) fn type_info(\n         Either::Left(expr) => sema.type_of_expr(expr)?,\n         Either::Right(pat) => sema.type_of_pat(pat)?,\n     };\n-\n-    let mut res = HoverResult::default();\n-    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n-    let mut push_new_def = |item: hir::ModuleDef| {\n-        if !targets.contains(&item) {\n-            targets.push(item);\n-        }\n-    };\n-    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n-\n-    res.markup = if let Some(adjusted_ty) = adjusted {\n-        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n-        let original = original.display(sema.db).to_string();\n-        let adjusted = adjusted_ty.display(sema.db).to_string();\n-        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n-        format!(\n-            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n-            original,\n-            adjusted,\n-            apad = static_text_diff_len + adjusted.len().max(original.len()),\n-            opad = original.len(),\n-        )\n-        .into()\n-    } else {\n-        Markup::fenced_block(&original.display(sema.db))\n-    };\n-    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n-    Some(res)\n+    type_info(sema, _config, original, adjusted)\n }\n \n pub(super) fn try_expr(\n@@ -217,6 +190,48 @@ pub(super) fn deref_expr(\n     Some(res)\n }\n \n+pub(super) fn underscore(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<HoverResult> {\n+    if token.kind() != T![_] {\n+        return None;\n+    }\n+    let parent = token.parent()?;\n+    let _it = match_ast! {\n+        match parent {\n+            ast::InferType(it) => it,\n+            ast::UnderscoreExpr(it) => return type_info_of(sema, config, &Either::Left(ast::Expr::UnderscoreExpr(it))),\n+            ast::WildcardPat(it) => return type_info_of(sema, config, &Either::Right(ast::Pat::WildcardPat(it))),\n+            _ => return None,\n+        }\n+    };\n+    // let it = infer_type.syntax().parent()?;\n+    // match_ast! {\n+    //     match it {\n+    //         ast::LetStmt(_it) => (),\n+    //         ast::Param(_it) => (),\n+    //         ast::RetType(_it) => (),\n+    //         ast::TypeArg(_it) => (),\n+\n+    //         ast::CastExpr(_it) => (),\n+    //         ast::ParenType(_it) => (),\n+    //         ast::TupleType(_it) => (),\n+    //         ast::PtrType(_it) => (),\n+    //         ast::RefType(_it) => (),\n+    //         ast::ArrayType(_it) => (),\n+    //         ast::SliceType(_it) => (),\n+    //         ast::ForType(_it) => (),\n+    //         _ => return None,\n+    //     }\n+    // }\n+\n+    // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown\n+    // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)\n+    None\n+}\n+\n pub(super) fn keyword(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n@@ -458,6 +473,41 @@ pub(super) fn definition(\n     markup(docs, label, mod_path)\n }\n \n+fn type_info(\n+    sema: &Semantics<'_, RootDatabase>,\n+    _config: &HoverConfig,\n+    original: hir::Type,\n+    adjusted: Option<hir::Type>,\n+) -> Option<HoverResult> {\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n+        format!(\n+            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n+            original,\n+            adjusted,\n+            apad = static_text_diff_len + adjusted.len().max(original.len()),\n+            opad = original.len(),\n+        )\n+        .into()\n+    } else {\n+        Markup::fenced_block(&original.display(sema.db))\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    Some(res)\n+}\n+\n fn render_builtin_attr(db: &RootDatabase, attr: hir::BuiltinAttr) -> Option<Markup> {\n     let name = attr.name(db);\n     let desc = format!(\"#[{name}]\");"}, {"sha": "2930aab68a987bf07c784e273f9538e0141f89ec", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a542bd46bf22a56dd7b519de515949fef6976b42/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=a542bd46bf22a56dd7b519de515949fef6976b42", "patch": "@@ -5592,3 +5592,93 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_underscore_pat() {\n+    check(\n+        r#\"\n+fn main() {\n+    let _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    let (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_expr() {\n+    check(\n+        r#\"\n+fn main() {\n+    _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_type() {\n+    check(\n+        r#\"\n+fn main() {\n+    let x: _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            {unknown}\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    let x: (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            {unknown}\n+            ```\n+        \"#]],\n+    );\n+}"}]}