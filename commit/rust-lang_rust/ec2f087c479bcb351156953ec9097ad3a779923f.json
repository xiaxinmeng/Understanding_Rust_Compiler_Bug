{"sha": "ec2f087c479bcb351156953ec9097ad3a779923f", "node_id": "C_kwDOAAsO6NoAKGVjMmYwODdjNDc5YmNiMzUxMTU2OTUzZWM5MDk3YWQzYTc3OTkyM2Y", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-20T21:33:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T21:33:51Z"}, "message": "Rollup merge of #91022 - compiler-errors:modulo_infer, r=estebank\n\nSuggest `await` in more situations where infer types are involved\n\nCurrently we use `TyS::same_type` in diagnostics that suggest adding `.await` to opaque future types.\n\nThis change makes the suggestion slightly more general, when we're comparing types like `Result<T, E>` and `Result<_, _>` which happens sometimes in places like `match` patterns or `let` statements with partially-elaborated types.\n\n----\n\nQuestion:\n1. Is this change worthwhile? Totally fine if it doesn't make sense adding.\n2. Should `same_type_modulo_infer` live in `rustc_infer::infer::error_reporting` or alongside the other method in `rustc_middle::ty::util`?\n3. Should we generalize this change? I wanted to change all usages, but I don't want erroneous suggestions when adding `.field_name`...", "tree": {"sha": "e8e9f3e96a9787c8c3a80ce7380e1fd619ce21a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8e9f3e96a9787c8c3a80ce7380e1fd619ce21a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec2f087c479bcb351156953ec9097ad3a779923f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmWnACRBK7hj4Ov3rIwAAlbEIAAjjzc8e0F37iUbWN4+BXfyk\nviK7Yfqc0cHF0MPbkNRK3MK63j+9NuqJecc5c7UTEdVWZ9TpWThn5ZFT04U0osQb\nVIvRuPxnPX9hYLgDmdLmGjH3kt75w6MCz81OgCVNIBNm/MrT5UztU0RzFuQ8NhYJ\n6m04s1PI5H5IXrpkYDnRbJ4tqkiLLFRfP/znzjAd9Ge3R5vFz+u30tDMb315AYtd\nfbKvpy2QP6GNo5px8/1CCna3YMg8DPFjPLe4/DSdBKuV9aREtncMClW0NgR/PFIK\nhaY9oggl0uj6dpTaPbo8gsjGs0Z7JHtEUog6S9I6HKFjWZIQJC1eIyvWas6RKro=\n=GXco\n-----END PGP SIGNATURE-----\n", "payload": "tree e8e9f3e96a9787c8c3a80ce7380e1fd619ce21a6\nparent f37a6caffe0ec03b0b32da9d7045f22d35deb526\nparent 1f625b739a1178e00ac36819738289b5dbc081ea\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1637444031 +0100\ncommitter GitHub <noreply@github.com> 1637444031 +0100\n\nRollup merge of #91022 - compiler-errors:modulo_infer, r=estebank\n\nSuggest `await` in more situations where infer types are involved\n\nCurrently we use `TyS::same_type` in diagnostics that suggest adding `.await` to opaque future types.\n\nThis change makes the suggestion slightly more general, when we're comparing types like `Result<T, E>` and `Result<_, _>` which happens sometimes in places like `match` patterns or `let` statements with partially-elaborated types.\n\n----\n\nQuestion:\n1. Is this change worthwhile? Totally fine if it doesn't make sense adding.\n2. Should `same_type_modulo_infer` live in `rustc_infer::infer::error_reporting` or alongside the other method in `rustc_middle::ty::util`?\n3. Should we generalize this change? I wanted to change all usages, but I don't want erroneous suggestions when adding `.field_name`...\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec2f087c479bcb351156953ec9097ad3a779923f", "html_url": "https://github.com/rust-lang/rust/commit/ec2f087c479bcb351156953ec9097ad3a779923f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec2f087c479bcb351156953ec9097ad3a779923f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f37a6caffe0ec03b0b32da9d7045f22d35deb526", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37a6caffe0ec03b0b32da9d7045f22d35deb526", "html_url": "https://github.com/rust-lang/rust/commit/f37a6caffe0ec03b0b32da9d7045f22d35deb526"}, {"sha": "1f625b739a1178e00ac36819738289b5dbc081ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f625b739a1178e00ac36819738289b5dbc081ea", "html_url": "https://github.com/rust-lang/rust/commit/1f625b739a1178e00ac36819738289b5dbc081ea"}], "stats": {"total": 89, "additions": 85, "deletions": 4}, "files": [{"sha": "3c2f99000806225280707ae2b1fc026f1c3decf3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ec2f087c479bcb351156953ec9097ad3a779923f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec2f087c479bcb351156953ec9097ad3a779923f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ec2f087c479bcb351156953ec9097ad3a779923f", "patch": "@@ -310,6 +310,34 @@ pub fn unexpected_hidden_region_diagnostic(\n     err\n }\n \n+/// Structurally compares two types, modulo any inference variables.\n+///\n+/// Returns `true` if two types are equal, or if one type is an inference variable compatible\n+/// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n+/// FloatVar inference type are compatible with themselves or their concrete types (Int and\n+/// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n+pub fn same_type_modulo_infer(a: Ty<'tcx>, b: Ty<'ctx>) -> bool {\n+    match (&a.kind(), &b.kind()) {\n+        (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n+            if did_a != did_b {\n+                return false;\n+            }\n+\n+            substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type_modulo_infer(a, b))\n+        }\n+        (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+        | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_) | &ty::Infer(ty::InferTy::IntVar(_)))\n+        | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+        | (\n+            &ty::Infer(ty::InferTy::FloatVar(_)),\n+            &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+        )\n+        | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n+        | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n+        _ => a == b,\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n@@ -1761,7 +1789,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.get_impl_future_output_ty(exp_found.expected),\n             self.get_impl_future_output_ty(exp_found.found),\n         ) {\n-            (Some(exp), Some(found)) if ty::TyS::same_type(exp, found) => match &cause.code {\n+            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match &cause.code {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n                     diag.multipart_suggestion(\n                         \"consider `await`ing on both `Future`s\",\n@@ -1793,15 +1821,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     diag.help(\"consider `await`ing on both `Future`s\");\n                 }\n             },\n-            (_, Some(ty)) if ty::TyS::same_type(exp_found.expected, ty) => {\n+            (_, Some(ty)) if same_type_modulo_infer(exp_found.expected, ty) => {\n                 diag.span_suggestion_verbose(\n                     exp_span.shrink_to_hi(),\n                     \"consider `await`ing on the `Future`\",\n                     \".await\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (Some(ty), _) if ty::TyS::same_type(ty, exp_found.found) => match cause.code {\n+            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code {\n                 ObligationCauseCode::Pattern { span: Some(span), .. }\n                 | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n                     diag.span_suggestion_verbose("}, {"sha": "c7c5b51e7334b87b27e40534c5541d9e7044b960", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec2f087c479bcb351156953ec9097ad3a779923f/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec2f087c479bcb351156953ec9097ad3a779923f/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=ec2f087c479bcb351156953ec9097ad3a779923f", "patch": "@@ -54,4 +54,21 @@ async fn suggest_await_on_match_expr() {\n     };\n }\n \n+async fn dummy_result() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_generic_pattern() {\n+    match dummy_result() {\n+        //~^ HELP consider `await`ing on the `Future`\n+        //~| HELP consider `await`ing on the `Future`\n+        //~| SUGGESTION .await\n+        Ok(_) => {}\n+        //~^ ERROR mismatched types [E0308]\n+        Err(_) => {}\n+        //~^ ERROR mismatched types [E0308]\n+    }\n+}\n+\n fn main() {}"}, {"sha": "3cca9616a358a34d7489d0efbd75aca2c185c2ba", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec2f087c479bcb351156953ec9097ad3a779923f/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec2f087c479bcb351156953ec9097ad3a779923f/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=ec2f087c479bcb351156953ec9097ad3a779923f", "patch": "@@ -106,6 +106,42 @@ help: consider `await`ing on the `Future`\n LL |     let _x = match dummy().await {\n    |                           ++++++\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-missing-await.rs:67:9\n+   |\n+LL |         Ok(_) => {}\n+   |         ^^^^^ expected opaque type, found enum `Result`\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/suggest-missing-await.rs:57:28\n+   |\n+LL | async fn dummy_result() -> Result<(), ()> {\n+   |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n+   = note: expected opaque type `impl Future<Output = Result<(), ()>>`\n+                     found enum `Result<_, _>`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     match dummy_result().await {\n+   |                         ++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-missing-await.rs:69:9\n+   |\n+LL |         Err(_) => {}\n+   |         ^^^^^^ expected opaque type, found enum `Result`\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/suggest-missing-await.rs:57:28\n+   |\n+LL | async fn dummy_result() -> Result<(), ()> {\n+   |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n+   = note: expected opaque type `impl Future<Output = Result<(), ()>>`\n+                     found enum `Result<_, _>`\n+help: consider `await`ing on the `Future`\n+   |\n+LL |     match dummy_result().await {\n+   |                         ++++++\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}