{"sha": "4dacd736510b2ae28a54489fe88571f1a6de019f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYWNkNzM2NTEwYjJhZTI4YTU0NDg5ZmU4ODU3MWYxYTZkZTAxOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-19T01:30:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-19T01:30:56Z"}, "message": "auto merge of #9260 : alexcrichton/rust/libuv-processes, r=brson\n\nThis is a re-landing of #8645, except that the bindings are *not* being used to\r\npower std::run just yet. Instead, this adds the bindings as standalone bindings\r\ninside the rt::io::process module.\r\n\r\nI made one major change from before, having to do with how pipes are\r\ncreated/bound. It's much clearer now when you can read/write to a pipe, as\r\nthere's an explicit difference (different types) between an unbound and a bound\r\npipe. The process configuration now takes unbound pipes (and consumes ownership\r\nof them), and will return corresponding pipe structures back if spawning is\r\nsuccessful (otherwise everything is destroyed normally).", "tree": {"sha": "4703e0ae31a895aa5485abec49eecf4984bdcf3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4703e0ae31a895aa5485abec49eecf4984bdcf3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dacd736510b2ae28a54489fe88571f1a6de019f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dacd736510b2ae28a54489fe88571f1a6de019f", "html_url": "https://github.com/rust-lang/rust/commit/4dacd736510b2ae28a54489fe88571f1a6de019f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dacd736510b2ae28a54489fe88571f1a6de019f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36cc41481c788e8d781e24908dcf30120797ed8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/36cc41481c788e8d781e24908dcf30120797ed8d", "html_url": "https://github.com/rust-lang/rust/commit/36cc41481c788e8d781e24908dcf30120797ed8d"}, {"sha": "cb7756a81d3cbc48e79ffaa1a1f9d4934b581166", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7756a81d3cbc48e79ffaa1a1f9d4934b581166", "html_url": "https://github.com/rust-lang/rust/commit/cb7756a81d3cbc48e79ffaa1a1f9d4934b581166"}], "stats": {"total": 1143, "additions": 1076, "deletions": 67}, "files": [{"sha": "6b405b0948a0fba6a5a523078bd591f5c6686e02", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -260,6 +260,9 @@ pub use self::net::ip::IpAddr;\n pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n+pub use self::pipe::PipeStream;\n+pub use self::pipe::UnboundPipeStream;\n+pub use self::process::Process;\n \n // Some extension traits that all Readers and Writers get.\n pub use self::extensions::ReaderUtil;\n@@ -269,6 +272,12 @@ pub use self::extensions::WriterByteConversions;\n /// Synchronous, non-blocking file I/O.\n pub mod file;\n \n+/// Synchronous, in-memory I/O.\n+pub mod pipe;\n+\n+/// Child process management.\n+pub mod process;\n+\n /// Synchronous, non-blocking network I/O.\n pub mod net;\n "}, {"sha": "7e6c59ffd0b7afd49c88afb29977d1c8b7e106a6", "filename": "src/libstd/rt/io/pipe.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Synchronous, in-memory pipes.\n+//!\n+//! Currently these aren't particularly useful, there only exists bindings\n+//! enough so that pipes can be created to child processes.\n+\n+use prelude::*;\n+use super::{Reader, Writer};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::local::Local;\n+use rt::rtio::{RtioPipe, RtioPipeObject, IoFactoryObject, IoFactory};\n+use rt::rtio::RtioUnboundPipeObject;\n+\n+pub struct PipeStream(RtioPipeObject);\n+pub struct UnboundPipeStream(~RtioUnboundPipeObject);\n+\n+impl PipeStream {\n+    /// Creates a new pipe initialized, but not bound to any particular\n+    /// source/destination\n+    pub fn new() -> Option<UnboundPipeStream> {\n+        let pipe = unsafe {\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*io).pipe_init(false)\n+        };\n+        match pipe {\n+            Ok(p) => Some(UnboundPipeStream(p)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn bind(inner: RtioPipeObject) -> PipeStream {\n+        PipeStream(inner)\n+    }\n+}\n+\n+impl Reader for PipeStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match (**self).read(buf) {\n+            Ok(read) => Some(read),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for PipeStream {\n+    fn write(&mut self, buf: &[u8]) {\n+        match (**self).write(buf) {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+\n+    fn flush(&mut self) { fail!() }\n+}"}, {"sha": "e92b0d3b7b5fbd87a7c9d72a20728d817c91a5f0", "filename": "src/libstd/rt/io/process.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bindings for executing child processes\n+\n+use prelude::*;\n+\n+use libc;\n+use rt::io;\n+use rt::io::io_error;\n+use rt::local::Local;\n+use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n+\n+pub struct Process {\n+    priv handle: ~RtioProcessObject,\n+    io: ~[Option<io::PipeStream>],\n+}\n+\n+/// This configuration describes how a new process should be spawned. This is\n+/// translated to libuv's own configuration\n+pub struct ProcessConfig<'self> {\n+    /// Path to the program to run\n+    program: &'self str,\n+\n+    /// Arguments to pass to the program (doesn't include the program itself)\n+    args: &'self [~str],\n+\n+    /// Optional environment to specify for the program. If this is None, then\n+    /// it will inherit the current process's environment.\n+    env: Option<&'self [(~str, ~str)]>,\n+\n+    /// Optional working directory for the new process. If this is None, then\n+    /// the current directory of the running process is inherited.\n+    cwd: Option<&'self str>,\n+\n+    /// Any number of streams/file descriptors/pipes may be attached to this\n+    /// process. This list enumerates the file descriptors and such for the\n+    /// process to be spawned, and the file descriptors inherited will start at\n+    /// 0 and go to the length of this array.\n+    ///\n+    /// Standard file descriptors are:\n+    ///\n+    ///     0 - stdin\n+    ///     1 - stdout\n+    ///     2 - stderr\n+    io: ~[StdioContainer]\n+}\n+\n+/// Describes what to do with a standard io stream for a child process.\n+pub enum StdioContainer {\n+    /// This stream will be ignored. This is the equivalent of attaching the\n+    /// stream to `/dev/null`\n+    Ignored,\n+\n+    /// The specified file descriptor is inherited for the stream which it is\n+    /// specified for.\n+    InheritFd(libc::c_int),\n+\n+    // XXX: these two shouldn't have libuv-specific implementation details\n+\n+    /// The specified libuv stream is inherited for the corresponding file\n+    /// descriptor it is assigned to.\n+    // XXX: this needs to be thought out more.\n+    //InheritStream(uv::net::StreamWatcher),\n+\n+    /// Creates a pipe for the specified file descriptor which will be directed\n+    /// into the previously-initialized pipe passed in.\n+    ///\n+    /// The first boolean argument is whether the pipe is readable, and the\n+    /// second is whether it is writable. These properties are from the view of\n+    /// the *child* process, not the parent process.\n+    CreatePipe(io::UnboundPipeStream,\n+               bool /* readable */,\n+               bool /* writable */),\n+}\n+\n+impl Process {\n+    /// Creates a new pipe initialized, but not bound to any particular\n+    /// source/destination\n+    pub fn new(config: ProcessConfig) -> Option<Process> {\n+        let process = unsafe {\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*io).spawn(config)\n+        };\n+        match process {\n+            Ok((p, io)) => Some(Process{\n+                handle: p,\n+                io: io.move_iter().map(|p|\n+                    p.map_move(|p| io::PipeStream::bind(p))\n+                ).collect()\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Returns the process id of this child process\n+    pub fn id(&self) -> libc::pid_t { self.handle.id() }\n+\n+    /// Sends the specified signal to the child process, returning whether the\n+    /// signal could be delivered or not.\n+    ///\n+    /// Note that this is purely a wrapper around libuv's `uv_process_kill`\n+    /// function.\n+    ///\n+    /// If the signal delivery fails, then the `io_error` condition is raised on\n+    pub fn signal(&mut self, signal: int) {\n+        match self.handle.kill(signal) {\n+            Ok(()) => {}\n+            Err(err) => {\n+                io_error::cond.raise(err)\n+            }\n+        }\n+    }\n+\n+    /// Wait for the child to exit completely, returning the status that it\n+    /// exited with. This function will continue to have the same return value\n+    /// after it has been called at least once.\n+    pub fn wait(&mut self) -> int { self.handle.wait() }\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        // Close all I/O before exiting to ensure that the child doesn't wait\n+        // forever to print some text or something similar.\n+        for _ in range(0, self.io.len()) {\n+            self.io.pop();\n+        }\n+\n+        self.wait();\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+\n+    use rt::io::{Reader, Writer};\n+    use rt::io::pipe::*;\n+    use str;\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn smoke() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"true\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert_eq!(p.wait(), 0);\n+    }\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn smoke_failure() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"if-this-is-a-binary-then-the-world-has-ended\",\n+            args: [],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.wait() != 0);\n+    }\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn exit_reported_right() {\n+        let io = ~[];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"exit 1\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert_eq!(p.wait(), 1);\n+    }\n+\n+    fn read_all(input: &mut Reader) -> ~str {\n+        let mut ret = ~\"\";\n+        let mut buf = [0, ..1024];\n+        loop {\n+            match input.read(buf) {\n+                None | Some(0) => { break }\n+                Some(n) => { ret = ret + str::from_utf8(buf.slice_to(n)); }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    fn run_output(args: ProcessConfig) -> ~str {\n+        let p = Process::new(args);\n+        assert!(p.is_some());\n+        let mut p = p.unwrap();\n+        assert!(p.io[0].is_none());\n+        assert!(p.io[1].is_some());\n+        let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert_eq!(p.wait(), 0);\n+        return ret;\n+    }\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn stdout_works() {\n+        let pipe = PipeStream::new().unwrap();\n+        let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"echo foobar\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"foobar\\n\");\n+    }\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn set_cwd_works() {\n+        let pipe = PipeStream::new().unwrap();\n+        let io = ~[Ignored, CreatePipe(pipe, false, true)];\n+        let cwd = Some(\"/\");\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"pwd\"],\n+            env: None,\n+            cwd: cwd,\n+            io: io,\n+        };\n+        assert_eq!(run_output(args), ~\"/\\n\");\n+    }\n+\n+    #[test]\n+    #[cfg(unix, not(android))]\n+    fn stdin_works() {\n+        let input = PipeStream::new().unwrap();\n+        let output = PipeStream::new().unwrap();\n+        let io = ~[CreatePipe(input, true, false),\n+                   CreatePipe(output, false, true)];\n+        let args = ProcessConfig {\n+            program: \"/bin/sh\",\n+            args: [~\"-c\", ~\"read line; echo $line\"],\n+            env: None,\n+            cwd: None,\n+            io: io,\n+        };\n+        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n+        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+        p.io[0] = None; // close stdin;\n+        let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert_eq!(p.wait(), 0);\n+        assert_eq!(out, ~\"foobar\\n\");\n+    }\n+}"}, {"sha": "ca521c792dc732e9e25cf9db564cf5c72a922143", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use libc;\n use option::*;\n use result::*;\n use libc::c_int;\n \n use rt::io::IoError;\n+use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n use path::Path;\n@@ -31,6 +33,9 @@ pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n+pub type RtioPipeObject = uvio::UvPipeStream;\n+pub type RtioUnboundPipeObject = uvio::UvUnboundPipe;\n+pub type RtioProcessObject = uvio::UvProcess;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -79,6 +84,9 @@ pub trait IoFactory {\n     fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n         Result<~[Path], IoError>;\n+    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError>;\n+    fn spawn(&mut self, config: ProcessConfig)\n+            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -135,3 +143,14 @@ pub trait RtioFileStream {\n     fn tell(&self) -> Result<u64, IoError>;\n     fn flush(&mut self) -> Result<(), IoError>;\n }\n+\n+pub trait RtioProcess {\n+    fn id(&self) -> libc::pid_t;\n+    fn kill(&mut self, signal: int) -> Result<(), IoError>;\n+    fn wait(&mut self) -> int;\n+}\n+\n+pub trait RtioPipe {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+}"}, {"sha": "95b2059d5381ddfa2fb3178b38d76719c9a8fdd3", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -58,6 +58,8 @@ pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n+pub use self::process::Process;\n+pub use self::pipe::Pipe;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -71,6 +73,8 @@ pub mod idle;\n pub mod timer;\n pub mod async;\n pub mod addrinfo;\n+pub mod process;\n+pub mod pipe;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -127,6 +131,8 @@ pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n+// first int is exit_status, second is term_signal\n+pub type ExitCallback = ~fn(Process, int, int, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n@@ -145,7 +151,8 @@ struct WatcherData {\n     timer_cb: Option<TimerCallback>,\n     async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n-    udp_send_cb: Option<UdpSendCallback>\n+    udp_send_cb: Option<UdpSendCallback>,\n+    exit_cb: Option<ExitCallback>,\n }\n \n pub trait WatcherInterop {\n@@ -177,7 +184,8 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 timer_cb: None,\n                 async_cb: None,\n                 udp_recv_cb: None,\n-                udp_send_cb: None\n+                udp_send_cb: None,\n+                exit_cb: None,\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}, {"sha": "1147c731a60c5e312a1d055bf915cec8ad4bbd4c", "filename": "src/libstd/rt/uv/pipe.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc;\n+\n+use rt::uv;\n+use rt::uv::net;\n+use rt::uv::uvll;\n+\n+pub struct Pipe(*uvll::uv_pipe_t);\n+\n+impl uv::Watcher for Pipe {}\n+\n+impl Pipe {\n+    pub fn new(loop_: &uv::Loop, ipc: bool) -> Pipe {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n+            assert!(handle.is_not_null());\n+            let ipc = ipc as libc::c_int;\n+            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n+            let mut ret: Pipe =\n+                    uv::NativeHandle::from_native_handle(handle);\n+            ret.install_watcher_data();\n+            ret\n+        }\n+    }\n+\n+    pub fn as_stream(&self) -> net::StreamWatcher {\n+        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    }\n+\n+    pub fn close(self, cb: uv::NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_pipe_t) {\n+            let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n+            process.get_watcher_data().close_cb.take_unwrap()();\n+            process.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *libc::c_void) }\n+        }\n+    }\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_pipe_t> for Pipe {\n+    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n+        Pipe(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_pipe_t {\n+        match self { &Pipe(ptr) => ptr }\n+    }\n+}"}, {"sha": "ccfa1ff87dbd05a3d5a4504978fc1c304945068e", "filename": "src/libstd/rt/uv/process.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use cell::Cell;\n+use libc;\n+use ptr;\n+use util;\n+use vec;\n+\n+use rt::io::process::*;\n+use rt::uv;\n+use rt::uv::uvio::UvPipeStream;\n+use rt::uv::uvll;\n+\n+/// A process wraps the handle of the underlying uv_process_t.\n+pub struct Process(*uvll::uv_process_t);\n+\n+impl uv::Watcher for Process {}\n+\n+impl Process {\n+    /// Creates a new process, ready to spawn inside an event loop\n+    pub fn new() -> Process {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_PROCESS) };\n+        assert!(handle.is_not_null());\n+        let mut ret: Process = uv::NativeHandle::from_native_handle(handle);\n+        ret.install_watcher_data();\n+        return ret;\n+    }\n+\n+    /// Spawn a new process inside the specified event loop.\n+    ///\n+    /// The `config` variable will be passed down to libuv, and the `exit_cb`\n+    /// will be run only once, when the process exits.\n+    ///\n+    /// Returns either the corresponding process object or an error which\n+    /// occurred.\n+    pub fn spawn(&mut self, loop_: &uv::Loop, mut config: ProcessConfig,\n+                 exit_cb: uv::ExitCallback)\n+                    -> Result<~[Option<UvPipeStream>], uv::UvError>\n+    {\n+        let cwd = config.cwd.map_move(|s| s.to_c_str());\n+\n+        extern fn on_exit(p: *uvll::uv_process_t,\n+                          exit_status: libc::c_int,\n+                          term_signal: libc::c_int) {\n+            let mut p: Process = uv::NativeHandle::from_native_handle(p);\n+            let err = match exit_status {\n+                0 => None,\n+                _ => uv::status_to_maybe_uv_error(-1)\n+            };\n+            p.get_watcher_data().exit_cb.take_unwrap()(p,\n+                                                       exit_status as int,\n+                                                       term_signal as int,\n+                                                       err);\n+        }\n+\n+        let io = util::replace(&mut config.io, ~[]);\n+        let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n+        let mut ret_io = vec::with_capacity(io.len());\n+        unsafe {\n+            vec::raw::set_len(&mut stdio, io.len());\n+            for (slot, other) in stdio.iter().zip(io.move_iter()) {\n+                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other);\n+                ret_io.push(io);\n+            }\n+        }\n+\n+        let exit_cb = Cell::new(exit_cb);\n+        let ret_io = Cell::new(ret_io);\n+        do with_argv(config.program, config.args) |argv| {\n+            do with_env(config.env) |envp| {\n+                let options = uvll::uv_process_options_t {\n+                    exit_cb: on_exit,\n+                    file: unsafe { *argv },\n+                    args: argv,\n+                    env: envp,\n+                    cwd: match cwd {\n+                        Some(ref cwd) => cwd.with_ref(|p| p),\n+                        None => ptr::null(),\n+                    },\n+                    flags: 0,\n+                    stdio_count: stdio.len() as libc::c_int,\n+                    stdio: stdio.as_imm_buf(|p, _| p),\n+                    uid: 0,\n+                    gid: 0,\n+                };\n+\n+                match unsafe {\n+                    uvll::spawn(loop_.native_handle(), **self, options)\n+                } {\n+                    0 => {\n+                        (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n+                        Ok(ret_io.take())\n+                    }\n+                    err => Err(uv::UvError(err))\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Sends a signal to this process.\n+    ///\n+    /// This is a wrapper around `uv_process_kill`\n+    pub fn kill(&self, signum: int) -> Result<(), uv::UvError> {\n+        match unsafe {\n+            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n+        } {\n+            0 => Ok(()),\n+            err => Err(uv::UvError(err))\n+        }\n+    }\n+\n+    /// Returns the process id of a spawned process\n+    pub fn pid(&self) -> libc::pid_t {\n+        unsafe { uvll::process_pid(**self) as libc::pid_t }\n+    }\n+\n+    /// Closes this handle, invoking the specified callback once closed\n+    pub fn close(self, cb: uv::NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_process_t) {\n+            let mut process: Process = uv::NativeHandle::from_native_handle(handle);\n+            process.get_watcher_data().close_cb.take_unwrap()();\n+            process.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *libc::c_void) }\n+        }\n+    }\n+}\n+\n+unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n+                    io: StdioContainer) -> Option<UvPipeStream> {\n+    match io {\n+        Ignored => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n+            None\n+        }\n+        InheritFd(fd) => {\n+            uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n+            uvll::set_stdio_container_fd(dst, fd);\n+            None\n+        }\n+        CreatePipe(pipe, readable, writable) => {\n+            let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n+            if readable {\n+                flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n+            }\n+            if writable {\n+                flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n+            }\n+            let handle = pipe.pipe.as_stream().native_handle();\n+            uvll::set_stdio_container_flags(dst, flags);\n+            uvll::set_stdio_container_stream(dst, handle);\n+            Some(pipe.bind())\n+        }\n+    }\n+}\n+\n+/// Converts the program and arguments to the argv array expected by libuv\n+fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n+    // First, allocation space to put all the C-strings (we need to have\n+    // ownership of them somewhere\n+    let mut c_strs = vec::with_capacity(args.len() + 1);\n+    c_strs.push(prog.to_c_str());\n+    for arg in args.iter() {\n+        c_strs.push(arg.to_c_str());\n+    }\n+\n+    // Next, create the char** array\n+    let mut c_args = vec::with_capacity(c_strs.len() + 1);\n+    for s in c_strs.iter() {\n+        c_args.push(s.with_ref(|p| p));\n+    }\n+    c_args.push(ptr::null());\n+    c_args.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+/// Converts the environment to the env array expected by libuv\n+fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n+    let env = match env {\n+        Some(s) => s,\n+        None => { return f(ptr::null()); }\n+    };\n+    // As with argv, create some temporary storage and then the actual array\n+    let mut envp = vec::with_capacity(env.len());\n+    for &(ref key, ref value) in env.iter() {\n+        envp.push(fmt!(\"%s=%s\", *key, *value).to_c_str());\n+    }\n+    let mut c_envp = vec::with_capacity(envp.len() + 1);\n+    for s in envp.iter() {\n+        c_envp.push(s.with_ref(|p| p));\n+    }\n+    c_envp.push(ptr::null());\n+    c_envp.as_imm_buf(|buf, _| f(buf))\n+}\n+\n+impl uv::NativeHandle<*uvll::uv_process_t> for Process {\n+    fn from_native_handle(handle: *uvll::uv_process_t) -> Process {\n+        Process(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_process_t {\n+        match self { &Process(ptr) => ptr }\n+    }\n+}"}, {"sha": "ed6e16c8fdb09046b0cbb4966a1cb37744735fa4", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 266, "deletions": 65, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -13,7 +13,7 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n-use libc::{c_int, c_uint, c_void};\n+use libc::{c_int, c_uint, c_void, pid_t};\n use ops::Drop;\n use option::*;\n use ptr;\n@@ -22,6 +22,8 @@ use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur, SeekEnd};\n+use rt::io::process::ProcessConfig;\n+use rt::kill::BlockedTask;\n use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n@@ -735,6 +737,64 @@ impl IoFactory for UvIoFactory {\n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n     }\n+\n+    fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError> {\n+        let home = get_handle_to_current_scheduler!();\n+        Ok(~UvUnboundPipe { pipe: Pipe::new(self.uv_loop(), ipc), home: home })\n+    }\n+\n+    fn spawn(&mut self, config: ProcessConfig)\n+            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>\n+    {\n+        // Sadly, we must create the UvProcess before we actually call uv_spawn\n+        // so that the exit_cb can close over it and notify it when the process\n+        // has exited.\n+        let mut ret = ~UvProcess {\n+            process: Process::new(),\n+            home: None,\n+            exit_status: None,\n+            term_signal: None,\n+            exit_error: None,\n+            descheduled: None,\n+        };\n+        let ret_ptr = unsafe {\n+            *cast::transmute::<&~UvProcess, &*mut UvProcess>(&ret)\n+        };\n+\n+        // The purpose of this exit callback is to record the data about the\n+        // exit and then wake up the task which may be waiting for the process\n+        // to exit. This is all performed in the current io-loop, and the\n+        // implementation of UvProcess ensures that reading these fields always\n+        // occurs on the current io-loop.\n+        let exit_cb: ExitCallback = |_, exit_status, term_signal, error| {\n+            unsafe {\n+                assert!((*ret_ptr).exit_status.is_none());\n+                (*ret_ptr).exit_status = Some(exit_status);\n+                (*ret_ptr).term_signal = Some(term_signal);\n+                (*ret_ptr).exit_error = error;\n+                match (*ret_ptr).descheduled.take() {\n+                    Some(task) => {\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task);\n+                    }\n+                    None => {}\n+                }\n+            }\n+        };\n+\n+        match ret.process.spawn(self.uv_loop(), config, exit_cb) {\n+            Ok(io) => {\n+                // Only now do we actually get a handle to this scheduler.\n+                ret.home = Some(get_handle_to_current_scheduler!());\n+                Ok((ret, io))\n+            }\n+            Err(uverr) => {\n+                // We still need to close the process handle we created, but\n+                // that's taken care for us in the destructor of UvProcess\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -856,6 +916,126 @@ impl RtioTcpAcceptor for UvTcpAcceptor {\n     }\n }\n \n+fn read_stream(mut watcher: StreamWatcher,\n+               scheduler: ~Scheduler,\n+               buf: &mut [u8]) -> Result<uint, IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+    let buf_ptr: *&mut [u8] = &buf;\n+    do scheduler.deschedule_running_task_and_then |_sched, task| {\n+        let task_cell = Cell::new(task);\n+        // XXX: We shouldn't reallocate these callbacks every\n+        // call to read\n+        let alloc: AllocCallback = |_| unsafe {\n+            slice_to_uv_buf(*buf_ptr)\n+        };\n+        do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n+\n+            // Stop reading so that no read callbacks are\n+            // triggered before the user calls `read` again.\n+            // XXX: Is there a performance impact to calling\n+            // stop here?\n+            watcher.read_stop();\n+\n+            let result = if status.is_none() {\n+                assert!(nread >= 0);\n+                Ok(nread as uint)\n+            } else {\n+                Err(uv_error_to_io_error(status.unwrap()))\n+            };\n+\n+            unsafe { (*result_cell_ptr).put_back(result); }\n+\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task_cell.take());\n+        }\n+    }\n+\n+    assert!(!result_cell.is_empty());\n+    result_cell.take()\n+}\n+\n+fn write_stream(mut watcher: StreamWatcher,\n+                scheduler: ~Scheduler,\n+                buf: &[u8]) -> Result<(), IoError> {\n+    let result_cell = Cell::new_empty();\n+    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+    let buf_ptr: *&[u8] = &buf;\n+    do scheduler.deschedule_running_task_and_then |_, task| {\n+        let task_cell = Cell::new(task);\n+        let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+        do watcher.write(buf) |_watcher, status| {\n+            let result = if status.is_none() {\n+                Ok(())\n+            } else {\n+                Err(uv_error_to_io_error(status.unwrap()))\n+            };\n+\n+            unsafe { (*result_cell_ptr).put_back(result); }\n+\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task_cell.take());\n+        }\n+    }\n+\n+    assert!(!result_cell.is_empty());\n+    result_cell.take()\n+}\n+\n+pub struct UvUnboundPipe {\n+    pipe: Pipe,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvUnboundPipe {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for UvUnboundPipe {\n+    fn drop(&mut self) {\n+        do self.home_for_io |self_| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.pipe.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl UvUnboundPipe {\n+    pub unsafe fn bind(~self) -> UvPipeStream {\n+        UvPipeStream { inner: self }\n+    }\n+}\n+\n+pub struct UvPipeStream {\n+    priv inner: ~UvUnboundPipe,\n+}\n+\n+impl UvPipeStream {\n+    pub fn new(inner: ~UvUnboundPipe) -> UvPipeStream {\n+        UvPipeStream { inner: inner }\n+    }\n+}\n+\n+impl RtioPipe for UvPipeStream {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        do self.inner.home_for_io_with_sched |self_, scheduler| {\n+            read_stream(self_.pipe.as_stream(), scheduler, buf)\n+        }\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        do self.inner.home_for_io_with_sched |self_, scheduler| {\n+            write_stream(self_.pipe.as_stream(), scheduler, buf)\n+        }\n+    }\n+}\n+\n pub struct UvTcpStream {\n     watcher: TcpWatcher,\n     home: SchedHandle,\n@@ -890,70 +1070,13 @@ impl RtioSocket for UvTcpStream {\n impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n-\n-            let buf_ptr: *&mut [u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                let task_cell = Cell::new(task);\n-                // XXX: We shouldn't reallocate these callbacks every\n-                // call to read\n-                let alloc: AllocCallback = |_| unsafe {\n-                    slice_to_uv_buf(*buf_ptr)\n-                };\n-                let mut watcher = self_.watcher.as_stream();\n-                do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n-\n-                    // Stop reading so that no read callbacks are\n-                    // triggered before the user calls `read` again.\n-                    // XXX: Is there a performance impact to calling\n-                    // stop here?\n-                    watcher.read_stop();\n-\n-                    let result = if status.is_none() {\n-                        assert!(nread >= 0);\n-                        Ok(nread as uint)\n-                    } else {\n-                        Err(uv_error_to_io_error(status.unwrap()))\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-\n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n+            read_stream(self_.watcher.as_stream(), scheduler, buf)\n         }\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-            let buf_ptr: *&[u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let mut watcher = self_.watcher.as_stream();\n-                do watcher.write(buf) |_watcher, status| {\n-                    let result = if status.is_none() {\n-                        Ok(())\n-                    } else {\n-                        Err(uv_error_to_io_error(status.unwrap()))\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n-\n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n+            write_stream(self_.watcher.as_stream(), scheduler, buf)\n         }\n     }\n \n@@ -1240,8 +1363,7 @@ impl UvTimer {\n \n impl Drop for UvTimer {\n     fn drop(&mut self) {\n-        let self_ = unsafe { transmute::<&UvTimer, &mut UvTimer>(self) };\n-        do self_.home_for_io_with_sched |self_, scheduler| {\n+        do self.home_for_io_with_sched |self_, scheduler| {\n             rtdebug!(\"closing UvTimer\");\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n@@ -1356,13 +1478,12 @@ impl UvFileStream {\n \n impl Drop for UvFileStream {\n     fn drop(&mut self) {\n-        let self_ = unsafe { transmute::<&UvFileStream, &mut UvFileStream>(self) };\n         if self.close_on_drop {\n-            do self_.home_for_io_with_sched |self_, scheduler| {\n+            do self.home_for_io_with_sched |self_, scheduler| {\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n                     let close_req = file::FsRequest::new();\n-                    do close_req.close(&self.loop_, self_.fd) |_,_| {\n+                    do close_req.close(&self_.loop_, self_.fd) |_,_| {\n                         let scheduler: ~Scheduler = Local::take();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     };\n@@ -1405,6 +1526,86 @@ impl RtioFileStream for UvFileStream {\n     }\n }\n \n+pub struct UvProcess {\n+    process: process::Process,\n+\n+    // Sadly, this structure must be created before we return it, so in that\n+    // brief interim the `home` is None.\n+    home: Option<SchedHandle>,\n+\n+    // All None until the process exits (exit_error may stay None)\n+    priv exit_status: Option<int>,\n+    priv term_signal: Option<int>,\n+    priv exit_error: Option<UvError>,\n+\n+    // Used to store which task to wake up from the exit_cb\n+    priv descheduled: Option<BlockedTask>,\n+}\n+\n+impl HomingIO for UvProcess {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.home.get_mut_ref() }\n+}\n+\n+impl Drop for UvProcess {\n+    fn drop(&mut self) {\n+        let close = |self_: &mut UvProcess| {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task = Cell::new(task);\n+                do self_.process.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task.take());\n+                }\n+            }\n+        };\n+\n+        // If home is none, then this process never actually successfully\n+        // spawned, so there's no need to switch event loops\n+        if self.home.is_none() {\n+            close(self)\n+        } else {\n+            self.home_for_io(close)\n+        }\n+    }\n+}\n+\n+impl RtioProcess for UvProcess {\n+    fn id(&self) -> pid_t {\n+        self.process.pid()\n+    }\n+\n+    fn kill(&mut self, signal: int) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            match self_.process.kill(signal) {\n+                Ok(()) => Ok(()),\n+                Err(uverr) => Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n+\n+    fn wait(&mut self) -> int {\n+        // Make sure (on the home scheduler) that we have an exit status listed\n+        do self.home_for_io |self_| {\n+            match self_.exit_status {\n+                Some(*) => {}\n+                None => {\n+                    // If there's no exit code previously listed, then the\n+                    // process's exit callback has yet to be invoked. We just\n+                    // need to deschedule ourselves and wait to be reawoken.\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        assert!(self_.descheduled.is_none());\n+                        self_.descheduled = Some(task);\n+                    }\n+                    assert!(self_.exit_status.is_some());\n+                }\n+            }\n+        }\n+\n+        self.exit_status.unwrap()\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_mt_newsched_task {"}, {"sha": "790bf53a291d9b526c41df6d0682cfc1a673d142", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -66,6 +66,19 @@ pub mod errors {\n     pub static EPIPE: c_int = -libc::EPIPE;\n }\n \n+pub static PROCESS_SETUID: c_int = 1 << 0;\n+pub static PROCESS_SETGID: c_int = 1 << 1;\n+pub static PROCESS_WINDOWS_VERBATIM_ARGUMENTS: c_int = 1 << 2;\n+pub static PROCESS_DETACHED: c_int = 1 << 3;\n+pub static PROCESS_WINDOWS_HIDE: c_int = 1 << 4;\n+\n+pub static STDIO_IGNORE: c_int = 0x00;\n+pub static STDIO_CREATE_PIPE: c_int = 0x01;\n+pub static STDIO_INHERIT_FD: c_int = 0x02;\n+pub static STDIO_INHERIT_STREAM: c_int = 0x04;\n+pub static STDIO_READABLE_PIPE: c_int = 0x10;\n+pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n+\n // see libuv/include/uv-unix.h\n #[cfg(unix)]\n pub struct uv_buf_t {\n@@ -80,6 +93,26 @@ pub struct uv_buf_t {\n     base: *u8,\n }\n \n+pub struct uv_process_options_t {\n+    exit_cb: uv_exit_cb,\n+    file: *libc::c_char,\n+    args: **libc::c_char,\n+    env: **libc::c_char,\n+    cwd: *libc::c_char,\n+    flags: libc::c_uint,\n+    stdio_count: libc::c_int,\n+    stdio: *uv_stdio_container_t,\n+    uid: uv_uid_t,\n+    gid: uv_gid_t,\n+}\n+\n+// These fields are private because they must be interfaced with through the\n+// functions below.\n+pub struct uv_stdio_container_t {\n+    priv flags: libc::c_int,\n+    priv stream: *uv_stream_t,\n+}\n+\n pub type uv_handle_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n@@ -94,6 +127,8 @@ pub type uv_stream_t = c_void;\n pub type uv_fs_t = c_void;\n pub type uv_udp_send_t = c_void;\n pub type uv_getaddrinfo_t = c_void;\n+pub type uv_process_t = c_void;\n+pub type uv_pipe_t = c_void;\n \n pub struct uv_timespec_t {\n     tv_sec: libc::c_long,\n@@ -178,6 +213,9 @@ pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n                                            status: c_int,\n                                            res: *addrinfo);\n+pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n+                                    exit_status: c_int,\n+                                    term_signal: c_int);\n \n pub type sockaddr = c_void;\n pub type sockaddr_in = c_void;\n@@ -226,6 +264,11 @@ pub struct addrinfo {\n     ai_next: *addrinfo\n }\n \n+#[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n+#[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n+#[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n+#[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n+\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -787,6 +830,45 @@ pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n     rust_uv_fs_req_cleanup(req);\n }\n \n+pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n+                    options: uv_process_options_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_spawn(loop_ptr, result, options);\n+}\n+\n+pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_kill(p, signum);\n+}\n+\n+pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    return rust_uv_process_pid(p);\n+}\n+\n+pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n+                                        flags: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_flags(c, flags);\n+}\n+\n+pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n+                                     fd: libc::c_int) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_fd(c, fd);\n+}\n+\n+pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                         stream: *uv_stream_t) {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_set_stdio_container_stream(c, stream);\n+}\n+\n+pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    rust_uv_pipe_init(loop_ptr, p, ipc)\n+}\n+\n // data access helpers\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -1009,4 +1091,13 @@ extern {\n                            node: *c_char, service: *c_char,\n                            hints: *addrinfo) -> c_int;\n     fn rust_uv_freeaddrinfo(ai: *addrinfo);\n+    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n+                     options: uv_process_options_t) -> c_int;\n+    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n+    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n+    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n+    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n+                                       stream: *uv_stream_t);\n+    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n }"}, {"sha": "3e9b8ba136eaa05e31537fd48a800eba46328e3e", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -602,3 +602,38 @@ extern \"C\" int\n rust_uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {\n   return uv_fs_readdir(loop, req, path, flags, cb);\n }\n+\n+extern \"C\" int\n+rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {\n+  return uv_spawn(loop, p, options);\n+}\n+\n+extern \"C\" int\n+rust_uv_process_kill(uv_process_t *p, int signum) {\n+  return uv_process_kill(p, signum);\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_flags(uv_stdio_container_t *c, int flags) {\n+  c->flags = (uv_stdio_flags) flags;\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_fd(uv_stdio_container_t *c, int fd) {\n+  c->data.fd = fd;\n+}\n+\n+extern \"C\" void\n+rust_set_stdio_container_stream(uv_stdio_container_t *c, uv_stream_t *stream) {\n+  c->data.stream = stream;\n+}\n+\n+extern \"C\" int\n+rust_uv_process_pid(uv_process_t* p) {\n+  return p->pid;\n+}\n+\n+extern \"C\" int\n+rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n+  return uv_pipe_init(loop, p, ipc);\n+}"}, {"sha": "6059d64761446e2eb67816d73866e94a82bc5264", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4dacd736510b2ae28a54489fe88571f1a6de019f/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4dacd736510b2ae28a54489fe88571f1a6de019f", "patch": "@@ -198,3 +198,10 @@ rust_drop_linenoise_lock\n rust_get_test_int\n rust_get_task\n rust_uv_get_loop_from_getaddrinfo_req\n+rust_uv_spawn\n+rust_uv_process_kill\n+rust_set_stdio_container_flags\n+rust_set_stdio_container_fd\n+rust_set_stdio_container_stream\n+rust_uv_process_pid\n+rust_uv_pipe_init"}]}