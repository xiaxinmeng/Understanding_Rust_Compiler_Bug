{"sha": "98e5ee7df02c7812441ac31338819cb3f788f4f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZTVlZTdkZjAyYzc4MTI0NDFhYzMxMzM4ODE5Y2IzZjc4OGY0Zjk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-23T12:54:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-23T12:54:02Z"}, "message": "Rollup merge of #76939 - lcnr:const-evaluatable-cont, r=oli-obk\n\nemit errors during AbstractConst building\n\nThere changes are currently still untested, so I don't expect this to pass CI :laughing:\n\nIt seems to me like this is the direction we want to go in, though we didn't have too much of a discussion about this.\n\nr? @oli-obk", "tree": {"sha": "c4ceb21b50f5b8d67553ca5392bdefa364fe47ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4ceb21b50f5b8d67553ca5392bdefa364fe47ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98e5ee7df02c7812441ac31338819cb3f788f4f9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfa0VqCRBK7hj4Ov3rIwAAdHIIACO63sy9vxlcH4BAHCEPFxjW\nD/4JVfZ2VJyvJuAitmOdFr7+V53sKS4LZU4IOCf+dVtbjG9hRAyNxzcVM3DmZm04\nIqvxbJIIkZT+a6Bz437kc8aoKq+5wTDyXlSDEWT0B8vSTe3ymXzrV2lb4S5Soi8o\nPgZxCaGPaJUyaNilCZKLjbnqLqjre3SrgC+M2iGtGWibcP+k3Zhr1AoZcqdC94y3\nKsEisb0PtiD+0nHOMaPeDL47NeqmSRkp3bd4adiBIC8DYflg8m1vZfu5Kyl2Y3xJ\nWefTja3gIzXqNdzjZxTYamWB74J95PZ8gKbK+FEQM2hxivMRZnV6CvhIDRsx8pk=\n=yr4F\n-----END PGP SIGNATURE-----\n", "payload": "tree c4ceb21b50f5b8d67553ca5392bdefa364fe47ce\nparent a22eb31668e949fb392c417547d2f5da5fbbcc19\nparent 2f893e458a20a159fcf93a9a5b0435ae3ed0a67e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1600865642 +0200\ncommitter GitHub <noreply@github.com> 1600865642 +0200\n\nRollup merge of #76939 - lcnr:const-evaluatable-cont, r=oli-obk\n\nemit errors during AbstractConst building\n\nThere changes are currently still untested, so I don't expect this to pass CI :laughing:\n\nIt seems to me like this is the direction we want to go in, though we didn't have too much of a discussion about this.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98e5ee7df02c7812441ac31338819cb3f788f4f9", "html_url": "https://github.com/rust-lang/rust/commit/98e5ee7df02c7812441ac31338819cb3f788f4f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98e5ee7df02c7812441ac31338819cb3f788f4f9/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a22eb31668e949fb392c417547d2f5da5fbbcc19", "url": "https://api.github.com/repos/rust-lang/rust/commits/a22eb31668e949fb392c417547d2f5da5fbbcc19", "html_url": "https://github.com/rust-lang/rust/commit/a22eb31668e949fb392c417547d2f5da5fbbcc19"}, {"sha": "2f893e458a20a159fcf93a9a5b0435ae3ed0a67e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f893e458a20a159fcf93a9a5b0435ae3ed0a67e", "html_url": "https://github.com/rust-lang/rust/commit/2f893e458a20a159fcf93a9a5b0435ae3ed0a67e"}], "stats": {"total": 252, "additions": 160, "deletions": 92}, "files": [{"sha": "72d54a26b01d4469350c351559bb5f3f2757aadf", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -11,6 +11,7 @@ use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n+use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -1201,13 +1202,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         id: DefIndex,\n-    ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+    ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n         self.root\n             .tables\n             .mir_abstract_consts\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n-            .map_or(None, |v| Some(v.decode((self, tcx))))\n+            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n     }\n \n     fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {"}, {"sha": "556cf419920769015c2c545b93777cd8c5062b4e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -1117,7 +1117,7 @@ impl EncodeContext<'a, 'tcx> {\n             }\n \n             let abstract_const = self.tcx.mir_abstract_const(def_id);\n-            if let Some(abstract_const) = abstract_const {\n+            if let Ok(Some(abstract_const)) = abstract_const {\n                 record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n             }\n         }"}, {"sha": "d41e5680602194c30fc939bd7ae1c9daba845ec9", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -23,6 +23,12 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n+impl From<ErrorReported> for ErrorHandled {\n+    fn from(err: ErrorReported) -> ErrorHandled {\n+        ErrorHandled::Reported(err)\n+    }\n+}\n+\n CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }"}, {"sha": "33854432af5a094237493239e999f2fc290cefd7", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -247,15 +247,15 @@ rustc_queries! {\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const(\n             key: DefId\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n             }\n         }\n         /// Try to build an abstract representation of the given constant.\n         query mir_abstract_const_of_const_arg(\n             key: (LocalDefId, DefId)\n-        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        ) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n             desc {\n                 |tcx|\n                 \"building an abstract representation for the const argument {}\","}, {"sha": "a53075448eddc5980b20dc1ac9331ff94b71b357", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n+#![feature(never_type)]\n #![feature(crate_visibility_modifier)]\n #![feature(or_patterns)]\n #![recursion_limit = \"512\"] // For rustdoc"}, {"sha": "0cfcaca9060336f2140a0e24d7f6e7647518047b", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 115, "deletions": 77, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -8,6 +8,7 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `mir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -31,15 +32,15 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs) {\n+        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs)? {\n             for pred in param_env.caller_bounds() {\n                 match pred.skip_binders() {\n                     ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n                         debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n                         if b_def == def && b_substs == substs {\n                             debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n                             return Ok(());\n-                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)\n+                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)?\n                             .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n                         {\n                             debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -114,15 +115,15 @@ impl AbstractConst<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<DefId>,\n         substs: SubstsRef<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         let inner = match (def.did.as_local(), def.const_param_did) {\n             (Some(did), Some(param_did)) => {\n                 tcx.mir_abstract_const_of_const_arg((did, param_did))?\n             }\n             _ => tcx.mir_abstract_const(def.did)?,\n         };\n \n-        Some(AbstractConst { inner, substs })\n+        Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n     #[inline]\n@@ -148,53 +149,83 @@ struct AbstractConstBuilder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            return None;\n-        }\n+    fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n+        self.tcx\n+            .sess\n+            .struct_span_err(self.body.span, \"overly complex generic constant\")\n+            .span_label(span.unwrap_or(self.body.span), msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .emit();\n \n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return None;\n-        }\n+        Err(ErrorReported)\n+    }\n \n-        Some(AbstractConstBuilder {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n+        let mut builder = AbstractConstBuilder {\n             tcx,\n             body,\n             nodes: IndexVec::new(),\n             locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n             checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        })\n+        };\n+\n+        // We don't have to look at concrete constants, as we\n+        // can just evaluate them.\n+        if !body.is_polymorphic {\n+            return Ok(None);\n+        }\n+\n+        // We only allow consts without control flow, so\n+        // we check for cycles here which simplifies the\n+        // rest of this implementation.\n+        if body.is_cfg_cyclic() {\n+            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n+        }\n+\n+        Ok(Some(builder))\n     }\n-    fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n+\n+    fn place_to_local(\n+        &mut self,\n+        span: Span,\n+        p: &mir::Place<'tcx>,\n+    ) -> Result<mir::Local, ErrorReported> {\n         const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n+        // Do not allow any projections.\n+        //\n+        // One exception are field accesses on the result of checked operations,\n+        // which are required to support things like `1 + 2`.\n+        if let Some(p) = p.as_local() {\n+            debug_assert!(!self.checked_op_locals.contains(p));\n+            Ok(p)\n+        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n+            // Only allow field accesses if the given local\n+            // contains the result of a checked operation.\n+            if self.checked_op_locals.contains(p.local) {\n+                Ok(p.local)\n+            } else {\n+                self.error(Some(span), \"unsupported projection\")?;\n+            }\n+        } else {\n+            self.error(Some(span), \"unsupported projection\")?;\n+        }\n+    }\n+\n+    fn operand_to_node(\n+        &mut self,\n+        span: Span,\n+        op: &mir::Operand<'tcx>,\n+    ) -> Result<NodeId, ErrorReported> {\n+        debug!(\"operand_to_node: op={:?}\", op);\n         match op {\n             mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                // Do not allow any projections.\n-                //\n-                // One exception are field accesses on the result of checked operations,\n-                // which are required to support things like `1 + 2`.\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    Some(self.locals[p])\n-                } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow field accesses if the given local\n-                    // contains the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        Some(self.locals[p.local])\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n+                let local = self.place_to_local(span, p)?;\n+                Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Some(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n         }\n     }\n \n@@ -217,44 +248,45 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Option<()> {\n+    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = place.as_local()?;\n+                let local = self.place_to_local(stmt.source_info.span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(operand)?;\n-                        Some(())\n+                        self.locals[local] =\n+                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n-                            Some(())\n+                            Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(lhs)?;\n-                        let rhs = self.operand_to_node(rhs)?;\n+                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n+                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n                         self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n                         self.checked_op_locals.insert(local);\n-                        Some(())\n+                        Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(operand)?;\n+                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n                         self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n-                        Some(())\n+                        Ok(())\n                     }\n-                    _ => None,\n+                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Some(()),\n-            _ => None,\n+            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Ok(()),\n+            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n         }\n     }\n \n@@ -266,11 +298,11 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     fn build_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n-    ) -> Option<Option<mir::BasicBlock>> {\n+    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n         debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n         match terminator.kind {\n-            TerminatorKind::Goto { target } => Some(Some(target)),\n-            TerminatorKind::Return => Some(None),\n+            TerminatorKind::Goto { target } => Ok(Some(target)),\n+            TerminatorKind::Return => Ok(None),\n             TerminatorKind::Call {\n                 ref func,\n                 ref args,\n@@ -288,17 +320,17 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 //\n                 // This is currently fairly irrelevant as it requires `const Trait`s.\n                 from_hir_call: true,\n-                fn_span: _,\n+                fn_span,\n             } => {\n-                let local = place.as_local()?;\n-                let func = self.operand_to_node(func)?;\n+                let local = self.place_to_local(fn_span, place)?;\n+                let func = self.operand_to_node(fn_span, func)?;\n                 let args = self.tcx.arena.alloc_from_iter(\n                     args.iter()\n-                        .map(|arg| self.operand_to_node(arg))\n-                        .collect::<Option<Vec<NodeId>>>()?,\n+                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n+                        .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n                 self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n-                Some(Some(target))\n+                Ok(Some(target))\n             }\n             // We only allow asserts for checked operations.\n             //\n@@ -315,19 +347,19 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n-                        return Some(Some(target));\n+                        return Ok(Some(target));\n                     }\n                 }\n \n-                None\n+                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n             }\n-            _ => None,\n+            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n         }\n     }\n \n     /// Builds the abstract const by walking the mir from start to finish\n     /// and bailing out when encountering an unsupported operation.\n-    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+    fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n         let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n         // We checked for a cyclic cfg above, so this should terminate.\n         loop {\n@@ -339,7 +371,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Some(self.tcx.arena.alloc_from_iter(self.nodes));\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n             }\n         }\n     }\n@@ -349,7 +381,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n pub(super) fn mir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Option<&'tcx [Node<'tcx>]> {\n+) -> Result<Option<&'tcx [mir::abstract_const::Node<'tcx>]>, ErrorReported> {\n     if tcx.features().const_evaluatable_checked {\n         match tcx.def_kind(def.did) {\n             // FIXME(const_evaluatable_checked): We currently only do this for anonymous constants,\n@@ -358,12 +390,12 @@ pub(super) fn mir_abstract_const<'tcx>(\n             //\n             // Right now we do neither of that and simply always fail to unify them.\n             DefKind::AnonConst => (),\n-            _ => return None,\n+            _ => return Ok(None),\n         }\n         let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.build()\n+        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n     } else {\n-        None\n+        Ok(None)\n     }\n }\n \n@@ -374,13 +406,19 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n         (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n     ),\n ) -> bool {\n-    if let Some(a) = AbstractConst::new(tcx, a, a_substs) {\n-        if let Some(b) = AbstractConst::new(tcx, b, b_substs) {\n-            return try_unify(tcx, a, b);\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a, a_substs)? {\n+            if let Some(b) = AbstractConst::new(tcx, b, b_substs)? {\n+                return Ok(try_unify(tcx, a, b));\n+            }\n         }\n-    }\n \n-    false\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|ErrorReported| true)\n+    // FIXME(const_evaluatable_checked): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `ErrorReported`.\n }\n \n /// Tries to unify two abstract constants using structural equality."}, {"sha": "32f43591e37b9d33f777aec73be281a5b187fa06", "filename": "src/test/ui/const-generics/const_evaluatable_checked/closures.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -0,0 +1,6 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+//~^ ERROR overly complex generic constant\n+\n+fn main() {}"}, {"sha": "9f0b7252e8326ff2893c633d2ea735670ed8de3c", "filename": "src/test/ui/const-generics/const_evaluatable_checked/closures.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fclosures.stderr?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -0,0 +1,12 @@\n+error: overly complex generic constant\n+  --> $DIR/closures.rs:3:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n+   |                                   ^^^^-------^^\n+   |                                       |\n+   |                                       unsupported rvalue\n+   |\n+   = help: consider moving this anonymous constant into a `const` function\n+\n+error: aborting due to previous error\n+"}, {"sha": "a6bb39208a42d9d2b16a0c0ec4013d652ac18f20", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -4,8 +4,8 @@\n // We do not yet want to support let-bindings in abstract consts,\n // so this test should keep failing for now.\n fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-    //~^ ERROR constant expression depends\n-    //~| ERROR constant expression depends\n+    //~^ ERROR overly complex generic constant\n+    //~| ERROR overly complex generic constant\n     Default::default()\n }\n "}, {"sha": "5749defb3e12c679227424fb7eef06d8bf66ad61", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98e5ee7df02c7812441ac31338819cb3f788f4f9/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr?ref=98e5ee7df02c7812441ac31338819cb3f788f4f9", "patch": "@@ -1,18 +1,22 @@\n-error: constant expression depends on a generic parameter\n-  --> $DIR/let-bindings.rs:6:91\n+error: overly complex generic constant\n+  --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                                           ^^^^^^^ required by this bound in `test::{{constant}}#0`\n+   |                                                                    ^^^^^^-^^^^^^^^^^^^^\n+   |                                                                          |\n+   |                                                                          unsupported statement\n    |\n-   = note: this may fail depending on what value the parameter takes\n+   = help: consider moving this anonymous constant into a `const` function\n \n-error: constant expression depends on a generic parameter\n-  --> $DIR/let-bindings.rs:6:30\n+error: overly complex generic constant\n+  --> $DIR/let-bindings.rs:6:35\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^-^^^^^^^^^^^^^\n+   |                                         |\n+   |                                         unsupported statement\n    |\n-   = note: this may fail depending on what value the parameter takes\n+   = help: consider moving this anonymous constant into a `const` function\n \n error: aborting due to 2 previous errors\n "}]}