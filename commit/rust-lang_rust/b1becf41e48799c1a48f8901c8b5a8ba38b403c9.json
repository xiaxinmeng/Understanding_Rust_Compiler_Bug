{"sha": "b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYmVjZjQxZTQ4Nzk5YzFhNDhmODkwMWM4YjVhOGJhMzhiNDAzYzk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-07-14T19:32:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-14T19:32:45Z"}, "message": "Merge pull request #1099 from Manishearth/fix\n\nSome small fixes", "tree": {"sha": "d7b8ad5cccf949582010d9fc421a49cc2bc63b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b8ad5cccf949582010d9fc421a49cc2bc63b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "html_url": "https://github.com/rust-lang/rust/commit/b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99b1ebbb33c5dcf02adaaa1c1e4ae101cc34abd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/99b1ebbb33c5dcf02adaaa1c1e4ae101cc34abd4", "html_url": "https://github.com/rust-lang/rust/commit/99b1ebbb33c5dcf02adaaa1c1e4ae101cc34abd4"}, {"sha": "ea665c38f1ad049935a775d19082adedede9e00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea665c38f1ad049935a775d19082adedede9e00e", "html_url": "https://github.com/rust-lang/rust/commit/ea665c38f1ad049935a775d19082adedede9e00e"}], "stats": {"total": 147, "additions": 84, "deletions": 63}, "files": [{"sha": "755c325fcbc36858c685db4d6d9d869d36514524", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -2,17 +2,17 @@ use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n-use rustc::ty::subst::{Subst, TypeSpace};\n+use rustc::ty::subst::TypeSpace;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint,\n-            span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n+            match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n+            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::MethodArgs;\n use utils::paths;\n use utils::sugg;\n@@ -471,7 +471,7 @@ impl LateLintPass for Pass {\n \n                     // check conventions w.r.t. conversion method names and predicates\n                     let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n-                    let is_copy = is_copy(cx, ty, item);\n+                    let is_copy = is_copy(cx, ty, item.id);\n                     for &(ref conv, self_kinds) in &CONVENTIONS {\n                         if_let_chain! {[\n                             conv.check(&name.as_str()),\n@@ -1163,8 +1163,3 @@ fn is_bool(ty: &hir::Ty) -> bool {\n         false\n     }\n }\n-\n-fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, item: &hir::Item) -> bool {\n-    let env = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n-    !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, item.span)\n-}"}, {"sha": "6d3f44036c062384040b5ff35880e15dd7353821", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -25,7 +25,11 @@ declare_lint! {\n ///\n /// **Known problems:** None?\n ///\n-/// **Example:** let (a, b, c, d, e, f, g) = (...);\n+/// **Example:**\n+///\n+/// ```rust\n+/// let (a, b, c, d, e, f, g) = (...);\n+/// ```\n declare_lint! {\n     pub MANY_SINGLE_CHAR_NAMES,\n     Warn,"}, {"sha": "deea50f03039649a6fd1a2aabf6bd33fba375552", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -39,19 +39,19 @@ impl ReturnPass {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n                 StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n-                    self.check_final_expr(cx, expr);\n+                    self.check_final_expr(cx, expr, Some(stmt.span));\n                 }\n                 _ => (),\n             }\n         }\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &Expr, span: Option<Span>) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ExprKind::Ret(Some(ref inner)) => {\n-                self.emit_return_lint(cx, (expr.span, inner.span));\n+                self.emit_return_lint(cx, span.expect(\"`else return` is not possible\"), inner.span);\n             }\n             // a whole block? check it!\n             ExprKind::Block(ref block) => {\n@@ -62,25 +62,25 @@ impl ReturnPass {\n             // (except for unit type functions) so we don't match it\n             ExprKind::If(_, ref ifblock, Some(ref elsexpr)) => {\n                 self.check_block_return(cx, ifblock);\n-                self.check_final_expr(cx, elsexpr);\n+                self.check_final_expr(cx, elsexpr, None);\n             }\n             // a match expr, check all arms\n             ExprKind::Match(_, ref arms) => {\n                 for arm in arms {\n-                    self.check_final_expr(cx, &arm.body);\n+                    self.check_final_expr(cx, &arm.body, Some(arm.body.span));\n                 }\n             }\n             _ => (),\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &EarlyContext, spans: (Span, Span)) {\n-        if in_external_macro(cx, spans.1) {\n+    fn emit_return_lint(&mut self, cx: &EarlyContext, ret_span: Span, inner_span: Span) {\n+        if in_external_macro(cx, inner_span) {\n             return;\n         }\n-        span_lint_and_then(cx, NEEDLESS_RETURN, spans.0, \"unneeded return statement\", |db| {\n-            if let Some(snippet) = snippet_opt(cx, spans.1) {\n-                db.span_suggestion(spans.0, \"remove `return` as shown:\", snippet);\n+        span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded return statement\", |db| {\n+            if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                db.span_suggestion(ret_span, \"remove `return` as shown:\", snippet);\n             }\n         });\n     }"}, {"sha": "bcc4be745c0022d73fefc30b9be24ac557363d51", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -15,7 +15,7 @@ use std::env;\n use std::mem;\n use std::str::FromStr;\n use syntax::ast::{self, LitKind};\n-use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span};\n+use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n@@ -723,3 +723,8 @@ pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n         _ => false,\n     }\n }\n+\n+pub fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, env: NodeId) -> bool {\n+    let env = ty::ParameterEnvironment::for_item(cx.tcx, env);\n+    !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, DUMMY_SP)\n+}"}, {"sha": "cc9d5a5f224b042e0f7256d972ed11077c3058b2", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -1,10 +1,10 @@\n-use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n use rustc::hir::*;\n+use rustc::lint::*;\n+use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use syntax::codemap::Span;\n-use utils::{higher, snippet, span_lint_and_then};\n+use utils::{higher, is_copy, snippet, span_lint_and_then};\n \n /// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n ///\n@@ -35,50 +35,61 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let TypeVariants::TyRef(_, ref ty) = cx.tcx.expr_ty_adjusted(expr).sty,\n-            let TypeVariants::TySlice(..) = ty.ty.sty,\n+            let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.expr_ty_adjusted(expr).sty,\n+            let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n+            let Some(vec_args) = higher::vec_macro(cx, addressee),\n         ], {\n-            check_vec_macro(cx, addressee, expr.span);\n+            check_vec_macro(cx, &vec_args, expr.span);\n         }}\n \n         // search for `for _ in vec![\u2026]`\n-        if let Some((_, arg, _)) = higher::for_loop(expr) {\n+        if_let_chain!{[\n+            let Some((_, arg, _)) = higher::for_loop(expr),\n+            let Some(vec_args) = higher::vec_macro(cx, arg),\n+            is_copy(cx, vec_type(cx.tcx.expr_ty_adjusted(arg)), cx.tcx.map.get_parent(expr.id)),\n+        ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = cx.sess().codemap().source_callsite(arg.span);\n-            check_vec_macro(cx, arg, span);\n-        }\n+            check_vec_macro(cx, &vec_args, span);\n+        }}\n     }\n }\n \n-fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n-    if let Some(vec_args) = higher::vec_macro(cx, vec) {\n-        let snippet = match vec_args {\n-            higher::VecArgs::Repeat(elem, len) => {\n-                if eval_const_expr_partial(cx.tcx, len, ExprTypeChecked, None).is_ok() {\n-                    format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n-                } else {\n-                    return;\n-                }\n+fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n+    let snippet = match *vec_args {\n+        higher::VecArgs::Repeat(elem, len) => {\n+            if eval_const_expr_partial(cx.tcx, len, ExprTypeChecked, None).is_ok() {\n+                format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n+            } else {\n+                return;\n             }\n-            higher::VecArgs::Vec(args) => {\n-                if let Some(last) = args.iter().last() {\n-                    let span = Span {\n-                        lo: args[0].span.lo,\n-                        hi: last.span.hi,\n-                        expn_id: args[0].span.expn_id,\n-                    };\n+        }\n+        higher::VecArgs::Vec(args) => {\n+            if let Some(last) = args.iter().last() {\n+                let span = Span {\n+                    lo: args[0].span.lo,\n+                    hi: last.span.hi,\n+                    expn_id: args[0].span.expn_id,\n+                };\n \n-                    format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n-                } else {\n-                    \"&[]\".into()\n-                }\n+                format!(\"&[{}]\", snippet(cx, span, \"..\")).into()\n+            } else {\n+                \"&[]\".into()\n             }\n-        };\n+        }\n+    };\n \n-        span_lint_and_then(cx, USELESS_VEC, span, \"useless use of `vec!`\", |db| {\n-            db.span_suggestion(span, \"you can use a slice directly\", snippet);\n-        });\n-    }\n+    span_lint_and_then(cx, USELESS_VEC, span, \"useless use of `vec!`\", |db| {\n+        db.span_suggestion(span, \"you can use a slice directly\", snippet);\n+    });\n }\n \n+/// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n+fn vec_type(ty: ty::Ty) -> ty::Ty {\n+    if let ty::TyStruct(_, substs) = ty.sty {\n+        substs.types.get(ty::subst::ParamSpace::TypeSpace, 0)\n+    } else {\n+        panic!(\"The type of `vec!` is a not a struct?\");\n+    }\n+}"}, {"sha": "5a391a358b1891a15492dad6165df6119ea2ab38", "filename": "tests/compile-fail/needless_return.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/tests%2Fcompile-fail%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/tests%2Fcompile-fail%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_return.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -37,12 +37,11 @@ fn test_if_block() -> bool {\n \n fn test_match(x: bool) -> bool {\n     match x {\n-        true => {\n-            return false;\n-            //~^ ERROR unneeded return statement\n-            //~| HELP remove `return` as shown\n-            //~| SUGGESTION false\n-        }\n+        true => return false,\n+        //~^ ERROR unneeded return statement\n+        //~| HELP remove `return` as shown\n+        //~| SUGGESTION false\n+\n         false => {\n             return true;\n             //~^ ERROR unneeded return statement"}, {"sha": "7a790e62116123f77bed1795d96568c3cebb142f", "filename": "tests/compile-fail/vec.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/tests%2Fcompile-fail%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1becf41e48799c1a48f8901c8b5a8ba38b403c9/tests%2Fcompile-fail%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvec.rs?ref=b1becf41e48799c1a48f8901c8b5a8ba38b403c9", "patch": "@@ -3,6 +3,9 @@\n \n #![deny(useless_vec)]\n \n+#[derive(Debug)]\n+struct NonCopy;\n+\n fn on_slice(_: &[u8]) {}\n #[allow(ptr_arg)]\n fn on_vec(_: &Vec<u8>) {}\n@@ -62,6 +65,10 @@ fn main() {\n         //~^ ERROR useless use of `vec!`\n         //~| HELP you can use\n         //~| SUGGESTION for a in &[1, 2, 3] {\n-        println!(\"{}\", a);\n+        println!(\"{:?}\", a);\n+    }\n+\n+    for a in vec![NonCopy, NonCopy] {\n+        println!(\"{:?}\", a);\n     }\n }"}]}