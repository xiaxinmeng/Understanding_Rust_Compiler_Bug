{"sha": "f6dd25bb380880b377bbe654158e85976c891f9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZGQyNWJiMzgwODgwYjM3N2JiZTY1NDE1OGU4NTk3NmM4OTFmOWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:08:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T21:26:42Z"}, "message": "rollup merge of #21713: alexcrichton/second-pass-fmt", "tree": {"sha": "e21c86599de5c9542da1fb872c0fbcf1ce99ddfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e21c86599de5c9542da1fb872c0fbcf1ce99ddfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6dd25bb380880b377bbe654158e85976c891f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6dd25bb380880b377bbe654158e85976c891f9b", "html_url": "https://github.com/rust-lang/rust/commit/f6dd25bb380880b377bbe654158e85976c891f9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6dd25bb380880b377bbe654158e85976c891f9b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83972176293632d4e5fed6aef4b344f7aea7db55", "url": "https://api.github.com/repos/rust-lang/rust/commits/83972176293632d4e5fed6aef4b344f7aea7db55", "html_url": "https://github.com/rust-lang/rust/commit/83972176293632d4e5fed6aef4b344f7aea7db55"}, {"sha": "62273575139a80c2b208a3a27e0c2392b1425be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/62273575139a80c2b208a3a27e0c2392b1425be6", "html_url": "https://github.com/rust-lang/rust/commit/62273575139a80c2b208a3a27e0c2392b1425be6"}], "stats": {"total": 728, "additions": 379, "deletions": 349}, "files": [{"sha": "32fe2bb0a320149fbf30060ac0ee14910e6b8824", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -12,20 +12,22 @@\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value. Destruction is\n-//! deterministic, and will occur as soon as the last owner is gone. It is marked as `Send` because\n-//! it uses atomic reference counting.\n+//! The `Arc<T>` type provides shared ownership of an immutable value.\n+//! Destruction is deterministic, and will occur as soon as the last owner is\n+//! gone. It is marked as `Send` because it uses atomic reference counting.\n //!\n-//! If you do not need thread-safety, and just need shared ownership, consider the [`Rc<T>`\n-//! type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but does not use atomics, making it\n-//! both thread-unsafe as well as significantly faster when updating the reference count.\n+//! If you do not need thread-safety, and just need shared ownership, consider\n+//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+//! does not use atomics, making it both thread-unsafe as well as significantly\n+//! faster when updating the reference count.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n-//! `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but will return `None` if the value\n-//! has already been dropped.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n+//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+//! will return `None` if the value has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n-//! `Arc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+//! as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n@@ -87,8 +89,9 @@ use heap::deallocate;\n ///\n /// # Example\n ///\n-/// In this example, a large vector of floats is shared between several tasks. With simple pipes,\n-/// without `Arc`, a copy would have to be made for each task.\n+/// In this example, a large vector of floats is shared between several tasks.\n+/// With simple pipes, without `Arc`, a copy would have to be made for each\n+/// task.\n ///\n /// ```rust\n /// use std::sync::Arc;"}, {"sha": "ec2a274a45d64fa1afcc5f65f80b0558cb62a5ba", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -1738,6 +1738,7 @@ impl BitvSet {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));"}, {"sha": "9765bb5875efee6766949074891a9ce6ae354d7c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -31,6 +31,7 @@ pub struct EnumSet<E> {\n \n impl<E> Copy for EnumSet<E> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));"}, {"sha": "a526c71c67a5f2b0f613594f11104c3ce2152e51", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -950,11 +950,14 @@ impl FromStr for String {\n }\n \n /// A generic trait for converting a value to a string\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToString {\n     /// Converts the value of `self` to an owned string\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_string(&self) -> String;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     fn to_string(&self) -> String {\n@@ -991,6 +994,7 @@ impl<'a> Str for CowString<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Writer for String {\n     #[inline]\n     fn write_str(&mut self, s: &str) -> fmt::Result {"}, {"sha": "d96b8907197a50e0fd599ea7b077a7f42709a0c1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -1591,13 +1591,6 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     }\n }\n \n-impl<'a> fmt::Writer for Vec<u8> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.push_all(s.as_bytes());\n-        Ok(())\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "2ff67ebd550abb910d5a82eec4b1ad8abb07b9a7", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 145, "deletions": 107, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -10,7 +10,6 @@\n \n //! Utilities for formatting and printing strings\n \n-#![allow(unused_variables)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use any;\n@@ -27,17 +26,23 @@ use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt};\n+use self::rt::v1::Alignment;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n mod num;\n mod float;\n-pub mod rt;\n \n-#[unstable(feature = \"core\",\n-           reason = \"core and I/O reconciliation may alter this definition\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(hidden)]\n+pub mod rt {\n+    #[cfg(stage0)] pub use self::v1::*;\n+    pub mod v1;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n \n@@ -46,8 +51,7 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable(feature = \"core\",\n-           reason = \"core and I/O reconciliation may alter this definition\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Debug)]\n pub struct Error;\n \n@@ -60,8 +64,7 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable(feature = \"core\",\n-           reason = \"waiting for core and I/O reconciliation\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n@@ -73,12 +76,14 @@ pub trait Writer {\n     /// # Errors\n     ///\n     /// This function will return an instance of `FormatError` on error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_str(&mut self, s: &str) -> Result;\n \n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, args: Arguments) -> Result {\n         // This Adapter is needed to allow `self` (of type `&mut\n         // Self`) to be cast to a FormatWriter (below) without\n@@ -104,18 +109,17 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable(feature = \"core\",\n-           reason = \"name may change and implemented traits are also unstable\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n     flags: uint,\n     fill: char,\n-    align: rt::Alignment,\n+    align: rt::v1::Alignment,\n     width: Option<uint>,\n     precision: Option<uint>,\n \n     buf: &'a mut (Writer+'a),\n-    curarg: slice::Iter<'a, Argument<'a>>,\n-    args: &'a [Argument<'a>],\n+    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n+    args: &'a [ArgumentV1<'a>],\n }\n \n // NB. Argument is essentially an optimized partially applied formatting function,\n@@ -127,50 +131,73 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n-pub struct Argument<'a> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(hidden)]\n+pub struct ArgumentV1<'a> {\n     value: &'a Void,\n     formatter: fn(&Void, &mut Formatter) -> Result,\n }\n \n-impl<'a> Argument<'a> {\n+impl<'a> ArgumentV1<'a> {\n     #[inline(never)]\n     fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n         Display::fmt(x, f)\n     }\n \n-    fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new<'b, T>(x: &'b T,\n+                      f: fn(&T, &mut Formatter) -> Result) -> ArgumentV1<'b> {\n         unsafe {\n-            Argument {\n+            ArgumentV1 {\n                 formatter: mem::transmute(f),\n                 value: mem::transmute(x)\n             }\n         }\n     }\n \n-    fn from_uint(x: &uint) -> Argument {\n-        Argument::new(x, Argument::show_uint)\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn from_uint(x: &uint) -> ArgumentV1 {\n+        ArgumentV1::new(x, ArgumentV1::show_uint)\n     }\n \n     fn as_uint(&self) -> Option<uint> {\n-        if self.formatter as uint == Argument::show_uint as uint {\n+        if self.formatter as uint == ArgumentV1::show_uint as uint {\n             Some(unsafe { *(self.value as *const _ as *const uint) })\n         } else {\n             None\n         }\n     }\n }\n \n+// flags available in the v1 format of format_args\n+#[derive(Copy)]\n+#[allow(dead_code)] // SignMinus isn't currently used\n+enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, }\n+\n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"implementation detail of the `format_args!` macro\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new_v1(pieces: &'a [&'a str],\n+                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: pieces,\n+            fmt: None,\n+            args: args\n+        }\n+    }\n+\n+    /// When using the format_args!() macro, this function is used to generate the\n+    /// Arguments structure.\n+    #[doc(hidden)] #[inline]\n+    #[cfg(stage0)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(pieces: &'a [&'a str],\n-               args: &'a [Argument<'a>]) -> Arguments<'a> {\n+               args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: None,\n@@ -185,11 +212,28 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"implementation detail of the `format_args!` macro\")]\n+    #[cfg(stage0)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n-                             fmt: &'a [rt::Argument],\n-                             args: &'a [Argument<'a>]) -> Arguments<'a> {\n+                             fmt: &'a [rt::v1::Argument],\n+                             args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments {\n+            pieces: pieces,\n+            fmt: Some(fmt),\n+            args: args\n+        }\n+    }\n+    /// This function is used to specify nonstandard formatting parameters.\n+    /// The `pieces` array must be at least as long as `fmt` to construct\n+    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n+    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n+    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// unsafety, but will ignore invalid .\n+    #[doc(hidden)] #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn new_v1_formatted(pieces: &'a [&'a str],\n+                            args: &'a [ArgumentV1<'a>],\n+                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n         Arguments {\n             pieces: pieces,\n             fmt: Some(fmt),\n@@ -214,11 +258,11 @@ pub struct Arguments<'a> {\n     pieces: &'a [&'a str],\n \n     // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    fmt: Option<&'a [rt::Argument]>,\n+    fmt: Option<&'a [rt::v1::Argument]>,\n \n     // Dynamic arguments for interpolation, to be interleaved with string\n     // pieces. (Every argument is preceded by a string piece.)\n-    args: &'a [Argument<'a>],\n+    args: &'a [ArgumentV1<'a>],\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -237,20 +281,20 @@ impl<'a> Display for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n+#[unstable(feature = \"old_fmt\")]\n pub trait Show {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is defined in your \\\n-                            crate, add `#[derive(Debug)]` or manually implement it\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted using `:?`; if it is \\\n+                            defined in your crate, add `#[derive(Debug)]` or \\\n+                            manually implement it\"]\n #[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n@@ -264,19 +308,20 @@ impl<T: Show + ?Sized> Debug for T {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n+#[unstable(feature = \"old_fmt\")]\n pub trait String {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n-#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default formatter; try using \\\n-                            `:?` instead if you are using a format string\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be formatted with the default \\\n+                            formatter; try using `:?` instead if you are using \\\n+                            a format string\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Display {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -288,58 +333,58 @@ impl<T: String + ?Sized> Display for T {\n }\n \n /// Format trait for the `o` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable(feature = \"core\",\n-           reason = \"I/O and core have yet to be reconciled\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n@@ -351,16 +396,14 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable(feature = \"core\",\n-           reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n-                     implementation detail which should not otherwise be exported\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n         precision: None,\n         buf: output,\n-        align: rt::AlignUnknown,\n+        align: Alignment::Unknown,\n         fill: ' ',\n         args: args.args,\n         curarg: args.args.iter(),\n@@ -402,7 +445,7 @@ impl<'a> Formatter<'a> {\n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n-    fn run(&mut self, arg: &rt::Argument) -> Result {\n+    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n         // Fill in the format parameters into the formatter\n         self.fill = arg.format.fill;\n         self.align = arg.format.align;\n@@ -412,22 +455,22 @@ impl<'a> Formatter<'a> {\n \n         // Extract the correct argument\n         let value = match arg.position {\n-            rt::ArgumentNext => { *self.curarg.next().unwrap() }\n-            rt::ArgumentIs(i) => self.args[i],\n+            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n+            rt::v1::Position::At(i) => self.args[i],\n         };\n \n         // Then actually do some printing\n         (value.formatter)(value.value, self)\n     }\n \n-    fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n+    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<uint> {\n         match *cnt {\n-            rt::CountIs(n) => Some(n),\n-            rt::CountImplied => None,\n-            rt::CountIsParam(i) => {\n+            rt::v1::Count::Is(n) => Some(n),\n+            rt::v1::Count::Implied => None,\n+            rt::v1::Count::Param(i) => {\n                 self.args[i].as_uint()\n             }\n-            rt::CountIsNextParam => {\n+            rt::v1::Count::NextParam => {\n                 self.curarg.next().and_then(|arg| arg.as_uint())\n             }\n         }\n@@ -437,8 +480,8 @@ impl<'a> Formatter<'a> {\n     // all formatting traits can use.\n \n     /// Performs the correct padding for an integer which has already been\n-    /// emitted into a byte-array. The byte-array should *not* contain the sign\n-    /// for the integer, that will be added by this method.\n+    /// emitted into a str. The str should *not* contain the sign for the\n+    /// integer, that will be added by this method.\n     ///\n     /// # Arguments\n     ///\n@@ -449,27 +492,25 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable(feature = \"core\",\n-               reason = \"definition may change slightly over time\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n                         buf: &str)\n                         -> Result {\n         use char::CharExt;\n-        use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut width = buf.len();\n \n         let mut sign = None;\n         if !is_positive {\n             sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+        } else if self.flags & (1 << (FlagV1::SignPlus as uint)) != 0 {\n             sign = Some('+'); width += 1;\n         }\n \n         let mut prefixed = false;\n-        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+        if self.flags & (1 << (FlagV1::Alternate as uint)) != 0 {\n             prefixed = true; width += prefix.char_len();\n         }\n \n@@ -499,16 +540,16 @@ impl<'a> Formatter<'a> {\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n-            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as uint)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n+                self.with_padding(min - width, Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n                 })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                self.with_padding(min - width, rt::AlignRight, |f| {\n+                self.with_padding(min - width, Alignment::Right, |f| {\n                     try!(write_prefix(f)); f.buf.write_str(buf)\n                 })\n             }\n@@ -526,8 +567,7 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable(feature = \"core\",\n-               reason = \"definition may change slightly over time\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n@@ -561,7 +601,7 @@ impl<'a> Formatter<'a> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                self.with_padding(width - s.char_len(), rt::AlignLeft, |me| {\n+                self.with_padding(width - s.char_len(), Alignment::Left, |me| {\n                     me.buf.write_str(s)\n                 })\n             }\n@@ -570,19 +610,20 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: uint, default: rt::Alignment, f: F) -> Result where\n-        F: FnOnce(&mut Formatter) -> Result,\n+    fn with_padding<F>(&mut self, padding: uint, default: Alignment,\n+                       f: F) -> Result\n+        where F: FnOnce(&mut Formatter) -> Result,\n     {\n         use char::CharExt;\n         let align = match self.align {\n-            rt::AlignUnknown => default,\n+            Alignment::Unknown => default,\n             _ => self.align\n         };\n \n         let (pre_pad, post_pad) = match align {\n-            rt::AlignLeft => (0, padding),\n-            rt::AlignRight | rt::AlignUnknown => (padding, 0),\n-            rt::AlignCenter => (padding / 2, (padding + 1) / 2),\n+            Alignment::Left => (0, padding),\n+            Alignment::Right | Alignment::Unknown => (padding, 0),\n+            Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n         let mut fill = [0u8; 4];\n@@ -604,31 +645,28 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable(feature = \"core\",\n-               reason = \"reconciling core and I/O may alter this definition\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable(feature = \"core\",\n-               reason = \"reconciling core and I/O may alter this definition\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable(feature = \"core\",\n-               reason = \"return type may change and method was just created\")]\n-    pub fn flags(&self) -> uint { self.flags }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flags(&self) -> usize { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn align(&self) -> rt::Alignment { self.align }\n+    pub fn align(&self) -> Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n@@ -649,20 +687,20 @@ impl Display for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n-                       t: &'a T) -> Argument<'a> {\n-    Argument::new(t, f)\n+                       t: &'a T) -> ArgumentV1<'a> {\n+    ArgumentV1::new(t, f)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"implementation detail of the `format_args!` macro\")]\n-pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    Argument::from_uint(s)\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn argumentuint<'a>(s: &'a uint) -> ArgumentV1<'a> {\n+    ArgumentV1::from_uint(s)\n }\n \n // Implementations of the core formatting traits\n@@ -741,9 +779,9 @@ impl Display for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (rt::FlagAlternate as uint);\n+        f.flags |= 1 << (FlagV1::Alternate as uint);\n         let ret = LowerHex::fmt(&(*self as uint), f);\n-        f.flags &= !(1 << (rt::FlagAlternate as uint));\n+        f.flags &= !(1 << (FlagV1::Alternate as uint));\n         ret\n     }\n }\n@@ -899,7 +937,7 @@ impl<'a> Debug for &'a (any::Any+'a) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n@@ -911,7 +949,7 @@ impl<T: Debug> Debug for [T] {\n             }\n             try!(write!(f, \"{:?}\", *x))\n         }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n             try!(write!(f, \"]\"));\n         }\n         Ok(())"}, {"sha": "0b2c1efbc5dee1682228f5e2ea263589265c2ee0", "filename": "src/libcore/fmt/rt.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/83972176293632d4e5fed6aef4b344f7aea7db55/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83972176293632d4e5fed6aef4b344f7aea7db55/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=83972176293632d4e5fed6aef4b344f7aea7db55", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This is an internal module used by the ifmt! runtime. These structures are\n-//! emitted to static arrays to precompile format strings ahead of time.\n-//!\n-//! These definitions are similar to their `ct` equivalents, but differ in that\n-//! these can be statically allocated and are slightly optimized for the runtime\n-\n-#![unstable(feature = \"core\",\n-            reason = \"implementation detail of the `format_args!` macro\")]\n-\n-pub use self::Alignment::*;\n-pub use self::Count::*;\n-pub use self::Position::*;\n-pub use self::Flag::*;\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub struct Argument {\n-    pub position: Position,\n-    pub format: FormatSpec,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub struct FormatSpec {\n-    pub fill: char,\n-    pub align: Alignment,\n-    pub flags: uint,\n-    pub precision: Count,\n-    pub width: Count,\n-}\n-\n-/// Possible alignments that can be requested as part of a formatting directive.\n-#[derive(Copy, PartialEq)]\n-pub enum Alignment {\n-    /// Indication that contents should be left-aligned.\n-    AlignLeft,\n-    /// Indication that contents should be right-aligned.\n-    AlignRight,\n-    /// Indication that contents should be center-aligned.\n-    AlignCenter,\n-    /// No alignment was requested.\n-    AlignUnknown,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub enum Count {\n-    CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n-}\n-\n-#[doc(hidden)]\n-#[derive(Copy)]\n-pub enum Position {\n-    ArgumentNext, ArgumentIs(uint)\n-}\n-\n-/// Flags which can be passed to formatting via a directive.\n-///\n-/// These flags are discovered through the `flags` field of the `Formatter`\n-/// structure. The flag in that structure is a union of these flags into a\n-/// `uint` where each flag's discriminant is the corresponding bit.\n-#[derive(Copy)]\n-pub enum Flag {\n-    /// A flag which enables number formatting to always print the sign of a\n-    /// number.\n-    FlagSignPlus,\n-    /// Currently not a used flag\n-    FlagSignMinus,\n-    /// Indicates that the \"alternate formatting\" for a type should be used.\n-    ///\n-    /// The meaning of this flag is type-specific.\n-    FlagAlternate,\n-    /// Indicates that padding should be done with a `0` character as well as\n-    /// being aware of the sign to be printed.\n-    FlagSignAwareZeroPad,\n-}"}, {"sha": "f0c82759b70560ffce03c6c947b2b7c5622c9d68", "filename": "src/libcore/fmt/rt/v1.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an internal module used by the ifmt! runtime. These structures are\n+//! emitted to static arrays to precompile format strings ahead of time.\n+//!\n+//! These definitions are similar to their `ct` equivalents, but differ in that\n+//! these can be statically allocated and are slightly optimized for the runtime\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#[cfg(stage0)] pub use self::Position::*;\n+\n+#[cfg(stage0)] pub use self::Alignment::Left as AlignLeft;\n+#[cfg(stage0)] pub use self::Alignment::Right as AlignRight;\n+#[cfg(stage0)] pub use self::Alignment::Center as AlignCenter;\n+#[cfg(stage0)] pub use self::Alignment::Unknown as AlignUnknown;\n+#[cfg(stage0)] pub use self::Count::Is as CountIs;\n+#[cfg(stage0)] pub use self::Count::Implied as CountImplied;\n+#[cfg(stage0)] pub use self::Count::Param as CountIsParam;\n+#[cfg(stage0)] pub use self::Count::NextParam as CountIsNextParam;\n+#[cfg(stage0)] pub use self::Position::Next as ArgumentNext;\n+#[cfg(stage0)] pub use self::Position::At as ArgumentIs;\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Argument {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub position: Position,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub format: FormatSpec,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct FormatSpec {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fill: char,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub align: Alignment,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub flags: uint,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub precision: Count,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub width: Count,\n+}\n+\n+/// Possible alignments that can be requested as part of a formatting directive.\n+#[derive(Copy, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Alignment {\n+    /// Indication that contents should be left-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Left,\n+    /// Indication that contents should be right-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Right,\n+    /// Indication that contents should be center-aligned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Center,\n+    /// No alignment was requested.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Unknown,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Count {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Is(usize),\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Param(usize),\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    NextParam,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Implied,\n+}\n+\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Position {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Next,\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    At(usize)\n+}"}, {"sha": "fc7d4e868f746890841e199f139f6f0215fa9062", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -229,7 +229,7 @@\n use self::Result::{Ok, Err};\n \n use clone::Clone;\n-use fmt::Debug;\n+use fmt;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -715,7 +715,7 @@ impl<T, E> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, E: Debug> Result<T, E> {\n+impl<T, E: fmt::Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n     /// # Panics\n@@ -746,7 +746,7 @@ impl<T, E: Debug> Result<T, E> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug, E> Result<T, E> {\n+impl<T: fmt::Debug, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n     /// # Panics"}, {"sha": "6b14592c23b8cc096ede1574e0909ecef270a43a", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -362,19 +362,19 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Option<Id<'a>> {\n+    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n             match chars.next() {\n                 Some(c) if is_letter_or_underscore(c) => { ; },\n-                _ => return None\n+                _ => return Err(())\n             }\n             if !chars.all(is_constituent) {\n-                return None\n+                return Err(())\n             }\n         }\n-        return Some(Id{ name: name });\n+        return Ok(Id{ name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -878,17 +878,17 @@ r#\"digraph syntax_tree {\n     fn simple_id_construction() {\n         let id1 = Id::new(\"hello\");\n         match id1 {\n-            Some(_) => {;},\n-            None => panic!(\"'hello' is not a valid value for id anymore\")\n+            Ok(_) => {;},\n+            Err(..) => panic!(\"'hello' is not a valid value for id anymore\")\n         }\n     }\n \n     #[test]\n     fn badly_formatted_id() {\n         let id2 = Id::new(\"Weird { struct : ure } !!!\");\n         match id2 {\n-            Some(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            None => {;}\n+            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+            Err(..) => {;}\n         }\n     }\n }"}, {"sha": "1f0fe4f1acaeaa37669e606b0fac7a17f1eabfff", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -54,10 +54,10 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).ok().unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n+        dot::Id::new(format!(\"N{}\", i.node_id())).ok().unwrap()\n     }\n \n     fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {"}, {"sha": "460687629e7b545baa4ceb5c8ffdb943f11f0106", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -157,10 +157,10 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n \n impl<'a, 'tcx> dot::Labeller<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn graph_id(&self) -> dot::Id {\n-        dot::Id::new(self.graph_name.as_slice()).unwrap()\n+        dot::Id::new(self.graph_name.as_slice()).ok().unwrap()\n     }\n     fn node_id(&self, n: &Node) -> dot::Id {\n-        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).unwrap()\n+        dot::Id::new(format!(\"node_{}\", self.node_ids.get(n).unwrap())).ok().unwrap()\n     }\n     fn node_label(&self, n: &Node) -> dot::LabelText {\n         match *n {"}, {"sha": "de7d3829487136f18fc6f6e6acaf26fb8899a211", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -3952,8 +3952,8 @@ mod tests {\n         struct ArbitraryType(uint);\n         let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n         hm.insert(ArbitraryType(1), true);\n-        let mut mem_buf = Vec::new();\n-        let mut encoder = Encoder::new(&mut mem_buf as &mut fmt::Writer);\n+        let mut mem_buf = string::String::new();\n+        let mut encoder = Encoder::new(&mut mem_buf);\n         let result = hm.encode(&mut encoder);\n         match result.err().unwrap() {\n             EncoderError::BadHashmapKey => (),"}, {"sha": "2e55c007b551b32e55a9a3e4430a15f8b32995d9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -122,7 +122,7 @@ impl Deref for CString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        String::from_utf8_lossy(self.as_bytes()).fmt(f)\n+        fmt::Debug::fmt(&String::from_utf8_lossy(self.as_bytes()), f)\n     }\n }\n "}, {"sha": "a1d6d097607bf6b9df29149108aef7dd09be5e91", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -411,9 +411,10 @@ pub use core::fmt::{Display, Debug};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;\n-pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n+pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n \n #[doc(hidden)]\n+#[cfg(stage0)]\n pub use core::fmt::{argument, argumentuint};\n \n /// The format function takes a precompiled format string and a list of\n@@ -431,9 +432,7 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable(feature = \"std_misc\",\n-           reason = \"this is an implementation detail of format! and should not \\\n-                     be called directly\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);"}, {"sha": "b47d81ae17364883342274c3608d1ee9f0d7b2a8", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -393,14 +393,15 @@ impl Command {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", String::from_utf8_lossy(self.program.as_bytes())));\n+        try!(write!(f, \"{:?}\", self.program));\n         for arg in self.args.iter() {\n-            try!(write!(f, \" '{}'\", String::from_utf8_lossy(arg.as_bytes())));\n+            try!(write!(f, \" '{:?}'\", arg));\n         }\n         Ok(())\n     }"}, {"sha": "f048dc9a84dc19b11ae7a1927f0ebfa2d8676864", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -382,8 +382,8 @@ impl<T> !Sync for SyncSender<T> {}\n /// A `send` operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n-#[derive(PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n@@ -396,7 +396,7 @@ pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[derive(PartialEq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n@@ -412,8 +412,8 @@ pub enum TryRecvError {\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[derive(PartialEq, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data."}, {"sha": "36dbf1176045741e220c1cacc94f3b4a83ff47dd", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 61, "deletions": 75, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -17,7 +17,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use fmt_macros as parse;\n-use parse::token::{InternedString, special_idents};\n+use parse::token::special_idents;\n use parse::token;\n use ptr::P;\n \n@@ -300,56 +300,35 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    /// These attributes are applied to all statics that this syntax extension\n-    /// will generate.\n-    fn static_attrs(ecx: &ExtCtxt, fmtsp: Span) -> Vec<ast::Attribute> {\n-        // Flag statics as `inline` so LLVM can merge duplicate globals as much\n-        // as possible (which we're generating a whole lot of).\n-        let unnamed = ecx.meta_word(fmtsp, InternedString::new(\"inline\"));\n-        let unnamed = ecx.attribute(fmtsp, unnamed);\n-\n-        // Do not warn format string as dead code\n-        let dead_code = ecx.meta_word(fmtsp, InternedString::new(\"dead_code\"));\n-        let allow_dead_code = ecx.meta_list(fmtsp,\n-                                            InternedString::new(\"allow\"),\n-                                            vec![dead_code]);\n-        let allow_dead_code = ecx.attribute(fmtsp, allow_dead_code);\n-        vec![unnamed, allow_dead_code]\n-    }\n-\n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n-        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"), ecx.ident_of(s)]\n+        vec![ecx.ident_of(\"std\"), ecx.ident_of(\"fmt\"), ecx.ident_of(\"rt\"),\n+             ecx.ident_of(\"v1\"), ecx.ident_of(s)]\n     }\n \n     fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        match c {\n-            parse::CountIs(i) => {\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIs\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n+        let count = |: c, arg| {\n+            let mut path = Context::rtpath(self.ecx, \"Count\");\n+            path.push(self.ecx.ident_of(c));\n+            match arg {\n+                Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n+                None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n             }\n+        };\n+        match c {\n+            parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => {\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                    \"CountImplied\"));\n-                self.ecx.expr_path(path)\n-            }\n-            parse::CountIsNextParam => {\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                    \"CountIsNextParam\"));\n-                self.ecx.expr_path(path)\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n+            parse::CountImplied => count(\"Implied\", None),\n+            parse::CountIsNextParam => count(\"NextParam\", None),\n             parse::CountIsName(n) => {\n                 let i = match self.name_positions.get(n) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n                 let i = i + self.args.len();\n-                self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_usize(sp, i)))\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n         }\n     }\n@@ -373,27 +352,35 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n             parse::NextArgument(ref arg) => {\n                 // Translate the position\n-                let pos = match arg.position {\n-                    // These two have a direct mapping\n-                    parse::ArgumentNext => {\n-                        let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n-                                                                            \"ArgumentNext\"));\n-                        self.ecx.expr_path(path)\n-                    }\n-                    parse::ArgumentIs(i) => {\n-                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_usize(sp, i)))\n-                    }\n-                    // Named arguments are converted to positional arguments at\n-                    // the end of the list of arguments\n-                    parse::ArgumentNamed(n) => {\n-                        let i = match self.name_positions.get(n) {\n-                            Some(&i) => i,\n-                            None => 0, // error already emitted elsewhere\n-                        };\n-                        let i = i + self.args.len();\n-                        self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_usize(sp, i)))\n+                let pos = {\n+                    let pos = |: c, arg| {\n+                        let mut path = Context::rtpath(self.ecx, \"Position\");\n+                        path.push(self.ecx.ident_of(c));\n+                        match arg {\n+                            Some(i) => {\n+                                let arg = self.ecx.expr_usize(sp, i);\n+                                self.ecx.expr_call_global(sp, path, vec![arg])\n+                            }\n+                            None => {\n+                                self.ecx.expr_path(self.ecx.path_global(sp, path))\n+                            }\n+                        }\n+                    };\n+                    match arg.position {\n+                        // These two have a direct mapping\n+                        parse::ArgumentNext => pos(\"Next\", None),\n+                        parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n+\n+                        // Named arguments are converted to positional arguments\n+                        // at the end of the list of arguments\n+                        parse::ArgumentNamed(n) => {\n+                            let i = match self.name_positions.get(n) {\n+                                Some(&i) => i,\n+                                None => 0, // error already emitted elsewhere\n+                            };\n+                            let i = i + self.args.len();\n+                            pos(\"At\", Some(i))\n+                        }\n                     }\n                 };\n \n@@ -417,19 +404,16 @@ impl<'a, 'b> Context<'a, 'b> {\n \n                 // Translate the format\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill));\n+                let align = |:name| {\n+                    let mut p = Context::rtpath(self.ecx, \"Alignment\");\n+                    p.push(self.ecx.ident_of(name));\n+                    self.ecx.path_global(sp, p)\n+                };\n                 let align = match arg.format.align {\n-                    parse::AlignLeft => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignLeft\"))\n-                    }\n-                    parse::AlignRight => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignRight\"))\n-                    }\n-                    parse::AlignCenter => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignCenter\"))\n-                    }\n-                    parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, Context::rtpath(self.ecx, \"AlignUnknown\"))\n-                    }\n+                    parse::AlignLeft => align(\"Left\"),\n+                    parse::AlignRight => align(\"Right\"),\n+                    parse::AlignCenter => align(\"Center\"),\n+                    parse::AlignUnknown => align(\"Unknown\"),\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_usize(sp, arg.format.flags);\n@@ -465,7 +449,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let st = ast::ItemStatic(ty, ast::MutImmutable, slice);\n \n         let name = ecx.ident_of(name);\n-        let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);\n+        let item = ecx.item(fmtsp, name, vec![], st);\n         let decl = respan(fmtsp, ast::DeclItem(item));\n \n         // Wrap the declaration in a block so that it forms a single expression.\n@@ -575,7 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n-            (\"new\", vec![pieces, args_slice])\n+            (\"new_v1\", vec![pieces, args_slice])\n         } else {\n             // Build up the static array which will store our precompiled\n             // nonstandard placeholders, if there are any.\n@@ -587,7 +571,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                             piece_ty,\n                                             self.pieces);\n \n-            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n+            (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n         };\n \n         self.ecx.expr_call_global(self.fmtsp, vec!(\n@@ -624,7 +608,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 return ecx.expr_call_global(sp, vec![\n                         ecx.ident_of(\"std\"),\n                         ecx.ident_of(\"fmt\"),\n-                        ecx.ident_of(\"argumentuint\")], vec![arg])\n+                        ecx.ident_of(\"ArgumentV1\"),\n+                        ecx.ident_of(\"from_uint\")], vec![arg])\n             }\n         };\n \n@@ -636,7 +621,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.expr_call_global(sp, vec![\n                 ecx.ident_of(\"std\"),\n                 ecx.ident_of(\"fmt\"),\n-                ecx.ident_of(\"argument\")], vec![ecx.expr_path(format_fn), arg])\n+                ecx.ident_of(\"ArgumentV1\"),\n+                ecx.ident_of(\"new\")], vec![arg, ecx.expr_path(format_fn)])\n     }\n }\n "}, {"sha": "449788459dcffc8da518cab723b1bbd669acf5f7", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -13,7 +13,6 @@\n #![deny(dead_code)]\n #![feature(libc)]\n #![feature(core)]\n-#![feature(collections)]\n \n extern crate libc;\n "}, {"sha": "bc4bfef4d48c45adfb9696e0bb8862230c441f57", "filename": "src/test/compile-fail/missing_debug_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing_debug_impls.rs?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -11,7 +11,6 @@\n // compile-flags: --crate-type lib\n #![deny(missing_debug_implementations)]\n #![allow(unused, missing_copy_implementations)]\n-#![feature(core)]\n \n use std::fmt;\n "}, {"sha": "b1d38f5dc9b16587a1ca05139d8562f50228740a", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/f6dd25bb380880b377bbe654158e85976c891f9b/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=f6dd25bb380880b377bbe654158e85976c891f9b", "patch": "@@ -41,41 +41,39 @@\n \n \n     ((::std::fmt::format as\n-         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new\n+         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                               as\n-                                                                                              fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})(({\n-                                                                                                                                                                                                        #[inline]\n-                                                                                                                                                                                                        #[allow(dead_code)]\n-                                                                                                                                                                                                        static __STATIC_FMTSTR:\n-                                                                                                                                                                                                               &'static [&'static str]\n-                                                                                                                                                                                                               =\n-                                                                                                                                                                                                            (&([(\"test\"\n-                                                                                                                                                                                                                    as\n-                                                                                                                                                                                                                    &'static str)]\n-                                                                                                                                                                                                                  as\n-                                                                                                                                                                                                                  [&'static str; 1])\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                &'static [&'static str; 1]);\n-                                                                                                                                                                                                        (__STATIC_FMTSTR\n+                                                                                              fn(&[&str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new_v1})(({\n+                                                                                                                                                                                                             static __STATIC_FMTSTR:\n+                                                                                                                                                                                                                    &'static [&'static str]\n+                                                                                                                                                                                                                    =\n+                                                                                                                                                                                                                 (&([(\"test\"\n+                                                                                                                                                                                                                         as\n+                                                                                                                                                                                                                         &'static str)]\n+                                                                                                                                                                                                                       as\n+                                                                                                                                                                                                                       [&'static str; 1])\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     &'static [&'static str; 1]);\n+                                                                                                                                                                                                             (__STATIC_FMTSTR\n+                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                 &'static [&'static str])\n+                                                                                                                                                                                                         }\n                                                                                                                                                                                                             as\n-                                                                                                                                                                                                            &'static [&'static str])\n-                                                                                                                                                                                                    }\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       &[&str]),\n-                                                                                                                                                                                                   (&(match (()\n-                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                ())\n-                                                                                                                                                                                                          {\n-                                                                                                                                                                                                          ()\n-                                                                                                                                                                                                          =>\n-                                                                                                                                                                                                          ([]\n+                                                                                                                                                                                                            &[&str]),\n+                                                                                                                                                                                                        (&(match (()\n+                                                                                                                                                                                                                     as\n+                                                                                                                                                                                                                     ())\n+                                                                                                                                                                                                               {\n+                                                                                                                                                                                                               ()\n+                                                                                                                                                                                                               =>\n+                                                                                                                                                                                                               ([]\n+                                                                                                                                                                                                                   as\n+                                                                                                                                                                                                                   [core::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                           }\n                                                                                                                                                                                                               as\n-                                                                                                                                                                                                              [core::fmt::Argument<'_>; 0]),\n-                                                                                                                                                                                                      }\n-                                                                                                                                                                                                         as\n-                                                                                                                                                                                                         [core::fmt::Argument<'_>; 0])\n-                                                                                                                                                                                                       as\n-                                                                                                                                                                                                       &[core::fmt::Argument<'_>; 0]))\n+                                                                                                                                                                                                              [core::fmt::ArgumentV1<'_>; 0])\n+                                                                                                                                                                                                            as\n+                                                                                                                                                                                                            &[core::fmt::ArgumentV1<'_>; 0]))\n                                                                                              as\n                                                                                              core::fmt::Arguments<'_>))\n         as collections::string::String);"}]}