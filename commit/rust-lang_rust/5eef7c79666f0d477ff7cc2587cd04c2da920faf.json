{"sha": "5eef7c79666f0d477ff7cc2587cd04c2da920faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZWY3Yzc5NjY2ZjBkNDc3ZmY3Y2MyNTg3Y2QwNGMyZGE5MjBmYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-29T23:48:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-29T23:48:17Z"}, "message": "Auto merge of #42902 - petrochenkov:keydcrate, r=jseyfried\n\nMake `$crate` a keyword\n\nFixes https://github.com/rust-lang/rust/issues/42898\n\nr? @jseyfried or @nrc", "tree": {"sha": "dc9dc9811abdaeff444eddc610c0a180c33435da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc9dc9811abdaeff444eddc610c0a180c33435da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eef7c79666f0d477ff7cc2587cd04c2da920faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eef7c79666f0d477ff7cc2587cd04c2da920faf", "html_url": "https://github.com/rust-lang/rust/commit/5eef7c79666f0d477ff7cc2587cd04c2da920faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eef7c79666f0d477ff7cc2587cd04c2da920faf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bfc18a9619a5151ff4f11618db9cd882996ba6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bfc18a9619a5151ff4f11618db9cd882996ba6f", "html_url": "https://github.com/rust-lang/rust/commit/3bfc18a9619a5151ff4f11618db9cd882996ba6f"}, {"sha": "b33fd6d75966411c3934cd6bde07bb1a653b2d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/b33fd6d75966411c3934cd6bde07bb1a653b2d83", "html_url": "https://github.com/rust-lang/rust/commit/b33fd6d75966411c3934cd6bde07bb1a653b2d83"}], "stats": {"total": 307, "additions": 185, "deletions": 122}, "files": [{"sha": "c6f4cd585d7b5d41accf1b189aaa2901ef935fb2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -1527,7 +1527,8 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-            if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+            if segment.name != keywords::CrateRoot.name() &&\n+               segment.name != keywords::DollarCrate.name() {\n                 self.print_name(segment.name)?;\n                 self.print_path_parameters(&segment.parameters, colons_before_params)?;\n             }\n@@ -1554,7 +1555,8 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         word(&mut self.s, \"::\")?\n                     }\n-                    if segment.name != keywords::CrateRoot.name() && segment.name != \"$crate\" {\n+                    if segment.name != keywords::CrateRoot.name() &&\n+                       segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n                         self.print_path_parameters(&segment.parameters, colons_before_params)?;\n                     }"}, {"sha": "4b6b754dca655cd7c77df77e2b1a37b26e59f1f7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -149,14 +149,15 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           view_path.span,\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n-                        } else if source_name == \"$crate\" && full_path.segments.len() == 1 {\n+                        } else if source_name == keywords::DollarCrate.name() &&\n+                                  full_path.segments.len() == 1 {\n                             let crate_root = self.resolve_crate_root(source.ctxt);\n                             let crate_name = match crate_root.kind {\n                                 ModuleKind::Def(_, name) => name,\n                                 ModuleKind::Block(..) => unreachable!(),\n                             };\n                             source.name = crate_name;\n-                            if binding.name == \"$crate\" {\n+                            if binding.name == keywords::DollarCrate.name() {\n                                 binding.name = crate_name;\n                             }\n "}, {"sha": "4bfe4d25ded9373ecdfe3a96e907469320426894", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -2665,7 +2665,8 @@ impl<'a> Resolver<'a> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n+           path[0].name != keywords::CrateRoot.name() &&\n+           path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(&[*path.last().unwrap()], Some(ns), false, span) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n@@ -2718,7 +2719,7 @@ impl<'a> Resolver<'a> {\n             if i == 0 && ns == TypeNS && ident.name == keywords::CrateRoot.name() {\n                 module = Some(self.resolve_crate_root(ident.ctxt.modern()));\n                 continue\n-            } else if i == 0 && ns == TypeNS && ident.name == \"$crate\" {\n+            } else if i == 0 && ns == TypeNS && ident.name == keywords::DollarCrate.name() {\n                 module = Some(self.resolve_crate_root(ident.ctxt));\n                 continue\n             }"}, {"sha": "0fbc596f2e1c24f132ebbbcd292b094503279866", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -128,7 +128,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n-                if ident.name == \"$crate\" {\n+                if ident.name == keywords::DollarCrate.name() {\n                     path.segments[0].identifier.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_root(ident.ctxt);\n                     if !module.is_local() {"}, {"sha": "de8749c43d95c95ec261a8b61d5379e273d4e7b5", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -300,7 +300,7 @@ impl<'a> Classifier<'a> {\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n                     \"$crate\" => Class::KeyWord,\n-                    _ if tas.tok.is_any_keyword() => Class::KeyWord,\n+                    _ if tas.tok.is_reserved_ident() => Class::KeyWord,\n \n                     _ => {\n                         if self.in_macro_nonterminal {"}, {"sha": "ecab801d40853f307f5db177f8fece4496509dfd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -97,9 +97,8 @@ impl Path {\n     }\n \n     pub fn default_to_global(mut self) -> Path {\n-        let name = self.segments[0].identifier.name;\n-        if !self.is_global() && name != \"$crate\" &&\n-           name != keywords::SelfValue.name() && name != keywords::Super.name() {\n+        if !self.is_global() &&\n+           !::parse::token::Ident(self.segments[0].identifier).is_path_segment_keyword() {\n             self.segments.insert(0, PathSegment::crate_root());\n         }\n         self"}, {"sha": "c094a23cefc4a0cec5120c25f4be2fbca3b1565d", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ext::tt::macro_parser;\n use parse::{ParseSess, token};\n use print::pprust;\n-use symbol::{keywords, Symbol};\n+use symbol::keywords;\n use syntax_pos::{DUMMY_SP, Span, BytePos};\n use tokenstream;\n \n@@ -196,7 +196,7 @@ fn parse_tree<I>(tree: tokenstream::TokenTree,\n             Some(tokenstream::TokenTree::Token(ident_span, token::Ident(ident))) => {\n                 let span = Span { lo: span.lo, ..ident_span };\n                 if ident.name == keywords::Crate.name() {\n-                    let ident = ast::Ident { name: Symbol::intern(\"$crate\"), ..ident };\n+                    let ident = ast::Ident { name: keywords::DollarCrate.name(), ..ident };\n                     TokenTree::Token(span, token::Ident(ident))\n                 } else {\n                     TokenTree::Token(span, token::SubstNt(ident))"}, {"sha": "a35b278a4b0649ebbe58b6b0d15139117daaccfa", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -1283,7 +1283,7 @@ impl<'a> StringReader<'a> {\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n-                    if keyword_checking_token.is_any_keyword() &&\n+                    if keyword_checking_token.is_reserved_ident() &&\n                        !keyword_checking_token.is_keyword(keywords::Static) {\n                         self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n                     }"}, {"sha": "64506c4af46919b05831a87d18d5dbea99015231", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -511,14 +511,13 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn this_token_descr(&self) -> String {\n-        let s = self.this_token_to_string();\n-        if self.token.is_strict_keyword() {\n-            format!(\"keyword `{}`\", s)\n-        } else if self.token.is_reserved_keyword() {\n-            format!(\"reserved keyword `{}`\", s)\n-        } else {\n-            format!(\"`{}`\", s)\n-        }\n+        let prefix = match &self.token {\n+            t if t.is_special_ident() => \"reserved identifier \",\n+            t if t.is_used_keyword() => \"keyword \",\n+            t if t.is_unused_keyword() => \"reserved keyword \",\n+            _ => \"\",\n+        };\n+        format!(\"{}`{}`\", prefix, self.this_token_to_string())\n     }\n \n     pub fn unexpected_last<T>(&self, t: &token::Token) -> PResult<'a, T> {\n@@ -637,10 +636,12 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_strict_keywords();\n-        self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i) => {\n+                if self.token.is_reserved_ident() {\n+                    self.span_err(self.span, &format!(\"expected identifier, found {}\",\n+                                                      self.this_token_descr()));\n+                }\n                 self.bump();\n                 Ok(i)\n             }\n@@ -713,25 +714,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&mut self) {\n-        if self.token.is_strict_keyword() {\n-            let token_str = self.this_token_to_string();\n-            let span = self.span;\n-            self.span_err(span,\n-                          &format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str));\n-        }\n-    }\n-\n-    /// Signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&mut self) {\n-        if self.token.is_reserved_keyword() {\n-            let token_str = self.this_token_to_string();\n-            self.fatal(&format!(\"`{}` is a reserved keyword\", token_str)).emit()\n-        }\n-    }\n-\n     fn check_ident(&mut self) -> bool {\n         if self.token.is_ident() {\n             true\n@@ -2301,7 +2283,7 @@ impl<'a> Parser<'a> {\n                     ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span;\n                 } else if self.token.is_keyword(keywords::Let) {\n-                    // Catch this syntax error here, instead of in `check_strict_keywords`, so\n+                    // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n@@ -3540,7 +3522,7 @@ impl<'a> Parser<'a> {\n                 // Parse box pat\n                 let subpat = self.parse_pat()?;\n                 pat = PatKind::Box(subpat);\n-            } else if self.token.is_ident() && !self.token.is_any_keyword() &&\n+            } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n                 // Parse ident @ pat\n                 // This can give false positives and parse nullary enums,\n@@ -3815,7 +3797,7 @@ impl<'a> Parser<'a> {\n \n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n-        self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n+        self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n     fn is_defaultness(&self) -> bool {"}, {"sha": "75969cf2eb85b8022e6cdf9ec1dfe23fa99b1988", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -87,7 +87,7 @@ impl Lit {\n fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::Do.name(),\n@@ -110,7 +110,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n fn ident_can_begin_type(ident: ast::Ident) -> bool {\n     let ident_token: Token = Ident(ident);\n \n-    !ident_token.is_any_keyword() ||\n+    !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::For.name(),\n@@ -315,7 +315,7 @@ impl Token {\n \n     pub fn is_path_start(&self) -> bool {\n         self == &ModSep || self.is_qpath_start() || self.is_path() ||\n-        self.is_path_segment_keyword() || self.is_ident() && !self.is_any_keyword()\n+        self.is_path_segment_keyword() || self.is_ident() && !self.is_reserved_ident()\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n@@ -327,31 +327,41 @@ impl Token {\n         match self.ident() {\n             Some(id) => id.name == keywords::Super.name() ||\n                         id.name == keywords::SelfValue.name() ||\n-                        id.name == keywords::SelfType.name(),\n+                        id.name == keywords::SelfType.name() ||\n+                        id.name == keywords::DollarCrate.name(),\n             None => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a strict or reserved keyword.\n-    pub fn is_any_keyword(&self) -> bool {\n-        self.is_strict_keyword() || self.is_reserved_keyword()\n+    // Returns true for reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n+    pub fn is_special_ident(&self) -> bool {\n+        match self.ident() {\n+            Some(id) => id.name <= keywords::DollarCrate.name(),\n+            _ => false,\n+        }\n     }\n \n-    /// Returns `true` if the token is a strict keyword.\n-    pub fn is_strict_keyword(&self) -> bool {\n+    /// Returns `true` if the token is a keyword used in the language.\n+    pub fn is_used_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n-    pub fn is_reserved_keyword(&self) -> bool {\n+    pub fn is_unused_keyword(&self) -> bool {\n         match self.ident() {\n             Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved_ident(&self) -> bool {\n+        self.is_special_ident() || self.is_used_keyword() || self.is_unused_keyword()\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]"}, {"sha": "6c00e0b9efd7ec23825a0aac6808e5a7c66ed827", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -761,7 +761,7 @@ pub trait PrintState<'a> {\n                         word(self.writer(), \"::\")?\n                     }\n                     if segment.identifier.name != keywords::CrateRoot.name() &&\n-                       segment.identifier.name != \"$crate\" {\n+                       segment.identifier.name != keywords::DollarCrate.name() {\n                         word(self.writer(), &segment.identifier.name.as_str())?;\n                     }\n                 }\n@@ -2375,7 +2375,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()>\n     {\n         if segment.identifier.name != keywords::CrateRoot.name() &&\n-           segment.identifier.name != \"$crate\" {\n+           segment.identifier.name != keywords::DollarCrate.name() {\n             self.print_ident(segment.identifier)?;\n             if let Some(ref parameters) = segment.parameters {\n                 self.print_path_parameters(parameters, colons_before_params)?;"}, {"sha": "debac70545a99d0f2ff39c08f69bd3c006d753db", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -237,76 +237,76 @@ macro_rules! declare_keywords {(\n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n // of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// After modifying this list adjust `is_special_ident`, `is_used_keyword`/`is_unused_keyword`,\n // this should be rarely necessary though if the keywords are kept in alphabetic order.\n declare_keywords! {\n-    // Invalid identifier\n+    // Special reserved identifiers used internally for elided lifetimes,\n+    // unnamed method parameters, crate root module, error recovery etc.\n     (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  Else,           \"else\")\n-    (8,  Enum,           \"enum\")\n-    (9,  Extern,         \"extern\")\n-    (10, False,          \"false\")\n-    (11, Fn,             \"fn\")\n-    (12, For,            \"for\")\n-    (13, If,             \"if\")\n-    (14, Impl,           \"impl\")\n-    (15, In,             \"in\")\n-    (16, Let,            \"let\")\n-    (17, Loop,           \"loop\")\n-    (18, Match,          \"match\")\n-    (19, Mod,            \"mod\")\n-    (20, Move,           \"move\")\n-    (21, Mut,            \"mut\")\n-    (22, Pub,            \"pub\")\n-    (23, Ref,            \"ref\")\n-    (24, Return,         \"return\")\n-    (25, SelfValue,      \"self\")\n-    (26, SelfType,       \"Self\")\n-    (27, Static,         \"static\")\n-    (28, Struct,         \"struct\")\n-    (29, Super,          \"super\")\n-    (30, Trait,          \"trait\")\n-    (31, True,           \"true\")\n-    (32, Type,           \"type\")\n-    (33, Unsafe,         \"unsafe\")\n-    (34, Use,            \"use\")\n-    (35, Where,          \"where\")\n-    (36, While,          \"while\")\n+    (1,  CrateRoot,      \"{{root}}\")\n+    (2,  DollarCrate,    \"$crate\")\n+\n+    // Keywords used in the language.\n+    (3,  As,             \"as\")\n+    (4,  Box,            \"box\")\n+    (5,  Break,          \"break\")\n+    (6,  Const,          \"const\")\n+    (7,  Continue,       \"continue\")\n+    (8,  Crate,          \"crate\")\n+    (9,  Else,           \"else\")\n+    (10, Enum,           \"enum\")\n+    (11, Extern,         \"extern\")\n+    (12, False,          \"false\")\n+    (13, Fn,             \"fn\")\n+    (14, For,            \"for\")\n+    (15, If,             \"if\")\n+    (16, Impl,           \"impl\")\n+    (17, In,             \"in\")\n+    (18, Let,            \"let\")\n+    (19, Loop,           \"loop\")\n+    (20, Match,          \"match\")\n+    (21, Mod,            \"mod\")\n+    (22, Move,           \"move\")\n+    (23, Mut,            \"mut\")\n+    (24, Pub,            \"pub\")\n+    (25, Ref,            \"ref\")\n+    (26, Return,         \"return\")\n+    (27, SelfValue,      \"self\")\n+    (28, SelfType,       \"Self\")\n+    (29, Static,         \"static\")\n+    (30, Struct,         \"struct\")\n+    (31, Super,          \"super\")\n+    (32, Trait,          \"trait\")\n+    (33, True,           \"true\")\n+    (34, Type,           \"type\")\n+    (35, Unsafe,         \"unsafe\")\n+    (36, Use,            \"use\")\n+    (37, Where,          \"where\")\n+    (38, While,          \"while\")\n \n     // Keywords reserved for future use.\n-    (37, Abstract,       \"abstract\")\n-    (38, Alignof,        \"alignof\")\n-    (39, Become,         \"become\")\n-    (40, Do,             \"do\")\n-    (41, Final,          \"final\")\n-    (42, Macro,          \"macro\")\n-    (43, Offsetof,       \"offsetof\")\n-    (44, Override,       \"override\")\n-    (45, Priv,           \"priv\")\n-    (46, Proc,           \"proc\")\n-    (47, Pure,           \"pure\")\n-    (48, Sizeof,         \"sizeof\")\n-    (49, Typeof,         \"typeof\")\n-    (50, Unsized,        \"unsized\")\n-    (51, Virtual,        \"virtual\")\n-    (52, Yield,          \"yield\")\n+    (39, Abstract,       \"abstract\")\n+    (40, Alignof,        \"alignof\")\n+    (41, Become,         \"become\")\n+    (42, Do,             \"do\")\n+    (43, Final,          \"final\")\n+    (44, Macro,          \"macro\")\n+    (45, Offsetof,       \"offsetof\")\n+    (46, Override,       \"override\")\n+    (47, Priv,           \"priv\")\n+    (48, Proc,           \"proc\")\n+    (49, Pure,           \"pure\")\n+    (50, Sizeof,         \"sizeof\")\n+    (51, Typeof,         \"typeof\")\n+    (52, Unsized,        \"unsized\")\n+    (53, Virtual,        \"virtual\")\n+    (54, Yield,          \"yield\")\n \n     // Weak keywords, have special meaning only in specific contexts.\n-    (53, Default,        \"default\")\n-    (54, StaticLifetime, \"'static\")\n-    (55, Union,          \"union\")\n-    (56, Catch,          \"catch\")\n-\n-    // A virtual keyword that resolves to the crate root when used in a lexical scope.\n-    (57, CrateRoot, \"{{root}}\")\n+    (55, Default,        \"default\")\n+    (56, StaticLifetime, \"'static\")\n+    (57, Union,          \"union\")\n+    (58, Catch,          \"catch\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "e221fc6e9e055503a941d42720aabdc0cfe8601e", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod a {}\n+\n+macro_rules! m {\n+    () => {\n+        use a::$crate; //~ ERROR unresolved import `a::$crate`\n+        use a::$crate::b; //~ ERROR unresolved import `a::$crate::b`\n+        type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n+    }\n+}\n+\n+m!();\n+\n+fn main() {}"}, {"sha": "70597a230a886f53365e53bed3db763d7e51ff1b", "filename": "src/test/compile-fail/dollar-crate-is-keyword.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    () => {\n+        struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+\n+        use $crate; // OK\n+                    //~^ WARN `$crate` may not be imported\n+        use $crate as $crate; //~ ERROR expected identifier, found reserved identifier `$crate`\n+                              //~^ WARN `$crate` may not be imported\n+    }\n+}\n+\n+m!();\n+\n+fn main() {}"}, {"sha": "6b5286bf0a7da9e969f4704714fa5b08e59727ef", "filename": "src/test/compile-fail/use-self-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-self-type.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn f() {}\n+    fn g() {\n+        use Self::f; //~ ERROR unresolved import\n+        pub(in Self::f) struct Z; //~ ERROR Use of undeclared type or module `Self`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c7dcaf4137e5d6cc752080e8b9a90e3db1ddf882", "filename": "src/test/parse-fail/macro-keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef7c79666f0d477ff7cc2587cd04c2da920faf/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmacro-keyword.rs?ref=5eef7c79666f0d477ff7cc2587cd04c2da920faf", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-fn macro() {  //~ ERROR `macro` is a reserved keyword\n+fn macro() {  //~ ERROR expected identifier, found reserved keyword `macro`\n }\n \n pub fn main() {"}]}