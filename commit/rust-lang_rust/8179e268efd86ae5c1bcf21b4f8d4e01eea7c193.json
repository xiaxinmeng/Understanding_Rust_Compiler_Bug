{"sha": "8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNzllMjY4ZWZkODZhZTVjMWJjZjIxYjRmOGQ0ZTAxZWVhN2MxOTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T20:33:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T20:33:00Z"}, "message": "Register snapshots", "tree": {"sha": "7e3fd944a844a195a0ed1bed8717db07a2d8ccc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e3fd944a844a195a0ed1bed8717db07a2d8ccc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "html_url": "https://github.com/rust-lang/rust/commit/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be6613e048c889a0aeaff056131c2406259f1fb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/be6613e048c889a0aeaff056131c2406259f1fb4", "html_url": "https://github.com/rust-lang/rust/commit/be6613e048c889a0aeaff056131c2406259f1fb4"}], "stats": {"total": 5989, "additions": 475, "deletions": 5514}, "files": [{"sha": "dcbe419ddb119000a2f8bb07ef8794e6b4ff3528", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1,14 +1,5 @@\n enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n-#[cfg(stage0)]\n-impl mode : cmp::Eq {\n-    pure fn eq(other: &mode) -> bool {\n-        (*other) as int == self as int\n-    }\n-    pure fn ne(other: &mode) -> bool { !self.eq(other) }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl mode : cmp::Eq {\n     pure fn eq(&self, other: &mode) -> bool {\n         (*other) as int == (*self) as int"}, {"sha": "36b76bcbfe26f5e65614971c029a458f691ce961", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -65,25 +65,6 @@ struct Package {\n }\n \n impl Package : cmp::Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &Package) -> bool {\n-        if self.name.lt(&(*other).name) { return true; }\n-        if (*other).name.lt(&self.name) { return false; }\n-        if self.uuid.lt(&(*other).uuid) { return true; }\n-        if (*other).uuid.lt(&self.uuid) { return false; }\n-        if self.url.lt(&(*other).url) { return true; }\n-        if (*other).url.lt(&self.url) { return false; }\n-        if self.method.lt(&(*other).method) { return true; }\n-        if (*other).method.lt(&self.method) { return false; }\n-        if self.description.lt(&(*other).description) { return true; }\n-        if (*other).description.lt(&self.description) { return false; }\n-        if self.tags.lt(&(*other).tags) { return true; }\n-        if (*other).tags.lt(&self.tags) { return false; }\n-        if self.versions.lt(&(*other).versions) { return true; }\n-        return false;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &Package) -> bool {\n         if (*self).name.lt(&(*other).name) { return true; }\n         if (*other).name.lt(&(*self).name) { return false; }\n@@ -100,20 +81,8 @@ impl Package : cmp::Ord {\n         if (*self).versions.lt(&(*other).versions) { return true; }\n         return false;\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &Package) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &Package) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &Package) -> bool { !self.lt(other)     }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &Package) -> bool { !(*self).lt(other)     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &Package) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &Package) -> bool { (*other).lt(&(*self))  }\n }\n \n@@ -160,19 +129,9 @@ struct Options {\n enum Mode { SystemMode, UserMode, LocalMode }\n \n impl Mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Mode) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Mode) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "74f8d6b5cecd80bb75a2a34ca8cbf3af6962d342", "filename": "src/libcore/alternate_crate.rc", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,273 +0,0 @@\n-/*!\n-\n-The Rust core library.\n-\n-The Rust core library provides runtime features required by the language,\n-including the task scheduler and memory allocators, as well as library\n-support for Rust built-in types, platform abstractions, and other commonly\n-used features.\n-\n-`core` includes modules corresponding to each of the integer types, each of\n-the floating point types, the `bool` type, tuples, characters, strings,\n-vectors (`vec`), shared boxes (`box`), and unsafe and borrowed pointers\n-(`ptr`).  Additionally, `core` provides task management and creation (`task`),\n-communication primitives (`comm` and `pipes`), an efficient vector builder\n-(`dvec`), platform abstractions (`os` and `path`), basic I/O abstractions\n-(`io`), common traits (`cmp`, `num`, `to_str`), and complete bindings\n-to the C standard library (`libc`).\n-\n-`core` is linked to all crates by default and its contents imported.\n-Implicitly, all crates behave as if they included the following prologue:\n-\n-    extern mod core;\n-    use core::*;\n-\n-*/\n-\n-#[link(name = \"core\",\n-       vers = \"0.5\",\n-       uuid = \"c70c24a7-5551-4f73-8e37-380b11d80be8\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/libcore\")];\n-\n-#[comment = \"The Rust core library\"];\n-#[license = \"MIT\"];\n-#[crate_type = \"lib\"];\n-\n-// Don't link to core. We are core.\n-#[no_core];\n-\n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n-#[warn(vecs_implicitly_copyable)];\n-#[deny(non_camel_case_types)];\n-\n-// Built-in-type support modules\n-\n-/// Operations and constants for `int`\n-#[path = \"int-template.rs\"]\n-#[merge = \"int-template/intb.rs\"]\n-pub mod int;\n-\n-/// Operations and constants for `i8`\n-#[path = \"int-template.rs\"]\n-#[merge = \"int-template/i8b.rs\"]\n-pub mod i8;\n-\n-/// Operations and constants for `i16`\n-#[path = \"int-template.rs\"]\n-#[merge = \"int-template/i16b.rs\"]\n-pub mod i16;\n-\n-/// Operations and constants for `i32`\n-#[path = \"int-template.rs\"]\n-#[merge = \"int-template/i32b.rs\"]\n-pub mod i32;\n-\n-/// Operations and constants for `i64`\n-#[path = \"int-template.rs\"]\n-#[merge = \"int-template/i64b.rs\"]\n-pub mod i64;\n-\n-/// Operations and constants for `uint`\n-#[path = \"uint-template.rs\"]\n-#[merge = \"uint-template/uintb.rs\"]\n-pub mod uint;\n-\n-/// Operations and constants for `u8`\n-#[path = \"uint-template.rs\"]\n-#[merge = \"uint-template/u8b.rs\"]\n-pub mod u8;\n-\n-/// Operations and constants for `u16`\n-#[path = \"uint-template.rs\"]\n-#[merge = \"uint-template/u16b.rs\"]\n-pub mod u16;\n-\n-/// Operations and constants for `u32`\n-#[path = \"uint-template.rs\"]\n-#[merge = \"uint-template/u32b.rs\"]\n-pub mod u32;\n-\n-/// Operations and constants for `u64`\n-#[path = \"uint-template.rs\"]\n-#[merge = \"uint-template/u64b.rs\"]\n-pub mod u64;\n-\n-\n-pub mod box;\n-pub mod char;\n-pub mod float;\n-pub mod f32;\n-pub mod f64;\n-pub mod str;\n-pub mod ptr;\n-pub mod vec;\n-pub mod at_vec;\n-pub mod bool;\n-pub mod tuple;\n-pub mod unit;\n-pub mod owned;\n-\n-// Ubiquitous-utility-type modules\n-\n-#[cfg(notest)]\n-pub mod ops;\n-pub mod cmp;\n-pub mod num;\n-pub mod hash;\n-pub mod either;\n-pub mod iter;\n-pub mod logging;\n-pub mod option;\n-#[path=\"iter-trait.rs\"]\n-#[merge = \"iter-trait/optionb.rs\"]\n-pub mod option_iter;\n-pub mod result;\n-pub mod to_str;\n-pub mod to_bytes;\n-pub mod from_str;\n-pub mod util;\n-\n-// Data structure modules\n-\n-pub mod dvec;\n-#[path=\"iter-trait.rs\"]\n-#[merge = \"iter-trait/dvecb.rs\"]\n-pub mod dvec_iter;\n-pub mod dlist;\n-#[path=\"iter-trait.rs\"]\n-#[merge = \"iter-trait/dlistb.rs\"]\n-pub mod dlist_iter;\n-pub mod send_map;\n-\n-// Concurrency\n-pub mod comm;\n-#[merge = \"task/mod.rs\"]\n-pub mod task;\n-pub mod pipes;\n-\n-// Runtime and language-primitive support\n-\n-pub mod gc;\n-pub mod io;\n-pub mod libc;\n-pub mod os;\n-pub mod path;\n-pub mod rand;\n-pub mod run;\n-pub mod sys;\n-pub mod cast;\n-pub mod mutable;\n-pub mod flate;\n-pub mod repr;\n-pub mod cleanup;\n-pub mod reflect;\n-pub mod condition;\n-\n-// Modules supporting compiler-generated code\n-// Exported but not part of the public interface\n-\n-pub mod extfmt;\n-// The test harness links against core, so don't include runtime in tests.\n-#[cfg(notest)]\n-#[legacy_exports]\n-pub mod rt;\n-\n-// Ideally not exported, but currently is.\n-pub mod private;\n-\n-// For internal use, not exported.\n-mod unicode;\n-mod cmath;\n-mod stackwalk;\n-\n-// Top-level, visible-everywhere definitions.\n-\n-// Export various ubiquitous types, constructors, methods.\n-\n-pub use option::{Some, None};\n-pub use Option = option::Option;\n-pub use result::{Result, Ok, Err};\n-\n-pub use Path = path::Path;\n-pub use GenericPath = path::GenericPath;\n-pub use WindowsPath = path::WindowsPath;\n-pub use PosixPath = path::PosixPath;\n-\n-pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use str::{StrSlice, Trimmable};\n-pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{MutableVector, MutableCopyableVector};\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-pub use num::Num;\n-pub use ptr::Ptr;\n-pub use to_str::ToStr;\n-\n-// The following exports are the core operators and kinds\n-// The compiler has special knowlege of these so we must not duplicate them\n-// when compiling for testing\n-#[cfg(notest)]\n-pub use ops::{Const, Copy, Send, Owned};\n-#[cfg(notest)]\n-pub use ops::{Drop};\n-#[cfg(notest)]\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(notest)]\n-pub use ops::{Shl, Shr, Index};\n-\n-#[cfg(test)]\n-extern mod coreops(name = \"core\", vers = \"0.5\");\n-\n-#[cfg(test)]\n-pub use coreops::ops::{Const, Copy, Send, Owned};\n-#[cfg(test)]\n-pub use coreops::ops::{Drop};\n-#[cfg(test)]\n-pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n-#[cfg(test)]\n-pub use coreops::ops::{BitXor};\n-#[cfg(test)]\n-pub use coreops::ops::{Shl, Shr, Index};\n-\n-\n-// Export the log levels as global constants. Higher levels mean\n-// more-verbosity. Error is the bottom level, default logging level is\n-// warn-and-below.\n-\n-/// The error log level\n-pub const error : u32 = 1_u32;\n-/// The warning log level\n-pub const warn : u32 = 2_u32;\n-/// The info log level\n-pub const info : u32 = 3_u32;\n-/// The debug log level\n-pub const debug : u32 = 4_u32;\n-\n-// A curious inner-module that's not exported that contains the binding\n-// 'core' so that macro-expanded references to core::error and such\n-// can be resolved within libcore.\n-#[doc(hidden)] // FIXME #3538\n-mod core {\n-    pub const error : u32 = 1_u32;\n-    pub const warn : u32 = 2_u32;\n-    pub const info : u32 = 3_u32;\n-    pub const debug : u32 = 4_u32;\n-}\n-\n-// Similar to above. Some magic to make core testable.\n-#[cfg(test)]\n-mod std {\n-    extern mod std(vers = \"0.5\");\n-    pub use std::test;\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "644cc90ccf68c605a7a03a085769c9ca3f3dfb94", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -66,15 +66,7 @@ pub fn all_values(blk: fn(v: bool)) {\n pub pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n impl bool : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bool) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bool) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bool) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "4b4890f770fcbd6b059fd777b8029c67a612aa8d", "filename": "src/libcore/box.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -28,38 +28,14 @@ pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n }\n \n impl<T:Eq> @const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@const T) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@const T) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@const T) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> @const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@const T) -> bool { *(*self) < *(*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &@const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@const T) -> bool { *(*self) <= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@const T) -> bool { *(*self) >= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "f1c67785aa07f6d1b16b7ebb8e5dd89025c6bbe6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -181,15 +181,7 @@ pub pure fn cmp(a: char, b: char) -> int {\n }\n \n impl char : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &char) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &char) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n "}, {"sha": "97f439d936b2bd7a5df76ba9cba8a45095c7ca7f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -30,17 +30,6 @@ mod nounittest {\n      * default implementations.\n      */\n     #[lang=\"ord\"]\n-    #[cfg(stage0)]\n-    pub trait Ord {\n-        pure fn lt(other: &self) -> bool;\n-        pure fn le(other: &self) -> bool;\n-        pure fn ge(other: &self) -> bool;\n-        pure fn gt(other: &self) -> bool;\n-    }\n-\n-    #[lang=\"ord\"]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Ord {\n         pure fn lt(&self, other: &self) -> bool;\n         pure fn le(&self, other: &self) -> bool;\n@@ -58,15 +47,6 @@ mod nounittest {\n      * a default implementation.\n      */\n     #[lang=\"eq\"]\n-    #[cfg(stage0)]\n-    pub trait Eq {\n-        pure fn eq(other: &self) -> bool;\n-        pure fn ne(other: &self) -> bool;\n-    }\n-\n-    #[lang=\"eq\"]\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Eq {\n         pure fn eq(&self, other: &self) -> bool;\n         pure fn ne(&self, other: &self) -> bool;\n@@ -81,31 +61,13 @@ mod nounittest {\n mod unittest {\n     #[legacy_exports];\n \n-    #[cfg(stage0)]\n-    pub trait Ord {\n-        pure fn lt(other: &self) -> bool;\n-        pure fn le(other: &self) -> bool;\n-        pure fn ge(other: &self) -> bool;\n-        pure fn gt(other: &self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Ord {\n         pure fn lt(&self, other: &self) -> bool;\n         pure fn le(&self, other: &self) -> bool;\n         pure fn ge(&self, other: &self) -> bool;\n         pure fn gt(&self, other: &self) -> bool;\n     }\n \n-    #[cfg(stage0)]\n-    pub trait Eq {\n-        pure fn eq(other: &self) -> bool;\n-        pure fn ne(other: &self) -> bool;\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pub trait Eq {\n         pure fn eq(&self, other: &self) -> bool;\n         pure fn ne(&self, other: &self) -> bool;"}, {"sha": "74f8d6b5cecd80bb75a2a34ca8cbf3af6962d342", "filename": "src/libcore/core.rc", "status": "modified", "additions": 123, "deletions": 79, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1,5 +1,3 @@\n-// DIVERT\n-\n /*!\n \n The Rust core library.\n@@ -47,80 +45,54 @@ Implicitly, all crates behave as if they included the following prologue:\n // Built-in-type support modules\n \n /// Operations and constants for `int`\n-#[path = \"int-template\"]\n-pub mod int {\n-    pub use inst::{ pow };\n-    #[path = \"int.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/intb.rs\"]\n+pub mod int;\n \n /// Operations and constants for `i8`\n-#[path = \"int-template\"]\n-pub mod i8 {\n-    #[path = \"i8.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i8b.rs\"]\n+pub mod i8;\n \n /// Operations and constants for `i16`\n-#[path = \"int-template\"]\n-pub mod i16 {\n-    #[path = \"i16.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i16b.rs\"]\n+pub mod i16;\n \n /// Operations and constants for `i32`\n-#[path = \"int-template\"]\n-pub mod i32 {\n-    #[path = \"i32.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i32b.rs\"]\n+pub mod i32;\n \n /// Operations and constants for `i64`\n-#[path = \"int-template\"]\n-pub mod i64 {\n-    #[path = \"i64.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"int-template.rs\"]\n+#[merge = \"int-template/i64b.rs\"]\n+pub mod i64;\n \n /// Operations and constants for `uint`\n-#[path = \"uint-template\"]\n-pub mod uint {\n-    pub use inst::{\n-        div_ceil, div_round, div_floor, iterate,\n-        next_power_of_two\n-    };\n-    #[path = \"uint.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/uintb.rs\"]\n+pub mod uint;\n \n /// Operations and constants for `u8`\n-#[path = \"uint-template\"]\n-pub mod u8 {\n-    pub use inst::is_ascii;\n-    #[path = \"u8.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u8b.rs\"]\n+pub mod u8;\n \n /// Operations and constants for `u16`\n-#[path = \"uint-template\"]\n-pub mod u16 {\n-    #[path = \"u16.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u16b.rs\"]\n+pub mod u16;\n \n /// Operations and constants for `u32`\n-#[path = \"uint-template\"]\n-pub mod u32 {\n-    #[path = \"u32.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u32b.rs\"]\n+pub mod u32;\n \n /// Operations and constants for `u64`\n-#[path = \"uint-template\"]\n-pub mod u64 {\n-    #[path = \"u64.rs\"]\n-    pub mod inst;\n-}\n+#[path = \"uint-template.rs\"]\n+#[merge = \"uint-template/u64b.rs\"]\n+pub mod u64;\n \n \n pub mod box;\n@@ -148,11 +120,9 @@ pub mod either;\n pub mod iter;\n pub mod logging;\n pub mod option;\n-#[path=\"iter-trait\"]\n-pub mod option_iter {\n-    #[path = \"option.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/optionb.rs\"]\n+pub mod option_iter;\n pub mod result;\n pub mod to_str;\n pub mod to_bytes;\n@@ -162,27 +132,19 @@ pub mod util;\n // Data structure modules\n \n pub mod dvec;\n-#[path=\"iter-trait\"]\n-pub mod dvec_iter {\n-    #[path = \"dvec.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dvecb.rs\"]\n+pub mod dvec_iter;\n pub mod dlist;\n-#[path=\"iter-trait\"]\n-pub mod dlist_iter {\n-    #[path =\"dlist.rs\"]\n-    pub mod inst;\n-}\n+#[path=\"iter-trait.rs\"]\n+#[merge = \"iter-trait/dlistb.rs\"]\n+pub mod dlist_iter;\n pub mod send_map;\n \n // Concurrency\n pub mod comm;\n-pub mod task {\n-    pub mod local_data;\n-    mod local_data_priv;\n-    pub mod spawn;\n-    pub mod rt;\n-}\n+#[merge = \"task/mod.rs\"]\n+pub mod task;\n pub mod pipes;\n \n // Runtime and language-primitive support\n@@ -220,6 +182,88 @@ mod unicode;\n mod cmath;\n mod stackwalk;\n \n+// Top-level, visible-everywhere definitions.\n+\n+// Export various ubiquitous types, constructors, methods.\n+\n+pub use option::{Some, None};\n+pub use Option = option::Option;\n+pub use result::{Result, Ok, Err};\n+\n+pub use Path = path::Path;\n+pub use GenericPath = path::GenericPath;\n+pub use WindowsPath = path::WindowsPath;\n+pub use PosixPath = path::PosixPath;\n+\n+pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use str::{StrSlice, Trimmable};\n+pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n+pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+pub use vec::{MutableVector, MutableCopyableVector};\n+pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use num::Num;\n+pub use ptr::Ptr;\n+pub use to_str::ToStr;\n+\n+// The following exports are the core operators and kinds\n+// The compiler has special knowlege of these so we must not duplicate them\n+// when compiling for testing\n+#[cfg(notest)]\n+pub use ops::{Const, Copy, Send, Owned};\n+#[cfg(notest)]\n+pub use ops::{Drop};\n+#[cfg(notest)]\n+pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(notest)]\n+pub use ops::{Shl, Shr, Index};\n+\n+#[cfg(test)]\n+extern mod coreops(name = \"core\", vers = \"0.5\");\n+\n+#[cfg(test)]\n+pub use coreops::ops::{Const, Copy, Send, Owned};\n+#[cfg(test)]\n+pub use coreops::ops::{Drop};\n+#[cfg(test)]\n+pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n+#[cfg(test)]\n+pub use coreops::ops::{BitXor};\n+#[cfg(test)]\n+pub use coreops::ops::{Shl, Shr, Index};\n+\n+\n+// Export the log levels as global constants. Higher levels mean\n+// more-verbosity. Error is the bottom level, default logging level is\n+// warn-and-below.\n+\n+/// The error log level\n+pub const error : u32 = 1_u32;\n+/// The warning log level\n+pub const warn : u32 = 2_u32;\n+/// The info log level\n+pub const info : u32 = 3_u32;\n+/// The debug log level\n+pub const debug : u32 = 4_u32;\n+\n+// A curious inner-module that's not exported that contains the binding\n+// 'core' so that macro-expanded references to core::error and such\n+// can be resolved within libcore.\n+#[doc(hidden)] // FIXME #3538\n+mod core {\n+    pub const error : u32 = 1_u32;\n+    pub const warn : u32 = 2_u32;\n+    pub const info : u32 = 3_u32;\n+    pub const debug : u32 = 4_u32;\n+}\n+\n+// Similar to above. Some magic to make core testable.\n+#[cfg(test)]\n+mod std {\n+    extern mod std(vers = \"0.5\");\n+    pub use std::test;\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "4bc04566740d52a70aaa7fdcdc0c84d88dd481a6", "filename": "src/libcore/core.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,81 +0,0 @@\n-// Top-level, visible-everywhere definitions.\n-\n-// Export various ubiquitous types, constructors, methods.\n-\n-pub use option::{Some, None};\n-pub use Option = option::Option;\n-pub use result::{Result, Ok, Err};\n-\n-pub use Path = path::Path;\n-pub use GenericPath = path::GenericPath;\n-pub use WindowsPath = path::WindowsPath;\n-pub use PosixPath = path::PosixPath;\n-\n-pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n-pub use str::{StrSlice, Trimmable};\n-pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n-pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{MutableVector, MutableCopyableVector};\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n-pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n-pub use num::Num;\n-pub use ptr::Ptr;\n-pub use to_str::ToStr;\n-\n-// The following exports are the core operators and kinds\n-// The compiler has special knowlege of these so we must not duplicate them\n-// when compiling for testing\n-#[cfg(notest)]\n-pub use ops::{Const, Copy, Send, Owned};\n-#[cfg(notest)]\n-pub use ops::{Drop};\n-#[cfg(notest)]\n-pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n-#[cfg(notest)]\n-pub use ops::{Shl, Shr, Index};\n-\n-#[cfg(test)]\n-extern mod coreops(name = \"core\", vers = \"0.5\");\n-\n-#[cfg(test)]\n-pub use coreops::ops::{Const, Copy, Send, Owned};\n-#[cfg(test)]\n-pub use coreops::ops::{Drop};\n-#[cfg(test)]\n-pub use coreops::ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr};\n-#[cfg(test)]\n-pub use coreops::ops::{BitXor};\n-#[cfg(test)]\n-pub use coreops::ops::{Shl, Shr, Index};\n-\n-\n-// Export the log levels as global constants. Higher levels mean\n-// more-verbosity. Error is the bottom level, default logging level is\n-// warn-and-below.\n-\n-/// The error log level\n-pub const error : u32 = 1_u32;\n-/// The warning log level\n-pub const warn : u32 = 2_u32;\n-/// The info log level\n-pub const info : u32 = 3_u32;\n-/// The debug log level\n-pub const debug : u32 = 4_u32;\n-\n-// A curious inner-module that's not exported that contains the binding\n-// 'core' so that macro-expanded references to core::error and such\n-// can be resolved within libcore.\n-#[doc(hidden)] // FIXME #3538\n-mod core {\n-    pub const error : u32 = 1_u32;\n-    pub const warn : u32 = 2_u32;\n-    pub const info : u32 = 3_u32;\n-    pub const debug : u32 = 4_u32;\n-}\n-\n-// Similar to above. Some magic to make core testable.\n-#[cfg(test)]\n-mod std {\n-    extern mod std(vers = \"0.5\");\n-    pub use std::test;\n-}"}, {"sha": "844f98acb2667e3fc4dfc297fa37dafaf3be8414", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -132,25 +132,6 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Either<T,U> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Either<T,U>) -> bool {\n-        match self {\n-            Left(ref a) => {\n-                match (*other) {\n-                    Left(ref b) => (*a).eq(b),\n-                    Right(_) => false\n-                }\n-            }\n-            Right(ref a) => {\n-                match (*other) {\n-                    Left(_) => false,\n-                    Right(ref b) => (*a).eq(b)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Either<T,U>) -> bool {\n         match (*self) {\n             Left(ref a) => {\n@@ -167,10 +148,6 @@ impl<T:Eq,U:Eq> Either<T,U> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Either<T,U>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Either<T,U>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "eb985a272dff235ee01eb6d3828068b9d83b9721", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -438,21 +438,6 @@ pub mod rt {\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n     pub impl PadMode : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &PadMode) -> bool {\n-            match (self, (*other)) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &PadMode) -> bool {\n             match ((*self), (*other)) {\n                 (PadSigned, PadSigned) => true,\n@@ -465,10 +450,6 @@ pub mod rt {\n                 (PadFloat, _) => false\n             }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &PadMode) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &PadMode) -> bool { !(*self).eq(other) }\n     }\n "}, {"sha": "a5740c71323cf3b877980952e6d7addb8c311212", "filename": "src/libcore/float.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -400,38 +400,14 @@ pub pure fn cos(x: float) -> float { f64::cos(x as f64) as float }\n pub pure fn tan(x: float) -> float { f64::tan(x as f64) as float }\n \n impl float : Eq {\n-    #[cfg(stage0)]\n-    pub pure fn eq(other: &float) -> bool { self == (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &float) -> bool { (*self) == (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn ne(other: &float) -> bool { self != (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &float) -> bool { (*self) != (*other) }\n }\n \n impl float : Ord {\n-    #[cfg(stage0)]\n-    pub pure fn lt(other: &float) -> bool { self < (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &float) -> bool { (*self) < (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn le(other: &float) -> bool { self <= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &float) -> bool { (*self) <= (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn ge(other: &float) -> bool { self >= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &float) -> bool { (*self) >= (*other) }\n-    #[cfg(stage0)]\n-    pub pure fn gt(other: &float) -> bool { self > (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &float) -> bool { (*self) > (*other) }\n }\n "}, {"sha": "e1383ba5ac218f44a031a27fce54b00eff921276", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -55,38 +55,14 @@ pub pure fn abs(i: T) -> T {\n }\n \n impl T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &T) -> bool { return self < (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &T) -> bool { return (*self) < (*other); }\n-    #[cfg(stage0)]\n-    pure fn le(other: &T) -> bool { return self <= (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &T) -> bool { return (*self) <= (*other); }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &T) -> bool { return self >= (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &T) -> bool { return (*self) >= (*other); }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &T) -> bool { return self > (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &T) -> bool { return (*self) > (*other); }\n }\n \n impl T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &T) -> bool { return self == (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &T) -> bool { return self != (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n "}, {"sha": "aa2eccfb343d83164174e889ccdf728a3ae9ad30", "filename": "src/libcore/io.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -516,25 +516,12 @@ pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n pub enum WriterType { Screen, File }\n \n pub impl WriterType : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &WriterType) -> bool {\n-        match (self, (*other)) {\n-            (Screen, Screen) | (File, File) => true,\n-            (Screen, _) | (File, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &WriterType) -> bool {\n         match ((*self), (*other)) {\n             (Screen, Screen) | (File, File) => true,\n             (Screen, _) | (File, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &WriterType) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &WriterType) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "e5fcc7e83eb6045d6d8ad7992a5011768a987c90", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -301,26 +301,6 @@ impl<T: Copy> Option<T> {\n }\n \n impl<T: Eq> Option<T> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Option<T>) -> bool {\n-        match self {\n-            None => {\n-                match (*other) {\n-                    None => true,\n-                    Some(_) => false\n-                }\n-            }\n-            Some(ref self_contents) => {\n-                match (*other) {\n-                    None => false,\n-                    Some(ref other_contents) =>\n-                        (*self_contents).eq(other_contents)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Option<T>) -> bool {\n         match (*self) {\n             None => {\n@@ -338,10 +318,6 @@ impl<T: Eq> Option<T> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Option<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Option<T>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "aaee987b4bd73d68990d5a509a3d852a6db2c392", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -7,38 +7,14 @@\n use cmp::{Eq, Ord};\n \n impl<T:Eq> ~const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~const T) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~const T) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~const T) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~const T) -> bool { *(*self) != *(*other) }\n }\n \n impl<T:Ord> ~const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~const T) -> bool { *(*self) < *(*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &~const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~const T) -> bool { *(*self) <= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~const T) -> bool { *(*self) >= *(*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~const T) -> bool { *(*self) > *(*other) }\n }\n "}, {"sha": "f0fefee9d06d2471d2dbd2e7637454845b4e4b8b", "filename": "src/libcore/path.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -344,44 +344,20 @@ impl PosixPath : ToStr {\n }\n \n impl PosixPath : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &PosixPath) -> bool {\n-        return self.is_absolute == (*other).is_absolute &&\n-            self.components == (*other).components;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &PosixPath) -> bool {\n         return (*self).is_absolute == (*other).is_absolute &&\n             (*self).components == (*other).components;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &PosixPath) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &PosixPath) -> bool { !(*self).eq(other) }\n }\n \n impl WindowsPath : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &WindowsPath) -> bool {\n-        return self.host == (*other).host &&\n-            self.device == (*other).device &&\n-            self.is_absolute == (*other).is_absolute &&\n-            self.components == (*other).components;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &WindowsPath) -> bool {\n         return (*self).host == (*other).host &&\n             (*self).device == (*other).device &&\n             (*self).is_absolute == (*other).is_absolute &&\n             (*self).components == (*other).components;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &WindowsPath) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &WindowsPath) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "9a6f05fe4051931c33e3d3a86b140c249c9e55ba", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -98,19 +98,9 @@ enum State {\n }\n \n impl State : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &State) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &State) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &State) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &State) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "d1566735a3f6cb251faf9d578644c342a3d5ba5a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -208,75 +208,31 @@ impl<T> *mut T: Ptr<T> {\n \n // Equality for pointers\n impl<T> *const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a == b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a == b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &*const T) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &*const T) -> bool { !(*self).eq(other) }\n }\n \n // Comparison for pointers\n impl<T> *const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a < b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a < b;\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a <= b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a <= b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a >= b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n         return a >= b;\n     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &*const T) -> bool unsafe {\n-        let a: uint = cast::reinterpret_cast(&self);\n-        let b: uint = cast::reinterpret_cast(&(*other));\n-        return a > b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &*const T) -> bool unsafe {\n         let a: uint = cast::reinterpret_cast(&(*self));\n         let b: uint = cast::reinterpret_cast(&(*other));\n@@ -286,49 +242,25 @@ impl<T> *const T : Ord {\n \n // Equality for region pointers\n impl<T:Eq> &const T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/const T) -> bool { return *self == *(*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/const T) -> bool {\n         return *(*self) == *(*other);\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/const T) -> bool { return *self != *(*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/const T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n \n // Comparison for region pointers\n impl<T:Ord> &const T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/const T) -> bool { *self < *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/const T) -> bool {\n         *(*self) < *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/const T) -> bool { *self <= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/const T) -> bool {\n         *(*self) <= *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/const T) -> bool { *self >= *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/const T) -> bool {\n         *(*self) >= *(*other)\n     }\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/const T) -> bool { *self > *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/const T) -> bool {\n         *(*self) > *(*other)\n     }"}, {"sha": "3bec87e0af62821fcaaf4541a1bc6253ab7da938", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -516,19 +516,9 @@ enum EnumVisitState {\n }\n \n impl EnumVisitState : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &EnumVisitState) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &EnumVisitState) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &EnumVisitState) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &EnumVisitState) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "20d4bd81056ce64ddba56ad9148710adb41f25f7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -365,25 +365,6 @@ pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n }\n \n impl<T:Eq,U:Eq> Result<T,U> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Result<T,U>) -> bool {\n-        match self {\n-            Ok(ref e0a) => {\n-                match (*other) {\n-                    Ok(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-            Err(ref e0a) => {\n-                match (*other) {\n-                    Err(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Result<T,U>) -> bool {\n         match (*self) {\n             Ok(ref e0a) => {\n@@ -400,10 +381,6 @@ impl<T:Eq,U:Eq> Result<T,U> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Result<T,U>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Result<T,U>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "410d18d66658a1e980a9d497abcae8c00d7043f4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -737,139 +737,61 @@ pure fn gt(a: &str, b: &str) -> bool {\n \n impl &str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n }\n \n impl @str : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@str) -> bool {\n-        eq_slice(self, (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@str) -> bool {\n         eq_slice((*self), (*other))\n     }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@str) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n }\n \n impl ~str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &~str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n }\n \n impl &str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/str) -> bool { gt((*self), (*other)) }\n }\n \n impl @str : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@str) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &@str) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@str) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@str) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n }\n "}, {"sha": "a2b5c3229ad89330d83a255f9c36ba0cde8a8131", "filename": "src/libcore/task.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -43,15 +43,7 @@ pub enum Task {\n }\n \n impl Task : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Task) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Task) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }\n }\n \n@@ -72,25 +64,12 @@ pub enum TaskResult {\n }\n \n impl TaskResult : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TaskResult) -> bool {\n-        match (self, (*other)) {\n-            (Success, Success) | (Failure, Failure) => true,\n-            (Success, _) | (Failure, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TaskResult) -> bool {\n         match ((*self), (*other)) {\n             (Success, Success) | (Failure, Failure) => true,\n             (Success, _) | (Failure, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TaskResult) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TaskResult) -> bool { !(*self).eq(other) }\n }\n \n@@ -114,43 +93,6 @@ pub enum SchedMode {\n }\n \n impl SchedMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &SchedMode) -> bool {\n-        match self {\n-            SingleThreaded => {\n-                match (*other) {\n-                    SingleThreaded => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerCore => {\n-                match (*other) {\n-                    ThreadPerCore => true,\n-                    _ => false\n-                }\n-            }\n-            ThreadPerTask => {\n-                match (*other) {\n-                    ThreadPerTask => true,\n-                    _ => false\n-                }\n-            }\n-            ManualThreads(e0a) => {\n-                match (*other) {\n-                    ManualThreads(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            PlatformThread => {\n-                match (*other) {\n-                    PlatformThread => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &SchedMode) -> bool {\n         match (*self) {\n             SingleThreaded => {\n@@ -185,12 +127,6 @@ impl SchedMode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &SchedMode) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &SchedMode) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "b8537373e655003b5702e1793b46715f56c5702b", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -7,23 +7,11 @@ pub trait LocalData { }\n impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n-        return ptr_a == ptr_b;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@LocalData) -> bool unsafe {\n         let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n         let ptr_b: (uint, uint) = cast::reinterpret_cast(other);\n         return ptr_a == ptr_b;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@LocalData) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "78a3e3c83550374cf28bdb3cbd7c16b61f14efc7", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -95,18 +95,6 @@ impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n }\n \n impl<A: Eq, B: Eq> (A, B) : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &(A, B)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b) => match other {\n-                &(ref other_a, ref other_b) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => match other {\n@@ -116,31 +104,10 @@ impl<A: Eq, B: Eq> (A, B) : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &(A, B)) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord> (A, B) : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &(A, B)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &(A, B)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b) => {\n@@ -155,37 +122,12 @@ impl<A: Ord, B: Ord> (A, B) : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &(A, B)) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &(A, B)) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &(A, B)) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n }\n \n impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &(A, B, C)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b, ref self_c) => match other {\n-                &(ref other_a, ref other_b, ref other_c) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                        && (*self_c).eq(other_c)\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => match other {\n@@ -196,33 +138,10 @@ impl<A: Eq, B: Eq, C: Eq> (A, B, C) : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &(A, B, C)) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n }\n \n impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &(A, B, C)) -> bool {\n-        match self {\n-            (ref self_a, ref self_b, ref self_c) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b, ref other_c) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        if (*other_b).lt(self_b) { return false; }\n-                        if (*self_c).lt(other_c) { return true; }\n-                        return false;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &(A, B, C)) -> bool {\n         match (*self) {\n             (ref self_a, ref self_b, ref self_c) => {\n@@ -239,20 +158,8 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &(A, B, C)) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &(A, B, C)) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &(A, B, C)) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n }\n "}, {"sha": "e96a6766570d93d593656056ab6b20c0cef93830", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -49,38 +49,14 @@ pub pure fn compl(i: T) -> T {\n }\n \n impl T : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &T) -> bool { self < (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &T) -> bool { (*self) < (*other) }\n-    #[cfg(stage0)]\n-    pure fn le(other: &T) -> bool { self <= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &T) -> bool { (*self) <= (*other) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &T) -> bool { self >= (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &T) -> bool { (*self) >= (*other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &T) -> bool { self > (*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &T) -> bool { (*self) > (*other) }\n }\n \n impl T : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &T) -> bool { return self == (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &T) -> bool { return (*self) == (*other); }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &T) -> bool { return self != (*other); }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &T) -> bool { return (*self) != (*other); }\n }\n "}, {"sha": "6110b9eebff3c4736e50bf4840874a6a026457df", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -11,38 +11,14 @@ Functions for the unit type.\n use cmp::{Eq, Ord};\n \n impl () : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn ne(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, _other: &()) -> bool { false }\n }\n \n impl () : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, _other: &()) -> bool { false }\n-    #[cfg(stage0)]\n-    pure fn le(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn ge(_other: &()) -> bool { true }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, _other: &()) -> bool { true }\n-    #[cfg(stage0)]\n-    pure fn gt(_other: &()) -> bool { false }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, _other: &()) -> bool { false }\n }\n "}, {"sha": "47864d0b5627420351289d70ca2f2c63269aa91a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1347,47 +1347,23 @@ pure fn eq<T: Eq>(a: &[T], b: &[T]) -> bool {\n \n impl<T: Eq> &[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: & &self/[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: & &self/[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: & &self/[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: & &self/[T]) -> bool { !(*self).eq(other) }\n }\n \n \n impl<T: Eq> ~[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &~[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &~[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &~[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &~[T]) -> bool { !(*self).eq(other) }\n }\n \n impl<T: Eq> @[T] : Eq {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn eq(other: &@[T]) -> bool { eq(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &@[T]) -> bool { eq((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ne(other: &@[T]) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &@[T]) -> bool { !(*self).eq(other) }\n }\n \n@@ -1414,82 +1390,34 @@ pure fn gt<T: Ord>(a: &[T], b: &[T]) -> bool { lt(b, a)  }\n \n impl<T: Ord> &[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: & &self/[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: & &self/[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: & &self/[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: & &self/[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: & &self/[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: & &self/[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: & &self/[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: & &self/[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> ~[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &~[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &~[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &~[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &~[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &~[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &~[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &~[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &~[T]) -> bool { gt((*self), (*other)) }\n }\n \n impl<T: Ord> @[T] : Ord {\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn lt(other: &@[T]) -> bool { lt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &@[T]) -> bool { lt((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn le(other: &@[T]) -> bool { le(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &@[T]) -> bool { le((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn ge(other: &@[T]) -> bool { ge(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &@[T]) -> bool { ge((*self), (*other)) }\n     #[inline(always)]\n-    #[cfg(stage0)]\n-    pure fn gt(other: &@[T]) -> bool { gt(self, (*other)) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &@[T]) -> bool { gt((*self), (*other)) }\n }\n "}, {"sha": "d8f4fd97c66ef94799e70a8776f968eb4d0ce102", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -34,16 +34,6 @@ use syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n-#[cfg(stage0)]\n-impl test_mode : cmp::Eq {\n-    pure fn eq(other: &test_mode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(other: &test_mode) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl test_mode : cmp::Eq {\n     pure fn eq(&self, other: &test_mode) -> bool {\n         ((*self) as uint) == ((*other) as uint)"}, {"sha": "1d2d0c1f77ca689aef972f1be1f3438489880a50", "filename": "src/librustc/alternate_crate.rc", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,501 +0,0 @@\n-// -*- rust -*-\n-\n-#[link(name = \"rustc\",\n-       vers = \"0.5\",\n-       uuid = \"0ce89b41-2f92-459e-bbc1-8f5fe32f16cf\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rustc\")];\n-\n-#[comment = \"The Rust compiler\"];\n-#[license = \"MIT\"];\n-#[crate_type = \"lib\"];\n-\n-#[no_core];\n-\n-#[legacy_modes];\n-#[legacy_exports];\n-\n-#[allow(vecs_implicitly_copyable)];\n-#[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n-\n-extern mod core(vers = \"0.5\");\n-extern mod std(vers = \"0.5\");\n-extern mod syntax(vers = \"0.5\");\n-\n-use core::*;\n-\n-/*\n-Alternate names for some modules.\n-\n-I am using this to help extract metadata into its own crate. In metadata.rs\n-it redefines all these modules in order to gate access from metadata to the\n-rest of the compiler, then uses these to access the original implementation.\n-*/\n-use util_ = util;\n-use lib_ = lib;\n-use driver_ = driver;\n-use middle_ = middle;\n-use back_ = back;\n-\n-mod middle {\n-    #[legacy_exports];\n-    mod trans {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        #[path = \"middle/trans/inline.rs\"]\n-        mod inline;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/monomorphize.rs\"]\n-        mod monomorphize;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/controlflow.rs\"]\n-        mod controlflow;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/glue.rs\"]\n-        mod glue;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/datum.rs\"]\n-        mod datum;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/callee.rs\"]\n-        mod callee;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/expr.rs\"]\n-        mod expr;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/common.rs\"]\n-        mod common;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/consts.rs\"]\n-        mod consts;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/type_of.rs\"]\n-        mod type_of;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/build.rs\"]\n-        mod build;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/base.rs\"]\n-        mod base;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/alt.rs\"]\n-        mod alt;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/uniq.rs\"]\n-        mod uniq;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/closure.rs\"]\n-        mod closure;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/tvec.rs\"]\n-        mod tvec;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/meth.rs\"]\n-        mod meth;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/foreign.rs\"]\n-        mod foreign;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/reflect.rs\"]\n-        mod reflect;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/shape.rs\"]\n-        mod shape;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/debuginfo.rs\"]\n-        mod debuginfo;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/type_use.rs\"]\n-        mod type_use;\n-        #[legacy_exports]\n-        #[path = \"middle/trans/reachable.rs\"]\n-        mod reachable;\n-        #[path = \"middle/trans/machine.rs\"]\n-        mod machine;\n-        #[path = \"middle/trans/deriving.rs\"]\n-        mod deriving;\n-    }\n-    #[legacy_exports]\n-    #[path = \"middle/ty.rs\"]\n-    mod ty;\n-    #[legacy_exports]\n-    #[path = \"middle/resolve.rs\"]\n-    mod resolve;\n-    #[path = \"middle/typeck.rs\"]\n-    #[merge = \"middle/typeck/mod.rs\"]\n-    pub mod typeck;\n-    #[legacy_exports]\n-    #[path = \"middle/check_loop.rs\"]\n-    mod check_loop;\n-    #[legacy_exports]\n-    #[path = \"middle/check_alt.rs\"]\n-    mod check_alt;\n-    #[legacy_exports]\n-    #[path = \"middle/check_const.rs\"]\n-    mod check_const;\n-    #[legacy_exports]\n-    #[path = \"middle/lint.rs\"]\n-    mod lint;\n-    #[path = \"middle/borrowck.rs\"]\n-    #[merge = \"middle/borrowck/mod.rs\"]\n-    mod borrowck;\n-    #[legacy_exports]\n-    #[path = \"middle/mem_categorization.rs\"]\n-    mod mem_categorization;\n-    #[legacy_exports]\n-    #[path = \"middle/liveness.rs\"]\n-    mod liveness;\n-    #[legacy_exports]\n-    #[path = \"middle/kind.rs\"]\n-    mod kind;\n-    #[legacy_exports]\n-    #[path = \"middle/freevars.rs\"]\n-    mod freevars;\n-    #[legacy_exports]\n-    #[path = \"middle/capture.rs\"]\n-    mod capture;\n-    #[legacy_exports]\n-    #[path = \"middle/pat_util.rs\"]\n-    mod pat_util;\n-    #[legacy_exports]\n-    #[path = \"middle/region.rs\"]\n-    mod region;\n-    #[legacy_exports]\n-    #[path = \"middle/const_eval.rs\"]\n-    mod const_eval;\n-    #[legacy_exports]\n-    #[path = \"middle/astencode.rs\"]\n-    mod astencode;\n-    #[legacy_exports]\n-    #[path = \"middle/lang_items.rs\"]\n-    mod lang_items;\n-    #[legacy_exports]\n-    #[path = \"middle/privacy.rs\"]\n-    mod privacy;\n-}\n-\n-mod front {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"front/config.rs\"]\n-    mod config;\n-    #[legacy_exports]\n-    #[path = \"front/test.rs\"]\n-    mod test;\n-    #[legacy_exports]\n-    #[path = \"front/core_inject.rs\"]\n-    mod core_inject;\n-    #[legacy_exports]\n-    #[path = \"front/intrinsic_inject.rs\"]\n-    mod intrinsic_inject;\n-}\n-\n-mod back {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"back/link.rs\"]\n-    mod link;\n-    #[legacy_exports]\n-    #[path = \"back/abi.rs\"]\n-    mod abi;\n-    #[legacy_exports]\n-    #[path = \"back/upcall.rs\"]\n-    mod upcall;\n-    #[legacy_exports]\n-    #[path = \"back/x86.rs\"]\n-    mod x86;\n-    #[legacy_exports]\n-    #[path = \"back/x86_64.rs\"]\n-    mod x86_64;\n-    #[legacy_exports]\n-    #[path = \"back/rpath.rs\"]\n-    mod rpath;\n-    #[legacy_exports]\n-    #[path = \"back/target_strs.rs\"]\n-    mod target_strs;\n-}\n-\n-#[merge = \"metadata/mod.rs\"]\n-mod metadata;\n-\n-#[merge = \"driver/mod.rs\"]\n-mod driver;\n-\n-mod util {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"util/common.rs\"]\n-    mod common;\n-    #[legacy_exports]\n-    #[path = \"util/ppaux.rs\"]\n-    mod ppaux;\n-}\n-\n-mod lib {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"lib/llvm.rs\"]\n-    mod llvm;\n-}\n-\n-use result::{Ok, Err};\n-use io::ReaderUtil;\n-use std::getopts;\n-use std::map::HashMap;\n-use getopts::{opt_present};\n-use getopts::groups;\n-use syntax::codemap;\n-use syntax::diagnostic;\n-use driver::driver::{host_triple, optgroups, early_error,\n-                     str_input, file_input, build_session_options,\n-                     build_session, build_configuration, parse_pretty,\n-                     pp_mode, pretty_print_input, list_metadata,\n-                     compile_input};\n-use driver::session;\n-use middle::lint;\n-\n-fn version(argv0: &str) {\n-    let mut vers = ~\"unknown version\";\n-    let env_vers = env!(\"CFG_VERSION\");\n-    if env_vers.len() != 0 { vers = env_vers; }\n-    io::println(fmt!(\"%s %s\", argv0, vers));\n-    io::println(fmt!(\"host: %s\", host_triple()));\n-}\n-\n-fn usage(argv0: &str) {\n-    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n-    io::println(groups::usage(message, optgroups()) +\n-                ~\"Additional help:\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc\n-\");\n-}\n-\n-fn describe_warnings() {\n-    io::println(fmt!(\"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n-\"));\n-\n-    let lint_dict = lint::get_lint_dict();\n-    let mut max_key = 0;\n-    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n-    fn padded(max: uint, s: &str) -> ~str {\n-        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n-    }\n-    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |k, v| {\n-        let k = str::replace(k, ~\"_\", ~\"-\");\n-        io::println(fmt!(\"    %s  %7.7s  %s\",\n-                         padded(max_key, k),\n-                         match v.default {\n-                             lint::allow => ~\"allow\",\n-                             lint::warn => ~\"warn\",\n-                             lint::deny => ~\"deny\",\n-                             lint::forbid => ~\"forbid\"\n-                         },\n-                         v.desc));\n-    }\n-    io::println(~\"\");\n-}\n-\n-fn describe_debug_flags() {\n-    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n-    for session::debugging_opts_map().each |pair| {\n-        let (name, desc, _) = *pair;\n-        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n-    }\n-}\n-\n-fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n-    // Don't display log spew by default. Can override with RUST_LOG.\n-    logging::console_off();\n-\n-    let mut args = *args;\n-    let binary = args.shift();\n-\n-    if args.is_empty() { usage(binary); return; }\n-\n-    let matches =\n-        match getopts::groups::getopts(args, optgroups()) {\n-          Ok(m) => m,\n-          Err(f) => {\n-            early_error(demitter, getopts::fail_str(f))\n-          }\n-        };\n-\n-    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n-        usage(binary);\n-        return;\n-    }\n-\n-    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n-                                 getopts::opt_strs(matches, ~\"warn\"));\n-    if lint_flags.contains(&~\"help\") {\n-        describe_warnings();\n-        return;\n-    }\n-\n-    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n-        describe_debug_flags();\n-        return;\n-    }\n-\n-    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n-        version(binary);\n-        return;\n-    }\n-    let input = match vec::len(matches.free) {\n-      0u => early_error(demitter, ~\"no input filename given\"),\n-      1u => {\n-        let ifile = matches.free[0];\n-        if ifile == ~\"-\" {\n-            let src = str::from_bytes(io::stdin().read_whole_stream());\n-            str_input(src)\n-        } else {\n-            file_input(Path(ifile))\n-        }\n-      }\n-      _ => early_error(demitter, ~\"multiple input filenames provided\")\n-    };\n-\n-    let sopts = build_session_options(binary, matches, demitter);\n-    let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n-    let odir = odir.map(|o| Path(*o));\n-    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n-    let ofile = ofile.map(|o| Path(*o));\n-    let cfg = build_configuration(sess, binary, input);\n-    let pretty =\n-        option::map(&getopts::opt_default(matches, ~\"pretty\",\n-                                         ~\"normal\"),\n-                    |a| parse_pretty(sess, *a) );\n-    match pretty {\n-      Some::<pp_mode>(ppm) => {\n-        pretty_print_input(sess, cfg, input, ppm);\n-        return;\n-      }\n-      None::<pp_mode> => {/* continue */ }\n-    }\n-    let ls = opt_present(matches, ~\"ls\");\n-    if ls {\n-        match input {\n-          file_input(ifile) => {\n-            list_metadata(sess, &ifile, io::stdout());\n-          }\n-          str_input(_) => {\n-            early_error(demitter, ~\"can not list metadata for stdin\");\n-          }\n-        }\n-        return;\n-    }\n-\n-    compile_input(sess, cfg, input, &odir, &ofile);\n-}\n-\n-enum monitor_msg {\n-    fatal,\n-    done,\n-}\n-\n-impl monitor_msg : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &monitor_msg) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &monitor_msg) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n-}\n-\n-/*\n-This is a sanity check that any failure of the compiler is performed\n-through the diagnostic module and reported properly - we shouldn't be calling\n-plain-old-fail on any execution path that might be taken. Since we have\n-console logging off by default, hitting a plain fail statement would make the\n-compiler silently exit, which would be terrible.\n-\n-This method wraps the compiler in a subtask and injects a function into the\n-diagnostic emitter which records when we hit a fatal error. If the task\n-fails without recording a fatal error then we've encountered a compiler\n-bug and need to present an error.\n-*/\n-fn monitor(+f: fn~(diagnostic::emitter)) {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n-\n-    match do task::try |move f| {\n-\n-        // The 'diagnostics emitter'. Every error, warning, etc. should\n-        // go through this function.\n-        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n-                           msg: &str, lvl: diagnostic::level) {\n-            if lvl == diagnostic::fatal {\n-                comm::send(ch, fatal);\n-            }\n-            diagnostic::emit(cmsp, msg, lvl);\n-        };\n-\n-        struct finally {\n-            ch: comm::Chan<monitor_msg>,\n-            drop { comm::send(self.ch, done); }\n-        }\n-\n-        let _finally = finally { ch: ch };\n-\n-        f(demitter)\n-    } {\n-        result::Ok(_) => { /* fallthrough */ }\n-        result::Err(_) => {\n-            // Task failed without emitting a fatal diagnostic\n-            if comm::recv(p) == done {\n-                diagnostic::emit(\n-                    None,\n-                    diagnostic::ice_msg(~\"unexpected failure\"),\n-                    diagnostic::error);\n-\n-                for [\n-                    ~\"the compiler hit an unexpected failure path. \\\n-                     this is a bug\",\n-                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n-                     to get further details and report the results \\\n-                     to github.com/mozilla/rust/issues\"\n-                ].each |note| {\n-                    diagnostic::emit(None, *note, diagnostic::note)\n-                }\n-            }\n-            // Fail so the process returns a failure code\n-            fail;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let mut args = os::args();\n-    do monitor |move args, demitter| {\n-        run_compiler(&args, demitter);\n-    }\n-}\n-\n-\n-// Local Variables:\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "36cbdf8c6646d807c99888124e6d44fa48280fa9", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -27,19 +27,9 @@ enum output_type {\n }\n \n impl output_type : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &output_type) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &output_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &output_type) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &output_type) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "9251b7d8374dd3b42e4d0bbb544526aab62b8e78", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -141,19 +141,9 @@ enum compile_upto {\n }\n \n impl compile_upto : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &compile_upto) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &compile_upto) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &compile_upto) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &compile_upto) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "7614bdbb25b39aadcd85644a980be78883ebebca", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -13,38 +13,18 @@ use middle::lint;\n enum os { os_win32, os_macos, os_linux, os_freebsd, }\n \n impl os : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &os) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &os) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &os) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &os) -> bool { !(*self).eq(other) }\n }\n \n enum arch { arch_x86, arch_x86_64, arch_arm, }\n \n impl arch : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &arch) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &arch) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &arch) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &arch) -> bool { !(*self).eq(other) }\n }\n \n@@ -111,19 +91,9 @@ enum OptLevel {\n }\n \n impl OptLevel : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OptLevel) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OptLevel) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OptLevel) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OptLevel) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "fa364700b74d3823d9ca36bafce3f0424c8bfce5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -131,45 +131,6 @@ enum TypeKind {\n }\n \n impl TypeKind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TypeKind) -> bool {\n-        match (self, (*other)) {\n-            (Void, Void) => true,\n-            (Half, Half) => true,\n-            (Float, Float) => true,\n-            (Double, Double) => true,\n-            (X86_FP80, X86_FP80) => true,\n-            (FP128, FP128) => true,\n-            (PPC_FP128, PPC_FP128) => true,\n-            (Label, Label) => true,\n-            (Integer, Integer) => true,\n-            (Function, Function) => true,\n-            (Struct, Struct) => true,\n-            (Array, Array) => true,\n-            (Pointer, Pointer) => true,\n-            (Vector, Vector) => true,\n-            (Metadata, Metadata) => true,\n-            (X86_MMX, X86_MMX) => true,\n-            (Void, _) => false,\n-            (Half, _) => false,\n-            (Float, _) => false,\n-            (Double, _) => false,\n-            (X86_FP80, _) => false,\n-            (FP128, _) => false,\n-            (PPC_FP128, _) => false,\n-            (Label, _) => false,\n-            (Integer, _) => false,\n-            (Function, _) => false,\n-            (Struct, _) => false,\n-            (Array, _) => false,\n-            (Pointer, _) => false,\n-            (Vector, _) => false,\n-            (Metadata, _) => false,\n-            (X86_MMX, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TypeKind) -> bool {\n         match ((*self), (*other)) {\n             (Void, Void) => true,\n@@ -206,10 +167,6 @@ impl TypeKind : cmp::Eq {\n             (X86_MMX, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TypeKind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TypeKind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "62235efb14d4d7e179199b7e24622a9a2dee2863", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -140,19 +140,9 @@ enum Family {\n }\n \n impl Family : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Family) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Family) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Family) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Family) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "b229e810862270d29016f539a01ec5ac6f79ea1d", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -323,50 +323,6 @@ enum bckerr_code {\n }\n \n impl bckerr_code : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bckerr_code) -> bool {\n-        match self {\n-            err_mut_uniq => {\n-                match (*other) {\n-                    err_mut_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            err_mut_variant => {\n-                match (*other) {\n-                    err_mut_variant => true,\n-                    _ => false\n-                }\n-            }\n-            err_root_not_permitted => {\n-                match (*other) {\n-                    err_root_not_permitted => true,\n-                    _ => false\n-                }\n-            }\n-            err_mutbl(e0a) => {\n-                match (*other) {\n-                    err_mutbl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_root_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_root_scope(e0b, e1b) =>\n-                        e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            err_out_of_scope(e0a, e1a) => {\n-                match (*other) {\n-                    err_out_of_scope(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bckerr_code) -> bool {\n         match (*self) {\n             err_mut_uniq => {\n@@ -408,10 +364,6 @@ impl bckerr_code : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bckerr_code) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bckerr_code) -> bool { !(*self).eq(other) }\n }\n \n@@ -420,19 +372,9 @@ impl bckerr_code : cmp::Eq {\n type bckerr = {cmt: cmt, code: bckerr_code};\n \n impl bckerr : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bckerr) -> bool {\n-        self.cmt == (*other).cmt && self.code == (*other).code\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bckerr) -> bool {\n         (*self).cmt == (*other).cmt && (*self).code == (*other).code\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bckerr) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bckerr) -> bool { !(*self).eq(other) }\n }\n \n@@ -463,21 +405,9 @@ fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T, f: fn() -> U) -> U {\n /// Creates and returns a new root_map\n \n impl root_map_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &root_map_key) -> bool {\n-        self.id == (*other).id && self.derefs == (*other).derefs\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &root_map_key) -> bool {\n         (*self).id == (*other).id && (*self).derefs == (*other).derefs\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &root_map_key) -> bool {\n-        ! (self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &root_map_key) -> bool {\n         ! ((*self) == (*other))\n     }"}, {"sha": "66a17333444f6d3f81384da67144a0e06be9183d", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -33,25 +33,6 @@ enum purity_cause {\n }\n \n impl purity_cause : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &purity_cause) -> bool {\n-        match self {\n-            pc_pure_fn => {\n-                match (*other) {\n-                    pc_pure_fn => true,\n-                    _ => false\n-                }\n-            }\n-            pc_cmt(e0a) => {\n-                match (*other) {\n-                    pc_cmt(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &purity_cause) -> bool {\n         match (*self) {\n             pc_pure_fn => {\n@@ -68,10 +49,6 @@ impl purity_cause : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &purity_cause) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &purity_cause) -> bool { !(*self).eq(other) }\n }\n \n@@ -97,19 +74,9 @@ enum assignment_type {\n }\n \n impl assignment_type : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &assignment_type) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &assignment_type) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &assignment_type) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &assignment_type) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "e7716ad984eb38dc61df721db0183ef5aba43c1f", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -126,22 +126,6 @@ enum ctor {\n }\n \n impl ctor : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ctor) -> bool {\n-        match (self, (*other)) {\n-            (single, single) => true,\n-            (variant(did_self), variant(did_other)) => did_self == did_other,\n-            (val(cv_self), val(cv_other)) => cv_self == cv_other,\n-            (range(cv0_self, cv1_self), range(cv0_other, cv1_other)) => {\n-                cv0_self == cv0_other && cv1_self == cv1_other\n-            }\n-            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n-                false\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ctor) -> bool {\n         match ((*self), (*other)) {\n             (single, single) => true,\n@@ -155,10 +139,6 @@ impl ctor : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ctor) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ctor) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "f2915cb27febb60c5ff54ae20f12365979ccca61", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -206,20 +206,6 @@ enum const_val {\n }\n \n impl const_val : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &const_val) -> bool {\n-        match (self, (*other)) {\n-            (const_float(a), const_float(b)) => a == b,\n-            (const_int(a), const_int(b)) => a == b,\n-            (const_uint(a), const_uint(b)) => a == b,\n-            (const_str(a), const_str(b)) => a == b,\n-            (const_bool(a), const_bool(b)) => a == b,\n-            (const_float(_), _) | (const_int(_), _) | (const_uint(_), _) |\n-            (const_str(_), _) | (const_bool(_), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &const_val) -> bool {\n         match ((*self), (*other)) {\n             (const_float(a), const_float(b)) => a == b,\n@@ -231,10 +217,6 @@ impl const_val : cmp::Eq {\n             (const_str(_), _) | (const_bool(_), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &const_val) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &const_val) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "3691f62cc0da9d8b8c89135ce928fc47e298c8c9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -68,19 +68,9 @@ enum lint {\n }\n \n impl lint : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &lint) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &lint) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &lint) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &lint) -> bool { !(*self).eq(other) }\n }\n \n@@ -98,19 +88,9 @@ enum level {\n }\n \n impl level : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &level) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &level) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &level) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "0f1b7489f4318befb758055ee4886e5152e7a3d0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -119,28 +119,12 @@ enum Variable = uint;\n enum LiveNode = uint;\n \n impl Variable : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Variable) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Variable) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n }\n \n impl LiveNode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &LiveNode) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &LiveNode) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n }\n \n@@ -152,37 +136,6 @@ enum LiveNodeKind {\n }\n \n impl LiveNodeKind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &LiveNodeKind) -> bool {\n-        match self {\n-            FreeVarNode(e0a) => {\n-                match (*other) {\n-                    FreeVarNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExprNode(e0a) => {\n-                match (*other) {\n-                    ExprNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            VarDefNode(e0a) => {\n-                match (*other) {\n-                    VarDefNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExitNode => {\n-                match (*other) {\n-                    ExitNode => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &LiveNodeKind) -> bool {\n         match (*self) {\n             FreeVarNode(e0a) => {\n@@ -211,10 +164,6 @@ impl LiveNodeKind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &LiveNodeKind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "e9fa4f6dae54d9a5f9384bd41da2278fcc713770", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -56,68 +56,6 @@ enum categorization {\n }\n \n impl categorization : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &categorization) -> bool {\n-        match self {\n-            cat_rvalue => {\n-                match (*other) {\n-                    cat_rvalue => true,\n-                    _ => false\n-                }\n-            }\n-            cat_special(e0a) => {\n-                match (*other) {\n-                    cat_special(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_local(e0a) => {\n-                match (*other) {\n-                    cat_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_binding(e0a) => {\n-                match (*other) {\n-                    cat_binding(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_arg(e0a) => {\n-                match (*other) {\n-                    cat_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_stack_upvar(e0a) => {\n-                match (*other) {\n-                    cat_stack_upvar(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            cat_deref(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    cat_deref(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            cat_comp(e0a, e1a) => {\n-                match (*other) {\n-                    cat_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            cat_discr(e0a, e1a) => {\n-                match (*other) {\n-                    cat_discr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &categorization) -> bool {\n         match (*self) {\n             cat_rvalue => {\n@@ -177,10 +115,6 @@ impl categorization : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &categorization) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &categorization) -> bool { !(*self).eq(other) }\n }\n \n@@ -193,37 +127,6 @@ enum ptr_kind {\n }\n \n impl ptr_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ptr_kind) -> bool {\n-        match self {\n-            uniq_ptr => {\n-                match (*other) {\n-                    uniq_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            gc_ptr => {\n-                match (*other) {\n-                    gc_ptr => true,\n-                    _ => false\n-                }\n-            }\n-            region_ptr(e0a) => {\n-                match (*other) {\n-                    region_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            unsafe_ptr => {\n-                match (*other) {\n-                    unsafe_ptr => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ptr_kind) -> bool {\n         match (*self) {\n             uniq_ptr => {\n@@ -252,10 +155,6 @@ impl ptr_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ptr_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ptr_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -273,43 +172,6 @@ enum comp_kind {\n }\n \n impl comp_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &comp_kind) -> bool {\n-        match self {\n-            comp_tuple => {\n-                match (*other) {\n-                    comp_tuple => true,\n-                    _ => false\n-                }\n-            }\n-            comp_anon_field => {\n-                match (*other) {\n-                    comp_anon_field => true,\n-                    _ => false\n-                }\n-            }\n-            comp_variant(e0a) => {\n-                match (*other) {\n-                    comp_variant(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            comp_field(e0a, e1a) => {\n-                match (*other) {\n-                    comp_field(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            comp_index(e0a, e1a) => {\n-                match (*other) {\n-                    comp_index(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &comp_kind) -> bool {\n         match (*self) {\n             comp_tuple => {\n@@ -344,10 +206,6 @@ impl comp_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &comp_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &comp_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -360,19 +218,9 @@ enum special_kind {\n }\n \n impl special_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &special_kind) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &special_kind) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &special_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &special_kind) -> bool { !(*self).eq(other) }\n }\n \n@@ -389,17 +237,6 @@ type cmt_ = {id: ast::node_id,        // id of expr/pat producing this value\n type cmt = @cmt_;\n \n impl cmt_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cmt_) -> bool {\n-        self.id == (*other).id &&\n-        self.span == (*other).span &&\n-        self.cat == (*other).cat &&\n-        self.lp == (*other).lp &&\n-        self.mutbl == (*other).mutbl &&\n-        self.ty == (*other).ty\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cmt_) -> bool {\n         (*self).id == (*other).id &&\n         (*self).span == (*other).span &&\n@@ -408,10 +245,6 @@ impl cmt_ : cmp::Eq {\n         (*self).mutbl == (*other).mutbl &&\n         (*self).ty == (*other).ty\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cmt_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cmt_) -> bool { !(*self).eq(other) }\n }\n \n@@ -426,37 +259,6 @@ enum loan_path {\n }\n \n impl loan_path : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &loan_path) -> bool {\n-        match self {\n-            lp_local(e0a) => {\n-                match (*other) {\n-                    lp_local(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_arg(e0a) => {\n-                match (*other) {\n-                    lp_arg(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            lp_deref(e0a, e1a) => {\n-                match (*other) {\n-                    lp_deref(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            lp_comp(e0a, e1a) => {\n-                match (*other) {\n-                    lp_comp(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &loan_path) -> bool {\n         match (*self) {\n             lp_local(e0a) => {\n@@ -485,10 +287,6 @@ impl loan_path : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &loan_path) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &loan_path) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "dccb3965753a9b3bd2f573f05a32b2856572446c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -148,6 +148,9 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n \n             visit::visit_mod(the_module, span, node_id, method_map, visitor);\n \n+            // FIXME #4054: n_added gets corrupted without this log statement\n+            debug!(\"%i\", n_added);\n+\n             for n_added.times {\n                 ignore(privileged_items.pop());\n             }"}, {"sha": "e7dec95f09a2846dcbe2ca45e2fc844e34583593", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -374,21 +374,10 @@ type region_dep = {ambient_variance: region_variance, id: ast::node_id};\n type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n impl region_dep : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &region_dep) -> bool {\n-        self.ambient_variance == (*other).ambient_variance &&\n-        self.id == (*other).id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &region_dep) -> bool {\n         (*self).ambient_variance == (*other).ambient_variance &&\n         (*self).id == (*other).id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &region_dep) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &region_dep) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "581f65de25e7c197129cd6d15e7af38613e4a6a8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -108,31 +108,6 @@ enum PatternBindingMode {\n }\n \n impl PatternBindingMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &PatternBindingMode) -> bool {\n-        match self {\n-            RefutableMode => {\n-                match *other {\n-                    RefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            LocalIrrefutableMode => {\n-                match *other {\n-                    LocalIrrefutableMode => true,\n-                    _ => false\n-                }\n-            }\n-            ArgumentIrrefutableMode(mode_a) => {\n-                match *other {\n-                    ArgumentIrrefutableMode(mode_b) => mode_a == mode_b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &PatternBindingMode) -> bool {\n         match (*self) {\n             RefutableMode => {\n@@ -155,10 +130,6 @@ impl PatternBindingMode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &PatternBindingMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &PatternBindingMode) -> bool {\n         !(*self).eq(other)\n     }\n@@ -198,19 +169,9 @@ enum Mutability {\n }\n \n impl Mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Mutability) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Mutability) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Mutability) -> bool { !(*self).eq(other) }\n }\n \n@@ -232,19 +193,9 @@ enum ImportDirectiveNS {\n }\n \n impl ImportDirectiveNS : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ImportDirectiveNS) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ImportDirectiveNS) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ImportDirectiveNS) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ImportDirectiveNS) -> bool {\n         !(*self).eq(other)\n     }\n@@ -343,19 +294,9 @@ enum XrayFlag {\n }\n \n impl XrayFlag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &XrayFlag) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &XrayFlag) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &XrayFlag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &XrayFlag) -> bool { !(*self).eq(other) }\n }\n \n@@ -365,19 +306,9 @@ enum AllowCapturingSelfFlag {\n }\n \n impl AllowCapturingSelfFlag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &AllowCapturingSelfFlag) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &AllowCapturingSelfFlag) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &AllowCapturingSelfFlag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &AllowCapturingSelfFlag) -> bool {\n         !(*self).eq(other)\n     }\n@@ -400,19 +331,9 @@ enum DuplicateCheckingMode {\n }\n \n impl DuplicateCheckingMode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &DuplicateCheckingMode) -> bool {\n-        (self as uint) == (*other as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &DuplicateCheckingMode) -> bool {\n         ((*self) as uint) == (*other as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &DuplicateCheckingMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &DuplicateCheckingMode) -> bool {\n         !(*self).eq(other)\n     }\n@@ -619,19 +540,9 @@ enum Privacy {\n }\n \n impl Privacy : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Privacy) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Privacy) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Privacy) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Privacy) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "c8753dd0274fe944d30bf1171137c6645ef093f1", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -907,19 +907,9 @@ fn pick_col(m: &[@Match]) -> uint {\n enum branch_kind { no_branch, single, switch, compare, }\n \n impl branch_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &branch_kind) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &branch_kind) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &branch_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &branch_kind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "8ce3b4153f0a84381b95d7a641de42f0039ff207", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -296,25 +296,6 @@ enum cleanup {\n }\n \n impl cleantype : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cleantype) -> bool {\n-        match self {\n-            normal_exit_only => {\n-                match (*other) {\n-                    normal_exit_only => true,\n-                    _ => false\n-                }\n-            }\n-            normal_exit_and_unwind => {\n-                match (*other) {\n-                    normal_exit_and_unwind => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cleantype) -> bool {\n         match (*self) {\n             normal_exit_only => {\n@@ -331,10 +312,6 @@ impl cleantype : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cleantype) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cleantype) -> bool { !(*self).eq(other) }\n }\n \n@@ -1167,25 +1144,6 @@ type mono_id_ = {\n type mono_id = @mono_id_;\n \n impl mono_param_id : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mono_param_id) -> bool {\n-        match (self, (*other)) {\n-            (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n-                ty_a == ty_b && ids_a == ids_b\n-            }\n-            (mono_any, mono_any) => true,\n-            (mono_repr(size_a, align_a, is_float_a, mode_a),\n-             mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n-                size_a == size_b && align_a == align_b &&\n-                    is_float_a == is_float_b && mode_a == mode_b\n-            }\n-            (mono_precise(*), _) => false,\n-            (mono_any, _) => false,\n-            (mono_repr(*), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mono_param_id) -> bool {\n         match ((*self), (*other)) {\n             (mono_precise(ty_a, ids_a), mono_precise(ty_b, ids_b)) => {\n@@ -1202,27 +1160,13 @@ impl mono_param_id : cmp::Eq {\n             (mono_repr(*), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mono_param_id) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mono_param_id) -> bool { !(*self).eq(other) }\n }\n \n impl mono_id_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mono_id_) -> bool {\n-        self.def == (*other).def && self.params == (*other).params\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mono_id_) -> bool {\n         (*self).def == (*other).def && (*self).params == (*other).params\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mono_id_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "0246e617e2536e435a4fe2ca50a6e35c0598b0cb", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -139,19 +139,9 @@ impl DatumMode {\n }\n \n impl DatumMode: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &DatumMode) -> bool {\n-        self as uint == (*other as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &DatumMode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n@@ -809,17 +799,6 @@ impl DatumBlock {\n }\n \n impl CopyAction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &CopyAction) -> bool {\n-        match (self, (*other)) {\n-            (INIT, INIT) => true,\n-            (DROP_EXISTING, DROP_EXISTING) => true,\n-            (INIT, _) => false,\n-            (DROP_EXISTING, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &CopyAction) -> bool {\n         match ((*self), (*other)) {\n             (INIT, INIT) => true,\n@@ -828,9 +807,5 @@ impl CopyAction : cmp::Eq {\n             (DROP_EXISTING, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &CopyAction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &CopyAction) -> bool { !(*self).eq(other) }\n }"}, {"sha": "0b8cef3da37246f1c7fb54e880dd2b731337d971", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -148,17 +148,6 @@ impl Dest {\n }\n \n impl Dest : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Dest) -> bool {\n-        match (self, (*other)) {\n-            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n-            (Ignore, Ignore) => true,\n-            (SaveIn(*), _) => false,\n-            (Ignore, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Dest) -> bool {\n         match ((*self), (*other)) {\n             (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n@@ -167,10 +156,6 @@ impl Dest : cmp::Eq {\n             (Ignore, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Dest) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n }\n \n@@ -1444,23 +1429,6 @@ enum cast_kind {\n }\n \n impl cast_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cast_kind) -> bool {\n-        match (self, (*other)) {\n-            (cast_pointer, cast_pointer) => true,\n-            (cast_integral, cast_integral) => true,\n-            (cast_float, cast_float) => true,\n-            (cast_enum, cast_enum) => true,\n-            (cast_other, cast_other) => true,\n-            (cast_pointer, _) => false,\n-            (cast_integral, _) => false,\n-            (cast_float, _) => false,\n-            (cast_enum, _) => false,\n-            (cast_other, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cast_kind) -> bool {\n         match ((*self), (*other)) {\n             (cast_pointer, cast_pointer) => true,\n@@ -1475,10 +1443,6 @@ impl cast_kind : cmp::Eq {\n             (cast_other, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cast_kind) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "4fe7c307d5977d3b48093ade2a985704e3c42491", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -41,19 +41,9 @@ enum x86_64_reg_class {\n }\n \n impl x86_64_reg_class : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &x86_64_reg_class) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &x86_64_reg_class) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "7cb49b88c6775a33185c278e1b472ab9e2c5d89d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 526, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -245,25 +245,11 @@ type creader_cache_key = {cnum: int, pos: uint, len: uint};\n type creader_cache = HashMap<creader_cache_key, t>;\n \n impl creader_cache_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &creader_cache_key) -> bool {\n-        self.cnum == (*other).cnum &&\n-            self.pos == (*other).pos &&\n-            self.len == (*other).len\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &creader_cache_key) -> bool {\n         (*self).cnum == (*other).cnum &&\n             (*self).pos == (*other).pos &&\n             (*self).len == (*other).len\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &creader_cache_key) -> bool {\n-        !(self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &creader_cache_key) -> bool {\n         !((*self) == (*other))\n     }\n@@ -278,19 +264,9 @@ impl creader_cache_key : to_bytes::IterBytes {\n type intern_key = {sty: sty, o_def_id: Option<ast::def_id>};\n \n impl intern_key : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &intern_key) -> bool {\n-        self.sty == (*other).sty && self.o_def_id == (*other).o_def_id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &intern_key) -> bool {\n         (*self).sty == (*other).sty && (*self).o_def_id == (*other).o_def_id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &intern_key) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &intern_key) -> bool { !(*self).eq(other) }\n }\n \n@@ -312,19 +288,6 @@ type opt_region_variance = Option<region_variance>;\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &region_variance) -> bool {\n-        match (self, (*other)) {\n-            (rv_covariant, rv_covariant) => true,\n-            (rv_invariant, rv_invariant) => true,\n-            (rv_contravariant, rv_contravariant) => true,\n-            (rv_covariant, _) => false,\n-            (rv_invariant, _) => false,\n-            (rv_contravariant, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &region_variance) -> bool {\n         match ((*self), (*other)) {\n             (rv_covariant, rv_covariant) => true,\n@@ -335,10 +298,6 @@ impl region_variance : cmp::Eq {\n             (rv_contravariant, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n@@ -547,19 +506,9 @@ type FnTy = FnTyBase<FnMeta>;\n type param_ty = {idx: uint, def_id: def_id};\n \n impl param_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &param_ty) -> bool {\n-        self.idx == (*other).idx && self.def_id == (*other).def_id\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &param_ty) -> bool {\n         (*self).idx == (*other).idx && (*self).def_id == (*other).def_id\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &param_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &param_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -776,20 +725,6 @@ impl InferRegion : to_bytes::IterBytes {\n }\n \n impl InferRegion : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &InferRegion) -> bool {\n-        match (self, *other) {\n-            (ReVar(rva), ReVar(rvb)) => {\n-                rva == rvb\n-            }\n-            (ReSkolemized(rva, _), ReSkolemized(rvb, _)) => {\n-                rva == rvb\n-            }\n-            _ => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n@@ -801,12 +736,6 @@ impl InferRegion : cmp::Eq {\n             _ => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &InferRegion) -> bool {\n-        !(self == (*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &InferRegion) -> bool {\n         !((*self) == (*other))\n     }\n@@ -4278,88 +4207,27 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n }\n \n impl mt : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mt) -> bool {\n-        self.ty == (*other).ty && self.mutbl == (*other).mutbl\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n impl arg : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &arg) -> bool {\n-        self.mode == (*other).mode && self.ty == (*other).ty\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &arg) -> bool {\n         (*self).mode == (*other).mode && (*self).ty == (*other).ty\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &arg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &arg) -> bool { !(*self).eq(other) }\n }\n \n impl field : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &field) -> bool {\n-        self.ident == (*other).ident && self.mt == (*other).mt\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &field) -> bool {\n         (*self).ident == (*other).ident && (*self).mt == (*other).mt\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &field) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &field) -> bool { !(*self).eq(other) }\n }\n \n impl vstore : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &vstore) -> bool {\n-        match self {\n-            vstore_fixed(e0a) => {\n-                match (*other) {\n-                    vstore_fixed(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            vstore_uniq => {\n-                match (*other) {\n-                    vstore_uniq => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_box => {\n-                match (*other) {\n-                    vstore_box => true,\n-                    _ => false\n-                }\n-            }\n-            vstore_slice(e0a) => {\n-                match (*other) {\n-                    vstore_slice(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &vstore) -> bool {\n         match (*self) {\n             vstore_fixed(e0a) => {\n@@ -4388,175 +4256,60 @@ impl vstore : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &vstore) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &vstore) -> bool { !(*self).eq(other) }\n }\n \n impl FnMeta : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnMeta) -> bool {\n-        self.purity == (*other).purity &&\n-        self.proto == (*other).proto &&\n-        self.bounds == (*other).bounds &&\n-        self.ret_style == (*other).ret_style\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnMeta) -> bool {\n         (*self).purity == (*other).purity &&\n         (*self).proto == (*other).proto &&\n         (*self).bounds == (*other).bounds &&\n         (*self).ret_style == (*other).ret_style\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnMeta) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnMeta) -> bool { !(*self).eq(other) }\n }\n \n impl FnSig : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnSig) -> bool {\n-        self.inputs == (*other).inputs &&\n-        self.output == (*other).output\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnSig) -> bool {\n         (*self).inputs == (*other).inputs &&\n         (*self).output == (*other).output\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnSig) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnSig) -> bool { !(*self).eq(other) }\n }\n \n impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnTyBase<M>) -> bool {\n-        self.meta == (*other).meta && self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnTyBase<M>) -> bool {\n         (*self).meta == (*other).meta && (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnTyBase<M>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnTyBase<M>) -> bool { !(*self).eq(other) }\n }\n \n impl TyVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TyVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TyVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TyVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TyVid) -> bool { *(*self) != *(*other) }\n }\n \n impl IntVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &IntVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &IntVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &IntVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FloatVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FloatVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FloatVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FloatVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FloatVid) -> bool { *(*self) != *(*other) }\n }\n \n impl FnVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FnVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FnVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FnVid) -> bool { *(*self) != *(*other) }\n }\n \n impl RegionVid : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &RegionVid) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &RegionVid) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &RegionVid) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &RegionVid) -> bool { *(*self) != *(*other) }\n }\n \n impl Region : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Region) -> bool {\n-        match self {\n-            re_bound(e0a) => {\n-                match (*other) {\n-                    re_bound(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_free(e0a, e1a) => {\n-                match (*other) {\n-                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            re_scope(e0a) => {\n-                match (*other) {\n-                    re_scope(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_static => {\n-                match (*other) {\n-                    re_static => true,\n-                    _ => false\n-                }\n-            }\n-            re_infer(e0a) => {\n-                match (*other) {\n-                    re_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Region) -> bool {\n         match (*self) {\n             re_bound(e0a) => {\n@@ -4591,45 +4344,10 @@ impl Region : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Region) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n }\n \n impl bound_region : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &bound_region) -> bool {\n-        match self {\n-            br_self => {\n-                match (*other) {\n-                    br_self => true,\n-                    _ => false\n-                }\n-            }\n-            br_anon(e0a) => {\n-                match (*other) {\n-                    br_anon(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_named(e0a) => {\n-                match (*other) {\n-                    br_named(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_cap_avoid(e0a, e1a) => {\n-                match (*other) {\n-                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &bound_region) -> bool {\n         match (*self) {\n             br_self => {\n@@ -4658,216 +4376,26 @@ impl bound_region : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &bound_region) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n impl substs : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &substs) -> bool {\n-        self.self_r == (*other).self_r &&\n-        self.self_ty == (*other).self_ty &&\n-        self.tps == (*other).tps\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &substs) -> bool {\n         (*self).self_r == (*other).self_r &&\n         (*self).self_ty == (*other).self_ty &&\n         (*self).tps == (*other).tps\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &substs) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &substs) -> bool { !(*self).eq(other) }\n }\n \n impl InferTy : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &InferTy) -> bool {\n-        self.to_hash() == (*other).to_hash()\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &InferTy) -> bool {\n         (*self).to_hash() == (*other).to_hash()\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &InferTy) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &InferTy) -> bool { !(*self).eq(other) }\n }\n \n impl sty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &sty) -> bool {\n-        match self {\n-            ty_nil => {\n-                match (*other) {\n-                    ty_nil => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bot => {\n-                match (*other) {\n-                    ty_bot => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_estr(e0a) => {\n-                match (*other) {\n-                    ty_estr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_enum(e0a, e1a) => {\n-                match (*other) {\n-                    ty_enum(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_box(e0a) => {\n-                match (*other) {\n-                    ty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uniq(e0a) => {\n-                match (*other) {\n-                    ty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_evec(e0a, e1a) => {\n-                match (*other) {\n-                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_ptr(e0a) => {\n-                match (*other) {\n-                    ty_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_rptr(e0a, e1a) => {\n-                match (*other) {\n-                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_rec(e0a) => {\n-                match (*other) {\n-                    ty_rec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_fn(e0a) => {\n-                match (*other) {\n-                    ty_fn(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_trait(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    ty_trait(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            ty_class(e0a, e1a) => {\n-                match (*other) {\n-                    ty_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_tup(e0a) => {\n-                match (*other) {\n-                    ty_tup(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_infer(e0a) => {\n-                match (*other) {\n-                    ty_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_err => {\n-                match (*other) {\n-                    ty_err => true,\n-                    _ => false\n-                }\n-            }\n-            ty_param(e0a) => {\n-                match (*other) {\n-                    ty_param(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_self => {\n-                match (*other) {\n-                    ty_self => true,\n-                    _ => false\n-                }\n-            }\n-            ty_type => {\n-                match (*other) {\n-                    ty_type => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_box => {\n-                match (*other) {\n-                    ty_opaque_box => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_closure_ptr(e0a) => {\n-                match (*other) {\n-                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_unboxed_vec(e0a) => {\n-                match (*other) {\n-                    ty_unboxed_vec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &sty) -> bool {\n         match (*self) {\n             ty_nil => {\n@@ -5029,51 +4557,10 @@ impl sty : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &sty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &sty) -> bool { !(*self).eq(other) }\n }\n \n impl param_bound : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &param_bound) -> bool {\n-        match self {\n-            bound_copy => {\n-                match (*other) {\n-                    bound_copy => true,\n-                    _ => false\n-                }\n-            }\n-            bound_owned => {\n-                match (*other) {\n-                    bound_owned => true,\n-                    _ => false\n-                }\n-            }\n-            bound_send => {\n-                match (*other) {\n-                    bound_send => true,\n-                    _ => false\n-                }\n-            }\n-            bound_const => {\n-                match (*other) {\n-                    bound_const => true,\n-                    _ => false\n-                }\n-            }\n-            bound_trait(e0a) => {\n-                match (*other) {\n-                    bound_trait(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {\n             bound_copy => {\n@@ -5108,23 +4595,11 @@ impl param_bound : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &param_bound) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &param_bound) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n }\n \n impl Kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Kind) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Kind) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Kind) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Kind) -> bool { *(*self) != *(*other) }\n }\n "}, {"sha": "7f5d503dac94cdd9f16ba0e93f754504e4e6abe9", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -469,25 +469,6 @@ enum Constraint {\n }\n \n impl Constraint : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Constraint) -> bool {\n-        match (self, (*other)) {\n-            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n-                v0a == v0b && v1a == v1b\n-            }\n-            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n-                ra == rb && va == vb\n-            }\n-            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n-                va == vb && ra == rb\n-            }\n-            (ConstrainVarSubVar(*), _) => false,\n-            (ConstrainRegSubVar(*), _) => false,\n-            (ConstrainVarSubReg(*), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Constraint) -> bool {\n         match ((*self), (*other)) {\n             (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n@@ -504,10 +485,6 @@ impl Constraint : cmp::Eq {\n             (ConstrainVarSubReg(*), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Constraint) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n@@ -532,19 +509,9 @@ struct TwoRegions {\n }\n \n impl TwoRegions : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TwoRegions) -> bool {\n-        self.a == (*other).a && self.b == (*other).b\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TwoRegions) -> bool {\n         (*self).a == (*other).a && (*self).b == (*other).b\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TwoRegions) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n@@ -1068,38 +1035,18 @@ priv impl RegionVarBindings {\n enum Direction { Incoming = 0, Outgoing = 1 }\n \n impl Direction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Direction) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Direction) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Direction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Direction) -> bool { !(*self).eq(other) }\n }\n \n enum Classification { Expanding, Contracting }\n \n impl Classification : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Classification) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Classification) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Classification) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Classification) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "ac222aa1fa8466566ced7bcb41f1538e7a3a1b3d", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 310, "deletions": 112, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1,5 +1,3 @@\n-// DIVERT\n-\n // -*- rust -*-\n \n #[link(name = \"rustc\",\n@@ -45,246 +43,446 @@ mod middle {\n     mod trans {\n         #[legacy_exports];\n         #[legacy_exports]\n+        #[path = \"middle/trans/inline.rs\"]\n         mod inline;\n         #[legacy_exports]\n+        #[path = \"middle/trans/monomorphize.rs\"]\n         mod monomorphize;\n         #[legacy_exports]\n+        #[path = \"middle/trans/controlflow.rs\"]\n         mod controlflow;\n         #[legacy_exports]\n+        #[path = \"middle/trans/glue.rs\"]\n         mod glue;\n         #[legacy_exports]\n+        #[path = \"middle/trans/datum.rs\"]\n         mod datum;\n         #[legacy_exports]\n+        #[path = \"middle/trans/callee.rs\"]\n         mod callee;\n         #[legacy_exports]\n+        #[path = \"middle/trans/expr.rs\"]\n         mod expr;\n         #[legacy_exports]\n+        #[path = \"middle/trans/common.rs\"]\n         mod common;\n         #[legacy_exports]\n+        #[path = \"middle/trans/consts.rs\"]\n         mod consts;\n         #[legacy_exports]\n+        #[path = \"middle/trans/type_of.rs\"]\n         mod type_of;\n         #[legacy_exports]\n+        #[path = \"middle/trans/build.rs\"]\n         mod build;\n         #[legacy_exports]\n+        #[path = \"middle/trans/base.rs\"]\n         mod base;\n         #[legacy_exports]\n+        #[path = \"middle/trans/alt.rs\"]\n         mod alt;\n         #[legacy_exports]\n+        #[path = \"middle/trans/uniq.rs\"]\n         mod uniq;\n         #[legacy_exports]\n+        #[path = \"middle/trans/closure.rs\"]\n         mod closure;\n         #[legacy_exports]\n+        #[path = \"middle/trans/tvec.rs\"]\n         mod tvec;\n         #[legacy_exports]\n+        #[path = \"middle/trans/meth.rs\"]\n         mod meth;\n         #[legacy_exports]\n+        #[path = \"middle/trans/foreign.rs\"]\n         mod foreign;\n         #[legacy_exports]\n+        #[path = \"middle/trans/reflect.rs\"]\n         mod reflect;\n         #[legacy_exports]\n+        #[path = \"middle/trans/shape.rs\"]\n         mod shape;\n         #[legacy_exports]\n+        #[path = \"middle/trans/debuginfo.rs\"]\n         mod debuginfo;\n         #[legacy_exports]\n+        #[path = \"middle/trans/type_use.rs\"]\n         mod type_use;\n         #[legacy_exports]\n+        #[path = \"middle/trans/reachable.rs\"]\n         mod reachable;\n+        #[path = \"middle/trans/machine.rs\"]\n         mod machine;\n+        #[path = \"middle/trans/deriving.rs\"]\n         mod deriving;\n     }\n     #[legacy_exports]\n+    #[path = \"middle/ty.rs\"]\n     mod ty;\n     #[legacy_exports]\n+    #[path = \"middle/resolve.rs\"]\n     mod resolve;\n-    pub mod typeck {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        pub mod check {\n-            #[legacy_exports]\n-            mod alt;\n-            #[legacy_exports]\n-            mod vtable;\n-            #[legacy_exports]\n-            mod writeback;\n-            #[legacy_exports]\n-            mod regionmanip;\n-            #[legacy_exports]\n-            mod regionck;\n-            #[legacy_exports]\n-            mod demand;\n-            #[legacy_exports]\n-            pub mod method;\n-        }\n-        #[legacy_exports]\n-        mod rscope;\n-        #[legacy_exports]\n-        mod astconv;\n-        mod infer {\n-            #[legacy_exports];\n-            #[legacy_exports]\n-            mod assignment;\n-            #[legacy_exports]\n-            mod combine;\n-            #[legacy_exports]\n-            mod glb;\n-            #[legacy_exports]\n-            mod integral;\n-            mod floating;\n-            #[legacy_exports]\n-            mod lattice;\n-            #[legacy_exports]\n-            mod lub;\n-            #[legacy_exports]\n-            mod region_inference;\n-            #[legacy_exports]\n-            mod resolve;\n-            #[legacy_exports]\n-            mod sub;\n-            #[legacy_exports]\n-            mod to_str;\n-            #[legacy_exports]\n-            mod unify;\n-            #[cfg(test)]\n-            #[legacy_exports]\n-            mod test;\n-        }\n-        #[legacy_exports]\n-        mod collect;\n-        #[legacy_exports]\n-        mod coherence;\n-        mod deriving;\n-    }\n+    #[path = \"middle/typeck.rs\"]\n+    #[merge = \"middle/typeck/mod.rs\"]\n+    pub mod typeck;\n     #[legacy_exports]\n+    #[path = \"middle/check_loop.rs\"]\n     mod check_loop;\n     #[legacy_exports]\n+    #[path = \"middle/check_alt.rs\"]\n     mod check_alt;\n     #[legacy_exports]\n+    #[path = \"middle/check_const.rs\"]\n     mod check_const;\n     #[legacy_exports]\n+    #[path = \"middle/lint.rs\"]\n     mod lint;\n-    mod borrowck {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod check_loans;\n-        #[legacy_exports]\n-        mod gather_loans;\n-        #[legacy_exports]\n-        mod loan;\n-        #[legacy_exports]\n-        mod preserve;\n-    }\n+    #[path = \"middle/borrowck.rs\"]\n+    #[merge = \"middle/borrowck/mod.rs\"]\n+    mod borrowck;\n     #[legacy_exports]\n+    #[path = \"middle/mem_categorization.rs\"]\n     mod mem_categorization;\n     #[legacy_exports]\n+    #[path = \"middle/liveness.rs\"]\n     mod liveness;\n     #[legacy_exports]\n+    #[path = \"middle/kind.rs\"]\n     mod kind;\n     #[legacy_exports]\n+    #[path = \"middle/freevars.rs\"]\n     mod freevars;\n     #[legacy_exports]\n+    #[path = \"middle/capture.rs\"]\n     mod capture;\n     #[legacy_exports]\n+    #[path = \"middle/pat_util.rs\"]\n     mod pat_util;\n     #[legacy_exports]\n+    #[path = \"middle/region.rs\"]\n     mod region;\n     #[legacy_exports]\n+    #[path = \"middle/const_eval.rs\"]\n     mod const_eval;\n     #[legacy_exports]\n+    #[path = \"middle/astencode.rs\"]\n     mod astencode;\n     #[legacy_exports]\n+    #[path = \"middle/lang_items.rs\"]\n     mod lang_items;\n     #[legacy_exports]\n+    #[path = \"middle/privacy.rs\"]\n     mod privacy;\n }\n \n mod front {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"front/config.rs\"]\n     mod config;\n     #[legacy_exports]\n+    #[path = \"front/test.rs\"]\n     mod test;\n     #[legacy_exports]\n+    #[path = \"front/core_inject.rs\"]\n     mod core_inject;\n     #[legacy_exports]\n+    #[path = \"front/intrinsic_inject.rs\"]\n     mod intrinsic_inject;\n }\n \n mod back {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"back/link.rs\"]\n     mod link;\n     #[legacy_exports]\n+    #[path = \"back/abi.rs\"]\n     mod abi;\n     #[legacy_exports]\n+    #[path = \"back/upcall.rs\"]\n     mod upcall;\n     #[legacy_exports]\n+    #[path = \"back/x86.rs\"]\n     mod x86;\n     #[legacy_exports]\n+    #[path = \"back/x86_64.rs\"]\n     mod x86_64;\n     #[legacy_exports]\n+    #[path = \"back/rpath.rs\"]\n     mod rpath;\n     #[legacy_exports]\n+    #[path = \"back/target_strs.rs\"]\n     mod target_strs;\n }\n \n-mod metadata {\n-    #[legacy_exports];\n-    export encoder;\n-    export creader;\n-    export cstore;\n-    export csearch;\n-    export common;\n-    export decoder;\n-    export tyencode;\n-    export tydecode;\n-    export loader;\n-    export filesearch;\n+#[merge = \"metadata/mod.rs\"]\n+mod metadata;\n \n-    #[legacy_exports]\n-    mod common;\n-    #[legacy_exports]\n-    mod tyencode;\n-    #[legacy_exports]\n-    mod tydecode;\n-    #[legacy_exports]\n-    mod encoder;\n-    #[legacy_exports]\n-    mod decoder;\n-    #[legacy_exports]\n-    mod creader;\n-    #[legacy_exports]\n-    mod cstore;\n-    #[legacy_exports]\n-    mod csearch;\n-    #[legacy_exports]\n-    mod loader;\n-    #[legacy_exports]\n-    mod filesearch;\n-}\n-\n-mod driver {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod driver;\n-    #[legacy_exports]\n-    mod session;\n-}\n+#[merge = \"driver/mod.rs\"]\n+mod driver;\n \n mod util {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"util/common.rs\"]\n     mod common;\n     #[legacy_exports]\n+    #[path = \"util/ppaux.rs\"]\n     mod ppaux;\n }\n \n mod lib {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"lib/llvm.rs\"]\n     mod llvm;\n }\n \n+use result::{Ok, Err};\n+use io::ReaderUtil;\n+use std::getopts;\n+use std::map::HashMap;\n+use getopts::{opt_present};\n+use getopts::groups;\n+use syntax::codemap;\n+use syntax::diagnostic;\n+use driver::driver::{host_triple, optgroups, early_error,\n+                     str_input, file_input, build_session_options,\n+                     build_session, build_configuration, parse_pretty,\n+                     pp_mode, pretty_print_input, list_metadata,\n+                     compile_input};\n+use driver::session;\n+use middle::lint;\n+\n+fn version(argv0: &str) {\n+    let mut vers = ~\"unknown version\";\n+    let env_vers = env!(\"CFG_VERSION\");\n+    if env_vers.len() != 0 { vers = env_vers; }\n+    io::println(fmt!(\"%s %s\", argv0, vers));\n+    io::println(fmt!(\"host: %s\", host_triple()));\n+}\n+\n+fn usage(argv0: &str) {\n+    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n+    io::println(groups::usage(message, optgroups()) +\n+                ~\"Additional help:\n+    -W help             Print 'lint' options and default settings\n+    -Z help             Print internal options for debugging rustc\n+\");\n+}\n+\n+fn describe_warnings() {\n+    io::println(fmt!(\"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+\"));\n+\n+    let lint_dict = lint::get_lint_dict();\n+    let mut max_key = 0;\n+    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n+    fn padded(max: uint, s: &str) -> ~str {\n+        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n+    }\n+    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\",\n+                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n+    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n+                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n+    for lint_dict.each |k, v| {\n+        let k = str::replace(k, ~\"_\", ~\"-\");\n+        io::println(fmt!(\"    %s  %7.7s  %s\",\n+                         padded(max_key, k),\n+                         match v.default {\n+                             lint::allow => ~\"allow\",\n+                             lint::warn => ~\"warn\",\n+                             lint::deny => ~\"deny\",\n+                             lint::forbid => ~\"forbid\"\n+                         },\n+                         v.desc));\n+    }\n+    io::println(~\"\");\n+}\n+\n+fn describe_debug_flags() {\n+    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n+    for session::debugging_opts_map().each |pair| {\n+        let (name, desc, _) = *pair;\n+        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n+    }\n+}\n+\n+fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n+    // Don't display log spew by default. Can override with RUST_LOG.\n+    logging::console_off();\n+\n+    let mut args = *args;\n+    let binary = args.shift();\n+\n+    if args.is_empty() { usage(binary); return; }\n+\n+    let matches =\n+        match getopts::groups::getopts(args, optgroups()) {\n+          Ok(m) => m,\n+          Err(f) => {\n+            early_error(demitter, getopts::fail_str(f))\n+          }\n+        };\n+\n+    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n+        usage(binary);\n+        return;\n+    }\n+\n+    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n+                                 getopts::opt_strs(matches, ~\"warn\"));\n+    if lint_flags.contains(&~\"help\") {\n+        describe_warnings();\n+        return;\n+    }\n+\n+    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n+        describe_debug_flags();\n+        return;\n+    }\n+\n+    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n+        version(binary);\n+        return;\n+    }\n+    let input = match vec::len(matches.free) {\n+      0u => early_error(demitter, ~\"no input filename given\"),\n+      1u => {\n+        let ifile = matches.free[0];\n+        if ifile == ~\"-\" {\n+            let src = str::from_bytes(io::stdin().read_whole_stream());\n+            str_input(src)\n+        } else {\n+            file_input(Path(ifile))\n+        }\n+      }\n+      _ => early_error(demitter, ~\"multiple input filenames provided\")\n+    };\n+\n+    let sopts = build_session_options(binary, matches, demitter);\n+    let sess = build_session(sopts, demitter);\n+    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let odir = odir.map(|o| Path(*o));\n+    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n+    let ofile = ofile.map(|o| Path(*o));\n+    let cfg = build_configuration(sess, binary, input);\n+    let pretty =\n+        option::map(&getopts::opt_default(matches, ~\"pretty\",\n+                                         ~\"normal\"),\n+                    |a| parse_pretty(sess, *a) );\n+    match pretty {\n+      Some::<pp_mode>(ppm) => {\n+        pretty_print_input(sess, cfg, input, ppm);\n+        return;\n+      }\n+      None::<pp_mode> => {/* continue */ }\n+    }\n+    let ls = opt_present(matches, ~\"ls\");\n+    if ls {\n+        match input {\n+          file_input(ifile) => {\n+            list_metadata(sess, &ifile, io::stdout());\n+          }\n+          str_input(_) => {\n+            early_error(demitter, ~\"can not list metadata for stdin\");\n+          }\n+        }\n+        return;\n+    }\n+\n+    compile_input(sess, cfg, input, &odir, &ofile);\n+}\n+\n+enum monitor_msg {\n+    fatal,\n+    done,\n+}\n+\n+impl monitor_msg : cmp::Eq {\n+    pure fn eq(&self, other: &monitor_msg) -> bool {\n+        ((*self) as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n+}\n+\n+/*\n+This is a sanity check that any failure of the compiler is performed\n+through the diagnostic module and reported properly - we shouldn't be calling\n+plain-old-fail on any execution path that might be taken. Since we have\n+console logging off by default, hitting a plain fail statement would make the\n+compiler silently exit, which would be terrible.\n+\n+This method wraps the compiler in a subtask and injects a function into the\n+diagnostic emitter which records when we hit a fatal error. If the task\n+fails without recording a fatal error then we've encountered a compiler\n+bug and need to present an error.\n+*/\n+fn monitor(+f: fn~(diagnostic::emitter)) {\n+    let p = comm::Port();\n+    let ch = comm::Chan(&p);\n+\n+    match do task::try |move f| {\n+\n+        // The 'diagnostics emitter'. Every error, warning, etc. should\n+        // go through this function.\n+        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n+                           msg: &str, lvl: diagnostic::level) {\n+            if lvl == diagnostic::fatal {\n+                comm::send(ch, fatal);\n+            }\n+            diagnostic::emit(cmsp, msg, lvl);\n+        };\n+\n+        struct finally {\n+            ch: comm::Chan<monitor_msg>,\n+            drop { comm::send(self.ch, done); }\n+        }\n+\n+        let _finally = finally { ch: ch };\n+\n+        f(demitter)\n+    } {\n+        result::Ok(_) => { /* fallthrough */ }\n+        result::Err(_) => {\n+            // Task failed without emitting a fatal diagnostic\n+            if comm::recv(p) == done {\n+                diagnostic::emit(\n+                    None,\n+                    diagnostic::ice_msg(~\"unexpected failure\"),\n+                    diagnostic::error);\n+\n+                for [\n+                    ~\"the compiler hit an unexpected failure path. \\\n+                     this is a bug\",\n+                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n+                     to get further details and report the results \\\n+                     to github.com/mozilla/rust/issues\"\n+                ].each |note| {\n+                    diagnostic::emit(None, *note, diagnostic::note)\n+                }\n+            }\n+            // Fail so the process returns a failure code\n+            fail;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut args = os::args();\n+    do monitor |move args, demitter| {\n+        run_compiler(&args, demitter);\n+    }\n+}\n+\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}, {"sha": "c03464e33583a7ef394e6cd263d5e2cb6ddbcb84", "filename": "src/librustc/rustc.rs", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,261 +0,0 @@\n-// -*- rust -*-\n-use result::{Ok, Err};\n-use io::ReaderUtil;\n-use std::getopts;\n-use std::map::HashMap;\n-use getopts::{opt_present};\n-use getopts::groups;\n-use syntax::codemap;\n-use syntax::diagnostic;\n-use driver::driver::{host_triple, optgroups, early_error,\n-                     str_input, file_input, build_session_options,\n-                     build_session, build_configuration, parse_pretty,\n-                     pp_mode, pretty_print_input, list_metadata,\n-                     compile_input};\n-use driver::session;\n-use middle::lint;\n-\n-fn version(argv0: &str) {\n-    let mut vers = ~\"unknown version\";\n-    let env_vers = env!(\"CFG_VERSION\");\n-    if env_vers.len() != 0 { vers = env_vers; }\n-    io::println(fmt!(\"%s %s\", argv0, vers));\n-    io::println(fmt!(\"host: %s\", host_triple()));\n-}\n-\n-fn usage(argv0: &str) {\n-    let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n-    io::println(groups::usage(message, optgroups()) +\n-                ~\"Additional help:\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc\n-\");\n-}\n-\n-fn describe_warnings() {\n-    io::println(fmt!(\"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n-\"));\n-\n-    let lint_dict = lint::get_lint_dict();\n-    let mut max_key = 0;\n-    for lint_dict.each_key |k| { max_key = uint::max(k.len(), max_key); }\n-    fn padded(max: uint, s: &str) -> ~str {\n-        str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n-    }\n-    io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n-    io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n-    for lint_dict.each |k, v| {\n-        let k = str::replace(k, ~\"_\", ~\"-\");\n-        io::println(fmt!(\"    %s  %7.7s  %s\",\n-                         padded(max_key, k),\n-                         match v.default {\n-                             lint::allow => ~\"allow\",\n-                             lint::warn => ~\"warn\",\n-                             lint::deny => ~\"deny\",\n-                             lint::forbid => ~\"forbid\"\n-                         },\n-                         v.desc));\n-    }\n-    io::println(~\"\");\n-}\n-\n-fn describe_debug_flags() {\n-    io::println(fmt!(\"\\nAvailable debug options:\\n\"));\n-    for session::debugging_opts_map().each |pair| {\n-        let (name, desc, _) = *pair;\n-        io::println(fmt!(\"    -Z %-20s -- %s\", name, desc));\n-    }\n-}\n-\n-fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n-    // Don't display log spew by default. Can override with RUST_LOG.\n-    logging::console_off();\n-\n-    let mut args = *args;\n-    let binary = args.shift();\n-\n-    if args.is_empty() { usage(binary); return; }\n-\n-    let matches =\n-        match getopts::groups::getopts(args, optgroups()) {\n-          Ok(m) => m,\n-          Err(f) => {\n-            early_error(demitter, getopts::fail_str(f))\n-          }\n-        };\n-\n-    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n-        usage(binary);\n-        return;\n-    }\n-\n-    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n-                                 getopts::opt_strs(matches, ~\"warn\"));\n-    if lint_flags.contains(&~\"help\") {\n-        describe_warnings();\n-        return;\n-    }\n-\n-    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n-        describe_debug_flags();\n-        return;\n-    }\n-\n-    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n-        version(binary);\n-        return;\n-    }\n-    let input = match vec::len(matches.free) {\n-      0u => early_error(demitter, ~\"no input filename given\"),\n-      1u => {\n-        let ifile = matches.free[0];\n-        if ifile == ~\"-\" {\n-            let src = str::from_bytes(io::stdin().read_whole_stream());\n-            str_input(src)\n-        } else {\n-            file_input(Path(ifile))\n-        }\n-      }\n-      _ => early_error(demitter, ~\"multiple input filenames provided\")\n-    };\n-\n-    let sopts = build_session_options(binary, matches, demitter);\n-    let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n-    let odir = odir.map(|o| Path(*o));\n-    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n-    let ofile = ofile.map(|o| Path(*o));\n-    let cfg = build_configuration(sess, binary, input);\n-    let pretty =\n-        option::map(&getopts::opt_default(matches, ~\"pretty\",\n-                                         ~\"normal\"),\n-                    |a| parse_pretty(sess, *a) );\n-    match pretty {\n-      Some::<pp_mode>(ppm) => {\n-        pretty_print_input(sess, cfg, input, ppm);\n-        return;\n-      }\n-      None::<pp_mode> => {/* continue */ }\n-    }\n-    let ls = opt_present(matches, ~\"ls\");\n-    if ls {\n-        match input {\n-          file_input(ifile) => {\n-            list_metadata(sess, &ifile, io::stdout());\n-          }\n-          str_input(_) => {\n-            early_error(demitter, ~\"can not list metadata for stdin\");\n-          }\n-        }\n-        return;\n-    }\n-\n-    compile_input(sess, cfg, input, &odir, &ofile);\n-}\n-\n-enum monitor_msg {\n-    fatal,\n-    done,\n-}\n-\n-impl monitor_msg : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &monitor_msg) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn eq(&self, other: &monitor_msg) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &monitor_msg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    pure fn ne(&self, other: &monitor_msg) -> bool { !(*self).eq(other) }\n-}\n-\n-/*\n-This is a sanity check that any failure of the compiler is performed\n-through the diagnostic module and reported properly - we shouldn't be calling\n-plain-old-fail on any execution path that might be taken. Since we have\n-console logging off by default, hitting a plain fail statement would make the\n-compiler silently exit, which would be terrible.\n-\n-This method wraps the compiler in a subtask and injects a function into the\n-diagnostic emitter which records when we hit a fatal error. If the task\n-fails without recording a fatal error then we've encountered a compiler\n-bug and need to present an error.\n-*/\n-fn monitor(+f: fn~(diagnostic::emitter)) {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n-\n-    match do task::try |move f| {\n-\n-        // The 'diagnostics emitter'. Every error, warning, etc. should\n-        // go through this function.\n-        let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n-                           msg: &str, lvl: diagnostic::level) {\n-            if lvl == diagnostic::fatal {\n-                comm::send(ch, fatal);\n-            }\n-            diagnostic::emit(cmsp, msg, lvl);\n-        };\n-\n-        struct finally {\n-            ch: comm::Chan<monitor_msg>,\n-            drop { comm::send(self.ch, done); }\n-        }\n-\n-        let _finally = finally { ch: ch };\n-\n-        f(demitter)\n-    } {\n-        result::Ok(_) => { /* fallthrough */ }\n-        result::Err(_) => {\n-            // Task failed without emitting a fatal diagnostic\n-            if comm::recv(p) == done {\n-                diagnostic::emit(\n-                    None,\n-                    diagnostic::ice_msg(~\"unexpected failure\"),\n-                    diagnostic::error);\n-\n-                for [\n-                    ~\"the compiler hit an unexpected failure path. \\\n-                     this is a bug\",\n-                    ~\"try running with RUST_LOG=rustc=1,::rt::backtrace \\\n-                     to get further details and report the results \\\n-                     to github.com/mozilla/rust/issues\"\n-                ].each |note| {\n-                    diagnostic::emit(None, *note, diagnostic::note)\n-                }\n-            }\n-            // Fail so the process returns a failure code\n-            fail;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let mut args = os::args();\n-    do monitor |move args, demitter| {\n-        run_compiler(&args, demitter);\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "4dfbda4e29e2e9dab407a3e731b49af05581a2d5", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -11,19 +11,9 @@ pub enum OutputFormat {\n }\n \n impl OutputFormat : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OutputFormat) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OutputFormat) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OutputFormat) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n }\n \n@@ -36,19 +26,9 @@ pub enum OutputStyle {\n }\n \n impl OutputStyle : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &OutputStyle) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &OutputStyle) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &OutputStyle) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "16fba7a9ffd4e3ba1daaded373178d2ef98dce6d", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -7,19 +7,9 @@ pub type Doc_ = {\n };\n \n impl Doc_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Doc_) -> bool {\n-        self.pages == (*other).pages\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Doc_) -> bool {\n         (*self).pages == (*other).pages\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Doc_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Doc_) -> bool { !(*self).eq(other) }\n }\n \n@@ -28,15 +18,7 @@ pub enum Doc {\n }\n \n impl Doc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Doc) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Doc) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Doc) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Doc) -> bool { *(*self) != *(*other) }\n }\n \n@@ -46,25 +28,6 @@ pub enum Page {\n }\n \n impl Page : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Page) -> bool {\n-        match self {\n-            CratePage(e0a) => {\n-                match (*other) {\n-                    CratePage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ItemPage(e0a) => {\n-                match (*other) {\n-                    ItemPage(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Page) -> bool {\n         match (*self) {\n             CratePage(e0a) => {\n@@ -81,10 +44,6 @@ impl Page : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Page) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Page) -> bool { !(*self).eq(other) }\n }\n \n@@ -94,19 +53,9 @@ pub enum Implementation {\n }\n \n impl Implementation : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Implementation) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Implementation) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Implementation) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Implementation) -> bool { !(*self).eq(other) }\n }\n \n@@ -121,19 +70,9 @@ pub type Section = {\n };\n \n impl Section : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Section) -> bool {\n-        self.header == (*other).header && self.body == (*other).body\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Section) -> bool {\n         (*self).header == (*other).header && (*self).body == (*other).body\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Section) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Section) -> bool { !(*self).eq(other) }\n }\n \n@@ -145,19 +84,9 @@ pub type CrateDoc = {\n };\n \n impl CrateDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &CrateDoc) -> bool {\n-        self.topmod == (*other).topmod\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &CrateDoc) -> bool {\n         (*self).topmod == (*other).topmod\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &CrateDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &CrateDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -174,67 +103,6 @@ pub enum ItemTag {\n }\n \n impl ItemTag : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ItemTag) -> bool {\n-        match self {\n-            ModTag(e0a) => {\n-                match (*other) {\n-                    ModTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            NmodTag(e0a) => {\n-                match (*other) {\n-                    NmodTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ConstTag(e0a) => {\n-                match (*other) {\n-                    ConstTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            FnTag(e0a) => {\n-                match (*other) {\n-                    FnTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EnumTag(e0a) => {\n-                match (*other) {\n-                    EnumTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TraitTag(e0a) => {\n-                match (*other) {\n-                    TraitTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ImplTag(e0a) => {\n-                match (*other) {\n-                    ImplTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            TyTag(e0a) => {\n-                match (*other) {\n-                    TyTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            StructTag(e0a) => {\n-                match (*other) {\n-                    StructTag(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ItemTag) -> bool {\n         match (*self) {\n             ModTag(e0a) => {\n@@ -293,10 +161,6 @@ impl ItemTag : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ItemTag) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ItemTag) -> bool { !(*self).eq(other) }\n }\n \n@@ -312,18 +176,6 @@ pub type ItemDoc = {\n };\n \n impl ItemDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ItemDoc) -> bool {\n-        self.id == (*other).id &&\n-        self.name == (*other).name &&\n-        self.path == (*other).path &&\n-        self.brief == (*other).brief &&\n-        self.desc == (*other).desc &&\n-        self.sections == (*other).sections &&\n-        self.reexport == (*other).reexport\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ItemDoc) -> bool {\n         (*self).id == (*other).id &&\n         (*self).name == (*other).name &&\n@@ -333,10 +185,6 @@ impl ItemDoc : cmp::Eq {\n         (*self).sections == (*other).sections &&\n         (*self).reexport == (*other).reexport\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ItemDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ItemDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -346,19 +194,9 @@ pub type SimpleItemDoc = {\n };\n \n impl SimpleItemDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &SimpleItemDoc) -> bool {\n-        self.item == (*other).item && self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &SimpleItemDoc) -> bool {\n         (*self).item == (*other).item && (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &SimpleItemDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &SimpleItemDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -369,23 +207,11 @@ pub type ModDoc_ = {\n };\n \n impl ModDoc_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ModDoc_) -> bool {\n-        self.item == (*other).item &&\n-        self.items == (*other).items &&\n-        self.index == (*other).index\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ModDoc_) -> bool {\n         (*self).item == (*other).item &&\n         (*self).items == (*other).items &&\n         (*self).index == (*other).index\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ModDoc_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ModDoc_) -> bool { !(*self).eq(other) }\n }\n \n@@ -394,15 +220,7 @@ pub enum ModDoc {\n }\n \n impl ModDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ModDoc) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ModDoc) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ModDoc) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ModDoc) -> bool { *(*self) != *(*other) }\n }\n \n@@ -413,23 +231,11 @@ pub type NmodDoc = {\n };\n \n impl NmodDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &NmodDoc) -> bool {\n-        self.item == (*other).item &&\n-        self.fns == (*other).fns &&\n-        self.index == (*other).index\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &NmodDoc) -> bool {\n         (*self).item == (*other).item &&\n         (*self).fns == (*other).fns &&\n         (*self).index == (*other).index\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &NmodDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &NmodDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -443,19 +249,9 @@ pub type EnumDoc = {\n };\n \n impl EnumDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &EnumDoc) -> bool {\n-        self.item == (*other).item && self.variants == (*other).variants\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &EnumDoc) -> bool {\n         (*self).item == (*other).item && (*self).variants == (*other).variants\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &EnumDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &EnumDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -466,23 +262,11 @@ pub type VariantDoc = {\n };\n \n impl VariantDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &VariantDoc) -> bool {\n-        self.name == (*other).name &&\n-        self.desc == (*other).desc &&\n-        self.sig == (*other).sig\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &VariantDoc) -> bool {\n         (*self).name == (*other).name &&\n         (*self).desc == (*other).desc &&\n         (*self).sig == (*other).sig\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &VariantDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &VariantDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -492,19 +276,9 @@ pub type TraitDoc = {\n };\n \n impl TraitDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TraitDoc) -> bool {\n-        self.item == (*other).item && self.methods == (*other).methods\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TraitDoc) -> bool {\n         (*self).item == (*other).item && (*self).methods == (*other).methods\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TraitDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TraitDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -518,17 +292,6 @@ pub type MethodDoc = {\n };\n \n impl MethodDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &MethodDoc) -> bool {\n-        self.name == (*other).name &&\n-        self.brief == (*other).brief &&\n-        self.desc == (*other).desc &&\n-        self.sections == (*other).sections &&\n-        self.sig == (*other).sig &&\n-        self.implementation == (*other).implementation\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &MethodDoc) -> bool {\n         (*self).name == (*other).name &&\n         (*self).brief == (*other).brief &&\n@@ -537,10 +300,6 @@ impl MethodDoc : cmp::Eq {\n         (*self).sig == (*other).sig &&\n         (*self).implementation == (*other).implementation\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &MethodDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &MethodDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -552,25 +311,12 @@ pub type ImplDoc = {\n };\n \n impl ImplDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ImplDoc) -> bool {\n-        self.item == (*other).item &&\n-        self.trait_types == (*other).trait_types &&\n-        self.self_ty == (*other).self_ty &&\n-        self.methods == (*other).methods\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ImplDoc) -> bool {\n         (*self).item == (*other).item &&\n         (*self).trait_types == (*other).trait_types &&\n         (*self).self_ty == (*other).self_ty &&\n         (*self).methods == (*other).methods\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ImplDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ImplDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -583,23 +329,11 @@ pub type StructDoc = {\n };\n \n impl StructDoc : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &StructDoc) -> bool {\n-        return self.item == other.item\n-            && self.fields == other.fields\n-            && self.sig == other.sig;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &StructDoc) -> bool {\n         return (*self).item == other.item\n             && (*self).fields == other.fields\n             && (*self).sig == other.sig;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &StructDoc) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &StructDoc) -> bool { !(*self).eq(other) }\n }\n \n@@ -608,19 +342,9 @@ pub type Index = {\n };\n \n impl Index : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Index) -> bool {\n-        self.entries == (*other).entries\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Index) -> bool {\n         (*self).entries == (*other).entries\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Index) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Index) -> bool { !(*self).eq(other) }\n }\n \n@@ -642,25 +366,12 @@ pub type IndexEntry = {\n };\n \n impl IndexEntry : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &IndexEntry) -> bool {\n-        self.kind == (*other).kind &&\n-        self.name == (*other).name &&\n-        self.brief == (*other).brief &&\n-        self.link == (*other).link\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &IndexEntry) -> bool {\n         (*self).kind == (*other).kind &&\n         (*self).name == (*other).name &&\n         (*self).brief == (*other).brief &&\n         (*self).link == (*other).link\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &IndexEntry) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &IndexEntry) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "f33ff892f367db542569c38b0bef5c98a7e8bc82", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -239,25 +239,6 @@ mod tests {\n     type RecCy = {x: int, y: int, t: Taggy};\n \n     impl Taggy : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &Taggy) -> bool {\n-            match self {\n-              One(a1) => match (*other) {\n-                One(b1) => return a1 == b1,\n-                _ => return false\n-              },\n-              Two(a1, a2) => match (*other) {\n-                Two(b1, b2) => return a1 == b1 && a2 == b2,\n-                _ => return false\n-              },\n-              Three(a1, a2, a3) => match (*other) {\n-                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n-                _ => return false\n-              }\n-            }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &Taggy) -> bool {\n             match (*self) {\n               One(a1) => match (*other) {\n@@ -274,36 +255,11 @@ mod tests {\n               }\n             }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &Taggy) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &Taggy) -> bool { !(*self).eq(other) }\n     }\n \n     impl Taggypar<int> : Eq {\n         //let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        #[cfg(stage0)]\n-        pure fn eq(other: &Taggypar<int>) -> bool {\n-                  match self {\n-                    Onepar::<int>(a1) => match (*other) {\n-                      Onepar::<int>(b1) => return a1 == b1,\n-                      _ => return false\n-                    },\n-                    Twopar::<int>(a1, a2) => match (*other) {\n-                      Twopar::<int>(b1, b2) => return a1 == b1 && a2 == b2,\n-                      _ => return false\n-                    },\n-                    Threepar::<int>(a1, a2, a3) => match (*other) {\n-                      Threepar::<int>(b1, b2, b3) => {\n-                          return a1 == b1 && a2 == b2 && a3 == b3\n-                      }\n-                      _ => return false\n-                    }\n-                  }\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &Taggypar<int>) -> bool {\n                   match (*self) {\n                     Onepar::<int>(a1) => match (*other) {\n@@ -322,33 +278,16 @@ mod tests {\n                     }\n                   }\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &Taggypar<int>) -> bool {\n-            !self.eq(other)\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &Taggypar<int>) -> bool {\n             !(*self).eq(other)\n         }\n     }\n \n     impl RecCy : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &RecCy) -> bool {\n-          return self.x == (*other).x && self.y == (*other).y &&\n-                 self.t == (*other).t;\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &RecCy) -> bool {\n           return (*self).x == (*other).x && (*self).y == (*other).y &&\n                  (*self).t == (*other).t;\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &RecCy) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ne(&self, other: &RecCy) -> bool { !(*self).eq(other) }\n     }\n "}, {"sha": "44296a009e7d97c054403d53d361c37ee327aa21", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 139, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -88,25 +88,6 @@ fn mkname(nm: &str) -> Name {\n }\n \n impl Name : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Name) -> bool {\n-        match self {\n-            Long(ref e0a) => {\n-                match (*other) {\n-                    Long(ref e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Short(e0a) => {\n-                match (*other) {\n-                    Short(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Name) -> bool {\n         match (*self) {\n             Long(ref e0a) => {\n@@ -123,65 +104,29 @@ impl Name : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Name) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Name) -> bool { !(*self).eq(other) }\n }\n \n impl Occur : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Occur) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Occur) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Occur) -> bool { !(*self).eq(other) }\n }\n \n impl HasArg : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &HasArg) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &HasArg) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &HasArg) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &HasArg) -> bool { !(*self).eq(other) }\n }\n \n impl Opt : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Opt) -> bool {\n-        self.name   == (*other).name   &&\n-        self.hasarg == (*other).hasarg &&\n-        self.occur  == (*other).occur\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Opt) -> bool {\n         (*self).name   == (*other).name   &&\n         (*self).hasarg == (*other).hasarg &&\n         (*self).occur  == (*other).occur\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Opt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Opt) -> bool { !(*self).eq(other) }\n }\n \n@@ -227,17 +172,6 @@ enum Optval { Val(~str), Given, }\n pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n impl Optval : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Optval) -> bool {\n-        match self {\n-            Val(ref s) => match *other { Val (ref os) => s == os,\n-                                          Given => false },\n-            Given       => match *other { Val(_) => false,\n-                                          Given => true }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Optval) -> bool {\n         match (*self) {\n             Val(ref s) => match *other { Val (ref os) => s == os,\n@@ -246,31 +180,15 @@ impl Optval : Eq {\n                                           Given => true }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Optval) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Optval) -> bool { !(*self).eq(other) }\n }\n \n impl Matches : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Matches) -> bool {\n-        self.opts == (*other).opts &&\n-        self.vals == (*other).vals &&\n-        self.free == (*other).free\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Matches) -> bool {\n         (*self).opts == (*other).opts &&\n         (*self).vals == (*other).vals &&\n         (*self).free == (*other).free\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Matches) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Matches) -> bool { !(*self).eq(other) }\n }\n \n@@ -303,33 +221,6 @@ pub enum Fail_ {\n \n impl Fail_ : Eq {\n     // this whole thing should be easy to infer...\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Fail_) -> bool {\n-        match self {\n-            ArgumentMissing(ref s) => {\n-                match *other { ArgumentMissing(ref so)    => s == so,\n-                               _                          => false }\n-            }\n-            UnrecognizedOption(ref s) => {\n-                match *other { UnrecognizedOption(ref so) => s == so,\n-                               _                          => false }\n-            }\n-            OptionMissing(ref s) => {\n-                match *other { OptionMissing(ref so)      => s == so,\n-                               _                          => false }\n-            }\n-            OptionDuplicated(ref s) => {\n-                match *other { OptionDuplicated(ref so)   => s == so,\n-                               _                          => false }\n-            }\n-            UnexpectedArgument(ref s) => {\n-                match *other { UnexpectedArgument(ref so) => s == so,\n-                               _                          => false }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Fail_) -> bool {\n         match (*self) {\n             ArgumentMissing(ref s) => {\n@@ -354,10 +245,6 @@ impl Fail_ : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Fail_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Fail_) -> bool { !(*self).eq(other) }\n }\n \n@@ -627,19 +514,9 @@ enum FailType {\n }\n \n impl FailType : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &FailType) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &FailType) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &FailType) -> bool { !(*self).eq(other) }\n }\n \n@@ -661,17 +538,6 @@ pub mod groups {\n     };\n \n     impl OptGroup : Eq {\n-        #[cfg(stage0)]\n-        pure fn eq(other: &OptGroup) -> bool {\n-            self.short_name == (*other).short_name &&\n-            self.long_name  == (*other).long_name  &&\n-            self.hint       == (*other).hint       &&\n-            self.desc       == (*other).desc       &&\n-            self.hasarg     == (*other).hasarg     &&\n-            self.occur      == (*other).occur\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn eq(&self, other: &OptGroup) -> bool {\n             (*self).short_name == (*other).short_name &&\n             (*self).long_name  == (*other).long_name  &&\n@@ -680,11 +546,9 @@ pub mod groups {\n             (*self).hasarg     == (*other).hasarg     &&\n             (*self).occur      == (*other).occur\n         }\n-        #[cfg(stage0)]\n-        pure fn ne(other: &OptGroup) -> bool { !self.eq(other) }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n-        pure fn ne(&self, other: &OptGroup) -> bool { !(*self).eq(other) }\n+        pure fn ne(&self, other: &OptGroup) -> bool {\n+            !self.eq(other)\n+        }\n     }\n \n     /// Create a long option that is required and takes an argument"}, {"sha": "8551072d4616f0739f232e8f4835c2a777853316", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -905,44 +905,6 @@ pub impl Deserializer: serialization::Deserializer {\n }\n \n impl Json : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Json) -> bool {\n-        // XXX: This is ugly because matching on references is broken, and\n-        // we can't match on dereferenced tuples without a copy.\n-        match self {\n-            Number(f0) =>\n-                match *other { Number(f1) => f0 == f1, _ => false },\n-            String(ref s0) =>\n-                match *other { String(ref s1) => s0 == s1, _ => false },\n-            Boolean(b0) =>\n-                match *other { Boolean(b1) => b0 == b1, _ => false },\n-            Null =>\n-                match *other { Null => true, _ => false },\n-            List(v0) =>\n-                match *other { List(v1) => v0 == v1, _ => false },\n-            Object(ref d0) => {\n-                match *other {\n-                    Object(ref d1) => {\n-                        if d0.len() == d1.len() {\n-                            let mut equal = true;\n-                            for d0.each |k, v0| {\n-                                match d1.find_ref(k) {\n-                                    Some(v1) if v0 == v1 => { },\n-                                    _ => { equal = false; break }\n-                                }\n-                            };\n-                            equal\n-                        } else {\n-                            false\n-                        }\n-                    }\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Json) -> bool {\n         // XXX: This is ugly because matching on references is broken, and\n         // we can't match on dereferenced tuples without a copy.\n@@ -978,88 +940,11 @@ impl Json : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Json) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Json) -> bool { !(*self).eq(other) }\n }\n \n /// Test if two json values are less than one another\n impl Json : Ord {\n-    #[cfg(stage0)]\n-    pure fn lt(other: &Json) -> bool {\n-        match self {\n-            Number(f0) => {\n-                match *other {\n-                    Number(f1) => f0 < f1,\n-                    String(_) | Boolean(_) | List(_) | Object(_) |\n-                    Null => true\n-                }\n-            }\n-\n-            String(ref s0) => {\n-                match *other {\n-                    Number(_) => false,\n-                    String(ref s1) => s0 < s1,\n-                    Boolean(_) | List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            Boolean(b0) => {\n-                match *other {\n-                    Number(_) | String(_) => false,\n-                    Boolean(b1) => b0 < b1,\n-                    List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            List(l0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) => false,\n-                    List(l1) => l0 < l1,\n-                    Object(_) | Null => true\n-                }\n-            }\n-\n-            Object(ref d0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n-                    Object(ref d1) => {\n-                        unsafe {\n-                            let mut d0_flat = ~[];\n-                            let mut d1_flat = ~[];\n-\n-                            // XXX: this is horribly inefficient...\n-                            for d0.each |k, v| {\n-                                 d0_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d0_flat.qsort();\n-\n-                            for d1.each |k, v| {\n-                                d1_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d1_flat.qsort();\n-\n-                            d0_flat < d1_flat\n-                        }\n-                    }\n-                    Null => true\n-                }\n-            }\n-\n-            Null => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) |\n-                    Object(_) =>\n-                        false,\n-                    Null => true\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn lt(&self, other: &Json) -> bool {\n         match (*self) {\n             Number(f0) => {\n@@ -1130,41 +1015,17 @@ impl Json : Ord {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn le(other: &Json) -> bool { !(*other).lt(&self) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n-    #[cfg(stage0)]\n-    pure fn ge(other: &Json) -> bool { !self.lt(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n-    #[cfg(stage0)]\n-    pure fn gt(other: &Json) -> bool { (*other).lt(&self)  }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n impl Error : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Error) -> bool {\n-        self.line == other.line &&\n-        self.col == other.col &&\n-        self.msg == other.msg\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Error) -> bool {\n         (*self).line == other.line &&\n         (*self).col == other.col &&\n         (*self).msg == other.msg\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Error) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "ccff91634b8e11b8e8f99963ba40945b650ef784", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -148,25 +148,6 @@ pub fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n }\n \n impl<T:Eq> List<T> : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &List<T>) -> bool {\n-        match self {\n-            Cons(ref e0a, e1a) => {\n-                match (*other) {\n-                    Cons(ref e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Nil => {\n-                match (*other) {\n-                    Nil => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &List<T>) -> bool {\n         match (*self) {\n             Cons(ref e0a, e1a) => {\n@@ -183,10 +164,6 @@ impl<T:Eq> List<T> : Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &List<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &List<T>) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "36fb86e0c494dea9efdd7b0eb98f32fe63c57568", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -315,19 +315,9 @@ pure fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n }\n \n impl UserInfo : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &UserInfo) -> bool {\n-        self.user == (*other).user && self.pass == (*other).pass\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &UserInfo) -> bool {\n         (*self).user == (*other).user && (*self).pass == (*other).pass\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &UserInfo) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &UserInfo) -> bool { !(*self).eq(other) }\n }\n \n@@ -389,19 +379,6 @@ enum Input {\n }\n \n impl Input : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Input) -> bool {\n-        match (self, (*other)) {\n-            (Digit, Digit) => true,\n-            (Hex, Hex) => true,\n-            (Unreserved, Unreserved) => true,\n-            (Digit, _) => false,\n-            (Hex, _) => false,\n-            (Unreserved, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Input) -> bool {\n         match ((*self), (*other)) {\n             (Digit, Digit) => true,\n@@ -412,10 +389,6 @@ impl Input : Eq {\n             (Unreserved, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Input) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Input) -> bool { !(*self).eq(other) }\n }\n \n@@ -749,18 +722,6 @@ impl Url: to_str::ToStr {\n }\n \n impl Url : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Url) -> bool {\n-        self.scheme == (*other).scheme\n-            && self.user == (*other).user\n-            && self.host == (*other).host\n-            && self.port == (*other).port\n-            && self.path == (*other).path\n-            && self.query == (*other).query\n-            && self.fragment == (*other).fragment\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Url) -> bool {\n         (*self).scheme == (*other).scheme\n             && (*self).user == (*other).user\n@@ -771,12 +732,6 @@ impl Url : Eq {\n             && (*self).fragment == (*other).fragment\n     }\n \n-    #[cfg(stage0)]\n-    pure fn ne(other: &Url) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Url) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "c6e8c72e6d64990409b5a9004acfc7174633003b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -871,37 +871,15 @@ mod test_tim_sort {\n     }\n \n     impl CVal: Ord {\n-        #[cfg(stage0)]\n-        pure fn lt(other: &CVal) -> bool {\n-            unsafe {\n-                let rng = rand::Rng();\n-                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n-            }\n-            self.val < other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn lt(&self, other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n                 if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n             }\n             (*self).val < other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn le(other: &CVal) -> bool { self.val <= other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        #[cfg(stage0)]\n-        pure fn gt(other: &CVal) -> bool { self.val > other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        #[cfg(stage0)]\n-        pure fn ge(other: &CVal) -> bool { self.val >= other.val }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n@@ -957,16 +935,6 @@ mod test_tim_sort {\n \n     struct DVal { val: uint }\n \n-    #[cfg(stage0)]\n-    impl DVal: Ord {\n-        pure fn lt(_x: &DVal) -> bool { true }\n-        pure fn le(_x: &DVal) -> bool { true }\n-        pure fn gt(_x: &DVal) -> bool { true }\n-        pure fn ge(_x: &DVal) -> bool { true }\n-    }\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     impl DVal: Ord {\n         pure fn lt(&self, _x: &DVal) -> bool { true }\n         pure fn le(&self, _x: &DVal) -> bool { true }\n@@ -1183,39 +1151,15 @@ mod big_tests {\n     }\n \n     impl LVal: Ord {\n-        #[cfg(stage0)]\n-        pure fn lt(other: &a/LVal/&self) -> bool {\n-            self.val < other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn lt(&self, other: &a/LVal/&self) -> bool {\n             (*self).val < other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn le(other: &a/LVal/&self) -> bool {\n-            self.val <= other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn le(&self, other: &a/LVal/&self) -> bool {\n             (*self).val <= other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn gt(other: &a/LVal/&self) -> bool {\n-            self.val > other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn gt(&self, other: &a/LVal/&self) -> bool {\n             (*self).val > other.val\n         }\n-        #[cfg(stage0)]\n-        pure fn ge(other: &a/LVal/&self) -> bool {\n-            self.val >= other.val\n-        }\n-        #[cfg(stage1)]\n-        #[cfg(stage2)]\n         pure fn ge(&self, other: &a/LVal/&self) -> bool {\n             (*self).val >= other.val\n         }"}, {"sha": "b3b5e978414234de464285061704ec55a3ddb04c", "filename": "src/libstd/test.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -85,19 +85,9 @@ fn parse_opts(args: &[~str]) -> OptRes {\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n impl TestResult : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &TestResult) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &TestResult) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &TestResult) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &TestResult) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "7596f4282b7a8402528881037a6730203d73c41d", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -24,19 +24,9 @@ extern mod rustrt {\n pub type Timespec = {sec: i64, nsec: i32};\n \n impl Timespec : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Timespec) -> bool {\n-        self.sec == (*other).sec && self.nsec == (*other).nsec\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Timespec) -> bool {\n         (*self).sec == (*other).sec && (*self).nsec == (*other).nsec\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Timespec) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Timespec) -> bool { !(*self).eq(other) }\n }\n \n@@ -91,23 +81,6 @@ type Tm_ = {\n };\n \n impl Tm_ : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Tm_) -> bool {\n-        self.tm_sec == (*other).tm_sec &&\n-        self.tm_min == (*other).tm_min &&\n-        self.tm_hour == (*other).tm_hour &&\n-        self.tm_mday == (*other).tm_mday &&\n-        self.tm_mon == (*other).tm_mon &&\n-        self.tm_year == (*other).tm_year &&\n-        self.tm_wday == (*other).tm_wday &&\n-        self.tm_yday == (*other).tm_yday &&\n-        self.tm_isdst == (*other).tm_isdst &&\n-        self.tm_gmtoff == (*other).tm_gmtoff &&\n-        self.tm_zone == (*other).tm_zone &&\n-        self.tm_nsec == (*other).tm_nsec\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Tm_) -> bool {\n         (*self).tm_sec == (*other).tm_sec &&\n         (*self).tm_min == (*other).tm_min &&\n@@ -122,10 +95,6 @@ impl Tm_ : Eq {\n         (*self).tm_zone == (*other).tm_zone &&\n         (*self).tm_nsec == (*other).tm_nsec\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Tm_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Tm_) -> bool { !(*self).eq(other) }\n }\n \n@@ -134,15 +103,7 @@ pub enum Tm {\n }\n \n impl Tm : Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Tm) -> bool { *self == *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Tm) -> bool { *(*self) == *(*other) }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Tm) -> bool { *self != *(*other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Tm) -> bool { *(*self) != *(*other) }\n }\n "}, {"sha": "d5a28a716ecc8b5cda1531042fb7708f6794f844", "filename": "src/libsyntax/alternate_crate.rc", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Falternate_crate.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be6613e048c889a0aeaff056131c2406259f1fb4/src%2Flibsyntax%2Falternate_crate.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Falternate_crate.rc?ref=be6613e048c889a0aeaff056131c2406259f1fb4", "patch": "@@ -1,128 +0,0 @@\n-#[link(name = \"syntax\",\n-       vers = \"0.5\",\n-       uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];\n-\n-\n-\n-#[crate_type = \"lib\"];\n-\n-#[no_core];\n-\n-#[legacy_modes];\n-#[legacy_exports];\n-\n-#[allow(vecs_implicitly_copyable)];\n-#[allow(non_camel_case_types)];\n-#[allow(deprecated_mode)];\n-#[allow(deprecated_pattern)];\n-\n-extern mod core(vers = \"0.5\");\n-extern mod std(vers = \"0.5\");\n-\n-use core::*;\n-\n-#[legacy_exports]\n-mod attr;\n-#[legacy_exports]\n-mod diagnostic;\n-mod codemap;\n-#[legacy_exports]\n-mod ast;\n-#[legacy_exports]\n-mod ast_util;\n-#[legacy_exports]\n-mod ast_map;\n-#[legacy_exports]\n-mod visit;\n-#[legacy_exports]\n-mod fold;\n-#[legacy_exports]\n-mod util {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"util/interner.rs\"]\n-    mod interner;\n-}\n-\n-#[merge = \"parse/mod.rs\"]\n-mod parse;\n-\n-mod print {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"print/pp.rs\"]\n-    mod pp;\n-    #[legacy_exports]\n-    #[path = \"print/pprust.rs\"]\n-    mod pprust;\n-}\n-\n-mod ext {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    #[path = \"ext/base.rs\"]\n-    mod base;\n-    #[legacy_exports]\n-    #[path = \"ext/expand.rs\"]\n-    mod expand;\n-    #[legacy_exports]\n-    #[path = \"ext/qquote.rs\"]\n-    mod qquote;\n-\n-    #[path = \"ext/quote.rs\"]\n-    mod quote;\n-    #[path = \"ext/deriving.rs\"]\n-    mod deriving;\n-\n-    #[legacy_exports]\n-    #[path = \"ext/build.rs\"]\n-    mod build;\n-\n-    mod tt {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        #[path = \"ext/tt/transcribe.rs\"]\n-        mod transcribe;\n-        #[legacy_exports]\n-        #[path = \"ext/tt/macro_parser.rs\"]\n-        mod macro_parser;\n-        #[legacy_exports]\n-        #[path = \"ext/tt/macro_rules.rs\"]\n-        mod macro_rules;\n-    }\n-\n-\n-    #[legacy_exports]\n-    #[path = \"ext/simplext.rs\"]\n-    mod simplext;\n-    #[legacy_exports]\n-    #[path = \"ext/fmt.rs\"]\n-    mod fmt;\n-    #[legacy_exports]\n-    #[path = \"ext/env.rs\"]\n-    mod env;\n-    #[legacy_exports]\n-    #[path = \"ext/concat_idents.rs\"]\n-    mod concat_idents;\n-    #[legacy_exports]\n-    #[path = \"ext/ident_to_str.rs\"]\n-    mod ident_to_str;\n-    #[legacy_exports]\n-    #[path = \"ext/log_syntax.rs\"]\n-    mod log_syntax;\n-    #[legacy_exports]\n-    #[path = \"ext/auto_serialize.rs\"]\n-    mod auto_serialize;\n-    #[legacy_exports]\n-    #[path = \"ext/source_util.rs\"]\n-    mod source_util;\n-\n-    #[legacy_exports]\n-    #[path = \"ext/pipes.rs\"]\n-    #[merge = \"ext/pipes/mod.rs\"]\n-    mod pipes;\n-\n-    #[legacy_exports]\n-    #[path = \"ext/trace_macros.rs\"]\n-    mod trace_macros;\n-}"}, {"sha": "1bfb1e772833b5343881a7902398a40c3a22d589", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 640, "changes": 640, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -50,15 +50,7 @@ impl<D: Deserializer> ident: Deserializable<D> {\n }\n \n impl ident: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ident) -> bool { self.repr == other.repr }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ident) -> bool { (*self).repr == other.repr }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ident) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n@@ -88,19 +80,9 @@ type node_id = int;\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &def_id) -> bool {\n-        self.crate == (*other).crate && self.node == (*other).node\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &def_id) -> bool {\n         (*self).crate == (*other).crate && (*self).node == (*other).node\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &def_id) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n }\n \n@@ -149,129 +131,6 @@ enum def {\n }\n \n impl def : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &def) -> bool {\n-        match self {\n-            def_fn(e0a, e1a) => {\n-                match (*other) {\n-                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_static_method(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_static_method(e0b, e1b, e2b) =>\n-                    e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_self(e0a) => {\n-                match (*other) {\n-                    def_self(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_mod(e0a) => {\n-                match (*other) {\n-                    def_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_foreign_mod(e0a) => {\n-                match (*other) {\n-                    def_foreign_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_const(e0a) => {\n-                match (*other) {\n-                    def_const(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_arg(e0a, e1a) => {\n-                match (*other) {\n-                    def_arg(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_local(e0a, e1a) => {\n-                match (*other) {\n-                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_variant(e0a, e1a) => {\n-                match (*other) {\n-                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_ty(e0a) => {\n-                match (*other) {\n-                    def_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_prim_ty(e0a) => {\n-                match (*other) {\n-                    def_prim_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_ty_param(e0a, e1a) => {\n-                match (*other) {\n-                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_binding(e0a, e1a) => {\n-                match (*other) {\n-                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_use(e0a) => {\n-                match (*other) {\n-                    def_use(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_upvar(e0a, e1a, e2a, e3a) => {\n-                match (*other) {\n-                    def_upvar(e0b, e1b, e2b, e3b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n-                    _ => false\n-                }\n-            }\n-            def_class(e0a) => {\n-                match (*other) {\n-                    def_class(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_typaram_binder(e0a) => {\n-                match (*other) {\n-                    def_typaram_binder(e1a) => e0a == e1a,\n-                    _ => false\n-                }\n-            }\n-            def_region(e0a) => {\n-                match (*other) {\n-                    def_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_label(e0a) => {\n-                match (*other) {\n-                    def_label(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &def) -> bool {\n         match (*self) {\n             def_fn(e0a, e1a) => {\n@@ -392,10 +251,6 @@ impl def : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &def) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &def) -> bool { !(*self).eq(other) }\n }\n \n@@ -464,37 +319,6 @@ impl binding_mode : to_bytes::IterBytes {\n }\n \n impl binding_mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binding_mode) -> bool {\n-        match self {\n-            bind_by_value => {\n-                match (*other) {\n-                    bind_by_value => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_move => {\n-                match (*other) {\n-                    bind_by_move => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_ref(e0a) => {\n-                match (*other) {\n-                    bind_by_ref(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            bind_by_implicit_ref => {\n-                match (*other) {\n-                    bind_by_implicit_ref => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binding_mode) -> bool {\n         match (*self) {\n             bind_by_value => {\n@@ -523,10 +347,6 @@ impl binding_mode : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binding_mode) -> bool { !(*self).eq(other) }\n }\n \n@@ -565,19 +385,9 @@ impl mutability : to_bytes::IterBytes {\n }\n \n impl mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &mutability) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &mutability) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n }\n \n@@ -591,19 +401,9 @@ pub enum Proto {\n }\n \n impl Proto : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Proto) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Proto) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Proto) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n }\n \n@@ -664,19 +464,9 @@ enum binop {\n }\n \n impl binop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binop) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binop) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n@@ -691,43 +481,6 @@ enum unop {\n }\n \n impl unop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &unop) -> bool {\n-        match self {\n-            box(e0a) => {\n-                match (*other) {\n-                    box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            uniq(e0a) => {\n-                match (*other) {\n-                    uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            deref => {\n-                match (*other) {\n-                    deref => true,\n-                    _ => false\n-                }\n-            }\n-            not => {\n-                match (*other) {\n-                    not => true,\n-                    _ => false\n-                }\n-            }\n-            neg => {\n-                match (*other) {\n-                    neg => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &unop) -> bool {\n         match (*self) {\n             box(e0a) => {\n@@ -762,12 +515,6 @@ impl unop : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &unop) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &unop) -> bool {\n         !(*self).eq(other)\n     }\n@@ -795,25 +542,6 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n }\n \n impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &inferable<T>) -> bool {\n-        match self {\n-            expl(e0a) => {\n-                match (*other) {\n-                    expl(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            infer(e0a) => {\n-                match (*other) {\n-                    infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &inferable<T>) -> bool {\n         match (*self) {\n             expl(e0a) => {\n@@ -830,10 +558,6 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &inferable<T>) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &inferable<T>) -> bool { !(*self).eq(other) }\n }\n \n@@ -850,19 +574,9 @@ impl rmode : to_bytes::IterBytes {\n \n \n impl rmode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &rmode) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &rmode) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &rmode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n }\n \n@@ -913,17 +627,6 @@ type field = spanned<field_>;\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &blk_check_mode) -> bool {\n-        match (self, (*other)) {\n-            (default_blk, default_blk) => true,\n-            (unsafe_blk, unsafe_blk) => true,\n-            (default_blk, _) => false,\n-            (unsafe_blk, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &blk_check_mode) -> bool {\n         match ((*self), (*other)) {\n             (default_blk, default_blk) => true,\n@@ -932,10 +635,6 @@ impl blk_check_mode : cmp::Eq {\n             (unsafe_blk, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n }\n \n@@ -1152,35 +851,6 @@ enum lit_ {\n }\n \n impl ast::lit_: cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ast::lit_) -> bool {\n-        match (self, *other) {\n-            (lit_str(a), lit_str(b)) => a == b,\n-            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n-            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n-            (lit_nil, lit_nil) => true,\n-            (lit_bool(a), lit_bool(b)) => a == b,\n-            (lit_str(_), _) => false,\n-            (lit_int(*), _) => false,\n-            (lit_uint(*), _) => false,\n-            (lit_int_unsuffixed(*), _) => false,\n-            (lit_float(*), _) => false,\n-            (lit_float_unsuffixed(*), _) => false,\n-            (lit_nil, _) => false,\n-            (lit_bool(_), _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ast::lit_) -> bool {\n         match ((*self), *other) {\n             (lit_str(a), lit_str(b)) => a == b,\n@@ -1207,10 +877,6 @@ impl ast::lit_: cmp::Eq {\n             (lit_bool(_), _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ast::lit_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ast::lit_) -> bool { !(*self).eq(other) }\n }\n \n@@ -1253,25 +919,6 @@ impl int_ty : to_bytes::IterBytes {\n }\n \n impl int_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &int_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_i, ty_i) => true,\n-            (ty_char, ty_char) => true,\n-            (ty_i8, ty_i8) => true,\n-            (ty_i16, ty_i16) => true,\n-            (ty_i32, ty_i32) => true,\n-            (ty_i64, ty_i64) => true,\n-            (ty_i, _) => false,\n-            (ty_char, _) => false,\n-            (ty_i8, _) => false,\n-            (ty_i16, _) => false,\n-            (ty_i32, _) => false,\n-            (ty_i64, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &int_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_i, ty_i) => true,\n@@ -1288,10 +935,6 @@ impl int_ty : cmp::Eq {\n             (ty_i64, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1306,23 +949,6 @@ impl uint_ty : to_bytes::IterBytes {\n }\n \n impl uint_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &uint_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_u, ty_u) => true,\n-            (ty_u8, ty_u8) => true,\n-            (ty_u16, ty_u16) => true,\n-            (ty_u32, ty_u32) => true,\n-            (ty_u64, ty_u64) => true,\n-            (ty_u, _) => false,\n-            (ty_u8, _) => false,\n-            (ty_u16, _) => false,\n-            (ty_u32, _) => false,\n-            (ty_u64, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &uint_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_u, ty_u) => true,\n@@ -1337,10 +963,6 @@ impl uint_ty : cmp::Eq {\n             (ty_u64, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1354,25 +976,12 @@ impl float_ty : to_bytes::IterBytes {\n     }\n }\n impl float_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &float_ty) -> bool {\n-        match (self, (*other)) {\n-            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n-            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &float_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n             (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1392,43 +1001,6 @@ enum prim_ty {\n }\n \n impl prim_ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &prim_ty) -> bool {\n-        match self {\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_str => {\n-                match (*other) {\n-                    ty_str => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &prim_ty) -> bool {\n         match (*self) {\n             ty_int(e0a) => {\n@@ -1463,10 +1035,6 @@ impl prim_ty : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n }\n \n@@ -1491,27 +1059,12 @@ enum Onceness {\n }\n \n impl Onceness : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Onceness) -> bool {\n-        match (self, *other) {\n-            (Once, Once) | (Many, Many) => true,\n-            _ => false\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Onceness) -> bool {\n         match ((*self), *other) {\n             (Once, Once) | (Many, Many) => true,\n             _ => false\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Onceness) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Onceness) -> bool {\n         !(*self).eq(other)\n     }\n@@ -1553,21 +1106,9 @@ enum ty_ {\n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n impl Ty : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Ty) -> bool {\n-        ptr::addr_of(&self) == ptr::addr_of(&(*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Ty) -> bool {\n         ptr::addr_of(&(*self)) == ptr::addr_of(&(*other))\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Ty) -> bool {\n-        ptr::addr_of(&self) != ptr::addr_of(&(*other))\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Ty) -> bool {\n         ptr::addr_of(&(*self)) != ptr::addr_of(&(*other))\n     }\n@@ -1607,19 +1148,9 @@ impl purity : to_bytes::IterBytes {\n }\n \n impl purity : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &purity) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &purity) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &purity) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n }\n \n@@ -1638,17 +1169,6 @@ impl ret_style : to_bytes::IterBytes {\n }\n \n impl ret_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ret_style) -> bool {\n-        match (self, (*other)) {\n-            (noreturn, noreturn) => true,\n-            (return_val, return_val) => true,\n-            (noreturn, _) => false,\n-            (return_val, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ret_style) -> bool {\n         match ((*self), (*other)) {\n             (noreturn, noreturn) => true,\n@@ -1657,10 +1177,6 @@ impl ret_style : cmp::Eq {\n             (return_val, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n }\n \n@@ -1676,49 +1192,6 @@ enum self_ty_ {\n }\n \n impl self_ty_ : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &self_ty_) -> bool {\n-        match self {\n-            sty_static => {\n-                match (*other) {\n-                    sty_static => true,\n-                    _ => false\n-                }\n-            }\n-            sty_by_ref => {\n-                match (*other) {\n-                    sty_by_ref => true,\n-                    _ => false\n-                }\n-            }\n-            sty_value => {\n-                match (*other) {\n-                    sty_value => true,\n-                    _ => false\n-                }\n-            }\n-            sty_region(e0a) => {\n-                match (*other) {\n-                    sty_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_box(e0a) => {\n-                match (*other) {\n-                    sty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_uniq(e0a) => {\n-                match (*other) {\n-                    sty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &self_ty_) -> bool {\n         match (*self) {\n             sty_static => {\n@@ -1759,10 +1232,6 @@ impl self_ty_ : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n }\n \n@@ -1794,36 +1263,13 @@ enum foreign_abi {\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &foreign_mod_sort) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &foreign_mod_sort) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n }\n \n impl foreign_abi : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &foreign_abi) -> bool {\n-        match (self, (*other)) {\n-            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n-            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n-            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n-            (foreign_abi_rust_intrinsic, _) => false,\n-            (foreign_abi_cdecl, _) => false,\n-            (foreign_abi_stdcall, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &foreign_abi) -> bool {\n         match ((*self), (*other)) {\n             (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n@@ -1834,10 +1280,6 @@ impl foreign_abi : cmp::Eq {\n             (foreign_abi_stdcall, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n }\n \n@@ -1886,19 +1328,9 @@ type path_list_ident = spanned<path_list_ident_>;\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &namespace) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &namespace) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n }\n \n@@ -1946,19 +1378,9 @@ type attribute = spanned<attribute_>;\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &attr_style) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &attr_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &attr_style) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &attr_style) -> bool { !(*self).eq(other) }\n }\n \n@@ -1985,19 +1407,6 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &visibility) -> bool {\n-        match (self, (*other)) {\n-            (public, public) => true,\n-            (private, private) => true,\n-            (inherited, inherited) => true,\n-            (public, _) => false,\n-            (private, _) => false,\n-            (inherited, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &visibility) -> bool {\n         match ((*self), (*other)) {\n             (public, public) => true,\n@@ -2008,10 +1417,6 @@ impl visibility : cmp::Eq {\n             (inherited, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n }\n \n@@ -2033,30 +1438,6 @@ enum struct_field_kind {\n }\n \n impl struct_field_kind : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &struct_field_kind) -> bool {\n-        match self {\n-            named_field(ident_a, class_mutability_a, visibility_a) => {\n-                match *other {\n-                    named_field(ident_b, class_mutability_b, visibility_b)\n-                            => {\n-                        ident_a == ident_b &&\n-                        class_mutability_a == class_mutability_b &&\n-                        visibility_a == visibility_b\n-                    }\n-                    unnamed_field => false\n-                }\n-            }\n-            unnamed_field => {\n-                match *other {\n-                    named_field(*) => false,\n-                    unnamed_field => true\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &struct_field_kind) -> bool {\n         match (*self) {\n             named_field(ident_a, class_mutability_a, visibility_a) => {\n@@ -2078,12 +1459,6 @@ impl struct_field_kind : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &struct_field_kind) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &struct_field_kind) -> bool {\n         !(*self).eq(other)\n     }\n@@ -2142,17 +1517,6 @@ impl class_mutability : to_bytes::IterBytes {\n }\n \n impl class_mutability : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &class_mutability) -> bool {\n-        match (self, (*other)) {\n-            (class_mutable, class_mutable) => true,\n-            (class_immutable, class_immutable) => true,\n-            (class_mutable, _) => false,\n-            (class_immutable, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &class_mutability) -> bool {\n         match ((*self), (*other)) {\n             (class_mutable, class_mutable) => true,\n@@ -2161,10 +1525,6 @@ impl class_mutability : cmp::Eq {\n             (class_immutable, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &class_mutability) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "3251ea5d2e9360fd420d927c6f8c7e35995e177e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -12,25 +12,6 @@ enum path_elt {\n }\n \n impl path_elt : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &path_elt) -> bool {\n-        match self {\n-            path_mod(e0a) => {\n-                match (*other) {\n-                    path_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            path_name(e0a) => {\n-                match (*other) {\n-                    path_name(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {\n@@ -47,10 +28,6 @@ impl path_elt : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &path_elt) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "468704c9affba0dba7c1eae5407676d72d85821b", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -338,19 +338,9 @@ enum inline_attr {\n }\n \n impl inline_attr : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &inline_attr) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &inline_attr) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &inline_attr) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "2b77c8057914b0ad50e62adb4de2736e332577b1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -37,29 +37,11 @@ impl BytePos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-#[cfg(stage0)]\n-impl BytePos: cmp::Eq {\n-    pure fn eq(other: &BytePos) -> bool { *self == **other }\n-    pure fn ne(other: &BytePos) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl BytePos: cmp::Eq {\n     pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n     pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl BytePos: cmp::Ord {\n-    pure fn lt(other: &BytePos) -> bool { *self < **other }\n-    pure fn le(other: &BytePos) -> bool { *self <= **other }\n-    pure fn ge(other: &BytePos) -> bool { *self >= **other }\n-    pure fn gt(other: &BytePos) -> bool { *self > **other }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl BytePos: cmp::Ord {\n     pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n     pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n@@ -101,29 +83,11 @@ impl CharPos: Pos {\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-#[cfg(stage0)]\n-impl CharPos: cmp::Eq {\n-    pure fn eq(other: &CharPos) -> bool { *self == **other }\n-    pure fn ne(other: &CharPos) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CharPos: cmp::Eq {\n     pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n     pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n-#[cfg(stage0)]\n-impl CharPos: cmp::Ord {\n-    pure fn lt(other: &CharPos) -> bool { *self < **other }\n-    pure fn le(other: &CharPos) -> bool { *self <= **other }\n-    pure fn ge(other: &CharPos) -> bool { *self >= **other }\n-    pure fn gt(other: &CharPos) -> bool { *self > **other }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl CharPos: cmp::Ord {\n     pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n     pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n@@ -173,19 +137,9 @@ pub struct span {\n }\n \n impl span : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &span) -> bool {\n-        return self.lo == (*other).lo && self.hi == (*other).hi;\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &span) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "8784b3837f17c19a2170c986d358f960142727a1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -149,19 +149,9 @@ enum level {\n }\n \n impl level : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &level) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &level) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &level) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "18caef0f72f6078123659421604801a5b98fdbc6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -6,17 +6,6 @@ use ast_builder::{path, append_types};\n enum direction { send, recv }\n \n impl direction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &direction) -> bool {\n-        match (self, (*other)) {\n-            (send, send) => true,\n-            (recv, recv) => true,\n-            (send, _) => false,\n-            (recv, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &direction) -> bool {\n         match ((*self), (*other)) {\n             (send, send) => true,\n@@ -25,10 +14,6 @@ impl direction : cmp::Eq {\n             (recv, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &direction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &direction) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "4f7bfb0d4e9f1d26dba864549ffbc7ea1f7a0532", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -20,21 +20,9 @@ enum cmnt_style {\n }\n \n impl cmnt_style : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &cmnt_style) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &cmnt_style) -> bool {\n-        (self as uint) != ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) != ((*other) as uint)\n     }"}, {"sha": "4304c01fdb63057b66ec611d8e1775973c309067", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -29,21 +29,9 @@ pub enum ObsoleteSyntax {\n }\n \n impl ObsoleteSyntax : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &ObsoleteSyntax) -> bool {\n-        self as uint == (*other) as uint\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &ObsoleteSyntax) -> bool {\n         (*self) as uint == (*other) as uint\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &ObsoleteSyntax) -> bool {\n-        !self.eq(other)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &ObsoleteSyntax) -> bool {\n         !(*self).eq(other)\n     }"}, {"sha": "921fcfccc28c65b2cb480e334d3e81796b00f264", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -3747,19 +3747,9 @@ impl Parser {\n }\n \n impl restriction : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &restriction) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &restriction) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &restriction) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &restriction) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "3ee99c16e49915f1448bbb0162fd638a56e6c168", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -463,294 +463,13 @@ fn reserved_keyword_table() -> HashMap<~str, ()> {\n }\n \n impl binop : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &binop) -> bool {\n-        (self as uint) == ((*other) as uint)\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &binop) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &binop) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n }\n \n impl Token : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &Token) -> bool {\n-        match self {\n-            EQ => {\n-                match (*other) {\n-                    EQ => true,\n-                    _ => false\n-                }\n-            }\n-            LT => {\n-                match (*other) {\n-                    LT => true,\n-                    _ => false\n-                }\n-            }\n-            LE => {\n-                match (*other) {\n-                    LE => true,\n-                    _ => false\n-                }\n-            }\n-            EQEQ => {\n-                match (*other) {\n-                    EQEQ => true,\n-                    _ => false\n-                }\n-            }\n-            NE => {\n-                match (*other) {\n-                    NE => true,\n-                    _ => false\n-                }\n-            }\n-            GE => {\n-                match (*other) {\n-                    GE => true,\n-                    _ => false\n-                }\n-            }\n-            GT => {\n-                match (*other) {\n-                    GT => true,\n-                    _ => false\n-                }\n-            }\n-            ANDAND => {\n-                match (*other) {\n-                    ANDAND => true,\n-                    _ => false\n-                }\n-            }\n-            OROR => {\n-                match (*other) {\n-                    OROR => true,\n-                    _ => false\n-                }\n-            }\n-            NOT => {\n-                match (*other) {\n-                    NOT => true,\n-                    _ => false\n-                }\n-            }\n-            TILDE => {\n-                match (*other) {\n-                    TILDE => true,\n-                    _ => false\n-                }\n-            }\n-            BINOP(e0a) => {\n-                match (*other) {\n-                    BINOP(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            BINOPEQ(e0a) => {\n-                match (*other) {\n-                    BINOPEQ(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            AT => {\n-                match (*other) {\n-                    AT => true,\n-                    _ => false\n-                }\n-            }\n-            DOT => {\n-                match (*other) {\n-                    DOT => true,\n-                    _ => false\n-                }\n-            }\n-            DOTDOT => {\n-                match (*other) {\n-                    DOTDOT => true,\n-                    _ => false\n-                }\n-            }\n-            ELLIPSIS => {\n-                match (*other) {\n-                    ELLIPSIS => true,\n-                    _ => false\n-                }\n-            }\n-            COMMA => {\n-                match (*other) {\n-                    COMMA => true,\n-                    _ => false\n-                }\n-            }\n-            SEMI => {\n-                match (*other) {\n-                    SEMI => true,\n-                    _ => false\n-                }\n-            }\n-            COLON => {\n-                match (*other) {\n-                    COLON => true,\n-                    _ => false\n-                }\n-            }\n-            MOD_SEP => {\n-                match (*other) {\n-                    MOD_SEP => true,\n-                    _ => false\n-                }\n-            }\n-            RARROW => {\n-                match (*other) {\n-                    RARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LARROW => {\n-                match (*other) {\n-                    LARROW => true,\n-                    _ => false\n-                }\n-            }\n-            DARROW => {\n-                match (*other) {\n-                    DARROW => true,\n-                    _ => false\n-                }\n-            }\n-            FAT_ARROW => {\n-                match (*other) {\n-                    FAT_ARROW => true,\n-                    _ => false\n-                }\n-            }\n-            LPAREN => {\n-                match (*other) {\n-                    LPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            RPAREN => {\n-                match (*other) {\n-                    RPAREN => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACKET => {\n-                match (*other) {\n-                    LBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACKET => {\n-                match (*other) {\n-                    RBRACKET => true,\n-                    _ => false\n-                }\n-            }\n-            LBRACE => {\n-                match (*other) {\n-                    LBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            RBRACE => {\n-                match (*other) {\n-                    RBRACE => true,\n-                    _ => false\n-                }\n-            }\n-            POUND => {\n-                match (*other) {\n-                    POUND => true,\n-                    _ => false\n-                }\n-            }\n-            DOLLAR => {\n-                match (*other) {\n-                    DOLLAR => true,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_INT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_UINT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_UINT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_INT_UNSUFFIXED(e0a) => {\n-                match (*other) {\n-                    LIT_INT_UNSUFFIXED(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            LIT_FLOAT(e0a, e1a) => {\n-                match (*other) {\n-                    LIT_FLOAT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            LIT_FLOAT_UNSUFFIXED(e0a) => {\n-                match (*other) {\n-                    LIT_FLOAT_UNSUFFIXED(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            LIT_STR(e0a) => {\n-                match (*other) {\n-                    LIT_STR(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            IDENT(e0a, e1a) => {\n-                match (*other) {\n-                    IDENT(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            UNDERSCORE => {\n-                match (*other) {\n-                    UNDERSCORE => true,\n-                    _ => false\n-                }\n-            }\n-            INTERPOLATED(_) => {\n-                match (*other) {\n-                    INTERPOLATED(_) => true,\n-                    _ => false\n-                }\n-            }\n-            DOC_COMMENT(e0a) => {\n-                match (*other) {\n-                    DOC_COMMENT(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            EOF => {\n-                match (*other) {\n-                    EOF => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &Token) -> bool {\n         match (*self) {\n             EQ => {\n@@ -1019,10 +738,6 @@ impl Token : cmp::Eq {\n             }\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &Token) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &Token) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "014d564b84e4d53f2ecfacb3c6a4ac00c7f35b43", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -56,17 +56,6 @@ use dvec::DVec;\n enum breaks { consistent, inconsistent, }\n \n impl breaks : cmp::Eq {\n-    #[cfg(stage0)]\n-    pure fn eq(other: &breaks) -> bool {\n-        match (self, (*other)) {\n-            (consistent, consistent) => true,\n-            (inconsistent, inconsistent) => true,\n-            (consistent, _) => false,\n-            (inconsistent, _) => false,\n-        }\n-    }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn eq(&self, other: &breaks) -> bool {\n         match ((*self), (*other)) {\n             (consistent, consistent) => true,\n@@ -75,10 +64,6 @@ impl breaks : cmp::Eq {\n             (inconsistent, _) => false,\n         }\n     }\n-    #[cfg(stage0)]\n-    pure fn ne(other: &breaks) -> bool { !self.eq(other) }\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n     pure fn ne(&self, other: &breaks) -> bool { !(*self).eq(other) }\n }\n "}, {"sha": "d5a28a716ecc8b5cda1531042fb7708f6794f844", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1,5 +1,3 @@\n-// DIVERT\n-\n #[link(name = \"syntax\",\n        vers = \"0.5\",\n        uuid = \"9311401b-d6ea-4cd9-a1d9-61f89499c645\")];\n@@ -42,116 +40,89 @@ mod fold;\n mod util {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"util/interner.rs\"]\n     mod interner;\n }\n \n-mod parse {\n-    #[legacy_exports];\n-    export parser;\n-    export common;\n-    export lexer;\n-    export token;\n-    export comments;\n-    export prec;\n-    export classify;\n-    export attr;\n-\n-    #[legacy_exports]\n-    mod lexer;\n-    #[legacy_exports]\n-    mod parser;\n-    #[legacy_exports]\n-    mod token;\n-    #[legacy_exports]\n-    mod comments;\n-    #[legacy_exports]\n-    mod attr;\n-    #[legacy_exports]\n-\n-    /// Common routines shared by parser mods\n-    #[legacy_exports]\n-    mod common;\n-\n-    /// Functions dealing with operator precedence\n-    #[legacy_exports]\n-    mod prec;\n-\n-    /// Routines the parser uses to classify AST nodes\n-    #[legacy_exports]\n-    mod classify;\n-\n-    /// Reporting obsolete syntax\n-    #[legacy_exports]\n-    mod obsolete;\n-}\n+#[merge = \"parse/mod.rs\"]\n+mod parse;\n \n mod print {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"print/pp.rs\"]\n     mod pp;\n     #[legacy_exports]\n+    #[path = \"print/pprust.rs\"]\n     mod pprust;\n }\n \n mod ext {\n     #[legacy_exports];\n     #[legacy_exports]\n+    #[path = \"ext/base.rs\"]\n     mod base;\n     #[legacy_exports]\n+    #[path = \"ext/expand.rs\"]\n     mod expand;\n     #[legacy_exports]\n+    #[path = \"ext/qquote.rs\"]\n     mod qquote;\n \n+    #[path = \"ext/quote.rs\"]\n     mod quote;\n+    #[path = \"ext/deriving.rs\"]\n     mod deriving;\n \n     #[legacy_exports]\n+    #[path = \"ext/build.rs\"]\n     mod build;\n \n     mod tt {\n         #[legacy_exports];\n         #[legacy_exports]\n+        #[path = \"ext/tt/transcribe.rs\"]\n         mod transcribe;\n         #[legacy_exports]\n+        #[path = \"ext/tt/macro_parser.rs\"]\n         mod macro_parser;\n         #[legacy_exports]\n+        #[path = \"ext/tt/macro_rules.rs\"]\n         mod macro_rules;\n     }\n \n \n     #[legacy_exports]\n+    #[path = \"ext/simplext.rs\"]\n     mod simplext;\n     #[legacy_exports]\n+    #[path = \"ext/fmt.rs\"]\n     mod fmt;\n     #[legacy_exports]\n+    #[path = \"ext/env.rs\"]\n     mod env;\n     #[legacy_exports]\n+    #[path = \"ext/concat_idents.rs\"]\n     mod concat_idents;\n     #[legacy_exports]\n+    #[path = \"ext/ident_to_str.rs\"]\n     mod ident_to_str;\n     #[legacy_exports]\n+    #[path = \"ext/log_syntax.rs\"]\n     mod log_syntax;\n     #[legacy_exports]\n+    #[path = \"ext/auto_serialize.rs\"]\n     mod auto_serialize;\n     #[legacy_exports]\n+    #[path = \"ext/source_util.rs\"]\n     mod source_util;\n \n-    mod pipes {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod ast_builder;\n-        #[legacy_exports]\n-        mod parse_proto;\n-        #[legacy_exports]\n-        mod pipec;\n-        #[legacy_exports]\n-        mod proto;\n-        #[legacy_exports]\n-        mod check;\n-        #[legacy_exports]\n-        mod liveness;\n-    }\n+    #[legacy_exports]\n+    #[path = \"ext/pipes.rs\"]\n+    #[merge = \"ext/pipes/mod.rs\"]\n+    mod pipes;\n \n     #[legacy_exports]\n+    #[path = \"ext/trace_macros.rs\"]\n     mod trace_macros;\n }"}, {"sha": "cf216fe923c79d0005ce6dc14b208fd20cf0e6b4", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8179e268efd86ae5c1bcf21b4f8d4e01eea7c193/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=8179e268efd86ae5c1bcf21b4f8d4e01eea7c193", "patch": "@@ -1,3 +1,11 @@\n+S 2012-11-26 be6613e\n+  winnt-i386 f800925ce98d23f842a03be65f01aae0dfa1e897\n+  freebsd-x86_64 23462b234b8ff3c0b6d6f94e5952178dbcef3488\n+  linux-i386 e5fc408495952b61c3c103265cf1f54e2ab51e05\n+  linux-x86_64 beb6454c57267c9fb198e4f0f8d4773e28f5bdf4\n+  macos-i386 46b83a3fec0731198e010827c6842f2854cc79df\n+  macos-x86_64 d06b16853e2a81fa5edb7fb2de73e6665c1ccd28\n+\n S 2012-11-18 68c73dc\n   freebsd-x86_64 976e75614c455557e3763e270cbf7b5fce1c5c67\n   linux-i386 d44088ce7183622921626038becf9c5e2d76cb66"}]}