{"sha": "0ad7ae523cca6cb6bb35037e37513d38423c2e05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDdhZTUyM2NjYTZjYjZiYjM1MDM3ZTM3NTEzZDM4NDIzYzJlMDU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-26T23:47:33Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:38Z"}, "message": "Macro and iface tricks to simulate self move.", "tree": {"sha": "00a0b1b0cfd853ed09953cbaa3a712b0b1fbf1f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00a0b1b0cfd853ed09953cbaa3a712b0b1fbf1f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad7ae523cca6cb6bb35037e37513d38423c2e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad7ae523cca6cb6bb35037e37513d38423c2e05", "html_url": "https://github.com/rust-lang/rust/commit/0ad7ae523cca6cb6bb35037e37513d38423c2e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad7ae523cca6cb6bb35037e37513d38423c2e05/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d3cdc3dfe5cbf9a6a1d16e8bc57fe4532329da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d3cdc3dfe5cbf9a6a1d16e8bc57fe4532329da", "html_url": "https://github.com/rust-lang/rust/commit/c2d3cdc3dfe5cbf9a6a1d16e8bc57fe4532329da"}], "stats": {"total": 307, "additions": 307, "deletions": 0}, "files": [{"sha": "bdfde62ecc77ef215590a5990169eb34497a608a", "filename": "src/test/run-pass/pipe-manual-3.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7ae523cca6cb6bb35037e37513d38423c2e05/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7ae523cca6cb6bb35037e37513d38423c2e05/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-3.rs?ref=0ad7ae523cca6cb6bb35037e37513d38423c2e05", "patch": "@@ -0,0 +1,307 @@\n+/*\n+The first test case using pipes. The idea is to break this into\n+several stages for prototyping. Here's the plan:\n+\n+1. Write an already-compiled protocol using existing ports and chans.\n+\n+2. Take the already-compiled version and add the low-level\n+synchronization code instead.\n+\n+3. Write a syntax extension to compile the protocols.\n+\n+At some point, we'll need to add support for select.\n+\n+This file does horrible things to pretend we have self-move.\n+\n+*/\n+\n+// Hopefully someday we'll move this into core.\n+mod pipes {\n+    import unsafe::{forget, reinterpret_cast};\n+\n+    enum state {\n+        empty,\n+        full,\n+        blocked,\n+        terminated\n+    }\n+\n+    type packet<T: send> = {\n+        mut state: state,\n+        mut blocked_task: option<task::task>,\n+        mut payload: option<T>\n+    };\n+\n+    fn packet<T: send>() -> *packet<T> unsafe {\n+        let p: *packet<T> = unsafe::transmute(~{\n+            mut state: empty,\n+            mut blocked_task: none::<task::task>,\n+            mut payload: none::<T>\n+        });\n+        p\n+    }\n+\n+    #[abi = \"rust-intrinsic\"]\n+    native mod rusti {\n+        fn atomic_xchng(&dst: int, src: int) -> int;\n+        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n+        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+    }\n+\n+    // We should consider moving this to core::unsafe, although I\n+    // suspect graydon would want us to use void pointers instead.\n+    unsafe fn uniquify<T>(x: *T) -> ~T {\n+        unsafe { unsafe::reinterpret_cast(x) }\n+    }\n+\n+    fn swap_state_acq(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_acq(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn swap_state_rel(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_rel(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn send<T: send>(-p: send_packet<T>, -payload: T) {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        assert (*p).payload == none;\n+        (*p).payload <- some(payload);\n+        let old_state = swap_state_rel((*p).state, full);\n+        alt old_state {\n+          empty {\n+            // Yay, fastpath.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          full { fail \"duplicate send\" }\n+          blocked {\n+            // FIXME: once the target will actually block, tell the\n+            // scheduler to wake it up.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          terminated {\n+            // The receiver will never receive this. Rely on drop_glue\n+            // to clean everything up.\n+          }\n+        }\n+    }\n+\n+    fn recv<T: send>(-p: recv_packet<T>) -> option<T> {\n+        let p = p.unwrap();\n+        let p = unsafe { uniquify(p) };\n+        loop {\n+            let old_state = swap_state_acq((*p).state,\n+                                           blocked);\n+            alt old_state {\n+              empty | blocked { task::yield(); }\n+              full {\n+                let mut payload = none;\n+                payload <-> (*p).payload;\n+                ret some(option::unwrap(payload))\n+              }\n+              terminated {\n+                assert old_state == terminated;\n+                ret none;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn sender_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty | blocked {\n+            // The receiver will eventually clean up.\n+            unsafe { forget(p) }\n+          }\n+          full {\n+            // This is impossible\n+            fail \"you dun goofed\"\n+          }\n+          terminated {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    fn receiver_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty {\n+            // the sender will clean up\n+            unsafe { forget(p) }\n+          }\n+          blocked {\n+            // this shouldn't happen.\n+            fail \"terminating a blocked packet\"\n+          }\n+          terminated | full {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    class send_packet<T: send> {\n+        let mut p: option<*packet<T>>;\n+        new(p: *packet<T>) { self.p = some(p); }\n+        drop {\n+            if self.p != none {\n+                let mut p = none;\n+                p <-> self.p;\n+                sender_terminate(option::unwrap(p))\n+            }\n+        }\n+        fn unwrap() -> *packet<T> {\n+            let mut p = none;\n+            p <-> self.p;\n+            option::unwrap(p)\n+        }\n+    }\n+\n+    class recv_packet<T: send> {\n+        let mut p: option<*packet<T>>;\n+        new(p: *packet<T>) { self.p = some(p); }\n+        drop {\n+            if self.p != none {\n+                let mut p = none;\n+                p <-> self.p;\n+                receiver_terminate(option::unwrap(p))\n+            }\n+        }\n+        fn unwrap() -> *packet<T> {\n+            let mut p = none;\n+            p <-> self.p;\n+            option::unwrap(p)\n+        }\n+    }\n+\n+    fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+        let p = packet();\n+        (send_packet(p), recv_packet(p))\n+    }\n+}\n+\n+mod pingpong {\n+    enum ping { ping, }\n+    enum ping_message = *pipes::packet<pong_message>;\n+    enum pong { pong, }\n+    enum pong_message = *pipes::packet<ping_message>;\n+\n+    fn init() -> (client::ping, server::ping) {\n+        pipes::entangle()\n+    }\n+\n+    mod client {\n+        type ping = pipes::send_packet<pingpong::ping_message>;\n+        type pong = pipes::recv_packet<pingpong::pong_message>;\n+    }\n+\n+    impl abominable for client::ping {\n+        fn send() -> fn@(-client::ping, ping) -> client::pong {\n+            {|pipe, data|\n+                let p = pipes::packet();\n+                pipes::send(pipe, pingpong::ping_message(p));\n+                pipes::recv_packet(p)\n+            }\n+        }\n+    }\n+\n+    impl abominable for client::pong {\n+        fn recv() -> fn@(-client::pong) -> (client::ping, pong) {\n+            {|pipe|\n+                let packet = pipes::recv(pipe);\n+                if packet == none {\n+                    fail \"sender closed the connection\"\n+                }\n+                let p : pong_message = option::unwrap(packet);\n+                (pipes::send_packet(*p), pong)\n+            }\n+        }\n+    }\n+\n+    mod server {\n+        type ping = pipes::recv_packet<pingpong::ping_message>;\n+        type pong = pipes::send_packet<pingpong::pong_message>;\n+    }\n+\n+    impl abominable for server::ping {\n+        fn recv() -> fn@(-server::ping) -> (server::pong, ping) {\n+            {|pipe|\n+                let packet = pipes::recv(pipe);\n+                if packet == none {\n+                    fail \"sender closed the connection\"\n+                }\n+                let p : ping_message = option::unwrap(packet);\n+                (pipes::send_packet(*p), ping)\n+            }\n+        }\n+    }\n+\n+    impl abominable for server::pong {\n+        fn send() -> fn@(-server::pong, pong) -> server::ping {\n+            {|pipe, data|\n+                let p = pipes::packet();\n+                pipes::send(pipe, pingpong::pong_message(p));\n+                pipes::recv_packet(p)\n+            }\n+        }\n+    }\n+}\n+\n+mod test {\n+    import pingpong::{ping, pong, abominable};\n+\n+    fn macros() {\n+        #macro[\n+            [#send[chan, data, ...],\n+             chan.send()(chan, data, ...)]\n+        ];\n+        #macro[\n+            [#recv[chan],\n+             chan.recv()(chan)]\n+        ];\n+    }\n+\n+    fn client(-chan: pingpong::client::ping) {\n+        let chan = #send(chan, ping);\n+        log(error, \"Sent ping\");\n+        let (chan, _data) = #recv(chan);\n+        log(error, \"Received pong\");\n+    }\n+    \n+    fn server(-chan: pingpong::server::ping) {\n+        let (chan, _data) = #recv(chan);\n+        log(error, \"Received ping\");\n+        let chan = #send(chan, pong);\n+        log(error, \"Sent pong\");\n+    }\n+}\n+\n+fn main() {\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+\n+    task::spawn {|move client_|\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        test::client(option::unwrap(client__));\n+    };\n+    task::spawn {|move server_|\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        test::server(option::unwrap(server_\u02ca));\n+    };\n+}"}]}