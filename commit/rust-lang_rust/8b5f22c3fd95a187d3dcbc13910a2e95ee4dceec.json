{"sha": "8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNWYyMmMzZmQ5NWExODdkM2RjYmMxMzkxMGEyZTk1ZWU0ZGNlZWM=", "commit": {"author": {"name": "David Renshaw", "email": "dwrenshaw@gmail.com", "date": "2017-08-26T17:48:59Z"}, "committer": {"name": "David Renshaw", "email": "dwrenshaw@gmail.com", "date": "2017-08-26T17:48:59Z"}, "message": "use rustc version of fulfill_obligation now that we can", "tree": {"sha": "ad0afab0aaf3fab3254f1b6238e11f480036a9b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0afab0aaf3fab3254f1b6238e11f480036a9b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec", "html_url": "https://github.com/rust-lang/rust/commit/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec/comments", "author": {"login": "dwrensha", "id": 495768, "node_id": "MDQ6VXNlcjQ5NTc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwrensha", "html_url": "https://github.com/dwrensha", "followers_url": "https://api.github.com/users/dwrensha/followers", "following_url": "https://api.github.com/users/dwrensha/following{/other_user}", "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions", "organizations_url": "https://api.github.com/users/dwrensha/orgs", "repos_url": "https://api.github.com/users/dwrensha/repos", "events_url": "https://api.github.com/users/dwrensha/events{/privacy}", "received_events_url": "https://api.github.com/users/dwrensha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dwrensha", "id": 495768, "node_id": "MDQ6VXNlcjQ5NTc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwrensha", "html_url": "https://github.com/dwrensha", "followers_url": "https://api.github.com/users/dwrensha/followers", "following_url": "https://api.github.com/users/dwrensha/following{/other_user}", "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions", "organizations_url": "https://api.github.com/users/dwrensha/orgs", "repos_url": "https://api.github.com/users/dwrensha/repos", "events_url": "https://api.github.com/users/dwrensha/events{/privacy}", "received_events_url": "https://api.github.com/users/dwrensha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54a1f079b8bbde11cf9690452430448515743bb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/54a1f079b8bbde11cf9690452430448515743bb5", "html_url": "https://github.com/rust-lang/rust/commit/54a1f079b8bbde11cf9690452430448515743bb5"}], "stats": {"total": 86, "additions": 3, "deletions": 83}, "files": [{"sha": "3e00b8a6fbc0d7018339a18e26cdd53cd51d4603", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8b5f22c3fd95a187d3dcbc13910a2e95ee4dceec", "patch": "@@ -10,10 +10,9 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size, Align, HasDataLayout};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n-use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP, Span};\n-use syntax::ast::{self, Mutability};\n+use syntax::codemap::{self, DUMMY_SP};\n+use syntax::ast::Mutability;\n use syntax::abi::Abi;\n \n use super::{EvalError, EvalResult, EvalErrorKind, GlobalId, Lvalue, LvalueExtra, Memory,\n@@ -2312,7 +2311,7 @@ fn resolve_associated_item<'a, 'tcx>(\n     );\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(tcx, DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -2419,85 +2418,6 @@ fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(tcx, ty::ParamEnv::empty(Reveal::All), DUMMY_SP)\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    span: Span,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> traits::Vtable<'tcx, ()> {\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    debug!(\n-        \"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-        trait_ref,\n-        trait_ref.def_id()\n-    );\n-\n-    // Do the initial selection for the obligation. This yields the\n-    // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-        let obligation_cause = traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-        let obligation = traits::Obligation::new(\n-            obligation_cause,\n-            ty::ParamEnv::empty(Reveal::All),\n-            trait_ref.to_poly_trait_predicate(),\n-        );\n-\n-        let selection = match selcx.select(&obligation) {\n-            Ok(Some(selection)) => selection,\n-            Ok(None) => {\n-                // Ambiguity can happen when monomorphizing during trans\n-                // expands to some humongo type that never occurred\n-                // statically -- this humongo type can then overflow,\n-                // leading to an ambiguous result. So report this as an\n-                // overflow bug, since I believe this is the only case\n-                // where ambiguity can result.\n-                debug!(\n-                    \"Encountered ambiguity selecting `{:?}` during trans, \\\n-                        presuming due to overflow\",\n-                    trait_ref\n-                );\n-                tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization \\\n-                        (selection ambiguity)\",\n-                );\n-            }\n-            Err(e) => {\n-                span_bug!(\n-                    span,\n-                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                    e,\n-                    trait_ref\n-                )\n-            }\n-        };\n-\n-        debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-        // Currently, we use a fulfillment context to completely resolve\n-        // all nested obligations. This is because they can inform the\n-        // inference of the impl's type parameters.\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let vtable = selection.map(|predicate| {\n-            debug!(\n-                \"fulfill_obligation: register_predicate_obligation {:?}\",\n-                predicate\n-            );\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n-        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-        debug!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-        vtable\n-    })\n-}\n-\n pub fn resolve_drop_in_place<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,"}]}