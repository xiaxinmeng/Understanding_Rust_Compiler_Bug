{"sha": "09bded443745a05daaeeca76e4b032381ca1a126", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YmRlZDQ0Mzc0NWEwNWRhYWVlY2E3NmU0YjAzMjM4MWNhMWExMjY=", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-02-17T17:42:21Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-02-23T23:50:30Z"}, "message": "Factor out `clippy_utils` crate", "tree": {"sha": "869873b3e41db89b08d69e50d76c1f59b68ebfec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/869873b3e41db89b08d69e50d76c1f59b68ebfec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09bded443745a05daaeeca76e4b032381ca1a126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09bded443745a05daaeeca76e4b032381ca1a126", "html_url": "https://github.com/rust-lang/rust/commit/09bded443745a05daaeeca76e4b032381ca1a126", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09bded443745a05daaeeca76e4b032381ca1a126/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2c25fa9f0a35d38506918a41f893231f67c5b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c25fa9f0a35d38506918a41f893231f67c5b24", "html_url": "https://github.com/rust-lang/rust/commit/a2c25fa9f0a35d38506918a41f893231f67c5b24"}], "stats": {"total": 1459, "additions": 778, "deletions": 681}, "files": [{"sha": "139129d55e330af9d2f323986a1c621878152625", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -18,6 +18,7 @@ out\n *Cargo.lock\n /target\n /clippy_lints/target\n+/clippy_utils/target\n /clippy_workspace_tests/target\n /clippy_dev/target\n /rustc_tools_util/target"}, {"sha": "f09df3393d7f9fa77e73a9c43094906353101cea", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -18,6 +18,7 @@ edition = \"2018\"\n \n [dependencies]\n cargo_metadata = \"0.12\"\n+clippy_utils = { path = \"../clippy_utils\" }\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n pulldown-cmark = { version = \"0.8\", default-features = false }"}, {"sha": "7e87f53e3fba7d2a7c8b739689d9dc416b77810e", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 574, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,574 +1 @@\n-#![allow(clippy::float_cmp)]\n-\n-use crate::utils::{clip, sext, unsext};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitFloatType, LitKind};\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n-use rustc_lint::LateContext;\n-use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n-use rustc_span::symbol::Symbol;\n-use std::cmp::Ordering::{self, Equal};\n-use std::convert::TryInto;\n-use std::hash::{Hash, Hasher};\n-\n-/// A `LitKind`-like enum to fold constant `Expr`s into.\n-#[derive(Debug, Clone)]\n-pub enum Constant {\n-    /// A `String` (e.g., \"abc\").\n-    Str(String),\n-    /// A binary string (e.g., `b\"abc\"`).\n-    Binary(Lrc<[u8]>),\n-    /// A single `char` (e.g., `'a'`).\n-    Char(char),\n-    /// An integer's bit representation.\n-    Int(u128),\n-    /// An `f32`.\n-    F32(f32),\n-    /// An `f64`.\n-    F64(f64),\n-    /// `true` or `false`.\n-    Bool(bool),\n-    /// An array of constants.\n-    Vec(Vec<Constant>),\n-    /// Also an array, but with only one constant, repeated N times.\n-    Repeat(Box<Constant>, u64),\n-    /// A tuple of constants.\n-    Tuple(Vec<Constant>),\n-    /// A raw pointer.\n-    RawPtr(u128),\n-    /// A reference\n-    Ref(Box<Constant>),\n-    /// A literal with syntax error.\n-    Err(Symbol),\n-}\n-\n-impl PartialEq for Constant {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n-            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n-            (&Self::Char(l), &Self::Char(r)) => l == r,\n-            (&Self::Int(l), &Self::Int(r)) => l == r,\n-            (&Self::F64(l), &Self::F64(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                l.to_bits() == r.to_bits()\n-            },\n-            (&Self::F32(l), &Self::F32(r)) => {\n-                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n-                // `Fw32 == Fw64`, so don\u2019t compare them.\n-                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n-                f64::from(l).to_bits() == f64::from(r).to_bits()\n-            },\n-            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n-            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n-            // TODO: are there inter-type equalities?\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Hash for Constant {\n-    fn hash<H>(&self, state: &mut H)\n-    where\n-        H: Hasher,\n-    {\n-        std::mem::discriminant(self).hash(state);\n-        match *self {\n-            Self::Str(ref s) => {\n-                s.hash(state);\n-            },\n-            Self::Binary(ref b) => {\n-                b.hash(state);\n-            },\n-            Self::Char(c) => {\n-                c.hash(state);\n-            },\n-            Self::Int(i) => {\n-                i.hash(state);\n-            },\n-            Self::F32(f) => {\n-                f64::from(f).to_bits().hash(state);\n-            },\n-            Self::F64(f) => {\n-                f.to_bits().hash(state);\n-            },\n-            Self::Bool(b) => {\n-                b.hash(state);\n-            },\n-            Self::Vec(ref v) | Self::Tuple(ref v) => {\n-                v.hash(state);\n-            },\n-            Self::Repeat(ref c, l) => {\n-                c.hash(state);\n-                l.hash(state);\n-            },\n-            Self::RawPtr(u) => {\n-                u.hash(state);\n-            },\n-            Self::Ref(ref r) => {\n-                r.hash(state);\n-            },\n-            Self::Err(ref s) => {\n-                s.hash(state);\n-            },\n-        }\n-    }\n-}\n-\n-impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n-        match (left, right) {\n-            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n-            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n-            (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = *cmp_type.kind() {\n-                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n-                } else {\n-                    Some(l.cmp(&r))\n-                }\n-            },\n-            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n-            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n-            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n-                .iter()\n-                .zip(r.iter())\n-                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n-            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n-                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n-                    Some(Equal) => Some(ls.cmp(rs)),\n-                    x => x,\n-                }\n-            },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n-            // TODO: are there any useful inter-type orderings?\n-            _ => None,\n-        }\n-    }\n-}\n-\n-/// Parses a `LitKind` to a `Constant`.\n-pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n-    match *lit {\n-        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n-        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n-        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n-        LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(n, _) => Constant::Int(n),\n-        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n-            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n-            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n-        },\n-        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n-            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n-            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n-            _ => bug!(),\n-        },\n-        LitKind::Bool(b) => Constant::Bool(b),\n-        LitKind::Err(s) => Constant::Err(s),\n-    }\n-}\n-\n-pub fn constant<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<(Constant, bool)> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    };\n-    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n-}\n-\n-pub fn constant_simple<'tcx>(\n-    lcx: &LateContext<'tcx>,\n-    typeck_results: &ty::TypeckResults<'tcx>,\n-    e: &Expr<'_>,\n-) -> Option<Constant> {\n-    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n-}\n-\n-/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n-pub fn constant_context<'a, 'tcx>(\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-) -> ConstEvalLateContext<'a, 'tcx> {\n-    ConstEvalLateContext {\n-        lcx,\n-        typeck_results,\n-        param_env: lcx.param_env,\n-        needed_resolution: false,\n-        substs: lcx.tcx.intern_substs(&[]),\n-    }\n-}\n-\n-pub struct ConstEvalLateContext<'a, 'tcx> {\n-    lcx: &'a LateContext<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    needed_resolution: bool,\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n-    /// Simple constant folding: Insert an expression, get a constant or none.\n-    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n-        match e.kind {\n-            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n-            ExprKind::Block(ref block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n-            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprKind::Repeat(ref value, _) => {\n-                let n = match self.typeck_results.expr_ty(e).kind() {\n-                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n-                    _ => span_bug!(e.span, \"typeck error\"),\n-                };\n-                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n-            },\n-            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n-            }),\n-            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n-            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n-            ExprKind::Call(ref callee, ref args) => {\n-                // We only handle a few const functions for now.\n-                if_chain! {\n-                    if args.is_empty();\n-                    if let ExprKind::Path(qpath) = &callee.kind;\n-                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n-                    if let Some(def_id) = res.opt_def_id();\n-                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n-                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n-                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n-                    then {\n-                       let value = match int_impl {\n-                           \"<impl i8>\" => i8::MAX as u128,\n-                           \"<impl i16>\" => i16::MAX as u128,\n-                           \"<impl i32>\" => i32::MAX as u128,\n-                           \"<impl i64>\" => i64::MAX as u128,\n-                           \"<impl i128>\" => i128::MAX as u128,\n-                           _ => return None,\n-                       };\n-                       Some(Constant::Int(value))\n-                    }\n-                    else {\n-                        None\n-                    }\n-                }\n-            },\n-            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n-            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n-            // TODO: add other expressions.\n-            _ => None,\n-        }\n-    }\n-\n-    #[allow(clippy::cast_possible_wrap)]\n-    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Bool, Int};\n-        match *o {\n-            Bool(b) => Some(Bool(!b)),\n-            Int(value) => {\n-                let value = !value;\n-                match *ty.kind() {\n-                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n-                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n-                    _ => None,\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n-        use self::Constant::{Int, F32, F64};\n-        match *o {\n-            Int(value) => {\n-                let ity = match *ty.kind() {\n-                    ty::Int(ity) => ity,\n-                    _ => return None,\n-                };\n-                // sign extend\n-                let value = sext(self.lcx.tcx, value, ity);\n-                let value = value.checked_neg()?;\n-                // clear unused bits\n-                Some(Int(unsext(self.lcx.tcx, value, ity)))\n-            },\n-            F32(f) => Some(F32(-f)),\n-            F64(f) => Some(F64(-f)),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Create `Some(Vec![..])` of all constants, unless there is any\n-    /// non-constant part.\n-    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n-        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n-    }\n-\n-    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n-    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n-        let res = self.typeck_results.qpath_res(qpath, id);\n-        match res {\n-            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n-                let substs = self.typeck_results.node_substs(id);\n-                let substs = if self.substs.is_empty() {\n-                    substs\n-                } else {\n-                    substs.subst(self.lcx.tcx, self.substs)\n-                };\n-\n-                let result = self\n-                    .lcx\n-                    .tcx\n-                    .const_eval_resolve(\n-                        self.param_env,\n-                        ty::WithOptConstParam::unknown(def_id),\n-                        substs,\n-                        None,\n-                        None,\n-                    )\n-                    .ok()\n-                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n-                let result = miri_to_const(&result);\n-                if result.is_some() {\n-                    self.needed_resolution = true;\n-                }\n-                result\n-            },\n-            // FIXME: cover all usable cases.\n-            _ => None,\n-        }\n-    }\n-\n-    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n-        let lhs = self.expr(lhs);\n-        let index = self.expr(index);\n-\n-        match (lhs, index) {\n-            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n-                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                _ => None,\n-            },\n-            (Some(Constant::Vec(vec)), _) => {\n-                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n-                    match vec.get(0) {\n-                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n-                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// A block can only yield a constant if it only has one constant expression.\n-    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n-        if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|b| self.expr(b))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n-        if let Some(Constant::Bool(b)) = self.expr(cond) {\n-            if b {\n-                self.expr(&*then)\n-            } else {\n-                otherwise.as_ref().and_then(|expr| self.expr(expr))\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n-        let l = self.expr(left)?;\n-        let r = self.expr(right);\n-        match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n-                ty::Int(ity) => {\n-                    let l = sext(self.lcx.tcx, l, ity);\n-                    let r = sext(self.lcx.tcx, r, ity);\n-                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n-                    match op.node {\n-                        BinOpKind::Add => l.checked_add(r).map(zext),\n-                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n-                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n-                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n-                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n-                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n-                        BinOpKind::BitXor => Some(zext(l ^ r)),\n-                        BinOpKind::BitOr => Some(zext(l | r)),\n-                        BinOpKind::BitAnd => Some(zext(l & r)),\n-                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                        _ => None,\n-                    }\n-                },\n-                ty::Uint(_) => match op.node {\n-                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n-                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n-                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n-                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n-                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n-                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n-                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n-                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n-                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n-                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F32(l + r)),\n-                BinOpKind::Sub => Some(Constant::F32(l - r)),\n-                BinOpKind::Mul => Some(Constant::F32(l * r)),\n-                BinOpKind::Div => Some(Constant::F32(l / r)),\n-                BinOpKind::Rem => Some(Constant::F32(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n-                BinOpKind::Add => Some(Constant::F64(l + r)),\n-                BinOpKind::Sub => Some(Constant::F64(l - r)),\n-                BinOpKind::Mul => Some(Constant::F64(l * r)),\n-                BinOpKind::Div => Some(Constant::F64(l / r)),\n-                BinOpKind::Rem => Some(Constant::F64(l % r)),\n-                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n-                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n-                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n-                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n-                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n-                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n-                _ => None,\n-            },\n-            (l, r) => match (op.node, l, r) {\n-                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n-                    Some(r)\n-                },\n-                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n-                _ => None,\n-            },\n-        }\n-    }\n-}\n-\n-pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::ConstValue;\n-    match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty.kind() {\n-                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n-                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                    int.try_into().expect(\"invalid f32 bit representation\"),\n-                ))),\n-                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                    int.try_into().expect(\"invalid f64 bit representation\"),\n-                ))),\n-                ty::RawPtr(type_and_mut) => {\n-                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n-                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n-                    }\n-                    None\n-                },\n-                // FIXME: implement other conversions.\n-                _ => None,\n-            }\n-        },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n-            ty::Ref(_, tam, _) => match tam.kind() {\n-                ty::Str => String::from_utf8(\n-                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n-                        .to_owned(),\n-                )\n-                .ok()\n-                .map(Constant::Str),\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n-            ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n-                        .to_owned()\n-                        .chunks(4)\n-                        .map(|chunk| {\n-                            Some(Constant::F32(f32::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n-                    Some(Constant::Int(len)) => alloc\n-                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n-                        .to_owned()\n-                        .chunks(8)\n-                        .map(|chunk| {\n-                            Some(Constant::F64(f64::from_le_bytes(\n-                                chunk.try_into().expect(\"this shouldn't happen\"),\n-                            )))\n-                        })\n-                        .collect::<Option<Vec<Constant>>>()\n-                        .map(Constant::Vec),\n-                    _ => None,\n-                },\n-                // FIXME: implement other array type conversions.\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        // FIXME: implement other conversions.\n-        _ => None,\n-    }\n-}\n+pub use clippy_utils::consts::*;"}, {"sha": "381e6f9369f368acf0744405311ede7c4aebd3a5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 15, "deletions": 95, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -50,103 +50,23 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_lint::LintId;\n use rustc_session::Session;\n \n-/// Macro used to declare a Clippy lint.\n-///\n-/// Every lint declaration consists of 4 parts:\n-///\n-/// 1. The documentation, which is used for the website\n-/// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n-/// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n-///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n-/// 4. The `description` that contains a short explanation on what's wrong with code where the\n-///    lint is triggered.\n-///\n-/// Currently the categories `style`, `correctness`, `complexity` and `perf` are enabled by default.\n-/// As said in the README.md of this repository, if the lint level mapping changes, please update\n-/// README.md.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(rustc_private)]\n-/// extern crate rustc_session;\n-/// use rustc_session::declare_tool_lint;\n-/// use clippy_lints::declare_clippy_lint;\n-///\n-/// declare_clippy_lint! {\n-///     /// **What it does:** Checks for ... (describe what the lint matches).\n-///     ///\n-///     /// **Why is this bad?** Supply the reason for linting the code.\n-///     ///\n-///     /// **Known problems:** None. (Or describe where it could go wrong.)\n-///     ///\n-///     /// **Example:**\n-///     ///\n-///     /// ```rust\n-///     /// // Bad\n-///     /// Insert a short example of code that triggers the lint\n-///     ///\n-///     /// // Good\n-///     /// Insert a short example of improved code that doesn't trigger the lint\n-///     /// ```\n-///     pub LINT_NAME,\n-///     pedantic,\n-///     \"description\"\n-/// }\n-/// ```\n-/// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n #[macro_export]\n macro_rules! declare_clippy_lint {\n-    { $(#[$attr:meta])* pub $name:tt, style, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, correctness, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, perf, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, pedantic, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, restriction, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, cargo, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, nursery, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, internal, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n-        }\n-    };\n-    { $(#[$attr:meta])* pub $name:tt, internal_warn, $description:tt } => {\n-        declare_tool_lint! {\n-            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n-        }\n-    };\n+    ( $($x:tt)* ) => { clippy_utils::declare_clippy_lint!($($x)*); }\n+}\n+\n+#[macro_export]\n+macro_rules! sym {\n+    ( $($x:tt)* ) => { clippy_utils::sym!($($x)*); }\n+}\n+\n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ( $($x:tt)* ) => { clippy_utils::unwrap_cargo_metadata!($($x)*); }\n+}\n+\n+macro_rules! extract_msrv_attr {\n+    ( $($x:tt)* ) => { clippy_utils::extract_msrv_attr!($($x)*); }\n }\n \n mod consts;"}, {"sha": "bf54e39769cb0724e86e9549c081ee9f0165ddb0", "filename": "clippy_lints/src/utils.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_lints%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -0,0 +1 @@\n+pub use clippy_utils::*;"}, {"sha": "1b05b543186960d4b83a8f618a0975874d0b39e0", "filename": "clippy_utils/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+name = \"clippy_utils\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n+\n+[dependencies]\n+cargo_metadata = \"0.12\"\n+if_chain = \"1.0.0\"\n+itertools = \"0.9\"\n+pulldown-cmark = { version = \"0.8\", default-features = false }\n+quine-mc_cluskey = \"0.2.2\"\n+regex-syntax = \"0.6\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+smallvec = { version = \"1\", features = [\"union\"] }\n+toml = \"0.5.3\"\n+unicode-normalization = \"0.1\"\n+semver = \"0.11\"\n+rustc-semver=\"1.1.0\"\n+# NOTE: cargo requires serde feat in its url dep\n+# see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n+url = { version =  \"2.1.0\", features = [\"serde\"] }\n+quote = \"1\"\n+syn = { version = \"1\", features = [\"full\"] }"}, {"sha": "7ec0e103c0002e2e9d85aad8c1a396ed5dee376e", "filename": "clippy_utils/src/ast_utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -4,7 +4,7 @@\n \n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use crate::utils::{both, over};\n+use crate::{both, over};\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;", "previous_filename": "clippy_lints/src/utils/ast_utils.rs"}, {"sha": "eefcbabd835d2b669cf65be463c4130b366b66e7", "filename": "clippy_utils/src/ast_utils/ident_iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils%2Fident_iter.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/ast_utils/ident_iter.rs"}, {"sha": "8d28421d70d707fdec87dcbf03a059f5d63ada2c", "filename": "clippy_utils/src/attrs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/attrs.rs"}, {"sha": "ba83566b5e65a44410f9fc6274f9aab253182ef8", "filename": "clippy_utils/src/author.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fauthor.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,7 +1,7 @@\n //! A group of attributes that can be attached to Rust code in order\n //! to generate a clippy lint detecting said code automatically.\n \n-use crate::utils::get_attr;\n+use crate::{declare_clippy_lint, get_attr};\n use rustc_ast::ast::{Attribute, LitFloatType, LitKind};\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashMap;", "previous_filename": "clippy_lints/src/utils/author.rs"}, {"sha": "ba1c01ebc9f76d2523340b2bd7c56cd482142293", "filename": "clippy_utils/src/camel_case.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcamel_case.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/camel_case.rs"}, {"sha": "7a18d5e818fb1c607298209b6b344ef6a484021d", "filename": "clippy_utils/src/comparisons.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcomparisons.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/comparisons.rs"}, {"sha": "7d7b35c21680d907bf4b772570b2126e7778679d", "filename": "clippy_utils/src/conf.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconf.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/conf.rs"}, {"sha": "522932f054d894eef06d81b7a53203fc255f9d89", "filename": "clippy_utils/src/constants.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconstants.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -0,0 +1,13 @@\n+//! This module contains some useful constants.\n+\n+#![deny(clippy::missing_docs_in_private_items)]\n+\n+/// List of the built-in types names.\n+///\n+/// See also [the reference][reference-types] for a list of such types.\n+///\n+/// [reference-types]: https://doc.rust-lang.org/reference/types.html\n+pub const BUILTIN_TYPES: &[&str] = &[\n+    \"i8\", \"u8\", \"i16\", \"u16\", \"i32\", \"u32\", \"i64\", \"u64\", \"i128\", \"u128\", \"isize\", \"usize\", \"f32\", \"f64\", \"bool\",\n+    \"str\", \"char\",\n+];"}, {"sha": "802c01055a68c84d68dd4307c841c6b67bcfa334", "filename": "clippy_utils/src/consts.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -0,0 +1,574 @@\n+#![allow(clippy::float_cmp)]\n+\n+use crate::{clip, sext, unsext};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, LitFloatType, LitKind};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n+use rustc_span::symbol::Symbol;\n+use std::cmp::Ordering::{self, Equal};\n+use std::convert::TryInto;\n+use std::hash::{Hash, Hasher};\n+\n+/// A `LitKind`-like enum to fold constant `Expr`s into.\n+#[derive(Debug, Clone)]\n+pub enum Constant {\n+    /// A `String` (e.g., \"abc\").\n+    Str(String),\n+    /// A binary string (e.g., `b\"abc\"`).\n+    Binary(Lrc<[u8]>),\n+    /// A single `char` (e.g., `'a'`).\n+    Char(char),\n+    /// An integer's bit representation.\n+    Int(u128),\n+    /// An `f32`.\n+    F32(f32),\n+    /// An `f64`.\n+    F64(f64),\n+    /// `true` or `false`.\n+    Bool(bool),\n+    /// An array of constants.\n+    Vec(Vec<Constant>),\n+    /// Also an array, but with only one constant, repeated N times.\n+    Repeat(Box<Constant>, u64),\n+    /// A tuple of constants.\n+    Tuple(Vec<Constant>),\n+    /// A raw pointer.\n+    RawPtr(u128),\n+    /// A reference\n+    Ref(Box<Constant>),\n+    /// A literal with syntax error.\n+    Err(Symbol),\n+}\n+\n+impl PartialEq for Constant {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => ls == rs,\n+            (&Self::Binary(ref l), &Self::Binary(ref r)) => l == r,\n+            (&Self::Char(l), &Self::Char(r)) => l == r,\n+            (&Self::Int(l), &Self::Int(r)) => l == r,\n+            (&Self::F64(l), &Self::F64(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                l.to_bits() == r.to_bits()\n+            },\n+            (&Self::F32(l), &Self::F32(r)) => {\n+                // We want `Fw32 == FwAny` and `FwAny == Fw64`, and by transitivity we must have\n+                // `Fw32 == Fw64`, so don\u2019t compare them.\n+                // `to_bits` is required to catch non-matching 0.0, -0.0, and NaNs.\n+                f64::from(l).to_bits() == f64::from(r).to_bits()\n+            },\n+            (&Self::Bool(l), &Self::Bool(r)) => l == r,\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n+            // TODO: are there inter-type equalities?\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        std::mem::discriminant(self).hash(state);\n+        match *self {\n+            Self::Str(ref s) => {\n+                s.hash(state);\n+            },\n+            Self::Binary(ref b) => {\n+                b.hash(state);\n+            },\n+            Self::Char(c) => {\n+                c.hash(state);\n+            },\n+            Self::Int(i) => {\n+                i.hash(state);\n+            },\n+            Self::F32(f) => {\n+                f64::from(f).to_bits().hash(state);\n+            },\n+            Self::F64(f) => {\n+                f.to_bits().hash(state);\n+            },\n+            Self::Bool(b) => {\n+                b.hash(state);\n+            },\n+            Self::Vec(ref v) | Self::Tuple(ref v) => {\n+                v.hash(state);\n+            },\n+            Self::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            },\n+            Self::RawPtr(u) => {\n+                u.hash(state);\n+            },\n+            Self::Ref(ref r) => {\n+                r.hash(state);\n+            },\n+            Self::Err(ref s) => {\n+                s.hash(state);\n+            },\n+        }\n+    }\n+}\n+\n+impl Constant {\n+    pub fn partial_cmp(tcx: TyCtxt<'_>, cmp_type: Ty<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n+        match (left, right) {\n+            (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n+            (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n+            (&Self::Int(l), &Self::Int(r)) => {\n+                if let ty::Int(int_ty) = *cmp_type.kind() {\n+                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n+                } else {\n+                    Some(l.cmp(&r))\n+                }\n+            },\n+            (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n+            (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n+            (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => l\n+                .iter()\n+                .zip(r.iter())\n+                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n+                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                }\n+            },\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n+            // TODO: are there any useful inter-type orderings?\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// Parses a `LitKind` to a `Constant`.\n+pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n+    match *lit {\n+        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n+        LitKind::Byte(b) => Constant::Int(u128::from(b)),\n+        LitKind::ByteStr(ref s) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::Char(c) => Constant::Char(c),\n+        LitKind::Int(n, _) => Constant::Int(n),\n+        LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n+            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n+            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n+        },\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n+            ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n+            _ => bug!(),\n+        },\n+        LitKind::Bool(b) => Constant::Bool(b),\n+        LitKind::Err(s) => Constant::Err(s),\n+    }\n+}\n+\n+pub fn constant<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<(Constant, bool)> {\n+    let mut cx = ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    };\n+    cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n+}\n+\n+pub fn constant_simple<'tcx>(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<Constant> {\n+    constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+}\n+\n+/// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n+pub fn constant_context<'a, 'tcx>(\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+) -> ConstEvalLateContext<'a, 'tcx> {\n+    ConstEvalLateContext {\n+        lcx,\n+        typeck_results,\n+        param_env: lcx.param_env,\n+        needed_resolution: false,\n+        substs: lcx.tcx.intern_substs(&[]),\n+    }\n+}\n+\n+pub struct ConstEvalLateContext<'a, 'tcx> {\n+    lcx: &'a LateContext<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    needed_resolution: bool,\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n+    /// Simple constant folding: Insert an expression, get a constant or none.\n+    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n+        match e.kind {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n+                let n = match self.typeck_results.expr_ty(e).kind() {\n+                    ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n+            },\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+                UnOp::Not => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Neg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n+                UnOp::Deref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n+            }),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, *otherwise),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Call(ref callee, ref args) => {\n+                // We only handle a few const functions for now.\n+                if_chain! {\n+                    if args.is_empty();\n+                    if let ExprKind::Path(qpath) = &callee.kind;\n+                    let res = self.typeck_results.qpath_res(qpath, callee.hir_id);\n+                    if let Some(def_id) = res.opt_def_id();\n+                    let def_path: Vec<_> = self.lcx.get_def_path(def_id).into_iter().map(Symbol::as_str).collect();\n+                    let def_path: Vec<&str> = def_path.iter().take(4).map(|s| &**s).collect();\n+                    if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n+                    then {\n+                       let value = match int_impl {\n+                           \"<impl i8>\" => i8::MAX as u128,\n+                           \"<impl i16>\" => i16::MAX as u128,\n+                           \"<impl i32>\" => i32::MAX as u128,\n+                           \"<impl i64>\" => i64::MAX as u128,\n+                           \"<impl i128>\" => i128::MAX as u128,\n+                           _ => return None,\n+                       };\n+                       Some(Constant::Int(value))\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }\n+            },\n+            ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n+            // TODO: add other expressions.\n+            _ => None,\n+        }\n+    }\n+\n+    #[allow(clippy::cast_possible_wrap)]\n+    fn constant_not(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Bool, Int};\n+        match *o {\n+            Bool(b) => Some(Bool(!b)),\n+            Int(value) => {\n+                let value = !value;\n+                match *ty.kind() {\n+                    ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n+                    ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn constant_negate(&self, o: &Constant, ty: Ty<'_>) -> Option<Constant> {\n+        use self::Constant::{Int, F32, F64};\n+        match *o {\n+            Int(value) => {\n+                let ity = match *ty.kind() {\n+                    ty::Int(ity) => ity,\n+                    _ => return None,\n+                };\n+                // sign extend\n+                let value = sext(self.lcx.tcx, value, ity);\n+                let value = value.checked_neg()?;\n+                // clear unused bits\n+                Some(Int(unsext(self.lcx.tcx, value, ity)))\n+            },\n+            F32(f) => Some(F32(-f)),\n+            F64(f) => Some(F64(-f)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Create `Some(Vec![..])` of all constants, unless there is any\n+    /// non-constant part.\n+    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n+        vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n+    }\n+\n+    /// Lookup a possibly constant expression from a `ExprKind::Path`.\n+    fn fetch_path(&mut self, qpath: &QPath<'_>, id: HirId, ty: Ty<'tcx>) -> Option<Constant> {\n+        let res = self.typeck_results.qpath_res(qpath, id);\n+        match res {\n+            Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n+                let substs = self.typeck_results.node_substs(id);\n+                let substs = if self.substs.is_empty() {\n+                    substs\n+                } else {\n+                    substs.subst(self.lcx.tcx, self.substs)\n+                };\n+\n+                let result = self\n+                    .lcx\n+                    .tcx\n+                    .const_eval_resolve(\n+                        self.param_env,\n+                        ty::WithOptConstParam::unknown(def_id),\n+                        substs,\n+                        None,\n+                        None,\n+                    )\n+                    .ok()\n+                    .map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty))?;\n+                let result = miri_to_const(&result);\n+                if result.is_some() {\n+                    self.needed_resolution = true;\n+                }\n+                result\n+            },\n+            // FIXME: cover all usable cases.\n+            _ => None,\n+        }\n+    }\n+\n+    fn index(&mut self, lhs: &'_ Expr<'_>, index: &'_ Expr<'_>) -> Option<Constant> {\n+        let lhs = self.expr(lhs);\n+        let index = self.expr(index);\n+\n+        match (lhs, index) {\n+            (Some(Constant::Vec(vec)), Some(Constant::Int(index))) => match vec.get(index as usize) {\n+                Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                _ => None,\n+            },\n+            (Some(Constant::Vec(vec)), _) => {\n+                if !vec.is_empty() && vec.iter().all(|x| *x == vec[0]) {\n+                    match vec.get(0) {\n+                        Some(Constant::F32(x)) => Some(Constant::F32(*x)),\n+                        Some(Constant::F64(x)) => Some(Constant::F64(*x)),\n+                        _ => None,\n+                    }\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// A block can only yield a constant if it only has one constant expression.\n+    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n+        if block.stmts.is_empty() {\n+            block.expr.as_ref().and_then(|b| self.expr(b))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n+        if let Some(Constant::Bool(b)) = self.expr(cond) {\n+            if b {\n+                self.expr(&*then)\n+            } else {\n+                otherwise.as_ref().and_then(|expr| self.expr(expr))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n+        let l = self.expr(left)?;\n+        let r = self.expr(right);\n+        match (l, r) {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n+                ty::Int(ity) => {\n+                    let l = sext(self.lcx.tcx, l, ity);\n+                    let r = sext(self.lcx.tcx, r, ity);\n+                    let zext = |n: i128| Constant::Int(unsext(self.lcx.tcx, n, ity));\n+                    match op.node {\n+                        BinOpKind::Add => l.checked_add(r).map(zext),\n+                        BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                        BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                        BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                        BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                        BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"invalid shift\")).map(zext),\n+                        BinOpKind::BitXor => Some(zext(l ^ r)),\n+                        BinOpKind::BitOr => Some(zext(l | r)),\n+                        BinOpKind::BitAnd => Some(zext(l & r)),\n+                        BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                        BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                        BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                        BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                        BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                        BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                        _ => None,\n+                    }\n+                },\n+                ty::Uint(_) => match op.node {\n+                    BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                    BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                    BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                    BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                    BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                    BinOpKind::Shr => l.checked_shr(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::Shl => l.checked_shl(r.try_into().expect(\"shift too large\")).map(Constant::Int),\n+                    BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                    BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                    BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                    BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                    BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                    BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                    BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                    BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                    BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (l, r) => match (op.node, l, r) {\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => {\n+                    Some(r)\n+                },\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                _ => None,\n+            },\n+        }\n+    }\n+}\n+\n+pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+    use rustc_middle::mir::interpret::ConstValue;\n+    match result.val {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n+            match result.ty.kind() {\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n+                    int.try_into().expect(\"invalid f32 bit representation\"),\n+                ))),\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n+                    int.try_into().expect(\"invalid f64 bit representation\"),\n+                ))),\n+                ty::RawPtr(type_and_mut) => {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n+                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n+                    }\n+                    None\n+                },\n+                // FIXME: implement other conversions.\n+                _ => None,\n+            }\n+        },\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n+                ty::Str => String::from_utf8(\n+                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                        .to_owned(),\n+                )\n+                .ok()\n+                .map(Constant::Str),\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n+                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .to_owned()\n+                        .chunks(4)\n+                        .map(|chunk| {\n+                            Some(Constant::F32(f32::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .to_owned()\n+                        .chunks(8)\n+                        .map(|chunk| {\n+                            Some(Constant::F64(f64::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                // FIXME: implement other array type conversions.\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        // FIXME: implement other conversions.\n+        _ => None,\n+    }\n+}"}, {"sha": "269be217c2d875bf3db450a39940705666154459", "filename": "clippy_utils/src/diagnostics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/diagnostics.rs"}, {"sha": "52a33e9b1704c300d8e1ffcf0bcdffcfd9071930", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::utils::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n+use crate::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;", "previous_filename": "clippy_lints/src/utils/eager_or_lazy.rs"}, {"sha": "be22df7109af792da83e68d6263cc14668572579", "filename": "clippy_utils/src/higher.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{is_expn_of, match_def_path, paths};\n+use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;", "previous_filename": "clippy_lints/src/utils/higher.rs"}, {"sha": "81be9254cbe1a3db8aa180acc936c2e7c2055af9", "filename": "clippy_utils/src/hir_utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::utils::differing_macro_contexts;\n+use crate::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};", "previous_filename": "clippy_lints/src/utils/hir_utils.rs"}, {"sha": "b082bb6cfda7eb17d0c8c4c7ee0700c25e0dfe98", "filename": "clippy_utils/src/inspector.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Finspector.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,6 +1,6 @@\n //! checks for attributes\n \n-use crate::utils::get_attr;\n+use crate::{declare_clippy_lint, get_attr};\n use rustc_ast::ast::{Attribute, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};", "previous_filename": "clippy_lints/src/utils/inspector.rs"}, {"sha": "164ecb23b14d271b16edb5bbef398b07ced5a9b6", "filename": "clippy_utils/src/internal_lints.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Finternal_lints.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{\n+use crate::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, run_lints, snippet,\n     span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };", "previous_filename": "clippy_lints/src/utils/internal_lints.rs"}, {"sha": "213945a63a3da40bb03b4cd6c88c2ca9c505bacc", "filename": "clippy_utils/src/lib.rs", "status": "renamed", "additions": 138, "deletions": 2, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,3 +1,38 @@\n+#![feature(bindings_after_at)]\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(concat_idents)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n+#![feature(once_cell)]\n+#![feature(or_patterns)]\n+#![feature(rustc_private)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(control_flow_enum)]\n+\n+extern crate rustc_ast;\n+extern crate rustc_ast_pretty;\n+extern crate rustc_attr;\n+extern crate rustc_data_structures;\n+extern crate rustc_driver;\n+extern crate rustc_errors;\n+extern crate rustc_hir;\n+extern crate rustc_hir_pretty;\n+extern crate rustc_index;\n+extern crate rustc_infer;\n+extern crate rustc_lexer;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_mir;\n+extern crate rustc_parse;\n+extern crate rustc_parse_format;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_target;\n+extern crate rustc_trait_selection;\n+extern crate rustc_typeck;\n+\n #[macro_use]\n pub mod sym_helper;\n \n@@ -8,6 +43,7 @@ pub mod author;\n pub mod camel_case;\n pub mod comparisons;\n pub mod conf;\n+pub mod consts;\n mod diagnostics;\n pub mod eager_or_lazy;\n pub mod higher;\n@@ -63,6 +99,105 @@ use smallvec::SmallVec;\n \n use crate::consts::{constant, Constant};\n \n+/// Macro used to declare a Clippy lint.\n+///\n+/// Every lint declaration consists of 4 parts:\n+///\n+/// 1. The documentation, which is used for the website\n+/// 2. The `LINT_NAME`. See [lint naming][lint_naming] on lint naming conventions.\n+/// 3. The `lint_level`, which is a mapping from *one* of our lint groups to `Allow`, `Warn` or\n+///    `Deny`. The lint level here has nothing to do with what lint groups the lint is a part of.\n+/// 4. The `description` that contains a short explanation on what's wrong with code where the\n+///    lint is triggered.\n+///\n+/// Currently the categories `style`, `correctness`, `complexity` and `perf` are enabled by default.\n+/// As said in the README.md of this repository, if the lint level mapping changes, please update\n+/// README.md.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(rustc_private)]\n+/// extern crate rustc_session;\n+/// use rustc_session::declare_tool_lint;\n+/// use clippy_lints::declare_clippy_lint;\n+///\n+/// declare_clippy_lint! {\n+///     /// **What it does:** Checks for ... (describe what the lint matches).\n+///     ///\n+///     /// **Why is this bad?** Supply the reason for linting the code.\n+///     ///\n+///     /// **Known problems:** None. (Or describe where it could go wrong.)\n+///     ///\n+///     /// **Example:**\n+///     ///\n+///     /// ```rust\n+///     /// // Bad\n+///     /// Insert a short example of code that triggers the lint\n+///     ///\n+///     /// // Good\n+///     /// Insert a short example of improved code that doesn't trigger the lint\n+///     /// ```\n+///     pub LINT_NAME,\n+///     pedantic,\n+///     \"description\"\n+/// }\n+/// ```\n+/// [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+#[macro_export]\n+macro_rules! declare_clippy_lint {\n+    { $(#[$attr:meta])* pub $name:tt, style, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, correctness, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Deny, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, complexity, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, perf, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, pedantic, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, restriction, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, cargo, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, nursery, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, internal, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Allow, $description, report_in_external_macro: true\n+        }\n+    };\n+    { $(#[$attr:meta])* pub $name:tt, internal_warn, $description:tt } => {\n+        declare_tool_lint! {\n+            $(#[$attr])* pub clippy::$name, Warn, $description, report_in_external_macro: true\n+        }\n+    };\n+}\n+\n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n         return Some(version);\n@@ -78,6 +213,7 @@ pub fn meets_msrv(msrv: Option<&RustcVersion>, lint_msrv: &RustcVersion) -> bool\n     msrv.map_or(true, |msrv| msrv.meets(*lint_msrv))\n }\n \n+#[macro_export]\n macro_rules! extract_msrv_attr {\n     (LateContext) => {\n         extract_msrv_attr!(@LateContext, ());\n@@ -87,11 +223,11 @@ macro_rules! extract_msrv_attr {\n     };\n     (@$context:ident$(, $call:tt)?) => {\n         fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n-            use $crate::utils::get_unique_inner_attr;\n+            use $crate::get_unique_inner_attr;\n             match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n                 Some(msrv_attr) => {\n                     if let Some(msrv) = msrv_attr.value_str() {\n-                        self.msrv = $crate::utils::parse_msrv(\n+                        self.msrv = $crate::parse_msrv(\n                             &msrv.to_string(),\n                             Some(cx.sess$($call)?),\n                             Some(msrv_attr.span),", "previous_filename": "clippy_lints/src/utils/mod.rs"}, {"sha": "d02603d7702c7f3c6a8f7f48d30b29a027ff7e00", "filename": "clippy_utils/src/numeric_literal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/numeric_literal.rs"}, {"sha": "432cc5b59f684ddac760861f8ab4906746de5fb3", "filename": "clippy_utils/src/paths.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/paths.rs"}, {"sha": "baeff08e02cd8f6738678b71e2cdf1d039f772ef", "filename": "clippy_utils/src/ptr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_pat_name, match_var, snippet};\n+use crate::{get_pat_name, match_var, snippet};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n use rustc_lint::LateContext;", "previous_filename": "clippy_lints/src/utils/ptr.rs"}, {"sha": "a482017afeb136339277386cd0f78be46d91c3cf", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/qualify_min_const_fn.rs"}, {"sha": "d4f6f4281d368ef32bef21978057a9b5a21cdb87", "filename": "clippy_utils/src/sugg.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,7 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::{higher, snippet, snippet_opt, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;", "previous_filename": "clippy_lints/src/utils/sugg.rs"}, {"sha": "f47dc80ebade8222716a721293eb00b50e80aa52", "filename": "clippy_utils/src/sym_helper.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fsym_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fsym_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsym_helper.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/sym_helper.rs"}, {"sha": "d577827dcf3ccc0aea320ef53630127b01e44010", "filename": "clippy_utils/src/usage.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils;\n+use crate as utils;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;", "previous_filename": "clippy_lints/src/utils/usage.rs"}, {"sha": "085c1f9c0cb8d3ea661a1640cbd946933467fe93", "filename": "clippy_utils/src/visitors.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09bded443745a05daaeeca76e4b032381ca1a126/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=09bded443745a05daaeeca76e4b032381ca1a126", "previous_filename": "clippy_lints/src/utils/visitors.rs"}]}