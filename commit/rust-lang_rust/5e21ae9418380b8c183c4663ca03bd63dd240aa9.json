{"sha": "5e21ae9418380b8c183c4663ca03bd63dd240aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjFhZTk0MTgzODBiOGMxODNjNDY2M2NhMDNiZDYzZGQyNDBhYTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-10T19:45:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-10T19:45:01Z"}, "message": "Some architecture notes", "tree": {"sha": "849404e44a4ddb246dbe0a29c5e330b501f71dac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/849404e44a4ddb246dbe0a29c5e330b501f71dac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e21ae9418380b8c183c4663ca03bd63dd240aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e21ae9418380b8c183c4663ca03bd63dd240aa9", "html_url": "https://github.com/rust-lang/rust/commit/5e21ae9418380b8c183c4663ca03bd63dd240aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e21ae9418380b8c183c4663ca03bd63dd240aa9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c10c31be339ef3082f142061d83149af2a30ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c10c31be339ef3082f142061d83149af2a30ec8", "html_url": "https://github.com/rust-lang/rust/commit/4c10c31be339ef3082f142061d83149af2a30ec8"}], "stats": {"total": 97, "additions": 96, "deletions": 1}, "files": [{"sha": "a1fa246c253a70b7f7cddd2d7a62762ca394aa94", "filename": "docs/ARCHITECTURE.md", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5e21ae9418380b8c183c4663ca03bd63dd240aa9/docs%2FARCHITECTURE.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e21ae9418380b8c183c4663ca03bd63dd240aa9/docs%2FARCHITECTURE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2FARCHITECTURE.md?ref=5e21ae9418380b8c183c4663ca03bd63dd240aa9", "patch": "@@ -1 +1,96 @@\n-# Design and open questions about libsyntax.\n+# Design and open questions about libsyntax\n+\n+\n+The high-level description of the architecture is in RFC.md. You might\n+also want to dig through https://github.com/matklad/fall/ which\n+contains some pretty interesting stuff build using similar ideas\n+(warning: it is completely undocumented, poorly written and in general\n+not the thing which I recommend to study (yes, this is\n+self-contradictory)).\n+\n+## Tree\n+\n+The centerpiece of this whole endeavor is the syntax tree, in the\n+`tree` module. Open questions:\n+\n+- how to best represent errors, to take advantage of the fact that\n+  they are rare, but to enable fully-persistent style structure\n+  sharing between tree nodes?\n+  \n+- should we make red/green split from Roslyn more pronounced?\n+\n+- one can layout nodes in a single array in such a way that children\n+  of the node form a continuous slice. Seems nifty, but do we need it?\n+  \n+- should we use SoA or AoS for NodeData?\n+\n+- should we split leaf nodes and internal nodes into separate arrays?\n+  Can we use it to save some bits here and there? (leaves don't need\n+  first_child field, for example).\n+\n+\n+## Parser\n+\n+The syntax tree is produced using a three-staged process. \n+\n+First, a raw text is split into tokens with a lexer. Lexer has a\n+peculiar signature: it is an `Fn(&str) -> Token`, where token is a\n+pair of `SyntaxKind` (you should have read the `tree` module and RFC\n+by this time! :)) and a len. That is, lexer chomps only the first\n+token of the input. This forces the lexer to be stateless, and makes\n+it possible to implement incremental relexing easily.\n+\n+Then, the bulk of work, the parser turns a stream of tokens into\n+stream of events. Not that parser **does not** construct a tree right\n+away. This is done for several reasons:\n+\n+* to decouple the actual tree data structure from the parser: you can\n+  build any datastructre you want from the stream of events\n+  \n+* to make parsing fast: you can produce a list of events without\n+  allocations\n+  \n+* to make it easy to tweak tree structure. Consider this code:\n+\n+  ```\n+  #[cfg(test)]\n+  pub fn foo() {}\n+  ```\n+  \n+  Here, the attribute and the `pub` keyword must be the children of\n+  the `fn` node. However, when parsing them, we don't yet know if\n+  there would be a function ahead: it very well might be a `struct`\n+  there. If we use events, we generally don't care about this *in\n+  parser* and just spit them in order.\n+  \n+* (Is this true?)  to make incremental reparsing easier: you can reuse\n+  the same rope data structure for all of the original string, the\n+  tokens and the events.\n+  \n+\n+The parser also does not know about whitespace tokens: it's the job of\n+the next layer to assign whitespace and comments to nodes. However,\n+parser can remap contextual tokens, like `>>` or `union`, so it has\n+access to the text.\n+\n+And at last, the TreeBuilder converts a flat stream of events into a\n+tree structure. It also *should* be responsible for attaching comments\n+and rebalancing the tree, but it does not do this yet :) \n+\n+\n+## Error reporing\n+\n+TODO: describe how stuff like `skip_to_first` works\n+\n+\n+## Validator\n+\n+Parser and lexer accept a lot of *invalid* code intentionally. The\n+idea is to post-process the tree and to proper error reporting,\n+literal conversion and quick-fix suggestions. There is no\n+design/implementation for this yet.\n+\n+\n+## AST\n+\n+Nothing yet, see `AstNode` in `fall`."}]}