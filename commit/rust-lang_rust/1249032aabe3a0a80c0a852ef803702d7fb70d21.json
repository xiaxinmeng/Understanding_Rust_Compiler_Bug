{"sha": "1249032aabe3a0a80c0a852ef803702d7fb70d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNDkwMzJhYWJlM2EwYTgwYzBhODUyZWY4MDM3MDJkN2ZiNzBkMjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-07T16:10:31Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-16T08:12:31Z"}, "message": "Move impl of Queries with its definition.", "tree": {"sha": "9b63c50ceb2aca50c0f384e99e9d359bc8131a62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b63c50ceb2aca50c0f384e99e9d359bc8131a62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1249032aabe3a0a80c0a852ef803702d7fb70d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1249032aabe3a0a80c0a852ef803702d7fb70d21", "html_url": "https://github.com/rust-lang/rust/commit/1249032aabe3a0a80c0a852ef803702d7fb70d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1249032aabe3a0a80c0a852ef803702d7fb70d21/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf238fd057651371731fde47a2ebf251bf37cfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf238fd057651371731fde47a2ebf251bf37cfb5", "html_url": "https://github.com/rust-lang/rust/commit/cf238fd057651371731fde47a2ebf251bf37cfb5"}], "stats": {"total": 98, "additions": 49, "deletions": 49}, "files": [{"sha": "5532d7e08cc927823d67fcb2c735d3591e327d09", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1249032aabe3a0a80c0a852ef803702d7fb70d21/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1249032aabe3a0a80c0a852ef803702d7fb70d21/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=1249032aabe3a0a80c0a852ef803702d7fb70d21", "patch": "@@ -842,55 +842,6 @@ macro_rules! define_queries_inner {\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n-        impl<$tcx> Queries<$tcx> {\n-            pub fn new(\n-                providers: IndexVec<CrateNum, Providers<$tcx>>,\n-                fallback_extern_providers: Providers<$tcx>,\n-                on_disk_cache: OnDiskCache<'tcx>,\n-            ) -> Self {\n-                Queries {\n-                    providers,\n-                    fallback_extern_providers: Box::new(fallback_extern_providers),\n-                    on_disk_cache,\n-                    $($name: Default::default()),*\n-                }\n-            }\n-\n-            pub fn try_collect_active_jobs(\n-                &self\n-            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n-                let mut jobs = FxHashMap::default();\n-\n-                $(\n-                    // We use try_lock_shards here since we are called from the\n-                    // deadlock handler, and this shouldn't be locked.\n-                    let shards = self.$name.shards.try_lock_shards()?;\n-                    let shards = shards.iter().enumerate();\n-                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n-                        shard.active.iter().filter_map(move |(k, v)| {\n-                        if let QueryResult::Started(ref job) = *v {\n-                                let id = QueryJobId {\n-                                    job: job.id,\n-                                    shard:  u16::try_from(shard_id).unwrap(),\n-                                    kind:\n-                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n-                                };\n-                                let info = QueryInfo {\n-                                    span: job.span,\n-                                    query: Query::$name(k.clone())\n-                                };\n-                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n-                        } else {\n-                            None\n-                        }\n-                        })\n-                    }));\n-                )*\n-\n-                Some(jobs)\n-            }\n-        }\n-\n         #[allow(nonstandard_style)]\n         #[derive(Clone, Debug)]\n         pub enum Query<$tcx> {\n@@ -1120,6 +1071,55 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*  $name: QueryState<$tcx, queries::$name<$tcx>>,)*\n         }\n+\n+        impl<$tcx> Queries<$tcx> {\n+            pub fn new(\n+                providers: IndexVec<CrateNum, Providers<$tcx>>,\n+                fallback_extern_providers: Providers<$tcx>,\n+                on_disk_cache: OnDiskCache<'tcx>,\n+            ) -> Self {\n+                Queries {\n+                    providers,\n+                    fallback_extern_providers: Box::new(fallback_extern_providers),\n+                    on_disk_cache,\n+                    $($name: Default::default()),*\n+                }\n+            }\n+\n+            pub fn try_collect_active_jobs(\n+                &self\n+            ) -> Option<FxHashMap<QueryJobId, QueryJobInfo<'tcx>>> {\n+                let mut jobs = FxHashMap::default();\n+\n+                $(\n+                    // We use try_lock_shards here since we are called from the\n+                    // deadlock handler, and this shouldn't be locked.\n+                    let shards = self.$name.shards.try_lock_shards()?;\n+                    let shards = shards.iter().enumerate();\n+                    jobs.extend(shards.flat_map(|(shard_id, shard)| {\n+                        shard.active.iter().filter_map(move |(k, v)| {\n+                        if let QueryResult::Started(ref job) = *v {\n+                                let id = QueryJobId {\n+                                    job: job.id,\n+                                    shard:  u16::try_from(shard_id).unwrap(),\n+                                    kind:\n+                                        <queries::$name<'tcx> as QueryAccessors<'tcx>>::DEP_KIND,\n+                                };\n+                                let info = QueryInfo {\n+                                    span: job.span,\n+                                    query: Query::$name(k.clone())\n+                                };\n+                                Some((id, QueryJobInfo { info,  job: job.clone() }))\n+                        } else {\n+                            None\n+                        }\n+                        })\n+                    }));\n+                )*\n+\n+                Some(jobs)\n+            }\n+        }\n     };\n }\n "}]}