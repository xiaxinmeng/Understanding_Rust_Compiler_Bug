{"sha": "21df87f515b10ab4d6dac2275d09e679471c7d7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZGY4N2Y1MTViMTBhYjRkNmRhYzIyNzVkMDllNjc5NDcxYzdkN2M=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-02-26T21:21:44Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-11T18:59:39Z"}, "message": "Forbid items with the same name being defined in overlapping inherent\nimpl blocks.\n\nFor example, the following is now correctly illegal:\n\n```rust\nstruct Foo;\n\nimpl Foo {\n    fn id() {}\n}\n\nimpl Foo {\n    fn id() {}\n}\n```\n\n\"Overlapping\" here is determined the same way it is for traits (and in\nfact shares the same code path): roughly, there must be some way of\nsubstituting any generic types to unify the impls, such that none of the\n`where` clauses are provably unsatisfiable under such a unification.\n\nCloses #22889", "tree": {"sha": "b41c60f6e2748a72196980a9df8ea9a4f30757ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b41c60f6e2748a72196980a9df8ea9a4f30757ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21df87f515b10ab4d6dac2275d09e679471c7d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21df87f515b10ab4d6dac2275d09e679471c7d7c", "html_url": "https://github.com/rust-lang/rust/commit/21df87f515b10ab4d6dac2275d09e679471c7d7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21df87f515b10ab4d6dac2275d09e679471c7d7c/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc3bfccebf60a214902f53074eea1b9a83d44f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3bfccebf60a214902f53074eea1b9a83d44f6", "html_url": "https://github.com/rust-lang/rust/commit/9cc3bfccebf60a214902f53074eea1b9a83d44f6"}], "stats": {"total": 158, "additions": 113, "deletions": 45}, "files": [{"sha": "f4df6994e047b501c049923adf84b208fec34783", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -58,6 +58,7 @@ pub enum DepNode {\n     CoherenceCheckImpl(DefId),\n     CoherenceOverlapCheck(DefId),\n     CoherenceOverlapCheckSpecial(DefId),\n+    CoherenceOverlapInherentCheck(DefId),\n     CoherenceOrphanCheck(DefId),\n     Variance,\n     WfCheck(DefId),"}, {"sha": "3eca4624bc17dd463c2271c1e7b11065926d6127", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -482,14 +482,14 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                     a_is_expected: bool,\n                                     origin: TypeOrigin,\n-                                    a: ty::ImplHeader<'tcx>,\n-                                    b: ty::ImplHeader<'tcx>)\n+                                    a: &ty::ImplHeader<'tcx>,\n+                                    b: &ty::ImplHeader<'tcx>)\n                                     -> UnitResult<'tcx>\n {\n     debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n     match (a.trait_ref, b.trait_ref) {\n-        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, a_ref, b_ref),\n-        (None, None) => mk_eqty(cx, a_is_expected, a.self_ty, b.self_ty),\n+        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, origin, a_ref, b_ref),\n+        (None, None) => mk_eqty(cx, a_is_expected, origin, a.self_ty, b.self_ty),\n         _ => cx.tcx.sess.bug(\"mk_eq_impl_headers given mismatched impl kinds\"),\n     }\n }"}, {"sha": "6005d36ff4eb20c79bc36592fd85fca6fc27d185", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -10,18 +10,15 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::{Normalized, SelectionContext};\n-use super::{Obligation, ObligationCause, PredicateObligation};\n-use super::project;\n-use super::util;\n+use super::{SelectionContext};\n+use super::{Obligation, ObligationCause};\n \n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n-use middle::subst::{Subst, Substs, TypeSpace};\n+use middle::subst::TypeSpace;\n use middle::ty::{self, Ty, TyCtxt};\n-use middle::ty::error::TypeError;\n use middle::infer::{self, InferCtxt, TypeOrigin};\n-use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::codemap::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n@@ -31,7 +28,7 @@ struct InferIsLocal(bool);\n pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)\n-                                    -> Option<ImplTy<'tcx>>\n+                                    -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -48,7 +45,7 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n                       a_def_id: DefId,\n                       b_def_id: DefId)\n-                      -> Option<ImplHeader<'tcx>>\n+                      -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n@@ -64,8 +61,8 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     if let Err(_) = infer::mk_eq_impl_headers(selcx.infcx(),\n                                               true,\n                                               TypeOrigin::Misc(DUMMY_SP),\n-                                              a_impl_header,\n-                                              b_impl_header) {\n+                                              &a_impl_header,\n+                                              &b_impl_header) {\n         return None;\n     }\n \n@@ -74,7 +71,7 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     // Are any of the obligations unsatisfiable? If so, no overlap.\n     let infcx = selcx.infcx();\n     let opt_failing_obligation =\n-        a_impl_header.prediates\n+        a_impl_header.predicates\n                      .iter()\n                      .chain(&b_impl_header.predicates)\n                      .map(|p| infcx.resolve_type_vars_if_possible(p))"}, {"sha": "b54b0b73ef292fd4e92577aaa3142195453371e5", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -164,23 +164,23 @@ pub struct ImplHeader<'tcx> {\n }\n \n impl<'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars<'a,'tcx>(selcx: &mut traits::SelectionContext<'a,'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> ImplHeader<'tcx>\n+    pub fn with_fresh_ty_vars<'a>(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n+                                  impl_def_id: DefId)\n+                                  -> ImplHeader<'tcx>\n     {\n         let tcx = selcx.tcx();\n         let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n         let impl_substs = selcx.infcx().fresh_substs_for_generics(DUMMY_SP, &impl_generics);\n \n         let header = ImplHeader {\n             impl_def_id: impl_def_id,\n-            self_ty: tcx.lookup_item_type(impl_def_id),\n+            self_ty: tcx.lookup_item_type(impl_def_id).ty,\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id),\n-        }.subst(tcx, impl_substs);\n+            predicates: tcx.lookup_predicates(impl_def_id).predicates.into_vec(),\n+        }.subst(tcx, &impl_substs);\n \n-        let Normalized { value: mut header, obligations: obligations } =\n-            proect::normalize(selcx, ObligationCause::dummy(), &header);\n+        let traits::Normalized { value: mut header, obligations } =\n+            traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n \n         header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n         header"}, {"sha": "57cfdd0d8b8aecd727a8fa58d9ea36e811dd098d", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -452,8 +452,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n             impl_def_id: self.impl_def_id,\n             self_ty: self.self_ty.fold_with(folder),\n             trait_ref: self.trait_ref.map(|t| t.fold_with(folder)),\n-            predicates: self.predicates.into_iter().map(|p| p.fold_with(folder)).collect(),\n-            polarity: self.polarity,\n+            predicates: self.predicates.iter().map(|p| p.fold_with(folder)).collect(),\n         }\n     }\n "}, {"sha": "9dc8d7ae943a110ace0790197552e9f4d90afa1d", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -35,7 +35,9 @@ use CrateCtxt;\n use middle::infer::{self, InferCtxt, TypeOrigin, new_infer_ctxt};\n use std::cell::RefCell;\n use std::rc::Rc;\n+use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n@@ -519,6 +521,13 @@ fn enforce_trait_manually_implementable(tcx: &TyCtxt, sp: Span, trait_def_id: De\n     err.emit();\n }\n \n+// Factored out into helper because the error cannot be defined in multiple locations.\n+pub fn report_duplicate_item<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span, name: ast::Name)\n+                                   -> DiagnosticBuilder<'tcx>\n+{\n+    struct_span_err!(tcx.sess, sp, E0201, \"duplicate definitions with name `{}`:\", name)\n+}\n+\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n     let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);"}, {"sha": "80430076f197d6294d6403ff043f8ea0590e94a8", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n //! Overlap: No two impls for the same trait are implemented for the\n-//! same type.\n+//! same type. Likewise, no two inherent impls for a given type\n+//! constructor provide a method with the same name.\n \n use middle::cstore::{CrateStore, LOCAL_CRATE};\n use middle::def_id::DefId;\n@@ -115,7 +116,6 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         }\n     }\n \n-\n     fn check_if_impls_overlap(&self,\n                               impl1_def_id: DefId,\n                               impl2_def_id: DefId)\n@@ -128,8 +128,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl2_def_id);\n \n             let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n-            if let Some(trait_ref) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                self.report_overlap_error(impl1_def_id, impl2_def_id, trait_ref);\n+            if let Some(header) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(impl1_def_id, impl2_def_id, header.trait_ref.unwrap());\n             }\n         }\n     }\n@@ -150,13 +150,13 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             }).unwrap_or(String::new())\n         };\n \n-        let mut err = struct_span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n+        let mut err = struct_span_err!(self.tcx.sess, self.span_of_def_id(impl1), E0119,\n                                        \"conflicting implementations of trait `{}`{}:\",\n                                        trait_ref,\n                                        self_type);\n \n         if impl2.is_local() {\n-            span_note!(&mut err, self.span_of_impl(impl2),\n+            span_note!(&mut err, self.span_of_def_id(impl2),\n                        \"conflicting implementation is here:\");\n         } else {\n             let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n@@ -165,10 +165,61 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         err.emit();\n     }\n \n-    fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        let node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+    fn span_of_def_id(&self, did: DefId) -> Span {\n+        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n         self.tcx.map.span(node_id)\n     }\n+\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace { Type, Value }\n+\n+        fn name_and_namespace(tcx: &TyCtxt, item: &ty::ImplOrTraitItemId)\n+                              -> (ast::Name, Namespace)\n+        {\n+            let name = tcx.impl_or_trait_item(item.def_id()).name();\n+            (name, match *item {\n+                ty::TypeTraitItemId(..) => Namespace::Type,\n+                ty::ConstTraitItemId(..) => Namespace::Value,\n+                ty::MethodTraitItemId(..) => Namespace::Value,\n+            })\n+        }\n+\n+        let impl_items = self.tcx.impl_items.borrow();\n+\n+        for item1 in &impl_items[&impl1] {\n+            let (name, namespace) = name_and_namespace(&self.tcx, item1);\n+\n+            for item2 in &impl_items[&impl2] {\n+                if (name, namespace) == name_and_namespace(&self.tcx, item2) {\n+                    let mut err = super::report_duplicate_item(\n+                        &self.tcx, self.span_of_def_id(item1.def_id()), name);\n+                    span_note!(&mut err, self.span_of_def_id(item2.def_id()),\n+                               \"conflicting definition is here:\");\n+                    err.emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n+\n+        let inherent_impls = self.tcx.inherent_impls.borrow();\n+        let impls = match inherent_impls.get(&ty_def_id) {\n+            Some(impls) => impls,\n+            None => return\n+        };\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i+1)..] {\n+                let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+                if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                    self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                }\n+            }\n+        }\n+    }\n }\n \n \n@@ -180,6 +231,11 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 self.check_for_overlapping_impls_of_trait(trait_def_id);\n             }\n \n+            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+                let type_def_id = self.tcx.map.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+\n             hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be"}, {"sha": "b493b64a45fcf9f650c3bc0fa76ec1377fb6a88b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -63,6 +63,7 @@ use lint;\n use middle::def::Def;\n use middle::def_id::DefId;\n use constrained_type_params as ctp;\n+use coherence;\n use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::const_eval::{self, ConstVal};\n@@ -750,17 +751,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     _                    => &mut seen_value_items,\n                 };\n                 if !seen_items.insert(impl_item.name) {\n-                    let desc = match impl_item.node {\n-                        hir::ImplItemKind::Const(_, _) => \"associated constant\",\n-                        hir::ImplItemKind::Type(_) => \"associated type\",\n-                        hir::ImplItemKind::Method(ref sig, _) =>\n-                            match sig.explicit_self.node {\n-                                hir::SelfStatic => \"associated function\",\n-                                _ => \"method\",\n-                            },\n-                    };\n-\n-                    span_err!(tcx.sess, impl_item.span, E0201, \"duplicate {}\", desc);\n+                    coherence::report_duplicate_item(tcx, impl_item.span, impl_item.name).emit();\n                 }\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {"}, {"sha": "14d04a5d109bbc9fd87db3e087544091ccfe9bd1", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21df87f515b10ab4d6dac2275d09e679471c7d7c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=21df87f515b10ab4d6dac2275d09e679471c7d7c", "patch": "@@ -2285,6 +2285,21 @@ impl Baz for Foo {\n     type Quux = u32;\n }\n ```\n+\n+Note, however, that items with the same name are allowed for inherent `impl`\n+blocks that don't overlap:\n+\n+```\n+struct Foo<T>(T);\n+\n+impl Foo<u8> {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+\n+impl Foo<bool> {\n+    fn bar(&self) -> bool { self.0 }\n+}\n+```\n \"##,\n \n E0202: r##\""}]}