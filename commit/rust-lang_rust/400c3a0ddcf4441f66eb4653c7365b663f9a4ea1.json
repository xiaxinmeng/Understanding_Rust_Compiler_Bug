{"sha": "400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMGMzYTBkZGNmNDQ0MWY2NmViNDY1M2M3MzY1YjY2M2Y5YTRlYTE=", "commit": {"author": {"name": "Ben Foppa", "email": "benjamin.foppa@gmail.com", "date": "2015-01-04T19:07:32Z"}, "committer": {"name": "Ben Foppa", "email": "benjamin.foppa@gmail.com", "date": "2015-01-04T20:55:54Z"}, "message": "[breaking change] Update entry API as part of RFC 509.", "tree": {"sha": "1a457687cff5058b1a1f58d623b75fcc10a50476", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a457687cff5058b1a1f58d623b75fcc10a50476"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "html_url": "https://github.com/rust-lang/rust/commit/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/comments", "author": {"login": "bfops", "id": 196249, "node_id": "MDQ6VXNlcjE5NjI0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/196249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bfops", "html_url": "https://github.com/bfops", "followers_url": "https://api.github.com/users/bfops/followers", "following_url": "https://api.github.com/users/bfops/following{/other_user}", "gists_url": "https://api.github.com/users/bfops/gists{/gist_id}", "starred_url": "https://api.github.com/users/bfops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bfops/subscriptions", "organizations_url": "https://api.github.com/users/bfops/orgs", "repos_url": "https://api.github.com/users/bfops/repos", "events_url": "https://api.github.com/users/bfops/events{/privacy}", "received_events_url": "https://api.github.com/users/bfops/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bfops", "id": 196249, "node_id": "MDQ6VXNlcjE5NjI0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/196249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bfops", "html_url": "https://github.com/bfops", "followers_url": "https://api.github.com/users/bfops/followers", "following_url": "https://api.github.com/users/bfops/following{/other_user}", "gists_url": "https://api.github.com/users/bfops/gists{/gist_id}", "starred_url": "https://api.github.com/users/bfops/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bfops/subscriptions", "organizations_url": "https://api.github.com/users/bfops/orgs", "repos_url": "https://api.github.com/users/bfops/repos", "events_url": "https://api.github.com/users/bfops/events{/privacy}", "received_events_url": "https://api.github.com/users/bfops/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260e46115b922d29ca98b3cbea190011b1d3e63f", "url": "https://api.github.com/repos/rust-lang/rust/commits/260e46115b922d29ca98b3cbea190011b1d3e63f", "html_url": "https://github.com/rust-lang/rust/commit/260e46115b922d29ca98b3cbea190011b1d3e63f"}], "stats": {"total": 305, "additions": 170, "deletions": 135}, "files": [{"sha": "cd4f8d203dfe94ec5d861f2af02312d440a16f28", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -11,7 +11,7 @@\n use prelude::*;\n use std::rand;\n use std::rand::Rng;\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n pub fn insert_rand_n<M, I, R>(n: uint,\n                               map: &mut M,\n@@ -33,7 +33,8 @@ pub fn insert_rand_n<M, I, R>(n: uint,\n         let k = rng.gen::<uint>() % n;\n         insert(map, k);\n         remove(map, k);\n-    })\n+    });\n+    black_box(map);\n }\n \n pub fn insert_seq_n<M, I, R>(n: uint,\n@@ -55,7 +56,8 @@ pub fn insert_seq_n<M, I, R>(n: uint,\n         insert(map, i);\n         remove(map, i);\n         i = (i + 2) % n;\n-    })\n+    });\n+    black_box(map);\n }\n \n pub fn find_rand_n<M, T, I, F>(n: uint,\n@@ -82,7 +84,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n     b.iter(|| {\n         let t = find(map, keys[i]);\n         i = (i + 1) % n;\n-        t\n+        black_box(t);\n     })\n }\n \n@@ -104,6 +106,6 @@ pub fn find_seq_n<M, T, I, F>(n: uint,\n     b.iter(|| {\n         let x = find(map, i);\n         i = (i + 1) % n;\n-        x\n+        black_box(x);\n     })\n }"}, {"sha": "a9e09a584d6877d8b86c4126941f97242cd27cb5", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -19,7 +19,7 @@ pub use self::Entry::*;\n \n use core::prelude::*;\n \n-use core::borrow::BorrowFrom;\n+use core::borrow::{BorrowFrom, ToOwned};\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n@@ -128,20 +128,23 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n+#[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, K:'a, V:'a> {\n+pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, K, V>),\n+    Vacant(VacantEntry<'a, Q, K, V>),\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n+#[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, K:'a, V:'a> {\n-    key: K,\n+pub struct VacantEntry<'a, Sized? Q:'a, K:'a, V:'a> {\n+    key: &'a Q,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n+#[stable]\n /// An occupied Entry.\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n@@ -1132,40 +1135,56 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n+impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+        match self {\n+            Occupied(entry) => Ok(entry.into_mut()),\n+            Vacant(entry) => Err(entry),\n+        }\n+    }\n+}\n \n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+impl<'a, Sized? Q: ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n+    #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    pub fn set(self, value: V) -> &'a mut V {\n-        self.stack.insert(self.key, value)\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        self.stack.insert(self.key.to_owned(), value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    #[stable]\n     /// Gets a reference to the value in the entry.\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n+    #[stable]\n     /// Gets a mutable reference to the value in the entry.\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n+    #[stable]\n     /// Converts the entry into a mutable reference to its value.\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n+    #[stable]\n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    pub fn set(&mut self, mut value: V) -> V {\n+    pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n+    #[stable]\n     /// Takes the value of the entry out of the map, and returns it.\n-    pub fn take(self) -> V {\n+    pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n }\n@@ -1352,9 +1371,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// // count the number of occurrences of letters in the vec\n     /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"].iter() {\n-    ///     match count.entry(*x) {\n+    ///     match count.entry(x) {\n     ///         Entry::Vacant(view) => {\n-    ///             view.set(1);\n+    ///             view.insert(1);\n     ///         },\n     ///         Entry::Occupied(mut view) => {\n     ///             let v = view.get_mut();\n@@ -1365,12 +1384,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n-    pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n+    /// The key must have the same ordering before or after `.to_owned()` is called.\n+    #[stable]\n+    pub fn entry<'a, Sized? Q>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n+        where Q: Ord + ToOwned<K>\n+    {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, &key) {\n+                return match Node::search(node, key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {\n@@ -1413,6 +1436,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n+    use std::borrow::{ToOwned, BorrowFrom};\n \n     use super::{BTreeMap, Occupied, Vacant};\n \n@@ -1562,19 +1586,19 @@ mod test {\n         let mut map: BTreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(1) {\n+        match map.entry(&1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n-                assert_eq!(view.set(100), 10);\n+                assert_eq!(view.insert(100), 10);\n             }\n         }\n         assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n         // Existing key (update)\n-        match map.entry(2) {\n+        match map.entry(&2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -1585,21 +1609,21 @@ mod test {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(3) {\n+        match map.entry(&3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n-                assert_eq!(view.take(), 30);\n+                assert_eq!(view.remove(), 30);\n             }\n         }\n         assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n         // Inexistent key (insert)\n-        match map.entry(10) {\n+        match map.entry(&10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n-                assert_eq!(*view.set(1000), 1000);\n+                assert_eq!(*view.insert(1000), 1000);\n             }\n         }\n         assert_eq!(map.get(&10).unwrap(), &1000);"}, {"sha": "ba32dbf1e4fc001416d323c1db60f55a88981353", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -1329,8 +1329,8 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.uint()) {\n-                            Vacant(entry) => { entry.set(vec![id]); },\n+                        match mutables.entry(&ident.name.uint()) {\n+                            Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n                     }"}, {"sha": "b0cf322b0688ec47baa287ca59477d45f88e7306", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -87,8 +87,8 @@ fn dump_crates(cstore: &CStore) {\n fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     let mut map = FnvHashMap::new();\n     cstore.iter_crate_data(|cnum, data| {\n-        match map.entry(data.name()) {\n-            Vacant(entry) => { entry.set(vec![cnum]); },\n+        match map.entry(&data.name()) {\n+            Vacant(entry) => { entry.insert(vec![cnum]); },\n             Occupied(mut entry) => { entry.get_mut().push(cnum); },\n         }\n     });"}, {"sha": "c18bd421b3b077b61946b57b615bbefd756c892d", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -228,7 +228,6 @@ use util::fs;\n \n use std::c_str::ToCStr;\n use std::cmp;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::{HashMap, HashSet};\n use std::io::fs::PathExtensions;\n use std::io;\n@@ -400,10 +399,9 @@ impl<'a> Context<'a> {\n             };\n             info!(\"lib candidate: {}\", path.display());\n \n-            let slot = match candidates.entry(hash.to_string()) {\n-                Occupied(entry) => entry.into_mut(),\n-                Vacant(entry) => entry.set((HashSet::new(), HashSet::new())),\n-            };\n+            let hash_str = hash.to_string();\n+            let slot = candidates.entry(&hash_str).get().unwrap_or_else(\n+                |vacant_entry| vacant_entry.insert((HashSet::new(), HashSet::new())));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n             if rlib {\n                 rlibs.insert(fs::realpath(path).unwrap());"}, {"sha": "6671f0f72f674f44717707f3846eb640428d1bf7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -311,8 +311,8 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n \n         ast::ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow()[callee.id].clone();\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.set(def);\n+            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(&expr.id) {\n+               entry.insert(def);\n             }\n             let path = match def {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),"}, {"sha": "7488a72b4e4609382b3c9cb262d6090d7928b883", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -66,13 +66,13 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             None => { }\n         }\n \n-        match self.freshen_map.entry(key) {\n+        match self.freshen_map.entry(&key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;\n                 self.freshen_count += 1;\n                 let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n-                entry.set(t);\n+                entry.insert(t);\n                 t\n             }\n         }"}, {"sha": "98c69962bc288b6732ab1951c698d068fe10f5dd", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -137,8 +137,8 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n         let mut node_ids = FnvHashMap::new();\n         {\n             let mut add_node = |&mut : node| {\n-                if let Vacant(e) = node_ids.entry(node) {\n-                    e.set(i);\n+                if let Vacant(e) = node_ids.entry(&node) {\n+                    e.insert(i);\n                     i += 1;\n                 }\n             };"}, {"sha": "c2327adece8e04dc274e6df1ad68fbfe6a6b2469", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -437,8 +437,9 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"register_region_obligation({})\",\n            region_obligation.repr(tcx));\n \n-    match region_obligations.entry(region_obligation.cause.body_id) {\n-        Vacant(entry) => { entry.set(vec![region_obligation]); },\n+    let body_id = region_obligation.cause.body_id;\n+    match region_obligations.entry(&body_id) {\n+        Vacant(entry) => { entry.insert(vec![region_obligation]); },\n         Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n     }\n "}, {"sha": "4c53c360b149446caccbdec928682d8bf691fd34", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -78,7 +78,6 @@ use std::ops;\n use std::rc::Rc;\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n@@ -5651,10 +5650,8 @@ pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n         node_id_to_type(tcx, id.node)\n     } else {\n         let mut tcache = tcx.tcache.borrow_mut();\n-        let pty = match tcache.entry(id) {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.set(csearch::get_field_type(tcx, struct_id, id)),\n-        };\n+        let pty = tcache.entry(&id).get().unwrap_or_else(\n+            |vacant_entry| vacant_entry.insert(csearch::get_field_type(tcx, struct_id, id)));\n         pty.ty\n     };\n     ty.subst(tcx, substs)\n@@ -6841,10 +6838,8 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         debug!(\"region={}\", region.repr(tcx));\n         match region {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                * match map.entry(br) {\n-                    Vacant(entry) => entry.set(mapf(br, debruijn)),\n-                    Occupied(entry) => entry.into_mut(),\n-                }\n+                * map.entry(&br).get().unwrap_or_else(\n+                      |vacant_entry| vacant_entry.insert(mapf(br, debruijn)))\n             }\n             _ => {\n                 region"}, {"sha": "4c9bd1e3416de4edcdc05a56fcba43a262274992", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -1114,8 +1114,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None => early_error(\"--extern value must be of the format `foo=bar`\"),\n         };\n \n-        match externs.entry(name.to_string()) {\n-            Vacant(entry) => { entry.set(vec![location.to_string()]); },\n+        match externs.entry(&name.to_string()) {\n+            Vacant(entry) => { entry.insert(vec![location.to_string()]); },\n             Occupied(mut entry) => { entry.get_mut().push(location.to_string()); },\n         }\n     }"}, {"sha": "6321486d459e65fce5de649037c968f7a6512ad9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -1688,15 +1688,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = match import_resolutions.entry(name) {\n-            Occupied(entry) => {\n-                entry.into_mut()\n-            }\n-            Vacant(entry) => {\n+        let dest_import_resolution = import_resolutions.entry(&name).get().unwrap_or_else(\n+            |vacant_entry| {\n                 // Create a new import resolution from this child.\n-                entry.set(ImportResolution::new(id, is_public))\n-            }\n-        };\n+                vacant_entry.insert(ImportResolution::new(id, is_public))\n+            });\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n@@ -2630,16 +2626,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = match seen.entry(function_id) {\n+                            let seen = match seen.entry(&function_id) {\n                                 Occupied(v) => v.into_mut(),\n-                                Vacant(v) => v.set(NodeSet::new()),\n+                                Vacant(v) => v.insert(NodeSet::new()),\n                             };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            match self.freevars.borrow_mut().entry(function_id) {\n+                            match self.freevars.borrow_mut().entry(&function_id) {\n                                 Occupied(v) => v.into_mut(),\n-                                Vacant(v) => v.set(vec![]),\n+                                Vacant(v) => v.insert(vec![]),\n                             }.push(Freevar { def: prev_def, span: span });\n                             seen.insert(node_id);\n                         }\n@@ -4722,7 +4718,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 \"Import should only be used for `use` directives\");\n         self.last_private.insert(node_id, lp);\n \n-        match self.def_map.borrow_mut().entry(node_id) {\n+        match self.def_map.borrow_mut().entry(&node_id) {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n@@ -4734,7 +4730,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                  *entry.get(),\n                                  def)[]);\n             },\n-            Vacant(entry) => { entry.set(def); },\n+            Vacant(entry) => { entry.insert(def); },\n         }\n     }\n "}, {"sha": "56cf4acc184e5dd7613902188aefdc1cf694289c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -496,7 +496,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields.iter() {\n-        let field_type = match used_fields.entry(field.ident.name) {\n+        let field_type = match used_fields.entry(&field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\",\n@@ -507,7 +507,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 tcx.types.err\n             }\n             Vacant(vacant) => {\n-                vacant.set(span);\n+                vacant.insert(span);\n                 field_type_map.get(&field.ident.name).cloned()\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,"}, {"sha": "3accbbfb1a2e79124d91709b8404b667905a9371", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -36,7 +36,6 @@ pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;\n@@ -822,10 +821,8 @@ impl DocFolder for Cache {\n         if let clean::ImplItem(ref i) = item.inner {\n             match i.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n-                    let v = match self.implementors.entry(did) {\n-                        Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-                        Occupied(entry) => entry.into_mut(),\n-                    };\n+                    let v = self.implementors.entry(&did).get().unwrap_or_else(\n+                        |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                     v.push(Implementor {\n                         def_id: item.def_id,\n                         generics: i.generics.clone(),\n@@ -1014,10 +1011,8 @@ impl DocFolder for Cache {\n                         };\n \n                         if let Some(did) = did {\n-                            let v = match self.impls.entry(did) {\n-                                Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-                                Occupied(entry) => entry.into_mut(),\n-                            };\n+                            let v = self.impls.entry(&did).get().unwrap_or_else(\n+                                |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n                             v.push(Impl {\n                                 impl_: i,\n                                 dox: dox,\n@@ -1264,10 +1259,9 @@ impl Context {\n                 None => continue,\n                 Some(ref s) => s.to_string(),\n             };\n-            let v = match map.entry(short.to_string()) {\n-                Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-                Occupied(entry) => entry.into_mut(),\n-            };\n+            let short = short.to_string();\n+            let v = map.entry(&short).get().unwrap_or_else(\n+                |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n             v.push(myname);\n         }\n "}, {"sha": "106fe452f46a6059a931a1973681f516f3454096", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -38,7 +38,6 @@ extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::io::File;\n use std::io;\n use std::rc::Rc;\n@@ -321,10 +320,9 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n                 return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n             }\n         };\n-        let locs = match externs.entry(name.to_string()) {\n-            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-            Occupied(entry) => entry.into_mut(),\n-        };\n+        let name = name.to_string();\n+        let locs = externs.entry(&name).get().unwrap_or_else(\n+            |vacant_entry| vacant_entry.insert(Vec::with_capacity(1)));\n         locs.push(location.to_string());\n     }\n     Ok(externs)"}, {"sha": "a6532707f3e367d74237d5f673e9ae78806bd22e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -14,7 +14,7 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::BorrowFrom;\n+use borrow::{BorrowFrom, ToOwned};\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n@@ -920,12 +920,16 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Gets the given key's corresponding entry in the map for in-place manipulation\n-    pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V> {\n+    #[stable]\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n+    pub fn entry<'a, Sized? Q>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n+        where Q: Eq + Hash<S> + ToOwned<K>\n+    {\n         // Gotta resize now.\n         self.reserve(1);\n \n-        let hash = self.make_hash(&key);\n+        let hash = self.make_hash(key);\n         search_entry_hashed(&mut self.table, hash, key)\n     }\n \n@@ -1138,8 +1142,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n-        -> Entry<'a, K, V> {\n+fn search_entry_hashed<'a, K, V, Sized? Q>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n+        -> Entry<'a, Q, K, V>\n+    where Q: Eq + ToOwned<K>\n+{\n     // Worst case, we'll find one empty bucket among `size + 1` buckets.\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n@@ -1161,7 +1167,7 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n         // hash matches?\n         if bucket.hash() == hash {\n             // key matches?\n-            if k == *bucket.read().0 {\n+            if *k == *BorrowFrom::borrow_from(bucket.read().0) {\n                 return Occupied(OccupiedEntry{\n                     elem: bucket,\n                 });\n@@ -1343,24 +1349,27 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     >\n }\n \n+#[stable]\n /// A view into a single occupied location in a HashMap\n-pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n+#[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K,V, &'a mut RawTable<K, V>>,\n+    key: &'a Q,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n+#[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, K:'a, V:'a> {\n+pub enum Entry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n-    Vacant(VacantEntry<'a, K, V>),\n+    Vacant(VacantEntry<'a, Q, K, V>),\n }\n \n /// Possible states of a VacantEntry\n@@ -1426,46 +1435,63 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n+impl<'a, Sized? Q, K, V> Entry<'a, Q, K, V> {\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n+        match self {\n+            Occupied(entry) => Ok(entry.into_mut()),\n+            Vacant(entry) => Err(entry),\n+        }\n+    }\n+}\n+\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n+    #[stable]\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n+    #[stable]\n     /// Gets a mutable reference to the value in the entry\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n+    #[stable]\n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n+    #[stable]\n     /// Sets the value of the entry, and returns the entry's old value\n-    pub fn set(&mut self, mut value: V) -> V {\n+    pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n+    #[stable]\n     /// Takes the value out of the entry, and returns it\n-    pub fn take(self) -> V {\n+    pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n }\n \n-impl<'a, K, V> VacantEntry<'a, K, V> {\n+impl<'a, Sized? Q: 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n+    #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n-    pub fn set(self, value: V) -> &'a mut V {\n+    pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key, value)\n+                robin_hood(bucket, ib, self.hash, self.key.to_owned(), value)\n             }\n             NoElem(bucket) => {\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n+                bucket.put(self.hash, self.key.to_owned(), value).into_mut_refs().1\n             }\n         }\n     }\n@@ -1497,6 +1523,8 @@ mod test_map {\n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n     use iter::{range_inclusive, range_step_inclusive, repeat};\n+    use borrow::ToOwned;\n+    use hash;\n     use cell::RefCell;\n     use rand::{weak_rng, Rng};\n \n@@ -2090,19 +2118,19 @@ mod test_map {\n         let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         // Existing key (insert)\n-        match map.entry(1) {\n+        match map.entry(&1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n-                assert_eq!(view.set(100), 10);\n+                assert_eq!(view.insert(100), 10);\n             }\n         }\n         assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n         // Existing key (update)\n-        match map.entry(2) {\n+        match map.entry(&2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n@@ -2114,21 +2142,21 @@ mod test_map {\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.entry(3) {\n+        match map.entry(&3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n-                assert_eq!(view.take(), 30);\n+                assert_eq!(view.remove(), 30);\n             }\n         }\n         assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n         // Inexistent key (insert)\n-        match map.entry(10) {\n+        match map.entry(&10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n-                assert_eq!(*view.set(1000), 1000);\n+                assert_eq!(*view.insert(1000), 1000);\n             }\n         }\n         assert_eq!(map.get(&10).unwrap(), &1000);\n@@ -2156,11 +2184,11 @@ mod test_map {\n \n         for i in range(0u, 1000) {\n             let x = rng.gen_range(-10, 10);\n-            match m.entry(x) {\n+            match m.entry(&x) {\n                 Vacant(_) => {},\n                 Occupied(e) => {\n                     println!(\"{}: remove {}\", i, x);\n-                    e.take();\n+                    e.remove();\n                 },\n             }\n "}, {"sha": "c0445fb5aea97babd873ca904f8678e4c6dcd93e", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -226,7 +226,7 @@\n //! the key has been seen or not. Normally, this would require a `find` followed by an\n //! `insert`, effectively duplicating the search effort on each insertion.\n //!\n-//! When a user calls `map.entry(key)`, the map will search for the key and then yield\n+//! When a user calls `map.entry(&key)`, the map will search for the key and then yield\n //! a variant of the `Entry` enum.\n //!\n //! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case the\n@@ -255,8 +255,8 @@\n //! let message = \"she sells sea shells by the sea shore\";\n //!\n //! for c in message.chars() {\n-//!     match count.entry(c) {\n-//!         Vacant(entry) => { entry.set(1u); },\n+//!     match count.entry(&c) {\n+//!         Vacant(entry) => { entry.insert(1u); },\n //!         Occupied(mut entry) => *entry.get_mut() += 1,\n //!     }\n //! }\n@@ -290,8 +290,8 @@\n //! for id in orders.into_iter() {\n //!     // If this is the first time we've seen this customer, initialize them\n //!     // with no blood alcohol. Otherwise, just retrieve them.\n-//!     let person = match blood_alcohol.entry(id) {\n-//!         Vacant(entry) => entry.set(Person{id: id, blood_alcohol: 0.0}),\n+//!     let person = match blood_alcohol.entry(&id) {\n+//!         Vacant(entry) => entry.insert(Person{id: id, blood_alcohol: 0.0}),\n //!         Occupied(entry) => entry.into_mut(),\n //!     };\n //!"}, {"sha": "4075b208f787399d2b8b74e577d09da141188dba", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -21,7 +21,6 @@ use ast::{Ident, Mrk, Name, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n@@ -67,10 +66,9 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    * match table.mark_memo.borrow_mut().entry(key) {\n-        Vacant(entry) => entry.set(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt))),\n-        Occupied(entry) => entry.into_mut(),\n-    }\n+    * table.mark_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+          |vacant_entry|\n+              vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt))))\n }\n \n /// Extend a syntax context with a given rename\n@@ -86,10 +84,9 @@ fn apply_rename_internal(id: Ident,\n                        table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, id, to);\n \n-    * match table.rename_memo.borrow_mut().entry(key) {\n-        Vacant(entry) => entry.set(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt))),\n-        Occupied(entry) => entry.into_mut(),\n-    }\n+    * table.rename_memo.borrow_mut().entry(&key).get().unwrap_or_else(\n+          |vacant_entry|\n+              vacant_entry.insert(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt))))\n }\n \n /// Apply a list of renamings to a context"}, {"sha": "1438d152554955662f84513ac87f50fd2f2871ea", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -219,9 +219,9 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                 }\n             }\n             &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n-                match ret_val.entry(bind_name) {\n+                match ret_val.entry(&bind_name) {\n                     Vacant(spot) => {\n-                        spot.set(res[*idx].clone());\n+                        spot.insert(res[*idx].clone());\n                         *idx += 1;\n                     }\n                     Occupied(..) => {"}, {"sha": "7e7f36f6e83fae1dbdf79b71caeffea8ff3b522b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/400c3a0ddcf4441f66eb4653c7365b663f9a4ea1/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=400c3a0ddcf4441f66eb4653c7365b663f9a4ea1", "patch": "@@ -438,12 +438,14 @@ pub fn write_boxplot<W: Writer, T: Float + Show + FromPrimitive>(\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<Item=U>, U: Eq+Hash>(mut iter: T) -> hash_map::HashMap<U, uint> {\n+pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n+  where T: Iterator<Item=U>, U: Eq + Clone + Hash\n+{\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n-        match map.entry(elem) {\n+        match map.entry(&elem) {\n             Occupied(mut entry) => { *entry.get_mut() += 1; },\n-            Vacant(entry) => { entry.set(1); },\n+            Vacant(entry) => { entry.insert(1); },\n         }\n     }\n     map"}]}