{"sha": "a804868bbf578dada5249ac3c79b7b524684c78e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MDQ4NjhiYmY1NzhkYWRhNTI0OWFjM2M3OWI3YjUyNDY4NGM3OGU=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T02:36:42Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:43:00Z"}, "message": "Get rid of RegionErrorNamingContext", "tree": {"sha": "4824682fa2412c97927ffac17a47103057eadf7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4824682fa2412c97927ffac17a47103057eadf7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a804868bbf578dada5249ac3c79b7b524684c78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a804868bbf578dada5249ac3c79b7b524684c78e", "html_url": "https://github.com/rust-lang/rust/commit/a804868bbf578dada5249ac3c79b7b524684c78e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a804868bbf578dada5249ac3c79b7b524684c78e/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "234b9301087ac21dd1dec5e6cad59cb76346ee6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/234b9301087ac21dd1dec5e6cad59cb76346ee6c", "html_url": "https://github.com/rust-lang/rust/commit/234b9301087ac21dd1dec5e6cad59cb76346ee6c"}], "stats": {"total": 259, "additions": 88, "deletions": 171}, "files": [{"sha": "01b7c5645fe8b2a1c0aaff5baed72ceede5ddb87", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -16,8 +16,8 @@ use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use crate::borrow_check::{\n-    borrow_set::BorrowData, diagnostics::RegionErrorNamingCtx, nll::ConstraintDescription,\n-    region_infer::Cause, MirBorrowckCtxt, WriteKind,\n+    borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n+    WriteKind,\n };\n \n use super::{find_use, RegionName, UseSpans};\n@@ -267,8 +267,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n         );\n \n-        let mut renctx = RegionErrorNamingCtx::new();\n-        let outlived_fr_name = self.give_region_a_name(&mut renctx, outlived_region);\n+        let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n         (category, from_closure, span, outlived_fr_name)\n     }"}, {"sha": "0fc73d33f90013475e059f7d9f8003343cdfe071", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -32,7 +32,7 @@ mod region_errors;\n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n-crate use region_name::{RegionErrorNamingCtx, RegionName, RegionNameSource};\n+crate use region_name::{RegionName, RegionNameSource};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n "}, {"sha": "ee9489078bdb9ba61d73168d6a419363235f637b", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -12,7 +12,7 @@ use smallvec::SmallVec;\n \n use crate::borrow_check::MirBorrowckCtxt;\n \n-use super::{ErrorConstraintInfo, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{ErrorConstraintInfo, RegionName, RegionNameSource};\n \n /// The different things we could suggest.\n enum SuggestedConstraint {\n@@ -77,17 +77,15 @@ impl OutlivesSuggestionBuilder {\n     fn region_vid_to_name(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n         region: RegionVid,\n     ) -> Option<RegionName> {\n-        mbcx.give_region_a_name(renctx, region).filter(Self::region_name_is_suggestable)\n+        mbcx.give_region_a_name(region).filter(Self::region_name_is_suggestable)\n     }\n \n     /// Compiles a list of all suggestions to be printed in the final big suggestion.\n     fn compile_all_suggestions(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> SmallVec<[SuggestedConstraint; 2]> {\n         let mut suggested = SmallVec::new();\n \n@@ -96,7 +94,7 @@ impl OutlivesSuggestionBuilder {\n         let mut unified_already = FxHashSet::default();\n \n         for (fr, outlived) in &self.constraints_to_add {\n-            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, renctx, *fr) {\n+            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, *fr) {\n                 fr_name\n             } else {\n                 continue;\n@@ -105,9 +103,7 @@ impl OutlivesSuggestionBuilder {\n             let outlived = outlived\n                 .iter()\n                 // if there is a `None`, we will just omit that constraint\n-                .filter_map(|fr| {\n-                    self.region_vid_to_name(mbcx, renctx, *fr).map(|rname| (fr, rname))\n-                })\n+                .filter_map(|fr| self.region_vid_to_name(mbcx, *fr).map(|rname| (fr, rname)))\n                 .collect::<Vec<_>>();\n \n             // No suggestable outlived lifetimes.\n@@ -171,12 +167,11 @@ impl OutlivesSuggestionBuilder {\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         // Emit an intermediate note.\n-        let fr_name = self.region_vid_to_name(mbcx, renctx, errci.fr);\n-        let outlived_fr_name = self.region_vid_to_name(mbcx, renctx, errci.outlived_fr);\n+        let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n+        let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr);\n \n         if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n             if let RegionNameSource::Static = outlived_fr_name.source {\n@@ -192,11 +187,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion(\n-        &self,\n-        mbcx: &mut MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) {\n+    crate fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n         // No constraints to add? Done.\n         if self.constraints_to_add.is_empty() {\n             debug!(\"No constraints to suggest.\");\n@@ -213,7 +204,7 @@ impl OutlivesSuggestionBuilder {\n         }\n \n         // Get all suggestable constraints.\n-        let suggested = self.compile_all_suggestions(mbcx, renctx);\n+        let suggested = self.compile_all_suggestions(mbcx);\n \n         // If there are no suggestable constraints...\n         if suggested.is_empty() {"}, {"sha": "729a679e92a32ccd27f20ba60838b5800a2c1d30", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -19,7 +19,7 @@ use crate::borrow_check::{\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{OutlivesSuggestionBuilder, RegionName, RegionNameSource};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -152,8 +152,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n         // buffered in the `MirBorrowckCtxt`.\n \n-        // TODO(mark-i-m): Would be great to get rid of the naming context.\n-        let mut region_naming = RegionErrorNamingCtx::new();\n         let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n \n         for nll_error in nll_errors.into_iter() {\n@@ -243,7 +241,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             fr_origin,\n                             shorter_fr,\n                             &mut outlives_suggestion,\n-                            &mut region_naming,\n                         );\n                     } else {\n                         // We only report the first error, so as not to overwhelm the user. See\n@@ -262,7 +259,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n \n         // Emit one outlives suggestions for each MIR def we borrowck\n-        outlives_suggestion.add_suggestion(self, &mut region_naming);\n+        outlives_suggestion.add_suggestion(self);\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -279,7 +276,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         outlives_suggestion: &mut OutlivesSuggestionBuilder,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n@@ -320,21 +316,21 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         let diag = match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n-                self.report_fnmut_error(&errci, renctx)\n+                self.report_fnmut_error(&errci)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n-                let mut db = self.report_escaping_data_error(&errci, renctx);\n+                let mut db = self.report_escaping_data_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(self, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n             _ => {\n-                let mut db = self.report_general_error(&errci, renctx);\n+                let mut db = self.report_general_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(self, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n@@ -360,11 +356,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(\n-        &self,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut diag = self\n@@ -386,7 +378,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         diag.span_label(*span, message);\n \n-        match self.give_region_a_name(renctx, *outlived_fr).unwrap().source {\n+        match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -421,11 +413,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n-    fn report_escaping_data_error(\n-        &self,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    fn report_escaping_data_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n         let fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n@@ -456,10 +444,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n-            return self.report_general_error(\n-                &ErrorConstraintInfo { fr_is_local: true, outlived_fr_is_local: false, ..*errci },\n-                renctx,\n-            );\n+            return self.report_general_error(&ErrorConstraintInfo {\n+                fr_is_local: true,\n+                outlived_fr_is_local: false,\n+                ..*errci\n+            });\n         }\n \n         let mut diag =\n@@ -505,11 +494,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///    |     ^^^^^^^^^^^^^^ function was supposed to return data with lifetime `'a` but it\n     ///    |                    is returning data with lifetime `'b`\n     /// ```\n-    fn report_general_error(\n-        &self,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'tcx> {\n+    fn report_general_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -526,9 +511,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mir_def_name =\n             if self.infcx.tcx.is_closure(self.mir_def_id) { \"closure\" } else { \"function\" };\n \n-        let fr_name = self.give_region_a_name(renctx, *fr).unwrap();\n+        let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(renctx, *outlived_fr).unwrap();\n+        let outlived_fr_name = self.give_region_a_name(*outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {"}, {"sha": "f7aeec5e76ee916429280d0731107285957c1292", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 43, "deletions": 95, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -3,7 +3,6 @@ use std::fmt::{self, Display};\n use rustc::ty::print::RegionHighlightMode;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::{self, RegionVid, Ty};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -52,46 +51,6 @@ crate enum RegionNameSource {\n     AnonRegionFromAsyncFn(Span),\n }\n \n-/// Records region names that have been assigned before so that we can use the same ones in later\n-/// diagnostics.\n-#[derive(Debug, Clone)]\n-crate struct RegionErrorNamingCtx {\n-    /// Record the region names generated for each region in the given\n-    /// MIR def so that we can reuse them later in help/error messages.\n-    renctx: FxHashMap<RegionVid, RegionName>,\n-\n-    /// The counter for generating new region names.\n-    counter: usize,\n-}\n-\n-impl RegionErrorNamingCtx {\n-    crate fn new() -> Self {\n-        Self { counter: 1, renctx: FxHashMap::default() }\n-    }\n-\n-    /// Get the name of `region` if it has previously been named.\n-    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n-        self.renctx.get(region)\n-    }\n-\n-    /// Give `region` the name `name`.\n-    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n-        self.renctx.insert(region, name);\n-    }\n-\n-    /// Creates a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n-    /// increment the counter.\n-    ///\n-    /// The name is not memoized. A separate call to `insert` should be made later. (Currently,\n-    /// this happens at the end of `give_region_a_name`).\n-    crate fn synthesize_region_name(&mut self) -> Symbol {\n-        let c = self.counter;\n-        self.counter += 1;\n-\n-        Symbol::intern(&format!(\"'{:?}\", c))\n-    }\n-}\n-\n impl RegionName {\n     crate fn was_named(&self) -> bool {\n         match self.source {\n@@ -159,6 +118,17 @@ impl Display for RegionName {\n }\n \n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n+    /// Generate a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n+    /// increment the counter.\n+    ///\n+    /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n+    fn synthesize_region_name(&self) -> Symbol {\n+        let mut counter = self.next_region_name.try_borrow_mut().unwrap();\n+        let c = *counter;\n+        *counter += 1;\n+        Symbol::intern(&format!(\"'{:?}\", c))\n+    }\n+\n     /// Maps from an internal MIR region vid to something that we can\n     /// report to the user. In some cases, the region vids will map\n     /// directly to lifetimes that the user has a name for (e.g.,\n@@ -167,6 +137,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// that end, this function takes a \"diagnostic\" so that it can\n     /// create auxiliary notes as needed.\n     ///\n+    /// The names are memoized, so this is both cheap to recompute and idempotent.\n+    ///\n     /// Example (function arguments):\n     ///\n     /// Suppose we are trying to give a name to the lifetime of the\n@@ -184,28 +156,28 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// ```\n     ///\n     /// and then return the name `'1` for us to use.\n-    crate fn give_region_a_name(\n-        &self,\n-        renctx: &mut RegionErrorNamingCtx,\n-        fr: RegionVid,\n-    ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n+    crate fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n+        debug!(\n+            \"give_region_a_name(fr={:?}, counter={:?})\",\n+            fr,\n+            self.next_region_name.try_borrow().unwrap()\n+        );\n \n         assert!(self.regioncx.universal_regions().is_universal_region(fr));\n \n-        if let Some(value) = renctx.get(&fr) {\n+        if let Some(value) = self.region_names.try_borrow_mut().unwrap().get(&fr) {\n             return Some(value.clone());\n         }\n \n         let value = self\n-            .give_name_from_error_region(fr, renctx)\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr, renctx));\n+            .give_name_from_error_region(fr)\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr));\n \n         if let Some(ref value) = value {\n-            renctx.insert(fr, value.clone());\n+            self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n \n         debug!(\"give_region_a_name: gave name {:?}\", value);\n@@ -216,11 +188,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n-    fn give_name_from_error_region(\n-        &self,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n+    fn give_name_from_error_region(&self, fr: RegionVid) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n         let tcx = self.infcx.tcx;\n@@ -262,7 +230,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         // happen if we have an elided name in an async fn for example: the\n                         // compiler will generate a region named `'_`, but reporting such a name is\n                         // not actually useful, so we synthesize a name for it instead.\n-                        let name = renctx.synthesize_region_name();\n+                        let name = self.synthesize_region_name();\n                         Some(RegionName {\n                             name,\n                             source: RegionNameSource::AnonRegionFromAsyncFn(span),\n@@ -287,7 +255,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -342,28 +310,26 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.regioncx.universal_regions().defining_ty.implicit_inputs();\n         let argument_index = self.regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n \n         let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n             [implicit_inputs + argument_index];\n         if let Some(region_name) =\n-            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index, renctx)\n+            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index)\n         {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n@@ -376,12 +342,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             // (`give_name_if_anonymous_region_appears_in_arguments`).\n             hir::TyKind::Infer => None,\n \n-            _ => self.give_name_if_we_can_match_hir_ty(\n-                needle_fr,\n-                argument_ty,\n-                argument_hir_ty,\n-                renctx,\n-            ),\n+            _ => self.give_name_if_we_can_match_hir_ty(needle_fr, argument_ty, argument_hir_ty),\n         }\n     }\n \n@@ -400,9 +361,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         &self,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let counter = renctx.counter;\n+        let counter = *self.next_region_name.try_borrow().unwrap();\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n@@ -425,7 +385,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: renctx.synthesize_region_name(),\n+                name: self.synthesize_region_name(),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -461,7 +421,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty<'_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -479,7 +438,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n@@ -512,7 +471,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                                     substs,\n                                     needle_fr,\n                                     last_segment,\n-                                    renctx,\n                                     search_stack,\n                                 ) {\n                                     return Some(name);\n@@ -557,7 +515,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment<'hir>,\n-        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n@@ -569,7 +526,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = renctx.synthesize_region_name();\n+                let region_name = self.synthesize_region_name();\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -650,18 +607,14 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  | let x = Some(&22);\n     ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n     /// ```\n-    fn give_name_if_anonymous_region_appears_in_upvars(\n-        &self,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n+    fn give_name_if_anonymous_region_appears_in_upvars(&self, fr: RegionVid) -> Option<RegionName> {\n         let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n         let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n             self.infcx.tcx,\n             &self.upvars,\n             upvar_index,\n         );\n-        let region_name = renctx.synthesize_region_name();\n+        let region_name = self.synthesize_region_name();\n \n         Some(RegionName {\n             name: region_name,\n@@ -673,11 +626,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n-    fn give_name_if_anonymous_region_appears_in_output(\n-        &self,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n+    fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n@@ -687,7 +636,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n@@ -714,7 +663,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n@@ -726,7 +675,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n@@ -740,7 +688,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n@@ -759,7 +707,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         );\n \n         Some(RegionName {\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }"}, {"sha": "90927069242b19e2cf032b2891558178fc642d28", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -11,7 +11,8 @@ use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n@@ -21,6 +22,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use smallvec::SmallVec;\n+use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n@@ -39,7 +41,7 @@ use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n-use self::diagnostics::AccessKind;\n+use self::diagnostics::{AccessKind, RegionName};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -290,6 +292,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         dominators,\n         upvars,\n         local_names,\n+        region_names: RefCell::default(),\n+        next_region_name: RefCell::new(1),\n     };\n \n     // Compute and report region errors, if any.\n@@ -489,6 +493,13 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n     local_names: IndexVec<Local, Option<Name>>,\n+\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    region_names: RefCell<FxHashMap<RegionVid, RegionName>>,\n+\n+    /// The counter for generating new region names.\n+    next_region_name: RefCell<usize>,\n }\n \n // Check that:"}, {"sha": "180bb95cab9f4754a4f33e7eb45d3c86b6e802fa", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -1603,23 +1603,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Get the region outlived by `longer_fr` and live at `element`.\n-    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n-        match element {\n-            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n-            RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self\n-                .definitions\n-                .iter_enumerated()\n-                .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n-                    _ => None,\n-                })\n-                .next()\n-                .unwrap(),\n-        }\n-    }\n-\n     /// We have a constraint `fr1: fr2` that is not satisfied, where\n     /// `fr2` represents some universal region. Here, `r` is some\n     /// region where we know that `fr1: r` and this function has the"}, {"sha": "89107e799bd2207c4f26a4f62e38ceb0cf27c35a", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a804868bbf578dada5249ac3c79b7b524684c78e/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=a804868bbf578dada5249ac3c79b7b524684c78e", "patch": "@@ -87,12 +87,12 @@ error[E0597]: `ap1` does not live long enough\n   --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                                    - let's call the lifetime of this reference `'1`\n+   |                                                    - let's call the lifetime of this reference `'3`\n LL |     ap0 = &mut ap1;\n    |     ------^^^^^^^^\n    |     |     |\n    |     |     borrowed value does not live long enough\n-   |     assignment requires that `ap1` is borrowed for `'1`\n+   |     assignment requires that `ap1` is borrowed for `'3`\n ...\n LL | }\n    | - `ap1` dropped here while still borrowed"}]}