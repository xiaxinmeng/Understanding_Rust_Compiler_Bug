{"sha": "e4edfa046af08a345c607ec9c80426d9eabc7c82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZWRmYTA0NmFmMDhhMzQ1YzYwN2VjOWM4MDQyNmQ5ZWFiYzdjODI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-02-23T06:46:04Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-03T00:36:05Z"}, "message": "libstd: implement fileinput.\n\nIterate over lines in a series of files. API (mostly) adopted from\nPython's fileinput module.", "tree": {"sha": "c9247d8c101c0dab1cdd062af28de43eb90f1e93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9247d8c101c0dab1cdd062af28de43eb90f1e93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4edfa046af08a345c607ec9c80426d9eabc7c82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4edfa046af08a345c607ec9c80426d9eabc7c82", "html_url": "https://github.com/rust-lang/rust/commit/e4edfa046af08a345c607ec9c80426d9eabc7c82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4edfa046af08a345c607ec9c80426d9eabc7c82/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "html_url": "https://github.com/rust-lang/rust/commit/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346"}], "stats": {"total": 465, "additions": 465, "deletions": 0}, "files": [{"sha": "3f281150331d61585851bc1fa9388d56049d444a", "filename": "src/libstd/fileinput.rs", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/e4edfa046af08a345c607ec9c80426d9eabc7c82/src%2Flibstd%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4edfa046af08a345c607ec9c80426d9eabc7c82/src%2Flibstd%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffileinput.rs?ref=e4edfa046af08a345c607ec9c80426d9eabc7c82", "patch": "@@ -0,0 +1,464 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+A convience device for iterating through the lines in a series of\n+files. Very similar to [the Python module of the same\n+name](http://docs.python.org/3.3/library/fileinput.html).\n+\n+It allows the programmer to automatically take filenames from the\n+command line arguments (via `input` and `input_state`), as well as\n+specify them as a vector directly (`input_vec` and\n+`input_vec_state`). The files are opened as necessary, so any files\n+that can't be opened only cause an error when reached in the\n+iteration.\n+\n+On the command line, `stdin` is represented by a filename of `-` (a\n+single hyphen) and in the functions that take a vector directly\n+(e.g. `input_vec`) it is represented by `None`. Note `stdin` is *not*\n+reset once it has been finished, so attempting to iterate on `[None,\n+None]` will only take input once unless `io::stdin().seek(0, SeekSet)`\n+is called between.\n+\n+The `pathify` function handles converting a list of file paths as\n+strings to the appropriate format, including the (optional) conversion\n+of `\"-\"` to `stdin`.\n+\n+# Basic\n+\n+In many cases, one can use the `input_*` functions without having\n+to handle any `FileInput` structs. E.g. a simple `cat` program\n+\n+    for input |line| {\n+        io::println(line)\n+    }\n+\n+or a program that numbers lines after concatenating two files\n+\n+    for input_vec_state(pathify([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n+        io::println(fmt!(\"%u: %s\", state.line_num,\n+                                   line));\n+    }\n+\n+The 2 `_vec` functions take a vec of file names (and empty means\n+read from `stdin`), the other 2 use the command line arguments.\n+\n+# Advanced\n+\n+For more complicated uses (e.g. if one needs to pause iteration and\n+resume it later), a `FileInput` instance can be constructed via the\n+`from_vec`, `from_vec_raw` and `from_args` functions.\n+\n+Once created, the `lines_each` and `lines_each_state` methods\n+allow one to iterate on the lines (the latter provides more\n+information about the position within the iteration to the caller.\n+\n+It is possible (and safe) to skip lines and files using the\n+`read_line` and `next_file` methods.\n+\n+E.g. the following (pointless) program reads until an empty line,\n+pauses for user input, skips the current file and then numbers the\n+remaining lines (where the numbers are from the start of the file,\n+rather than the total line count).\n+\n+    let mut in = FileInput::from_vec(pathify([~\"a.txt\", ~\"b.txt\", ~\"c.txt\"],\n+                                             true));\n+\n+    for in.lines_each |line| {\n+        if line.is_empty() {\n+            break\n+        }\n+        io::println(line);\n+    }\n+\n+    io::println(\"Continue?\");\n+\n+    if io::stdin().read_line() == ~\"yes\" {\n+        in.next_file(); // skip!\n+\n+        for in.lines_each_state |line, state| {\n+           io::println(fmt!(\"%u: %s\", state.line_num_file,\n+                                      line))\n+        }\n+    }\n+*/\n+\n+use core::prelude::*;\n+use core::io::ReaderUtil;\n+\n+/**\n+A summary of the internal state of a FileInput object. `line_num` and\n+`line_num_file` represent the number of lines read in total and in the\n+current file respectively.\n+*/\n+pub struct FileInputState {\n+    current_path: Option<Path>,\n+    line_num: uint,\n+    line_num_file: uint\n+}\n+\n+impl FileInputState {\n+    fn is_stdin(&self) -> bool {\n+        self.current_path.is_none()\n+    }\n+\n+    fn is_first_line(&self) -> bool {\n+        self.line_num_file == 1\n+    }\n+}\n+\n+priv struct FileInput {\n+    /**\n+    `Some(path)` is the file represented by `path`, `None` is\n+    `stdin`. Consumed as the files are read.\n+    */\n+    files: ~[Option<Path>],\n+    /**\n+    The current file: `Some(r)` for an open file, `None` before\n+    starting and after reading everything.\n+    */\n+    current_reader: Option<@io::Reader>,\n+    state: FileInputState\n+}\n+\n+impl FileInput {\n+    /**\n+    Create a `FileInput` object from a vec of files. An empty\n+    vec means lines are read from `stdin` (use `from_vec_raw` to stop\n+    this behaviour). Any occurence of `None` represents `stdin`.\n+    */\n+    static pure fn from_vec(files: ~[Option<Path>]) -> FileInput {\n+        FileInput::from_vec_raw(\n+            if files.is_empty() {\n+                ~[None]\n+            } else {\n+                files\n+            })\n+    }\n+\n+    /**\n+    Identical to `from_vec`, but an empty `files` vec stays\n+    empty. (`None` is `stdin`.)\n+    */\n+    static pure fn from_vec_raw(files: ~[Option<Path>])\n+                                         -> FileInput {\n+        FileInput {\n+            files: files,\n+            current_reader: None,\n+            state: FileInputState {\n+                current_path: None,\n+                line_num: 0,\n+                line_num_file: 0\n+            }\n+        }\n+    }\n+\n+    /**\n+    Create a `FileInput` object from the command line\n+    arguments. `-` represents `stdin`.\n+    */\n+    static fn from_args() -> FileInput {\n+        let args = os::args(),\n+            pathed = pathify(args.tail(), true);\n+        FileInput::from_vec(pathed)\n+    }\n+\n+    priv fn current_file_eof(&self) -> bool {\n+        match self.current_reader {\n+            None => false,\n+            Some(r) => r.eof()\n+        }\n+    }\n+\n+    /**\n+    Skip to the next file in the queue. Can `fail` when opening\n+    a file.\n+    */\n+    pub fn next_file(&mut self) {\n+        // No more files\n+        if self.files.is_empty() {\n+            self.current_reader = None;\n+            return;\n+        }\n+\n+        let path_option = self.files.shift(),\n+            file = match path_option {\n+                None => io::stdin(),\n+                Some(ref path) => io::file_reader(path).get()\n+            };\n+\n+        self.current_reader = Some(file);\n+        self.state.current_path = path_option;\n+        self.state.line_num_file = 0;\n+    }\n+\n+    /**\n+    Attempt to open the next file if there is none currently open,\n+    or if the current one is EOF'd.\n+    */\n+    priv fn next_file_if_eof(&mut self) {\n+        match self.current_reader {\n+            None => self.next_file(),\n+            Some(r) => {\n+                if r.eof() {\n+                    self.next_file()\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+    Read a single line. Returns `None` if there are no remaining lines\n+    in any remaining file. (Automatically opens files as required, see\n+    `next_file` for details.)\n+\n+    (Name to avoid conflicting with `core::io::ReaderUtil::read_line`.)\n+    */\n+    pub fn next_line(&mut self) -> Option<~str> {\n+        loop {\n+            // iterate until there is a file that can be read from\n+            self.next_file_if_eof();\n+            match self.current_reader {\n+                None => {\n+                    // no file has any content\n+                    return None;\n+                },\n+                Some(r) => {\n+                    let l = r.read_line();\n+\n+                    // at the end of this file, and we read nothing, so\n+                    // go to the next file\n+                    if r.eof() && l.is_empty() {\n+                        loop;\n+                    }\n+                    self.state.line_num += 1;\n+                    self.state.line_num_file += 1;\n+                    return Some(l);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+    Call `f` on the lines in the files in succession, stopping if\n+    it ever returns `false`.\n+\n+    State is preserved across calls.\n+\n+    (The name is to avoid conflict with\n+    `core::io::ReaderUtil::each_line`.)\n+    */\n+    pub fn lines_each(&mut self, f: &fn(~str) -> bool) {\n+        loop {\n+            match self.next_line() {\n+                None => break,\n+                Some(line) => {\n+                    if !f(line) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+    Apply `f` to each line successively, along with some state\n+    (line numbers and file names, see documentation for\n+    `FileInputState`). Otherwise identical to `lines_each`.\n+    */\n+    pub fn lines_each_state(&mut self,\n+                            f: &fn(~str, &FileInputState) -> bool) {\n+        loop {\n+            match self.next_line() {\n+                None => break,\n+                Some(line) => {\n+                    if !f(line, &self.state) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/**\n+Convert a list of strings to an appropriate form for a `FileInput`\n+instance. `stdin_hyphen` controls whether `-` represents `stdin` or\n+not.\n+*/\n+// XXX: stupid, unclear name\n+pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n+    vec::map(vec, |&str : & ~str| {\n+        if stdin_hyphen && str == ~\"-\" {\n+            None\n+        } else {\n+            Some(Path(str))\n+        }\n+    })\n+}\n+\n+/**\n+Iterate directly over the command line arguments (no arguments implies\n+reading from `stdin`).\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+pub fn input(f: &fn(~str) -> bool) {\n+    let mut i = FileInput::from_args();\n+    i.lines_each(f);\n+}\n+\n+/**\n+Iterate directly over the command line arguments (no arguments\n+implies reading from `stdin`) with the current state of the iteration\n+provided at each call.\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+pub fn input_state(f: &fn(~str, &FileInputState) -> bool) {\n+    let mut i = FileInput::from_args();\n+    i.lines_each_state(f);\n+}\n+\n+/**\n+Iterate over a vec of files (an empty vec implies just `stdin`).\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+pub fn input_vec(files: ~[Option<Path>], f: &fn(~str) -> bool) {\n+    let mut i = FileInput::from_vec(files);\n+    i.lines_each(f);\n+}\n+\n+/**\n+Iterate over a vec of files (an empty vec implies just `stdin`) with\n+the current state of the iteration provided at each call.\n+\n+Fails when attempting to read from a file that can't be opened.\n+*/\n+pub fn input_vec_state(files: ~[Option<Path>],\n+                       f: &fn(~str, &FileInputState) -> bool) {\n+    let mut i = FileInput::from_vec(files);\n+    i.lines_each_state(f);\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use core::io::WriterUtil;\n+    use core::prelude::*;\n+    use super::{FileInput, pathify, input_vec, input_vec_state};\n+\n+    fn make_file(path : &Path, contents: &[~str]) {\n+        let file = io::file_writer(path, [io::Create, io::Truncate]).get();\n+\n+        for contents.each |&str| {\n+            file.write_str(str);\n+            file.write_char('\\n');\n+        }\n+    }\n+\n+    #[test]\n+    fn test_pathify() {\n+        let strs = [~\"some/path\",\n+                    ~\"some/other/path\"],\n+            paths = ~[Some(Path(\"some/path\")),\n+                      Some(Path(\"some/other/path\"))];\n+\n+        fail_unless!(pathify(strs, true) == paths);\n+        fail_unless!(pathify(strs, false) == paths);\n+\n+        fail_unless!(pathify([~\"-\"], true) == ~[None]);\n+        fail_unless!(pathify([~\"-\"], false) == ~[Some(Path(\"-\"))]);\n+    }\n+\n+    #[test]\n+    fn test_input_vec() {\n+        let mut all_lines = ~[];\n+        let filenames = pathify(vec::from_fn(\n+            3,\n+            |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n+\n+        for filenames.eachi |i, &filename| {\n+            let contents =\n+                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n+            make_file(&filename.get(), contents);\n+            all_lines.push_all(contents);\n+        }\n+\n+        let mut read_lines = ~[];\n+        for input_vec(filenames) |line| {\n+            read_lines.push(line);\n+        }\n+        fail_unless!(read_lines == all_lines);\n+    }\n+\n+    #[test]\n+    fn test_input_vec_state() {\n+        let filenames = pathify(vec::from_fn(\n+            3,\n+            |i|\n+            fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n+\n+        for filenames.eachi |i, &filename| {\n+            let contents =\n+                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+            make_file(&filename.get(), contents);\n+        }\n+\n+        for input_vec_state(filenames) |line, state| {\n+            let nums = str::split_char(line, ' ');\n+\n+            let file_num = uint::from_str(nums[0]).get();\n+            let line_num = uint::from_str(nums[1]).get();\n+\n+            fail_unless!(line_num == state.line_num_file);\n+            fail_unless!(file_num * 3 + line_num == state.line_num);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_next_file() {\n+        let filenames = pathify(vec::from_fn(\n+            3,\n+            |i|\n+            fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n+\n+        for filenames.eachi |i, &filename| {\n+            let contents =\n+                vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n+            make_file(&filename.get(), contents);\n+        }\n+\n+        let mut in = FileInput::from_vec(filenames);\n+\n+        // read once from 0\n+        fail_unless!(in.next_line() == Some(~\"0 1\"));\n+        in.next_file(); // skip the rest of 1\n+\n+        // read all lines from 1 (but don't read any from 2),\n+        for uint::range(1, 4) |i| {\n+            fail_unless!(in.next_line() == Some(fmt!(\"1 %u\", i)));\n+        }\n+        // 1 is finished, but 2 hasn't been started yet, so this will\n+        // just \"skip\" to the beginning of 2 (Python's fileinput does\n+        // the same)\n+        in.next_file();\n+\n+        fail_unless!(in.next_line() == Some(~\"2 1\"));\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_input_vec_missing_file() {\n+        for input_vec(pathify([~\"this/file/doesnt/exist\"], true)) |line| {\n+            io::println(line);\n+        }\n+    }\n+}"}, {"sha": "74ef229a033536e372ecc617a7dd0f9eeb7fac49", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4edfa046af08a345c607ec9c80426d9eabc7c82/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e4edfa046af08a345c607ec9c80426d9eabc7c82/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=e4edfa046af08a345c607ec9c80426d9eabc7c82", "patch": "@@ -98,6 +98,7 @@ pub mod workcache;\n pub mod bigint;\n pub mod stats;\n pub mod semver;\n+pub mod fileinput;\n \n #[cfg(unicode)]\n mod unicode;"}]}