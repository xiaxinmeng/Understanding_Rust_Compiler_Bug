{"sha": "c56bf67150ecd87b0467bd4b2bd6099c83eff65e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NmJmNjcxNTBlY2Q4N2IwNDY3YmQ0YjJiZDYwOTljODNlZmY2NWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-10-12T13:49:50Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-10-14T21:18:34Z"}, "message": "Issue 7655: align the bench printouts so that the numbers tend to be aligned.\n\n(scratching an itch.)\n\nRebased and updated.\nFixed bug: omitted field init from embedded struct literal in a test.\nFixed bug: int underflow during padding length calculation.", "tree": {"sha": "de110a221411226959c7854aa8bb5acab8234e9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de110a221411226959c7854aa8bb5acab8234e9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c56bf67150ecd87b0467bd4b2bd6099c83eff65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c56bf67150ecd87b0467bd4b2bd6099c83eff65e", "html_url": "https://github.com/rust-lang/rust/commit/c56bf67150ecd87b0467bd4b2bd6099c83eff65e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c56bf67150ecd87b0467bd4b2bd6099c83eff65e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8e77d5586aed50821e0b9361b2e24c96ade816c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e77d5586aed50821e0b9361b2e24c96ade816c", "html_url": "https://github.com/rust-lang/rust/commit/c8e77d5586aed50821e0b9361b2e24c96ade816c"}], "stats": {"total": 63, "additions": 51, "deletions": 12}, "files": [{"sha": "991be1b2d302e14db592825a4b3fdb1ac89c2b98", "filename": "src/libextra/test.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c56bf67150ecd87b0467bd4b2bd6099c83eff65e/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56bf67150ecd87b0467bd4b2bd6099c83eff65e/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=c56bf67150ecd87b0467bd4b2bd6099c83eff65e", "patch": "@@ -57,6 +57,23 @@ impl ToStr for TestName {\n     }\n }\n \n+#[deriving(Clone)]\n+enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n+\n+impl TestDesc {\n+    fn padded_name(&self, column_count: uint, align: NamePadding) -> ~str {\n+        use std::num::Saturating;\n+        let name = self.name.to_str();\n+        let fill = column_count.saturating_sub(name.len());\n+        let pad = \" \".repeat(fill);\n+        match align {\n+            PadNone => name,\n+            PadOnLeft => pad.append(name),\n+            PadOnRight => name.append(pad),\n+        }\n+    }\n+}\n+\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n@@ -70,6 +87,19 @@ pub enum TestFn {\n     DynBenchFn(~fn(&mut BenchHarness))\n }\n \n+impl TestFn {\n+    fn padding(&self) -> NamePadding {\n+        match self {\n+            &StaticTestFn(*)   => PadNone,\n+            &StaticBenchFn(*)  => PadOnRight,\n+            &StaticMetricFn(*) => PadOnRight,\n+            &DynTestFn(*)      => PadNone,\n+            &DynMetricFn(*)    => PadOnRight,\n+            &DynBenchFn(*)     => PadOnRight,\n+        }\n+    }\n+}\n+\n // Structure passed to BenchFns\n pub struct BenchHarness {\n     iterations: u64,\n@@ -316,7 +346,8 @@ struct ConsoleTestState {\n     ignored: uint,\n     measured: uint,\n     metrics: MetricMap,\n-    failures: ~[TestDesc]\n+    failures: ~[TestDesc],\n+    max_name_len: uint, // number of columns to fill when aligning names\n }\n \n impl ConsoleTestState {\n@@ -348,7 +379,8 @@ impl ConsoleTestState {\n             ignored: 0u,\n             measured: 0u,\n             metrics: MetricMap::new(),\n-            failures: ~[]\n+            failures: ~[],\n+            max_name_len: 0u,\n         }\n     }\n \n@@ -411,8 +443,9 @@ impl ConsoleTestState {\n         self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n     }\n \n-    pub fn write_test_start(&self, test: &TestDesc) {\n-        self.out.write_str(format!(\"test {} ... \", test.name.to_str()));\n+    pub fn write_test_start(&self, test: &TestDesc, align: NamePadding) {\n+        let name = test.padded_name(self.max_name_len, align);\n+        self.out.write_str(format!(\"test {} ... \", name));\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -559,12 +592,12 @@ pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n \n pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n     if bs.mb_s != 0 {\n-        format!(\"{} ns/iter (+/- {}) = {} MB/s\",\n+        format!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        format!(\"{} ns/iter (+/- {})\",\n+        format!(\"{:>9} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -577,7 +610,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         debug2!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n-            TeWait(ref test) => st.write_test_start(test),\n+            TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result) => {\n                 st.write_log(&test, &result);\n                 st.write_result(&result);\n@@ -607,6 +640,11 @@ pub fn run_tests_console(opts: &TestOpts,\n         }\n     }\n     let st = @mut ConsoleTestState::new(opts);\n+    match tests.iter().map(|t| t.desc.name.to_str().len()).max() {\n+        Some(l) => { st.max_name_len = l; },\n+        None => {}\n+    }\n+    debug2!(\"tests max_name_len: {}\", st.max_name_len);\n     run_tests(opts, tests, |x| callback(&x, st));\n     match opts.save_metrics {\n         None => (),\n@@ -646,7 +684,8 @@ fn should_sort_failures_before_printing_them() {\n             ignored: 0u,\n             measured: 0u,\n             metrics: MetricMap::new(),\n-            failures: ~[test_b, test_a]\n+            failures: ~[test_b, test_a],\n+            max_name_len: 0u,\n         };\n \n         st.write_failures();\n@@ -662,7 +701,7 @@ fn use_color() -> bool { return get_concurrency() == 1; }\n #[deriving(Clone)]\n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n-    TeWait(TestDesc),\n+    TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult),\n }\n \n@@ -704,15 +743,15 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(test.desc.clone()));\n+                callback(TeWait(test.desc.clone(), test.testfn.padding()));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(desc.clone()));\n+            callback(TeWait(desc.clone(), PadNone));\n         }\n         callback(TeResult(desc, result));\n         pending -= 1;\n@@ -721,7 +760,7 @@ fn run_tests(opts: &TestOpts,\n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n-        callback(TeWait(b.desc.clone()));\n+        callback(TeWait(b.desc.clone(), b.testfn.padding()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n         callback(TeResult(test, result));"}]}