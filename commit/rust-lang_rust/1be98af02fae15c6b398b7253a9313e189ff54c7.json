{"sha": "1be98af02fae15c6b398b7253a9313e189ff54c7", "node_id": "C_kwDOAAsO6NoAKDFiZTk4YWYwMmZhZTE1YzZiMzk4YjcyNTNhOTMxM2UxODlmZjU0Yzc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-08T15:08:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-08T15:08:09Z"}, "message": "Rollup merge of #91571 - dtolnay:printerderef, r=Mark-Simulacrum\n\nRemove unneeded access to pretty printer's `s` field in favor of deref\n\nI found it taxing in some of my recent PRs touching the pretty printer to maintain consistency with the surrounding code, since the current code is all over the place about whether it uses `self.s.\u2026()` or `self.\u2026()` for invoking methods of `rustc_ast_pretty::pp::Printer`.\n\nThis PR standardizes on `self.\u2026()` &mdash; relying on the `Deref` and `DerefMut` impls introduced by [#62532](https://github.com/rust-lang/rust/pull/62532/commits/cab453250a3ceae5cf0cf7eac836c03b37e4ca8e).", "tree": {"sha": "e78c30fc5ac546e542017bc853ea77741b136c95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e78c30fc5ac546e542017bc853ea77741b136c95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be98af02fae15c6b398b7253a9313e189ff54c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhsMpaCRBK7hj4Ov3rIwAAufEIAJM8N+Go70jcN/ucAItDkBnH\n5vwK6pfA05QH1h/K3KgqkvHxAmZsJhXYVjRInGWbpAzX+Dt29We1XnrZRrTz1JyQ\n2moH/kZYOi1WgKu/+EGAPpHrPCgUJZynWSOU6cvLPcxxRdbHDuprA+hvkXETUxjF\nztAeJHKmSrV0cStPWeIwBDee76YeWsYo87z6Xqhimyx0jHZF4wAFZl1JA67wwMPQ\nRVH8EYspz1wiPvpJnnK/+bE1d/sUCglctb0PdY3973TgR//fGNqYJx+HdS0camtQ\nn3ZfO8iklLexseSk4qMjrQUXrQrW+jwdIcJvPnPg4ie0Sf6R8OcfG3s32ft8Efw=\n=QLVA\n-----END PGP SIGNATURE-----\n", "payload": "tree e78c30fc5ac546e542017bc853ea77741b136c95\nparent 67c58327fc6c15ad7e8e15a05c8ff2314cd7ca96\nparent a79b702956e24aca5857a0630e9ff4f2e257a713\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638976089 +0100\ncommitter GitHub <noreply@github.com> 1638976089 +0100\n\nRollup merge of #91571 - dtolnay:printerderef, r=Mark-Simulacrum\n\nRemove unneeded access to pretty printer's `s` field in favor of deref\n\nI found it taxing in some of my recent PRs touching the pretty printer to maintain consistency with the surrounding code, since the current code is all over the place about whether it uses `self.s.\u2026()` or `self.\u2026()` for invoking methods of `rustc_ast_pretty::pp::Printer`.\n\nThis PR standardizes on `self.\u2026()` &mdash; relying on the `Deref` and `DerefMut` impls introduced by [#62532](https://github.com/rust-lang/rust/pull/62532/commits/cab453250a3ceae5cf0cf7eac836c03b37e4ca8e).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be98af02fae15c6b398b7253a9313e189ff54c7", "html_url": "https://github.com/rust-lang/rust/commit/1be98af02fae15c6b398b7253a9313e189ff54c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be98af02fae15c6b398b7253a9313e189ff54c7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67c58327fc6c15ad7e8e15a05c8ff2314cd7ca96", "url": "https://api.github.com/repos/rust-lang/rust/commits/67c58327fc6c15ad7e8e15a05c8ff2314cd7ca96", "html_url": "https://github.com/rust-lang/rust/commit/67c58327fc6c15ad7e8e15a05c8ff2314cd7ca96"}, {"sha": "a79b702956e24aca5857a0630e9ff4f2e257a713", "url": "https://api.github.com/repos/rust-lang/rust/commits/a79b702956e24aca5857a0630e9ff4f2e257a713", "html_url": "https://github.com/rust-lang/rust/commit/a79b702956e24aca5857a0630e9ff4f2e257a713"}], "stats": {"total": 684, "additions": 342, "deletions": 342}, "files": [{"sha": "74f2a2b2e09d613511909b34c53b758d4cc197bf", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 165, "deletions": 165, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/1be98af02fae15c6b398b7253a9313e189ff54c7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be98af02fae15c6b398b7253a9313e189ff54c7/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=1be98af02fae15c6b398b7253a9313e189ff54c7", "patch": "@@ -878,29 +878,29 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: Ident) {\n-        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n+        self.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool) {\n         if colons_before_params {\n-            self.s.word(\"::\")\n+            self.word(\"::\")\n         }\n \n         match *args {\n             ast::GenericArgs::AngleBracketed(ref data) => {\n-                self.s.word(\"<\");\n+                self.word(\"<\");\n                 self.commasep(Inconsistent, &data.args, |s, arg| match arg {\n                     ast::AngleBracketedArg::Arg(a) => s.print_generic_arg(a),\n                     ast::AngleBracketedArg::Constraint(c) => s.print_assoc_constraint(c),\n                 });\n-                self.s.word(\">\")\n+                self.word(\">\")\n             }\n \n             ast::GenericArgs::Parenthesized(ref data) => {\n-                self.s.word(\"(\");\n+                self.word(\"(\");\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n-                self.s.word(\")\");\n+                self.word(\")\");\n                 self.print_fn_ret_ty(&data.output);\n             }\n         }\n@@ -925,7 +925,7 @@ impl<'a> State<'a> {\n             op(self, elt);\n             i += 1;\n             if i < len {\n-                self.s.word(\",\");\n+                self.word(\",\");\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi()));\n                 self.space_if_not_bol();\n             }\n@@ -954,7 +954,7 @@ impl<'a> State<'a> {\n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n         self.print_ident(constraint.ident);\n         constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n-        self.s.space();\n+        self.space();\n         match &constraint.kind {\n             ast::AssocTyConstraintKind::Equality { ty } => {\n                 self.word_space(\"=\");\n@@ -979,27 +979,27 @@ impl<'a> State<'a> {\n         self.ibox(0);\n         match ty.kind {\n             ast::TyKind::Slice(ref ty) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(ty);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::TyKind::Ptr(ref mt) => {\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n-                self.s.word(\"!\");\n+                self.word(\"!\");\n             }\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n@@ -1023,33 +1023,33 @@ impl<'a> State<'a> {\n                 self.print_type_bounds(\"impl\", &bounds[..]);\n             }\n             ast::TyKind::Array(ref ty, ref length) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(ty);\n-                self.s.word(\"; \");\n+                self.word(\"; \");\n                 self.print_expr(&length.value);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::TyKind::Typeof(ref e) => {\n-                self.s.word(\"typeof(\");\n+                self.word(\"typeof(\");\n                 self.print_expr(&e.value);\n-                self.s.word(\")\");\n+                self.word(\")\");\n             }\n             ast::TyKind::Infer => {\n-                self.s.word(\"_\");\n+                self.word(\"_\");\n             }\n             ast::TyKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n             ast::TyKind::ImplicitSelf => {\n-                self.s.word(\"Self\");\n+                self.word(\"Self\");\n             }\n             ast::TyKind::MacCall(ref m) => {\n                 self.print_mac(m);\n             }\n             ast::TyKind::CVarArgs => {\n-                self.s.word(\"...\");\n+                self.word(\"...\");\n             }\n         }\n         self.end();\n@@ -1087,7 +1087,7 @@ impl<'a> State<'a> {\n             ast::ForeignItemKind::MacCall(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1115,13 +1115,13 @@ impl<'a> State<'a> {\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n-        self.s.space();\n+        self.space();\n         self.end(); // end the head-ibox\n         if let Some(body) = body {\n             self.word_space(\"=\");\n             self.print_expr(body);\n         }\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end the outer cbox\n     }\n \n@@ -1143,11 +1143,11 @@ impl<'a> State<'a> {\n         self.print_type_bounds(\":\", bounds);\n         self.print_where_clause(&generics.where_clause);\n         if let Some(ty) = ty {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_type(ty);\n         }\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end inner head-block\n         self.end(); // end outer head-block\n     }\n@@ -1163,19 +1163,19 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n-                    self.s.space();\n-                    self.s.word(\"as\");\n-                    self.s.space();\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n                 }\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n             ast::ItemKind::Use(ref tree) => {\n                 self.head(visibility_qualified(&item.vis, \"use\"));\n                 self.print_use_tree(tree);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n@@ -1218,7 +1218,7 @@ impl<'a> State<'a> {\n                         self.bclose(item.span, empty);\n                     }\n                     ModKind::Unloaded => {\n-                        self.s.word(\";\");\n+                        self.word(\";\");\n                         self.end(); // end inner head-block\n                         self.end(); // end outer head-block\n                     }\n@@ -1289,23 +1289,23 @@ impl<'a> State<'a> {\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n-                    self.s.space();\n+                    self.space();\n                 }\n \n                 if let ast::ImplPolarity::Negative(_) = polarity {\n-                    self.s.word(\"!\");\n+                    self.word(\"!\");\n                 }\n \n                 if let Some(ref t) = *of_trait {\n                     self.print_trait_ref(t);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"for\");\n                 }\n \n                 self.print_type(self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n                 for impl_item in items {\n@@ -1332,7 +1332,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -1341,7 +1341,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_type_bounds(\":\", &real_bounds[..]);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n                 for trait_item in items {\n@@ -1360,7 +1360,7 @@ impl<'a> State<'a> {\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -1370,12 +1370,12 @@ impl<'a> State<'a> {\n                 self.nbsp();\n                 self.print_type_bounds(\"=\", &real_bounds[..]);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::ItemKind::MacCall(ref mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n@@ -1393,7 +1393,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n@@ -1416,7 +1416,7 @@ impl<'a> State<'a> {\n         self.print_ident(ident);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -1428,7 +1428,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n-            self.s.word(\",\");\n+            self.word(\",\");\n             self.end();\n             self.maybe_print_trailing_comment(v.span, None);\n         }\n@@ -1477,7 +1477,7 @@ impl<'a> State<'a> {\n                 self.print_ident(field.ident.unwrap());\n                 self.word_nbsp(\":\");\n                 self.print_type(&field.ty);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n \n@@ -1508,7 +1508,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 if print_finalizer {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n                 self.end();\n                 self.end(); // Close the outer-box.\n@@ -1526,7 +1526,7 @@ impl<'a> State<'a> {\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_expr(&d.value)\n         }\n@@ -1558,7 +1558,7 @@ impl<'a> State<'a> {\n             ast::AssocItemKind::MacCall(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1584,36 +1584,36 @@ impl<'a> State<'a> {\n                     if let Some(els) = els {\n                         self.cbox(INDENT_UNIT);\n                         self.ibox(INDENT_UNIT);\n-                        self.s.word(\" else \");\n+                        self.word(\" else \");\n                         self.print_block(els);\n                     }\n                 }\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // `let` ibox\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(item),\n             ast::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n                 if classify::expr_requires_semi_to_be_stmt(expr) {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr_outer_attr_style(expr, false);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::StmtKind::Empty => {\n                 self.space_if_not_bol();\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             ast::StmtKind::MacCall(ref mac) => {\n                 self.space_if_not_bol();\n                 self.print_outer_attributes(&mac.attrs);\n                 self.print_mac(&mac.mac);\n                 if mac.style == ast::MacStmtStyle::Semicolon {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n             }\n         }\n@@ -1667,9 +1667,9 @@ impl<'a> State<'a> {\n \n     /// Print a `let pat = expr` expression.\n     crate fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n-        self.s.word(\"let \");\n+        self.word(\"let \");\n         self.print_pat(pat);\n-        self.s.space();\n+        self.space();\n         self.word_space(\"=\");\n         let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n@@ -1682,17 +1682,17 @@ impl<'a> State<'a> {\n                 ast::ExprKind::If(ref i, ref then, ref e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else if \");\n+                    self.word(\" else if \");\n                     self.print_expr_as_cond(i);\n-                    self.s.space();\n+                    self.space();\n                     self.print_block(then);\n                     self.print_else(e.as_deref())\n                 }\n                 // Final `else` block.\n                 ast::ExprKind::Block(ref b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else \");\n+                    self.word(\" else \");\n                     self.print_block(b)\n                 }\n                 // Constraints would be great here!\n@@ -1706,7 +1706,7 @@ impl<'a> State<'a> {\n     crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block, elseopt: Option<&ast::Expr>) {\n         self.head(\"if\");\n         self.print_expr_as_cond(test);\n-        self.s.space();\n+        self.space();\n         self.print_block(blk);\n         self.print_else(elseopt)\n     }\n@@ -1763,26 +1763,26 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end();\n     }\n \n     fn print_expr_anon_const(&mut self, expr: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"const\");\n+        self.word(\"const\");\n         self.print_expr(&expr.value);\n         self.end();\n     }\n \n     fn print_expr_repeat(&mut self, element: &ast::Expr, count: &ast::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n         self.print_expr(&count.value);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end();\n     }\n \n@@ -1798,7 +1798,7 @@ impl<'a> State<'a> {\n         } else {\n             self.print_path(path, true, 0);\n         }\n-        self.s.word(\"{\");\n+        self.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n             fields,\n@@ -1818,26 +1818,26 @@ impl<'a> State<'a> {\n             ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n-                    self.s.word(\",\");\n-                    self.s.space();\n+                    self.word(\",\");\n+                    self.space();\n                 }\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n                 if let ast::StructRest::Base(ref expr) = *rest {\n                     self.print_expr(expr);\n                 }\n                 self.end();\n             }\n-            ast::StructRest::None if !fields.is_empty() => self.s.word(\",\"),\n+            ast::StructRest::None if !fields.is_empty() => self.word(\",\"),\n             _ => {}\n         }\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n-            self.s.word(\",\");\n+            self.word(\",\");\n         }\n         self.pclose()\n     }\n@@ -1855,7 +1855,7 @@ impl<'a> State<'a> {\n     fn print_expr_method_call(&mut self, segment: &ast::PathSegment, args: &[P<ast::Expr>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.s.word(\".\");\n+        self.word(\".\");\n         self.print_ident(segment.ident);\n         if let Some(ref args) = segment.args {\n             self.print_generic_args(args, true);\n@@ -1896,13 +1896,13 @@ impl<'a> State<'a> {\n         };\n \n         self.print_expr_maybe_paren(lhs, left_prec);\n-        self.s.space();\n+        self.space();\n         self.word_space(op.node.to_string());\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: ast::UnOp, expr: &ast::Expr) {\n-        self.s.word(ast::UnOp::to_string(op));\n+        self.word(ast::UnOp::to_string(op));\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1912,7 +1912,7 @@ impl<'a> State<'a> {\n         mutability: ast::Mutability,\n         expr: &ast::Expr,\n     ) {\n-        self.s.word(\"&\");\n+        self.word(\"&\");\n         match kind {\n             ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n             ast::BorrowKind::Raw => {\n@@ -1980,7 +1980,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n                 self.print_type(ty);\n             }\n@@ -2003,7 +2003,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\");\n                 self.print_expr_as_cond(test);\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_label) => {\n@@ -2013,10 +2013,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"for\");\n                 self.print_pat(pat);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"in\");\n                 self.print_expr_as_cond(iter);\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs);\n             }\n             ast::ExprKind::Loop(ref blk, opt_label) => {\n@@ -2032,7 +2032,7 @@ impl<'a> State<'a> {\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(expr);\n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs);\n                 for arm in arms {\n@@ -2054,7 +2054,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_fn_params_and_ret(decl, true);\n-                self.s.space();\n+                self.space();\n                 self.print_expr(body);\n                 self.end(); // need to close a box\n \n@@ -2084,33 +2084,33 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Await(ref expr) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".await\");\n+                self.word(\".await\");\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1);\n-                self.s.space();\n-                self.s.word(op.node.to_string());\n+                self.space();\n+                self.word(op.node.to_string());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(rhs, prec);\n             }\n             ast::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".\");\n+                self.word(\".\");\n                 self.print_ident(ident);\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_expr(index);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n                 // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n@@ -2122,41 +2122,41 @@ impl<'a> State<'a> {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 } else {\n-                    self.s.word(\"..=\");\n+                    self.word(\"..=\");\n                 }\n                 if let Some(ref e) = *end {\n                     self.print_expr_maybe_paren(e, fake_prec);\n                 }\n             }\n-            ast::ExprKind::Underscore => self.s.word(\"_\"),\n+            ast::ExprKind::Underscore => self.word(\"_\"),\n             ast::ExprKind::Path(None, ref path) => self.print_path(path, true, 0),\n             ast::ExprKind::Path(Some(ref qself), ref path) => self.print_qpath(path, qself, true),\n             ast::ExprKind::Break(opt_label, ref opt_expr) => {\n-                self.s.word(\"break\");\n-                self.s.space();\n+                self.word(\"break\");\n+                self.space();\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n             ast::ExprKind::Continue(opt_label) => {\n-                self.s.word(\"continue\");\n-                self.s.space();\n+                self.word(\"continue\");\n+                self.space();\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n-                    self.s.space()\n+                    self.space()\n                 }\n             }\n             ast::ExprKind::Ret(ref result) => {\n-                self.s.word(\"return\");\n+                self.word(\"return\");\n                 if let Some(ref expr) = *result {\n-                    self.s.word(\" \");\n+                    self.word(\" \");\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n@@ -2165,7 +2165,7 @@ impl<'a> State<'a> {\n                 self.print_inline_asm(a);\n             }\n             ast::ExprKind::LlvmInlineAsm(ref a) => {\n-                self.s.word(\"llvm_asm!\");\n+                self.word(\"llvm_asm!\");\n                 self.popen();\n                 self.print_symbol(a.asm, a.asm_str_style);\n                 self.word_space(\":\");\n@@ -2183,7 +2183,7 @@ impl<'a> State<'a> {\n                     s.print_expr(&out.expr);\n                     s.pclose();\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n@@ -2192,7 +2192,7 @@ impl<'a> State<'a> {\n                     s.print_expr(o);\n                     s.pclose();\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, &co| {\n@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\":\");\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked);\n@@ -2227,25 +2227,25 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             ast::ExprKind::Yield(ref e) => {\n-                self.s.word(\"yield\");\n+                self.word(\"yield\");\n \n                 if let Some(ref expr) = *e {\n-                    self.s.space();\n+                    self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr_maybe_paren(e, parser::PREC_POSTFIX);\n-                self.s.word(\"?\")\n+                self.word(\"?\")\n             }\n             ast::ExprKind::TryBlock(ref blk) => {\n                 self.head(\"try\");\n-                self.s.space();\n+                self.space();\n                 self.print_block_with_attrs(blk, attrs)\n             }\n             ast::ExprKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose()\n             }\n         }\n@@ -2387,22 +2387,22 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_name(&mut self, name: Symbol) {\n-        self.s.word(name.to_string());\n+        self.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n     fn print_qpath(&mut self, path: &ast::Path, qself: &ast::QSelf, colons_before_params: bool) {\n-        self.s.word(\"<\");\n+        self.word(\"<\");\n         self.print_type(&qself.ty);\n         if qself.position > 0 {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"as\");\n             let depth = path.segments.len() - qself.position;\n             self.print_path(path, false, depth);\n         }\n-        self.s.word(\">\");\n+        self.word(\">\");\n         for item_segment in &path.segments[qself.position..] {\n-            self.s.word(\"::\");\n+            self.word(\"::\");\n             self.print_ident(item_segment.ident);\n             if let Some(ref args) = item_segment.args {\n                 self.print_generic_args(args, colons_before_params)\n@@ -2416,7 +2416,7 @@ impl<'a> State<'a> {\n         /* Pat isn't normalized, but the beauty of it\n         is that it doesn't matter */\n         match pat.kind {\n-            PatKind::Wild => self.s.word(\"_\"),\n+            PatKind::Wild => self.word(\"_\"),\n             PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n@@ -2430,8 +2430,8 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n-                    self.s.space();\n-                    self.s.word_space(\"@\");\n+                    self.space();\n+                    self.word_space(\"@\");\n                     self.print_pat(p);\n                 }\n             }\n@@ -2480,27 +2480,27 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 }\n-                self.s.space();\n-                self.s.word(\"}\");\n+                self.space();\n+                self.word(\"}\");\n             }\n             PatKind::Tuple(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n-                self.s.word(\"box \");\n+                self.word(\"box \");\n                 self.print_pat(inner);\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 if mutbl == ast::Mutability::Mut {\n-                    self.s.word(\"mut \");\n+                    self.word(\"mut \");\n                 }\n                 if let PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Mut), ..) =\n                     inner.kind\n@@ -2516,23 +2516,23 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, Spanned { node: ref end_kind, .. }) => {\n                 if let Some(e) = begin {\n                     self.print_expr(e);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 match *end_kind {\n-                    RangeEnd::Included(RangeSyntax::DotDotDot) => self.s.word(\"...\"),\n-                    RangeEnd::Included(RangeSyntax::DotDotEq) => self.s.word(\"..=\"),\n-                    RangeEnd::Excluded => self.s.word(\"..\"),\n+                    RangeEnd::Included(RangeSyntax::DotDotDot) => self.word(\"...\"),\n+                    RangeEnd::Included(RangeSyntax::DotDotEq) => self.word(\"..=\"),\n+                    RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(e) = end {\n                     self.print_expr(e);\n                 }\n             }\n             PatKind::Slice(ref elts) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n-            PatKind::Rest => self.s.word(\"..\"),\n+            PatKind::Rest => self.word(\"..\"),\n             PatKind::Paren(ref inner) => {\n                 self.popen();\n                 self.print_pat(inner);\n@@ -2546,18 +2546,18 @@ impl<'a> State<'a> {\n     fn print_arm(&mut self, arm: &ast::Arm) {\n         // Note, I have no idea why this check is necessary, but here it is.\n         if arm.attrs.is_empty() {\n-            self.s.space();\n+            self.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ibox(0);\n         self.maybe_print_comment(arm.pat.span.lo());\n         self.print_outer_attributes(&arm.attrs);\n         self.print_pat(&arm.pat);\n-        self.s.space();\n+        self.space();\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\");\n             self.print_expr(e);\n-            self.s.space();\n+            self.space();\n         }\n         self.word_space(\"=>\");\n \n@@ -2573,13 +2573,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it.\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n             }\n             _ => {\n                 self.end(); // Close the ibox for the pattern.\n                 self.print_expr(&arm.body);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n         self.end(); // Close enclosing cbox.\n@@ -2589,17 +2589,17 @@ impl<'a> State<'a> {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\")\n+                self.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lt);\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\")\n+                self.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n                 self.print_mutability(m, false);\n-                self.s.word(\"self\");\n+                self.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n             }\n@@ -2626,7 +2626,7 @@ impl<'a> State<'a> {\n             self.nbsp();\n             self.print_block_with_attrs(body, attrs);\n         } else {\n-            self.s.word(\";\");\n+            self.word(\";\");\n         }\n     }\n \n@@ -2677,7 +2677,7 @@ impl<'a> State<'a> {\n \n     pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound]) {\n         if !bounds.is_empty() {\n-            self.s.word(prefix);\n+            self.word(prefix);\n             let mut first = true;\n             for bound in bounds {\n                 if !(first && prefix.is_empty()) {\n@@ -2692,7 +2692,7 @@ impl<'a> State<'a> {\n                 match bound {\n                     GenericBound::Trait(tref, modifier) => {\n                         if modifier == &TraitBoundModifier::Maybe {\n-                            self.s.word(\"?\");\n+                            self.word(\"?\");\n                         }\n                         self.print_poly_trait_ref(tref);\n                     }\n@@ -2713,10 +2713,10 @@ impl<'a> State<'a> {\n     ) {\n         self.print_lifetime(lifetime);\n         if !bounds.is_empty() {\n-            self.s.word(\": \");\n+            self.word(\": \");\n             for (i, bound) in bounds.iter().enumerate() {\n                 if i != 0 {\n-                    self.s.word(\" + \");\n+                    self.word(\" + \");\n                 }\n                 match bound {\n                     ast::GenericBound::Outlives(lt) => self.print_lifetime(*lt),\n@@ -2731,7 +2731,7 @@ impl<'a> State<'a> {\n             return;\n         }\n \n-        self.s.word(\"<\");\n+        self.word(\"<\");\n \n         self.commasep(Inconsistent, &generic_params, |s, param| {\n             s.print_outer_attributes_inline(&param.attrs);\n@@ -2745,36 +2745,36 @@ impl<'a> State<'a> {\n                     s.print_ident(param.ident);\n                     s.print_type_bounds(\":\", &param.bounds);\n                     if let Some(ref default) = default {\n-                        s.s.space();\n+                        s.space();\n                         s.word_space(\"=\");\n                         s.print_type(default)\n                     }\n                 }\n                 ast::GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n                     s.word_space(\"const\");\n                     s.print_ident(param.ident);\n-                    s.s.space();\n+                    s.space();\n                     s.word_space(\":\");\n                     s.print_type(ty);\n                     s.print_type_bounds(\":\", &param.bounds);\n                     if let Some(ref default) = default {\n-                        s.s.space();\n+                        s.space();\n                         s.word_space(\"=\");\n                         s.print_expr(&default.value);\n                     }\n                 }\n             }\n         });\n \n-        self.s.word(\">\");\n+        self.word(\">\");\n     }\n \n     crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n         if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n             return;\n         }\n \n-        self.s.space();\n+        self.space();\n         self.word_space(\"where\");\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2806,7 +2806,7 @@ impl<'a> State<'a> {\n                     ..\n                 }) => {\n                     self.print_type(lhs_ty);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(rhs_ty);\n                 }\n@@ -2819,29 +2819,29 @@ impl<'a> State<'a> {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0);\n                 if let Some(rename) = rename {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"as\");\n                     self.print_ident(rename);\n                 }\n             }\n             ast::UseTreeKind::Glob => {\n                 if !tree.prefix.segments.is_empty() {\n                     self.print_path(&tree.prefix, false, 0);\n-                    self.s.word(\"::\");\n+                    self.word(\"::\");\n                 }\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 if tree.prefix.segments.is_empty() {\n-                    self.s.word(\"{\");\n+                    self.word(\"{\");\n                 } else {\n                     self.print_path(&tree.prefix, false, 0);\n-                    self.s.word(\"::{\");\n+                    self.word(\"::{\");\n                 }\n                 self.commasep(Inconsistent, &items[..], |this, &(ref tree, _)| {\n                     this.print_use_tree(tree)\n                 });\n-                self.s.word(\"}\");\n+                self.word(\"}\");\n             }\n         }\n     }\n@@ -2880,8 +2880,8 @@ impl<'a> State<'a> {\n                     };\n                     if !invalid {\n                         self.print_pat(&input.pat);\n-                        self.s.word(\":\");\n-                        self.s.space();\n+                        self.word(\":\");\n+                        self.space();\n                     }\n                     self.print_type(&input.ty);\n                 }\n@@ -2911,7 +2911,7 @@ impl<'a> State<'a> {\n     ) {\n         self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n         }\n         let generics = ast::Generics {\n@@ -2945,7 +2945,7 @@ impl<'a> State<'a> {\n             }\n         }\n \n-        self.s.word(\"fn\")\n+        self.word(\"fn\")\n     }\n \n     crate fn print_unsafety(&mut self, s: ast::Unsafe) {"}, {"sha": "4240a4045a1ec7c2ef151c943f31430c18161286", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 177, "deletions": 177, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/1be98af02fae15c6b398b7253a9313e189ff54c7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be98af02fae15c6b398b7253a9313e189ff54c7/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=1be98af02fae15c6b398b7253a9313e189ff54c7", "patch": "@@ -89,7 +89,7 @@ impl<'a> State<'a> {\n             Node::TraitRef(a) => self.print_trait_ref(&a),\n             Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n             Node::Arm(a) => self.print_arm(&a),\n-            Node::Infer(_) => self.s.word(\"_\"),\n+            Node::Infer(_) => self.word(\"_\"),\n             Node::Block(a) => {\n                 // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(INDENT_UNIT);\n@@ -130,7 +130,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: Ident) {\n-        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n+        self.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n \n@@ -194,7 +194,7 @@ where\n pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis);\n-        s.s.word(w)\n+        s.word(w)\n     })\n }\n \n@@ -244,7 +244,7 @@ impl<'a> State<'a> {\n     pub fn bclose_maybe_open(&mut self, span: rustc_span::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n         self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n@@ -267,7 +267,7 @@ impl<'a> State<'a> {\n             op(self, elt);\n             i += 1;\n             if i < len {\n-                self.s.word(\",\");\n+                self.word(\",\");\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi()));\n                 self.space_if_not_bol();\n             }\n@@ -298,27 +298,27 @@ impl<'a> State<'a> {\n         self.ibox(0);\n         match ty.kind {\n             hir::TyKind::Slice(ref ty) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(&ty);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::TyKind::Ptr(ref mt) => {\n-                self.s.word(\"*\");\n+                self.word(\"*\");\n                 self.print_mt(mt, true);\n             }\n             hir::TyKind::Rptr(ref lifetime, ref mt) => {\n-                self.s.word(\"&\");\n+                self.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n                 self.print_mt(mt, false);\n             }\n             hir::TyKind::Never => {\n-                self.s.word(\"!\");\n+                self.word(\"!\");\n             }\n             hir::TyKind::Tup(ref elts) => {\n                 self.popen();\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty));\n                 if elts.len() == 1 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n                 self.pclose();\n             }\n@@ -332,7 +332,7 @@ impl<'a> State<'a> {\n                     f.param_names,\n                 );\n             }\n-            hir::TyKind::OpaqueDef(..) => self.s.word(\"/*impl Trait*/\"),\n+            hir::TyKind::OpaqueDef(..) => self.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n             hir::TyKind::TraitObject(bounds, ref lifetime, syntax) => {\n                 if syntax == ast::TraitObjectSyntax::Dyn {\n@@ -355,24 +355,24 @@ impl<'a> State<'a> {\n                 }\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_type(&ty);\n-                self.s.word(\"; \");\n+                self.word(\"; \");\n                 self.print_anon_const(length);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::TyKind::Typeof(ref e) => {\n-                self.s.word(\"typeof(\");\n+                self.word(\"typeof(\");\n                 self.print_anon_const(e);\n-                self.s.word(\")\");\n+                self.word(\")\");\n             }\n             hir::TyKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n             hir::TyKind::Infer => {\n-                self.s.word(\"_\");\n+                self.word(\"_\");\n             }\n         }\n         self.end()\n@@ -400,7 +400,7 @@ impl<'a> State<'a> {\n                     None,\n                 );\n                 self.end(); // end head-ibox\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n@@ -411,14 +411,14 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&t);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n                 self.head(visibility_qualified(&item.vis, \"type\"));\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -432,17 +432,17 @@ impl<'a> State<'a> {\n         default: Option<hir::BodyId>,\n         vis: &hir::Visibility<'_>,\n     ) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n+        self.word(visibility_qualified(vis, \"\"));\n         self.word_space(\"const\");\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n         if let Some(expr) = default {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.ann.nested(self, Nested::Body(expr));\n         }\n-        self.s.word(\";\")\n+        self.word(\";\")\n     }\n \n     fn print_associated_type(\n@@ -460,11 +460,11 @@ impl<'a> State<'a> {\n         }\n         self.print_where_clause(&generics.where_clause);\n         if let Some(ty) = ty {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_type(ty);\n         }\n-        self.s.word(\";\")\n+        self.word(\";\")\n     }\n \n     fn print_item_type(\n@@ -479,9 +479,9 @@ impl<'a> State<'a> {\n         self.end(); // end the inner ibox\n \n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         inner(self);\n-        self.s.word(\";\");\n+        self.word(\";\");\n         self.end(); // end the outer ibox\n     }\n \n@@ -497,12 +497,12 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"extern crate\"));\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n-                    self.s.space();\n-                    self.s.word(\"as\");\n-                    self.s.space();\n+                    self.space();\n+                    self.word(\"as\");\n+                    self.space();\n                 }\n                 self.print_ident(item.ident);\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n@@ -513,14 +513,14 @@ impl<'a> State<'a> {\n                 match kind {\n                     hir::UseKind::Single => {\n                         if path.segments.last().unwrap().ident != item.ident {\n-                            self.s.space();\n+                            self.space();\n                             self.word_space(\"as\");\n                             self.print_ident(item.ident);\n                         }\n-                        self.s.word(\";\");\n+                        self.word(\";\");\n                     }\n-                    hir::UseKind::Glob => self.s.word(\"::*;\"),\n-                    hir::UseKind::ListStem => self.s.word(\"::{};\"),\n+                    hir::UseKind::Glob => self.word(\"::*;\"),\n+                    hir::UseKind::ListStem => self.word(\"::{};\"),\n                 }\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n@@ -533,25 +533,25 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n-                self.s.space();\n+                self.space();\n                 self.end(); // end the head-ibox\n \n                 self.word_space(\"=\");\n                 self.ann.nested(self, Nested::Body(expr));\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"const\"));\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n-                self.s.space();\n+                self.space();\n                 self.end(); // end the head-ibox\n \n                 self.word_space(\"=\");\n                 self.ann.nested(self, Nested::Body(expr));\n-                self.s.word(\";\");\n+                self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Fn(ref sig, ref param_names, body) => {\n@@ -565,7 +565,7 @@ impl<'a> State<'a> {\n                     &[],\n                     Some(body),\n                 );\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n@@ -609,7 +609,7 @@ impl<'a> State<'a> {\n                     let mut real_bounds = Vec::with_capacity(opaque_ty.bounds.len());\n                     for b in opaque_ty.bounds.iter() {\n                         if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                            state.s.space();\n+                            state.space();\n                             state.word_space(\"for ?\");\n                             state.print_trait_ref(&ptr.trait_ref);\n                         } else {\n@@ -649,27 +649,27 @@ impl<'a> State<'a> {\n \n                 if !generics.params.is_empty() {\n                     self.print_generic_params(&generics.params);\n-                    self.s.space();\n+                    self.space();\n                 }\n \n                 if constness == hir::Constness::Const {\n                     self.word_nbsp(\"const\");\n                 }\n \n                 if let hir::ImplPolarity::Negative(_) = polarity {\n-                    self.s.word(\"!\");\n+                    self.word(\"!\");\n                 }\n \n                 if let Some(ref t) = of_trait {\n                     self.print_trait_ref(t);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"for\");\n                 }\n \n                 self.print_type(&self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 self.print_inner_attributes(attrs);\n                 for impl_item in items {\n@@ -688,7 +688,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -697,7 +697,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", real_bounds);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\" \");\n+                self.word(\" \");\n                 self.bopen();\n                 for trait_item in trait_items {\n                     self.ann.nested(self, Nested::TraitItem(trait_item.id));\n@@ -714,7 +714,7 @@ impl<'a> State<'a> {\n                 // FIXME(durka) this seems to be some quite outdated syntax\n                 for b in bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        self.s.space();\n+                        self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n                     } else {\n@@ -724,7 +724,7 @@ impl<'a> State<'a> {\n                 self.nbsp();\n                 self.print_bounds(\"=\", real_bounds);\n                 self.print_where_clause(&generics.where_clause);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n         }\n         self.ann.post(self, AnnNode::Item(item))\n@@ -736,7 +736,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n@@ -759,7 +759,7 @@ impl<'a> State<'a> {\n         self.print_name(name);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n-        self.s.space();\n+        self.space();\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -771,7 +771,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(self.attrs(v.id));\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n-            self.s.word(\",\");\n+            self.word(\",\");\n             self.end();\n             self.maybe_print_trailing_comment(v.span, None);\n         }\n@@ -784,10 +784,10 @@ impl<'a> State<'a> {\n             hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n             hir::VisibilityKind::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\"),\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n-                self.s.word(\"pub(\");\n+                self.word(\"pub(\");\n                 if path.segments.len() == 1 && path.segments[0].ident.name == kw::Super {\n                     // Special case: `super` can print like `pub(super)`.\n-                    self.s.word(\"super\");\n+                    self.word(\"super\");\n                 } else {\n                     // Everything else requires `in` at present.\n                     self.word_nbsp(\"in\");\n@@ -830,7 +830,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_where_clause(&generics.where_clause);\n                 if print_finalizer {\n-                    self.s.word(\";\");\n+                    self.word(\";\");\n                 }\n                 self.end();\n                 self.end() // close the outer-box\n@@ -849,7 +849,7 @@ impl<'a> State<'a> {\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n                     self.print_type(&field.ty);\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n \n                 self.bclose(span)\n@@ -862,7 +862,7 @@ impl<'a> State<'a> {\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n-            self.s.space();\n+            self.space();\n             self.word_space(\"=\");\n             self.print_anon_const(d);\n         }\n@@ -894,7 +894,7 @@ impl<'a> State<'a> {\n                 let vis =\n                     Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 let vis =\n@@ -975,11 +975,11 @@ impl<'a> State<'a> {\n             hir::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol();\n                 self.print_expr(&expr);\n-                self.s.word(\";\");\n+                self.word(\";\");\n             }\n         }\n         if stmt_ends_with_semi(&st.kind) {\n-            self.s.word(\";\");\n+            self.word(\";\");\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n@@ -1031,17 +1031,17 @@ impl<'a> State<'a> {\n                 hir::ExprKind::If(ref i, ref then, ref e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else if \");\n+                    self.word(\" else if \");\n                     self.print_expr_as_cond(&i);\n-                    self.s.space();\n+                    self.space();\n                     self.print_expr(&then);\n                     self.print_else(e.as_ref().map(|e| &**e))\n                 }\n                 // Final `else` block.\n                 hir::ExprKind::Block(ref b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n-                    self.s.word(\" else \");\n+                    self.word(\" else \");\n                     self.print_block(&b)\n                 }\n                 // Constraints would be great here!\n@@ -1060,7 +1060,7 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"if\");\n         self.print_expr_as_cond(test);\n-        self.s.space();\n+        self.space();\n         self.print_expr(blk);\n         self.print_else(elseopt)\n     }\n@@ -1102,9 +1102,9 @@ impl<'a> State<'a> {\n \n     /// Print a `let pat = expr` expression.\n     fn print_let(&mut self, pat: &hir::Pat<'_>, expr: &hir::Expr<'_>) {\n-        self.s.word(\"let \");\n+        self.word(\"let \");\n         self.print_pat(pat);\n-        self.s.space();\n+        self.space();\n         self.word_space(\"=\");\n         let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n@@ -1123,26 +1123,26 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.commasep_exprs(Inconsistent, exprs);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end()\n     }\n \n     fn print_expr_anon_const(&mut self, anon_const: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word_space(\"const\");\n+        self.word_space(\"const\");\n         self.print_anon_const(anon_const);\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr<'_>, count: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n-        self.s.word(\"[\");\n+        self.word(\"[\");\n         self.print_expr(element);\n         self.word_space(\";\");\n         self.print_anon_const(count);\n-        self.s.word(\"]\");\n+        self.word(\"]\");\n         self.end()\n     }\n \n@@ -1153,7 +1153,7 @@ impl<'a> State<'a> {\n         wth: &Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n-        self.s.word(\"{\");\n+        self.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n             fields,\n@@ -1172,27 +1172,27 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n-                    self.s.word(\",\");\n-                    self.s.space();\n+                    self.word(\",\");\n+                    self.space();\n                 }\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n                 self.print_expr(&expr);\n                 self.end();\n             }\n             _ => {\n                 if !fields.is_empty() {\n-                    self.s.word(\",\")\n+                    self.word(\",\")\n                 }\n             }\n         }\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[hir::Expr<'_>]) {\n         self.popen();\n         self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n-            self.s.word(\",\");\n+            self.word(\",\");\n         }\n         self.pclose()\n     }\n@@ -1210,7 +1210,7 @@ impl<'a> State<'a> {\n     fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n-        self.s.word(\".\");\n+        self.word(\".\");\n         self.print_ident(segment.ident);\n \n         let generic_args = segment.args();\n@@ -1246,13 +1246,13 @@ impl<'a> State<'a> {\n         };\n \n         self.print_expr_maybe_paren(lhs, left_prec);\n-        self.s.space();\n+        self.space();\n         self.word_space(op.node.as_str());\n         self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr<'_>) {\n-        self.s.word(op.as_str());\n+        self.word(op.as_str());\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1262,7 +1262,7 @@ impl<'a> State<'a> {\n         mutability: hir::Mutability,\n         expr: &hir::Expr<'_>,\n     ) {\n-        self.s.word(\"&\");\n+        self.word(\"&\");\n         match kind {\n             hir::BorrowKind::Ref => self.print_mutability(mutability, false),\n             hir::BorrowKind::Raw => {\n@@ -1434,7 +1434,7 @@ impl<'a> State<'a> {\n             hir::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(&expr, prec);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n                 self.print_type(&ty);\n             }\n@@ -1453,7 +1453,7 @@ impl<'a> State<'a> {\n                 // Print `let _t = $init;`:\n                 let temp = Ident::from_str(\"_t\");\n                 self.print_local(Some(init), |this| this.print_ident(temp));\n-                self.s.word(\";\");\n+                self.word(\";\");\n \n                 // Print `_t`:\n                 self.space_if_not_bol();\n@@ -1481,7 +1481,7 @@ impl<'a> State<'a> {\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n                 self.print_expr_as_cond(&expr);\n-                self.s.space();\n+                self.space();\n                 self.bopen();\n                 for arm in arms {\n                     self.print_arm(arm);\n@@ -1492,7 +1492,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_closure_params(&decl, body);\n-                self.s.space();\n+                self.space();\n \n                 // This is a bare expression.\n                 self.ann.nested(self, Nested::Body(body));\n@@ -1517,54 +1517,54 @@ impl<'a> State<'a> {\n             hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(&rhs, prec);\n             }\n             hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(&lhs, prec + 1);\n-                self.s.space();\n-                self.s.word(op.node.as_str());\n+                self.space();\n+                self.word(op.node.as_str());\n                 self.word_space(\"=\");\n                 self.print_expr_maybe_paren(&rhs, prec);\n             }\n             hir::ExprKind::Field(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n-                self.s.word(\".\");\n+                self.word(\".\");\n                 self.print_ident(ident);\n             }\n             hir::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX);\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.print_expr(&index);\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n             hir::ExprKind::Path(ref qpath) => self.print_qpath(qpath, true),\n             hir::ExprKind::Break(destination, ref opt_expr) => {\n-                self.s.word(\"break\");\n-                self.s.space();\n+                self.word(\"break\");\n+                self.space();\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n             hir::ExprKind::Continue(destination) => {\n-                self.s.word(\"continue\");\n-                self.s.space();\n+                self.word(\"continue\");\n+                self.space();\n                 if let Some(label) = destination.label {\n                     self.print_ident(label.ident);\n-                    self.s.space()\n+                    self.space()\n                 }\n             }\n             hir::ExprKind::Ret(ref result) => {\n-                self.s.word(\"return\");\n+                self.word(\"return\");\n                 if let Some(ref expr) = *result {\n-                    self.s.word(\" \");\n+                    self.word(\" \");\n                     self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n                 }\n             }\n@@ -1574,7 +1574,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::LlvmInlineAsm(ref a) => {\n                 let i = &a.inner;\n-                self.s.word(\"llvm_asm!\");\n+                self.word(\"llvm_asm!\");\n                 self.popen();\n                 self.print_symbol(i.asm, i.asm_str_style);\n                 self.word_space(\":\");\n@@ -1594,7 +1594,7 @@ impl<'a> State<'a> {\n                     s.pclose();\n                     out_idx += 1;\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 let mut in_idx = 0;\n@@ -1605,7 +1605,7 @@ impl<'a> State<'a> {\n                     s.pclose();\n                     in_idx += 1;\n                 });\n-                self.s.space();\n+                self.space();\n                 self.word_space(\":\");\n \n                 self.commasep(Inconsistent, &i.clobbers, |s, &co| {\n@@ -1624,7 +1624,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\":\");\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked);\n@@ -1639,7 +1639,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::Err => {\n                 self.popen();\n-                self.s.word(\"/*ERROR*/\");\n+                self.word(\"/*ERROR*/\");\n                 self.pclose();\n             }\n         }\n@@ -1664,7 +1664,7 @@ impl<'a> State<'a> {\n \n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                self.s.word(\"::\")\n+                self.word(\"::\")\n             }\n             if segment.ident.name != kw::PathRoot {\n                 self.print_ident(segment.ident);\n@@ -1684,14 +1684,14 @@ impl<'a> State<'a> {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n-                self.s.word(\"<\");\n+                self.word(\"<\");\n                 self.print_type(qself);\n-                self.s.space();\n+                self.space();\n                 self.word_space(\"as\");\n \n                 for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n                     if i > 0 {\n-                        self.s.word(\"::\")\n+                        self.word(\"::\")\n                     }\n                     if segment.ident.name != kw::PathRoot {\n                         self.print_ident(segment.ident);\n@@ -1703,8 +1703,8 @@ impl<'a> State<'a> {\n                     }\n                 }\n \n-                self.s.word(\">\");\n-                self.s.word(\"::\");\n+                self.word(\">\");\n+                self.word(\"::\");\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_ident(item_segment.ident);\n                 self.print_generic_args(\n@@ -1720,12 +1720,12 @@ impl<'a> State<'a> {\n                 if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = &qself.kind {\n                     self.print_type(qself);\n                 } else {\n-                    self.s.word(\"<\");\n+                    self.word(\"<\");\n                     self.print_type(qself);\n-                    self.s.word(\">\");\n+                    self.word(\">\");\n                 }\n \n-                self.s.word(\"::\");\n+                self.word(\"::\");\n                 self.print_ident(item_segment.ident);\n                 self.print_generic_args(\n                     item_segment.args(),\n@@ -1734,9 +1734,9 @@ impl<'a> State<'a> {\n                 )\n             }\n             hir::QPath::LangItem(lang_item, span) => {\n-                self.s.word(\"#[lang = \\\"\");\n+                self.word(\"#[lang = \\\"\");\n                 self.print_ident(Ident::new(lang_item.name(), span));\n-                self.s.word(\"\\\"]\");\n+                self.word(\"\\\"]\");\n             }\n         }\n     }\n@@ -1748,9 +1748,9 @@ impl<'a> State<'a> {\n         colons_before_params: bool,\n     ) {\n         if generic_args.parenthesized {\n-            self.s.word(\"(\");\n+            self.word(\"(\");\n             self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(&ty));\n-            self.s.word(\")\");\n+            self.word(\")\");\n \n             self.space_if_not_bol();\n             self.word_space(\"->\");\n@@ -1761,7 +1761,7 @@ impl<'a> State<'a> {\n             let start_or_comma = |this: &mut Self| {\n                 if empty.get() {\n                     empty.set(false);\n-                    this.s.word(start)\n+                    this.word(start)\n                 } else {\n                     this.word_space(\",\")\n                 }\n@@ -1795,14 +1795,14 @@ impl<'a> State<'a> {\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\").\n             if infer_args && false {\n                 start_or_comma(self);\n-                self.s.word(\"..\");\n+                self.word(\"..\");\n             }\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self);\n                 self.print_ident(binding.ident);\n                 self.print_generic_args(binding.gen_args, false, false);\n-                self.s.space();\n+                self.space();\n                 match generic_args.bindings[0].kind {\n                     hir::TypeBindingKind::Equality { ref ty } => {\n                         self.word_space(\"=\");\n@@ -1815,7 +1815,7 @@ impl<'a> State<'a> {\n             }\n \n             if !empty.get() {\n-                self.s.word(\">\")\n+                self.word(\">\")\n             }\n         }\n     }\n@@ -1826,7 +1826,7 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.kind {\n-            PatKind::Wild => self.s.word(\"_\"),\n+            PatKind::Wild => self.word(\"_\"),\n             PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n@@ -1844,7 +1844,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(ident);\n                 if let Some(ref p) = *sub {\n-                    self.s.word(\"@\");\n+                    self.word(\"@\");\n                     self.print_pat(&p);\n                 }\n             }\n@@ -1856,9 +1856,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if ddpos != elts.len() {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n                     }\n                 } else {\n@@ -1891,10 +1891,10 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                 }\n-                self.s.space();\n-                self.s.word(\"}\");\n+                self.space();\n+                self.word(\"}\");\n             }\n             PatKind::Or(ref pats) => {\n                 self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(&p));\n@@ -1906,22 +1906,22 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if ddpos != elts.len() {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p));\n                     if elts.len() == 1 {\n-                        self.s.word(\",\");\n+                        self.word(\",\");\n                     }\n                 }\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n-                self.s.word(\"box \");\n+                self.word(\"box \");\n                 if is_range_inner {\n                     self.popen();\n                 }\n@@ -1932,8 +1932,8 @@ impl<'a> State<'a> {\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n-                self.s.word(\"&\");\n-                self.s.word(mutbl.prefix_str());\n+                self.word(\"&\");\n+                self.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }\n@@ -1946,18 +1946,18 @@ impl<'a> State<'a> {\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 if let Some(expr) = begin {\n                     self.print_expr(expr);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 match *end_kind {\n-                    RangeEnd::Included => self.s.word(\"...\"),\n-                    RangeEnd::Excluded => self.s.word(\"..\"),\n+                    RangeEnd::Included => self.word(\"...\"),\n+                    RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(expr) = end {\n                     self.print_expr(expr);\n                 }\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                self.s.word(\"[\");\n+                self.word(\"[\");\n                 self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n@@ -1968,13 +1968,13 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_pat(&p);\n                     }\n-                    self.s.word(\"..\");\n+                    self.word(\"..\");\n                     if !after.is_empty() {\n                         self.word_space(\",\");\n                     }\n                 }\n                 self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p));\n-                self.s.word(\"]\");\n+                self.word(\"]\");\n             }\n         }\n         self.ann.post(self, AnnNode::Pat(pat))\n@@ -1989,29 +1989,29 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if self.attrs(arm.hir_id).is_empty() {\n-            self.s.space();\n+            self.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&self.attrs(arm.hir_id));\n         self.print_pat(&arm.pat);\n-        self.s.space();\n+        self.space();\n         if let Some(ref g) = arm.guard {\n             match g {\n                 hir::Guard::If(e) => {\n                     self.word_space(\"if\");\n                     self.print_expr(&e);\n-                    self.s.space();\n+                    self.space();\n                 }\n                 hir::Guard::IfLet(pat, e) => {\n                     self.word_nbsp(\"if\");\n                     self.word_nbsp(\"let\");\n                     self.print_pat(&pat);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_expr(&e);\n-                    self.s.space();\n+                    self.space();\n                 }\n             }\n         }\n@@ -2029,13 +2029,13 @@ impl<'a> State<'a> {\n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n                 {\n-                    self.s.word(\",\");\n+                    self.word(\",\");\n                 }\n             }\n             _ => {\n                 self.end(); // close the ibox for the pattern\n                 self.print_expr(&arm.body);\n-                self.s.word(\",\");\n+                self.word(\",\");\n             }\n         }\n         self.ann.post(self, AnnNode::Arm(arm));\n@@ -2067,20 +2067,20 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n-                s.s.word(arg_name.to_string());\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(arg_name.to_string());\n+                s.word(\":\");\n+                s.space();\n             } else if let Some(body_id) = body_id {\n                 s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(\":\");\n+                s.space();\n             }\n             i += 1;\n             s.print_type(ty);\n             s.end()\n         });\n         if decl.c_variadic {\n-            self.s.word(\", ...\");\n+            self.word(\", ...\");\n         }\n         self.pclose();\n \n@@ -2089,7 +2089,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n-        self.s.word(\"|\");\n+        self.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n@@ -2100,13 +2100,13 @@ impl<'a> State<'a> {\n             if let hir::TyKind::Infer = ty.kind {\n                 // Print nothing.\n             } else {\n-                s.s.word(\":\");\n-                s.s.space();\n+                s.word(\":\");\n+                s.space();\n                 s.print_type(ty);\n             }\n             s.end();\n         });\n-        self.s.word(\"|\");\n+        self.word(\"|\");\n \n         if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n@@ -2138,7 +2138,7 @@ impl<'a> State<'a> {\n         let mut first = true;\n         for bound in bounds {\n             if first {\n-                self.s.word(prefix);\n+                self.word(prefix);\n             }\n             if !(first && prefix.is_empty()) {\n                 self.nbsp();\n@@ -2152,14 +2152,14 @@ impl<'a> State<'a> {\n             match bound {\n                 GenericBound::Trait(tref, modifier) => {\n                     if modifier == &TraitBoundModifier::Maybe {\n-                        self.s.word(\"?\");\n+                        self.word(\"?\");\n                     }\n                     self.print_poly_trait_ref(tref);\n                 }\n                 GenericBound::LangItemTrait(lang_item, span, ..) => {\n-                    self.s.word(\"#[lang = \\\"\");\n+                    self.word(\"#[lang = \\\"\");\n                     self.print_ident(Ident::new(lang_item.name(), *span));\n-                    self.s.word(\"\\\"]\");\n+                    self.word(\"\\\"]\");\n                 }\n                 GenericBound::Outlives(lt) => {\n                     self.print_lifetime(lt);\n@@ -2170,11 +2170,11 @@ impl<'a> State<'a> {\n \n     pub fn print_generic_params(&mut self, generic_params: &[GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n-            self.s.word(\"<\");\n+            self.word(\"<\");\n \n             self.commasep(Inconsistent, generic_params, |s, param| s.print_generic_param(param));\n \n-            self.s.word(\">\");\n+            self.word(\">\");\n         }\n     }\n \n@@ -2191,7 +2191,7 @@ impl<'a> State<'a> {\n                 for bound in param.bounds {\n                     match bound {\n                         GenericBound::Outlives(ref lt) => {\n-                            self.s.word(sep);\n+                            self.word(sep);\n                             self.print_lifetime(lt);\n                             sep = \"+\";\n                         }\n@@ -2202,7 +2202,7 @@ impl<'a> State<'a> {\n             GenericParamKind::Type { ref default, .. } => {\n                 self.print_bounds(\":\", param.bounds);\n                 if let Some(default) = default {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(&default)\n                 }\n@@ -2211,7 +2211,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n                 if let Some(ref default) = default {\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_anon_const(&default)\n                 }\n@@ -2228,7 +2228,7 @@ impl<'a> State<'a> {\n             return;\n         }\n \n-        self.s.space();\n+        self.space();\n         self.word_space(\"where\");\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2253,7 +2253,7 @@ impl<'a> State<'a> {\n                     ..\n                 }) => {\n                     self.print_lifetime(lifetime);\n-                    self.s.word(\":\");\n+                    self.word(\":\");\n \n                     for (i, bound) in bounds.iter().enumerate() {\n                         match bound {\n@@ -2264,15 +2264,15 @@ impl<'a> State<'a> {\n                         }\n \n                         if i != 0 {\n-                            self.s.word(\":\");\n+                            self.word(\":\");\n                         }\n                     }\n                 }\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty, rhs_ty, ..\n                 }) => {\n                     self.print_type(lhs_ty);\n-                    self.s.space();\n+                    self.space();\n                     self.word_space(\"=\");\n                     self.print_type(rhs_ty);\n                 }\n@@ -2326,7 +2326,7 @@ impl<'a> State<'a> {\n     ) {\n         self.ibox(INDENT_UNIT);\n         if !generic_params.is_empty() {\n-            self.s.word(\"for\");\n+            self.word(\"for\");\n             self.print_generic_params(generic_params);\n         }\n         let generics = hir::Generics {\n@@ -2352,7 +2352,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n+        self.word(visibility_qualified(vis, \"\"));\n \n         match header.constness {\n             hir::Constness::NotConst => {}\n@@ -2371,7 +2371,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(header.abi.to_string());\n         }\n \n-        self.s.word(\"fn\")\n+        self.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: hir::Unsafety) {"}]}