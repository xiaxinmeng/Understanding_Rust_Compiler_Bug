{"sha": "13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "node_id": "C_kwDOAAsO6NoAKDEzZmMzM2UzZjI5OWY0NzVhMGM2NGQ5YTVmMDUyYmVkZjNlY2NjMTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-20T08:33:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-20T08:33:33Z"}, "message": "Auto merge of #110585 - JohnTitor:rollup-gfffoiv, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102341 (Implement `Neg` for signed non-zero integers.)\n - #110424 (Spelling misc)\n - #110448 (cmp doc examples improvements)\n - #110516 (bootstrap: Update linux-raw-sys to 0.3.2)\n - #110548 (Make `impl Debug for Span` not panic on not having session globals.)\n - #110554 (`deny(unsafe_op_in_unsafe_fn)` in `rustc_data_structures`)\n - #110575 (fix lint regression in `non_upper_case_globals`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "07cb96626cda3e71ab26b36dcf23fbac01ca5e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07cb96626cda3e71ab26b36dcf23fbac01ca5e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "html_url": "https://github.com/rust-lang/rust/commit/13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23a76a8ab5f7b29a1eb7aca5f3e4c4a9b866d5b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/23a76a8ab5f7b29a1eb7aca5f3e4c4a9b866d5b7", "html_url": "https://github.com/rust-lang/rust/commit/23a76a8ab5f7b29a1eb7aca5f3e4c4a9b866d5b7"}, {"sha": "a2826dc4d46fc08d65926a3054368fadd1985711", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2826dc4d46fc08d65926a3054368fadd1985711", "html_url": "https://github.com/rust-lang/rust/commit/a2826dc4d46fc08d65926a3054368fadd1985711"}], "stats": {"total": 432, "additions": 254, "deletions": 178}, "files": [{"sha": "934312662beb66fe5f3f9e07a5d59f1600b0238e", "filename": ".github/ISSUE_TEMPLATE/library_tracking_issue.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -12,7 +12,7 @@ Tracking issues are for tracking a feature from implementation to stabilization.\n Make sure to include the relevant RFC for the feature if it has one.\n \n If the new feature is small, it may be fine to skip the RFC process. In that\n-case, you can use use `issue = \"none\"` in your initial implementation PR. The\n+case, you can use `issue = \"none\"` in your initial implementation PR. The\n reviewer will ask you to open a tracking issue if they agree your feature can be\n added without an RFC.\n -->\n@@ -65,7 +65,7 @@ the rfcbot will ask all the team members to verify they agree with\n stabilization. Once enough members agree and there are no concerns, the final\n comment period begins: this issue will be marked as such and will be listed\n in the next This Week in Rust newsletter. If no blocking concerns are raised in\n-that period of 10 days, a stabilzation PR can be opened by anyone.\n+that period of 10 days, a stabilization PR can be opened by anyone.\n -->\n \n ### Unresolved Questions"}, {"sha": "699735de6fb4d489ec58d36cbf80785378d54e6b", "filename": "RELEASES.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -963,7 +963,7 @@ Compatibility Notes\n - [rustdoc: doctests are now run on unexported `macro_rules!` macros, matching other private items][96630]\n - [rustdoc: Remove .woff font files][96279]\n - [Enforce Copy bounds for repeat elements while considering lifetimes][95819]\n-- [Windows: Fix potentinal unsoundness by aborting if `File` reads or writes cannot\n+- [Windows: Fix potential unsoundness by aborting if `File` reads or writes cannot\n   complete synchronously][95469].\n \n Internal Changes\n@@ -1794,10 +1794,10 @@ Libraries\n - [impl Default, Copy, Clone for std::io::Sink and std::io::Empty][rust#86744]\n - [`impl From<[(K, V); N]>` for all collections.][rust#84111]\n - [Remove `P: Unpin` bound on impl Future for Pin.][rust#81363]\n-- [Treat invalid environment variable names as non-existent.][rust#86183]\n+- [Treat invalid environment variable names as nonexistent.][rust#86183]\n   Previously, the environment functions would panic if given a variable name\n   with an internal null character or equal sign (`=`). Now, these functions will\n-  just treat such names as non-existent variables, since the OS cannot represent\n+  just treat such names as nonexistent variables, since the OS cannot represent\n   the existence of a variable with such a name.\n \n Stabilised APIs\n@@ -1990,7 +1990,7 @@ Compatibility Notes\n   kinds of errors could be categorised [into newer more specific `ErrorKind`\n   variants][79965], and that they do not represent a user error.\n - [Using environment variable names with `process::Command` on Windows now\n-  behaves as expected.][85270] Previously using envionment variables with\n+  behaves as expected.][85270] Previously using environment variables with\n   `Command` would cause them to be ASCII-uppercased.\n - [Rustdoc will now warn on using rustdoc lints that aren't prefixed\n   with `rustdoc::`][86849]\n@@ -6367,7 +6367,7 @@ eg. `static MINUTE: Duration = Duration::from_secs(60);`\n \n Cargo\n -----\n-- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` no longer removes `rust` or `rs` prefixes/suffixes.][cargo/5013]\n - [`cargo new` now defaults to creating a binary crate, instead of a\n   library crate.][cargo/5029]\n "}, {"sha": "426d2c4034bd8f64c0aa3eaf032743ef791b957d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -35,6 +35,7 @@\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "ca908671ae5307b6d78bfc6424040781b1f156bd", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -13,7 +13,8 @@ pub struct Mmap(Vec<u8>);\n impl Mmap {\n     #[inline]\n     pub unsafe fn map(file: File) -> io::Result<Self> {\n-        memmap2::Mmap::map(&file).map(Mmap)\n+        // Safety: this is in fact not safe.\n+        unsafe { memmap2::Mmap::map(&file).map(Mmap) }\n     }\n }\n "}, {"sha": "4a0ed87f77c84e78c3a011b1cbc374062d573c4b", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 101, "deletions": 95, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -96,28 +96,30 @@ macro_rules! compress {\n unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {\n     debug_assert!(count <= 8);\n \n-    if count == 8 {\n-        ptr::copy_nonoverlapping(src, dst, 8);\n-        return;\n-    }\n+    unsafe {\n+        if count == 8 {\n+            ptr::copy_nonoverlapping(src, dst, 8);\n+            return;\n+        }\n \n-    let mut i = 0;\n-    if i + 3 < count {\n-        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);\n-        i += 4;\n-    }\n+        let mut i = 0;\n+        if i + 3 < count {\n+            ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);\n+            i += 4;\n+        }\n \n-    if i + 1 < count {\n-        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);\n-        i += 2\n-    }\n+        if i + 1 < count {\n+            ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);\n+            i += 2\n+        }\n \n-    if i < count {\n-        *dst.add(i) = *src.add(i);\n-        i += 1;\n-    }\n+        if i < count {\n+            *dst.add(i) = *src.add(i);\n+            i += 1;\n+        }\n \n-    debug_assert_eq!(i, count);\n+        debug_assert_eq!(i, count);\n+    }\n }\n \n // # Implementation\n@@ -232,38 +234,40 @@ impl SipHasher128 {\n     // overflow) if it wasn't already.\n     #[inline(never)]\n     unsafe fn short_write_process_buffer<const LEN: usize>(&mut self, bytes: [u8; LEN]) {\n-        let nbuf = self.nbuf;\n-        debug_assert!(LEN <= 8);\n-        debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + LEN >= BUFFER_SIZE);\n-        debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n+        unsafe {\n+            let nbuf = self.nbuf;\n+            debug_assert!(LEN <= 8);\n+            debug_assert!(nbuf < BUFFER_SIZE);\n+            debug_assert!(nbuf + LEN >= BUFFER_SIZE);\n+            debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n+\n+            // Copy first part of input into end of buffer, possibly into spill\n+            // element. The memcpy call is optimized away because the size is known.\n+            let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+            ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n+\n+            // Process buffer.\n+            for i in 0..BUFFER_CAPACITY {\n+                let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+            }\n \n-        // Copy first part of input into end of buffer, possibly into spill\n-        // element. The memcpy call is optimized away because the size is known.\n-        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-        ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n-\n-        // Process buffer.\n-        for i in 0..BUFFER_CAPACITY {\n-            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n+            // Copy remaining input into start of buffer by copying LEN - 1\n+            // elements from spill (at most LEN - 1 bytes could have overflowed\n+            // into the spill). The memcpy call is optimized away because the size\n+            // is known. And the whole copy is optimized away for LEN == 1.\n+            let dst = self.buf.as_mut_ptr() as *mut u8;\n+            let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n+            ptr::copy_nonoverlapping(src, dst, LEN - 1);\n+\n+            // This function should only be called when the write fills the buffer.\n+            // Therefore, when LEN == 1, the new `self.nbuf` must be zero.\n+            // LEN is statically known, so the branch is optimized away.\n+            self.nbuf = if LEN == 1 { 0 } else { nbuf + LEN - BUFFER_SIZE };\n+            self.processed += BUFFER_SIZE;\n         }\n-\n-        // Copy remaining input into start of buffer by copying LEN - 1\n-        // elements from spill (at most LEN - 1 bytes could have overflowed\n-        // into the spill). The memcpy call is optimized away because the size\n-        // is known. And the whole copy is optimized away for LEN == 1.\n-        let dst = self.buf.as_mut_ptr() as *mut u8;\n-        let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n-        ptr::copy_nonoverlapping(src, dst, LEN - 1);\n-\n-        // This function should only be called when the write fills the buffer.\n-        // Therefore, when LEN == 1, the new `self.nbuf` must be zero.\n-        // LEN is statically known, so the branch is optimized away.\n-        self.nbuf = if LEN == 1 { 0 } else { nbuf + LEN - BUFFER_SIZE };\n-        self.processed += BUFFER_SIZE;\n     }\n \n     // A write function for byte slices.\n@@ -301,57 +305,59 @@ impl SipHasher128 {\n     // containing the byte offset `self.nbuf`.\n     #[inline(never)]\n     unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {\n-        let length = msg.len();\n-        let nbuf = self.nbuf;\n-        debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + length >= BUFFER_SIZE);\n-\n-        // Always copy first part of input into current element of buffer.\n-        // This function should only be called when the write fills the buffer,\n-        // so we know that there is enough input to fill the current element.\n-        let valid_in_elem = nbuf % ELEM_SIZE;\n-        let needed_in_elem = ELEM_SIZE - valid_in_elem;\n-\n-        let src = msg.as_ptr();\n-        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-        copy_nonoverlapping_small(src, dst, needed_in_elem);\n-\n-        // Process buffer.\n+        unsafe {\n+            let length = msg.len();\n+            let nbuf = self.nbuf;\n+            debug_assert!(nbuf < BUFFER_SIZE);\n+            debug_assert!(nbuf + length >= BUFFER_SIZE);\n+\n+            // Always copy first part of input into current element of buffer.\n+            // This function should only be called when the write fills the buffer,\n+            // so we know that there is enough input to fill the current element.\n+            let valid_in_elem = nbuf % ELEM_SIZE;\n+            let needed_in_elem = ELEM_SIZE - valid_in_elem;\n+\n+            let src = msg.as_ptr();\n+            let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+            copy_nonoverlapping_small(src, dst, needed_in_elem);\n+\n+            // Process buffer.\n+\n+            // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /\n+            // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.\n+            // We know that is true, because last step ensured we have a full\n+            // element in the buffer.\n+            let last = nbuf / ELEM_SIZE + 1;\n+\n+            for i in 0..last {\n+                let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+            }\n \n-        // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /\n-        // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.\n-        // We know that is true, because last step ensured we have a full\n-        // element in the buffer.\n-        let last = nbuf / ELEM_SIZE + 1;\n+            // Process the remaining element-sized chunks of input.\n+            let mut processed = needed_in_elem;\n+            let input_left = length - processed;\n+            let elems_left = input_left / ELEM_SIZE;\n+            let extra_bytes_left = input_left % ELEM_SIZE;\n+\n+            for _ in 0..elems_left {\n+                let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+                processed += ELEM_SIZE;\n+            }\n \n-        for i in 0..last {\n-            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n-        }\n+            // Copy remaining input into start of buffer.\n+            let src = msg.as_ptr().add(processed);\n+            let dst = self.buf.as_mut_ptr() as *mut u8;\n+            copy_nonoverlapping_small(src, dst, extra_bytes_left);\n \n-        // Process the remaining element-sized chunks of input.\n-        let mut processed = needed_in_elem;\n-        let input_left = length - processed;\n-        let elems_left = input_left / ELEM_SIZE;\n-        let extra_bytes_left = input_left % ELEM_SIZE;\n-\n-        for _ in 0..elems_left {\n-            let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n-            processed += ELEM_SIZE;\n+            self.nbuf = extra_bytes_left;\n+            self.processed += nbuf + processed;\n         }\n-\n-        // Copy remaining input into start of buffer.\n-        let src = msg.as_ptr().add(processed);\n-        let dst = self.buf.as_mut_ptr() as *mut u8;\n-        copy_nonoverlapping_small(src, dst, extra_bytes_left);\n-\n-        self.nbuf = extra_bytes_left;\n-        self.processed += nbuf + processed;\n     }\n \n     #[inline]"}, {"sha": "8568aac67c08c719631c85be87f2586397c2911c", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -153,7 +153,7 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Box<T> {\n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n         // Safety: `ptr` comes from `into_ptr` which calls `Box::into_raw`\n-        Box::from_raw(ptr.as_ptr())\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n }\n \n@@ -169,7 +169,7 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Rc<T> {\n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n         // Safety: `ptr` comes from `into_ptr` which calls `Rc::into_raw`\n-        Rc::from_raw(ptr.as_ptr())\n+        unsafe { Rc::from_raw(ptr.as_ptr()) }\n     }\n }\n \n@@ -185,7 +185,7 @@ unsafe impl<T: ?Sized + Aligned> Pointer for Arc<T> {\n     #[inline]\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n         // Safety: `ptr` comes from `into_ptr` which calls `Arc::into_raw`\n-        Arc::from_raw(ptr.as_ptr())\n+        unsafe { Arc::from_raw(ptr.as_ptr()) }\n     }\n }\n \n@@ -201,7 +201,7 @@ unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a T {\n     unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n         // Safety:\n         // `ptr` comes from `into_ptr` which gets the pointer from a reference\n-        ptr.as_ref()\n+        unsafe { ptr.as_ref() }\n     }\n }\n \n@@ -217,7 +217,7 @@ unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a mut T {\n     unsafe fn from_ptr(mut ptr: NonNull<T>) -> Self {\n         // Safety:\n         // `ptr` comes from `into_ptr` which gets the pointer from a reference\n-        ptr.as_mut()\n+        unsafe { ptr.as_mut() }\n     }\n }\n "}, {"sha": "79253cbc8b43cc451561f1f2ee4a2f8e0285270f", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -33,6 +33,11 @@ pub fn method_context(cx: &LateContext<'_>, id: LocalDefId) -> MethodLateContext\n     }\n }\n \n+fn assoc_item_in_trait_impl(cx: &LateContext<'_>, ii: &hir::ImplItem<'_>) -> bool {\n+    let item = cx.tcx.associated_item(ii.owner_id);\n+    item.trait_item_def_id.is_some()\n+}\n+\n declare_lint! {\n     /// The `non_camel_case_types` lint detects types, variants, traits and\n     /// type parameters that don't have camel case names.\n@@ -177,6 +182,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n             // trait impls where we should have warned for the trait definition already.\n             ast::ItemKind::Impl(box ast::Impl { of_trait: None, items, .. }) => {\n                 for it in items {\n+                    // FIXME: this doesn't respect `#[allow(..)]` on the item itself.\n                     if let ast::AssocItemKind::Type(..) = it.kind {\n                         self.check_case(cx, \"associated type\", &it.ident);\n                     }\n@@ -494,15 +500,6 @@ impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n             hir::ItemKind::Const(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant\", &it.ident);\n             }\n-            // we only want to check inherent associated consts, trait consts\n-            // are linted at def-site.\n-            hir::ItemKind::Impl(hir::Impl { of_trait: None, items, .. }) => {\n-                for it in *items {\n-                    if let hir::AssocItemKind::Const = it.kind {\n-                        NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &it.ident);\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n     }\n@@ -513,6 +510,12 @@ impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, ii: &hir::ImplItem<'_>) {\n+        if let hir::ImplItemKind::Const(..) = ii.kind && !assoc_item_in_trait_impl(cx, ii) {\n+            NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ii.ident);\n+        }\n+    }\n+\n     fn check_pat(&mut self, cx: &LateContext<'_>, p: &hir::Pat<'_>) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {"}, {"sha": "8a900ca427ebe92af8641a574965e84813e9c923", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -1044,17 +1044,26 @@ impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Use the global `SourceMap` to print the span. If that's not\n         // available, fall back to printing the raw values.\n-        with_session_globals(|session_globals| {\n-            if let Some(source_map) = &*session_globals.source_map.borrow() {\n-                write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(*self), self.ctxt())\n-            } else {\n-                f.debug_struct(\"Span\")\n-                    .field(\"lo\", &self.lo())\n-                    .field(\"hi\", &self.hi())\n-                    .field(\"ctxt\", &self.ctxt())\n-                    .finish()\n-            }\n-        })\n+\n+        fn fallback(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Span\")\n+                .field(\"lo\", &span.lo())\n+                .field(\"hi\", &span.hi())\n+                .field(\"ctxt\", &span.ctxt())\n+                .finish()\n+        }\n+\n+        if SESSION_GLOBALS.is_set() {\n+            with_session_globals(|session_globals| {\n+                if let Some(source_map) = &*session_globals.source_map.borrow() {\n+                    write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(*self), self.ctxt())\n+                } else {\n+                    fallback(*self, f)\n+                }\n+            })\n+        } else {\n+            fallback(*self, f)\n+        }\n     }\n }\n "}, {"sha": "87ec35c040fbf4cd6eb192447a346806f346b40d", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -321,14 +321,11 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// ```\n /// use std::cmp::Ordering;\n ///\n-/// let result = 1.cmp(&2);\n-/// assert_eq!(Ordering::Less, result);\n+/// assert_eq!(1.cmp(&2), Ordering::Less);\n ///\n-/// let result = 1.cmp(&1);\n-/// assert_eq!(Ordering::Equal, result);\n+/// assert_eq!(1.cmp(&1), Ordering::Equal);\n ///\n-/// let result = 2.cmp(&1);\n-/// assert_eq!(Ordering::Greater, result);\n+/// assert_eq!(2.cmp(&1), Ordering::Greater);\n /// ```\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -784,8 +781,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// # Examples\n     ///\n     /// ```\n-    /// assert_eq!(2, 1.max(2));\n-    /// assert_eq!(2, 2.max(2));\n+    /// assert_eq!(1.max(2), 2);\n+    /// assert_eq!(2.max(2), 2);\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n@@ -804,8 +801,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// # Examples\n     ///\n     /// ```\n-    /// assert_eq!(1, 1.min(2));\n-    /// assert_eq!(2, 2.min(2));\n+    /// assert_eq!(1.min(2), 1);\n+    /// assert_eq!(2.min(2), 2);\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n@@ -829,9 +826,9 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// # Examples\n     ///\n     /// ```\n-    /// assert!((-3).clamp(-2, 1) == -2);\n-    /// assert!(0.clamp(-2, 1) == 0);\n-    /// assert!(2.clamp(-2, 1) == 1);\n+    /// assert_eq!((-3).clamp(-2, 1), -2);\n+    /// assert_eq!(0.clamp(-2, 1), 0);\n+    /// assert_eq!(2.clamp(-2, 1), 1);\n     /// ```\n     #[must_use]\n     #[stable(feature = \"clamp\", since = \"1.50.0\")]\n@@ -1060,11 +1057,9 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let result = 1.0 < 2.0;\n-    /// assert_eq!(result, true);\n-    ///\n-    /// let result = 2.0 < 1.0;\n-    /// assert_eq!(result, false);\n+    /// assert_eq!(1.0 < 1.0, false);\n+    /// assert_eq!(1.0 < 2.0, true);\n+    /// assert_eq!(2.0 < 1.0, false);\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -1079,11 +1074,9 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let result = 1.0 <= 2.0;\n-    /// assert_eq!(result, true);\n-    ///\n-    /// let result = 2.0 <= 2.0;\n-    /// assert_eq!(result, true);\n+    /// assert_eq!(1.0 <= 1.0, true);\n+    /// assert_eq!(1.0 <= 2.0, true);\n+    /// assert_eq!(2.0 <= 1.0, false);\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -1097,11 +1090,9 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let result = 1.0 > 2.0;\n-    /// assert_eq!(result, false);\n-    ///\n-    /// let result = 2.0 > 2.0;\n-    /// assert_eq!(result, false);\n+    /// assert_eq!(1.0 > 1.0, false);\n+    /// assert_eq!(1.0 > 2.0, false);\n+    /// assert_eq!(2.0 > 1.0, true);\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -1116,11 +1107,9 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let result = 2.0 >= 1.0;\n-    /// assert_eq!(result, true);\n-    ///\n-    /// let result = 2.0 >= 2.0;\n-    /// assert_eq!(result, true);\n+    /// assert_eq!(1.0 >= 1.0, true);\n+    /// assert_eq!(1.0 >= 2.0, false);\n+    /// assert_eq!(2.0 >= 1.0, true);\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -1150,8 +1139,8 @@ pub macro PartialOrd($item:item) {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(1, cmp::min(1, 2));\n-/// assert_eq!(2, cmp::min(2, 2));\n+/// assert_eq!(cmp::min(1, 2), 1);\n+/// assert_eq!(cmp::min(2, 2), 2);\n /// ```\n #[inline]\n #[must_use]\n@@ -1170,8 +1159,11 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 1);\n-/// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n+/// let result = cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs()));\n+/// assert_eq!(result, 1);\n+///\n+/// let result = cmp::min_by(-2, 3, |x: &i32, y: &i32| x.abs().cmp(&y.abs()));\n+/// assert_eq!(result, -2);\n /// ```\n #[inline]\n #[must_use]\n@@ -1192,8 +1184,11 @@ pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(cmp::min_by_key(-2, 1, |x: &i32| x.abs()), 1);\n-/// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n+/// let result = cmp::min_by_key(-2, 1, |x: &i32| x.abs());\n+/// assert_eq!(result, 1);\n+///\n+/// let result = cmp::min_by_key(-2, 2, |x: &i32| x.abs());\n+/// assert_eq!(result, -2);\n /// ```\n #[inline]\n #[must_use]\n@@ -1213,8 +1208,8 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(2, cmp::max(1, 2));\n-/// assert_eq!(2, cmp::max(2, 2));\n+/// assert_eq!(cmp::max(1, 2), 2);\n+/// assert_eq!(cmp::max(2, 2), 2);\n /// ```\n #[inline]\n #[must_use]\n@@ -1233,8 +1228,11 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n-/// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n+/// let result = cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs()));\n+/// assert_eq!(result, -2);\n+///\n+/// let result = cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())) ;\n+/// assert_eq!(result, 2);\n /// ```\n #[inline]\n #[must_use]\n@@ -1255,8 +1253,11 @@ pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// ```\n /// use std::cmp;\n ///\n-/// assert_eq!(cmp::max_by_key(-2, 1, |x: &i32| x.abs()), -2);\n-/// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n+/// let result = cmp::max_by_key(-2, 1, |x: &i32| x.abs());\n+/// assert_eq!(result, -2);\n+///\n+/// let result = cmp::max_by_key(-2, 2, |x: &i32| x.abs());\n+/// assert_eq!(result, 2);\n /// ```\n #[inline]\n #[must_use]"}, {"sha": "fc9b07d29e26695e143aefb1e17aad5ad1891379", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -1,7 +1,7 @@\n //! Definitions of integer that is known not to equal zero.\n \n use crate::fmt;\n-use crate::ops::{BitOr, BitOrAssign, Div, Rem};\n+use crate::ops::{BitOr, BitOrAssign, Div, Neg, Rem};\n use crate::str::FromStr;\n \n use super::from_str_radix;\n@@ -664,8 +664,7 @@ macro_rules! nonzero_signed_operations {\n                 /// assert_eq!(pos, pos.wrapping_abs());\n                 /// assert_eq!(pos, neg.wrapping_abs());\n                 /// assert_eq!(min, min.wrapping_abs());\n-                /// # // FIXME: add once Neg is implemented?\n-                /// # // assert_eq!(max, (-max).wrapping_abs());\n+                /// assert_eq!(max, (-max).wrapping_abs());\n                 /// # Some(())\n                 /// # }\n                 /// ```\n@@ -868,6 +867,20 @@ macro_rules! nonzero_signed_operations {\n                     unsafe { $Ty::new_unchecked(result) }\n                 }\n             }\n+\n+            #[stable(feature = \"signed_nonzero_neg\", since = \"CURRENT_RUSTC_VERSION\")]\n+            impl Neg for $Ty {\n+                type Output = $Ty;\n+\n+                #[inline]\n+                fn neg(self) -> $Ty {\n+                    // SAFETY: negation of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(self.get().neg()) }\n+                }\n+            }\n+\n+            forward_ref_unop! { impl Neg, neg for $Ty,\n+                #[stable(feature = \"signed_nonzero_neg\", since = \"CURRENT_RUSTC_VERSION\")] }\n         )+\n     }\n }"}, {"sha": "007f8442533081cd615a28362b02c42092a8212e", "filename": "library/core/tests/nonzero.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/library%2Fcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnonzero.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -336,3 +336,21 @@ fn test_nonzero_uint_rem() {\n     let x: u32 = 42u32 % nz;\n     assert_eq!(x, 2u32);\n }\n+\n+#[test]\n+fn test_signed_nonzero_neg() {\n+    assert_eq!((-NonZeroI8::new(1).unwrap()).get(), -1);\n+    assert_eq!((-NonZeroI8::new(-1).unwrap()).get(), 1);\n+\n+    assert_eq!((-NonZeroI16::new(1).unwrap()).get(), -1);\n+    assert_eq!((-NonZeroI16::new(-1).unwrap()).get(), 1);\n+\n+    assert_eq!((-NonZeroI32::new(1).unwrap()).get(), -1);\n+    assert_eq!((-NonZeroI32::new(-1).unwrap()).get(), 1);\n+\n+    assert_eq!((-NonZeroI64::new(1).unwrap()).get(), -1);\n+    assert_eq!((-NonZeroI64::new(-1).unwrap()).get(), 1);\n+\n+    assert_eq!((-NonZeroI128::new(1).unwrap()).get(), -1);\n+    assert_eq!((-NonZeroI128::new(-1).unwrap()).get(), 1);\n+}"}, {"sha": "19d67e80a61c53dfec9c6ad5c52f673035f95b4a", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -374,9 +374,9 @@ checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n \n [[package]]\n name = \"linux-raw-sys\"\n-version = \"0.3.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d59d8c75012853d2e872fb56bc8a2e53718e2cafe1a4c823143141c6d90c322f\"\n+checksum = \"3f508063cc7bb32987c71511216bd5a32be15bccb6a80b52df8b9d7f01fc3aa2\"\n \n [[package]]\n name = \"log\""}, {"sha": "d9f0868b7659dd279ab20e239832faac3ae61747", "filename": "tests/ui/lint/issue-110573.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/tests%2Fui%2Flint%2Fissue-110573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/tests%2Fui%2Flint%2Fissue-110573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-110573.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![deny(warnings)]\n+\n+pub struct Struct;\n+\n+impl Struct {\n+    #[allow(non_upper_case_globals)]\n+    pub const Const: () = ();\n+}\n+\n+fn main() {}"}, {"sha": "565b7e86fc4b954c875905b45b9bf84a3c912a71", "filename": "tests/ui/numbers-arithmetic/overflowing-neg-nonzero.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/tests%2Fui%2Fnumbers-arithmetic%2Foverflowing-neg-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13fc33e3f299f475a0c64d9a5f052bedf3eccc11/tests%2Fui%2Fnumbers-arithmetic%2Foverflowing-neg-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbers-arithmetic%2Foverflowing-neg-nonzero.rs?ref=13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "patch": "@@ -0,0 +1,12 @@\n+// run-fail\n+// error-pattern:thread 'main' panicked at 'attempt to negate with overflow'\n+// ignore-emscripten no processes\n+// compile-flags: -C debug-assertions\n+\n+#![allow(arithmetic_overflow)]\n+\n+use std::num::NonZeroI8;\n+\n+fn main() {\n+    let _x = -NonZeroI8::new(i8::MIN).unwrap();\n+}"}]}