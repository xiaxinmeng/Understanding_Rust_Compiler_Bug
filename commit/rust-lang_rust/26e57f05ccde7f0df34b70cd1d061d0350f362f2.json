{"sha": "26e57f05ccde7f0df34b70cd1d061d0350f362f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZTU3ZjA1Y2NkZTdmMGRmMzRiNzBjZDFkMDYxZDAzNTBmMzYyZjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T16:50:41Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2021-07-04T16:50:41Z"}, "message": "revert broken formatting", "tree": {"sha": "a1189c2fb6a72d95185f690d1ba4eb0729d6f610", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1189c2fb6a72d95185f690d1ba4eb0729d6f610"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e57f05ccde7f0df34b70cd1d061d0350f362f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e57f05ccde7f0df34b70cd1d061d0350f362f2", "html_url": "https://github.com/rust-lang/rust/commit/26e57f05ccde7f0df34b70cd1d061d0350f362f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e57f05ccde7f0df34b70cd1d061d0350f362f2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2", "html_url": "https://github.com/rust-lang/rust/commit/89f6c4cfe2fee1ba2a9a89e0e03f88306dc343d2"}], "stats": {"total": 56, "additions": 25, "deletions": 31}, "files": [{"sha": "2808fc35e2a1b2d01215e8837b3679fa59fa3177", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26e57f05ccde7f0df34b70cd1d061d0350f362f2/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e57f05ccde7f0df34b70cd1d061d0350f362f2/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=26e57f05ccde7f0df34b70cd1d061d0350f362f2", "patch": "@@ -146,26 +146,22 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => must_use_attr(cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(cx.tcx.get_attrs(*did)).is_some(),\n-        ty::Slice(ty)\n-        | ty::Array(ty, _)\n-        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n-        | ty::Ref(_, ty, _) => {\n+        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n-        }\n+        },\n         ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder()\n-                {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n                     if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }\n             }\n             false\n-        }\n+        },\n         ty::Dynamic(binder, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n@@ -175,7 +171,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        }\n+        },\n         _ => false,\n     }\n }\n@@ -185,11 +181,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> bool {\n+pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n     is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n@@ -209,14 +201,15 @@ fn is_normalizable_helper<'tcx>(\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n                 ty::Adt(def, substs) => def.variants.iter().all(|variant| {\n-                    variant.fields.iter().all(|field| {\n-                        is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache)\n-                    })\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n                 }),\n                 _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    }\n+                    },\n                     _ => true, // if inner_ty == ty, we've already checked it\n                 }),\n             }\n@@ -234,9 +227,7 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => {\n-            is_recursively_primitive_type(inner_type)\n-        }\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -280,7 +271,11 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() { peel(ty, count + 1) } else { (ty, count) }\n+        if let ty::Ref(_, ty, _) = ty.kind() {\n+            peel(ty, count + 1)\n+        } else {\n+            (ty, count)\n+        }\n     }\n     peel(ty, 0)\n }\n@@ -335,18 +330,17 @@ pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n                 return false;\n             }\n \n-            substs_a.iter().zip(substs_b.iter()).all(|(arg_a, arg_b)| {\n-                match (arg_a.unpack(), arg_b.unpack()) {\n-                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => {\n-                        inner_a == inner_b\n-                    }\n+            substs_a\n+                .iter()\n+                .zip(substs_b.iter())\n+                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n                     (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n                         same_type_and_consts(type_a, type_b)\n-                    }\n+                    },\n                     _ => true,\n-                }\n-            })\n-        }\n+                })\n+        },\n         _ => a == b,\n     }\n }"}]}