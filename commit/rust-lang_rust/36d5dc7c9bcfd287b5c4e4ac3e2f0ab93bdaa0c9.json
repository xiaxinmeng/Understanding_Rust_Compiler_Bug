{"sha": "36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZDVkYzdjOWJjZmQyODdiNWM0ZTRhYzNlMmYwYWI5M2JkYWEwYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-27T05:46:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-27T05:46:08Z"}, "message": "Auto merge of #33864 - Manishearth:breaking-batch, r=Manishearth\n\nBatch up libsyntax breaking changes\n\ncc https://github.com/rust-lang/rust/issues/31645", "tree": {"sha": "7e1af7784abe1ebab1c219d13e1a57439eb91996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e1af7784abe1ebab1c219d13e1a57439eb91996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "html_url": "https://github.com/rust-lang/rust/commit/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97e3a2401e4b2f659d69ed0c0822cae04e3495b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/97e3a2401e4b2f659d69ed0c0822cae04e3495b7", "html_url": "https://github.com/rust-lang/rust/commit/97e3a2401e4b2f659d69ed0c0822cae04e3495b7"}, {"sha": "63dfbdbc1bc1ace106a525682f77b3d08af9ad71", "url": "https://api.github.com/repos/rust-lang/rust/commits/63dfbdbc1bc1ace106a525682f77b3d08af9ad71", "html_url": "https://github.com/rust-lang/rust/commit/63dfbdbc1bc1ace106a525682f77b3d08af9ad71"}], "stats": {"total": 1809, "additions": 1143, "deletions": 666}, "files": [{"sha": "810138e5a2983a0620adf6e635453ada53411d22", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -2433,6 +2433,8 @@ The currently implemented features of the reference compiler are:\n * - `abi_vectorcall` - Allows the usage of the vectorcall calling convention\n                              (e.g. `extern \"vectorcall\" func fn_();`)\n \n+* - `dotdot_in_tuple_patterns` - Allows `..` in tuple (struct) patterns.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "af47617ea92fda64456e8551e0d74591e7103159", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -100,7 +100,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Ident(_, _, None) |\n-            PatKind::TupleStruct(_, None) |\n             PatKind::Path(..) |\n             PatKind::QPath(..) |\n             PatKind::Lit(..) |\n@@ -116,8 +115,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            PatKind::TupleStruct(_, Some(ref subpats)) |\n-            PatKind::Tup(ref subpats) => {\n+            PatKind::TupleStruct(_, ref subpats, _) |\n+            PatKind::Tuple(ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }"}, {"sha": "641fe5f3b4747fddafbea65449c2325a8d1accea", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -923,9 +923,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n                 PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats) => {\n+                PatKind::TupleStruct(pth, pats, ddpos) => {\n                     PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n                 }\n                 PatKind::Path(pth) => {\n                     PatKind::Path(folder.fold_path(pth))\n@@ -948,7 +948,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                     });\n                     PatKind::Struct(pth, fs, etc)\n                 }\n-                PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+                PatKind::Tuple(elts, ddpos) => {\n+                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n+                }\n                 PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n                 PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n                 PatKind::Range(e1, e2) => {\n@@ -1009,11 +1011,15 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             ExprWhile(cond, body, opt_name) => {\n                 ExprWhile(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_name.map(|i| folder.fold_name(i)))\n+                          opt_name.map(|label| {\n+                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n+                          }))\n             }\n             ExprLoop(body, opt_name) => {\n                 ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|i| folder.fold_name(i)))\n+                         opt_name.map(|label| {\n+                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n+                         }))\n             }\n             ExprMatch(expr, arms, source) => {\n                 ExprMatch(folder.fold_expr(expr),"}, {"sha": "9b1d22436677f3b8d1baf67981e2d4e4d9f02413", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -28,7 +28,7 @@\n use syntax::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::attr::ThinAttributesExt;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Spanned};\n use hir::*;\n \n use std::cmp;\n@@ -203,11 +203,17 @@ pub trait Visitor<'v> : Sized {\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    for name in opt_name {\n+    if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n+pub fn walk_opt_sp_name<'v, V: Visitor<'v>>(visitor: &mut V, opt_sp_name: &Option<Spanned<Name>>) {\n+    if let Some(ref sp_name) = *opt_sp_name {\n+        visitor.visit_name(sp_name.span, sp_name.node);\n+    }\n+}\n+\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n@@ -454,11 +460,9 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *opt_children {\n-                walk_list!(visitor, visit_pat, children);\n-            }\n+            walk_list!(visitor, visit_pat, children);\n         }\n         PatKind::Path(ref path) => {\n             visitor.visit_path(path, pattern.id);\n@@ -474,7 +478,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatKind::Tup(ref tuple_elements) => {\n+        PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |\n@@ -737,14 +741,14 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprWhile(ref subexpression, ref block, opt_name) => {\n+        ExprWhile(ref subexpression, ref block, ref opt_sp_name) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_name(visitor, expression.span, opt_name)\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, opt_name) => {\n+        ExprLoop(ref block, ref opt_sp_name) => {\n             visitor.visit_block(block);\n-            walk_opt_name(visitor, expression.span, opt_name)\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(subexpression);\n@@ -784,9 +788,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprBreak(ref opt_sp_name) | ExprAgain(ref opt_sp_name) => {\n-            for sp_name in opt_sp_name {\n-                visitor.visit_name(sp_name.span, sp_name.node);\n-            }\n+            walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "ea9a76d982a3aea2dc14f19ca47ce27f6d2feeb3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -192,6 +192,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n+        o_id.map(|sp_ident| respan(sp_ident.span, self.lower_ident(sp_ident.node)))\n+    }\n+\n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n         attrs.clone().into()\n     }\n@@ -269,7 +273,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                Infer => hir::TyInfer,\n+                Infer | ImplicitSelf => hir::TyInfer,\n                 Vec(ref ty) => hir::TyVec(self.lower_ty(ty)),\n                 Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 Rptr(ref region, ref mt) => {\n@@ -787,23 +791,24 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n-        // Check for `self: _` and `self: &_`\n-        if let SelfKind::Explicit(ref ty, _) = sig.explicit_self.node {\n-            match sig.decl.inputs.get(0).and_then(Arg::to_self).map(|eself| eself.node) {\n-                Some(SelfKind::Value(..)) | Some(SelfKind::Region(..)) => {\n-                    self.id_assigner.diagnostic().span_err(ty.span,\n-                        \"the type placeholder `_` is not allowed within types on item signatures\");\n-                }\n-                _ => {}\n-            }\n-        }\n-        hir::MethodSig {\n+        let hir_sig = hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),\n+        };\n+        // Check for `self: _` and `self: &_`\n+        if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n+            match hir_sig.decl.get_self().map(|eself| eself.node) {\n+                Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n+                    self.id_assigner.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n+                        \"the type placeholder `_` is not allowed within types on item signatures\");\n+                }\n+                _ => {}\n+            }\n         }\n+        hir_sig\n     }\n \n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n@@ -872,10 +877,10 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref pth, ref pats) => {\n+                PatKind::TupleStruct(ref pth, ref pats, ddpos) => {\n                     hir::PatKind::TupleStruct(self.lower_path(pth),\n-                                 pats.as_ref()\n-                                     .map(|pats| pats.iter().map(|x| self.lower_pat(x)).collect()))\n+                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                              ddpos)\n                 }\n                 PatKind::Path(ref pth) => {\n                     hir::PatKind::Path(self.lower_path(pth))\n@@ -903,8 +908,8 @@ impl<'a> LoweringContext<'a> {\n                                    .collect();\n                     hir::PatKind::Struct(pth, fs, etc)\n                 }\n-                PatKind::Tup(ref elts) => {\n-                    hir::PatKind::Tup(elts.iter().map(|x| self.lower_pat(x)).collect())\n+                PatKind::Tuple(ref elts, ddpos) => {\n+                    hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n                 }\n                 PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n                 PatKind::Ref(ref inner, mutbl) => {\n@@ -1122,11 +1127,10 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::While(ref cond, ref body, opt_ident) => {\n                     hir::ExprWhile(self.lower_expr(cond), self.lower_block(body),\n-                                   opt_ident.map(|ident| self.lower_ident(ident)))\n+                                   self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body),\n-                                  opt_ident.map(|ident| self.lower_ident(ident)))\n+                    hir::ExprLoop(self.lower_block(body), self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(self.lower_expr(expr),\n@@ -1243,12 +1247,8 @@ impl<'a> LoweringContext<'a> {\n                     };\n                     hir::ExprPath(hir_qself, self.lower_path_full(path, rename))\n                 }\n-                ExprKind::Break(opt_ident) => hir::ExprBreak(opt_ident.map(|sp_ident| {\n-                    respan(sp_ident.span, self.lower_ident(sp_ident.node))\n-                })),\n-                ExprKind::Again(opt_ident) => hir::ExprAgain(opt_ident.map(|sp_ident| {\n-                    respan(sp_ident.span, self.lower_ident(sp_ident.node))\n-                })),\n+                ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Again(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| self.lower_expr(x))),\n                 ExprKind::InlineAsm(InlineAsm {\n                         ref inputs,\n@@ -1422,8 +1422,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| self.lower_ident(ident)));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     // add attributes to the outer returned expr node\n                     let attrs = e.attrs.clone();\n                     return P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs });\n@@ -1503,8 +1502,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = self.block_expr(match_expr);\n-                    let loop_expr = hir::ExprLoop(loop_block,\n-                                                  opt_ident.map(|ident| self.lower_ident(ident)));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n                     let loop_expr =\n                         P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n \n@@ -1857,7 +1855,7 @@ impl<'a> LoweringContext<'a> {\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(path)\n         } else {\n-            hir::PatKind::TupleStruct(path, Some(subpats))\n+            hir::PatKind::TupleStruct(path, subpats, None)\n         };\n         let pat = self.pat(span, pt);\n         self.resolver.record_resolution(pat.id, def);"}, {"sha": "ea52a393da6c7671701b9ee313ac16bc9a12d22a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -470,7 +470,7 @@ impl Pat {\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk_(it))\n             }\n-            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n             }\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n@@ -485,7 +485,6 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n-            PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) => {\n                 true\n@@ -539,9 +538,10 @@ pub enum PatKind {\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n \n-    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n-    /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    TupleStruct(Path, Option<HirVec<P<Pat>>>),\n+    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n+    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n \n     /// A path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n@@ -553,8 +553,10 @@ pub enum PatKind {\n     /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n-    /// A tuple pattern `(a, b)`\n-    Tup(HirVec<P<Pat>>),\n+    /// A tuple pattern `(a, b)`.\n+    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    Tuple(HirVec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n@@ -873,11 +875,11 @@ pub enum Expr_ {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    ExprWhile(P<Expr>, P<Block>, Option<Name>),\n+    ExprWhile(P<Expr>, P<Block>, Option<Spanned<Name>>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Name>),\n+    ExprLoop(P<Block>, Option<Spanned<Name>>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -1175,6 +1177,9 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n+    pub fn get_self(&self) -> Option<ExplicitSelf> {\n+        self.inputs.get(0).and_then(Arg::to_self)\n+    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n     }"}, {"sha": "1008ba7a6e6a037b7fda5c239cd9698f7e632baf", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -18,9 +18,43 @@ use hir::{self, PatKind};\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n use std::cell::RefCell;\n+use std::iter::{Enumerate, ExactSizeIterator};\n \n pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n \n+pub struct EnumerateAndAdjust<I> {\n+    enumerate: Enumerate<I>,\n+    gap_pos: usize,\n+    gap_len: usize,\n+}\n+\n+impl<I> Iterator for EnumerateAndAdjust<I> where I: Iterator {\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.enumerate.next().map(|(i, elem)| {\n+            (if i < self.gap_pos { i } else { i + self.gap_len }, elem)\n+        })\n+    }\n+}\n+\n+pub trait EnumerateAndAdjustIterator {\n+    fn enumerate_and_adjust(self, expected_len: usize, gap_pos: Option<usize>)\n+        -> EnumerateAndAdjust<Self> where Self: Sized;\n+}\n+\n+impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n+    fn enumerate_and_adjust(self, expected_len: usize, gap_pos: Option<usize>)\n+            -> EnumerateAndAdjust<Self> where Self: Sized {\n+        let actual_len = self.len();\n+        EnumerateAndAdjust {\n+            enumerate: self.enumerate(),\n+            gap_pos: if let Some(gap_pos) = gap_pos { gap_pos } else { expected_len },\n+            gap_len: expected_len - actual_len,\n+        }\n+    }\n+}\n+\n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {"}, {"sha": "a9ed83d9dc3158a4e760736e944e002486c115d7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -1351,19 +1351,19 @@ impl<'a> State<'a> {\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n-            hir::ExprWhile(ref test, ref blk, opt_name) => {\n-                if let Some(name) = opt_name {\n-                    self.print_name(name)?;\n+            hir::ExprWhile(ref test, ref blk, opt_sp_name) => {\n+                if let Some(sp_name) = opt_sp_name {\n+                    self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(&test)?;\n                 space(&mut self.s)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_name) => {\n-                if let Some(name) = opt_name {\n-                    self.print_name(name)?;\n+            hir::ExprLoop(ref blk, opt_sp_name) => {\n+                if let Some(sp_name) = opt_sp_name {\n+                    self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -1736,16 +1736,23 @@ impl<'a> State<'a> {\n                     None => (),\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n                 self.print_path(path, true, 0)?;\n-                match *args_ {\n-                    None => word(&mut self.s, \"(..)\")?,\n-                    Some(ref args) => {\n-                        self.popen()?;\n-                        self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p))?;\n-                        self.pclose()?;\n+                self.popen()?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n+                } else {\n+                    try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 }\n+                try!(self.pclose());\n             }\n             PatKind::Path(ref path) => {\n                 self.print_path(path, true, 0)?;\n@@ -1778,11 +1785,23 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 word(&mut self.s, \"}\")?;\n             }\n-            PatKind::Tup(ref elts) => {\n+            PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n-                self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n-                if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                    }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    if elts.len() == 1 {\n+                        word(&mut self.s, \",\")?;\n+                    }\n                 }\n                 self.pclose()?;\n             }"}, {"sha": "94f17ea779ac8827b86c9176de71b52057d364c1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -1043,11 +1043,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         run_lints!(self, check_lifetime_def, early_passes, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n-        run_lints!(self, check_explicit_self, early_passes, es);\n-        ast_visit::walk_explicit_self(self, es);\n-    }\n-\n     fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n         ast_visit::walk_path(self, p);"}, {"sha": "cc7fa54bd0a5ef6f7959f9b6a2108f6e2f4c51d8", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -167,7 +167,6 @@ pub trait LateLintPass: LintPass {\n     fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n     fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &LateContext, _: &hir::ExplicitSelf) { }\n     fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n     fn check_path_list_item(&mut self, _: &LateContext, _: &hir::PathListItem) { }\n     fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n@@ -218,7 +217,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n     fn check_path_list_item(&mut self, _: &EarlyContext, _: &ast::PathListItem) { }\n     fn check_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }"}, {"sha": "b0add5a23dc4638fa14017093f61ae489c11e3ad", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // will visit the substructure recursively.\n                 }\n \n-                PatKind::Wild | PatKind::Tup(..) | PatKind::Box(..) |\n+                PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n                 PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n                 PatKind::Vec(..) => {\n                     // Similarly, each of these cases does not"}, {"sha": "e933b22f60799cb759137dd84f83154b77524fdf", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -80,6 +80,7 @@ use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n \n use hir::{MutImmutable, MutMutable, PatKind};\n+use hir::pat_util::EnumerateAndAdjustIterator;\n use hir;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -1225,14 +1226,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // _\n           }\n \n-          PatKind::TupleStruct(_, None) => {\n-            // variant(..)\n-          }\n-          PatKind::TupleStruct(_, Some(ref subpats)) => {\n+          PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             match opt_def {\n-                Some(Def::Variant(..)) => {\n+                Some(Def::Variant(enum_def, def_id)) => {\n                     // variant(x, y, z)\n-                    for (i, subpat) in subpats.iter().enumerate() {\n+                    let expected_len = self.tcx().lookup_adt_def(enum_def)\n+                                                 .variant_with_id(def_id).fields.len();\n+                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                         let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n \n                         let subcmt =\n@@ -1244,7 +1244,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n-                    for (i, subpat) in subpats.iter().enumerate() {\n+                    let expected_len = match self.pat_ty(&pat) {\n+                        Ok(&ty::TyS{sty: ty::TyStruct(adt_def, _), ..}) => {\n+                            adt_def.struct_variant().fields.len()\n+                        }\n+                        ref ty => {\n+                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n+                        }\n+                    };\n+\n+                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                         let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n@@ -1284,9 +1293,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Tup(ref subpats) => {\n+          PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n-            for (i, subpat) in subpats.iter().enumerate() {\n+            let expected_len = match self.pat_ty(&pat) {\n+                Ok(&ty::TyS{sty: ty::TyTuple(ref tys), ..}) => tys.len(),\n+                ref ty => span_bug!(pat.span, \"tuple pattern unexpected type {:?}\", ty),\n+            };\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior("}, {"sha": "6b2c2dfcd72b48375c57d501c9d89015db6610cb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -970,8 +970,8 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            PatKind::TupleStruct(_, Some(ref subpats)) |\n-            PatKind::Tup(ref subpats) => {\n+            PatKind::TupleStruct(_, ref subpats, _) |\n+            PatKind::Tuple(ref subpats, _) => {\n                 subpats.iter().any(|p| is_binding_pat(&p))\n             }\n "}, {"sha": "4cc9b0b4353a0b2da14878c789d888979c7df2c7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -404,23 +404,23 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n             if let hir::ExprClosure(..) = ex.node {\n                 return\n             }\n-            if let Some(label) = expression_label(ex) {\n+            if let Some((label, label_span)) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n                     if label == prior {\n                         signal_shadowing_problem(self.sess,\n                                                  label,\n                                                  original_label(prior_span),\n-                                                 shadower_label(ex.span));\n+                                                 shadower_label(label_span));\n                     }\n                 }\n \n                 check_if_label_shadows_lifetime(self.sess,\n                                                 self.scope,\n                                                 label,\n-                                                ex.span);\n+                                                label_span);\n \n-                self.labels_in_fn.push((label, ex.span));\n+                self.labels_in_fn.push((label, label_span));\n             }\n             intravisit::walk_expr(self, ex)\n         }\n@@ -430,10 +430,11 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v hir::Block) {\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<ast::Name> {\n+    fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(_, _, Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some(label.unhygienize()),\n+            hir::ExprLoop(_, Some(label)) => Some((label.node.unhygienize(),\n+                                                   label.span)),\n             _ => None,\n         }\n     }"}, {"sha": "fcb03aba6d12cb6434c413789954f88caa1cf431", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -33,6 +33,7 @@ use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n use hir;\n use hir::{Item, Generics, StructField, Variant, PatKind};\n use hir::intravisit::{self, Visitor};\n+use hir::pat_util::EnumerateAndAdjustIterator;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -614,10 +615,9 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        // A Variant(..) pattern `PatKind::TupleStruct(_, None)` doesn't have to be recursed into.\n-        PatKind::TupleStruct(_, Some(ref pat_fields)) => {\n-            for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n-                maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n+        PatKind::TupleStruct(_, ref pat_fields, ddpos) => {\n+            for (i, field) in pat_fields.iter().enumerate_and_adjust(v.fields.len(), ddpos) {\n+                maybe_do_stability_check(tcx, v.fields[i].did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }"}, {"sha": "16b61534ee9abb4bb3fcc1d73c1a5c987354f8cf", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -374,7 +374,7 @@ fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n         PatKind::Ident(_, _, None) => pat_is_binding(dm, p),\n         PatKind::Ident(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n-        PatKind::Tup(ref v) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n+        PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n         _ => false\n     }\n }\n@@ -398,7 +398,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n+                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => bug!(),\n                         },\n@@ -559,7 +559,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::TyTuple(_) => PatKind::Tup(pats.collect()),\n+        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = ctor.variant_for_adt(adt);\n@@ -580,7 +580,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n                 }\n                 VariantKind::Tuple => {\n-                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n                 VariantKind::Unit => {\n                     PatKind::Path(def_to_path(cx.tcx, v.did))\n@@ -832,7 +832,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        PatKind::Box(_) | PatKind::Tup(_) | PatKind::Ref(..) =>\n+        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n             vec!(Single),\n         PatKind::Wild =>\n             vec!(),\n@@ -914,18 +914,23 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        PatKind::TupleStruct(_, ref args) => {\n+        PatKind::TupleStruct(_, ref args, ddpos) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n-                    Some(match args {\n-                        &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => vec![DUMMY_WILD_PAT; arity],\n-                    })\n+                    match ddpos {\n+                        Some(ddpos) => {\n+                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n+                            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n+                            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+                            Some(pats)\n+                        }\n+                        None => Some(args.iter().map(|p| &**p).collect())\n+                    }\n                 }\n                 _ => None\n             }\n@@ -952,7 +957,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        PatKind::Tup(ref args) =>\n+        PatKind::Tuple(ref args, Some(ddpos)) => {\n+            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| &**p).collect();\n+            pats.extend(repeat(DUMMY_WILD_PAT).take(arity - args.len()));\n+            pats.extend(args[ddpos..].iter().map(|p| &**p));\n+            Some(pats)\n+        }\n+        PatKind::Tuple(ref args, None) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n         PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>"}, {"sha": "b727b778fcd791495897af9f77d0829fd29a9e1b", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -271,10 +271,9 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            PatKind::Tup(try!(exprs.iter()\n-                                  .map(|expr| const_expr_to_pat(tcx, &expr,\n-                                                                pat_id, span))\n-                                  .collect())),\n+            PatKind::Tuple(try!(exprs.iter()\n+                                     .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n+                                     .collect()), None),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -295,7 +294,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 .map(|expr| const_expr_to_pat(tcx, &**expr,\n                                                               pat_id, span))\n                                 .collect());\n-            PatKind::TupleStruct(path, Some(pats))\n+            PatKind::TupleStruct(path, pats, None)\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {"}, {"sha": "0a093887c509413a0b2884798c4efe4fd44d3ccf", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -757,6 +757,7 @@ fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n                   .get_filemap(&src_name)\n+                  .unwrap()\n                   .src\n                   .as_ref()\n                   .unwrap()"}, {"sha": "3dd1b6eb205d4f501585b1db83022dc0ff5702d4", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -251,7 +251,7 @@ mod svh_visitor {\n             ExprType(..)             => SawExprType,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.as_str())),\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.node.as_str())),\n             ExprMatch(..)            => SawExprMatch,\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,"}, {"sha": "b9ba860e8d0aad4ca909bf30a3f0315ebc263f8a", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const, pat_is_binding};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -148,17 +148,23 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Tup(ref subpatterns) => {\n-                let subpatterns =\n-                    subpatterns.iter()\n-                               .enumerate()\n-                               .map(|(i, subpattern)| FieldPattern {\n-                                   field: Field::new(i),\n-                                   pattern: self.to_pattern(subpattern),\n-                               })\n-                               .collect();\n+            PatKind::Tuple(ref subpatterns, ddpos) => {\n+                match self.cx.tcx.node_id_to_type(pat.id).sty {\n+                    ty::TyTuple(ref tys) => {\n+                        let subpatterns =\n+                            subpatterns.iter()\n+                                       .enumerate_and_adjust(tys.len(), ddpos)\n+                                       .map(|(i, subpattern)| FieldPattern {\n+                                            field: Field::new(i),\n+                                            pattern: self.to_pattern(subpattern),\n+                                       })\n+                                       .collect();\n+\n+                        PatternKind::Leaf { subpatterns: subpatterns }\n+                    }\n \n-                PatternKind::Leaf { subpatterns: subpatterns }\n+                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n+                }\n             }\n \n             PatKind::Ident(bm, ref ident, ref sub)\n@@ -208,11 +214,18 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 self.variant_or_leaf(pat, vec![])\n             }\n \n-            PatKind::TupleStruct(_, ref opt_subpatterns) => {\n+            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n+                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to struct or enum\"),\n+                };\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+                let variant_def = adt_def.variant_of_def(def);\n+\n                 let subpatterns =\n-                    opt_subpatterns.iter()\n-                                   .flat_map(|v| v.iter())\n-                                   .enumerate()\n+                        subpatterns.iter()\n+                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n                                    .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n                                        pattern: self.to_pattern(field),"}, {"sha": "c90d152e3c314fe726f875fd76529993acabb087", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -31,7 +31,7 @@ use std::mem::replace;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::{self, Visitor};\n-\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::dep_graph::DepNode;\n use rustc::lint;\n use rustc::hir::def::{self, Def};\n@@ -488,13 +488,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n-\n-            // Patterns which bind no fields are allowable (the path is check\n-            // elsewhere).\n-            PatKind::TupleStruct(_, Some(ref fields)) => {\n+            PatKind::TupleStruct(_, ref fields, ddpos) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n-                        for (i, field) in fields.iter().enumerate() {\n+                        let expected_len = def.struct_variant().fields.len();\n+                        for (i, field) in fields.iter().enumerate_and_adjust(expected_len, ddpos) {\n                             if let PatKind::Wild = field.node {\n                                 continue\n                             }\n@@ -506,7 +504,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                     _ => {}\n                 }\n-\n             }\n             _ => {}\n         }"}, {"sha": "e0243bf4fa690eeae1171b56973d5dc03676daf9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -35,7 +35,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast::{Block, Crate, DeclKind};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{SelfKind, Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n@@ -335,7 +335,7 @@ impl<'b> Resolver<'b> {\n                     let (def, ns) = match item.node {\n                         TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n                         TraitItemKind::Method(ref sig, _) => {\n-                            is_static_method = sig.explicit_self.node == SelfKind::Static;\n+                            is_static_method = !sig.decl.has_self();\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n                         TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),"}, {"sha": "2444f6acced24d6740af757f61d8869ebc5c375e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -67,7 +67,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, SelfKind, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -607,7 +607,7 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n-                MethodRibKind(sig.explicit_self.node == SelfKind::Static)\n+                MethodRibKind(!sig.decl.has_self())\n             }\n             FnKind::Closure => ClosureRibKind(node_id),\n         };\n@@ -1676,9 +1676,7 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind(\n-                                                             sig.explicit_self.node ==\n-                                                             SelfKind::Static));\n+                                                          MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n@@ -2007,9 +2005,7 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind(\n-                                                            sig.explicit_self.node ==\n-                                                            SelfKind::Static));\n+                                                          MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_impl_item(this, impl_item);\n                                     });\n@@ -2360,7 +2356,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                PatKind::TupleStruct(ref path, _) | PatKind::Path(ref path) => {\n+                PatKind::TupleStruct(ref path, _, _) | PatKind::Path(ref path) => {\n                     // This must be an enum variant, struct or const.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n@@ -3128,7 +3124,7 @@ impl<'a> Resolver<'a> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(mtwt::resolve(label), def);\n+                        rib.bindings.insert(mtwt::resolve(label.node), def);\n                     }\n \n                     visit::walk_expr(this, expr);\n@@ -3173,7 +3169,7 @@ impl<'a> Resolver<'a> {\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n \n-                self.resolve_labeled_block(label, expr.id, block);\n+                self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n                 self.value_ribs.pop();\n             }\n@@ -3183,7 +3179,7 @@ impl<'a> Resolver<'a> {\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n \n-                self.resolve_labeled_block(label, expr.id, block);\n+                self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n                 self.value_ribs.pop();\n             }"}, {"sha": "7b0ae100f058ff124ebee42269a5c6c99f832c08", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -696,7 +696,7 @@ impl<'v> Visitor<'v> for PathCollector {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::TypeRef));\n             }\n-            PatKind::TupleStruct(ref path, _) |\n+            PatKind::TupleStruct(ref path, _, _) |\n             PatKind::Path(ref path) |\n             PatKind::QPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),"}, {"sha": "4b22e410f4c227993a1ccba465753104341b7261", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -792,7 +792,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n-            PatKind::Tup(_) => true,\n+            PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) |\n             PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n                 match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n@@ -1833,7 +1833,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n-        PatKind::TupleStruct(_, ref sub_pats) => {\n+        PatKind::TupleStruct(_, ref sub_pats, ddpos) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Variant(enum_id, var_id)) => {\n@@ -1843,35 +1843,34 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     &repr,\n                                                     Disr::from(vinfo.disr_val),\n                                                     val);\n-                    if let Some(ref sub_pat) = *sub_pats {\n-                        for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(\n-                                bcx,\n-                                &sub_pat[i],\n-                                MatchInput::from_val(argval),\n-                                cleanup_scope);\n-                        }\n+                    for (i, subpat) in sub_pats.iter()\n+                                               .enumerate_and_adjust(vinfo.fields.len(), ddpos) {\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            subpat,\n+                            MatchInput::from_val(args.vals[i]),\n+                            cleanup_scope);\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n-                    match *sub_pats {\n-                        None => {\n-                            // This is a unit-like struct. Nothing to do here.\n+                    let expected_len = match *ccx.tcx().pat_ty(&pat) {\n+                        ty::TyS{sty: ty::TyStruct(adt_def, _), ..} => {\n+                            adt_def.struct_variant().fields.len()\n                         }\n-                        Some(ref elems) => {\n-                            // This is the tuple struct case.\n-                            let repr = adt::represent_node(bcx, pat.id);\n-                            let val = adt::MaybeSizedValue::sized(val.val);\n-                            for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, &repr,\n-                                                                  val, Disr(0), i);\n-                                bcx = bind_irrefutable_pat(\n-                                    bcx,\n-                                    &elem,\n-                                    MatchInput::from_val(fldptr),\n-                                    cleanup_scope);\n-                            }\n+                        ref ty => {\n+                            span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n                         }\n+                    };\n+\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let val = adt::MaybeSizedValue::sized(val.val);\n+                    for (i, elem) in sub_pats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                        let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            &elem,\n+                            MatchInput::from_val(fldptr),\n+                            cleanup_scope);\n                     }\n                 }\n                 _ => {\n@@ -1919,16 +1918,21 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            cleanup_scope);\n             }\n         }\n-        PatKind::Tup(ref elems) => {\n-            let repr = adt::represent_node(bcx, pat.id);\n-            let val = adt::MaybeSizedValue::sized(val.val);\n-            for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n-                bcx = bind_irrefutable_pat(\n-                    bcx,\n-                    &elem,\n-                    MatchInput::from_val(fldptr),\n-                    cleanup_scope);\n+        PatKind::Tuple(ref elems, ddpos) => {\n+            match tcx.node_id_to_type(pat.id).sty {\n+                ty::TyTuple(ref tys) => {\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let val = adt::MaybeSizedValue::sized(val.val);\n+                    for (i, elem) in elems.iter().enumerate_and_adjust(tys.len(), ddpos) {\n+                        let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n+                        bcx = bind_irrefutable_pat(\n+                            bcx,\n+                            &elem,\n+                            MatchInput::from_val(fldptr),\n+                            cleanup_scope);\n+                    }\n+                }\n+                ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n             }\n         }\n         PatKind::Box(ref inner) => {"}, {"sha": "aec43e69e5182bfe166829dc95fab4819a9e82dc", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -318,13 +318,11 @@ fn walk_pattern(cx: &CrateContext,\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        PatKind::TupleStruct(_, ref sub_pats_opt) => {\n+        PatKind::TupleStruct(_, ref sub_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-            if let Some(ref sub_pats) = *sub_pats_opt {\n-                for p in sub_pats {\n-                    walk_pattern(cx, &p, scope_stack, scope_map);\n-                }\n+            for p in sub_pats {\n+                walk_pattern(cx, &p, scope_stack, scope_map);\n             }\n         }\n \n@@ -343,7 +341,7 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        PatKind::Tup(ref sub_pats) => {\n+        PatKind::Tuple(ref sub_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {"}, {"sha": "fc1abb56d5abc61631dc42a8f7decb9d8b4136fa", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -1833,8 +1833,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let explicit_self = decl.inputs.get(0).and_then(hir::Arg::to_self);\n-        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, explicit_self) {\n+        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, decl.get_self()) {\n             (Some(untransformed_self_ty), Some(explicit_self)) => {\n                 let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n                                                          &explicit_self);"}, {"sha": "9030a6f222b853ce3656c068393076dd04e8f739", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -11,7 +11,7 @@\n use hir::def::{self, Def};\n use rustc::infer::{self, InferOk, TypeOrigin};\n use hir::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n-use hir::pat_util::pat_is_resolved_const;\n+use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n use check::{FnCtxt, Expectation};\n@@ -213,13 +213,13 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::Ident(_, ref path, _) => {\n                 let path = hir::Path::from_name(path.span, path.node);\n-                self.check_pat_enum(pat, &path, Some(&[]), expected, false);\n+                self.check_pat_enum(pat, &path, &[], None, expected, false);\n             }\n-            PatKind::TupleStruct(ref path, ref subpats) => {\n-                self.check_pat_enum(pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+            PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n+                self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n             }\n             PatKind::Path(ref path) => {\n-                self.check_pat_enum(pat, path, Some(&[]), expected, false);\n+                self.check_pat_enum(pat, path, &[], None, expected, false);\n             }\n             PatKind::QPath(ref qself, ref path) => {\n                 let self_ty = self.to_ty(&qself.ty);\n@@ -260,14 +260,23 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Struct(ref path, ref fields, etc) => {\n                 self.check_pat_struct(pat, path, fields, etc, expected);\n             }\n-            PatKind::Tup(ref elements) => {\n-                let element_tys: Vec<_> =\n-                    (0..elements.len()).map(|_| self.next_ty_var()).collect();\n+            PatKind::Tuple(ref elements, ddpos) => {\n+                let mut expected_len = elements.len();\n+                if ddpos.is_some() {\n+                    // Require known type only when `..` is present\n+                    if let ty::TyTuple(ref tys) =\n+                            self.structurally_resolved_type(pat.span, expected).sty {\n+                        expected_len = tys.len();\n+                    }\n+                }\n+                let max_len = cmp::max(expected_len, elements.len());\n+\n+                let element_tys: Vec<_> = (0 .. max_len).map(|_| self.next_ty_var()).collect();\n                 let pat_ty = tcx.mk_tup(element_tys.clone());\n                 self.write_ty(pat.id, pat_ty);\n                 self.demand_eqtype(pat.span, expected, pat_ty);\n-                for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                    self.check_pat(&element_pat, element_ty);\n+                for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                    self.check_pat(elem, &element_tys[i]);\n                 }\n             }\n             PatKind::Box(ref inner) => {\n@@ -615,7 +624,8 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n     fn check_pat_enum(&self,\n                       pat: &hir::Pat,\n                       path: &hir::Path,\n-                      subpats: Option<&'gcx [P<hir::Pat>]>,\n+                      subpats: &'gcx [P<hir::Pat>],\n+                      ddpos: Option<usize>,\n                       expected: Ty<'tcx>,\n                       is_tuple_struct_pat: bool)\n     {\n@@ -628,12 +638,9 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 self.write_error(pat.id);\n \n-                if let Some(subpats) = subpats {\n-                    for pat in subpats {\n-                        self.check_pat(&pat, tcx.types.err);\n-                    }\n+                for pat in subpats {\n+                    self.check_pat(&pat, tcx.types.err);\n                 }\n-\n                 return;\n             }\n         };\n@@ -670,15 +677,12 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         };\n         self.instantiate_path(segments, path_scheme, &ctor_predicates,\n                               opt_ty, def, pat.span, pat.id);\n-\n         let report_bad_struct_kind = |is_warning| {\n             bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n             if is_warning { return; }\n             self.write_error(pat.id);\n-            if let Some(subpats) = subpats {\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         };\n \n@@ -715,42 +719,35 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         match (is_tuple_struct_pat, variant.kind()) {\n-            (true, ty::VariantKind::Unit) => {\n+            (true, ty::VariantKind::Unit) if subpats.is_empty() && ddpos.is_some() => {\n                 // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n                 // is allowed for backward compatibility.\n                 report_bad_struct_kind(true);\n             }\n+            (true, ty::VariantKind::Unit) |\n+            (false, ty::VariantKind::Tuple) |\n             (_, ty::VariantKind::Struct) => {\n                 report_bad_struct_kind(false);\n                 return\n             }\n             _ => {}\n         }\n \n-        if let Some(subpats) = subpats {\n-            if subpats.len() == variant.fields.len() {\n-                for (subpat, field) in subpats.iter().zip(&variant.fields) {\n-                    let field_ty = self.field_ty(subpat.span, field, expected_substs);\n-                    self.check_pat(&subpat, field_ty);\n-                }\n-            } else if variant.fields.is_empty() {\n-                span_err!(tcx.sess, pat.span, E0024,\n-                          \"this pattern has {} field{}, but the corresponding {} has no fields\",\n-                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n-\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n-            } else {\n-                span_err!(tcx.sess, pat.span, E0023,\n-                          \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                          subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                          kind_name,\n-                          variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n-\n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n+        if subpats.len() == variant.fields.len() ||\n+                subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], expected_substs);\n+                self.check_pat(&subpat, field_ty);\n+            }\n+        } else {\n+            span_err!(tcx.sess, pat.span, E0023,\n+                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n+                      kind_name,\n+                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n         }\n     }"}, {"sha": "77ff818aa881a8252ae0ad0576d84bb417dadec8", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -62,31 +62,6 @@ Check how many fields the enum was declared with and ensure that your pattern\n uses the same number.\n \"##,\n \n-E0024: r##\"\n-This error indicates that a pattern attempted to extract the fields of an enum\n-variant with no fields. Here's a tiny example of this error:\n-\n-```compile_fail\n-// This enum has two variants.\n-enum Number {\n-    // This variant has no fields.\n-    Zero,\n-    // This variant has one field.\n-    One(u32)\n-}\n-\n-// Assuming x is a Number we can pattern match on its contents.\n-match x {\n-    Number::Zero(inside) => {},\n-    Number::One(inside) => {},\n-}\n-```\n-\n-The pattern match `Zero(inside)` is incorrect because the `Zero` variant\n-contains no fields, yet the `inside` name attempts to bind the first field of\n-the enum.\n-\"##,\n-\n E0025: r##\"\n Each field of a struct can only be bound once in a pattern. Erroneous code\n example:"}, {"sha": "4831ee9a2e041a5e6950d350b4e74cf7070bd604", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -2579,7 +2579,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Ident(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, _) | PatKind::Path(ref p) => path_to_string(p),\n+        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n         PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),\n         PatKind::Struct(ref name, ref fields, etc) => {\n@@ -2590,7 +2590,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n                 if etc { \", ...\" } else { \"\" }\n             )\n         },\n-        PatKind::Tup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),\n         PatKind::Ref(ref p, _) => name_from_pat(&**p),"}, {"sha": "9ecaa5b346af4f04c57a79f8b07cc2b50521a0c2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -567,7 +567,7 @@ impl Pat {\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk(it))\n             }\n-            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n+            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n@@ -582,7 +582,6 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Ident(_, _, _) |\n-            PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) |\n             PatKind::Mac(_) => {\n@@ -631,9 +630,10 @@ pub enum PatKind {\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(Path, Vec<Spanned<FieldPat>>, bool),\n \n-    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n-    /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    TupleStruct(Path, Option<Vec<P<Pat>>>),\n+    /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n+    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    TupleStruct(Path, Vec<P<Pat>>, Option<usize>),\n \n     /// A path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n@@ -645,8 +645,10 @@ pub enum PatKind {\n     /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n-    /// A tuple pattern `(a, b)`\n-    Tup(Vec<P<Pat>>),\n+    /// A tuple pattern `(a, b)`.\n+    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n+    /// 0 <= position <= subpats.len()\n+    Tuple(Vec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n@@ -1007,23 +1009,23 @@ pub enum ExprKind {\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n-    While(P<Expr>, P<Block>, Option<Ident>),\n+    While(P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    WhileLet(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n-    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n+    ForLoop(P<Pat>, P<Expr>, P<Block>, Option<SpannedIdent>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    Loop(P<Block>, Option<Ident>),\n+    Loop(P<Block>, Option<SpannedIdent>),\n     /// A `match` block.\n     Match(P<Expr>, Vec<Arm>),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n@@ -1387,7 +1389,6 @@ pub struct MethodSig {\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1638,6 +1639,8 @@ pub enum TyKind {\n     /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n+    /// Inferred type of a `self` or `&self` argument in a method.\n+    ImplicitSelf,\n     // A macro in the type position.\n     Mac(Mac),\n }\n@@ -1677,81 +1680,65 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n-/// Represents the kind of 'self' associated with a method.\n-/// String representation of `Ident` here is always \"self\", but hygiene contexts may differ.\n+/// Alternative representation for `Arg`s describing `self` parameter of methods.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SelfKind {\n-    /// No self\n-    Static,\n     /// `self`, `mut self`\n-    Value(Ident),\n+    Value(Mutability),\n     /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability, Ident),\n+    Region(Option<Lifetime>, Mutability),\n     /// `self: TYPE`, `mut self: TYPE`\n-    Explicit(P<Ty>, Ident),\n+    Explicit(P<Ty>, Mutability),\n }\n \n pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.10.0\", reason = \"use `from_self` instead\")]\n-    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n-        let path = Spanned{span:span,node:self_ident};\n-        Arg {\n-            // HACK(eddyb) fake type for the self argument.\n-            ty: P(Ty {\n-                id: DUMMY_NODE_ID,\n-                node: TyKind::Infer,\n-                span: DUMMY_SP,\n-            }),\n-            pat: P(Pat {\n-                id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(mutability), path, None),\n-                span: span\n-            }),\n-            id: DUMMY_NODE_ID\n-        }\n-    }\n-\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n             if ident.node.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n-                    TyKind::Infer => Some(respan(self.pat.span, SelfKind::Value(ident.node))),\n-                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::Infer => {\n-                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl, ident.node)))\n+                    TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n-                                     SelfKind::Explicit(self.ty.clone(), ident.node))),\n+                                     SelfKind::Explicit(self.ty.clone(), mutbl))),\n                 }\n             }\n         }\n         None\n     }\n \n-    pub fn from_self(eself: ExplicitSelf, ident_sp: Span, mutbl: Mutability) -> Arg {\n-        let pat = |ident, span| P(Pat {\n-            id: DUMMY_NODE_ID,\n-            node: PatKind::Ident(BindingMode::ByValue(mutbl), respan(ident_sp, ident), None),\n-            span: span,\n-        });\n+    pub fn is_self(&self) -> bool {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            ident.node.name == keywords::SelfValue.name()\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n-            node: TyKind::Infer,\n+            node: TyKind::ImplicitSelf,\n             span: DUMMY_SP,\n         });\n-        let arg = |ident, ty, span| Arg {\n-            pat: pat(ident, span),\n+        let arg = |mutbl, ty, span| Arg {\n+            pat: P(Pat {\n+                id: DUMMY_NODE_ID,\n+                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                span: span,\n+            }),\n             ty: ty,\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Static => panic!(\"bug: `Arg::from_self` is called \\\n-                                        with `SelfKind::Static` argument\"),\n-            SelfKind::Explicit(ty, ident) => arg(ident, ty, mk_sp(eself.span.lo, ident_sp.hi)),\n-            SelfKind::Value(ident) => arg(ident, infer_ty, eself.span),\n-            SelfKind::Region(lt, mutbl, ident) => arg(ident, P(Ty {\n+            SelfKind::Explicit(ty, mutbl) => {\n+                arg(mutbl, ty, mk_sp(eself.span.lo, eself_ident.span.hi))\n+            }\n+            SelfKind::Value(mutbl) => arg(mutbl, infer_ty, eself.span),\n+            SelfKind::Region(lt, mutbl) => arg(Mutability::Immutable, P(Ty {\n                 id: DUMMY_NODE_ID,\n                 node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n                 span: DUMMY_SP,\n@@ -1768,6 +1755,15 @@ pub struct FnDecl {\n     pub variadic: bool\n }\n \n+impl FnDecl {\n+    pub fn get_self(&self) -> Option<ExplicitSelf> {\n+        self.inputs.get(0).and_then(Arg::to_self)\n+    }\n+    pub fn has_self(&self) -> bool {\n+        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,"}, {"sha": "3b13bf2fc50bace83ccf35e788d6ec9d23b55444", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -1191,13 +1191,13 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n+    pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n-                return fm.clone();\n+                return Some(fm.clone());\n             }\n         }\n-        panic!(\"asking for {} which we don't know about\", filename);\n+        None\n     }\n \n     /// For a global BytePos compute the local offset within the containing FileMap"}, {"sha": "3a1cdae9bfbd0387abd344874388217b072946f7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -832,7 +832,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = if subpats.is_empty() {\n             PatKind::Path(path)\n         } else {\n-            PatKind::TupleStruct(path, Some(subpats))\n+            PatKind::TupleStruct(path, subpats, None)\n         };\n         self.pat(span, pat)\n     }\n@@ -842,7 +842,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.pat(span, pat)\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        self.pat(span, PatKind::Tup(pats))\n+        self.pat(span, PatKind::Tuple(pats, None))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "ecca370fb8a3a4fabb18d404a2065a0163baad67", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, DeclKind, PatKind};\n-use ast::{Local, Ident, Mac_, Name};\n+use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n use ast;\n@@ -334,20 +334,20 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n /// body is in a block enclosed by loop head so the renaming of loop label\n /// must be propagated to the enclosed context.\n fn expand_loop_block(loop_block: P<Block>,\n-                     opt_ident: Option<Ident>,\n-                     fld: &mut MacroExpander) -> (P<Block>, Option<Ident>) {\n+                     opt_ident: Option<SpannedIdent>,\n+                     fld: &mut MacroExpander) -> (P<Block>, Option<SpannedIdent>) {\n     match opt_ident {\n         Some(label) => {\n-            let new_label = fresh_name(label);\n-            let rename = (label, new_label);\n+            let new_label = fresh_name(label.node);\n+            let rename = (label.node, new_label);\n \n             // The rename *must not* be added to the pending list of current\n             // syntax context otherwise an unrelated `break` or `continue` in\n             // the same context will pick that up in the deferred renaming pass\n             // and be renamed incorrectly.\n             let mut rename_list = vec!(rename);\n             let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n-            let renamed_ident = rename_fld.fold_ident(label);\n+            let renamed_ident = rename_fld.fold_ident(label.node);\n \n             // The rename *must* be added to the enclosed syntax context for\n             // `break` or `continue` to pick up because by definition they are\n@@ -357,7 +357,7 @@ fn expand_loop_block(loop_block: P<Block>,\n             let expanded_block = expand_block_elts(loop_block, fld);\n             fld.cx.syntax_env.pop_frame();\n \n-            (expanded_block, Some(renamed_ident))\n+            (expanded_block, Some(Spanned { node: renamed_ident, span: label.span }))\n         }\n         None => (fld.fold_block(loop_block), opt_ident)\n     }\n@@ -950,7 +950,6 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n     (ast::MethodSig {\n         generics: fld.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: fld.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: rewritten_fn_decl"}, {"sha": "5687099b27cedabde3df9895d607f9701d158dde", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -274,7 +274,10 @@ declare_features! (\n     (active, drop_types_in_const, \"1.9.0\", Some(33156)),\n \n     // Allows cfg(target_has_atomic = \"...\").\n-    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976))\n+    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976)),\n+\n+    // Allows `..` in tuple (struct) patterns\n+    (active, dotdot_in_tuple_patterns, \"1.10.0\", Some(33627))\n );\n \n declare_features! (\n@@ -315,7 +318,6 @@ declare_features! (\n     // Allows `#[deprecated]` attribute\n     (accepted, deprecated, \"1.9.0\", Some(29935))\n );\n-\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n@@ -1024,6 +1026,24 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n+            PatKind::Tuple(_, ddpos)\n+                    if ddpos.is_some() => {\n+                gate_feature_post!(&self, dotdot_in_tuple_patterns,\n+                                  pattern.span,\n+                                  \"`..` in tuple patterns is experimental\");\n+            }\n+            PatKind::TupleStruct(_, ref fields, ddpos)\n+                    if ddpos.is_some() && !fields.is_empty() => {\n+                gate_feature_post!(&self, dotdot_in_tuple_patterns,\n+                                  pattern.span,\n+                                  \"`..` in tuple struct patterns is experimental\");\n+            }\n+            PatKind::TupleStruct(_, ref fields, ddpos)\n+                    if ddpos.is_none() && fields.is_empty() => {\n+                self.context.span_handler.struct_span_err(pattern.span,\n+                                                          \"nullary enum variants are written with \\\n+                                                           no trailing `( )`\").emit();\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)"}, {"sha": "edf418e33325b6a51eca26b853a412470452a794", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -179,14 +179,6 @@ pub trait Folder : Sized {\n         // fold::noop_fold_mac(_mac, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n-        noop_fold_explicit_self(es, self)\n-    }\n-\n-    fn fold_explicit_self_kind(&mut self, es: SelfKind) -> SelfKind {\n-        noop_fold_explicit_self_kind(es, self)\n-    }\n-\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -383,7 +375,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyKind::Infer => node,\n+            TyKind::Infer | TyKind::ImplicitSelf => node,\n             TyKind::Vec(ty) => TyKind::Vec(fld.fold_ty(ty)),\n             TyKind::Ptr(mt) => TyKind::Ptr(fld.fold_mt(mt)),\n             TyKind::Rptr(region, mt) => {\n@@ -523,28 +515,6 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n-pub fn noop_fold_explicit_self_kind<T: Folder>(es: SelfKind, fld: &mut T)\n-                                                     -> SelfKind {\n-    match es {\n-        SelfKind::Static | SelfKind::Value(_) => es,\n-        SelfKind::Region(lifetime, m, ident) => {\n-            SelfKind::Region(fld.fold_opt_lifetime(lifetime), m, ident)\n-        }\n-        SelfKind::Explicit(typ, ident) => {\n-            SelfKind::Explicit(fld.fold_ty(typ), ident)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n-                                          -> ExplicitSelf {\n-    Spanned {\n-        node: fld.fold_explicit_self_kind(node),\n-        span: fld.new_span(span)\n-    }\n-}\n-\n-\n pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: Mac_ {\n@@ -1096,7 +1066,6 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl)\n@@ -1115,9 +1084,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                         sub.map(|x| folder.fold_pat(x)))\n             }\n             PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-            PatKind::TupleStruct(pth, pats) => {\n+            PatKind::TupleStruct(pth, pats, ddpos) => {\n                 PatKind::TupleStruct(folder.fold_path(pth),\n-                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+                        pats.move_map(|x| folder.fold_pat(x)), ddpos)\n             }\n             PatKind::Path(pth) => {\n                 PatKind::Path(folder.fold_path(pth))\n@@ -1138,7 +1107,9 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 });\n                 PatKind::Struct(pth, fs, etc)\n             }\n-            PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatKind::Tuple(elts, ddpos) => {\n+                PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n+            }\n             PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n             PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n             PatKind::Range(e1, e2) => {\n@@ -1212,23 +1183,27 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::While(cond, body, opt_ident) => {\n                 ExprKind::While(folder.fold_expr(cond),\n                           folder.fold_block(body),\n-                          opt_ident.map(|i| folder.fold_ident(i)))\n+                          opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                       folder.fold_ident(label.node))))\n             }\n             ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n                 ExprKind::WhileLet(folder.fold_pat(pat),\n                              folder.fold_expr(expr),\n                              folder.fold_block(body),\n-                             opt_ident.map(|i| folder.fold_ident(i)))\n+                             opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                          folder.fold_ident(label.node))))\n             }\n             ExprKind::ForLoop(pat, iter, body, opt_ident) => {\n                 ExprKind::ForLoop(folder.fold_pat(pat),\n                             folder.fold_expr(iter),\n                             folder.fold_block(body),\n-                            opt_ident.map(|i| folder.fold_ident(i)))\n+                            opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                         folder.fold_ident(label.node))))\n             }\n             ExprKind::Loop(body, opt_ident) => {\n                 ExprKind::Loop(folder.fold_block(body),\n-                        opt_ident.map(|i| folder.fold_ident(i)))\n+                               opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                            folder.fold_ident(label.node))))\n             }\n             ExprKind::Match(expr, arms) => {\n                 ExprKind::Match(folder.fold_expr(expr),"}, {"sha": "de74cdc8fb3dea5ca5127bd5e8308fb04533d5a8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 87, "deletions": 112, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -17,7 +17,7 @@ use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n use ast::{Decl, DeclKind, Defaultness};\n-use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n+use ast::{EMPTY_CTXT, EnumDef};\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n@@ -954,25 +954,6 @@ impl<'a> Parser<'a> {\n         Ok(result)\n     }\n \n-    /// Parse a sequence parameter of enum variant. For consistency purposes,\n-    /// these should not be empty.\n-    pub fn parse_enum_variant_seq<T, F>(&mut self,\n-                                        bra: &token::Token,\n-                                        ket: &token::Token,\n-                                        sep: SeqSep,\n-                                        f: F)\n-                                        -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-    {\n-        let result = self.parse_unspanned_seq(bra, ket, sep, f)?;\n-        if result.is_empty() {\n-            let last_span = self.last_span;\n-            self.span_err(last_span,\n-            \"nullary enum variants are written with no trailing `( )`\");\n-        }\n-        Ok(result)\n-    }\n-\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     pub fn parse_seq<T, F>(&mut self,\n@@ -1310,7 +1291,7 @@ impl<'a> Parser<'a> {\n                 let ident = p.parse_ident()?;\n                 let mut generics = p.parse_generics()?;\n \n-                let (explicit_self, d) = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                let d = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n@@ -1324,7 +1305,6 @@ impl<'a> Parser<'a> {\n                     decl: d,\n                     generics: generics,\n                     abi: abi,\n-                    explicit_self: explicit_self,\n                 };\n \n                 let body = match p.token {\n@@ -2283,18 +2263,19 @@ impl<'a> Parser<'a> {\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n-                    let lifetime = self.get_lifetime();\n+                    let label = Spanned { node: self.get_lifetime(),\n+                                          span: self.span };\n                     let lo = self.span.lo;\n                     self.bump();\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n-                        return self.parse_while_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_while_expr(Some(label), lo, attrs)\n                     }\n                     if self.eat_keyword(keywords::For) {\n-                        return self.parse_for_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_for_expr(Some(label), lo, attrs)\n                     }\n                     if self.eat_keyword(keywords::Loop) {\n-                        return self.parse_loop_expr(Some(lifetime), lo, attrs)\n+                        return self.parse_loop_expr(Some(label), lo, attrs)\n                     }\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n@@ -3264,7 +3245,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                           span_lo: BytePos,\n                           attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n@@ -3283,7 +3264,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                             span_lo: BytePos,\n                             attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n@@ -3298,7 +3279,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n-    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                                 span_lo: BytePos,\n                                 attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n@@ -3312,7 +3293,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n-    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n                            span_lo: BytePos,\n                            attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -3433,21 +3414,33 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    fn parse_pat_tuple_elements(&mut self) -> PResult<'a, Vec<P<Pat>>> {\n+    fn parse_pat_tuple_elements(&mut self, unary_needs_comma: bool)\n+                                -> PResult<'a, (Vec<P<Pat>>, Option<usize>)> {\n         let mut fields = vec![];\n-        if !self.check(&token::CloseDelim(token::Paren)) {\n-            fields.push(self.parse_pat()?);\n-            if self.look_ahead(1, |t| *t != token::CloseDelim(token::Paren)) {\n-                while self.eat(&token::Comma) &&\n-                      !self.check(&token::CloseDelim(token::Paren)) {\n+        let mut ddpos = None;\n+\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            if ddpos.is_none() && self.eat(&token::DotDot) {\n+                ddpos = Some(fields.len());\n+                if self.eat(&token::Comma) {\n+                    // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n                     fields.push(self.parse_pat()?);\n                 }\n+            } else if ddpos.is_some() && self.eat(&token::DotDot) {\n+                // Emit a friendly error, ignore `..` and continue parsing\n+                self.span_err(self.last_span, \"`..` can only be used once per \\\n+                                               tuple or tuple struct pattern\");\n+            } else {\n+                fields.push(self.parse_pat()?);\n             }\n-            if fields.len() == 1 {\n+\n+            if !self.check(&token::CloseDelim(token::Paren)) ||\n+                    (unary_needs_comma && fields.len() == 1 && ddpos.is_none()) {\n                 self.expect(&token::Comma)?;\n             }\n         }\n-        Ok(fields)\n+\n+        Ok((fields, ddpos))\n     }\n \n     fn parse_pat_vec_elements(\n@@ -3626,9 +3619,9 @@ impl<'a> Parser<'a> {\n           token::OpenDelim(token::Paren) => {\n             // Parse (pat,pat,pat,...) as tuple pattern\n             self.bump();\n-            let fields = self.parse_pat_tuple_elements()?;\n+            let (fields, ddpos) = self.parse_pat_tuple_elements(true)?;\n             self.expect(&token::CloseDelim(token::Paren))?;\n-            pat = PatKind::Tup(fields);\n+            pat = PatKind::Tuple(fields, ddpos);\n           }\n           token::OpenDelim(token::Bracket) => {\n             // Parse [pat,pat,...] as slice pattern\n@@ -3713,20 +3706,10 @@ impl<'a> Parser<'a> {\n                             return Err(self.fatal(\"unexpected `(` after qualified path\"));\n                         }\n                         // Parse tuple struct or enum pattern\n-                        if self.look_ahead(1, |t| *t == token::DotDot) {\n-                            // This is a \"top constructor only\" pat\n-                            self.bump();\n-                            self.bump();\n-                            self.expect(&token::CloseDelim(token::Paren))?;\n-                            pat = PatKind::TupleStruct(path, None);\n-                        } else {\n-                            let args = self.parse_enum_variant_seq(\n-                                &token::OpenDelim(token::Paren),\n-                                &token::CloseDelim(token::Paren),\n-                                SeqSep::trailing_allowed(token::Comma),\n-                                |p| p.parse_pat())?;\n-                            pat = PatKind::TupleStruct(path, Some(args));\n-                        }\n+                        self.bump();\n+                        let (fields, ddpos) = self.parse_pat_tuple_elements(false)?;\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        pat = PatKind::TupleStruct(path, fields, ddpos)\n                       }\n                       _ => {\n                         pat = match qself {\n@@ -4616,25 +4599,19 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F)\n-                                  -> PResult<'a, (ExplicitSelf, P<FnDecl>)>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n-    {\n+    /// Returns the parsed optional self argument and whether a self shortcut was used.\n+    fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n-            token::Ident(ident) => { this.bump(); ident } // Preserve hygienic context.\n+            // Preserve hygienic context.\n+            token::Ident(ident) => { this.bump(); codemap::respan(this.last_span, ident) }\n             _ => unreachable!()\n         };\n \n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         // Parse optional self parameter of a method.\n         // Only a limited set of initial token sequences is considered self parameters, anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.span.lo;\n-        let mut eself_mutbl = Mutability::Immutable;\n-        let (eself, eself_ident_sp) = match self.token {\n+        let (eself, eself_ident) = match self.token {\n             token::BinOp(token::And) => {\n                 // &self\n                 // &mut self\n@@ -4643,30 +4620,26 @@ impl<'a> Parser<'a> {\n                 // &not_self\n                 if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Immutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(None, Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Mutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(None, Mutability::Mutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     let lt = self.parse_lifetime()?;\n-                    (SelfKind::Region(Some(lt), Mutability::Immutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           self.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     let lt = self.parse_lifetime()?;\n                     self.bump();\n-                    (SelfKind::Region(Some(lt), Mutability::Mutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n             token::BinOp(token::Star) => {\n@@ -4678,80 +4651,85 @@ impl<'a> Parser<'a> {\n                 if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_mutability()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n                     // self\n                     // self: TYPE\n                     let eself_ident = expect_ident(self);\n-                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n+                        let ty = self.parse_ty_sum()?;\n+                        (SelfKind::Explicit(ty, Mutability::Immutable), eself_ident)\n                     } else {\n-                        (SelfKind::Value(eself_ident), eself_ident_sp)\n+                        (SelfKind::Value(Mutability::Immutable), eself_ident)\n                     }\n                 } else if self.token.is_keyword(keywords::Mut) &&\n                         self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     // mut self\n                     // mut self: TYPE\n-                    eself_mutbl = Mutability::Mutable;\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n-                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n+                        let ty = self.parse_ty_sum()?;\n+                        (SelfKind::Explicit(ty, Mutability::Mutable), eself_ident)\n                     } else {\n-                        (SelfKind::Value(eself_ident), eself_ident_sp)\n+                        (SelfKind::Value(Mutability::Mutable), eself_ident)\n                     }\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n-            _ => (SelfKind::Static, codemap::DUMMY_SP)\n+            _ => return Ok(None),\n         };\n-        let mut eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n+\n+        let eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n+        Ok(Some(Arg::from_self(eself, eself_ident)))\n+    }\n+\n+    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> PResult<'a, P<FnDecl>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n+    {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+\n+        // Parse optional self argument\n+        let self_arg = self.parse_self_arg()?;\n \n         // Parse the rest of the function parameter list.\n         let sep = SeqSep::trailing_allowed(token::Comma);\n-        let fn_inputs = match eself.node {\n-            SelfKind::Static => {\n-                eself.span = codemap::DUMMY_SP;\n-                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-            }\n-            SelfKind::Value(..) | SelfKind::Region(..) | SelfKind::Explicit(..) => {\n-                if self.check(&token::CloseDelim(token::Paren)) {\n-                    vec![Arg::from_self(eself.clone(), eself_ident_sp, eself_mutbl)]\n-                } else if self.check(&token::Comma) {\n-                    self.bump();\n-                    let mut fn_inputs = vec![Arg::from_self(eself.clone(), eself_ident_sp,\n-                                                            eself_mutbl)];\n-                    fn_inputs.append(&mut self.parse_seq_to_before_end(\n-                        &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-                    );\n-                    fn_inputs\n-                } else {\n-                    return self.unexpected();\n-                }\n+        let fn_inputs = if let Some(self_arg) = self_arg {\n+            if self.check(&token::CloseDelim(token::Paren)) {\n+                vec![self_arg]\n+            } else if self.eat(&token::Comma) {\n+                let mut fn_inputs = vec![self_arg];\n+                fn_inputs.append(&mut self.parse_seq_to_before_end(\n+                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+                );\n+                fn_inputs\n+            } else {\n+                return self.unexpected();\n             }\n+        } else {\n+            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n         };\n \n         // Parse closing paren and return type.\n         self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok((eself, P(FnDecl {\n+        Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty()?,\n             variadic: false\n-        })))\n+        }))\n     }\n \n     // parse the |arg, arg| header on a lambda\n@@ -4944,15 +4922,12 @@ impl<'a> Parser<'a> {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n-                    p.parse_arg()\n-                })?;\n+            let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             Ok((ident, inner_attrs, ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: generics,\n                 abi: abi,\n-                explicit_self: explicit_self,\n                 unsafety: unsafety,\n                 constness: constness,\n                 decl: decl"}, {"sha": "5b9ec924de953528e5ea4c0bfd476f2c69e44543", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 63, "deletions": 70, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use abi::{self, Abi};\n use ast::{self, TokenTree, BlockCheckMode, PatKind};\n-use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n@@ -382,13 +382,12 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,\n                      name: ast::Ident,\n-                     opt_explicit_self: Option<&ast::SelfKind>,\n                      generics: &ast::Generics)\n                      -> String {\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n-                   generics, opt_explicit_self, &ast::Visibility::Inherited)?;\n+                   generics, &ast::Visibility::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -416,10 +415,6 @@ pub fn lit_to_string(l: &ast::Lit) -> String {\n     to_string(|s| s.print_literal(l))\n }\n \n-pub fn explicit_self_to_string(explicit_self: &ast::SelfKind) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, ast::Mutability::Immutable).map(|_| {}))\n-}\n-\n pub fn variant_to_string(var: &ast::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n@@ -1005,8 +1000,7 @@ impl<'a> State<'a> {\n                                  f.unsafety,\n                                  &f.decl,\n                                  None,\n-                                 &generics,\n-                                 None)?;\n+                                 &generics)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n                 self.print_path(path, false, 0)?;\n@@ -1036,6 +1030,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer => {\n                 word(&mut self.s, \"_\")?;\n             }\n+            ast::TyKind::ImplicitSelf => {\n+                unreachable!();\n+            }\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m, token::Paren)?;\n             }\n@@ -1054,7 +1051,7 @@ impl<'a> State<'a> {\n                 self.print_fn(decl, ast::Unsafety::Normal,\n                               ast::Constness::NotConst,\n                               Abi::Rust, Some(item.ident),\n-                              generics, None, &item.vis)?;\n+                              generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n@@ -1182,7 +1179,6 @@ impl<'a> State<'a> {\n                     abi,\n                     Some(item.ident),\n                     typarams,\n-                    None,\n                     &item.vis\n                 )?;\n                 word(&mut self.s, \" \")?;\n@@ -1522,7 +1518,6 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n-                      None,\n                       vis)\n     }\n \n@@ -2021,7 +2016,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n@@ -2031,7 +2026,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n@@ -2044,7 +2039,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"for\")?;\n@@ -2057,7 +2052,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n-                    self.print_ident(ident)?;\n+                    self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -2472,17 +2467,23 @@ impl<'a> State<'a> {\n                     None => ()\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n                 self.print_path(path, true, 0)?;\n-                match *args_ {\n-                    None => word(&mut self.s, \"(..)\")?,\n-                    Some(ref args) => {\n-                        self.popen()?;\n-                        self.commasep(Inconsistent, &args[..],\n-                                          |s, p| s.print_pat(&p))?;\n-                        self.pclose()?;\n+                self.popen()?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n                 }\n+                self.pclose()?;\n             }\n             PatKind::Path(ref path) => {\n                 self.print_path(path, true, 0)?;\n@@ -2513,13 +2514,23 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 word(&mut self.s, \"}\")?;\n             }\n-            PatKind::Tup(ref elts) => {\n+            PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n-                self.commasep(Inconsistent,\n-                                   &elts[..],\n-                                   |s, p| s.print_pat(&p))?;\n-                if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                if let Some(ddpos) = ddpos {\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    if ddpos != 0 {\n+                        self.word_space(\",\")?;\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    if ddpos != elts.len() {\n+                        word(&mut self.s, \",\")?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                    }\n+                } else {\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    if elts.len() == 1 {\n+                        word(&mut self.s, \",\")?;\n+                    }\n                 }\n                 self.pclose()?;\n             }\n@@ -2610,29 +2621,25 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    // Returns whether it printed anything\n-    fn print_explicit_self(&mut self,\n-                           explicit_self: &ast::SelfKind,\n-                           mutbl: ast::Mutability) -> io::Result<bool> {\n-        self.print_mutability(mutbl)?;\n-        match *explicit_self {\n-            ast::SelfKind::Static => { return Ok(false); }\n-            ast::SelfKind::Value(_) => {\n-                word(&mut self.s, \"self\")?;\n+    fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) -> io::Result<()> {\n+        match explicit_self.node {\n+            SelfKind::Value(m) => {\n+                self.print_mutability(m)?;\n+                word(&mut self.s, \"self\")\n             }\n-            ast::SelfKind::Region(ref lt, m, _) => {\n+            SelfKind::Region(ref lt, m) => {\n                 word(&mut self.s, \"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                word(&mut self.s, \"self\")\n             }\n-            ast::SelfKind::Explicit(ref typ, _) => {\n+            SelfKind::Explicit(ref typ, m) => {\n+                self.print_mutability(m)?;\n                 word(&mut self.s, \"self\")?;\n                 self.word_space(\":\")?;\n-                self.print_type(&typ)?;\n+                self.print_type(&typ)\n             }\n         }\n-        return Ok(true);\n     }\n \n     pub fn print_fn(&mut self,\n@@ -2642,7 +2649,6 @@ impl<'a> State<'a> {\n                     abi: abi::Abi,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n-                    opt_explicit_self: Option<&ast::SelfKind>,\n                     vis: &ast::Visibility) -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -2651,21 +2657,14 @@ impl<'a> State<'a> {\n             self.print_ident(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl, opt_explicit_self)?;\n+        self.print_fn_args_and_ret(decl)?;\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         _: Option<&ast::SelfKind>,\n-                         is_closure: bool) -> io::Result<()> {\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, is_closure))\n-    }\n-\n-    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n-                                 opt_explicit_self: Option<&ast::SelfKind>)\n+    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl)\n         -> io::Result<()> {\n         self.popen()?;\n-        self.print_fn_args(decl, opt_explicit_self, false)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n@@ -2679,7 +2678,7 @@ impl<'a> State<'a> {\n             decl: &ast::FnDecl)\n             -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.print_fn_args(decl, None, true)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n         word(&mut self.s, \"|\")?;\n \n         if let ast::FunctionRetTy::Default(..) = decl.output {\n@@ -2929,17 +2928,14 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                let (mutbl, invalid) = match input.pat.node {\n-                    PatKind::Ident(ast::BindingMode::ByValue(mutbl), ident, _) |\n-                    PatKind::Ident(ast::BindingMode::ByRef(mutbl), ident, _) => {\n-                        (mutbl, ident.node.name == keywords::Invalid.name())\n-                    }\n-                    _ => (ast::Mutability::Immutable, false)\n-                };\n-\n                 if let Some(eself) = input.to_self() {\n-                    self.print_explicit_self(&eself.node, mutbl)?;\n+                    self.print_explicit_self(&eself)?;\n                 } else {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                        ident.node.name == keywords::Invalid.name()\n+                    } else {\n+                        false\n+                    };\n                     if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n@@ -2980,8 +2976,7 @@ impl<'a> State<'a> {\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n-                       generics: &ast::Generics,\n-                       opt_explicit_self: Option<&ast::SelfKind>)\n+                       generics: &ast::Generics)\n                        -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -3002,7 +2997,6 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      opt_explicit_self,\n                       &ast::Visibility::Inherited)?;\n         self.end()\n     }\n@@ -3126,8 +3120,7 @@ mod tests {\n         let generics = ast::Generics::default();\n         assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal,\n                                  ast::Constness::NotConst,\n-                                 abba_ident,\n-                                 None, &generics),\n+                                 abba_ident, &generics),\n                    \"fn abba()\");\n     }\n "}, {"sha": "919dd84b117993292342e07a45ea923a77edeabf", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -129,10 +129,6 @@ impl<'v> Visitor<'v> for NodeCounter {\n         self.count += 1;\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        self.count += 1;\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_mac(&mut self, _mac: &'v Mac) {\n         self.count += 1;\n         walk_mac(self, _mac)"}, {"sha": "8a02e549d4c398abe61336cf12595a5f631607e0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -26,7 +26,7 @@\n use abi::Abi;\n use ast::*;\n use attr::ThinAttributesExt;\n-use codemap::Span;\n+use codemap::{Span, Spanned};\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -99,9 +99,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_mac(&mut self, _mac: &'v Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n@@ -149,17 +146,24 @@ macro_rules! walk_list {\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n-    for name in opt_name {\n+    if let Some(name) = opt_name {\n         visitor.visit_name(span, name);\n     }\n }\n \n pub fn walk_opt_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_ident: Option<Ident>) {\n-    for ident in opt_ident {\n+    if let Some(ident) = opt_ident {\n         visitor.visit_ident(span, ident);\n     }\n }\n \n+pub fn walk_opt_sp_ident<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             opt_sp_ident: &Option<Spanned<Ident>>) {\n+    if let Some(ref sp_ident) = *opt_sp_ident {\n+        visitor.visit_ident(sp_ident.span, sp_ident.node);\n+    }\n+}\n+\n pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, ident: Ident) {\n     visitor.visit_name(span, ident.name);\n }\n@@ -196,24 +200,6 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              explicit_self: &'v ExplicitSelf) {\n-    match explicit_self.node {\n-        SelfKind::Static => {},\n-        SelfKind::Value(ident) => {\n-            visitor.visit_ident(explicit_self.span, ident)\n-        }\n-        SelfKind::Region(ref opt_lifetime, _, ident) => {\n-            visitor.visit_ident(explicit_self.span, ident);\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n-        }\n-        SelfKind::Explicit(ref typ, ident) => {\n-            visitor.visit_ident(explicit_self.span, ident);\n-            visitor.visit_ty(typ)\n-        }\n-    }\n-}\n-\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -369,7 +355,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        TyKind::Infer => {}\n+        TyKind::Infer | TyKind::ImplicitSelf => {}\n         TyKind::Mac(ref mac) => {\n             visitor.visit_mac(mac)\n         }\n@@ -423,11 +409,9 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref children, _) => {\n             visitor.visit_path(path, pattern.id);\n-            if let Some(ref children) = *opt_children {\n-                walk_list!(visitor, visit_pat, children);\n-            }\n+            walk_list!(visitor, visit_pat, children);\n         }\n         PatKind::Path(ref path) => {\n             visitor.visit_path(path, pattern.id);\n@@ -443,7 +427,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatKind::Tup(ref tuple_elements) => {\n+        PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n         PatKind::Box(ref subpattern) |\n@@ -553,7 +537,6 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n         }\n         FnKind::Method(_, ref sig, _) => {\n             visitor.visit_generics(&sig.generics);\n-            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FnKind::Closure => {}\n     }\n@@ -578,7 +561,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_expr, default);\n         }\n         TraitItemKind::Method(ref sig, None) => {\n-            visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n@@ -712,32 +694,32 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::While(ref subexpression, ref block, opt_ident) => {\n+        ExprKind::While(ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(if_block);\n             walk_list!(visitor, visit_expr, optional_else);\n         }\n-        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::WhileLet(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, opt_ident) => {\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_sp_ident) => {\n             visitor.visit_pat(pattern);\n             visitor.visit_expr(subexpression);\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n-        ExprKind::Loop(ref block, opt_ident) => {\n+        ExprKind::Loop(ref block, ref opt_sp_ident) => {\n             visitor.visit_block(block);\n-            walk_opt_ident(visitor, expression.span, opt_ident)\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Match(ref subexpression, ref arms) => {\n             visitor.visit_expr(subexpression);\n@@ -781,9 +763,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprKind::Break(ref opt_sp_ident) | ExprKind::Again(ref opt_sp_ident) => {\n-            for sp_ident in opt_sp_ident {\n-                visitor.visit_ident(sp_ident.span, sp_ident.node);\n-            }\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "9095230df630a339e5b63a74e7095501aee1b039", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -197,7 +197,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, respan, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n@@ -806,25 +806,21 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n         let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n \n-        let ast_explicit_self = match self.explicit_self {\n-            Some(ref self_ptr) => {\n-                let (self_expr, explicit_self) =\n-                    ty::get_explicit_self(cx, trait_.span, self_ptr);\n+        let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_.span, self_ptr);\n \n-                self_args.push(self_expr);\n-                nonstatic = true;\n+            self_args.push(self_expr);\n+            nonstatic = true;\n \n-                explicit_self\n-            }\n-            None => codemap::respan(trait_.span, ast::SelfKind::Static),\n-        };\n+            explicit_self\n+        });\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n@@ -857,24 +853,20 @@ impl<'a> MethodDef<'a> {\n                      type_ident: Ident,\n                      generics: &Generics,\n                      abi: Abi,\n-                     explicit_self: ast::ExplicitSelf,\n+                     explicit_self: Option<ast::ExplicitSelf>,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n                      body: P<Expr>) -> ast::ImplItem {\n \n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n-        let self_arg = match explicit_self.node {\n-            ast::SelfKind::Static => None,\n-            // creating fresh self id\n-            _ => Some(ast::Arg::from_self(explicit_self.clone(), trait_.span,\n-                                          ast::Mutability::Immutable)),\n-        };\n         let args = {\n-            let args = arg_types.into_iter().map(|(name, ty)| {\n-                    cx.arg(trait_.span, name, ty)\n-                });\n-            self_arg.into_iter().chain(args).collect()\n+            let self_args = explicit_self.map(|explicit_self| {\n+                ast::Arg::from_self(explicit_self, respan(trait_.span, keywords::SelfValue.ident()))\n+            });\n+            let nonself_args = arg_types.into_iter()\n+                                        .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n+            self_args.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -900,7 +892,6 @@ impl<'a> MethodDef<'a> {\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: fn_generics,\n                 abi: abi,\n-                explicit_self: explicit_self,\n                 unsafety: unsafety,\n                 constness: ast::Constness::NotConst,\n                 decl: fn_decl"}, {"sha": "b581f5267eaac221ccfa0cb708b7d0d45d19b13a", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -15,11 +15,10 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr,Generics,Ident};\n+use syntax::ast::{Expr, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n /// The types of pointers\n@@ -258,20 +257,19 @@ impl<'a> LifetimeBounds<'a> {\n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (P<Expr>, ast::ExplicitSelf) {\n-    // this constructs a fresh `self` path, which will match the fresh `self` binding\n-    // created below.\n+    // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident())))\n+            (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident())\n+                        SelfKind::Region(lt, mutbl)\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}, {"sha": "8d74154655fcee4b9006a78b57786493f18aceef", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -18,12 +18,12 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR this pattern has 0 fields, but the corresponding variant\n+        //~^ ERROR `Foo::Bar` does not name a tuple variant or a tuple struct\n         _ => {}\n     }\n \n     match S {\n         S(()) => {}\n-        //~^ ERROR this pattern has 1 field, but the corresponding struct\n+        //~^ ERROR `S` does not name a tuple variant or a tuple struct\n     }\n }"}, {"sha": "a4ba93ea1733311c7ccac7f0e4516c7f4510da1a", "filename": "src/test/compile-fail/match-pattern-field-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-pattern-field-mismatch-2.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -20,7 +20,7 @@ fn main() {\n           color::rgb(_, _, _) => { }\n           color::cmyk(_, _, _, _) => { }\n           color::no_color(_) => { }\n-          //~^ ERROR this pattern has 1 field, but the corresponding variant has no fields\n+          //~^ ERROR `color::no_color` does not name a tuple variant or a tuple struct\n         }\n     }\n }"}, {"sha": "0d50a30dd0526b07f4495dd806180d537d785002", "filename": "src/test/compile-fail/pat-tuple-bad-type.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-bad-type.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn main() {\n+    let x;\n+\n+    match x {\n+        (..) => {} //~ ERROR the type of this value must be known in this context\n+        _ => {}\n+    }\n+\n+    match 0u8 {\n+        (..) => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+\n+    x = 10;\n+}"}, {"sha": "55ca05bdef381f605f18ef926b7d3b64ce161444", "filename": "src/test/compile-fail/pat-tuple-feature-gate.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-feature-gate.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    match 0 {\n+        (..) => {} //~ ERROR `..` in tuple patterns is experimental\n+        (pat, ..) => {} //~ ERROR `..` in tuple patterns is experimental\n+        S(pat, ..) => {} //~ ERROR `..` in tuple struct patterns is experimental\n+    }\n+}"}, {"sha": "034ef4a72e21c5d5896e77829a7838a0902ea663", "filename": "src/test/compile-fail/pat-tuple-overfield.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-tuple-overfield.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+struct S(u8, u8, u8);\n+\n+fn main() {\n+    match (1, 2, 3) {\n+        (1, 2, 3, 4) => {} //~ ERROR mismatched types\n+        (1, 2, .., 3, 4) => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+    match S(1, 2, 3) {\n+        S(1, 2, 3, 4) => {}\n+        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        S(1, 2, .., 3, 4) => {}\n+        //~^ ERROR this pattern has 4 fields, but the corresponding struct has 3 fields\n+        _ => {}\n+    }\n+}"}, {"sha": "507012e8c5c06803a7c3a2426678c08516fa3758", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -25,7 +25,7 @@ fn f(_c: char) {}\n fn main() {\n     match A::B(1, 2) {\n         A::B(_, _, _) => (), //~ ERROR this pattern has 3 fields, but\n-        A::D(_) => (),       //~ ERROR this pattern has 1 field, but\n+        A::D(_) => (),       //~ ERROR `A::D` does not name a tuple variant or a tuple struct\n         _ => ()\n     }\n     match 'c' {"}, {"sha": "fb78e558a951a7c6cbac3968b5f0a3dfaeb9f669", "filename": "src/test/parse-fail/pat-lt-bracket-6.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let Test(&desc[..]) = x; //~ error: expected one of `,` or `@`, found `[`\n-    //~^ ERROR expected one of `:`, `;`, `=`, or `@`, found `[`\n+    let Test(&desc[..]) = x; //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n }"}, {"sha": "d75589d8889e3381613a6f55a755dac09fb896c2", "filename": "src/test/parse-fail/pat-lt-bracket-7.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -9,6 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    for thing(x[]) in foo {} //~ error: expected one of `,` or `@`, found `[`\n-    //~^ ERROR expected one of `@` or `in`, found `[`\n+    for thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n }"}, {"sha": "945d0740654e8b82f3d744fc59c27c6a7cf6e15b", "filename": "src/test/parse-fail/pat-tuple-1.rs", "status": "renamed", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-1.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -8,15 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Number {\n-    Zero,\n-    One(u32)\n-}\n+// compile-flags: -Z parse-only\n \n fn main() {\n-    let x = Number::Zero;\n-    match x {\n-        Number::Zero(inside) => {}, //~ ERROR E0024\n-        Number::One(inside) => {},\n+    match 0 {\n+        (, ..) => {} //~ ERROR expected pattern, found `,`\n     }\n }", "previous_filename": "src/test/compile-fail/E0024.rs"}, {"sha": "ad52fa578700747983f67ef43593eafc67462e2c", "filename": "src/test/parse-fail/pat-tuple-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-2.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat, ..,) => {} //~ ERROR expected pattern, found `)`\n+    }\n+}"}, {"sha": "029dc7a295678494ac52bffed45165de1b4535fd", "filename": "src/test/parse-fail/pat-tuple-3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-3.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (.., pat, ..) => {} //~ ERROR `..` can only be used once per tuple or tuple struct pattern\n+    }\n+}"}, {"sha": "f4c3afa07f106b37589a7b143d72102033c32898", "filename": "src/test/parse-fail/pat-tuple-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-4.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (.. pat) => {} //~ ERROR expected one of `)` or `,`, found `pat`\n+    }\n+}"}, {"sha": "145d1f9d8ec763c850f7ed23cfcbe8d187074bf9", "filename": "src/test/parse-fail/pat-tuple-5.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-5.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat ..) => {} //~ ERROR expected one of `)`, `,`, or `@`, found `..`\n+    }\n+}"}, {"sha": "3252d92fe1b50649d2c33fa002e55de548a402e3", "filename": "src/test/parse-fail/pat-tuple-6.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-tuple-6.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn main() {\n+    match 0 {\n+        (pat) => {} //~ ERROR expected one of `,` or `@`, found `)`\n+    }\n+}"}, {"sha": "c3796210a8e5b9070f06a63511b713e23e69cdaa", "filename": "src/test/run-pass/pat-tuple-1.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-1.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    let x = (1, 2, 3);\n+    match x {\n+        (a, b, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+        }\n+    }\n+    match x {\n+        (.., b, c) => {\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (a, .., c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (a, b, c, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        (.., a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+}\n+\n+fn tuple_struct() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    match x {\n+        S(a, b, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+        }\n+    }\n+    match x {\n+        S(.., b, c) => {\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(a, .., c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(a, b, c, ..) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+    match x {\n+        S(.., a, b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}, {"sha": "881e96a9d788ca41a3e5ff0ce0342fb4e7f4c9ee", "filename": "src/test/run-pass/pat-tuple-2.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-2.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    let x = (1,);\n+    match x {\n+        (2, ..) => panic!(),\n+        (..) => ()\n+    }\n+}\n+\n+fn tuple_struct() {\n+    struct S(u8);\n+\n+    let x = S(1);\n+    match x {\n+        S(2, ..) => panic!(),\n+        S(..) => ()\n+    }\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}, {"sha": "94d33d41899a413c992ff7e13e462d1634ebe8ae", "filename": "src/test/run-pass/pat-tuple-3.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-3.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    let x = (1, 2, 3);\n+    let branch = match x {\n+        (1, 1, ..) => 0,\n+        (1, 2, 3, ..) => 1,\n+        (1, 2, ..) => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n+fn tuple_struct() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    let branch = match x {\n+        S(1, 1, ..) => 0,\n+        S(1, 2, 3, ..) => 1,\n+        S(1, 2, ..) => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}, {"sha": "ffd82fea99622ac58d87ff7352a44e18f53b187c", "filename": "src/test/run-pass/pat-tuple-4.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-4.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    let x = (1, 2, 3);\n+    match x {\n+        (1, 2, 4) => unreachable!(),\n+        (0, 2, 3, ..) => unreachable!(),\n+        (0, .., 3) => unreachable!(),\n+        (0, ..) => unreachable!(),\n+        (1, 2, 3) => (),\n+        (_, _, _) => unreachable!(),\n+    }\n+    match x {\n+        (..) => (),\n+    }\n+    match x {\n+        (_, _, _, ..) => (),\n+    }\n+    match x {\n+        (a, b, c) => {\n+            assert_eq!(1, a);\n+            assert_eq!(2, b);\n+            assert_eq!(3, c);\n+        }\n+    }\n+}\n+\n+fn tuple_struct() {\n+    struct S(u8, u8, u8);\n+\n+    let x = S(1, 2, 3);\n+    match x {\n+        S(1, 2, 4) => unreachable!(),\n+        S(0, 2, 3, ..) => unreachable!(),\n+        S(0, .., 3) => unreachable!(),\n+        S(0, ..) => unreachable!(),\n+        S(1, 2, 3) => (),\n+        S(_, _, _) => unreachable!(),\n+    }\n+    match x {\n+        S(..) => (),\n+    }\n+    match x {\n+        S(_, _, _, ..) => (),\n+    }\n+    match x {\n+        S(a, b, c) => {\n+            assert_eq!(1, a);\n+            assert_eq!(2, b);\n+            assert_eq!(3, c);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}, {"sha": "41c4d02abcbd3837f58ea57453e64acd3f9aa1af", "filename": "src/test/run-pass/pat-tuple-5.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-5.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    struct S;\n+    struct Z;\n+    struct W;\n+    let x = (S, Z, W);\n+    match x { (S, ..) => {} }\n+    match x { (.., W) => {} }\n+    match x { (S, .., W) => {} }\n+    match x { (.., Z, _) => {} }\n+}\n+\n+fn tuple_struct() {\n+    struct SS(S, Z, W);\n+\n+    struct S;\n+    struct Z;\n+    struct W;\n+    let x = SS(S, Z, W);\n+    match x { SS(S, ..) => {} }\n+    match x { SS(.., W) => {} }\n+    match x { SS(S, .., W) => {} }\n+    match x { SS(.., Z, _) => {} }\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}, {"sha": "6f3f2b3aed5507266406c66419db6c61b79857a4", "filename": "src/test/run-pass/pat-tuple-6.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9/src%2Ftest%2Frun-pass%2Fpat-tuple-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpat-tuple-6.rs?ref=36d5dc7c9bcfd287b5c4e4ac3e2f0ab93bdaa0c9", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dotdot_in_tuple_patterns)]\n+\n+fn tuple() {\n+    let x = (1, 2, 3, 4, 5);\n+    match x {\n+        (a, .., b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 4);\n+            assert_eq!(c, 5);\n+        }\n+    }\n+    match x {\n+        (a, b, c, .., d) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+            assert_eq!(d, 5);\n+        }\n+    }\n+}\n+\n+fn tuple_struct() {\n+    struct S(u8, u8, u8, u8, u8);\n+\n+    let x = S(1, 2, 3, 4, 5);\n+    match x {\n+        S(a, .., b, c) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 4);\n+            assert_eq!(c, 5);\n+        }\n+    }\n+    match x {\n+        S(a, b, c, .., d) => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+            assert_eq!(d, 5);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    tuple();\n+    tuple_struct();\n+}"}]}