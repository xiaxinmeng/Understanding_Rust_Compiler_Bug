{"sha": "5e6eee5f631e354ba3323e7237bf35d24d7741e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNmVlZTVmNjMxZTM1NGJhMzMyM2U3MjM3YmYzNWQyNGQ3NzQxZTk=", "commit": {"author": {"name": "Manas", "email": "manas18244@iiitd.ac.in", "date": "2021-07-07T16:48:36Z"}, "committer": {"name": "Manas", "email": "manas18244@iiitd.ac.in", "date": "2021-07-07T19:53:57Z"}, "message": "Explicitly name all spawned threads\n\nThe thread name is shown in debugger as well as panic messages and this\npatch makes it easier to follow a thread instead of looking through\nfull backtrace, by naming all spawned threads according to their\nfunctioning.", "tree": {"sha": "ed0556b36725759a41d3667cb5b33f03d8546629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0556b36725759a41d3667cb5b33f03d8546629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6eee5f631e354ba3323e7237bf35d24d7741e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6eee5f631e354ba3323e7237bf35d24d7741e9", "html_url": "https://github.com/rust-lang/rust/commit/5e6eee5f631e354ba3323e7237bf35d24d7741e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6eee5f631e354ba3323e7237bf35d24d7741e9/comments", "author": {"login": "weirdsmiley", "id": 41788201, "node_id": "MDQ6VXNlcjQxNzg4MjAx", "avatar_url": "https://avatars.githubusercontent.com/u/41788201?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirdsmiley", "html_url": "https://github.com/weirdsmiley", "followers_url": "https://api.github.com/users/weirdsmiley/followers", "following_url": "https://api.github.com/users/weirdsmiley/following{/other_user}", "gists_url": "https://api.github.com/users/weirdsmiley/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirdsmiley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirdsmiley/subscriptions", "organizations_url": "https://api.github.com/users/weirdsmiley/orgs", "repos_url": "https://api.github.com/users/weirdsmiley/repos", "events_url": "https://api.github.com/users/weirdsmiley/events{/privacy}", "received_events_url": "https://api.github.com/users/weirdsmiley/received_events", "type": "User", "site_admin": false}, "committer": {"login": "weirdsmiley", "id": 41788201, "node_id": "MDQ6VXNlcjQxNzg4MjAx", "avatar_url": "https://avatars.githubusercontent.com/u/41788201?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirdsmiley", "html_url": "https://github.com/weirdsmiley", "followers_url": "https://api.github.com/users/weirdsmiley/followers", "following_url": "https://api.github.com/users/weirdsmiley/following{/other_user}", "gists_url": "https://api.github.com/users/weirdsmiley/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirdsmiley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirdsmiley/subscriptions", "organizations_url": "https://api.github.com/users/weirdsmiley/orgs", "repos_url": "https://api.github.com/users/weirdsmiley/repos", "events_url": "https://api.github.com/users/weirdsmiley/events{/privacy}", "received_events_url": "https://api.github.com/users/weirdsmiley/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b6770c9367d69ea82f63ceab081b2fec7b4900c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b6770c9367d69ea82f63ceab081b2fec7b4900c", "html_url": "https://github.com/rust-lang/rust/commit/2b6770c9367d69ea82f63ceab081b2fec7b4900c"}], "stats": {"total": 110, "additions": 64, "deletions": 46}, "files": [{"sha": "e55f74bc452686cd07667ab78f4ac72be72880b5", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=5e6eee5f631e354ba3323e7237bf35d24d7741e9", "patch": "@@ -67,7 +67,10 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<Restart>();\n-        let thread = jod_thread::spawn(move || actor.run(receiver));\n+        let thread = jod_thread::Builder::new()\n+            .name(\"FlycheckThread\".to_owned())\n+            .spawn(move || actor.run(receiver))\n+            .expect(\"failed to spawn thread\");\n         FlycheckHandle { sender, thread }\n     }\n \n@@ -266,7 +269,10 @@ impl CargoHandle {\n         let child_stdout = child.stdout.take().unwrap();\n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(child_stdout, sender);\n-        let thread = jod_thread::spawn(move || actor.run());\n+        let thread = jod_thread::Builder::new()\n+            .name(\"CargoHandleThread\".to_owned())\n+            .spawn(move || actor.run())\n+            .expect(\"failed to spawn thread\");\n         CargoHandle { child, thread, receiver }\n     }\n     fn join(mut self) -> io::Result<()> {"}, {"sha": "19f854dba12b66eb5f99272f5482e378d92261ca", "filename": "crates/proc_macro_api/src/process.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs?ref=5e6eee5f631e354ba3323e7237bf35d24d7741e9", "patch": "@@ -37,9 +37,12 @@ impl ProcMacroProcessSrv {\n         let process = Process::run(process_path, args)?;\n \n         let (task_tx, task_rx) = bounded(0);\n-        let handle = jod_thread::spawn(move || {\n-            client_loop(task_rx, process);\n-        });\n+        let handle = jod_thread::Builder::new()\n+            .name(\"ProcMacroClientThread\".to_owned())\n+            .spawn(move || {\n+                client_loop(task_rx, process);\n+            })\n+            .expect(\"failed to spawn thread\");\n \n         let task_tx = Arc::new(task_tx);\n         let srv = ProcMacroProcessSrv { inner: Arc::downgrade(&task_tx) };"}, {"sha": "29b340445efe03c2b74a7d677607cdfd97f762cf", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/server.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fserver.rs?ref=5e6eee5f631e354ba3323e7237bf35d24d7741e9", "patch": "@@ -181,21 +181,24 @@ impl ExecutionStrategy for CrossThread1 {\n         let (req_tx, req_rx) = channel();\n         let (res_tx, res_rx) = channel();\n \n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                req_tx.send(b).unwrap();\n-                res_rx.recv().unwrap()\n-            };\n-\n-            run_client(\n-                Bridge {\n-                    cached_buffer: input,\n-                    dispatch: (&mut dispatch).into(),\n-                    force_show_panics,\n-                },\n-                client_data,\n-            )\n-        });\n+        let join_handle = thread::Builder::new()\n+            .name(\"DispatchThread\".to_owned())\n+            .spawn(move || {\n+                let mut dispatch = |b| {\n+                    req_tx.send(b).unwrap();\n+                    res_rx.recv().unwrap()\n+                };\n+\n+                run_client(\n+                    Bridge {\n+                        cached_buffer: input,\n+                        dispatch: (&mut dispatch).into(),\n+                        force_show_panics,\n+                    },\n+                    client_data,\n+                )\n+            })\n+            .expect(\"failed to spawn thread\");\n \n         for b in req_rx {\n             res_tx.send(dispatcher.dispatch(b)).unwrap();\n@@ -227,33 +230,36 @@ impl ExecutionStrategy for CrossThread2 {\n \n         let server_thread = thread::current();\n         let state2 = state.clone();\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                *state2.lock().unwrap() = State::Req(b);\n-                server_thread.unpark();\n-                loop {\n-                    thread::park();\n-                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n-                        break b.take();\n+        let join_handle = thread::Builder::new()\n+            .name(\"ServerThread\".to_owned())\n+            .spawn(move || {\n+                let mut dispatch = |b| {\n+                    *state2.lock().unwrap() = State::Req(b);\n+                    server_thread.unpark();\n+                    loop {\n+                        thread::park();\n+                        if let State::Res(b) = &mut *state2.lock().unwrap() {\n+                            break b.take();\n+                        }\n                     }\n-                }\n-            };\n+                };\n+\n+                let r = run_client(\n+                    Bridge {\n+                        cached_buffer: input,\n+                        dispatch: (&mut dispatch).into(),\n+                        force_show_panics,\n+                    },\n+                    client_data,\n+                );\n+\n+                // Wake up the server so it can exit the dispatch loop.\n+                drop(state2);\n+                server_thread.unpark();\n \n-            let r = run_client(\n-                Bridge {\n-                    cached_buffer: input,\n-                    dispatch: (&mut dispatch).into(),\n-                    force_show_panics,\n-                },\n-                client_data,\n-            );\n-\n-            // Wake up the server so it can exit the dispatch loop.\n-            drop(state2);\n-            server_thread.unpark();\n-\n-            r\n-        });\n+                r\n+            })\n+            .expect(\"failed to spawn thread\");\n \n         // Check whether `state2` was dropped, to know when to stop.\n         while Arc::get_mut(&mut state).is_none() {"}, {"sha": "ca341ddae92f774d8a97034871fccb7c2134745b", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6eee5f631e354ba3323e7237bf35d24d7741e9/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=5e6eee5f631e354ba3323e7237bf35d24d7741e9", "patch": "@@ -31,7 +31,10 @@ impl loader::Handle for NotifyHandle {\n     fn spawn(sender: loader::Sender) -> NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n-        let thread = jod_thread::spawn(move || actor.run(receiver));\n+        let thread = jod_thread::Builder::new()\n+            .name(\"LoaderThread\".to_owned())\n+            .spawn(move || actor.run(receiver))\n+            .expect(\"failed to spawn thread\");\n         NotifyHandle { sender, thread }\n     }\n     fn set_config(&mut self, config: loader::Config) {"}]}