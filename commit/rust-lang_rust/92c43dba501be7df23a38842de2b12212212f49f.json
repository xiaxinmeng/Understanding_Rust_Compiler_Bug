{"sha": "92c43dba501be7df23a38842de2b12212212f49f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYzQzZGJhNTAxYmU3ZGYyM2EzODg0MmRlMmIxMjIxMjIxMmY0OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T06:01:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-31T06:01:43Z"}, "message": "auto merge of #14544 : aturon/rust/issue-14352, r=alexcrichton\n\nAdds a platform-specific function, `split_paths` to the `os` module. This\r\nfunction can be used to parse PATH-like environment variables according to\r\nlocal platform conventions.\r\n\r\nCloses #14352.", "tree": {"sha": "6f7aae36b39fd509acf284e3e39d425370b619da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f7aae36b39fd509acf284e3e39d425370b619da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92c43dba501be7df23a38842de2b12212212f49f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92c43dba501be7df23a38842de2b12212212f49f", "html_url": "https://github.com/rust-lang/rust/commit/92c43dba501be7df23a38842de2b12212212f49f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92c43dba501be7df23a38842de2b12212212f49f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a43f9bc5d24b47aae9681fc7ef47d517329e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a43f9bc5d24b47aae9681fc7ef47d517329e59", "html_url": "https://github.com/rust-lang/rust/commit/60a43f9bc5d24b47aae9681fc7ef47d517329e59"}, {"sha": "b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb", "html_url": "https://github.com/rust-lang/rust/commit/b1fbbf3e48fdcfaa5e875bf457bc098faec30dbb"}], "stats": {"total": 96, "additions": 94, "deletions": 2}, "files": [{"sha": "fa0116b248223d55e7a44ba789e4ac60d561a048", "filename": "src/libstd/os.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/92c43dba501be7df23a38842de2b12212212f49f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c43dba501be7df23a38842de2b12212212f49f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=92c43dba501be7df23a38842de2b12212212f49f", "patch": "@@ -38,7 +38,7 @@ use libc;\n use ops::Drop;\n use option::{Some, None, Option};\n use os;\n-use path::{Path, GenericPath};\n+use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n@@ -395,6 +395,63 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n+#[cfg(unix)]\n+/// Parse a string or vector according to the platform's conventions\n+/// for the `PATH` environment variable. Drops empty paths.\n+pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+    unparsed.container_as_bytes()\n+            .split(|b| *b == ':' as u8)\n+            .filter(|s| s.len() > 0)\n+            .map(Path::new)\n+            .collect()\n+}\n+\n+#[cfg(windows)]\n+/// Parse a string or vector according to the platform's conventions\n+/// for the `PATH` environment variable. Drops empty paths.\n+pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+    // On Windows, the PATH environment variable is semicolon separated.  Double\n+    // quotes are used as a way of introducing literal semicolons (since\n+    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+    // permitted in path names, so there is no way to escape a double quote.\n+    // Quoted regions can appear in arbitrary locations, so\n+    //\n+    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+    //\n+    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+    //\n+    // (The above is based on testing; there is no clear reference available\n+    // for the grammar.)\n+\n+    let mut parsed = Vec::new();\n+    let mut in_progress = Vec::new();\n+    let mut in_quote = false;\n+\n+    for b in unparsed.container_as_bytes().iter() {\n+        match *b as char {\n+            ';' if !in_quote => {\n+                // ignore zero-length path strings\n+                if in_progress.len() > 0 {\n+                    parsed.push(Path::new(in_progress.as_slice()));\n+                }\n+                in_progress.truncate(0)\n+            }\n+            '\\\"' => {\n+                in_quote = !in_quote;\n+            }\n+            _  => {\n+                in_progress.push(*b);\n+            }\n+        }\n+    }\n+\n+    if in_progress.len() > 0 {\n+        parsed.push(Path::new(in_progress));\n+    }\n+\n+    parsed\n+}\n+\n /// A low-level OS in-memory pipe.\n pub struct Pipe {\n     /// A file descriptor representing the reading end of the pipe. Data written\n@@ -1502,7 +1559,7 @@ mod tests {\n     use c_str::ToCStr;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute};\n-    use os::{setenv, unsetenv};\n+    use os::{split_paths, setenv, unsetenv};\n     use os;\n     use rand::Rng;\n     use rand;\n@@ -1754,5 +1811,40 @@ mod tests {\n         fs::unlink(&path).unwrap();\n     }\n \n+    #[test]\n+    #[cfg(windows)]\n+    fn split_paths_windows() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed) ==\n+                parsed.iter().map(|s| Path::new(*s)).collect()\n+        }\n+\n+        assert!(check_parse(\"\", []));\n+        assert!(check_parse(r#\"\"\"\"#, []));\n+        assert!(check_parse(\";;\", []));\n+        assert!(check_parse(r\"c:\\\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n+                            [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, [r\"c:\\\", r\"c:\\foo\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+                            [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+    }\n+\n+    #[test]\n+    #[cfg(unix)]\n+    fn split_paths_unix() {\n+        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+            split_paths(unparsed) ==\n+                parsed.iter().map(|s| Path::new(*s)).collect()\n+        }\n+\n+        assert!(check_parse(\"\", []));\n+        assert!(check_parse(\"::\", []));\n+        assert!(check_parse(\"/\", [\"/\"]));\n+        assert!(check_parse(\"/:\", [\"/\"]));\n+        assert!(check_parse(\"/:/usr/local\", [\"/\", \"/usr/local\"]));\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}]}