{"sha": "47f78a2487010d884bd40af173fddd4ac9d9aba8", "node_id": "C_kwDOAAsO6NoAKDQ3Zjc4YTI0ODcwMTBkODg0YmQ0MGFmMTczZmRkZDRhYzlkOWFiYTg", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-17T10:44:57Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-03-21T17:47:23Z"}, "message": "try to evaluate in try_unify", "tree": {"sha": "92f0d609318cb9b6f5eb3e88be942d4e269e0a74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92f0d609318cb9b6f5eb3e88be942d4e269e0a74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f78a2487010d884bd40af173fddd4ac9d9aba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f78a2487010d884bd40af173fddd4ac9d9aba8", "html_url": "https://github.com/rust-lang/rust/commit/47f78a2487010d884bd40af173fddd4ac9d9aba8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f78a2487010d884bd40af173fddd4ac9d9aba8/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8e564715e0eb17130e99e8fcc92a36fce7feaf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e564715e0eb17130e99e8fcc92a36fce7feaf5", "html_url": "https://github.com/rust-lang/rust/commit/d8e564715e0eb17130e99e8fcc92a36fce7feaf5"}], "stats": {"total": 101, "additions": 66, "deletions": 35}, "files": [{"sha": "e1d0da803fce221929f0929725abac93132dc62d", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=47f78a2487010d884bd40af173fddd4ac9d9aba8", "patch": "@@ -691,11 +691,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         a: ty::Unevaluated<'tcx, ()>,\n         b: ty::Unevaluated<'tcx, ()>,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());\n         debug!(\"canonical consts: {:?}\", &canonical.value);\n \n-        self.tcx.try_unify_abstract_consts(canonical.value)\n+        self.tcx.try_unify_abstract_consts(param_env.and(canonical.value))\n     }\n \n     pub fn is_in_snapshot(&self) -> bool {"}, {"sha": "d39ae43fe8c1a7e27e838d2cfa4a183d886ee046", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=47f78a2487010d884bd40af173fddd4ac9d9aba8", "patch": "@@ -329,12 +329,12 @@ rustc_queries! {\n         }\n     }\n \n-    query try_unify_abstract_consts(key: (\n-        ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n-    )) -> bool {\n+    query try_unify_abstract_consts(key:\n+        ty::ParamEnvAnd<'tcx, (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n+    )>) -> bool {\n         desc {\n             |tcx| \"trying to unify the generic constants {} and {}\",\n-            tcx.def_path_str(key.0.def.did), tcx.def_path_str(key.1.def.did)\n+            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n         }\n     }\n "}, {"sha": "5d6cbcf6907069f8b0823129782bd5ee27c0f1ab", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=47f78a2487010d884bd40af173fddd4ac9d9aba8", "patch": "@@ -585,7 +585,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().generic_const_exprs =>\n         {\n-            tcx.try_unify_abstract_consts((au.shrink(), bu.shrink()))\n+            tcx.try_unify_abstract_consts(relation.param_env().and((au.shrink(), bu.shrink())))\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`"}, {"sha": "0c33ea858fd0d8871406f0913dd7262d165ad1ac", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f78a2487010d884bd40af173fddd4ac9d9aba8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=47f78a2487010d884bd40af173fddd4ac9d9aba8", "patch": "@@ -28,13 +28,13 @@ use std::iter;\n use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n+#[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     uv: ty::Unevaluated<'tcx, ()>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n-    debug!(\"is_const_evaluatable({:?})\", uv);\n     let tcx = infcx.tcx;\n \n     if tcx.features().generic_const_exprs {\n@@ -185,6 +185,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n fn satisfied_from_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ct: AbstractConst<'tcx>,\n@@ -197,11 +198,12 @@ fn satisfied_from_param_env<'tcx>(\n                     // Try to unify with each subtree in the AbstractConst to allow for\n                     // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n                     // predicate for `(N + 1) * 2`\n-                    let result =\n-                        walk_abstract_const(tcx, b_ct, |b_ct| match try_unify(tcx, ct, b_ct) {\n+                    let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n+                        match try_unify(tcx, ct, b_ct, param_env) {\n                             true => ControlFlow::BREAK,\n                             false => ControlFlow::CONTINUE,\n-                        });\n+                        }\n+                    });\n \n                     if let ControlFlow::Break(()) = result {\n                         debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n@@ -570,11 +572,12 @@ pub(super) fn thir_abstract_const<'tcx>(\n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> bool {\n     (|| {\n         if let Some(a) = AbstractConst::new(tcx, a)? {\n             if let Some(b) = AbstractConst::new(tcx, b)? {\n-                return Ok(try_unify(tcx, a, b));\n+                return Ok(try_unify(tcx, a, b, param_env));\n             }\n         }\n \n@@ -619,32 +622,59 @@ where\n     recurse(tcx, ct, &mut f)\n }\n \n+// Substitutes generics repeatedly to allow AbstractConsts to unify where a\n+// ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n+// Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+#[inline]\n+#[instrument(skip(tcx), level = \"debug\")]\n+fn try_replace_substs_in_root<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mut abstr_const: AbstractConst<'tcx>,\n+) -> Option<AbstractConst<'tcx>> {\n+    while let Node::Leaf(ct) = abstr_const.root(tcx) {\n+        match AbstractConst::from_const(tcx, ct) {\n+            Ok(Some(act)) => abstr_const = act,\n+            Ok(None) => break,\n+            Err(_) => return None,\n+        }\n+    }\n+\n+    Some(abstr_const)\n+}\n+\n /// Tries to unify two abstract constants using structural equality.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub(super) fn try_unify<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    mut a: AbstractConst<'tcx>,\n-    mut b: AbstractConst<'tcx>,\n+    a: AbstractConst<'tcx>,\n+    b: AbstractConst<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n ) -> bool {\n-    // We substitute generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    while let Node::Leaf(a_ct) = a.root(tcx) {\n-        match AbstractConst::from_const(tcx, a_ct) {\n-            Ok(Some(a_act)) => a = a_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n+    let a = match try_replace_substs_in_root(tcx, a) {\n+        Some(a) => a,\n+        None => {\n+            return true;\n         }\n-    }\n-    while let Node::Leaf(b_ct) = b.root(tcx) {\n-        match AbstractConst::from_const(tcx, b_ct) {\n-            Ok(Some(b_act)) => b = b_act,\n-            Ok(None) => break,\n-            Err(_) => return true,\n+    };\n+\n+    let b = match try_replace_substs_in_root(tcx, b) {\n+        Some(b) => b,\n+        None => {\n+            return true;\n         }\n-    }\n+    };\n \n-    match (a.root(tcx), b.root(tcx)) {\n+    let a_root = a.root(tcx);\n+    let b_root = b.root(tcx);\n+    debug!(?a_root, ?b_root);\n+\n+    match (a_root, b_root) {\n         (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+            let a_ct = a_ct.eval(tcx, param_env);\n+            debug!(\"a_ct evaluated: {:?}\", a_ct);\n+            let b_ct = b_ct.eval(tcx, param_env);\n+            debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n             if a_ct.ty() != b_ct.ty() {\n                 return false;\n             }\n@@ -678,23 +708,23 @@ pub(super) fn try_unify<'tcx>(\n             }\n         }\n         (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(al), b.subtree(bl))\n-                && try_unify(tcx, a.subtree(ar), b.subtree(br))\n+            try_unify(tcx, a.subtree(al), b.subtree(bl), param_env)\n+                && try_unify(tcx, a.subtree(ar), b.subtree(br), param_env)\n         }\n         (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-            try_unify(tcx, a.subtree(av), b.subtree(bv))\n+            try_unify(tcx, a.subtree(av), b.subtree(bv), param_env)\n         }\n         (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n             if a_args.len() == b_args.len() =>\n         {\n-            try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n+            try_unify(tcx, a.subtree(a_f), b.subtree(b_f), param_env)\n                 && iter::zip(a_args, b_args)\n-                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n+                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn), param_env))\n         }\n         (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n             if (a_ty == b_ty) && (a_kind == b_kind) =>\n         {\n-            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand))\n+            try_unify(tcx, a.subtree(a_operand), b.subtree(b_operand), param_env)\n         }\n         // use this over `_ => false` to make adding variants to `Node` less error prone\n         (Node::Cast(..), _)"}]}