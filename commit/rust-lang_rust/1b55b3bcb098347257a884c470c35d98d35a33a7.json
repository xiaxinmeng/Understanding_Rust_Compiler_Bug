{"sha": "1b55b3bcb098347257a884c470c35d98d35a33a7", "node_id": "C_kwDOAAsO6NoAKDFiNTViM2JjYjA5ODM0NzI1N2E4ODRjNDcwYzM1ZDk4ZDM1YTMzYTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T11:23:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-28T11:23:36Z"}, "message": "Auto merge of #2828 - Vanille-N:tb-diags, r=RalfJung\n\nTree Borrows: improved diagnostics\n\nBetter diagnostics for Tree Borrows violations.\n\n- Shows where the conflicting tags (the one that was accessed and the one that had a permission or protector that caused UB) were reborrowed, which is more readable than only `<TAG>`\n- Shows a small history of what happened for the faulty tag to get there (which lines caused it to lose read/write permissions)\n- Explains permissions and transitions in natural language (e.g. \"does not have read permissions\" instead of \"is Disabled\")\n\nNot perfect, but at least testing TB will be less confusing.\n\nLack of range information from `RangeMap` makes selection of relevant events nontrivial: we reconstruct history from knowledge of `(initial, final)` and `(offset, pi, p'i)` so that `initial -> final = p1 -> p1' = p2 -> p2' = p3 -> ... = final `", "tree": {"sha": "b35bc8d0d18faac211924303a489f488beb14ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b35bc8d0d18faac211924303a489f488beb14ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b55b3bcb098347257a884c470c35d98d35a33a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b55b3bcb098347257a884c470c35d98d35a33a7", "html_url": "https://github.com/rust-lang/rust/commit/1b55b3bcb098347257a884c470c35d98d35a33a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b55b3bcb098347257a884c470c35d98d35a33a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0507192fbc2f23797ec17694747e9f4c75d845f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0507192fbc2f23797ec17694747e9f4c75d845f", "html_url": "https://github.com/rust-lang/rust/commit/a0507192fbc2f23797ec17694747e9f4c75d845f"}, {"sha": "7566ed8ff4db1549feeaebe0ed1ca2e0de2c9c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/7566ed8ff4db1549feeaebe0ed1ca2e0de2c9c01", "html_url": "https://github.com/rust-lang/rust/commit/7566ed8ff4db1549feeaebe0ed1ca2e0de2c9c01"}], "stats": {"total": 1048, "additions": 802, "deletions": 246}, "files": [{"sha": "2c6d27ced0180df81e3d8768c6881be94712a68f", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "modified", "additions": 207, "deletions": 38, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,14 +1,90 @@\n-use rustc_data_structures::fx::FxHashMap;\n-\n use std::fmt;\n use std::ops::Range;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::{Span, SpanData};\n+use rustc_target::abi::Size;\n+\n use crate::borrow_tracker::tree_borrows::{\n-    err_tb_ub, perms::Permission, tree::LocationState, unimap::UniIndex,\n+    perms::{PermTransition, Permission},\n+    tree::LocationState,\n+    unimap::UniIndex,\n };\n use crate::borrow_tracker::{AccessKind, ProtectorKind};\n use crate::*;\n \n+/// Complete data for an event:\n+/// - `kind` is what happened to the permissions\n+/// - `access_kind` and `access_range` describe the access that caused the event\n+/// - `offset` allows filtering only the relevant events for a given memory location\n+/// (see how we perform the filtering in `History::extract_relevant`.\n+/// - `span` is the line of code in question\n+#[derive(Clone, Debug)]\n+pub struct Event {\n+    pub transition: PermTransition,\n+    pub access_kind: AccessKind,\n+    pub is_foreign: bool,\n+    pub access_range: AllocRange,\n+    pub offset: Size,\n+    pub span: Span,\n+}\n+\n+/// List of all events that affected a tag.\n+/// NOTE: not all of these events are relevant for a particular location,\n+/// the events should be filtered before the generation of diagnostics.\n+/// Available filtering methods include `History::forget` and `History::extract_relevant`.\n+#[derive(Clone, Debug)]\n+pub struct History {\n+    pub tag: BorTag,\n+    pub created: (Span, Permission),\n+    pub events: Vec<Event>,\n+}\n+\n+/// History formatted for use by `src/diagnostics.rs`.\n+///\n+/// NOTE: needs to be `Send` because of a bound on `MachineStopType`, hence\n+/// the use of `SpanData` rather than `Span`.\n+#[derive(Debug, Clone, Default)]\n+pub struct HistoryData {\n+    pub events: Vec<(Option<SpanData>, String)>, // includes creation\n+}\n+\n+impl History {\n+    /// Record an additional event to the history.\n+    pub fn push(&mut self, event: Event) {\n+        self.events.push(event);\n+    }\n+}\n+\n+impl HistoryData {\n+    // Format events from `new_history` into those recorded by `self`.\n+    //\n+    // NOTE: also converts `Span` to `SpanData`.\n+    pub fn extend(\n+        &mut self,\n+        new_history: History,\n+        tag_name: &'static str,\n+        show_initial_state: bool,\n+    ) {\n+        let History { tag, created, events } = new_history;\n+        let this = format!(\"the {tag_name} tag {tag:?}\");\n+        let msg_initial_state = format!(\", in the initial state {}\", created.1);\n+        let msg_creation = format!(\n+            \"{this} was created here{maybe_msg_initial_state}\",\n+            maybe_msg_initial_state = if show_initial_state { &msg_initial_state } else { \"\" },\n+        );\n+\n+        self.events.push((Some(created.0.data()), msg_creation));\n+        for &Event { transition, access_kind, is_foreign, access_range, span, offset: _ } in &events\n+        {\n+            // NOTE: `offset` is explicitly absent from the error message, it has no significance\n+            // to the user. The meaningful one is `access_range`.\n+            self.events.push((Some(span.data()), format!(\"{this} then transitioned {transition} due to a {rel} {access_kind} at offsets {access_range:?}\", rel = if is_foreign { \"foreign\" } else { \"child\" })));\n+            self.events.push((None, format!(\"this corresponds to {}\", transition.summary())));\n+        }\n+    }\n+}\n+\n /// Some information that is irrelevant for the algorithm but very\n /// convenient to know about a tag for debugging and testing.\n #[derive(Clone, Debug)]\n@@ -20,18 +96,29 @@ pub struct NodeDebugInfo {\n     /// pointer in the source code.\n     /// Helps match tag numbers to human-readable names.\n     pub name: Option<String>,\n+    /// Notable events in the history of this tag, used for\n+    /// diagnostics.\n+    ///\n+    /// NOTE: by virtue of being part of `NodeDebugInfo`,\n+    /// the history is automatically cleaned up by the GC.\n+    /// NOTE: this is `!Send`, it needs to be converted before displaying\n+    /// the actual diagnostics because `src/diagnostics.rs` requires `Send`.\n+    pub history: History,\n }\n+\n impl NodeDebugInfo {\n-    /// New node info with a name.\n-    pub fn new(tag: BorTag) -> Self {\n-        Self { tag, name: None }\n+    /// Information for a new node. By default it has no\n+    /// name and an empty history.\n+    pub fn new(tag: BorTag, initial: Permission, span: Span) -> Self {\n+        let history = History { tag, created: (span, initial), events: Vec::new() };\n+        Self { tag, name: None, history }\n     }\n \n     /// Add a name to the tag. If a same tag is associated to several pointers,\n     /// it can have several names which will be separated by commas.\n-    fn add_name(&mut self, name: &str) {\n+    pub fn add_name(&mut self, name: &str) {\n         if let Some(ref mut prev_name) = &mut self.name {\n-            prev_name.push(',');\n+            prev_name.push_str(\", \");\n             prev_name.push_str(name);\n         } else {\n             self.name = Some(String::from(name));\n@@ -42,7 +129,7 @@ impl NodeDebugInfo {\n impl fmt::Display for NodeDebugInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if let Some(ref name) = self.name {\n-            write!(f, \"{tag:?} (also named '{name}')\", tag = self.tag)\n+            write!(f, \"{tag:?} ({name})\", tag = self.tag)\n         } else {\n             write!(f, \"{tag:?}\", tag = self.tag)\n         }\n@@ -86,7 +173,7 @@ impl<'tcx> Tree {\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n pub(super) enum TransitionError {\n     /// This access is not allowed because some parent tag has insufficient permissions.\n     /// For example, if a tag is `Frozen` and encounters a child write this will\n@@ -96,63 +183,145 @@ pub(super) enum TransitionError {\n     /// A protector was triggered due to an invalid transition that loses\n     /// too much permissions.\n     /// For example, if a protected tag goes from `Active` to `Frozen` due\n-    /// to a foreign write this will produce a `ProtectedTransition(Active, Frozen)`.\n+    /// to a foreign write this will produce a `ProtectedTransition(PermTransition(Active, Frozen))`.\n     /// This kind of error can only occur on foreign accesses.\n-    ProtectedTransition(Permission, Permission),\n+    ProtectedTransition(PermTransition),\n     /// Cannot deallocate because some tag in the allocation is strongly protected.\n     /// This kind of error can only occur on deallocations.\n     ProtectedDealloc,\n }\n \n+impl History {\n+    /// Keep only the tag and creation\n+    fn forget(&self) -> Self {\n+        History { events: Vec::new(), created: self.created, tag: self.tag }\n+    }\n+\n+    /// Reconstruct the history relevant to `error_offset` knowing that\n+    /// its permission followed `complete_transition`.\n+    ///\n+    /// Here's how we do this:\n+    /// - we know `full := complete_transition` the transition of the permission from\n+    /// its initialization to the state just before the error was caused,\n+    /// we want to find a chain of events that produces `full`\n+    /// - we decompose `full` into `pre o post` where\n+    /// `pre` is the best applicable transition from recorded events\n+    /// - we select the event that caused `pre` and iterate\n+    /// to find the chain of events that produces `full := post`\n+    ///\n+    /// To find the \"best applicable transition\" for full:\n+    /// - eliminate events that cannot be applied because their offset is too big\n+    /// - eliminate events that cannot be applied because their starting point is wrong\n+    /// - select the one that happened closest to the range of interest\n+    fn extract_relevant(&self, complete_transition: PermTransition, error_offset: Size) -> Self {\n+        let mut selected_events: Vec<Event> = Vec::new();\n+        let mut full = complete_transition;\n+        while !full.is_noop() {\n+            let (pre, post) = self\n+                .events\n+                .iter()\n+                .filter(|e| e.offset <= error_offset)\n+                .filter_map(|pre_canditate| {\n+                    full.apply_start(pre_canditate.transition)\n+                        .map(|post_canditate| (pre_canditate, post_canditate))\n+                })\n+                .max_by_key(|(pre_canditate, _post_candidate)| pre_canditate.offset)\n+                .unwrap();\n+            // If this occurs we will loop infinitely !\n+            // Make sure to only put non-noop transitions in `History`.\n+            assert!(!pre.transition.is_noop());\n+            full = post;\n+            selected_events.push(pre.clone());\n+        }\n+\n+        History { events: selected_events, created: self.created, tag: self.tag }\n+    }\n+}\n+\n /// Failures that can occur during the execution of Tree Borrows procedures.\n pub(super) struct TbError<'node> {\n     /// What failure occurred.\n     pub error_kind: TransitionError,\n+    /// The byte at which the conflict occured.\n+    pub error_offset: Size,\n     /// The tag on which the error was triggered.\n     /// On protector violations, this is the tag that was protected.\n     /// On accesses rejected due to insufficient permissions, this is the\n     /// tag that lacked those permissions.\n-    pub faulty_tag: &'node NodeDebugInfo,\n+    pub conflicting_info: &'node NodeDebugInfo,\n     /// Whether this was a Read or Write access. This field is ignored\n     /// when the error was triggered by a deallocation.\n     pub access_kind: AccessKind,\n     /// Which tag the access that caused this error was made through, i.e.\n     /// which tag was used to read/write/deallocate.\n-    pub tag_of_access: &'node NodeDebugInfo,\n+    pub accessed_info: &'node NodeDebugInfo,\n }\n \n impl TbError<'_> {\n     /// Produce a UB error.\n-    pub fn build<'tcx>(self) -> InterpErrorInfo<'tcx> {\n+    pub fn build<'tcx>(self) -> InterpError<'tcx> {\n         use TransitionError::*;\n-        err_tb_ub(match self.error_kind {\n+        let started_as = self.conflicting_info.history.created.1;\n+        let kind = self.access_kind;\n+        let accessed = self.accessed_info;\n+        let conflicting = self.conflicting_info;\n+        let accessed_is_conflicting = accessed.tag == conflicting.tag;\n+        let (pre_error, title, details, conflicting_tag_name) = match self.error_kind {\n             ChildAccessForbidden(perm) => {\n-                format!(\n-                    \"{kind} through {initial} is forbidden because it is a child of {current} which is {perm}.\",\n-                    kind=self.access_kind,\n-                    initial=self.tag_of_access,\n-                    current=self.faulty_tag,\n-                    perm=perm,\n-                )\n+                let conflicting_tag_name =\n+                    if accessed_is_conflicting { \"accessed\" } else { \"conflicting\" };\n+                let title = format!(\"{kind} through {accessed} is forbidden\");\n+                let mut details = Vec::new();\n+                if !accessed_is_conflicting {\n+                    details.push(format!(\n+                        \"the accessed tag {accessed} is a child of the conflicting tag {conflicting}\"\n+                    ));\n+                }\n+                details.push(format!(\n+                    \"the {conflicting_tag_name} tag {conflicting} has state {perm} which forbids child {kind}es\"\n+                ));\n+                (perm, title, details, conflicting_tag_name)\n             }\n-            ProtectedTransition(start, end) => {\n-                format!(\n-                    \"{kind} through {initial} is forbidden because it is a foreign tag for {current}, which would hence change from {start} to {end}, but {current} is protected\",\n-                    current=self.faulty_tag,\n-                    start=start,\n-                    end=end,\n-                    kind=self.access_kind,\n-                    initial=self.tag_of_access,\n-                )\n+            ProtectedTransition(transition) => {\n+                let conflicting_tag_name = \"protected\";\n+                let title = format!(\"{kind} through {accessed} is forbidden\");\n+                let details = vec![\n+                    format!(\n+                        \"the accessed tag {accessed} is foreign to the {conflicting_tag_name} tag {conflicting} (i.e., it is not a child)\"\n+                    ),\n+                    format!(\n+                        \"the access would cause the {conflicting_tag_name} tag {conflicting} to transition {transition}\"\n+                    ),\n+                    format!(\n+                        \"this is {loss}, which is not allowed for protected tags\",\n+                        loss = transition.summary(),\n+                    ),\n+                ];\n+                (transition.started(), title, details, conflicting_tag_name)\n             }\n             ProtectedDealloc => {\n-                format!(\n-                    \"the allocation of {initial} also contains {current} which is strongly protected, cannot deallocate\",\n-                    initial=self.tag_of_access,\n-                    current=self.faulty_tag,\n-                )\n+                let conflicting_tag_name = \"strongly protected\";\n+                let title = format!(\"deallocation through {accessed} is forbidden\");\n+                let details = vec![\n+                    format!(\n+                        \"the allocation of the accessed tag {accessed} also contains the {conflicting_tag_name} tag {conflicting}\"\n+                    ),\n+                    format!(\"the {conflicting_tag_name} tag {conflicting} disallows deallocations\"),\n+                ];\n+                (started_as, title, details, conflicting_tag_name)\n             }\n-        }).into()\n+        };\n+        let pre_transition = PermTransition::from(started_as, pre_error).unwrap();\n+        let mut history = HistoryData::default();\n+        if !accessed_is_conflicting {\n+            history.extend(self.accessed_info.history.forget(), \"accessed\", false);\n+        }\n+        history.extend(\n+            self.conflicting_info.history.extract_relevant(pre_transition, self.error_offset),\n+            conflicting_tag_name,\n+            true,\n+        );\n+        err_machine_stop!(TerminationInfo::TreeBorrowsUb { title, details, history })\n     }\n }\n "}, {"sha": "3361d212f2c0837bd6e9b8dbfbed83ad06aa838c", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::{\n \n use crate::*;\n \n-mod diagnostics;\n+pub mod diagnostics;\n mod perms;\n mod tree;\n mod unimap;\n@@ -23,10 +23,6 @@ pub use tree::Tree;\n \n pub type AllocState = Tree;\n \n-pub fn err_tb_ub<'tcx>(msg: String) -> InterpError<'tcx> {\n-    err_machine_stop!(TerminationInfo::TreeBorrowsUb { msg })\n-}\n-\n impl<'tcx> Tree {\n     /// Create a new allocation, i.e. a new tree\n     pub fn new_allocation(\n@@ -37,7 +33,8 @@ impl<'tcx> Tree {\n         machine: &MiriMachine<'_, 'tcx>,\n     ) -> Self {\n         let tag = state.base_ptr_tag(id, machine); // Fresh tag for the root\n-        Tree::new(tag, size)\n+        let span = machine.current_span();\n+        Tree::new(tag, size, span)\n     }\n \n     /// Check that an access on the entire range is permitted, and update\n@@ -64,7 +61,8 @@ impl<'tcx> Tree {\n             ProvenanceExtra::Wildcard => return Ok(()),\n         };\n         let global = machine.borrow_tracker.as_ref().unwrap();\n-        self.perform_access(access_kind, tag, range, global)\n+        let span = machine.current_span();\n+        self.perform_access(access_kind, tag, range, global, span)\n     }\n \n     /// Check that this pointer has permission to deallocate this range.\n@@ -82,7 +80,8 @@ impl<'tcx> Tree {\n             ProvenanceExtra::Wildcard => return Ok(()),\n         };\n         let global = machine.borrow_tracker.as_ref().unwrap();\n-        self.dealloc(tag, range, global)\n+        let span = machine.current_span();\n+        self.dealloc(tag, range, global, span)\n     }\n \n     pub fn expose_tag(&mut self, _tag: BorTag) {\n@@ -265,21 +264,23 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 .insert(new_tag, protect);\n         }\n \n+        let span = this.machine.current_span();\n         let alloc_extra = this.get_alloc_extra(alloc_id)?;\n         let range = alloc_range(base_offset, ptr_size);\n         let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n \n         if new_perm.perform_read_access {\n             // Count this reborrow as a read access\n             let global = &this.machine.borrow_tracker.as_ref().unwrap();\n-            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global)?;\n+            let span = this.machine.current_span();\n+            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global, span)?;\n             if let Some(data_race) = alloc_extra.data_race.as_ref() {\n                 data_race.read(alloc_id, range, &this.machine)?;\n             }\n         }\n \n         // Record the parent-child pair in the tree.\n-        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range)?;\n+        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range, span)?;\n         Ok(Some((alloc_id, new_tag)))\n     }\n "}, {"sha": "7e3e587db7248e3a1e240bd5ba6583384526b5b1", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "modified", "additions": 136, "deletions": 64, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n use crate::borrow_tracker::tree_borrows::tree::AccessRelatedness;\n use crate::borrow_tracker::AccessKind;\n \n-/// The activation states of a pointer\n+/// The activation states of a pointer.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum PermissionPriv {\n     /// represents: a local reference that has not yet been written to;\n@@ -112,47 +112,14 @@ mod transition {\n     }\n }\n \n-impl PermissionPriv {\n-    /// Determines whether a transition that occurred is compatible with the presence\n-    /// of a Protector. This is not included in the `transition` functions because\n-    /// it would distract from the few places where the transition is modified\n-    /// because of a protector, but not forbidden.\n-    fn protector_allows_transition(self, new: Self) -> bool {\n-        match (self, new) {\n-            _ if self == new => true,\n-            // It is always a protector violation to not be readable anymore\n-            (_, Disabled) => false,\n-            // In the case of a `Reserved` under a protector, both transitions\n-            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n-            // The first is standard (Child Write), the second is for Foreign Writes\n-            // on protected Reserved where we must ensure that the pointer is not\n-            // written to in the future.\n-            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n-            // This pointer should have stayed writeable for the whole function\n-            (Active, Frozen) => false,\n-            _ => unreachable!(\"Transition from {self:?} to {new:?} should never be possible\"),\n-        }\n-    }\n-}\n-\n /// Public interface to the state machine that controls read-write permissions.\n+/// This is the \"private `enum`\" pattern.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct Permission(PermissionPriv);\n \n-impl fmt::Display for Permission {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}\",\n-            match self.0 {\n-                PermissionPriv::Reserved { .. } => \"Reserved\",\n-                PermissionPriv::Active => \"Active\",\n-                PermissionPriv::Frozen => \"Frozen\",\n-                PermissionPriv::Disabled => \"Disabled\",\n-            }\n-        )\n-    }\n-}\n+/// Transition from one permission to the next.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct PermTransition(PermissionPriv, PermissionPriv);\n \n impl Permission {\n     /// Default initial permission of the root of a new tree.\n@@ -170,43 +137,148 @@ impl Permission {\n         Self(Frozen)\n     }\n \n-    /// Pretty-printing. Needs to be here and not in diagnostics.rs\n-    /// because `Self` is private.\n-    pub fn short_name(self) -> &'static str {\n-        // Make sure there are all of the same length as each other\n-        // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n-        // alignment will be incorrect.\n-        match self.0 {\n-            Reserved { ty_is_freeze: true } => \"Res\",\n-            Reserved { ty_is_freeze: false } => \"Re*\",\n-            Active => \"Act\",\n-            Frozen => \"Frz\",\n-            Disabled => \"Dis\",\n-        }\n+    /// Apply the transition to the inner PermissionPriv.\n+    pub fn perform_access(\n+        kind: AccessKind,\n+        rel_pos: AccessRelatedness,\n+        old_perm: Self,\n+        protected: bool,\n+    ) -> Option<PermTransition> {\n+        let old_state = old_perm.0;\n+        transition::perform_access(kind, rel_pos, old_state, protected)\n+            .map(|new_state| PermTransition(old_state, new_state))\n     }\n+}\n \n-    /// Check that there are no complaints from a possible protector.\n+impl PermTransition {\n+    /// All transitions created through normal means (using `perform_access`)\n+    /// should be possible, but the same is not guaranteed by construction of\n+    /// transitions inferred by diagnostics. This checks that a transition\n+    /// reconstructed by diagnostics is indeed one that could happen.\n+    fn is_possible(old: PermissionPriv, new: PermissionPriv) -> bool {\n+        old <= new\n+    }\n+\n+    pub fn from(old: Permission, new: Permission) -> Option<Self> {\n+        Self::is_possible(old.0, new.0).then_some(Self(old.0, new.0))\n+    }\n+\n+    pub fn is_noop(self) -> bool {\n+        self.0 == self.1\n+    }\n+\n+    /// Extract result of a transition (checks that the starting point matches).\n+    pub fn applied(self, starting_point: Permission) -> Option<Permission> {\n+        (starting_point.0 == self.0).then_some(Permission(self.1))\n+    }\n+\n+    /// Extract starting point of a transition\n+    pub fn started(self) -> Permission {\n+        Permission(self.0)\n+    }\n+\n+    /// Determines whether a transition that occured is compatible with the presence\n+    /// of a Protector. This is not included in the `transition` functions because\n+    /// it would distract from the few places where the transition is modified\n+    /// because of a protector, but not forbidden.\n     ///\n     /// Note: this is not in charge of checking that there *is* a protector,\n     /// it should be used as\n     /// ```\n     /// let no_protector_error = if is_protected(tag) {\n-    ///     old_perm.protector_allows_transition(new_perm)\n+    ///     transition.is_allowed_by_protector()\n     /// };\n     /// ```\n-    pub fn protector_allows_transition(self, new: Self) -> bool {\n-        self.0.protector_allows_transition(new.0)\n+    pub fn is_allowed_by_protector(&self) -> bool {\n+        let &Self(old, new) = self;\n+        assert!(Self::is_possible(old, new));\n+        match (old, new) {\n+            _ if old == new => true,\n+            // It is always a protector violation to not be readable anymore\n+            (_, Disabled) => false,\n+            // In the case of a `Reserved` under a protector, both transitions\n+            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n+            // The first is standard (Child Write), the second is for Foreign Writes\n+            // on protected Reserved where we must ensure that the pointer is not\n+            // written to in the future.\n+            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n+            // This pointer should have stayed writeable for the whole function\n+            (Active, Frozen) => false,\n+            _ => unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n+        }\n     }\n \n-    /// Apply the transition to the inner PermissionPriv.\n-    pub fn perform_access(\n-        kind: AccessKind,\n-        rel_pos: AccessRelatedness,\n-        old_perm: Self,\n-        protected: bool,\n-    ) -> Option<Self> {\n-        let old_state = old_perm.0;\n-        transition::perform_access(kind, rel_pos, old_state, protected).map(Self)\n+    /// Composition function: get the transition that can be added after `app` to\n+    /// produce `self`.\n+    pub fn apply_start(self, app: Self) -> Option<Self> {\n+        let new_start = app.applied(Permission(self.0))?;\n+        Self::from(new_start, Permission(self.1))\n+    }\n+}\n+\n+pub mod diagnostics {\n+    use super::*;\n+    impl fmt::Display for PermissionPriv {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(\n+                f,\n+                \"{}\",\n+                match self {\n+                    PermissionPriv::Reserved { .. } => \"Reserved\",\n+                    PermissionPriv::Active => \"Active\",\n+                    PermissionPriv::Frozen => \"Frozen\",\n+                    PermissionPriv::Disabled => \"Disabled\",\n+                }\n+            )\n+        }\n+    }\n+\n+    impl fmt::Display for PermTransition {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"from {} to {}\", self.0, self.1)\n+        }\n+    }\n+\n+    impl fmt::Display for Permission {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"{}\", self.0)\n+        }\n+    }\n+\n+    impl Permission {\n+        /// Abbreviated name of the permission (uniformly 3 letters for nice alignment).\n+        pub fn short_name(self) -> &'static str {\n+            // Make sure there are all of the same length as each other\n+            // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n+            // alignment will be incorrect.\n+            match self.0 {\n+                Reserved { ty_is_freeze: true } => \"Res\",\n+                Reserved { ty_is_freeze: false } => \"Re*\",\n+                Active => \"Act\",\n+                Frozen => \"Frz\",\n+                Disabled => \"Dis\",\n+            }\n+        }\n+    }\n+\n+    impl PermTransition {\n+        /// Readable explanation of the consequences of an event.\n+        /// Fits in the sentence \"This accessed caused {trans.summary()}\".\n+        ///\n+        /// Important: for the purposes of this explanation, `Reserved` is considered\n+        /// to have write permissions, because that's what the diagnostics care about\n+        /// (otherwise `Reserved -> Frozen` would be considered a noop).\n+        pub fn summary(&self) -> &'static str {\n+            assert!(Self::is_possible(self.0, self.1));\n+            match (self.0, self.1) {\n+                (_, Active) => \"an activation\",\n+                (_, Frozen) => \"a loss of write permissions\",\n+                (Frozen, Disabled) => \"a loss of read permissions\",\n+                (_, Disabled) => \"a loss of read and write permissions\",\n+                (old, new) =>\n+                    unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n+            }\n+        }\n     }\n }\n "}, {"sha": "6392f5101ad5f9a2ebb3bbc257d9bbe1ad541861", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -14,10 +14,11 @@ use smallvec::SmallVec;\n \n use rustc_const_eval::interpret::InterpResult;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_span::Span;\n use rustc_target::abi::Size;\n \n use crate::borrow_tracker::tree_borrows::{\n-    diagnostics::{NodeDebugInfo, TbError, TransitionError},\n+    diagnostics::{self, NodeDebugInfo, TbError, TransitionError},\n     unimap::{UniEntry, UniIndex, UniKeyMap, UniValMap},\n     Permission,\n };\n@@ -118,7 +119,7 @@ pub(super) struct Node {\n /// Data given to the transition function\n struct NodeAppArgs<'node> {\n     /// Node on which the transition is currently being applied\n-    node: &'node Node,\n+    node: &'node mut Node,\n     /// Mutable access to its permissions\n     perm: UniEntry<'node, LocationState>,\n     /// Relative position of the access\n@@ -131,14 +132,17 @@ struct ErrHandlerArgs<'node, InErr> {\n     /// Tag that triggered the error (not the tag that was accessed,\n     /// rather the parent tag that had insufficient permissions or the\n     /// non-parent tag that had a protector).\n-    faulty_tag: &'node NodeDebugInfo,\n+    conflicting_info: &'node NodeDebugInfo,\n+    /// Information about the tag that was accessed just before the\n+    /// error was triggered.\n+    accessed_info: &'node NodeDebugInfo,\n }\n /// Internal contents of `Tree` with the minimum of mutable access for\n /// the purposes of the tree traversal functions: the permissions (`perms`) can be\n /// updated but not the tree structure (`tag_mapping` and `nodes`)\n struct TreeVisitor<'tree> {\n     tag_mapping: &'tree UniKeyMap<BorTag>,\n-    nodes: &'tree UniValMap<Node>,\n+    nodes: &'tree mut UniValMap<Node>,\n     perms: &'tree mut UniValMap<LocationState>,\n }\n \n@@ -167,6 +171,7 @@ impl<'tree> TreeVisitor<'tree> {\n     ) -> Result<(), OutErr>\n where {\n         struct TreeVisitAux<NodeApp, ErrHandler> {\n+            accessed_tag: UniIndex,\n             f_propagate: NodeApp,\n             err_builder: ErrHandler,\n             stack: Vec<(UniIndex, AccessRelatedness)>,\n@@ -190,15 +195,21 @@ where {\n                 rel_pos: AccessRelatedness,\n             ) -> Result<(), OutErr> {\n                 // 1. apply the propagation function\n-                let node = this.nodes.get(tag).unwrap();\n+                let node = this.nodes.get_mut(tag).unwrap();\n                 let recurse =\n                     (self.f_propagate)(NodeAppArgs { node, perm: this.perms.entry(tag), rel_pos })\n                         .map_err(|error_kind| {\n                             (self.err_builder)(ErrHandlerArgs {\n                                 error_kind,\n-                                faulty_tag: &node.debug_info,\n+                                conflicting_info: &this.nodes.get(tag).unwrap().debug_info,\n+                                accessed_info: &this\n+                                    .nodes\n+                                    .get(self.accessed_tag)\n+                                    .unwrap()\n+                                    .debug_info,\n                             })\n                         })?;\n+                let node = this.nodes.get(tag).unwrap();\n                 // 2. add the children to the stack for future traversal\n                 if matches!(recurse, ContinueTraversal::Recurse) {\n                     let child_rel = rel_pos.for_child();\n@@ -214,7 +225,8 @@ where {\n         }\n \n         let start_idx = self.tag_mapping.get(&start).unwrap();\n-        let mut stack = TreeVisitAux { f_propagate, err_builder, stack: Vec::new() };\n+        let mut stack =\n+            TreeVisitAux { accessed_tag: start_idx, f_propagate, err_builder, stack: Vec::new() };\n         {\n             let mut path_ascend = Vec::new();\n             // First climb to the root while recording the path\n@@ -262,20 +274,23 @@ where {\n \n impl Tree {\n     /// Create a new tree, with only a root pointer.\n-    pub fn new(root_tag: BorTag, size: Size) -> Self {\n+    pub fn new(root_tag: BorTag, size: Size, span: Span) -> Self {\n         let root_perm = Permission::new_root();\n         let mut tag_mapping = UniKeyMap::default();\n         let root_idx = tag_mapping.insert(root_tag);\n         let nodes = {\n             let mut nodes = UniValMap::<Node>::default();\n+            let mut debug_info = NodeDebugInfo::new(root_tag, root_perm, span);\n+            // name the root so that all allocations contain one named pointer\n+            debug_info.add_name(\"root of the allocation\");\n             nodes.insert(\n                 root_idx,\n                 Node {\n                     tag: root_tag,\n                     parent: None,\n                     children: SmallVec::default(),\n                     default_initial_perm: root_perm,\n-                    debug_info: NodeDebugInfo::new(root_tag),\n+                    debug_info,\n                 },\n             );\n             nodes\n@@ -297,6 +312,7 @@ impl<'tcx> Tree {\n         new_tag: BorTag,\n         default_initial_perm: Permission,\n         range: AllocRange,\n+        span: Span,\n     ) -> InterpResult<'tcx> {\n         assert!(!self.tag_mapping.contains_key(&new_tag));\n         let idx = self.tag_mapping.insert(new_tag);\n@@ -309,7 +325,7 @@ impl<'tcx> Tree {\n                 parent: Some(parent_idx),\n                 children: SmallVec::default(),\n                 default_initial_perm,\n-                debug_info: NodeDebugInfo::new(new_tag),\n+                debug_info: NodeDebugInfo::new(new_tag, default_initial_perm, span),\n             },\n         );\n         // Register new_tag as a child of parent_tag\n@@ -330,11 +346,11 @@ impl<'tcx> Tree {\n         tag: BorTag,\n         range: AllocRange,\n         global: &GlobalState,\n+        span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        self.perform_access(AccessKind::Write, tag, range, global)?;\n-        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n-        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n-            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+        self.perform_access(AccessKind::Write, tag, range, global, span)?;\n+        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n                     |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n@@ -347,13 +363,14 @@ impl<'tcx> Tree {\n                             Ok(ContinueTraversal::Recurse)\n                         }\n                     },\n-                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n-                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpError<'tcx> {\n+                        let ErrHandlerArgs { error_kind, conflicting_info, accessed_info } = args;\n                         TbError {\n-                            faulty_tag,\n+                            conflicting_info,\n                             access_kind: AccessKind::Write,\n+                            error_offset: offset,\n                             error_kind,\n-                            tag_of_access: access_info,\n+                            accessed_info,\n                         }\n                         .build()\n                     },\n@@ -373,10 +390,10 @@ impl<'tcx> Tree {\n         tag: BorTag,\n         range: AllocRange,\n         global: &GlobalState,\n+        span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n-        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n-            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n                     |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n@@ -424,24 +441,42 @@ impl<'tcx> Tree {\n \n                         let old_perm = old_state.permission;\n                         let protected = global.borrow().protected_tags.contains_key(&node.tag);\n-                        let new_perm =\n+                        let transition =\n                             Permission::perform_access(access_kind, rel_pos, old_perm, protected)\n                                 .ok_or(TransitionError::ChildAccessForbidden(old_perm))?;\n                         if protected\n                             // Can't trigger Protector on uninitialized locations\n                             && old_state.initialized\n-                            && !old_perm.protector_allows_transition(new_perm)\n+                            && !transition.is_allowed_by_protector()\n                         {\n-                            return Err(TransitionError::ProtectedTransition(old_perm, new_perm));\n+                            return Err(TransitionError::ProtectedTransition(transition));\n+                        }\n+                        // Record the event as part of the history\n+                        if !transition.is_noop() {\n+                            node.debug_info.history.push(diagnostics::Event {\n+                                transition,\n+                                access_kind,\n+                                access_range: range,\n+                                is_foreign: rel_pos.is_foreign(),\n+                                offset,\n+                                span,\n+                            });\n+                            old_state.permission =\n+                                transition.applied(old_state.permission).unwrap();\n                         }\n-                        old_state.permission = new_perm;\n                         old_state.initialized |= !rel_pos.is_foreign();\n                         Ok(ContinueTraversal::Recurse)\n                     },\n-                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n-                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n-                        TbError { faulty_tag, access_kind, error_kind, tag_of_access: access_info }\n-                            .build()\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpError<'tcx> {\n+                        let ErrHandlerArgs { error_kind, conflicting_info, accessed_info } = args;\n+                        TbError {\n+                            conflicting_info,\n+                            access_kind,\n+                            error_offset: offset,\n+                            error_kind,\n+                            accessed_info,\n+                        }\n+                        .build()\n                     },\n                 )?;\n         }"}, {"sha": "aeba0ea5a9524f66cee0015ba8a6c01e4a78b282", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -7,6 +7,7 @@ use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::borrow_tracker::stacked_borrows::diagnostics::TagHistory;\n+use crate::borrow_tracker::tree_borrows::diagnostics as tree_diagnostics;\n use crate::*;\n \n /// Details of premature program termination.\n@@ -23,8 +24,9 @@ pub enum TerminationInfo {\n         history: Option<TagHistory>,\n     },\n     TreeBorrowsUb {\n-        msg: String,\n-        // FIXME: incomplete\n+        title: String,\n+        details: Vec<String>,\n+        history: tree_diagnostics::HistoryData,\n     },\n     Int2PtrWithStrictProvenance,\n     Deadlock,\n@@ -65,7 +67,7 @@ impl fmt::Display for TerminationInfo {\n                     \"integer-to-pointer casts and `ptr::from_exposed_addr` are not supported with `-Zmiri-strict-provenance`\"\n                 ),\n             StackedBorrowsUb { msg, .. } => write!(f, \"{msg}\"),\n-            TreeBorrowsUb { msg } => write!(f, \"{msg}\"),\n+            TreeBorrowsUb { title, .. } => write!(f, \"{title}\"),\n             Deadlock => write!(f, \"the evaluated program deadlocked\"),\n             MultipleSymbolDefinitions { link_name, .. } =>\n                 write!(f, \"multiple definitions of symbol `{link_name}`\"),\n@@ -219,10 +221,16 @@ pub fn report_error<'tcx, 'mir>(\n                 }\n                 helps\n             },\n-            TreeBorrowsUb { .. } => {\n-                let helps = vec![\n-                    (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\")),\n+            TreeBorrowsUb { title: _, details, history } => {\n+                let mut helps = vec![\n+                    (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\"))\n                 ];\n+                for m in details {\n+                    helps.push((None, m.clone()));\n+                }\n+                for event in history.events.clone() {\n+                    helps.push(event);\n+                }\n                 helps\n             }\n             MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>"}, {"sha": "bb601fc88352d6c23aedd4674584163b5dc44952", "filename": "src/tools/miri/tests/fail/tree-borrows/alternate-read-write.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,11 +1,35 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/alternate-read-write.rs:LL:CC\n    |\n LL |     *y += 1; // Failure\n-   |     ^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |     ^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let y = unsafe { &mut *(x as *mut u8) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let y = unsafe { &mut *(x as *mut u8) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     *y += 1; // Success\n+   |     ^^^^^^^\n+   = help: this corresponds to an activation\n+help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let _val = *x;\n+   |                ^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/alternate-read-write.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "d9980e75d6051c694373f733540496c780e79ae4", "filename": "src/tools/miri/tests/fail/tree-borrows/error-range.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -0,0 +1,27 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+use core::ptr::addr_of_mut;\n+\n+// Check that the diagnostics correctly report the exact range at fault\n+// and trim irrelevant events.\n+fn main() {\n+    unsafe {\n+        let data = &mut [0u8; 16];\n+\n+        // Create and activate a few bytes\n+        let rmut = &mut *addr_of_mut!(data[0..6]);\n+        rmut[3] += 1;\n+        rmut[4] += 1;\n+        rmut[5] += 1;\n+\n+        // Now make them lose some perms\n+        let _v = data[3];\n+        let _v = data[4];\n+        let _v = data[5];\n+        data[4] = 1;\n+        data[5] = 1;\n+\n+        // Final test\n+        rmut[5] += 1; //~ ERROR: /read access through .* is forbidden/\n+    }\n+}"}, {"sha": "bc829fd86d35094c50fe0a814fe1842caedd68f8", "filename": "src/tools/miri/tests/fail/tree-borrows/error-range.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -0,0 +1,44 @@\n+error: Undefined Behavior: read access through <TAG> is forbidden\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         rmut[5] += 1;\n+   |         ^^^^^^^^^^^^ read access through <TAG> is forbidden\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Disabled which forbids child read accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let rmut = &mut *addr_of_mut!(data[0..6]);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let rmut = &mut *addr_of_mut!(data[0..6]);\n+   |                                       ^^^^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         rmut[5] += 1;\n+   |         ^^^^^^^^^^^^\n+   = help: this corresponds to an activation\n+help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let _v = data[5];\n+   |                  ^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+help: the conflicting tag <TAG> then transitioned from Frozen to Disabled due to a foreign write access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         data[5] = 1;\n+   |         ^^^^^^^^^^^\n+   = help: this corresponds to a loss of read permissions\n+   = note: BACKTRACE (of the first span):\n+   = note: inside `main` at $DIR/error-range.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "8e80bdd63c0bed64feab6e6b7d752f99acb40090", "filename": "src/tools/miri/tests/fail/tree-borrows/fragile-data-race.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,11 +1,29 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/fragile-data-race.rs:LL:CC\n    |\n LL |     unsafe { *p = 1 };\n-   |              ^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |              ^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/fragile-data-race.rs:LL:CC\n+   |\n+LL | fn thread_1(x: &mut u8) -> SendPtr {\n+   |             ^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> RUSTLIB/std/src/panic.rs:LL:CC\n+   |\n+LL | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n+   |                                                       ^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL |             crate::intrinsics::read_via_copy(src)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/fragile-data-race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "14696c704fc1b8e6beb10a1d6d2b64c89a44d7aa", "filename": "src/tools/miri/tests/fail/tree-borrows/outside-range.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,11 +1,24 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/outside-range.rs:LL:CC\n    |\n LL |     *y.add(3) = 42;\n-   |     ^^^^^^^^^^^^^^ write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+   |     ^^^^^^^^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is foreign to the protected tag <TAG> (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL |         let raw = data.as_mut_ptr();\n+   |                   ^^^^^^^^^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL | unsafe fn stuff(x: &mut u8, y: *mut u8) {\n+   |                 ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `stuff` at $DIR/outside-range.rs:LL:CC\n note: inside `main`\n   --> $DIR/outside-range.rs:LL:CC"}, {"sha": "8c9c2f8f9656b2344a43e1583ac52c3731f30417", "filename": "src/tools/miri/tests/fail/tree-borrows/read-to-local.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,12 +1,31 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/read-to-local.rs:LL:CC\n    |\n LL |         *ptr = 0;\n-   |         ^^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |         ^^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         let mref = &mut root;\n+   |                    ^^^^^^^^^\n+help: the accessed tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         *ptr = 0; // Write\n+   |         ^^^^^^^^\n+   = help: this corresponds to an activation\n+help: the accessed tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         assert_eq!(root, 0); // Parent Read\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/read-to-local.rs:LL:CC\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "b85793ff0633758e1225aef234cf3da3d5c0cb0e", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/cell-protected-write.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,20 +1,34 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Re*|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Re*|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y, callee:y, caller:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+error: Undefined Behavior: write access through <TAG> (y, callee:y, caller:y) is forbidden\n   --> $DIR/cell-protected-write.rs:LL:CC\n    |\n LL |             *y = 1;\n-   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |             ^^^^^^ write access through <TAG> (y, callee:y, caller:y) is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> (y, callee:y, caller:y) is foreign to the protected tag <TAG> (callee:x) (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> (callee:x) to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |         let y = (&mut *n).get();\n+   |                 ^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |         unsafe fn write_second(x: &mut UnsafeCell<u8>, y: *mut u8) {\n+   |                                ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main::write_second` at $DIR/cell-protected-write.rs:LL:CC\n note: inside `main`\n   --> $DIR/cell-protected-write.rs:LL:CC"}, {"sha": "5de7dc0c7c51fd79bd3fe2d46bfb298f8c7253ff", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/int-protected-write.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,20 +1,34 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=n>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=n>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y, callee:y, caller:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+error: Undefined Behavior: write access through <TAG> (y, callee:y, caller:y) is forbidden\n   --> $DIR/int-protected-write.rs:LL:CC\n    |\n LL |             *y = 0;\n-   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |             ^^^^^^ write access through <TAG> (y, callee:y, caller:y) is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> (y, callee:y, caller:y) is foreign to the protected tag <TAG> (callee:x) (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> (callee:x) to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |         let y = (&mut *n) as *mut _;\n+   |                 ^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |         unsafe fn write_second(x: &mut u8, y: *mut u8) {\n+   |                                ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main::write_second` at $DIR/int-protected-write.rs:LL:CC\n note: inside `main`\n   --> $DIR/int-protected-write.rs:LL:CC"}, {"sha": "a68efea890cf7ee0c6dd2d842529d660f80efbc8", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -0,0 +1,14 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+//@error-pattern: /deallocation through .* is forbidden/\n+\n+fn inner(x: &mut i32, f: fn(&mut i32)) {\n+    // `f` may mutate, but it may not deallocate!\n+    f(x)\n+}\n+\n+fn main() {\n+    inner(Box::leak(Box::new(0)), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "97088d5854cc9dd396f4d85f90a5c6b6e09eea64", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -0,0 +1,49 @@\n+error: Undefined Behavior: deallocation through <TAG> is forbidden\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocation through <TAG> is forbidden\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = help: the allocation of the accessed tag <TAG> also contains the strongly protected tag <TAG>\n+   = help: the strongly protected tag <TAG> disallows deallocations\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |         drop(unsafe { Box::from_raw(raw) });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the strongly protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL | fn inner(x: &mut i32, f: fn(&mut i32)) {\n+   |          ^\n+   = note: BACKTRACE (of the first span):\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::box_free::<i32, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<i32>> - shim(Some(std::boxed::Box<i32>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   = note: inside `std::mem::drop::<std::boxed::Box<i32>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n+note: inside closure\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |         drop(unsafe { Box::from_raw(raw) });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `<[closure@$DIR/strongly-protected.rs:LL:CC] as std::ops::FnOnce<(&mut i32,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n+note: inside `inner`\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |     f(x)\n+   |     ^^^^\n+note: inside `main`\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL | /     inner(Box::leak(Box::new(0)), |x| {\n+LL | |         let raw = x as *mut _;\n+LL | |         drop(unsafe { Box::from_raw(raw) });\n+LL | |     });\n+   | |______^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "f6285bdcf16d4fc49a7a17ce23a79c84361cfe50", "filename": "src/tools/miri/tests/fail/tree-borrows/write-during-2phase.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,11 +1,30 @@\n-error: Undefined Behavior: read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+error: Undefined Behavior: read access through <TAG> is forbidden\n   --> $DIR/write-during-2phase.rs:LL:CC\n    |\n LL |     fn add(&mut self, n: u64) -> u64 {\n-   |            ^^^^^^^^^ read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+   |            ^^^^^^^^^ read access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> has state Disabled which forbids child read accesses\n+help: the accessed tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |       let _res = f.add(unsafe {\n+   |  ________________^\n+LL | |         let n = f.0;\n+LL | |         // This is the access at fault, but it's not immediately apparent because\n+LL | |         // the reference that got invalidated is not under a Protector.\n+LL | |         *inner = 42;\n+LL | |         n\n+LL | |     });\n+   | |______^\n+help: the accessed tag <TAG> then transitioned from Reserved to Disabled due to a foreign write access at offsets [0x0..0x8]\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |         *inner = 42;\n+   |         ^^^^^^^^^^^\n+   = help: this corresponds to a loss of read and write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `Foo::add` at $DIR/write-during-2phase.rs:LL:CC\n note: inside `main`\n   --> $DIR/write-during-2phase.rs:LL:CC"}, {"sha": "1eab4685a35f5c06d8bc56f552399fd5c4e4c8b8", "filename": "src/tools/miri/tests/pass/tree-borrows/cell-alternate-writes.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,10 +1,12 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=data, x, y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=data, x, y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "c20da1a593fc028f72cbf24dcd405362bd76fe53", "filename": "src/tools/miri/tests/pass/tree-borrows/end-of-protector.stderr", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,32 +1,36 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=x>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|        \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|          \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|          \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|            \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Dis|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Dis|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Dis|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Dis|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Dis|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Dis|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "8c3779fe1f7f71fb0a1803dd41acd6d2503f9f49", "filename": "src/tools/miri/tests/pass/tree-borrows/formatting.stderr", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,29 +1,31 @@\n-\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1..  2.. 10.. 11..100..101..1000..1001..1024\n-| Res| Act| Res| Act| Res| Act|  Res|  Act|  Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-|----| Act|----|?Dis|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[1]>\n-|----|----|----| Act|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[10]>\n-|----|----|----|----|----| Frz| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[100]>\n-|----|----|----|----|----|----| ----|  Act| ----|      \u2514\u2500\u2500\u2500\u2500<TAG=data[1000]>\n-\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+| Act| Act| Act| Act| Act| Act|  Act|  Act|  Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res| Act| Res| Act| Res| Act|  Res|  Act|  Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+|----| Act|----|?Dis|----|?Dis| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[1]>\n+|----|----|----| Act|----|?Dis| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[10]>\n+|----|----|----|----|----| Frz| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[100]>\n+|----|----|----|----|----|----| ----|  Act| ----|        \u2514\u2500\u2500\u2500\u2500<TAG=data[1000]>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Frz|    \u2514\u2500\u252c\u2500\u2500<TAG=x>\n-| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xa>\n-| Frz|      \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xaa>\n-| Frz|      \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xab>\n-| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xb>\n-| Frz|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=xba>\n-| Frz|      \u2502   \u2514\u2500\u252c\u2500\u2500<TAG=xbaa>\n-| Frz|      \u2502     \u2514\u2500\u252c\u2500\u2500<TAG=xbaaa>\n-| Frz|      \u2502       \u2514\u2500\u2500\u2500\u2500<TAG=xbaaaa>\n-| Frz|      \u2514\u2500\u252c\u2500\u2500<TAG=xc>\n-| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xca>\n-| Frz|        \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xcaa>\n-| Frz|        \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xcab>\n-| Frz|        \u2514\u2500\u252c\u2500\u2500<TAG=xcb>\n-| Frz|          \u251c\u2500\u2500\u2500\u2500<TAG=xcba>\n-| Frz|          \u2514\u2500\u2500\u2500\u2500<TAG=xcbb>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Frz|      \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xa>\n+| Frz|        \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xaa>\n+| Frz|        \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xab>\n+| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xb>\n+| Frz|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=xba>\n+| Frz|        \u2502   \u2514\u2500\u252c\u2500\u2500<TAG=xbaa>\n+| Frz|        \u2502     \u2514\u2500\u252c\u2500\u2500<TAG=xbaaa>\n+| Frz|        \u2502       \u2514\u2500\u2500\u2500\u2500<TAG=xbaaaa>\n+| Frz|        \u2514\u2500\u252c\u2500\u2500<TAG=xc>\n+| Frz|          \u251c\u2500\u252c\u2500\u2500<TAG=xca>\n+| Frz|          \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xcaa>\n+| Frz|          \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xcab>\n+| Frz|          \u2514\u2500\u252c\u2500\u2500<TAG=xcb>\n+| Frz|            \u251c\u2500\u2500\u2500\u2500<TAG=xcba>\n+| Frz|            \u2514\u2500\u2500\u2500\u2500<TAG=xcbb>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "8c4323b2f7fa75e5da7f607043e1a44b8e95d811", "filename": "src/tools/miri/tests/pass/tree-borrows/reborrow-is-read.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -1,13 +1,15 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=x>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n-| Frz|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Frz|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "afb917002221e14cf11a541690c530de783d5cda", "filename": "src/tools/miri/tests/pass/tree-borrows/reserved.stderr", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b55b3bcb098347257a884c470c35d98d35a33a7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr?ref=1b55b3bcb098347257a884c470c35d98d35a33a7", "patch": "@@ -2,51 +2,57 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y, caller:y, callee:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [interior mut] Foreign Read: Re* -> Re*\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  8\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [interior mut] Foreign Write: Re* -> Re*\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  8\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [protected] Foreign Read: Res -> Frz\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y, caller:y, callee:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [] Foreign Read: Res -> Res\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Res|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [] Foreign Write: Res -> Dis\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Dis|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Dis|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}]}