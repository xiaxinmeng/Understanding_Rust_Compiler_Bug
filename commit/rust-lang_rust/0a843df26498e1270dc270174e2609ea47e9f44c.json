{"sha": "0a843df26498e1270dc270174e2609ea47e9f44c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODQzZGYyNjQ5OGUxMjcwZGMyNzAxNzRlMjYwOWVhNDdlOWY0NGM=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-10-17T14:42:10Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-07T19:13:19Z"}, "message": "Implement more efficient saturation", "tree": {"sha": "c29d80545fdf0e5f2fc8462da5f4ac35c3b1a258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c29d80545fdf0e5f2fc8462da5f4ac35c3b1a258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a843df26498e1270dc270174e2609ea47e9f44c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a843df26498e1270dc270174e2609ea47e9f44c", "html_url": "https://github.com/rust-lang/rust/commit/0a843df26498e1270dc270174e2609ea47e9f44c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a843df26498e1270dc270174e2609ea47e9f44c/comments", "author": null, "committer": null, "parents": [{"sha": "354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/354a5cb250fe386075d33539a6c2e9a75d9d7fc5", "html_url": "https://github.com/rust-lang/rust/commit/354a5cb250fe386075d33539a6c2e9a75d9d7fc5"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "e232ddb38889d101814e975cedd10f223447c840", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 63, "deletions": 71, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0a843df26498e1270dc270174e2609ea47e9f44c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a843df26498e1270dc270174e2609ea47e9f44c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=0a843df26498e1270dc270174e2609ea47e9f44c", "patch": "@@ -849,12 +849,14 @@ fn cast_float_to_int(bcx: &Builder,\n                      x: ValueRef,\n                      float_ty: Type,\n                      int_ty: Type) -> ValueRef {\n+    let fptosui_result = if signed {\n+        bcx.fptosi(x, int_ty)\n+    } else {\n+        bcx.fptoui(x, int_ty)\n+    };\n+\n     if !bcx.sess().opts.debugging_opts.saturating_float_casts {\n-        if signed {\n-            return bcx.fptosi(x, int_ty);\n-        } else {\n-            return bcx.fptoui(x, int_ty);\n-        }\n+        return fptosui_result;\n     }\n     // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n     // destination integer type after rounding towards zero. This `undef` value can cause UB in\n@@ -875,10 +877,9 @@ fn cast_float_to_int(bcx: &Builder,\n     // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128, Status) {\n+    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128) {\n         let f_min = if signed {\n-            let int_min = i128::MIN >> (128 - int_ty.int_width());\n-            let rounded_min = F::from_i128_r(int_min, Round::TowardZero);\n+            let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n             assert_eq!(rounded_min.status, Status::OK);\n             rounded_min.value\n         } else {\n@@ -888,7 +889,7 @@ fn cast_float_to_int(bcx: &Builder,\n         let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n         assert!(rounded_max.value.is_finite());\n \n-        (f_min.to_bits(), rounded_max.value.to_bits(), rounded_max.status)\n+        (f_min.to_bits(), rounded_max.value.to_bits())\n     }\n     fn int_max(signed: bool, int_ty: Type) -> u128 {\n         let shift_amount = 128 - int_ty.int_width();\n@@ -898,7 +899,14 @@ fn cast_float_to_int(bcx: &Builder,\n             u128::MAX >> shift_amount\n         }\n     }\n-    let (f_min, f_max, f_max_status) = match float_ty.float_width() {\n+    fn int_min(signed: bool, int_ty: Type) -> i128 {\n+        if signed {\n+            i128::MIN >> (128 - int_ty.int_width())\n+        } else {\n+            0\n+        }\n+    }\n+    let (f_min, f_max) = match float_ty.float_width() {\n         32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n         64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n         n => bug!(\"unsupported float width {}\", n),\n@@ -913,76 +921,60 @@ fn cast_float_to_int(bcx: &Builder,\n     };\n     let f_min = float_bits_to_llval(f_min);\n     let f_max = float_bits_to_llval(f_max);\n-    // To implement saturation, we perform the following steps (not all steps are necessary for\n-    // all combinations of int_ty and float_ty, but we'll deal with that below):\n+    // To implement saturation, we perform the following steps:\n     //\n-    // 1. Clamp x into the range [f_min, f_max] in such a way that NaN becomes f_min.\n-    // 2. If x is NaN, replace the result of the clamping with 0.0, otherwise\n-    //    keep the clamping result.\n-    // 3. Now cast the result of step 2 with fpto[su]i.\n-    // 4. If x > f_max, return int_ty::MAX, otherwise return the result of step 3.\n+    // 1. Cast x to an integer with fpto[su]i. This may result in undef.\n+    // 2. Compare x to f_min and f_max, and use the comparison results to select:\n+    //  a) int_ty::MIN if x < f_min or x is NaN\n+    //  b) int_ty::MAX if x > f_max\n+    //  c) the result of fpto[su]i otherwise\n+    // 3. If x is NaN, return 0.0, otherwise return the result of step 2.\n     //\n-    // This avoids undef because values in range [f_min, f_max] by definition fit into the\n-    // destination type. More importantly, it correctly implements saturating conversion.\n+    // This avoids resulting undef because values in range [f_min, f_max] by definition fit into the\n+    // destination type. It creates an undef temporary, but *producing* undef is not UB. Our use of\n+    // undef does not introduce any non-determinism either.\n+    // More importantly, the above procedure correctly implements saturating conversion.\n     // Proof (sketch):\n-    // If x is NaN, step 2 yields 0.0, which is converted to 0 in step 3, and NaN > f_max does\n-    // not hold in step 4, therefore 0 is returned, as desired.\n+    // If x is NaN, 0 is trivially returned.\n     // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n     // This yields three cases to consider:\n-    // (1) if x in [f_min, f_max], steps 1, 2, and 4 do nothing and the result of fpto[su]i\n-    //     is returned, which agrees with saturating conversion for inputs in that range.\n-    // (2) if x > f_max, then x is larger than int_ty::MAX and step 4 correctly returns\n-    //     int_ty::MAX. This holds even if f_max is rounded (i.e., if f_max < int_ty::MAX)\n-    //     because in those cases, nextUp(f_max) is already larger than int_ty::MAX.\n-    // (3) if x < f_min, then x is smaller than int_ty::MIN and is clamped to f_min. As shown\n-    //     earlier, f_min exactly equals int_ty::MIN and therefore no fixup analogous to step 4\n-    //     is needed. Instead, step 3 casts f_min to int_ty::MIN and step 4 returns this cast\n-    //     result, as desired.\n+    // (1) if x in [f_min, f_max], the result of fpto[su]i is returned, which agrees with\n+    //     saturating conversion for inputs in that range.\n+    // (2) if x > f_max, then x is larger than int_ty::MAX. This holds even if f_max is rounded\n+    //     (i.e., if f_max < int_ty::MAX) because in those cases, nextUp(f_max) is already larger\n+    //     than int_ty::MAX. Because x is larger than int_ty::MAX, the return value is correct.\n+    // (3) if x < f_min, then x is smaller than int_ty::MIN. As shown earlier, f_min exactly equals\n+    //     int_ty::MIN and therefore the return value of int_ty::MIN is immediately correct.\n     // QED.\n \n-    // Step 1: Clamping. Computed as:\n-    //    clamped_to_min = if f_min < x { x } else { f_min };\n-    //    clamped_x = if f_max < clamped_to_min { f_max } else { clamped_to_min };\n-    // Note that for x = NaN, both of the above variables become f_min.\n-    let clamped_to_min = bcx.select(bcx.fcmp(llvm::RealOLT, f_min, x), x, f_min);\n-    let clamped_x = bcx.select(\n-                                bcx.fcmp(llvm::RealOLT, f_max, clamped_to_min),\n-                                f_max,\n-                                clamped_to_min\n-                            );\n-\n-    // Step 2: NaN replacement.\n-    // For unsigned types, f_min == 0.0 and therefore clamped_x is already zero.\n+    // Step 1 was already performed above.\n+\n+    // Step 2: We use two comparisons and two selects, with s1 being the result:\n+    //     %less = fcmp ult %x, %f_min\n+    //     %greater = fcmp olt %x, %f_max\n+    //     %s0 = select %less, int_ty::MIN, %fptosi_result\n+    //     %s1 = select %greater, int_ty::MAX, %s0\n+    // Note that %less uses an *unordered* comparison. This comparison is true if the operands are\n+    // not comparable (i.e., if x is NaN). The unordered comparison ensures that s1 becomes\n+    // int_ty::MIN if x is NaN.\n+    // Performance note: It can be lowered to a flipped comparison and a negation (and the negation\n+    // can be merged into the select), so it not necessarily any more expensive than a ordered\n+    // (\"normal\") comparison. Whether these optimizations will be performed is ultimately up to the\n+    // backend but at least x86 does that.\n+    let less = bcx.fcmp(llvm::RealULT, x, f_min);\n+    let greater = bcx.fcmp(llvm::RealOGT, x, f_max);\n+    let int_max = C_big_integral(int_ty, int_max(signed, int_ty) as u128);\n+    let int_min = C_big_integral(int_ty, int_min(signed, int_ty) as u128);\n+    let s0 = bcx.select(less, int_min, fptosui_result);\n+    let s1 = bcx.select(greater, int_max, s0);\n+\n+    // Step 3: NaN replacement.\n+    // For unsigned types, the above step already yielded int_ty::MIN == 0 if x is NaN.\n     // Therefore we only need to execute this step for signed integer types.\n-    let clamped_x = if signed {\n-        let zero = match float_ty.float_width() {\n-            32 => float_bits_to_llval(ieee::Single::ZERO.to_bits()),\n-            64 => float_bits_to_llval(ieee::Double::ZERO.to_bits()),\n-            n => bug!(\"unsupported float width {}\", n),\n-        };\n+    if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), clamped_x, zero)\n-    } else {\n-        clamped_x\n-    };\n-\n-    // Step 3: fpto[su]i cast\n-    let cast_result = if signed {\n-        bcx.fptosi(clamped_x, int_ty)\n-    } else {\n-        bcx.fptoui(clamped_x, int_ty)\n-    };\n-\n-    // Step 4: f_max fixup.\n-    // Note that x > f_max implies that x was clamped to f_max in step 1, and therefore the\n-    // cast result is the integer equal to f_max. If the conversion from int_ty::MAX to f_max\n-    // was exact, then the result of casting f_max is again int_ty::MAX, so we'd return the same\n-    // value whether or not x > f_max holds. Therefore, we only need to execute this step\n-    // if f_max is inexact.\n-    if f_max_status.contains(Status::INEXACT) {\n-        let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n-        bcx.select(bcx.fcmp(llvm::RealOGT, x, f_max), int_max, cast_result)\n+        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), s1, C_big_integral(int_ty, 0))\n     } else {\n-        cast_result\n+        s1\n     }\n }"}]}