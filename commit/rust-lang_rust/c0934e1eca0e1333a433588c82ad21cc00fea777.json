{"sha": "c0934e1eca0e1333a433588c82ad21cc00fea777", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwOTM0ZTFlY2EwZTEzMzNhNDMzNTg4YzgyYWQyMWNjMDBmZWE3Nzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T14:15:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T14:15:55Z"}, "message": "Auto merge of #1152 - divergentdave:shim-directory, r=RalfJung\n\nAdd directory-related shims\n\nThis PR adds support for `mkdir`, `rmdir`, `opendir`, `closedir`, and `readdir64_r`.\n\nOpen directory streams are tracked through a HashMap indexed by pointer locations, which holds directory iterators. Since `DIR` is an opaque type in glibc, I represent them with 1-byte allocations, and then just use their pointers in HashMap lookups.\n\nTests are included to exercise the new functionality.", "tree": {"sha": "9df662d77d66d1dfb71a29ea746fe721578d5a4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9df662d77d66d1dfb71a29ea746fe721578d5a4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0934e1eca0e1333a433588c82ad21cc00fea777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0934e1eca0e1333a433588c82ad21cc00fea777", "html_url": "https://github.com/rust-lang/rust/commit/c0934e1eca0e1333a433588c82ad21cc00fea777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0934e1eca0e1333a433588c82ad21cc00fea777/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070cecb6fc7e29430a95bfa0ad08593faa07fa78", "url": "https://api.github.com/repos/rust-lang/rust/commits/070cecb6fc7e29430a95bfa0ad08593faa07fa78", "html_url": "https://github.com/rust-lang/rust/commit/070cecb6fc7e29430a95bfa0ad08593faa07fa78"}, {"sha": "62f9f4c578ab2780468ac3a25fe46d0d9a1c8146", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f9f4c578ab2780468ac3a25fe46d0d9a1c8146", "html_url": "https://github.com/rust-lang/rust/commit/62f9f4c578ab2780468ac3a25fe46d0d9a1c8146"}], "stats": {"total": 448, "additions": 437, "deletions": 11}, "files": [{"sha": "53facf89dce922b8d5907eda1f8930c78c4f7335", "filename": "src/helpers.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -474,15 +474,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n-    /// the Unix APIs usually handle. This function returns `Ok(false)` without trying to write if\n-    /// `size` is not large enough to fit the contents of `os_string` plus a null terminator. It\n-    /// returns `Ok(true)` if the writing process was successful.\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does not include the null terminator.\n     fn write_os_str_to_c_str(\n         &mut self,\n         os_str: &OsStr,\n         scalar: Scalar<Tag>,\n         size: u64,\n-    ) -> InterpResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(target_os = \"unix\")]\n         fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n             std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n@@ -501,13 +502,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let bytes = os_str_to_bytes(os_str)?;\n         // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n         // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n-        if size <= bytes.len() as u64 {\n-            return Ok(false);\n+        let string_length = bytes.len() as u64;\n+        if size <= string_length {\n+            return Ok((false, string_length));\n         }\n         self.eval_context_mut()\n             .memory\n             .write_bytes(scalar, bytes.iter().copied().chain(iter::once(0u8)))?;\n-        Ok(true)\n+        Ok((true, string_length))\n     }\n \n     fn alloc_os_str_as_c_str("}, {"sha": "10dfc32b0f78138d0100ec5d481395e668e564d7", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -36,7 +36,7 @@ pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n-pub use crate::shims::fs::{EvalContextExt as FileEvalContextExt, FileHandler};\n+pub use crate::shims::fs::{DirHandler, EvalContextExt as FileEvalContextExt, FileHandler};\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n pub use crate::shims::time::EvalContextExt as TimeEvalContextExt;"}, {"sha": "ec4c69159c6ece26b7d07c4b12dad81fb3c0d9bd", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -120,6 +120,7 @@ pub struct Evaluator<'tcx> {\n     pub(crate) validate: bool,\n \n     pub(crate) file_handler: FileHandler,\n+    pub(crate) dir_handler: DirHandler,\n \n     /// The temporary used for storing the argument of\n     /// the call to `miri_start_panic` (the panic payload) when unwinding.\n@@ -140,6 +141,7 @@ impl<'tcx> Evaluator<'tcx> {\n             communicate,\n             validate,\n             file_handler: Default::default(),\n+            dir_handler: Default::default(),\n             panic_payload: None,\n         }\n     }"}, {"sha": "3fd895576e534cc1b2a8a3a962dc5c0042ded5de", "filename": "src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -124,7 +124,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n-                if this.write_os_str_to_c_str(&OsString::from(cwd), buf, size)? {\n+                if this.write_os_str_to_c_str(&OsString::from(cwd), buf, size)?.0 {\n                     return Ok(buf);\n                 }\n                 let erange = this.eval_libc(\"ERANGE\")?;"}, {"sha": "636137f62de05d8e4c315181de04dbf6d4bdce3e", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -109,6 +109,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            \"mkdir\" => {\n+                let result = this.mkdir(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"rmdir\" => {\n+                let result = this.rmdir(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"closedir\" => {\n+                let result = this.closedir(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             \"lseek\" | \"lseek64\" => {\n                 let result = this.lseek64(args[0], args[1], args[2])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;"}, {"sha": "8a1ce5594ae46050a0c22e2b9ba34e60144c9ba6", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -27,6 +27,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            // The only reason this is not in the `posix` module is because the `macos` item has a\n+            // different name.\n+            \"opendir\" => {\n+                let result = this.opendir(args[0])?;\n+                this.write_scalar(result, dest)?;\n+            }\n+\n+            // The `macos` module has a parallel foreign item, `readdir_r`, which uses a different\n+            // struct layout.\n+            \"readdir64_r\" => {\n+                let result = this.linux_readdir64_r(args[0], args[1], args[2])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             // Time related shims\n \n             // This is a POSIX function but it has only been tested on linux."}, {"sha": "cb6cd9ba44b40a8f89c90ec97e4b8163c683a901", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -42,6 +42,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            // The only reason this is not in the `posix` module is because the `linux` item has a\n+            // different name.\n+            \"opendir$INODE64\" => {\n+                let result = this.opendir(args[0])?;\n+                this.write_scalar(result, dest)?;\n+            }\n+\n+            // The `linux` module has a parallel foreign item, `readdir64_r`, which uses a\n+            // different struct layout.\n+            \"readdir_r$INODE64\" => {\n+                let result = this.macos_readdir_r(args[0], args[1], args[2])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             // Time related shims\n             \"gettimeofday\" => {\n                 let result = this.gettimeofday(args[0], args[1])?;"}, {"sha": "cc8f18af7d618a512bf199ac4b6079345477cfa8", "filename": "src/shims/fs.rs", "status": "modified", "additions": 341, "deletions": 1, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -1,6 +1,7 @@\n use std::collections::BTreeMap;\n+use std::collections::HashMap;\n use std::convert::{TryFrom, TryInto};\n-use std::fs::{remove_file, rename, File, OpenOptions};\n+use std::fs::{read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir};\n use std::io::{Read, Seek, SeekFrom, Write};\n use std::path::PathBuf;\n use std::time::SystemTime;\n@@ -160,6 +161,82 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         this.set_last_error(ebadf)?;\n         Ok((-1).into())\n     }\n+\n+    fn file_type_to_d_type(&mut self, file_type: std::io::Result<FileType>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+        match file_type {\n+            Ok(file_type) => {\n+                if file_type.is_dir() {\n+                    Ok(this.eval_libc(\"DT_DIR\")?.to_u8()? as i32)\n+                } else if file_type.is_file() {\n+                    Ok(this.eval_libc(\"DT_REG\")?.to_u8()? as i32)\n+                } else if file_type.is_symlink() {\n+                    Ok(this.eval_libc(\"DT_LNK\")?.to_u8()? as i32)\n+                } else {\n+                    // Certain file types are only supported when the host is a Unix system.\n+                    // (i.e. devices and sockets) If it is, check those cases, if not, fall back to\n+                    // DT_UNKNOWN sooner.\n+\n+                    #[cfg(unix)]\n+                    {\n+                        use std::os::unix::fs::FileTypeExt;\n+                        if file_type.is_block_device() {\n+                            Ok(this.eval_libc(\"DT_BLK\")?.to_u8()? as i32)\n+                        } else if file_type.is_char_device() {\n+                            Ok(this.eval_libc(\"DT_CHR\")?.to_u8()? as i32)\n+                        } else if file_type.is_fifo() {\n+                            Ok(this.eval_libc(\"DT_FIFO\")?.to_u8()? as i32)\n+                        } else if file_type.is_socket() {\n+                            Ok(this.eval_libc(\"DT_SOCK\")?.to_u8()? as i32)\n+                        } else {\n+                            Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()? as i32)\n+                        }\n+                    }\n+                    #[cfg(not(unix))]\n+                    Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()? as i32)\n+                }\n+            }\n+            Err(e) => return match e.raw_os_error() {\n+                Some(error) => Ok(error),\n+                None => throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e),\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct DirHandler {\n+    /// Directory iterators used to emulate libc \"directory streams\", as used in opendir, readdir,\n+    /// and closedir.\n+    ///\n+    /// When opendir is called, a directory iterator is created on the host for the target\n+    /// directory, and an entry is stored in this hash map, indexed by an ID which represents\n+    /// the directory stream. When readdir is called, the directory stream ID is used to look up\n+    /// the corresponding ReadDir iterator from this HashMap, and information from the next\n+    /// directory entry is returned. When closedir is called, the ReadDir iterator is removed from\n+    /// this HashMap.\n+    streams: HashMap<u64, ReadDir>,\n+    /// ID number to be used by the next call to opendir\n+    next_id: u64,\n+}\n+\n+impl DirHandler {\n+    fn insert_new(&mut self, read_dir: ReadDir) -> u64 {\n+        let id = self.next_id;\n+        self.next_id += 1;\n+        self.streams.insert(id, read_dir).unwrap_none();\n+        id\n+    }\n+}\n+\n+impl Default for DirHandler {\n+    fn default() -> DirHandler {\n+        DirHandler {\n+            streams: HashMap::new(),\n+            // Skip 0 as an ID, because it looks like a null pointer to libc\n+            next_id: 1,\n+        }\n+    }\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -722,6 +799,269 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.try_unwrap_io_result(result)\n     }\n+\n+    fn mkdir(\n+        &mut self,\n+        path_op: OpTy<'tcx, Tag>,\n+        mode_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"mkdir\")?;\n+\n+        let _mode = if this.tcx.sess.target.target.target_os.as_str() == \"macos\" {\n+            this.read_scalar(mode_op)?.not_undef()?.to_u16()? as u32\n+        } else {\n+            this.read_scalar(mode_op)?.to_u32()?\n+        };\n+\n+        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+\n+        let mut builder = DirBuilder::new();\n+\n+        // If the host supports it, forward on the mode of the directory\n+        // (i.e. permission bits and the sticky bit)\n+        #[cfg(target_family = \"unix\")]\n+        {\n+            use std::os::unix::fs::DirBuilderExt;\n+            builder.mode(_mode.into());\n+        }\n+\n+        let result = builder.create(path).map(|_| 0i32);\n+\n+        this.try_unwrap_io_result(result)\n+    }\n+\n+    fn rmdir(\n+        &mut self,\n+        path_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"rmdir\")?;\n+\n+        let path = this.read_os_str_from_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+\n+        let result = remove_dir(path).map(|_| 0i32);\n+\n+        this.try_unwrap_io_result(result)\n+    }\n+\n+    fn opendir(&mut self, name_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"opendir\")?;\n+\n+        let name = this.read_os_str_from_c_str(this.read_scalar(name_op)?.not_undef()?)?;\n+\n+        let result = read_dir(name);\n+\n+        match result {\n+            Ok(dir_iter) => {\n+                let id = this.machine.dir_handler.insert_new(dir_iter);\n+\n+                // The libc API for opendir says that this method returns a pointer to an opaque\n+                // structure, but we are returning an ID number. Thus, pass it as a scalar of\n+                // pointer width.\n+                Ok(Scalar::from_machine_usize(id, this))\n+            }\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e)?;\n+                Ok(Scalar::from_machine_usize(0, this))\n+            }\n+        }\n+    }\n+\n+    fn linux_readdir64_r(\n+        &mut self,\n+        dirp_op: OpTy<'tcx, Tag>,\n+        entry_op: OpTy<'tcx, Tag>,\n+        result_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"readdir64_r\")?;\n+        this.assert_platform(\"linux\", \"readdir64_r\");\n+\n+        let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n+\n+        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"The DIR pointer passed to readdir64_r did not come from opendir\")\n+        })?;\n+        match dir_iter.next() {\n+            Some(Ok(dir_entry)) => {\n+                // Write into entry, write pointer to result, return 0 on success.\n+                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // dirent64 struct is written using write_packed_immediates.\n+\n+                // For reference:\n+                // pub struct dirent64 {\n+                //     pub d_ino: ino64_t,\n+                //     pub d_off: off64_t,\n+                //     pub d_reclen: c_ushort,\n+                //     pub d_type: c_uchar,\n+                //     pub d_name: [c_char; 256],\n+                // }\n+\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let name_place = this.mplace_field(entry_place, 4)?;\n+\n+                let file_name = dir_entry.file_name();\n+                let (name_fits, _) = this.write_os_str_to_c_str(\n+                    &file_name,\n+                    name_place.ptr,\n+                    name_place.layout.size.bytes(),\n+                )?;\n+                if !name_fits {\n+                    throw_unsup_format!(\"A directory entry had a name too large to fit in libc::dirent64\");\n+                }\n+\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n+                let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n+                let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n+                let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n+\n+                // If the host is a Unix system, fill in the inode number with its real value.\n+                // If not, use 0 as a fallback value.\n+                #[cfg(unix)]\n+                let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n+                #[cfg(not(unix))]\n+                let ino = 0u64;\n+\n+                let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n+\n+                let imms = [\n+                    immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n+                    immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n+                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n+                ];\n+                this.write_packed_immediates(entry_place, &imms)?;\n+\n+                let result_place = this.deref_operand(result_op)?;\n+                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+\n+                Ok(0)\n+            }\n+            None => {\n+                // end of stream: return 0, assign *result=NULL\n+                this.write_null(this.deref_operand(result_op)?.into())?;\n+                Ok(0)\n+            }\n+            Some(Err(e)) => match e.raw_os_error() {\n+                // return positive error number on error\n+                Some(error) => Ok(error),\n+                None => {\n+                    throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e)\n+                }\n+            },\n+        }\n+    }\n+\n+    fn macos_readdir_r(\n+        &mut self,\n+        dirp_op: OpTy<'tcx, Tag>,\n+        entry_op: OpTy<'tcx, Tag>,\n+        result_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"readdir_r\")?;\n+        this.assert_platform(\"macos\", \"readdir_r\");\n+\n+        let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n+\n+        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"The DIR pointer passed to readdir_r did not come from opendir\")\n+        })?;\n+        match dir_iter.next() {\n+            Some(Ok(dir_entry)) => {\n+                // Write into entry, write pointer to result, return 0 on success.\n+                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // dirent struct is written using write_packed_Immediates.\n+\n+                // For reference:\n+                // pub struct dirent {\n+                //     pub d_ino: u64,\n+                //     pub d_seekoff: u64,\n+                //     pub d_reclen: u16,\n+                //     pub d_namlen: u16,\n+                //     pub d_type: u8,\n+                //     pub d_name: [c_char; 1024],\n+                // }\n+\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let name_place = this.mplace_field(entry_place, 5)?;\n+\n+                let file_name = dir_entry.file_name();\n+                let (name_fits, file_name_len) = this.write_os_str_to_c_str(\n+                    &file_name,\n+                    name_place.ptr,\n+                    name_place.layout.size.bytes(),\n+                )?;\n+                if !name_fits {\n+                    throw_unsup_format!(\"A directory entry had a name too large to fit in libc::dirent\");\n+                }\n+\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n+                let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n+                let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n+                let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n+\n+                // If the host is a Unix system, fill in the inode number with its real value.\n+                // If not, use 0 as a fallback value.\n+                #[cfg(unix)]\n+                let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n+                #[cfg(not(unix))]\n+                let ino = 0u64;\n+\n+                let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n+\n+                let imms = [\n+                    immty_from_uint_checked(ino, ino_t_layout)?, // d_ino\n+                    immty_from_uint_checked(0u128, off_t_layout)?, // d_seekoff\n+                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n+                    immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n+                ];\n+                this.write_packed_immediates(entry_place, &imms)?;\n+\n+                let result_place = this.deref_operand(result_op)?;\n+                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+\n+                Ok(0)\n+            }\n+            None => {\n+                // end of stream: return 0, assign *result=NULL\n+                this.write_null(this.deref_operand(result_op)?.into())?;\n+                Ok(0)\n+            }\n+            Some(Err(e)) => match e.raw_os_error() {\n+                // return positive error number on error\n+                Some(error) => Ok(error),\n+                None => {\n+                    throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e)\n+                }\n+            },\n+        }\n+    }\n+\n+    fn closedir(&mut self, dirp_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.check_no_isolation(\"closedir\")?;\n+\n+        let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n+\n+        if let Some(dir_iter) = this.machine.dir_handler.streams.remove(&dirp) {\n+            drop(dir_iter);\n+            Ok(0)\n+        } else {\n+            this.handle_not_found()\n+        }\n+    }\n }\n \n /// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch when"}, {"sha": "f859f934bdd1c7995ff6b57cb35ccf17e89ba64a", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c0934e1eca0e1333a433588c82ad21cc00fea777/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0934e1eca0e1333a433588c82ad21cc00fea777/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=c0934e1eca0e1333a433588c82ad21cc00fea777", "patch": "@@ -1,7 +1,7 @@\n // ignore-windows: File handling is not implemented yet\n // compile-flags: -Zmiri-disable-isolation\n \n-use std::fs::{File, remove_file, rename};\n+use std::fs::{File, create_dir, read_dir, remove_dir, remove_dir_all, remove_file, rename};\n use std::io::{Read, Write, ErrorKind, Result, Seek, SeekFrom};\n use std::path::{PathBuf, Path};\n \n@@ -13,6 +13,7 @@ fn main() {\n     test_symlink();\n     test_errors();\n     test_rename();\n+    test_directory();\n }\n \n /// Prepare: compute filename and make sure the file does not exist.\n@@ -24,6 +25,15 @@ fn prepare(filename: &str) -> PathBuf {\n     path\n }\n \n+/// Prepare directory: compute directory name and make sure it does not exist.\n+fn prepare_dir(dirname: &str) -> PathBuf {\n+    let tmp = std::env::temp_dir();\n+    let path = tmp.join(&dirname);\n+    // Clean the directory for robustness.\n+    remove_dir_all(&path).ok();\n+    path\n+}\n+\n /// Prepare like above, and also write some initial content to the file.\n fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n     let path = prepare(filename);\n@@ -182,3 +192,32 @@ fn test_rename() {\n \n     remove_file(&path2).unwrap();\n }\n+\n+fn test_directory() {\n+    let dir_path = prepare_dir(\"miri_test_fs_dir\");\n+    // Creating a directory should succeed.\n+    create_dir(&dir_path).unwrap();\n+    // Test that the metadata of a directory is correct.\n+    assert!(dir_path.metadata().unwrap().is_dir());\n+    // Creating a directory when it already exists should fail.\n+    assert_eq!(ErrorKind::AlreadyExists, create_dir(&dir_path).unwrap_err().kind());\n+\n+    // Create some files inside the directory\n+    let path_1 = dir_path.join(\"test_file_1\");\n+    drop(File::create(&path_1).unwrap());\n+    let path_2 = dir_path.join(\"test_file_2\");\n+    drop(File::create(&path_2).unwrap());\n+    // Test that the files are present inside the directory\n+    let dir_iter = read_dir(&dir_path).unwrap();\n+    let mut file_names = dir_iter.map(|e| e.unwrap().file_name()).collect::<Vec<_>>();\n+    file_names.sort_unstable();\n+    assert_eq!(file_names, vec![\"test_file_1\", \"test_file_2\"]);\n+    // Clean up the files in the directory\n+    remove_file(&path_1).unwrap();\n+    remove_file(&path_2).unwrap();\n+\n+    // Deleting the directory should succeed.\n+    remove_dir(&dir_path).unwrap();\n+    // Reading the metadata of a non-existent file should fail with a \"not found\" error.\n+    assert_eq!(ErrorKind::NotFound, check_metadata(&[], &dir_path).unwrap_err().kind());\n+}"}]}