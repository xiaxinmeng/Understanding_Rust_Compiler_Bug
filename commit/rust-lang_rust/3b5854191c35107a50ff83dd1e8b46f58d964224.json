{"sha": "3b5854191c35107a50ff83dd1e8b46f58d964224", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNTg1NDE5MWMzNTEwN2E1MGZmODNkZDFlOGI0NmY1OGQ5NjQyMjQ=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T22:21:01Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T22:21:01Z"}, "message": "Fix MacOS and Windows builds.", "tree": {"sha": "8e79bb0d00bc4d7e4d909b8a87ecce11fc7c6d7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e79bb0d00bc4d7e4d909b8a87ecce11fc7c6d7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b5854191c35107a50ff83dd1e8b46f58d964224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5854191c35107a50ff83dd1e8b46f58d964224", "html_url": "https://github.com/rust-lang/rust/commit/3b5854191c35107a50ff83dd1e8b46f58d964224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b5854191c35107a50ff83dd1e8b46f58d964224/comments", "author": null, "committer": null, "parents": [{"sha": "1355574bebb5f7cb572bb7399964f91101e8852e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1355574bebb5f7cb572bb7399964f91101e8852e", "html_url": "https://github.com/rust-lang/rust/commit/1355574bebb5f7cb572bb7399964f91101e8852e"}], "stats": {"total": 26, "additions": 18, "deletions": 8}, "files": [{"sha": "f13d9e6dfee826550205fa622a268f620c1bdfb9", "filename": "src/shims/tls.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b5854191c35107a50ff83dd1e8b46f58d964224/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b5854191c35107a50ff83dd1e8b46f58d964224/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=3b5854191c35107a50ff83dd1e8b46f58d964224", "patch": "@@ -253,10 +253,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Schedule the MacOS thread destructor of the thread local storage to be\n-    /// executed.\n+    /// executed. Returns `true` if scheduled.\n     ///\n     /// Note: It is safe to call this function also on other Unixes.\n-    fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx> {\n+    fn schedule_macos_tls_dtor(&mut self) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n         let thread_id = this.get_active_thread()?;\n         if let Some((instance, data)) = this.machine.tls.thread_dtors.remove(&thread_id) {\n@@ -275,8 +275,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // guaranteed that we will schedule it again. The `dtors_running`\n             // flag will prevent the code from adding the destructor again.\n             this.enable_thread(thread_id)?;\n+            Ok(true)\n+        } else {\n+            Ok(false)\n         }\n-        Ok(())\n     }\n \n     /// Schedule a pthread TLS destructor. Returns `true` if found\n@@ -331,20 +333,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread()?;\n \n-        let finished = if this.tcx.sess.target.target.target_os == \"windows\" {\n+        let scheduled_next = if this.tcx.sess.target.target.target_os == \"windows\" {\n             if !this.machine.tls.set_dtors_running_for_thread(active_thread) {\n                 this.schedule_windows_tls_dtors()?;\n+                true\n+            } else {\n+                false\n             }\n-            true\n         } else {\n             this.machine.tls.set_dtors_running_for_thread(active_thread);\n             // The macOS thread wide destructor runs \"before any TLS slots get\n             // freed\", so do that first.\n-            this.schedule_macos_tls_dtor()?;\n-            this.schedule_pthread_tls_dtors()?\n+            if this.schedule_macos_tls_dtor()? {\n+                true\n+            } else {\n+                this.schedule_pthread_tls_dtors()?\n+            }\n         };\n \n-        if finished {\n+        if !scheduled_next {\n+            // No dtors scheduled means that we are finished. Delete the\n+            // remaining TLS entries.\n             this.machine.tls.delete_all_thread_tls(active_thread);\n         }\n "}, {"sha": "36805fc83e30cff3710dde3b44e80f0c2c93fee2", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b5854191c35107a50ff83dd1e8b46f58d964224/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b5854191c35107a50ff83dd1e8b46f58d964224/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=3b5854191c35107a50ff83dd1e8b46f58d964224", "patch": "@@ -144,6 +144,7 @@ fn test_rwlock_libc_static_initializer() {\n /// Test whether the `prctl` shim correctly sets the thread name.\n ///\n /// Note: `prctl` exists only on Linux.\n+#[cfg(target_os = \"linux\")]\n fn test_prctl_thread_name() {\n     use std::ffi::CString;\n     unsafe {"}]}