{"sha": "19c8d701743922a709a4eb6554f562996b7baa27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzhkNzAxNzQzOTIyYTcwOWE0ZWI2NTU0ZjU2Mjk5NmI3YmFhMjc=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-04-21T17:19:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-04-21T17:23:53Z"}, "message": "syntax: Copy unstable str::char_at into libsyntax", "tree": {"sha": "41162a0de7c354de3cdc5beb3dbdf051340615da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41162a0de7c354de3cdc5beb3dbdf051340615da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c8d701743922a709a4eb6554f562996b7baa27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c8d701743922a709a4eb6554f562996b7baa27", "html_url": "https://github.com/rust-lang/rust/commit/19c8d701743922a709a4eb6554f562996b7baa27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c8d701743922a709a4eb6554f562996b7baa27/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9180fcb97e667d88260e1b3d396f8078e30b2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9180fcb97e667d88260e1b3d396f8078e30b2d", "html_url": "https://github.com/rust-lang/rust/commit/7f9180fcb97e667d88260e1b3d396f8078e30b2d"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "d8beeb6a5503b2e9599de4369d7571536a8cb60e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -92,6 +92,7 @@ pub mod parse;\n pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n+pub mod str;\n pub mod test;\n pub mod visit;\n "}, {"sha": "fb3a96f4c2887fdbd2b5c2875d239f50a37c9dc5", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -13,11 +13,12 @@ pub use self::CommentStyle::*;\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n-use parse::lexer::{is_whitespace, Reader};\n-use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::is_block_doc_comment;\n+use parse::lexer::{StringReader, TokenAndSpan};\n+use parse::lexer::{is_whitespace, Reader};\n use parse::lexer;\n use print::pprust;\n+use str::char_at;\n \n use std::io::Read;\n use std::usize;\n@@ -209,7 +210,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let mut col = col.to_usize();\n     let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n-        let ch = s.char_at(cursor);\n+        let ch = char_at(s, cursor);\n         if !ch.is_whitespace() {\n             return None;\n         }"}, {"sha": "8e37b983e21e0425e845223056e33dcecdd6b097", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -13,8 +13,9 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use diagnostic::SpanHandler;\n use ext::tt::transcribe::tt_next_token;\n-use parse::token;\n use parse::token::str_to_ident;\n+use parse::token;\n+use str::char_at;\n \n use std::borrow::Cow;\n use std::char;\n@@ -289,10 +290,10 @@ impl<'a> StringReader<'a> {\n                           s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n-            let ch = s.char_at(i);\n+            let ch = char_at(s, i);\n             let next = i + ch.len_utf8();\n             if ch == '\\r' {\n-                if next < s.len() && s.char_at(next) == '\\n' {\n+                if next < s.len() && char_at(s, next) == '\\n' {\n                     return translate_crlf_(self, start, s, errmsg, i).into();\n                 }\n                 let pos = start + BytePos(i as u32);\n@@ -308,12 +309,12 @@ impl<'a> StringReader<'a> {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n-                let ch = s.char_at(i);\n+                let ch = char_at(s, i);\n                 let next = i + ch.len_utf8();\n                 if ch == '\\r' {\n                     if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n-                    if next >= s.len() || s.char_at(next) != '\\n' {\n+                    if next >= s.len() || char_at(s, next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n                         let end_pos = start + BytePos(next as u32);\n                         rdr.err_span_(pos, end_pos, errmsg);\n@@ -335,7 +336,7 @@ impl<'a> StringReader<'a> {\n         if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let ch = self.source_text.char_at(current_byte_offset);\n+            let ch = char_at(&self.source_text, current_byte_offset);\n             let next = current_byte_offset + ch.len_utf8();\n             let byte_offset_diff = next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n@@ -357,7 +358,7 @@ impl<'a> StringReader<'a> {\n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         if offset < self.source_text.len() {\n-            Some(self.source_text.char_at(offset))\n+            Some(char_at(&self.source_text, offset))\n         } else {\n             None\n         }\n@@ -371,9 +372,9 @@ impl<'a> StringReader<'a> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n-        let next = offset + s.char_at(offset).len_utf8();\n+        let next = offset + char_at(s, offset).len_utf8();\n         if next < s.len() {\n-            Some(s.char_at(next))\n+            Some(char_at(s, next))\n         } else {\n             None\n         }"}, {"sha": "1333e27058f1db90e6a857ed567b2b1c91fc5db8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -16,7 +16,7 @@ use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto, FatalError\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use ptr::P;\n-\n+use str::char_at;\n \n use std::cell::{Cell, RefCell};\n use std::fs::File;\n@@ -536,7 +536,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n // check if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n-        first_chars.contains(&s.char_at(0)) &&\n+        first_chars.contains(&char_at(s, 0)) &&\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n@@ -673,8 +673,8 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     let orig = s;\n     let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n \n-    if s.char_at(0) == '0' && s.len() > 1 {\n-        match s.char_at(1) {\n+    if char_at(s, 0) == '0' && s.len() > 1 {\n+        match char_at(s, 1) {\n             'x' => base = 16,\n             'o' => base = 8,\n             'b' => base = 2,"}, {"sha": "d0f47629b10e5b42fd877c563c6d299e9097b85f", "filename": "src/libsyntax/str.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstr.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn char_at(s: &str, byte: usize) -> char {\n+    s[byte..].chars().next().unwrap()\n+}"}, {"sha": "6adeb30a94ec4d3c68f8a8af5bfe2d3f2e218edc", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c8d701743922a709a4eb6554f562996b7baa27/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=19c8d701743922a709a4eb6554f562996b7baa27", "patch": "@@ -15,6 +15,7 @@ use parse::new_parser_from_source_str;\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n+use str::char_at;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n@@ -96,24 +97,24 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n         else if idx_a == a.len() {return false;}\n         else if idx_b == b.len() {\n             // maybe the stuff left in a is all ws?\n-            if is_whitespace(a.char_at(idx_a)) {\n+            if is_whitespace(char_at(a, idx_a)) {\n                 return scan_for_non_ws_or_end(a,idx_a) == a.len();\n             } else {\n                 return false;\n             }\n         }\n         // ws in both given and pattern:\n-        else if is_whitespace(a.char_at(idx_a))\n-           && is_whitespace(b.char_at(idx_b)) {\n+        else if is_whitespace(char_at(a, idx_a))\n+           && is_whitespace(char_at(b, idx_b)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n             idx_b = scan_for_non_ws_or_end(b,idx_b);\n         }\n         // ws in given only:\n-        else if is_whitespace(a.char_at(idx_a)) {\n+        else if is_whitespace(char_at(a, idx_a)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n         }\n         // *don't* silently eat ws in expected only.\n-        else if a.char_at(idx_a) == b.char_at(idx_b) {\n+        else if char_at(a, idx_a) == char_at(b, idx_b) {\n             idx_a += 1;\n             idx_b += 1;\n         }\n@@ -129,7 +130,7 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n     let mut i = idx;\n     let len = a.len();\n-    while (i < len) && (is_whitespace(a.char_at(i))) {\n+    while (i < len) && (is_whitespace(char_at(a, i))) {\n         i += 1;\n     }\n     i"}]}