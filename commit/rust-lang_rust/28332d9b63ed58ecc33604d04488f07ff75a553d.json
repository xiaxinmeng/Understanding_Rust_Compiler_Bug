{"sha": "28332d9b63ed58ecc33604d04488f07ff75a553d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzMyZDliNjNlZDU4ZWNjMzM2MDRkMDQ0ODhmMDdmZjc1YTU1M2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-29T17:32:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-29T17:32:18Z"}, "message": "Simplify SourceBinder", "tree": {"sha": "9d3c5dcbffffe51481b148d8cd143efc4f19ec84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d3c5dcbffffe51481b148d8cd143efc4f19ec84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28332d9b63ed58ecc33604d04488f07ff75a553d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28332d9b63ed58ecc33604d04488f07ff75a553d", "html_url": "https://github.com/rust-lang/rust/commit/28332d9b63ed58ecc33604d04488f07ff75a553d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28332d9b63ed58ecc33604d04488f07ff75a553d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6a623dfbb40b79cac7857165114fa11a25e4e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a623dfbb40b79cac7857165114fa11a25e4e1f", "html_url": "https://github.com/rust-lang/rust/commit/a6a623dfbb40b79cac7857165114fa11a25e4e1f"}], "stats": {"total": 670, "additions": 321, "deletions": 349}, "files": [{"sha": "a9615a3b7e5f879e6794bff66a548297d3bc24ed", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=28332d9b63ed58ecc33604d04488f07ff75a553d", "patch": "@@ -778,6 +778,7 @@ impl GenericDef {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n+    // TODO: ID,\n     pub(crate) parent: DefWithBody,\n     pub(crate) pat_id: PatId,\n }"}, {"sha": "88540fbf2e07174dc828b24d6621f2fcc18743fb", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=28332d9b63ed58ecc33604d04488f07ff75a553d", "patch": "@@ -4,12 +4,12 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    AdtId, AssocItemId, AttrDefId, DefWithBodyId, EnumVariantId, GenericDefId, ModuleDefId,\n-    StructFieldId, VariantId,\n+    expr::PatId, AdtId, AssocItemId, AttrDefId, DefWithBodyId, EnumVariantId, GenericDefId,\n+    ModuleDefId, StructFieldId, VariantId,\n };\n \n use crate::{\n-    Adt, AssocItem, AttrDef, DefWithBody, EnumVariant, GenericDef, ModuleDef, StructField,\n+    Adt, AssocItem, AttrDef, DefWithBody, EnumVariant, GenericDef, Local, ModuleDef, StructField,\n     VariantDef,\n };\n \n@@ -222,3 +222,9 @@ impl From<AssocItem> for GenericDefId {\n         }\n     }\n }\n+\n+impl From<(DefWithBodyId, PatId)> for Local {\n+    fn from((parent, pat_id): (DefWithBodyId, PatId)) -> Self {\n+        Local { parent: parent.into(), pat_id }\n+    }\n+}"}, {"sha": "cefbd80e6b366756cab3606bdaf5c327e5500b3f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=28332d9b63ed58ecc33604d04488f07ff75a553d", "patch": "@@ -29,7 +29,6 @@ macro_rules! impl_froms {\n mod semantics;\n pub mod db;\n mod source_analyzer;\n-mod source_binder;\n \n pub mod diagnostics;\n "}, {"sha": "60392947e8de2a3dfce47966ce256f5b58996f93", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 40, "deletions": 61, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=28332d9b63ed58ecc33604d04488f07ff75a553d", "patch": "@@ -1,32 +1,33 @@\n //! See `Semantics`.\n \n+mod source_to_def;\n+\n use std::{cell::RefCell, fmt, iter::successors};\n \n use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n-    DefWithBodyId, TraitId,\n+    TraitId,\n };\n+use hir_expand::ExpansionInfo;\n use ra_db::{FileId, FileRange};\n+use ra_prof::profile;\n use ra_syntax::{\n-    algo::skip_trivia_token, ast, match_ast, AstNode, Direction, SyntaxNode, SyntaxToken,\n-    TextRange, TextUnit,\n+    algo::skip_trivia_token, ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     db::HirDatabase,\n+    semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, ReferenceDescriptor, SourceAnalyzer},\n-    source_binder::{ChildContainer, SourceBinder},\n     Function, HirFileId, InFile, Local, MacroDef, Module, ModuleDef, Name, Origin, Path,\n     PathResolution, ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n };\n-use hir_expand::ExpansionInfo;\n-use ra_prof::profile;\n \n /// Primary API to get semantic information, like types, from syntax trees.\n pub struct Semantics<'db, DB> {\n     pub db: &'db DB,\n-    sb: RefCell<SourceBinder>,\n+    s2d_cache: RefCell<SourceToDefCache>,\n     cache: RefCell<FxHashMap<SyntaxNode, HirFileId>>,\n }\n \n@@ -38,8 +39,7 @@ impl<DB> fmt::Debug for Semantics<'_, DB> {\n \n impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn new(db: &DB) -> Semantics<DB> {\n-        let sb = RefCell::new(SourceBinder::new());\n-        Semantics { db, sb, cache: RefCell::default() }\n+        Semantics { db, s2d_cache: Default::default(), cache: Default::default() }\n     }\n \n     pub fn parse(&self, file_id: FileId) -> ast::SourceFile {\n@@ -136,13 +136,19 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n-    pub fn to_def<T: ToDef + Clone>(&self, src: &T) -> Option<T::Def> {\n+    pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n+        let src = self.find_file(src.syntax().clone()).with_value(src).cloned();\n         T::to_def(self, src)\n     }\n \n+    fn with_ctx<F: FnOnce(&mut SourceToDefCtx<&DB>) -> T, T>(&self, f: F) -> T {\n+        let mut cache = self.s2d_cache.borrow_mut();\n+        let mut ctx = SourceToDefCtx { db: self.db, cache: &mut *cache };\n+        f(&mut ctx)\n+    }\n+\n     pub fn to_module_def(&self, file: FileId) -> Option<Module> {\n-        let mut sb = self.sb.borrow_mut();\n-        sb.to_module_def(self.db, file)\n+        self.with_ctx(|ctx| ctx.file_to_def(file)).map(Module::from)\n     }\n \n     pub fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db, DB> {\n@@ -176,7 +182,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     fn analyze2(&self, src: InFile<&SyntaxNode>, offset: Option<TextUnit>) -> SourceAnalyzer {\n         let _p = profile(\"Semantics::analyze2\");\n \n-        let container = match self.sb.borrow_mut().find_container(self.db, src) {\n+        let container = match self.with_ctx(|ctx| ctx.find_container(src)) {\n             Some(it) => it,\n             None => return SourceAnalyzer::new_for_resolver(Resolver::default(), src),\n         };\n@@ -233,68 +239,41 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n }\n \n-pub trait ToDef: Sized + AstNode + 'static {\n+pub trait ToDef: AstNode + Clone {\n     type Def;\n-    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Self::Def>;\n+\n+    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: InFile<Self>) -> Option<Self::Def>;\n }\n \n macro_rules! to_def_impls {\n-    ($(($def:path, $ast:path)),* ,) => {$(\n+    ($(($def:path, $ast:path, $meth:ident)),* ,) => {$(\n         impl ToDef for $ast {\n             type Def = $def;\n-            fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self)\n-                -> Option<Self::Def>\n-            {\n-                let src = sema.find_file(src.syntax().clone()).with_value(src);\n-                sema.sb.borrow_mut().to_id(sema.db, src.cloned()).map(Into::into)\n+            fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: InFile<Self>) -> Option<Self::Def> {\n+                sema.with_ctx(|ctx| ctx.$meth(src)).map(<$def>::from)\n             }\n         }\n     )*}\n }\n \n to_def_impls![\n-    (crate::Module, ast::Module),\n-    (crate::Struct, ast::StructDef),\n-    (crate::Enum, ast::EnumDef),\n-    (crate::Union, ast::UnionDef),\n-    (crate::Trait, ast::TraitDef),\n-    (crate::ImplBlock, ast::ImplBlock),\n-    (crate::TypeAlias, ast::TypeAliasDef),\n-    (crate::Const, ast::ConstDef),\n-    (crate::Static, ast::StaticDef),\n-    (crate::Function, ast::FnDef),\n-    (crate::StructField, ast::RecordFieldDef),\n-    (crate::EnumVariant, ast::EnumVariant),\n-    (crate::TypeParam, ast::TypeParam),\n-    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n+    (crate::Module, ast::Module, module_to_def),\n+    (crate::Struct, ast::StructDef, struct_to_def),\n+    (crate::Enum, ast::EnumDef, enum_to_def),\n+    (crate::Union, ast::UnionDef, union_to_def),\n+    (crate::Trait, ast::TraitDef, trait_to_def),\n+    (crate::ImplBlock, ast::ImplBlock, impl_to_def),\n+    (crate::TypeAlias, ast::TypeAliasDef, type_alias_to_def),\n+    (crate::Const, ast::ConstDef, const_to_def),\n+    (crate::Static, ast::StaticDef, static_to_def),\n+    (crate::Function, ast::FnDef, fn_to_def),\n+    (crate::StructField, ast::RecordFieldDef, record_field_to_def),\n+    (crate::EnumVariant, ast::EnumVariant, enum_variant_to_def),\n+    (crate::TypeParam, ast::TypeParam, type_param_to_def),\n+    (crate::MacroDef, ast::MacroCall, macro_call_to_def), // this one is dubious, not all calls are macros\n+    (crate::Local, ast::BindPat, bind_pat_to_def),\n ];\n \n-impl ToDef for ast::BindPat {\n-    type Def = Local;\n-\n-    fn to_def<DB: HirDatabase>(sema: &Semantics<DB>, src: &Self) -> Option<Local> {\n-        let src = sema.find_file(src.syntax().clone()).with_value(src);\n-        let file_id = src.file_id;\n-        let mut sb = sema.sb.borrow_mut();\n-        let db = sema.db;\n-        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::ConstDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::StaticDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        let (_body, source_map) = db.body_with_source_map(parent);\n-        let src = src.cloned().map(ast::Pat::from);\n-        let pat_id = source_map.node_pat(src.as_ref())?;\n-        Some(Local { parent: parent.into(), pat_id })\n-    }\n-}\n-\n fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }"}, {"sha": "303610dc4829c613a83d1abae94f1f27e86a851f", "filename": "crates/ra_hir/src/semantics/source_to_def.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28332d9b63ed58ecc33604d04488f07ff75a553d/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=28332d9b63ed58ecc33604d04488f07ff75a553d", "patch": "@@ -0,0 +1,271 @@\n+//! Maps *syntax* of various definitions to their semantic ids.\n+\n+use hir_def::{\n+    child_by_source::ChildBySource,\n+    dyn_map::DynMap,\n+    expr::PatId,\n+    keys::{self, Key},\n+    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n+    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n+};\n+use hir_expand::{name::AsName, AstId, MacroDefKind};\n+use ra_db::FileId;\n+use ra_prof::profile;\n+use ra_syntax::{\n+    ast::{self, NameOwner},\n+    match_ast, AstNode, SyntaxNode,\n+};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{db::HirDatabase, InFile, MacroDefId};\n+\n+pub(super) type SourceToDefCache = FxHashMap<ChildContainer, DynMap>;\n+\n+pub(super) struct SourceToDefCtx<'a, DB> {\n+    pub(super) db: DB,\n+    pub(super) cache: &'a mut SourceToDefCache,\n+}\n+\n+impl<DB: HirDatabase> SourceToDefCtx<'_, &'_ DB> {\n+    pub(super) fn file_to_def(&mut self, file: FileId) -> Option<ModuleId> {\n+        let _p = profile(\"SourceBinder::to_module_def\");\n+        let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n+            let crate_def_map = self.db.crate_def_map(crate_id);\n+            let local_id = crate_def_map.modules_for_file(file).next()?;\n+            Some((crate_id, local_id))\n+        })?;\n+        Some(ModuleId { krate, local_id })\n+    }\n+\n+    pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n+        let _p = profile(\"module_to_def\");\n+        let parent_declaration = src\n+            .as_ref()\n+            .map(|it| it.syntax())\n+            .cloned()\n+            .ancestors_with_macros(self.db)\n+            .skip(1)\n+            .find_map(|it| {\n+                let m = ast::Module::cast(it.value.clone())?;\n+                Some(it.with_value(m))\n+            });\n+\n+        let parent_module = match parent_declaration {\n+            Some(parent_declaration) => self.module_to_def(parent_declaration),\n+            None => {\n+                let file_id = src.file_id.original_file(self.db);\n+                self.file_to_def(file_id)\n+            }\n+        }?;\n+\n+        let child_name = src.value.name()?.as_name();\n+        let def_map = self.db.crate_def_map(parent_module.krate);\n+        let child_id = *def_map[parent_module.local_id].children.get(&child_name)?;\n+        Some(ModuleId { krate: parent_module.krate, local_id: child_id })\n+    }\n+\n+    pub(super) fn trait_to_def(&mut self, src: InFile<ast::TraitDef>) -> Option<TraitId> {\n+        self.to_def(src, keys::TRAIT)\n+    }\n+    pub(super) fn impl_to_def(&mut self, src: InFile<ast::ImplBlock>) -> Option<ImplId> {\n+        self.to_def(src, keys::IMPL)\n+    }\n+    pub(super) fn fn_to_def(&mut self, src: InFile<ast::FnDef>) -> Option<FunctionId> {\n+        self.to_def(src, keys::FUNCTION)\n+    }\n+    pub(super) fn struct_to_def(&mut self, src: InFile<ast::StructDef>) -> Option<StructId> {\n+        self.to_def(src, keys::STRUCT)\n+    }\n+    pub(super) fn enum_to_def(&mut self, src: InFile<ast::EnumDef>) -> Option<EnumId> {\n+        self.to_def(src, keys::ENUM)\n+    }\n+    pub(super) fn union_to_def(&mut self, src: InFile<ast::UnionDef>) -> Option<UnionId> {\n+        self.to_def(src, keys::UNION)\n+    }\n+    pub(super) fn static_to_def(&mut self, src: InFile<ast::StaticDef>) -> Option<StaticId> {\n+        self.to_def(src, keys::STATIC)\n+    }\n+    pub(super) fn const_to_def(&mut self, src: InFile<ast::ConstDef>) -> Option<ConstId> {\n+        self.to_def(src, keys::CONST)\n+    }\n+    pub(super) fn type_alias_to_def(\n+        &mut self,\n+        src: InFile<ast::TypeAliasDef>,\n+    ) -> Option<TypeAliasId> {\n+        self.to_def(src, keys::TYPE_ALIAS)\n+    }\n+    //TODO: tuple field\n+    pub(super) fn record_field_to_def(\n+        &mut self,\n+        src: InFile<ast::RecordFieldDef>,\n+    ) -> Option<StructFieldId> {\n+        self.to_def(src, keys::RECORD_FIELD)\n+    }\n+    pub(super) fn enum_variant_to_def(\n+        &mut self,\n+        src: InFile<ast::EnumVariant>,\n+    ) -> Option<EnumVariantId> {\n+        self.to_def(src, keys::ENUM_VARIANT)\n+    }\n+    pub(super) fn bind_pat_to_def(\n+        &mut self,\n+        src: InFile<ast::BindPat>,\n+    ) -> Option<(DefWithBodyId, PatId)> {\n+        let container = self.find_pat_container(src.as_ref().map(|it| it.syntax()))?;\n+        let (_body, source_map) = self.db.body_with_source_map(container);\n+        let src = src.map(ast::Pat::from);\n+        let pat_id = source_map.node_pat(src.as_ref())?;\n+        Some((container, pat_id))\n+    }\n+\n+    fn to_def<Ast: AstNode + 'static, ID: Copy + 'static>(\n+        &mut self,\n+        src: InFile<Ast>,\n+        key: Key<Ast, ID>,\n+    ) -> Option<ID> {\n+        let container = self.find_container(src.as_ref().map(|it| it.syntax()))?;\n+        let db = self.db;\n+        let dyn_map =\n+            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        dyn_map[key].get(&src).copied()\n+    }\n+\n+    pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {\n+        let container: ChildContainer =\n+            self.find_type_param_container(src.as_ref().map(|it| it.syntax()))?.into();\n+        let db = self.db;\n+        let dyn_map =\n+            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        dyn_map[keys::TYPE_PARAM].get(&src).copied()\n+    }\n+\n+    // FIXME: use DynMap as well?\n+    pub(super) fn macro_call_to_def(&mut self, src: InFile<ast::MacroCall>) -> Option<MacroDefId> {\n+        let kind = MacroDefKind::Declarative;\n+        let file_id = src.file_id.original_file(self.db);\n+        let krate = self.file_to_def(file_id)?.krate;\n+        let file_ast_id = self.db.ast_id_map(src.file_id).ast_id(&src.value);\n+        let ast_id = Some(AstId::new(src.file_id, file_ast_id));\n+        Some(MacroDefId { krate: Some(krate), ast_id, kind })\n+    }\n+\n+    pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n+        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+            let res: ChildContainer = match_ast! {\n+                match (container.value) {\n+                    ast::Module(it) => {\n+                        let def = self.module_to_def(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::TraitDef(it) => {\n+                        let def = self.trait_to_def(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::ImplBlock(it) => {\n+                        let def = self.impl_to_def(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::FnDef(it) => {\n+                        let def = self.fn_to_def(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::StructDef(it) => {\n+                        let def = self.struct_to_def(container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    ast::EnumDef(it) => {\n+                        let def = self.enum_to_def(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::UnionDef(it) => {\n+                        let def = self.union_to_def(container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    ast::StaticDef(it) => {\n+                        let def = self.static_to_def(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::ConstDef(it) => {\n+                        let def = self.const_to_def(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    _ => continue,\n+                }\n+            };\n+            return Some(res);\n+        }\n+\n+        let def = self.file_to_def(src.file_id.original_file(self.db))?;\n+        Some(def.into())\n+    }\n+\n+    fn find_type_param_container(&mut self, src: InFile<&SyntaxNode>) -> Option<GenericDefId> {\n+        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+            let res: GenericDefId = match_ast! {\n+                match (container.value) {\n+                    ast::FnDef(it) => { self.fn_to_def(container.with_value(it))?.into() },\n+                    ast::StructDef(it) => { self.struct_to_def(container.with_value(it))?.into() },\n+                    ast::EnumDef(it) => { self.enum_to_def(container.with_value(it))?.into() },\n+                    ast::TraitDef(it) => { self.trait_to_def(container.with_value(it))?.into() },\n+                    ast::TypeAliasDef(it) => { self.type_alias_to_def(container.with_value(it))?.into() },\n+                    ast::ImplBlock(it) => { self.impl_to_def(container.with_value(it))?.into() },\n+                    _ => continue,\n+                }\n+            };\n+            return Some(res);\n+        }\n+        None\n+    }\n+\n+    fn find_pat_container(&mut self, src: InFile<&SyntaxNode>) -> Option<DefWithBodyId> {\n+        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+            let res: DefWithBodyId = match_ast! {\n+                match (container.value) {\n+                    ast::ConstDef(it) => { self.const_to_def(container.with_value(it))?.into() },\n+                    ast::StaticDef(it) => { self.static_to_def(container.with_value(it))?.into() },\n+                    ast::FnDef(it) => { self.fn_to_def(container.with_value(it))?.into() },\n+                    _ => continue,\n+                }\n+            };\n+            return Some(res);\n+        }\n+        None\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub(crate) enum ChildContainer {\n+    DefWithBodyId(DefWithBodyId),\n+    ModuleId(ModuleId),\n+    TraitId(TraitId),\n+    ImplId(ImplId),\n+    EnumId(EnumId),\n+    VariantId(VariantId),\n+    /// XXX: this might be the same def as, for example an `EnumId`. However,\n+    /// here the children generic parameters, and not, eg enum variants.\n+    GenericDefId(GenericDefId),\n+}\n+impl_froms! {\n+    ChildContainer:\n+    DefWithBodyId,\n+    ModuleId,\n+    TraitId,\n+    ImplId,\n+    EnumId,\n+    VariantId,\n+    GenericDefId\n+}\n+\n+impl ChildContainer {\n+    fn child_by_source(self, db: &impl HirDatabase) -> DynMap {\n+        match self {\n+            ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n+            ChildContainer::ModuleId(it) => it.child_by_source(db),\n+            ChildContainer::TraitId(it) => it.child_by_source(db),\n+            ChildContainer::ImplId(it) => it.child_by_source(db),\n+            ChildContainer::EnumId(it) => it.child_by_source(db),\n+            ChildContainer::VariantId(it) => it.child_by_source(db),\n+            ChildContainer::GenericDefId(it) => it.child_by_source(db),\n+        }\n+    }\n+}"}, {"sha": "439a4d5dbb9de71dfd3e7454351b3117323fe9d1", "filename": "crates/ra_hir/src/source_binder.rs", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/a6a623dfbb40b79cac7857165114fa11a25e4e1f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a623dfbb40b79cac7857165114fa11a25e4e1f/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=a6a623dfbb40b79cac7857165114fa11a25e4e1f", "patch": "@@ -1,284 +0,0 @@\n-//! `SourceBinder` is the main entry point for getting info about source code.\n-//! It's main task is to map source syntax trees to hir-level IDs.\n-\n-use hir_def::{\n-    child_by_source::ChildBySource,\n-    dyn_map::DynMap,\n-    keys::{self, Key},\n-    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n-    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n-};\n-use hir_expand::{name::AsName, AstId, InFile, MacroDefId, MacroDefKind};\n-use ra_db::FileId;\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    match_ast, AstNode, SyntaxNode,\n-};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{db::HirDatabase, Module};\n-\n-pub(crate) struct SourceBinder {\n-    child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n-}\n-\n-impl SourceBinder {\n-    pub(crate) fn new() -> SourceBinder {\n-        SourceBinder { child_by_source_cache: FxHashMap::default() }\n-    }\n-\n-    pub(crate) fn to_module_def(&mut self, db: &impl HirDatabase, file: FileId) -> Option<Module> {\n-        let _p = profile(\"SourceBinder::to_module_def\");\n-        let (krate, local_id) = db.relevant_crates(file).iter().find_map(|&crate_id| {\n-            let crate_def_map = db.crate_def_map(crate_id);\n-            let local_id = crate_def_map.modules_for_file(file).next()?;\n-            Some((crate_id, local_id))\n-        })?;\n-        Some(Module { id: ModuleId { krate, local_id } })\n-    }\n-\n-    pub(crate) fn to_id<T: ToId>(\n-        &mut self,\n-        db: &impl HirDatabase,\n-        src: InFile<T>,\n-    ) -> Option<T::ID> {\n-        T::to_id(db, self, src)\n-    }\n-\n-    pub(crate) fn find_container(\n-        &mut self,\n-        db: &impl HirDatabase,\n-        src: InFile<&SyntaxNode>,\n-    ) -> Option<ChildContainer> {\n-        for container in src.cloned().ancestors_with_macros(db).skip(1) {\n-            let res: ChildContainer = match_ast! {\n-                match (container.value) {\n-                    ast::TraitDef(it) => {\n-                        let def: TraitId = self.to_id(db, container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::ImplBlock(it) => {\n-                        let def: ImplId = self.to_id(db, container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::FnDef(it) => {\n-                        let def: FunctionId = self.to_id(db, container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::StaticDef(it) => {\n-                        let def: StaticId = self.to_id(db, container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::ConstDef(it) => {\n-                        let def: ConstId = self.to_id(db, container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::EnumDef(it) => {\n-                        let def: EnumId = self.to_id(db, container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::StructDef(it) => {\n-                        let def: StructId = self.to_id(db, container.with_value(it))?;\n-                        VariantId::from(def).into()\n-                    },\n-                    ast::UnionDef(it) => {\n-                        let def: UnionId = self.to_id(db, container.with_value(it))?;\n-                        VariantId::from(def).into()\n-                    },\n-                    ast::Module(it) => {\n-                        let def: ModuleId = self.to_id(db, container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    _ => { continue },\n-                }\n-            };\n-            return Some(res);\n-        }\n-\n-        let c = self.to_module_def(db, src.file_id.original_file(db))?;\n-        Some(c.id.into())\n-    }\n-\n-    fn child_by_source(&mut self, db: &impl HirDatabase, container: ChildContainer) -> &DynMap {\n-        self.child_by_source_cache.entry(container).or_insert_with(|| container.child_by_source(db))\n-    }\n-}\n-\n-pub(crate) trait ToId: Sized {\n-    type ID: Sized + Copy + 'static;\n-    fn to_id<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::ID>;\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub(crate) enum ChildContainer {\n-    DefWithBodyId(DefWithBodyId),\n-    ModuleId(ModuleId),\n-    TraitId(TraitId),\n-    ImplId(ImplId),\n-    EnumId(EnumId),\n-    VariantId(VariantId),\n-    /// XXX: this might be the same def as, for example an `EnumId`. However,\n-    /// here the children generic parameters, and not, eg enum variants.\n-    GenericDefId(GenericDefId),\n-}\n-impl_froms! {\n-    ChildContainer:\n-    DefWithBodyId,\n-    ModuleId,\n-    TraitId,\n-    ImplId,\n-    EnumId,\n-    VariantId,\n-    GenericDefId\n-}\n-\n-impl ChildContainer {\n-    fn child_by_source(self, db: &impl HirDatabase) -> DynMap {\n-        match self {\n-            ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n-            ChildContainer::ModuleId(it) => it.child_by_source(db),\n-            ChildContainer::TraitId(it) => it.child_by_source(db),\n-            ChildContainer::ImplId(it) => it.child_by_source(db),\n-            ChildContainer::EnumId(it) => it.child_by_source(db),\n-            ChildContainer::VariantId(it) => it.child_by_source(db),\n-            ChildContainer::GenericDefId(it) => it.child_by_source(db),\n-        }\n-    }\n-}\n-\n-pub(crate) trait ToIdByKey: Sized + AstNode + 'static {\n-    type ID: Sized + Copy + 'static;\n-    const KEY: Key<Self, Self::ID>;\n-}\n-\n-impl<T: ToIdByKey> ToId for T {\n-    type ID = <T as ToIdByKey>::ID;\n-    fn to_id<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::ID> {\n-        let container = sb.find_container(db, src.as_ref().map(|it| it.syntax()))?;\n-        let dyn_map =\n-            &*sb.child_by_source_cache.entry(container).or_insert_with(|| match container {\n-                ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n-                ChildContainer::ModuleId(it) => it.child_by_source(db),\n-                ChildContainer::TraitId(it) => it.child_by_source(db),\n-                ChildContainer::ImplId(it) => it.child_by_source(db),\n-                ChildContainer::EnumId(it) => it.child_by_source(db),\n-                ChildContainer::VariantId(it) => it.child_by_source(db),\n-                ChildContainer::GenericDefId(it) => it.child_by_source(db),\n-            });\n-        dyn_map[T::KEY].get(&src).copied()\n-    }\n-}\n-\n-macro_rules! to_id_key_impls {\n-    ($(($id:ident, $ast:path, $key:path)),* ,) => {$(\n-        impl ToIdByKey for $ast {\n-            type ID = $id;\n-            const KEY: Key<Self, Self::ID> = $key;\n-        }\n-    )*}\n-}\n-\n-to_id_key_impls![\n-    (StructId, ast::StructDef, keys::STRUCT),\n-    (UnionId, ast::UnionDef, keys::UNION),\n-    (EnumId, ast::EnumDef, keys::ENUM),\n-    (TraitId, ast::TraitDef, keys::TRAIT),\n-    (FunctionId, ast::FnDef, keys::FUNCTION),\n-    (StaticId, ast::StaticDef, keys::STATIC),\n-    (ConstId, ast::ConstDef, keys::CONST),\n-    (TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n-    (ImplId, ast::ImplBlock, keys::IMPL),\n-    (StructFieldId, ast::RecordFieldDef, keys::RECORD_FIELD),\n-    (EnumVariantId, ast::EnumVariant, keys::ENUM_VARIANT),\n-];\n-\n-// FIXME: use DynMap as well?\n-impl ToId for ast::MacroCall {\n-    type ID = MacroDefId;\n-    fn to_id<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::ID> {\n-        let kind = MacroDefKind::Declarative;\n-\n-        let krate = sb.to_module_def(db, src.file_id.original_file(db))?.id.krate;\n-\n-        let ast_id = Some(AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value)));\n-\n-        Some(MacroDefId { krate: Some(krate), ast_id, kind })\n-    }\n-}\n-\n-impl ToId for ast::TypeParam {\n-    type ID = TypeParamId;\n-\n-    fn to_id<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<Self>,\n-    ) -> Option<Self::ID> {\n-        let file_id = src.file_id;\n-        let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::FnDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::StructDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::EnumDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::TraitDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::TypeAliasDef(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    ast::ImplBlock(value) => { sb.to_id(db, InFile { value, file_id})?.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        sb.child_by_source(db, parent.into())[keys::TYPE_PARAM].get(&src).copied()\n-    }\n-}\n-\n-impl ToId for ast::Module {\n-    type ID = ModuleId;\n-\n-    fn to_id<DB: HirDatabase>(\n-        db: &DB,\n-        sb: &mut SourceBinder,\n-        src: InFile<ast::Module>,\n-    ) -> Option<ModuleId> {\n-        {\n-            let _p = profile(\"ast::Module::to_def\");\n-            let parent_declaration = src\n-                .as_ref()\n-                .map(|it| it.syntax())\n-                .cloned()\n-                .ancestors_with_macros(db)\n-                .skip(1)\n-                .find_map(|it| {\n-                    let m = ast::Module::cast(it.value.clone())?;\n-                    Some(it.with_value(m))\n-                });\n-\n-            let parent_module = match parent_declaration {\n-                Some(parent_declaration) => sb.to_id(db, parent_declaration)?,\n-                None => {\n-                    let file_id = src.file_id.original_file(db);\n-                    sb.to_module_def(db, file_id)?.id\n-                }\n-            };\n-\n-            let child_name = src.value.name()?.as_name();\n-            let def_map = db.crate_def_map(parent_module.krate);\n-            let child_id = *def_map[parent_module.local_id].children.get(&child_name)?;\n-            Some(ModuleId { krate: parent_module.krate, local_id: child_id })\n-        }\n-    }\n-}"}]}