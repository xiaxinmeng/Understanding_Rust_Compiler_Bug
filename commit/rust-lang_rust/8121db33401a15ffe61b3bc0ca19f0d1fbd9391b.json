{"sha": "8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMjFkYjMzNDAxYTE1ZmZlNjFiM2JjMGNhMTlmMGQxZmJkOTM5MWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-07T02:03:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-07T15:11:47Z"}, "message": "Merge branch 'refactor-select' of https://github.com/aravind-pg/rust into update-cargo", "tree": {"sha": "a5f03642446a13502adde8091783221de023ed9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5f03642446a13502adde8091783221de023ed9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "html_url": "https://github.com/rust-lang/rust/commit/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53cda8e9ebe79d19a8b968ee28bff6a3876d8c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/53cda8e9ebe79d19a8b968ee28bff6a3876d8c58", "html_url": "https://github.com/rust-lang/rust/commit/53cda8e9ebe79d19a8b968ee28bff6a3876d8c58"}, {"sha": "81f0b962f37952179e4402a6078ea48f27fc77ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/81f0b962f37952179e4402a6078ea48f27fc77ad", "html_url": "https://github.com/rust-lang/rust/commit/81f0b962f37952179e4402a6078ea48f27fc77ad"}], "stats": {"total": 123, "additions": 39, "deletions": 84}, "files": [{"sha": "8ac69c4b5287a67509d69cce85157ca0d3c4a70b", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "patch": "@@ -851,19 +851,6 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n-        match self {\n-            &mut VtableImpl(ref mut i) => &mut i.nested,\n-            &mut VtableParam(ref mut n) => n,\n-            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n-            &mut VtableAutoImpl(ref mut d) => &mut d.nested,\n-            &mut VtableGenerator(ref mut c) => &mut c.nested,\n-            &mut VtableClosure(ref mut c) => &mut c.nested,\n-            &mut VtableObject(ref mut d) => &mut d.nested,\n-            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n-        }\n-    }\n-\n     pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M> where F: FnMut(N) -> M {\n         match self {\n             VtableImpl(i) => VtableImpl(VtableImplData {"}, {"sha": "600b4a515f0bf969a8764e6bd3cd8a316c5f4b89", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 39, "deletions": 71, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8121db33401a15ffe61b3bc0ca19f0d1fbd9391b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8121db33401a15ffe61b3bc0ca19f0d1fbd9391b", "patch": "@@ -44,27 +44,17 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::iter;\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n-use std::marker::PhantomData;\n use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use lint;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-struct InferredObligationsSnapshotVecDelegate<'tcx> {\n-    phantom: PhantomData<&'tcx i32>,\n-}\n-impl<'tcx> SnapshotVecDelegate for InferredObligationsSnapshotVecDelegate<'tcx> {\n-    type Value = PredicateObligation<'tcx>;\n-    type Undo = ();\n-    fn reverse(_: &mut Vec<Self::Value>, _: Self::Undo) {}\n-}\n \n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -92,8 +82,6 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: Option<IntercrateMode>,\n \n-    inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n-\n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n     /// Controls whether or not to filter out negative impls when selecting.\n@@ -429,7 +417,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -442,7 +429,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: Some(mode),\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n         }\n@@ -455,7 +441,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx,\n             freshener: infcx.freshener(),\n             intercrate: None,\n-            inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n         }\n@@ -498,8 +483,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        // The irrefutable nature of the operation means we don't need to snapshot the\n-        // inferred_obligations vector.\n         self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n     }\n \n@@ -508,28 +491,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn probe<R, F>(&mut self, f: F) -> R\n         where F: FnOnce(&mut Self, &infer::CombinedSnapshot<'cx, 'tcx>) -> R\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n-        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-        result\n+        self.infcx.probe(|snapshot| f(self, snapshot))\n     }\n \n     /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n     /// the transaction fails and s.t. old obligations are retained.\n     fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n         F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n     {\n-        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n-        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n-            Ok(ok) => {\n-                self.inferred_obligations.commit(inferred_obligations_snapshot);\n-                Ok(ok)\n-            },\n-            Err(err) => {\n-                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n-                Err(err)\n-            }\n-        }\n+        self.infcx.commit_if_ok(|snapshot| f(self, snapshot))\n     }\n \n \n@@ -560,12 +530,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         let ret = match self.candidate_from_obligation(&stack)? {\n             None => None,\n-            Some(candidate) => {\n-                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n-                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n-                candidate.nested_obligations_mut().extend(inferred_obligations);\n-                Some(candidate)\n-            },\n+            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n         };\n \n         // Test whether this is a `()` which was produced by defaulting a\n@@ -658,7 +623,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult\n-        where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n+        where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n@@ -695,7 +660,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.inferred_obligations.extend(obligations);\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n                         EvaluatedToOk\n                     },\n                     Some(Err(_)) => EvaluatedToErr,\n@@ -1542,12 +1507,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        match self.infcx.at(&obligation.cause, obligation.param_env)\n-                        .sup(ty::Binder(skol_trait_ref), trait_bound) {\n-            Ok(InferOk { obligations, .. }) => {\n-                self.inferred_obligations.extend(obligations);\n-            }\n-            Err(_) => { return false; }\n+        if let Err(_) = self.infcx.at(&obligation.cause, obligation.param_env)\n+                                  .sup(ty::Binder(skol_trait_ref), trait_bound) {\n+            return false;\n         }\n \n         self.infcx.leak_check(false, obligation.cause.span, skol_map, snapshot).is_ok()\n@@ -2633,6 +2595,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         let mut upcast_trait_ref = None;\n+        let mut nested = vec![];\n         let vtable_base;\n \n         {\n@@ -2651,7 +2614,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         self.commit_if_ok(\n                             |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n-                        Ok(_) => { upcast_trait_ref = Some(t); false }\n+                        Ok(obligations) => {\n+                            upcast_trait_ref = Some(t);\n+                            nested.extend(obligations);\n+                            false\n+                        }\n                         Err(_) => { true }\n                     }\n                 });\n@@ -2669,7 +2636,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base,\n-            nested: vec![]\n+            nested,\n         }\n     }\n \n@@ -2726,7 +2693,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n-            obligations\n+            mut obligations\n         } = normalize_with_depth(self,\n                                  obligation.param_env,\n                                  obligation.cause.clone(),\n@@ -2738,10 +2705,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         Ok(VtableGeneratorData {\n             closure_def_id: closure_def_id,\n@@ -2787,10 +2755,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.param_env,\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)?;\n+        obligations.extend(\n+            self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                        obligation.param_env,\n+                                        obligation.predicate.to_poly_trait_ref(),\n+                                        trait_ref)?);\n \n         obligations.push(Obligation::new(\n             obligation.cause.clone(),\n@@ -2834,13 +2803,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                obligation_param_env: ty::ParamEnv<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n-                               -> Result<(), SelectionError<'tcx>>\n+                               -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n         self.infcx\n             .at(&obligation_cause, obligation_param_env)\n             .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+            .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2877,7 +2846,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_trait)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2939,7 +2908,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(b, a)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -3003,7 +2972,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_struct)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3034,7 +3003,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n                               .eq(target, new_tuple)\n                               .map_err(|_| Unimplemented)?;\n-                self.inferred_obligations.extend(obligations);\n+                nested.extend(obligations);\n \n                 // Construct the nested T: Unsize<U> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -3107,7 +3076,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   impl_substs);\n \n-        let impl_trait_ref =\n+        let Normalized { value: impl_trait_ref, obligations: mut nested_obligations } =\n             project::normalize_with_depth(self,\n                                           obligation.param_env,\n                                           obligation.cause.clone(),\n@@ -3123,12 +3092,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let InferOk { obligations, .. } =\n             self.infcx.at(&obligation.cause, obligation.param_env)\n-                      .eq(skol_obligation_trait_ref, impl_trait_ref.value)\n+                      .eq(skol_obligation_trait_ref, impl_trait_ref)\n                       .map_err(|e| {\n                           debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                           ()\n                       })?;\n-        self.inferred_obligations.extend(obligations);\n+        nested_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n                                               obligation.cause.span,\n@@ -3141,7 +3110,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok((Normalized {\n             value: impl_substs,\n-            obligations: impl_trait_ref.obligations\n+            obligations: nested_obligations\n         }, skol_map))\n     }\n \n@@ -3178,24 +3147,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        self.match_poly_trait_ref(obligation, where_clause_trait_ref)?;\n-        Ok(Vec::new())\n+        self.match_poly_trait_ref(obligation, where_clause_trait_ref)\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n     fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n-                            -> Result<(),()>\n+                            -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n         debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n                obligation,\n                poly_trait_ref);\n \n         self.infcx.at(&obligation.cause, obligation.param_env)\n                   .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n-                  .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+                  .map(|InferOk { obligations, .. }| obligations)\n                   .map_err(|_| ())\n     }\n "}]}