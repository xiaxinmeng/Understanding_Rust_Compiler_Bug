{"sha": "4ecba94dcb415b0642ebd8695a08adc4ec07441e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlY2JhOTRkY2I0MTViMDY0MmViZDg2OTVhMDhhZGM0ZWMwNzQ0MWU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-26T12:16:02Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T22:11:29Z"}, "message": "Move weak lang items to librustc_lang_items.", "tree": {"sha": "52bfcae745e45e4c9fd4ff9b1fb7e464bb543ff1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52bfcae745e45e4c9fd4ff9b1fb7e464bb543ff1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ecba94dcb415b0642ebd8695a08adc4ec07441e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecba94dcb415b0642ebd8695a08adc4ec07441e", "html_url": "https://github.com/rust-lang/rust/commit/4ecba94dcb415b0642ebd8695a08adc4ec07441e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ecba94dcb415b0642ebd8695a08adc4ec07441e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c04195da9f47e8090bc49bad605765e9a2a721b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c04195da9f47e8090bc49bad605765e9a2a721b4", "html_url": "https://github.com/rust-lang/rust/commit/c04195da9f47e8090bc49bad605765e9a2a721b4"}], "stats": {"total": 148, "additions": 80, "deletions": 68}, "files": [{"sha": "ab19483a62d6e2661465d1646eb9caf89ee125d5", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 31, "deletions": 68, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=4ecba94dcb415b0642ebd8695a08adc4ec07441e", "patch": "@@ -10,13 +10,12 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_lang_items::weak_lang_items::WEAK_ITEMS_REFS;\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::PanicStrategy;\n-use syntax::ast;\n \n-macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n+pub use rustc_lang_items::weak_lang_items::link_name;\n \n struct Context<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -25,16 +24,14 @@ struct Context<'a, 'tcx> {\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n-                             items: &mut lang_items::LanguageItems) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n     // so here.\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n-    if tcx.sess.target.target.options.custom_unwind_resume &\n-       items.eh_unwind_resume().is_none() {\n+    if tcx.sess.target.target.options.custom_unwind_resume & items.eh_unwind_resume().is_none() {\n         items.missing.push(lang_items::EhUnwindResumeLangItem);\n     }\n \n@@ -45,16 +42,6 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n     verify(tcx, items);\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    rustc_lang_items::lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n-        }\n-    })\n-}\n-\n /// Returns `true` if the specified `lang_item` doesn't actually need to be\n /// present for this compilation.\n ///\n@@ -66,29 +53,26 @@ pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: lang_items::LangItem) -> bool {\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == lang_items::EhPersonalityLangItem ||\n-            lang_item == lang_items::EhUnwindResumeLangItem\n+        return lang_item == lang_items::EhPersonalityLangItem\n+            || lang_item == lang_items::EhUnwindResumeLangItem;\n     }\n \n     false\n }\n \n-fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n-                    items: &lang_items::LanguageItems) {\n+fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n-    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n-        match *kind {\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro |\n-            config::CrateType::Cdylib |\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib => true,\n-            config::CrateType::Rlib => false,\n-        }\n+    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n+        config::CrateType::Dylib\n+        | config::CrateType::ProcMacro\n+        | config::CrateType::Cdylib\n+        | config::CrateType::Executable\n+        | config::CrateType::Staticlib => true,\n+        config::CrateType::Rlib => false,\n     });\n     if !needs_check {\n-        return\n+        return;\n     }\n \n     let mut missing = FxHashSet::default();\n@@ -98,37 +82,28 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n         }\n     }\n \n-    $(\n-        if missing.contains(&lang_items::$item) &&\n-           !whitelisted(tcx, lang_items::$item) &&\n-           items.$name().is_none() {\n-            if lang_items::$item == lang_items::PanicImplLangItem {\n-                tcx.sess.err(&format!(\"`#[panic_handler]` function required, \\\n-                                       but not found\"));\n-            } else if lang_items::$item == lang_items::OomLangItem {\n-                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, \\\n-                                       but not found\"));\n+    for (name, &item) in WEAK_ITEMS_REFS.iter() {\n+        if missing.contains(&item) && !whitelisted(tcx, item) && items.require(item).is_err() {\n+            if item == lang_items::PanicImplLangItem {\n+                tcx.sess.err(&format!(\"`#[panic_handler]` function required, but not found\"));\n+            } else if item == lang_items::OomLangItem {\n+                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, but not found\"));\n             } else {\n-                tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n-                                      stringify!($name)));\n+                tcx.sess.err(&format!(\"language item required, but not found: `{}`\", name));\n             }\n         }\n-    )*\n+    }\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n     fn register(&mut self, name: Symbol, span: Span) {\n-        $(if name == sym::$name {\n-            if self.items.$name().is_none() {\n-                self.items.missing.push(lang_items::$item);\n+        if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n+            if self.items.require(item).is_err() {\n+                self.items.missing.push(item);\n             }\n-        } else)* {\n-            struct_span_err!(\n-                self.tcx.sess, span, E0264,\n-                \"unknown external lang item: `{}`\",\n-                name\n-            )\n-            .emit();\n+        } else {\n+            struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n+                .emit();\n         }\n     }\n }\n@@ -150,18 +125,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let lang_items = self.lang_items();\n-        let did = Some(item_def_id);\n-\n-        $(lang_items.$name() == did)||*\n+        self.lang_items().is_weak_lang_item(item_def_id)\n     }\n }\n-\n-) }\n-\n-weak_lang_items! {\n-    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n-    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n-    oom,                OomLangItem,                rust_oom;\n-}"}, {"sha": "9bcd54b6cbfa1e5839944762596370c3e1614ea5", "filename": "src/librustc_lang_items/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc_lang_items%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc_lang_items%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lang_items%2Flib.rs?ref=4ecba94dcb415b0642ebd8695a08adc4ec07441e", "patch": "@@ -37,6 +37,7 @@ macro_rules! enum_from_u32 {\n \n pub mod lang_items;\n mod target;\n+pub mod weak_lang_items;\n \n pub use lang_items::{LangItem, LanguageItems};\n pub use target::{MethodKind, Target};"}, {"sha": "ab2955fb3fcf0ec65a573c70babcfd69a9e2895f", "filename": "src/librustc_lang_items/weak_lang_items.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc_lang_items%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecba94dcb415b0642ebd8695a08adc4ec07441e/src%2Flibrustc_lang_items%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lang_items%2Fweak_lang_items.rs?ref=4ecba94dcb415b0642ebd8695a08adc4ec07441e", "patch": "@@ -0,0 +1,48 @@\n+//! Validity checking for weak lang items\n+\n+use crate::{lang_items, LangItem, LanguageItems};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::{sym, Symbol};\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+macro_rules! weak_lang_items {\n+    ($($name:ident, $item:ident, $sym:ident;)*) => (\n+\n+lazy_static! {\n+    pub static ref WEAK_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n+        let mut map = FxHashMap::default();\n+        $(map.insert(sym::$name, lang_items::$item);)*\n+        map\n+    };\n+}\n+\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    lang_items::extract(attrs).and_then(|(name, _)| {\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n+        } else)* {\n+            None\n+        }\n+    })\n+}\n+\n+impl LanguageItems {\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        let did = Some(item_def_id);\n+\n+        $(self.$name() == did)||*\n+    }\n+}\n+\n+) }\n+\n+weak_lang_items! {\n+    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n+    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n+    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n+    oom,                OomLangItem,                rust_oom;\n+}"}]}