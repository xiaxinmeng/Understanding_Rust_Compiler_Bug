{"sha": "e96a171453973bad66ed9b5df3a7f6e37d9bce31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NmExNzE0NTM5NzNiYWQ2NmVkOWI1ZGYzYTdmNmUzN2Q5YmNlMzE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-05T05:01:48Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc: move the actual values of enum discriminants into a map.", "tree": {"sha": "a0b02603017a66c97e779890685a52e5b8ac43d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b02603017a66c97e779890685a52e5b8ac43d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e96a171453973bad66ed9b5df3a7f6e37d9bce31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e96a171453973bad66ed9b5df3a7f6e37d9bce31", "html_url": "https://github.com/rust-lang/rust/commit/e96a171453973bad66ed9b5df3a7f6e37d9bce31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e96a171453973bad66ed9b5df3a7f6e37d9bce31/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86e402904ae68e3a72e5c88d0a1722ab753f98d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/86e402904ae68e3a72e5c88d0a1722ab753f98d8", "html_url": "https://github.com/rust-lang/rust/commit/86e402904ae68e3a72e5c88d0a1722ab753f98d8"}], "stats": {"total": 458, "additions": 311, "deletions": 147}, "files": [{"sha": "8da032f59353a9ea0410aca3e1b63331bf8f0910", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -114,6 +114,7 @@ pub enum DepNode<D: Clone + Debug> {\n     InherentImpls(D),\n     TypeckTables(D),\n     UsedTraitImports(D),\n+    MonomorphicConstEval(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -263,6 +264,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n+            MonomorphicConstEval(ref d) => op(d).map(MonomorphicConstEval),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "527f115277082318de059d8be2a4d4cf47712b17", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -173,7 +173,9 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Discriminant(ref lval) => {\n                 let ty = lval.ty(mir, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n-                    Some(adt_def.discr_ty.to_ty(tcx))\n+                    let repr_hints = tcx.lookup_repr_hints(adt_def.did);\n+                    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+                    Some(repr_type.to_ty(tcx))\n                 } else {\n                     // Undefined behaviour, bug for now; may want to return something for\n                     // the `discriminant` intrinsic later."}, {"sha": "c7e7fac275981eb77386b9b605e360f625f82476", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -507,6 +507,10 @@ pub struct GlobalCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n+    /// Results of evaluating monomorphic constants embedded in\n+    /// other items, such as enum variant explicit discriminants.\n+    pub monomorphic_const_eval: RefCell<DepTrackingMap<maps::MonomorphicConstEval<'tcx>>>,\n+\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -662,12 +666,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         discr_ty: Option<attr::IntType>,\n                          variants: Vec<ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let discr_ty = discr_ty.unwrap_or(attr::UnsignedInt(ast::UintTy::U8));\n-        let def = ty::AdtDef::new(self, did, kind, discr_ty, variants, repr);\n+        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n@@ -783,6 +785,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             used_trait_imports: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             populated_external_types: RefCell::new(DefIdSet()),\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n+            monomorphic_const_eval: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),"}, {"sha": "5829ae195c9413bd5acfe7fd6b3669b3e14eb66d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -20,6 +20,7 @@ use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n+use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -1181,8 +1182,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let (mut min, mut max, mut non_zero) = (i64::max_value(),\n                                                             i64::min_value(),\n                                                             true);\n-                    for v in &def.variants {\n-                        let x = v.disr_val as i128 as i64;\n+                    for discr in def.discriminants(tcx) {\n+                        let x = match discr.erase_type() {\n+                            ConstInt::InferSigned(i) => i as i64,\n+                            ConstInt::Infer(i) => i as u64 as i64,\n+                            _ => bug!()\n+                        };\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n@@ -1240,7 +1245,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u128 != v.disr_val {\n+                    if v.discr != ty::VariantDiscr::Relative(i) {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }\n@@ -1348,7 +1353,9 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n-                let typeck_ity = Integer::from_attr(dl, def.discr_ty);\n+                let repr_hints = tcx.lookup_repr_hints(def.did);\n+                let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+                let typeck_ity = Integer::from_attr(dl, repr_type);\n                 if typeck_ity < min_ity {\n                     // It is a bug if Layout decided on a greater discriminant size than typeck for\n                     // some reason at this point (based on values discriminant can take on). Mostly"}, {"sha": "cedb0307495602696a47053091d62e3fe9a5ccce", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -10,6 +10,7 @@\n \n use dep_graph::{DepNode, DepTrackingMapConfig};\n use hir::def_id::DefId;\n+use middle::const_val::ConstVal;\n use mir;\n use ty::{self, Ty};\n use util::nodemap::DefIdSet;\n@@ -51,3 +52,4 @@ dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n dep_map_ty! { TypeckTables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx> }\n dep_map_ty! { UsedTraitImports: UsedTraitImports(DefId) -> DefIdSet }\n+dep_map_ty! { MonomorphicConstEval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()> }"}, {"sha": "be4ec881482d1870957c50a241fdf996a24440de", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -20,13 +20,15 @@ use hir::{map as hir_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n+use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n@@ -45,6 +47,7 @@ use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n+use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n \n@@ -96,8 +99,6 @@ mod flags;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = u128;\n-\n // Data types\n \n /// The complete set of all analyses described in this module. This is\n@@ -1309,11 +1310,24 @@ pub struct VariantDef {\n     /// this is the DefId of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n-    pub disr_val: Disr,\n+    pub discr: VariantDiscr,\n     pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub enum VariantDiscr {\n+    /// Explicit value for this variant, i.e. `X = 123`.\n+    /// The `DefId` corresponds to the embedded constant.\n+    Explicit(DefId),\n+\n+    /// The previous variant's discriminant plus one.\n+    /// For efficiency reasons, the distance from the\n+    /// last `Explicit` discriminant is being stored,\n+    /// or `0` for the first variant, if it has none.\n+    Relative(usize),\n+}\n+\n #[derive(Debug)]\n pub struct FieldDef {\n     pub did: DefId,\n@@ -1327,12 +1341,6 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n-    /// Type of the discriminant\n-    ///\n-    /// Note, that this is the type specified in `repr()` or a default type of some sort, and might\n-    /// not match the actual type that layout algorithm decides to use when translating this type\n-    /// into LLVM. That being said, layout algorithm may not use a type larger than specified here.\n-    pub discr_ty: attr::IntType,\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n@@ -1395,7 +1403,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           discr_ty: attr::IntType,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -1419,7 +1426,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n         AdtDef {\n             did: did,\n-            discr_ty: discr_ty,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n@@ -1577,6 +1583,28 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.destructor.set(Some(dtor));\n     }\n \n+    pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                         -> impl Iterator<Item=ConstInt> + 'a {\n+        let repr_hints = tcx.lookup_repr_hints(self.did);\n+        let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+        let initial = repr_type.initial_discriminant(tcx.global_tcx());\n+        let mut prev_discr = None::<ConstInt>;\n+        self.variants.iter().map(move |v| {\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+            if let VariantDiscr::Explicit(expr_did) = v.discr {\n+                match tcx.monomorphic_const_eval.borrow()[&expr_did] {\n+                    Ok(ConstVal::Integral(v)) => {\n+                        discr = v;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            prev_discr = Some(discr);\n+\n+            discr\n+        })\n+    }\n+\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///"}, {"sha": "af25990978793696c2b9a0245e54af584a892d85", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -16,13 +16,14 @@ use infer::InferCtxt;\n use hir::map as hir_map;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n-use ty::{Disr, ParameterEnvironment};\n+use ty::{ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n+use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n@@ -35,21 +36,88 @@ use syntax_pos::Span;\n \n use hir;\n \n-pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n-}\n+type Disr = ConstInt;\n+\n+ pub trait IntTypeExt {\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr>;\n+    fn assert_ty_matches(&self, val: Disr);\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+ }\n+\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match self {\n-            SignedInt(i) => tcx.mk_mach_int(i),\n-            UnsignedInt(i) => tcx.mk_mach_uint(i),\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n+            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n+            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n+            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n+            SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n+            UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n+            UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n+            UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n+            UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n+            UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n+        }\n+    }\n+\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n+        match *self {\n+            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n+            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n+            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n+            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n+            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n+                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n+                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n+                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n+                _ => bug!(),\n+            },\n+            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n+            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n+            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n+            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n+            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n+                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n+                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n+                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n+                _ => bug!(),\n+            },\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        0\n+    fn assert_ty_matches(&self, val: Disr) {\n+        match (*self, val) {\n+            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n+            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n+            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n+            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n+            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n+            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n+            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n+            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n+            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n+            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n+            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n+        }\n+    }\n+\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr> {\n+        if let Some(val) = val {\n+            self.assert_ty_matches(val);\n+            (val + ConstInt::Infer(1)).ok()\n+        } else {\n+            Some(self.initial_discriminant(tcx))\n+        }\n     }\n }\n "}, {"sha": "c64b25032c9efbc59e11edf12f59724e90af17f7", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n-use rustc::middle::const_val::{ConstVal, ConstInt};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -639,10 +639,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let mut values = Vec::with_capacity(adt.variants.len());\n                 let mut blocks = Vec::with_capacity(adt.variants.len());\n                 let mut otherwise = None;\n-                for (variant_index, variant) in adt.variants.iter().enumerate() {\n-                    let discr = ConstInt::new_inttype(variant.disr_val, adt.discr_ty,\n-                                                      self.tcx.sess.target.uint_type,\n-                                                      self.tcx.sess.target.int_type).unwrap();\n+                for (variant_index, discr) in adt.discriminants(self.tcx).enumerate() {\n                     let subpath = super::move_path_children_matching(\n                         self.move_data(), c.path, |proj| match proj {\n                             &Projection {\n@@ -680,7 +677,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 // Additionally, we do not want to switch on the\n                 // discriminant after it is free-ed, because that\n                 // way lies only trouble.\n-                let discr_ty = adt.discr_ty.to_ty(self.tcx);\n+                let repr_hints = self.tcx.lookup_repr_hints(adt.did);\n+                let repr_type = self.tcx.enum_repr_type(repr_hints.get(0));\n+                let discr_ty = repr_type.to_ty(self.tcx);\n                 let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n                 let switch_block = self.patch.new_block(BasicBlockData {\n                     statements: vec!["}, {"sha": "17714f2fb2d6cd3074c460e7b6783cbdf0704ee8", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -77,14 +77,6 @@ mod ibounds {\n }\n \n impl ConstInt {\n-    pub fn new_inttype(val: u128, ty: IntType, usize_ty: UintTy, isize_ty: IntTy)\n-    -> Option<ConstInt> {\n-        match ty {\n-            IntType::SignedInt(i) => ConstInt::new_signed(val as i128, i, isize_ty),\n-            IntType::UnsignedInt(i) => ConstInt::new_unsigned(val, i, usize_ty),\n-        }\n-    }\n-\n     /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n     /// not happen.\n     pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {"}, {"sha": "88b06e29e103ce3a0e7f00dc7cea166e7f1683b7", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -515,7 +515,8 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_variant(&self,\n                    item: &Entry<'tcx>,\n-                   index: DefIndex)\n+                   index: DefIndex,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                    -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n@@ -524,6 +525,11 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n+        if let ty::VariantDiscr::Explicit(def_id) = data.discr {\n+            let result = data.evaluated_discr.map_or(Err(()), Ok);\n+            tcx.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n+        }\n+\n         (ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n             name: self.item_name(index),\n@@ -535,7 +541,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            disr_val: data.disr,\n+            discr: data.discr,\n             ctor_kind: data.ctor_kind,\n         }, data.struct_ctor)\n     }\n@@ -546,35 +552,36 @@ impl<'a, 'tcx> CrateMetadata {\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n-        let (kind, ty) = match item.kind {\n-            EntryKind::Enum(dt, _) => (ty::AdtKind::Enum, Some(dt.decode(self))),\n-            EntryKind::Struct(_, _) => (ty::AdtKind::Struct, None),\n-            EntryKind::Union(_, _) => (ty::AdtKind::Union, None),\n+        let kind = match item.kind {\n+            EntryKind::Enum(_) => ty::AdtKind::Enum,\n+            EntryKind::Struct(_, _) => ty::AdtKind::Struct,\n+            EntryKind::Union(_, _) => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n         let mut ctor_index = None;\n         let variants = if let ty::AdtKind::Enum = kind {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n+                    let (variant, struct_ctor) =\n+                        self.get_variant(&self.entry(index), index, tcx);\n                     assert_eq!(struct_ctor, None);\n                     variant\n                 })\n                 .collect()\n         } else {\n-            let (variant, struct_ctor) = self.get_variant(&item, item_id);\n+            let (variant, struct_ctor) = self.get_variant(&item, item_id, tcx);\n             ctor_index = struct_ctor;\n             vec![variant]\n         };\n         let (kind, repr) = match item.kind {\n-            EntryKind::Enum(_, repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, ty, variants, repr);\n+        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n             tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);"}, {"sha": "725d54c227a3074a3864f94b2e3aece2207b0c39", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -261,7 +261,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val,\n+            discr: variant.discr,\n+            evaluated_discr: match variant.discr {\n+                ty::VariantDiscr::Explicit(def_id) => {\n+                    tcx.monomorphic_const_eval.borrow()[&def_id].clone().ok()\n+                }\n+                ty::VariantDiscr::Relative(_) => None\n+            },\n             struct_ctor: None,\n         };\n \n@@ -388,7 +394,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val,\n+            discr: variant.discr,\n+            evaluated_discr: None,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -644,8 +651,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum(self.lazy(&tcx.lookup_adt_def(def_id).discr_ty),\n-                                                 get_repr_options(&tcx, def_id)),\n+            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -662,7 +668,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val,\n+                    discr: variant.discr,\n+                    evaluated_discr: None,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -672,7 +679,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val,\n+                    discr: variant.discr,\n+                    evaluated_discr: None,\n                     struct_ctor: None,\n                 }), repr_options)\n             }"}, {"sha": "6307d4eda308efd24256fd8af000b94c2a43f389", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -14,6 +14,7 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -227,7 +228,7 @@ pub enum EntryKind<'tcx> {\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum(Lazy<attr::IntType>, ReprOptions),\n+    Enum(ReprOptions),\n     Field,\n     Variant(Lazy<VariantData>),\n     Struct(Lazy<VariantData>, ReprOptions),\n@@ -264,7 +265,8 @@ pub struct FnData {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData {\n     pub ctor_kind: CtorKind,\n-    pub disr: u128,\n+    pub discr: ty::VariantDiscr,\n+    pub evaluated_discr: Option<ConstVal>,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item."}, {"sha": "3256bdf9c25e31ae30d84ebfa99de0cfb4cdca48", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -20,7 +20,7 @@ use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::{ConstVal, ConstInt};\n+use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n@@ -191,11 +191,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let mut targets = Vec::with_capacity(used_variants + 1);\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n-                for (idx, variant) in adt_def.variants.iter().enumerate() {\n+                for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n                     target_blocks.place_back() <- if variants.contains(idx) {\n-                        let discr = ConstInt::new_inttype(variant.disr_val, adt_def.discr_ty,\n-                                                          tcx.sess.target.uint_type,\n-                                                          tcx.sess.target.int_type).unwrap();\n                         values.push(discr);\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n@@ -212,7 +209,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n-                let discr_ty = adt_def.discr_ty.to_ty(tcx);\n+                let repr_hints = tcx.lookup_repr_hints(adt_def.did);\n+                let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+                let discr_ty = repr_type.to_ty(tcx);\n                 let discr = self.temp(discr_ty);\n                 self.cfg.push_assign(block, source_info, &discr,\n                                      Rvalue::Discriminant(lvalue.clone()));"}, {"sha": "9a06820115f632831d152dbaade69007082b83c7", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -93,9 +93,9 @@ impl<'tcx> Callee<'tcx> {\n \n         // FIXME(eddyb) Detect ADT constructors more efficiently.\n         if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n-            if let Some(v) = adt_def.variants.iter().find(|v| def_id == v.did) {\n+            if let Some(i) = adt_def.variants.iter().position(|v| def_id == v.did) {\n                 return Callee {\n-                    data: NamedTupleConstructor(Disr::from(v.disr_val)),\n+                    data: NamedTupleConstructor(Disr::for_variant(tcx, adt_def, i)),\n                     ty: fn_ty\n                 };\n             }"}, {"sha": "2b584344ed1c7a3d9cb04e61dcf22e1ba2f786b3", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -1465,18 +1465,18 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // <unknown>\n     let file_metadata = unknown_file_metadata(cx);\n \n-    let variants = &enum_type.ty_adt_def().unwrap().variants;\n-    let enumerators_metadata: Vec<DIDescriptor> = variants\n-        .iter()\n-        .map(|v| {\n+    let def = enum_type.ty_adt_def().unwrap();\n+    let enumerators_metadata: Vec<DIDescriptor> = def.discriminants(cx.tcx())\n+        .zip(&def.variants)\n+        .map(|(discr, v)| {\n             let token = v.name.as_str();\n             let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    v.disr_val as u64)\n+                    discr.to_u128_unchecked() as u64)\n             }\n         })\n         .collect();"}, {"sha": "00c0e0d541586eeb92dc4f8f9d23ce26f967b342", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -8,10 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_const_math::ConstInt;\n+\n #[derive(Debug, Eq, PartialEq, Copy, Clone)]\n pub struct Disr(pub u64);\n \n impl Disr {\n+    pub fn for_variant(tcx: TyCtxt,\n+                       def: &ty::AdtDef,\n+                       variant_index: usize) -> Self {\n+        let mut explicit_index = variant_index;\n+        let mut explicit_value = Disr(0);\n+        loop {\n+            match def.variants[explicit_index].discr {\n+                ty::VariantDiscr::Relative(0) => break,\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(expr_did) => {\n+                    match tcx.monomorphic_const_eval.borrow()[&expr_did] {\n+                        Ok(ConstVal::Integral(v)) => {\n+                            explicit_value = Disr::from(v);\n+                            break;\n+                        }\n+                        _ => {\n+                            explicit_index -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let distance = variant_index - explicit_index;\n+        explicit_value.wrapping_add(Disr::from(distance))\n+    }\n+\n     pub fn wrapping_add(self, other: Self) -> Self {\n         Disr(self.0.wrapping_add(other.0))\n     }\n@@ -24,10 +56,10 @@ impl ::std::ops::BitAnd for Disr {\n     }\n }\n \n-impl From<::rustc::ty::Disr> for Disr {\n-    fn from(i: ::rustc::ty::Disr) -> Disr {\n+impl From<ConstInt> for Disr {\n+    fn from(i: ConstInt) -> Disr {\n         // FIXME: what if discr has 128 bit discr?\n-        Disr(i as u64)\n+        Disr(i.to_u128_unchecked() as u64)\n     }\n }\n "}, {"sha": "58e0a9e589f3369b70be642435d2088f85237195", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -521,11 +521,10 @@ fn drop_structural_ty<'a, 'tcx>(\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n                         let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n \n-                        for (i, variant) in adt.variants.iter().enumerate() {\n-                            let variant_cx_name = format!(\"enum-iter-variant-{}\",\n-                                &variant.disr_val.to_string());\n+                        for (i, discr) in adt.discriminants(cx.tcx()).enumerate() {\n+                            let variant_cx_name = format!(\"enum-iter-variant-{}\", i);\n                             let variant_cx = cx.build_sibling_block(&variant_cx_name);\n-                            let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n+                            let case_val = adt::trans_case(&cx, t, Disr::from(discr));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             ptr.ty = LvalueTy::Downcast {\n                                 adt_def: adt,"}, {"sha": "6a0e05803c355cef9d45b46dd3157e198a8f56ee", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -1001,7 +1001,7 @@ fn trans_const<'a, 'tcx>(\n         layout::CEnum { discr: d, min, max, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    Disr::from(adt_def.variants[variant_index].disr_val)\n+                    Disr::for_variant(ccx.tcx(), adt_def, variant_index)\n                 },\n                 _ => Disr(0),\n             };"}, {"sha": "c3dffd476e133115308aacf397c8b59dc910011e", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -106,9 +106,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n+                        let disr = Disr::for_variant(bcx.tcx(), adt_def, variant_index);\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n+                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, disr);\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 val.ty = LvalueTy::Downcast {\n                                     adt_def: adt_def,\n                                     substs: self.monomorphize(&substs),\n-                                    variant_index: disr.0 as usize,\n+                                    variant_index: variant_index,\n                                 };\n                                 let (lldest_i, align) = val.trans_field_ptr(&bcx, field_index);\n                                 self.store_operand(&bcx, lldest_i, align.to_align(), op);"}, {"sha": "6a003ef734020fecb1be85d4150233bac2d4bf86", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -124,6 +124,7 @@ use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n use rustc_const_eval::eval_length;\n+use rustc_const_math::ConstInt;\n \n mod assoc;\n mod autoderef;\n@@ -1323,14 +1324,12 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     let def_id = ccx.tcx.hir.local_def_id(id);\n \n-    let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n-    let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-    for (v, variant) in vs.iter().zip(variants.iter()) {\n-        let current_disr_val = variant.disr_val;\n-\n+    let def = ccx.tcx.lookup_adt_def(def_id);\n+    let mut disr_vals: Vec<ConstInt> = Vec::new();\n+    for (discr, v) in def.discriminants(ccx.tcx).zip(vs) {\n         // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-            let variant_i_node_id = ccx.tcx.hir.as_local_node_id(variants[i].did).unwrap();\n+        if let Some(i) = disr_vals.iter().position(|&x| x == discr) {\n+            let variant_i_node_id = ccx.tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n             let variant_i = ccx.tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {\n                 Some(expr) => ccx.tcx.hir.span(expr.node_id),\n@@ -1346,7 +1345,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n                 .emit();\n         }\n-        disr_vals.push(current_disr_val);\n+        disr_vals.push(discr);\n     }\n \n     check_representable(ccx.tcx, sp, def_id);"}, {"sha": "3f3fc40320eb63903856501d531eba20b938e0de", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -875,8 +875,36 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                         def: &'tcx ty::AdtDef,\n                                         ty: Ty<'tcx>,\n                                         variants: &[hir::Variant]) {\n-    // fill the field types\n+    let tcx = ccx.tcx;\n+    let repr_hints = tcx.lookup_repr_hints(def.did);\n+    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n+    let initial = repr_type.initial_discriminant(tcx);\n+    let mut prev_discr = None::<ConstInt>;\n+\n+    // fill the discriminant values and field types\n     for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n+        let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+        prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n+            let result = evaluate_disr_expr(ccx, repr_type, e);\n+\n+            let expr_did = tcx.hir.local_def_id(e.node_id);\n+            tcx.monomorphic_const_eval.borrow_mut()\n+               .insert(expr_did, result.map(ConstVal::Integral));\n+\n+            result.ok()\n+        } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n+            Some(discr)\n+        } else {\n+            struct_span_err!(tcx.sess, variant.span, E0370,\n+                             \"enum discriminant overflowed\")\n+                .span_label(variant.span, &format!(\"overflowed on value after {}\",\n+                                                   prev_discr.unwrap()))\n+                .note(&format!(\"explicitly set `{} = {}` if that is desired outcome\",\n+                               variant.node.name, wrapped_discr))\n+                .emit();\n+            None\n+        }.unwrap_or(wrapped_discr));\n+\n         for (f, ty_f) in variant.node.data.fields().iter().zip(ty_variant.fields.iter()) {\n             convert_field(ccx, f, ty_f)\n         }\n@@ -890,7 +918,7 @@ fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     did: DefId,\n                                     name: ast::Name,\n-                                    disr_val: ty::Disr,\n+                                    discr: ty::VariantDiscr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n@@ -918,7 +946,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ty::VariantDef {\n         did: did,\n         name: name,\n-        disr_val: disr_val,\n+        discr: discr,\n         fields: fields,\n         ctor_kind: CtorKind::from_hir(def),\n     }\n@@ -932,8 +960,9 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = ccx.tcx.hir.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n-    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name, 0, def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, None, variants,\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n+                                               ty::VariantDiscr::Relative(0), def)];\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n         ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n@@ -950,15 +979,16 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.hir.local_def_id(it.id);\n-    let variants = vec![convert_struct_variant(ccx, did, it.name, 0, def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, None, variants,\n-                                    ReprOptions::new(&ccx.tcx, did));\n+    let variants = vec![convert_struct_variant(ccx, did, it.name,\n+                                               ty::VariantDiscr::Relative(0), def)];\n+\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n-                      -> Option<ConstInt> {\n+                      -> Result<ConstInt, ()> {\n     let e = &ccx.tcx.hir.body(body).value;\n     debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n \n@@ -987,25 +1017,24 @@ fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId\n                 (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n                 (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n                 (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n-                (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) =>\n-                    Some(i),\n+                (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Ok(i),\n                 (_, i) => {\n                     print_err(ConstVal::Integral(i));\n-                    None\n+                    Err(())\n                 },\n             }\n         },\n         Ok(cv) => {\n             print_err(cv);\n-            None\n+            Err(())\n         },\n         // enum variant evaluation happens before the global constant check\n         // so we need to report the real error\n         Err(err) => {\n             let mut diag = report_const_eval_err(\n                 ccx.tcx, &err, e.span, \"enum discriminant\");\n             diag.emit();\n-            None\n+            Err(())\n         }\n     }\n }\n@@ -1016,36 +1045,22 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               -> &'tcx ty::AdtDef\n {\n     let tcx = ccx.tcx;\n-    let did = tcx.hir.local_def_id(it.id);\n-    let repr_hints = tcx.lookup_repr_hints(did);\n-    let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-    let initial = ConstInt::new_inttype(repr_type.initial_discriminant(tcx), repr_type,\n-                                        tcx.sess.target.uint_type, tcx.sess.target.int_type)\n-        .unwrap();\n-    let mut prev_disr = None::<ConstInt>;\n+    let mut distance_from_explicit = 0;\n     let variants = def.variants.iter().map(|v| {\n-        let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n-        let disr = if let Some(e) = v.node.disr_expr {\n-            // FIXME: i128 discriminants\n-            evaluate_disr_expr(ccx, repr_type, e)\n-        } else if let Some(disr) = prev_disr.map_or(Some(initial),\n-                                                    |v| (v + ConstInt::Infer(1)).ok()) {\n-            Some(disr)\n-        } else {\n-            struct_span_err!(tcx.sess, v.span, E0370,\n-                             \"enum discriminant overflowed\")\n-                .span_label(v.span, &format!(\"overflowed on value after {}\", prev_disr.unwrap()))\n-                .note(&format!(\"explicitly set `{} = {}` if that is desired outcome\",\n-                               v.node.name, wrapped_disr))\n-                .emit();\n-            None\n-        }.unwrap_or(wrapped_disr);\n-        prev_disr = Some(disr);\n         let did = tcx.hir.local_def_id(v.node.data.id());\n-        convert_struct_variant(ccx, did, v.node.name, disr.to_u128_unchecked(), &v.node.data)\n+        let discr = if let Some(e) = v.node.disr_expr {\n+            distance_from_explicit = 0;\n+            ty::VariantDiscr::Explicit(tcx.hir.local_def_id(e.node_id))\n+        } else {\n+            ty::VariantDiscr::Relative(distance_from_explicit)\n+        };\n+        distance_from_explicit += 1;\n+\n+        convert_struct_variant(ccx, did, v.node.name, discr, &v.node.data)\n     }).collect();\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, Some(repr_type), variants,\n-                                ReprOptions::new(&ccx.tcx, did));\n+\n+    let did = tcx.hir.local_def_id(it.id);\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}, {"sha": "9911e093a898036d5fcae44fe656f6add46c2225", "filename": "src/test/compile-fail/E0081.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Ftest%2Fcompile-fail%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Ftest%2Fcompile-fail%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0081.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n enum Enum {\n-    P = 3, //~ NOTE first use of `3`\n+    P = 3, //~ NOTE first use of `3isize`\n     X = 3,\n-    //~^ ERROR discriminant value `3` already exists\n-    //~| NOTE enum already has `3`\n+    //~^ ERROR discriminant value `3isize` already exists\n+    //~| NOTE enum already has `3isize`\n     Y = 5\n }\n "}, {"sha": "658a0c1546b9f337b27704fa31d060075e91bdfc", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e96a171453973bad66ed9b5df3a7f6e37d9bce31/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=e96a171453973bad66ed9b5df3a7f6e37d9bce31", "patch": "@@ -12,20 +12,20 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    //~^ NOTE first use of `1`\n-    //~| NOTE first use of `1`\n-    //~| NOTE first use of `1`\n+    //~^ NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n+    //~| NOTE first use of `1isize`\n     B = 1,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n     C = 0,\n     D,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n     E = N,\n-    //~^ ERROR discriminant value `1` already exists\n-    //~| NOTE enum already has `1`\n+    //~^ ERROR discriminant value `1isize` already exists\n+    //~| NOTE enum already has `1isize`\n \n }\n "}]}