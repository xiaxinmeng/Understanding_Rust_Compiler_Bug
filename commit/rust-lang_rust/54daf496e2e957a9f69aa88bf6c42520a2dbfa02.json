{"sha": "54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "node_id": "C_kwDOAAsO6NoAKDU0ZGFmNDk2ZTJlOTU3YTlmNjlhYTg4YmY2YzQyNTIwYTJkYmZhMDI", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-04-25T13:19:50Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-04-25T13:19:50Z"}, "message": "std: directly use pthread in UNIX parker implementation\n\nMutex and Condvar are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore use the pthread synchronization primitives directly. Also, avoid allocating because the Parker struct is being placed in an Arc anyways.", "tree": {"sha": "3ecee0dc5e3b5f0e8c3a93ce4bd6ecb5eaf05a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ecee0dc5e3b5f0e8c3a93ce4bd6ecb5eaf05a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmJmn/YACgkQcE4BSbAZ\nSzx0rg/+Pv0Gz/CaKFAWhZCrC0htUhvbaExu7LaM9tx3ugjDSz4acF3zJIQbhs7f\nRXNrC7bE8LeDbrucjJCXyInc6U3M+/ce4ndLlGXuVMRSEkMw1UuLVx2N+odAVzcO\nQ98aZ1E99vpDp+Ea0Eas5SeG2c+xnvki4KB31Obkfex9kC1MZhMDYwpAVhX+q7EI\nPb2OxiF+nBBSXQCjSuqyK3PY71lbilQbduPSHxHdPOqlnvCc53q4HagSMjCgaKp6\nJRF8rVeUsHdFnUycifEyLqrca8ZNiUA+JNW0Uq2lF3uTnTQCpqZtXwBj5TF9FyXZ\n0zxNAZ7oyFymD1Y/yc0vZrA4aZX6Q0DEoFJO9VPcdD6O0bSh/isG9UxmLt4ZUaJS\noC8E1QNUlMs20CA+Qy1o/AyufIUGfC6MLUnt7i1AKmC0sHxyaoO2T1ao1hhIkNrw\nQlVsneKt4Hg3ieTcsz9vq208xddsWv3vEHug6f+H+7jfHj5qCvQPFp3y7QBy1YH+\n6KdmVdJKeKIc7DFkWceOBHL5GLKQFKhD+Tq98qJVNpeQ6zHF05IFif2wiZsfoEX5\n9u6qLwfTbFfqycUO220NQ/B1CbOzoW7ETFDJPfn7gFQCYxvw+geAQnc2LCfBU9VD\nsrrXW8uTZUiF25Q2q7fPaG73UfESfAYmcNhzxunSPXAkqTGl/bM=\n=qNVi\n-----END PGP SIGNATURE-----", "payload": "tree 3ecee0dc5e3b5f0e8c3a93ce4bd6ecb5eaf05a5f\nparent b759b2218649016cc40e82bdd6d958e2277ff6d7\nauthor joboet <jonasboettiger@icloud.com> 1650892790 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1650892790 +0200\n\nstd: directly use pthread in UNIX parker implementation\n\nMutex and Condvar are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore use the pthread synchronization primitives directly. Also, avoid allocating because the Parker struct is being placed in an Arc anyways.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "html_url": "https://github.com/rust-lang/rust/commit/54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b759b2218649016cc40e82bdd6d958e2277ff6d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b759b2218649016cc40e82bdd6d958e2277ff6d7", "html_url": "https://github.com/rust-lang/rust/commit/b759b2218649016cc40e82bdd6d958e2277ff6d7"}], "stats": {"total": 400, "additions": 372, "deletions": 28}, "files": [{"sha": "8e909aab7f0cabae9793bac4e96677253e5947df", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -39,6 +39,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]"}, {"sha": "90bdb46c4b075b0a82fcbd66184a75d7b1a9c89d", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -0,0 +1,303 @@\n+//! Thread parking without `futex` using the `pthread` synchronization primitives.\n+\n+#![cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    all(target_os = \"emscripten\", target_feature = \"atomics\")\n+)))]\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomPinned;\n+use crate::pin::Pin;\n+use crate::ptr::addr_of_mut;\n+use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::time::Duration;\n+\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n+unsafe fn lock(lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_mutex_lock(lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn unlock(lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_mutex_unlock(lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn notify_one(cond: *mut libc::pthread_cond_t) {\n+    let r = libc::pthread_cond_signal(cond);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn wait(cond: *mut libc::pthread_cond_t, lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_cond_wait(cond, lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n+\n+fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n+    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n+}\n+\n+// This implementation is used on systems that support pthread_condattr_setclock\n+// where we configure the condition variable to use the monotonic clock (instead of\n+// the default system clock). This approach avoids all problems that result\n+// from changes made to the system time.\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\")))]\n+unsafe fn wait_timeout(\n+    cond: *mut libc::pthread_cond_t,\n+    lock: *mut libc::pthread_mutex_t,\n+    dur: Duration,\n+) {\n+    use crate::mem;\n+\n+    let mut now: libc::timespec = mem::zeroed();\n+    let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n+    assert_eq!(r, 0);\n+    // Nanosecond calculations can't overflow because both values are below 1e9.\n+    let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n+    let sec = saturating_cast_to_time_t(dur.as_secs())\n+        .checked_add((nsec / 1_000_000_000) as libc::time_t)\n+        .and_then(|s| s.checked_add(now.tv_sec));\n+    let nsec = nsec % 1_000_000_000;\n+    let timeout =\n+        sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n+    let r = libc::pthread_cond_timedwait(cond, lock, &timeout);\n+    assert!(r == libc::ETIMEDOUT || r == 0);\n+}\n+\n+// This implementation is modeled after libcxx's condition_variable\n+// https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n+// https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\"))]\n+unsafe fn wait_timeout(\n+    cond: *mut libc::pthread_cond_t,\n+    lock: *mut libc::pthread_mutex_t,\n+    mut dur: Duration,\n+) {\n+    use crate::ptr;\n+\n+    // 1000 years\n+    let max_dur = Duration::from_secs(1000 * 365 * 86400);\n+\n+    if dur > max_dur {\n+        // OSX implementation of `pthread_cond_timedwait` is buggy\n+        // with super long durations. When duration is greater than\n+        // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+        // in macOS Sierra return error 316.\n+        //\n+        // This program demonstrates the issue:\n+        // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+        //\n+        // To work around this issue, and possible bugs of other OSes, timeout\n+        // is clamped to 1000 years, which is allowable per the API of `park_timeout`\n+        // because of spurious wakeups.\n+        dur = max_dur;\n+    }\n+\n+    let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n+    let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n+    debug_assert_eq!(r, 0);\n+    let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n+    let extra = (nsec / 1_000_000_000) as libc::time_t;\n+    let nsec = nsec % 1_000_000_000;\n+    let seconds = saturating_cast_to_time_t(dur.as_secs());\n+    let timeout = sys_now\n+        .tv_sec\n+        .checked_add(extra)\n+        .and_then(|s| s.checked_add(seconds))\n+        .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n+        .unwrap_or(TIMESPEC_MAX);\n+    // And wait!\n+    let r = libc::pthread_cond_timedwait(cond, lock, &timeout);\n+    debug_assert!(r == libc::ETIMEDOUT || r == 0);\n+}\n+\n+pub struct Parker {\n+    state: AtomicUsize,\n+    lock: UnsafeCell<libc::pthread_mutex_t>,\n+    cvar: UnsafeCell<libc::pthread_cond_t>,\n+    // The `pthread` primitives require a stable address, so make this struct `!Unpin`.\n+    _pinned: PhantomPinned,\n+}\n+\n+impl Parker {\n+    /// Construct the UNIX parker in-place.\n+    ///\n+    /// # Safety\n+    /// The constructed parker must never be moved.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        // Use the default mutex implementation to allow for simpler initialization.\n+        // This could lead to undefined behaviour when deadlocking. This is avoided\n+        // by not deadlocking. Note in particular the unlocking operation before any\n+        // panic, as code after the panic could try to park again.\n+        addr_of_mut!((*parker).state).write(AtomicUsize::new(EMPTY));\n+        addr_of_mut!((*parker).lock).write(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER));\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+                target_os = \"l4re\",\n+                target_os = \"android\",\n+                target_os = \"redox\"\n+            ))] {\n+                addr_of_mut!((*parker).cvar).write(UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER));\n+            } else if #[cfg(target_os = \"espidf\")] {\n+                let r = libc::pthread_cond_init(addr_of_mut!((*parker).cvar).cast(), crate::ptr::null());\n+                assert_eq!(r, 0);\n+            } else {\n+                use crate::mem::MaybeUninit;\n+                let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+                let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_cond_init(addr_of_mut!((*parker).cvar).cast(), attr.as_ptr());\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n+                assert_eq!(r, 0);\n+            }\n+        }\n+    }\n+\n+    // This implementation doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // If we were previously notified then we consume this notification and\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        // Otherwise we need to coordinate going to sleep\n+        lock(self.lock.get());\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read here, even though we know it will be `NOTIFIED`.\n+                // This is because `unpark` may have been called again since we read\n+                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+                // acquire operation that synchronizes with that `unpark` to observe\n+                // any writes it made before the call to unpark. To do that we must\n+                // read from the write it made to `state`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+\n+                unlock(self.lock.get());\n+\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => {\n+                unlock(self.lock.get());\n+\n+                panic!(\"inconsistent park state\")\n+            }\n+        }\n+\n+        loop {\n+            wait(self.cvar.get(), self.lock.get());\n+\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+                Ok(_) => break, // got a notification\n+                Err(_) => {}    // spurious wakeup, go back to sleep\n+            }\n+        }\n+\n+        unlock(self.lock.get());\n+    }\n+\n+    // This implementation doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker. Use\n+    // `Pin` to guarantee a stable address for the mutex and condition variable.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        // Like `park` above we have a fast path for an already-notified thread, and\n+        // afterwards we start coordinating for a sleep.\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        lock(self.lock.get());\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read again here, see `park`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                unlock(self.lock.get());\n+\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => {\n+                unlock(self.lock.get());\n+                panic!(\"inconsistent park_timeout state\")\n+            }\n+        }\n+\n+        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+        // from a notification we just want to unconditionally set the state back to\n+        // empty, either consuming a notification or un-flagging ourselves as\n+        // parked.\n+        wait_timeout(self.cvar.get(), self.lock.get(), dur);\n+\n+        match self.state.swap(EMPTY, SeqCst) {\n+            NOTIFIED => unlock(self.lock.get()), // got a notification, hurray!\n+            PARKED => unlock(self.lock.get()),   // no notification, alas\n+            n => {\n+                unlock(self.lock.get());\n+                panic!(\"inconsistent park_timeout state: {n}\")\n+            }\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return,    // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {}        // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n+        }\n+\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        unsafe {\n+            lock(self.lock.get());\n+            unlock(self.lock.get());\n+            notify_one(self.cvar.get());\n+        }\n+    }\n+}\n+\n+impl Drop for Parker {\n+    fn drop(&mut self) {\n+        unsafe {\n+            libc::pthread_cond_destroy(self.cvar.get_mut());\n+            libc::pthread_mutex_destroy(self.lock.get_mut());\n+        }\n+    }\n+}\n+\n+unsafe impl Sync for Parker {}\n+unsafe impl Send for Parker {}"}, {"sha": "5144834447503414a9ea832e1b9b930ff1d44dd9", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -58,6 +58,7 @@\n // [4]: Windows Internals, Part 1, ISBN 9780735671300\n \n use crate::convert::TryFrom;\n+use crate::pin::Pin;\n use crate::ptr;\n use crate::sync::atomic::{\n     AtomicI8, AtomicPtr,\n@@ -95,13 +96,16 @@ const NOTIFIED: i8 = 1;\n // Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n // Ordering::Acquire when reading this state in park() after waking up.\n impl Parker {\n-    pub fn new() -> Self {\n-        Self { state: AtomicI8::new(EMPTY) }\n+    /// Construct the Windows parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Self { state: AtomicI8::new(EMPTY) });\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park(&self) {\n+    // which means that `self.state != PARKED`. This implementation doesn't require `Pin`,\n+    // but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -132,8 +136,9 @@ impl Parker {\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+    // which means that `self.state != PARKED`. This implementation doesn't require `Pin`,\n+    // but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -184,7 +189,8 @@ impl Parker {\n         }\n     }\n \n-    pub fn unpark(&self) {\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n         // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n         // wake the thread in the first case.\n         //"}, {"sha": "d9e2f39e3451848bea88a071b3a293d24b82e517", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -1,3 +1,4 @@\n+use crate::pin::Pin;\n use crate::sync::atomic::AtomicU32;\n use crate::sync::atomic::Ordering::{Acquire, Release};\n use crate::sys::futex::{futex_wait, futex_wake};\n@@ -32,14 +33,15 @@ pub struct Parker {\n // Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n // Ordering::Acquire when checking for this state in park().\n impl Parker {\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Parker { state: AtomicU32::new(EMPTY) }\n+    /// Construct the futex parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Self { state: AtomicU32::new(EMPTY) });\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n     // which means that `self.state != PARKED`.\n-    pub unsafe fn park(&self) {\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -58,8 +60,9 @@ impl Parker {\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+    // which means that `self.state != PARKED`. This implementation doesn't\n+    // require `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -78,8 +81,9 @@ impl Parker {\n         }\n     }\n \n+    // This implementation doesn't require `Pin`, but other implementations do.\n     #[inline]\n-    pub fn unpark(&self) {\n+    pub fn unpark(self: Pin<&Self>) {\n         // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n         // wake the thread in the first case.\n         //"}, {"sha": "f3d8b34d3fd39279b20887f50081e2788b65f470", "filename": "library/std/src/sys_common/thread_parker/generic.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -1,5 +1,6 @@\n //! Parker implementation based on a Mutex and Condvar.\n \n+use crate::pin::Pin;\n use crate::sync::atomic::AtomicUsize;\n use crate::sync::atomic::Ordering::SeqCst;\n use crate::sync::{Condvar, Mutex};\n@@ -16,13 +17,18 @@ pub struct Parker {\n }\n \n impl Parker {\n-    pub fn new() -> Self {\n-        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n+    /// Construct the generic parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker {\n+            state: AtomicUsize::new(EMPTY),\n+            lock: Mutex::new(()),\n+            cvar: Condvar::new(),\n+        });\n     }\n \n-    // This implementation doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park(&self) {\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // If we were previously notified then we consume this notification and\n         // return quickly.\n         if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n@@ -55,9 +61,8 @@ impl Parker {\n         }\n     }\n \n-    // This implementation doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park_timeout(&self, dur: Duration) {\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n         // Like `park` above we have a fast path for an already-notified thread, and\n         // afterwards we start coordinating for a sleep.\n         // return quickly.\n@@ -88,7 +93,8 @@ impl Parker {\n         }\n     }\n \n-    pub fn unpark(&self) {\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n         // To ensure the unparked thread will observe any writes we made\n         // before this call, we must perform a release operation that `park`\n         // can synchronize with. To do that we must write `NOTIFIED` even if"}, {"sha": "ea0204cd357ba5605b5b253a89dd8945e43e743a", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -8,6 +8,8 @@ cfg_if::cfg_if! {\n         pub use futex::Parker;\n     } else if #[cfg(windows)] {\n         pub use crate::sys::thread_parker::Parker;\n+    } else if #[cfg(target_family = \"unix\")] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}, {"sha": "99da5f7a87e15eec196312e22f5baf5b1fc14751", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54daf496e2e957a9f69aa88bf6c42520a2dbfa02/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=54daf496e2e957a9f69aa88bf6c42520a2dbfa02", "patch": "@@ -163,6 +163,8 @@ use crate::num::NonZeroU64;\n use crate::num::NonZeroUsize;\n use crate::panic;\n use crate::panicking;\n+use crate::pin::Pin;\n+use crate::ptr::addr_of_mut;\n use crate::str;\n use crate::sync::Arc;\n use crate::sys::thread as imp;\n@@ -923,7 +925,7 @@ pub fn sleep(dur: Duration) {\n pub fn park() {\n     // SAFETY: park_timeout is called on the parker owned by this thread.\n     unsafe {\n-        current().inner.parker.park();\n+        current().inner.as_ref().parker().park();\n     }\n }\n \n@@ -987,7 +989,7 @@ pub fn park_timeout_ms(ms: u32) {\n pub fn park_timeout(dur: Duration) {\n     // SAFETY: park_timeout is called on the parker owned by this thread.\n     unsafe {\n-        current().inner.parker.park_timeout(dur);\n+        current().inner.as_ref().parker().park_timeout(dur);\n     }\n }\n \n@@ -1073,6 +1075,12 @@ struct Inner {\n     parker: Parker,\n }\n \n+impl Inner {\n+    fn parker(self: Pin<&Self>) -> Pin<&Parker> {\n+        unsafe { Pin::map_unchecked(self, |inner| &inner.parker) }\n+    }\n+}\n+\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n@@ -1094,14 +1102,28 @@ struct Inner {\n ///\n /// [`thread::current`]: current\n pub struct Thread {\n-    inner: Arc<Inner>,\n+    inner: Pin<Arc<Inner>>,\n }\n \n impl Thread {\n     // Used only internally to construct a thread object without spawning\n     // Panics if the name contains nuls.\n     pub(crate) fn new(name: Option<CString>) -> Thread {\n-        Thread { inner: Arc::new(Inner { name, id: ThreadId::new(), parker: Parker::new() }) }\n+        // We have to use `unsafe` here to constuct the `Parker` in-place,\n+        // which is required for the UNIX implementation.\n+        //\n+        // SAFETY: We pin the Arc immediately after creation, so its address never\n+        // changes.\n+        let inner = unsafe {\n+            let mut arc = Arc::<Inner>::new_uninit();\n+            let ptr = Arc::get_mut_unchecked(&mut arc).as_mut_ptr();\n+            addr_of_mut!((*ptr).name).write(name);\n+            addr_of_mut!((*ptr).id).write(ThreadId::new());\n+            Parker::new(addr_of_mut!((*ptr).parker));\n+            Pin::new_unchecked(arc.assume_init())\n+        };\n+\n+        Thread { inner }\n     }\n \n     /// Atomically makes the handle's token available if it is not already.\n@@ -1137,7 +1159,7 @@ impl Thread {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn unpark(&self) {\n-        self.inner.parker.unpark();\n+        self.inner.as_ref().parker().unpark();\n     }\n \n     /// Gets the thread's unique identifier."}]}