{"sha": "3322595e896e95c3e19ca33c854ad529f2ef3c19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMjI1OTVlODk2ZTk1YzNlMTljYTMzYzg1NGFkNTI5ZjJlZjNjMTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-02T05:32:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-10T14:52:46Z"}, "message": "Reason about nested free variables that appear in a function\nsignature.  In a nutshell, the idea is to (1) report an error if, for\na region pointer `'a T`, the lifetime `'a` is longer than any\nlifetimes that appear in `T` (in other words, if a borrowed pointer\noutlives any portion of its contents) and then (2) use this to assume\nthat in a function like `fn(self: &'a &'b T)`, the relationship `'a <=\n'b` holds. This is needed for #5656.  Fixes #5728.", "tree": {"sha": "f785d8bc645c7fa424ef1487e617e054415f883d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f785d8bc645c7fa424ef1487e617e054415f883d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3322595e896e95c3e19ca33c854ad529f2ef3c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3322595e896e95c3e19ca33c854ad529f2ef3c19", "html_url": "https://github.com/rust-lang/rust/commit/3322595e896e95c3e19ca33c854ad529f2ef3c19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3322595e896e95c3e19ca33c854ad529f2ef3c19/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5606fc0c90461db40faeca16d7bffd9e61c2be73", "url": "https://api.github.com/repos/rust-lang/rust/commits/5606fc0c90461db40faeca16d7bffd9e61c2be73", "html_url": "https://github.com/rust-lang/rust/commit/5606fc0c90461db40faeca16d7bffd9e61c2be73"}], "stats": {"total": 1378, "additions": 1029, "deletions": 349}, "files": [{"sha": "bd4832b6faf6c380c3e8cb83d2c43957fc184f4d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -116,6 +116,19 @@ totalord_impl!(i64)\n totalord_impl!(int)\n totalord_impl!(uint)\n \n+pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n+    a1: &A, b1: &B,\n+    a2: &A, b2: &B) -> Ordering\n+{\n+    //! Compares (a1, b1) against (a2, b2), where the a values are more significant.\n+\n+    match a1.cmp(a2) {\n+        Less => Less,\n+        Greater => Greater,\n+        Equal => b1.cmp(b2)\n+    }\n+}\n+\n /**\n * Trait for values that can be compared for a sort-order.\n *\n@@ -193,6 +206,14 @@ mod test {\n         assert_eq!(12.cmp(-5), Greater);\n     }\n \n+    #[test]\n+    fn test_cmp2() {\n+        assert_eq!(cmp2(1, 2, 3, 4), Less);\n+        assert_eq!(cmp2(3, 2, 3, 4), Less);\n+        assert_eq!(cmp2(5, 2, 3, 4), Greater);\n+        assert_eq!(cmp2(5, 5, 5, 4), Greater);\n+    }\n+\n     #[test]\n     fn test_int_totaleq() {\n         assert!(5.equals(&5));"}, {"sha": "8d15d6afbda10edd7050e15f5a948d03a640277d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -301,7 +301,11 @@ pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n \n /// Prepend a char to a string\n pub fn unshift_char(s: &mut ~str, ch: char) {\n-    *s = from_char(ch) + *s;\n+    // This could be more efficient.\n+    let mut new_str = ~\"\";\n+    new_str.push_char(ch);\n+    new_str.push_str(*s);\n+    *s = new_str;\n }\n \n /**"}, {"sha": "8234129e254741a9b16b69549c7e2310d716a214", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -161,7 +161,6 @@ impl<A:Ord> Ord for (A,) {\n     fn gt(&self, other: &(A,)) -> bool { other.lt(&(*self))  }\n }\n \n-\n #[cfg(notest)]\n impl<A:Eq,B:Eq> Eq for (A, B) {\n     #[inline(always)]"}, {"sha": "c1420822d06e554c306ee4dd82e52c30cca5213d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -239,7 +239,8 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         assert!(next(st) == '|');\n         let br = parse_bound_region(st);\n         assert!(next(st) == ']');\n-        ty::re_free(id, br)\n+        ty::re_free(ty::FreeRegion {scope_id: id,\n+                                    bound_region: br})\n       }\n       's' => {\n         let id = parse_int(st);"}, {"sha": "2e1dd8b6dad86a5095481e56a3b5447bcf093a97", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -146,12 +146,12 @@ fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n         w.write_char('b');\n         enc_bound_region(w, cx, br);\n       }\n-      ty::re_free(id, br) => {\n+      ty::re_free(ref fr) => {\n         w.write_char('f');\n         w.write_char('[');\n-        w.write_int(id);\n+        w.write_int(fr.scope_id);\n         w.write_char('|');\n-        enc_bound_region(w, cx, br);\n+        enc_bound_region(w, cx, fr.bound_region);\n         w.write_char(']');\n       }\n       ty::re_scope(nid) => {"}, {"sha": "b25b975830bd58e4c7770ba5fd87a9cc022a3f8d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -475,9 +475,12 @@ impl tr for ty::Region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n         match *self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n-            ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n             ty::re_static | ty::re_infer(*) => *self,\n+            ty::re_free(ref fr) => {\n+                ty::re_free(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n+                                            bound_region: fr.bound_region.tr(xcx)})\n+            }\n         }\n     }\n }"}, {"sha": "721bb99626249a02599d5a3c3ae7d3f6cb1d7e15", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -128,9 +128,9 @@ pub impl CheckLoanCtxt {\n               Some(e) => return Some(pc_cmt(*e))\n             }\n \n-            match self.tcx().region_map.find(&scope_id) {\n+            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n               None => return default_purity,\n-              Some(&next_scope_id) => scope_id = next_scope_id\n+              Some(next_scope_id) => scope_id = next_scope_id\n             }\n         }\n     }\n@@ -146,9 +146,9 @@ pub impl CheckLoanCtxt {\n                 }\n             }\n \n-            match self.tcx().region_map.find(&scope_id) {\n+            match self.tcx().region_maps.opt_encl_scope(scope_id) {\n               None => return,\n-              Some(&next_scope_id) => scope_id = next_scope_id,\n+              Some(next_scope_id) => scope_id = next_scope_id,\n             }\n         }\n     }\n@@ -270,7 +270,7 @@ pub impl CheckLoanCtxt {\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n \n-        let par_scope_id = *self.tcx().region_map.get(&scope_id);\n+        let par_scope_id = self.tcx().region_maps.encl_scope(scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n             debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n "}, {"sha": "4e61b5738912f380598ac61b7148e5dfff71b302", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -242,7 +242,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // (if used like `a.b(...)`), the call where it's an argument\n         // (if used like `x(a.b)`), or the block (if used like `let x\n         // = a.b`).\n-        let scope_r = ty::re_scope(*self.tcx().region_map.get(&ex.id));\n+        let scope_r = self.tcx().region_maps.encl_region(ex.id);\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n         visit::visit_expr(ex, self, vt);\n@@ -524,7 +524,10 @@ pub impl GatherLoanCtxt {\n         // immutable structures, this is just the converse I suppose)\n \n         let scope_id = match scope_r {\n-            ty::re_scope(scope_id) | ty::re_free(scope_id, _) => scope_id,\n+            ty::re_scope(scope_id) |\n+            ty::re_free(ty::FreeRegion {scope_id, _}) => {\n+                scope_id\n+            }\n             _ => {\n                 self.bccx.tcx.sess.span_bug(\n                     cmt.span,"}, {"sha": "a38cd015654b526a3784eb3faefd0be7a28b833e", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -130,8 +130,8 @@ pub impl LoanContext {\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n               // FIXME(#4903)\n-            let local_scope_id = *self.bccx.tcx.region_map.get(&local_id);\n-            self.issue_loan(cmt, ty::re_scope(local_scope_id), loan_kind,\n+            let local_region = self.bccx.tcx.region_maps.encl_region(local_id);\n+            self.issue_loan(cmt, local_region, loan_kind,\n                             owns_lent_data)\n           }\n           cat_stack_upvar(cmt) => {"}, {"sha": "01fea2a960d4b1c617154fc96145efdf35d49e89", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -227,7 +227,6 @@ Borrowck results in two maps.\n use core::prelude::*;\n \n use middle::mem_categorization::*;\n-use middle::region;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n@@ -458,7 +457,7 @@ pub fn root_map() -> root_map {\n \n pub impl BorrowckCtxt {\n     fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n-        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+        self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n     fn cat_expr(&self, expr: @ast::expr) -> cmt {"}, {"sha": "40a59e2f89f26898965cb0bb54adc6a144837032", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -108,7 +108,7 @@ pub impl<'self> PreserveCtxt<'self> {\n                 // Maybe if we pass in the parent instead here,\n                 // we can prevent the \"scope not found\" error\n                 debug!(\"scope_region thing: %? \", cmt.id);\n-                ty::re_scope(*self.tcx().region_map.get(&cmt.id))\n+                self.tcx().region_maps.encl_region(cmt.id)\n             };\n \n             self.compare_scope(cmt, scope_region)\n@@ -128,27 +128,27 @@ pub impl<'self> PreserveCtxt<'self> {\n                     cmt.span,\n                     ~\"preserve() called with local and !root_managed_data\");\n             }\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n             // deref of a region ptr.\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_self(local_id) => {\n-            let local_scope_id = *self.tcx().region_map.get(&local_id);\n-            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n+            let local_region = self.tcx().region_maps.encl_region(local_id);\n+            self.compare_scope(cmt, local_region)\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |"}, {"sha": "6898dcca45dd8a629a387ee03f119dbd236b4d12", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -596,8 +596,11 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                                                              class_id);\n                             }\n                             _ => {\n-                                cx.tcx.sess.span_bug(pat_span,\n-                                ~\"struct pattern didn't resolve to a struct\");\n+                                cx.tcx.sess.span_bug(\n+                                    pat_span,\n+                                    fmt!(\"struct pattern resolved to %s, \\\n+                                          not a struct\",\n+                                         ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n                         let args = vec::map(class_fields, |class_field| {"}, {"sha": "1f8401c0d533ee082507b77d7973c237c12be298", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -478,13 +478,13 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n     }\n }\n \n-/// This is rather subtle.  When we are casting a value to a\n-/// instantiated trait like `a as trait<'r>`, regionck already ensures\n-/// that any borrowed pointers that appear in the type of `a` are\n-/// bounded by `&r`.  However, it is possible that there are *type\n-/// parameters* in the type of `a`, and those *type parameters* may\n-/// have borrowed pointers within them.  We have to guarantee that the\n-/// regions which appear in those type parameters are not obscured.\n+/// This is rather subtle.  When we are casting a value to a instantiated\n+/// trait like `a as trait<'r>`, regionck already ensures that any borrowed\n+/// pointers that appear in the type of `a` are bounded by `'r` (ed.: modulo\n+/// FIXME(#5723)).  However, it is possible that there are *type parameters*\n+/// in the type of `a`, and those *type parameters* may have borrowed pointers\n+/// within them.  We have to guarantee that the regions which appear in those\n+/// type parameters are not obscured.\n ///\n /// Therefore, we ensure that one of three conditions holds:\n ///\n@@ -501,6 +501,8 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n ///\n /// (3) The type parameter is owned (and therefore does not contain\n /// borrowed ptrs).\n+///\n+/// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: Context,\n     source: @expr,\n@@ -509,40 +511,78 @@ pub fn check_cast_for_escaping_regions(\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n-    let target_substs = match ty::get(target_ty).sty {\n-      ty::ty_trait(_, ref substs, _) => {(/*bad*/copy *substs)}\n-      _ => { return; /* not a cast to a trait */ }\n-    };\n+    match ty::get(target_ty).sty {\n+        ty::ty_trait(*) => {}\n+        _ => { return; }\n+    }\n+\n+    // Collect up the regions that appear in the target type.  We want to\n+    // ensure that these lifetimes are shorter than all lifetimes that are in\n+    // the source type.  See test `src/test/compile-fail/regions-trait-2.rs`\n+    let mut target_regions = ~[];\n+    ty::walk_regions_and_ty(\n+        cx.tcx,\n+        target_ty,\n+        |r| {\n+            if !r.is_bound() {\n+                target_regions.push(r);\n+            }\n+        },\n+        |_| true);\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n-    // must have been declared on the enclosing fn item):\n-    match target_substs.self_r {\n-      Some(ty::re_scope(*)) => { return; /* case (1) */ }\n-      None | Some(ty::re_static) | Some(ty::re_free(*)) => {}\n-      Some(ty::re_bound(*)) | Some(ty::re_infer(*)) => {\n-        cx.tcx.sess.span_bug(\n-            source.span,\n-            fmt!(\"bad region found in kind: %?\", target_substs.self_r));\n-      }\n+    // must have been declared on the enclosing fn item).\n+    if target_regions.any(|r| is_re_scope(*r)) {\n+        return; /* case (1) */\n     }\n \n     // Assuming the trait instance can escape, then ensure that each parameter\n-    // either appears in the trait type or is owned:\n+    // either appears in the trait type or is owned.\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n-    do ty::walk_ty(source_ty) |ty| {\n-        match ty::get(ty).sty {\n-          ty::ty_param(source_param) => {\n-            if target_params.contains(&source_param) {\n-                /* case (2) */\n-            } else {\n-                check_durable(cx.tcx, ty, source.span); /* case (3) */\n+    ty::walk_regions_and_ty(\n+        cx.tcx,\n+        source_ty,\n+\n+        |_r| {\n+            // FIXME(#5723) --- turn this check on once &Objects are usable\n+            //\n+            // if !target_regions.any(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            //     cx.tcx.sess.span_err(\n+            //         source.span,\n+            //         fmt!(\"source contains borrowed pointer with lifetime \\\n+            //               not found in the target type `%s`\",\n+            //              ty_to_str(cx.tcx, target_ty)));\n+            //     note_and_explain_region(\n+            //         cx.tcx, \"source data is only valid for \", r, \"\");\n+            // }\n+        },\n+\n+        |ty| {\n+            match ty::get(ty).sty {\n+                ty::ty_param(source_param) => {\n+                    if target_params.contains(&source_param) {\n+                        /* case (2) */\n+                    } else {\n+                        check_durable(cx.tcx, ty, source.span); /* case (3) */\n+                    }\n+                }\n+                _ => {}\n             }\n-          }\n-          _ => {}\n+            true\n+        });\n+\n+    fn is_re_scope(+r: ty::Region) -> bool {\n+        match r {\n+            ty::re_scope(*) => true,\n+            _ => false\n         }\n     }\n+\n+    fn is_subregion_of(cx: Context, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+        cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n+    }\n }\n \n /// Ensures that values placed into a ~Trait are copyable and sendable."}, {"sha": "79130097078689d9eae503bc94ff51fd611b179f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 220, "deletions": 88, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -11,7 +11,7 @@\n /*!\n \n This file actually contains two passes related to regions.  The first\n-pass builds up the `region_map`, which describes the parent links in\n+pass builds up the `scope_map`, which describes the parent links in\n the region hierarchy.  The second pass infers which types must be\n region parameterized.\n \n@@ -23,7 +23,7 @@ use driver::session::Session;\n use metadata::csearch;\n use middle::resolve;\n use middle::ty::{region_variance, rv_covariant, rv_invariant};\n-use middle::ty::{rv_contravariant};\n+use middle::ty::{rv_contravariant, FreeRegion};\n use middle::ty;\n \n use core::hashmap::{HashMap, HashSet};\n@@ -37,23 +37,31 @@ use syntax::{ast, visit};\n pub type parent = Option<ast::node_id>;\n \n /**\n-Encodes the bounding lifetime for a given AST node:\n-\n-- Expressions are mapped to the expression or block encoding the maximum\n-  (static) lifetime of a value produced by that expression.  This is\n-  generally the innermost call, statement, match, or block.\n-\n-- Variables and bindings are mapped to the block in which they are declared.\n-\n+The region maps encode information about region relationships.\n+\n+- `scope_map` maps from:\n+  - an expression to the expression or block encoding the maximum\n+    (static) lifetime of a value produced by that expression.  This is\n+    generally the innermost call, statement, match, or block.\n+  - a variable or binding id to the block in which that variable is declared.\n+- `free_region_map` maps from:\n+  - a free region `a` to a list of free regions `bs` such that\n+    `a <= b for all b in bs`\n+  - the free region map is populated during type check as we check\n+    each function. See the function `relate_free_regions` for\n+    more information.\n */\n-pub type region_map = @mut HashMap<ast::node_id, ast::node_id>;\n+pub struct RegionMaps {\n+    priv scope_map: HashMap<ast::node_id, ast::node_id>,\n+    priv free_region_map: HashMap<FreeRegion, ~[FreeRegion]>,\n+}\n \n pub struct ctxt {\n     sess: Session,\n     def_map: resolve::DefMap,\n \n     // Generated maps:\n-    region_map: region_map,\n+    region_maps: @mut RegionMaps,\n \n     // Generally speaking, expressions are parented to their innermost\n     // enclosing block. But some kinds of expressions serve as\n@@ -98,94 +106,215 @@ pub struct ctxt {\n     parent: parent,\n }\n \n-/// Returns true if `subscope` is equal to or is lexically nested inside\n-/// `superscope` and false otherwise.\n-pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n-                      subscope: ast::node_id) -> bool {\n-    let mut subscope = subscope;\n-    while superscope != subscope {\n-        match region_map.find(&subscope) {\n-            None => return false,\n-            Some(&scope) => subscope = scope\n+pub impl RegionMaps {\n+    fn relate_free_regions(&mut self,\n+                           sub: FreeRegion,\n+                           sup: FreeRegion)\n+    {\n+        match self.free_region_map.find_mut(&sub) {\n+            Some(sups) => {\n+                if !sups.contains(&sup) {\n+                    sups.push(sup);\n+                }\n+                return;\n+            }\n+            None => {}\n         }\n+\n+        debug!(\"relate_free_regions(sub=%?, sup=%?)\", sub, sup);\n+\n+        self.free_region_map.insert(sub, ~[sup]);\n     }\n-    return true;\n-}\n \n-/// Determines whether one region is a subregion of another.  This is\n-/// intended to run *after inference* and sadly the logic is somewhat\n-/// duplicated with the code in infer.rs.\n-pub fn is_subregion_of(region_map: region_map,\n-                       sub_region: ty::Region,\n-                       super_region: ty::Region) -> bool {\n-    sub_region == super_region ||\n-        match (sub_region, super_region) {\n-            (_, ty::re_static) => {\n-                true\n-            }\n+    fn record_parent(&mut self,\n+                     sub: ast::node_id,\n+                     sup: ast::node_id)\n+    {\n+        debug!(\"record_parent(sub=%?, sup=%?)\", sub, sup);\n \n-            (ty::re_scope(sub_scope), ty::re_scope(super_scope)) |\n-            (ty::re_scope(sub_scope), ty::re_free(super_scope, _)) => {\n-                scope_contains(region_map, super_scope, sub_scope)\n-            }\n+        self.scope_map.insert(sub, sup);\n+    }\n \n-            _ => {\n-                false\n+    fn opt_encl_scope(&self,\n+                      id: ast::node_id) -> Option<ast::node_id>\n+    {\n+        //! Returns the narrowest scope that encloses `id`, if any.\n+\n+        self.scope_map.find(&id).map(|&x| *x)\n+    }\n+\n+    fn encl_scope(&self,\n+                  id: ast::node_id) -> ast::node_id\n+    {\n+        //! Returns the narrowest scope that encloses `id`, if any.\n+\n+        match self.scope_map.find(&id) {\n+            Some(&r) => r,\n+            None => { fail!(fmt!(\"No enclosing scope for id %?\", id)); }\n+        }\n+    }\n+\n+    fn encl_region(&self,\n+                   id: ast::node_id) -> ty::Region\n+    {\n+        //! Returns the narrowest scope region that encloses `id`, if any.\n+\n+        ty::re_scope(self.encl_scope(id))\n+    }\n+\n+    fn is_sub_scope(&self,\n+                    sub_scope: ast::node_id,\n+                    superscope: ast::node_id) -> bool\n+    {\n+        /*!\n+         * Returns true if `sub_scope` is equal to or is lexically\n+         * nested inside `superscope` and false otherwise.\n+         */\n+\n+        let mut sub_scope = sub_scope;\n+        while superscope != sub_scope {\n+            match self.scope_map.find(&sub_scope) {\n+                None => return false,\n+                Some(&scope) => sub_scope = scope\n             }\n         }\n-}\n+        return true;\n+    }\n \n-/// Finds the nearest common ancestor (if any) of two scopes.  That\n-/// is, finds the smallest scope which is greater than or equal to\n-/// both `scope_a` and `scope_b`.\n-pub fn nearest_common_ancestor(region_map: region_map,\n-                               scope_a: ast::node_id,\n-                               scope_b: ast::node_id)\n-                            -> Option<ast::node_id> {\n+    fn sub_free_region(&self,\n+                       sub: FreeRegion,\n+                       sup: FreeRegion) -> bool\n+    {\n+        /*!\n+         * Determines whether two free regions have a subregion relationship\n+         * by walking the graph encoded in `free_region_map`.  Note that\n+         * it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n+         * (that is, the user can give two different names to the same lifetime).\n+         */\n+\n+        if sub == sup {\n+            return true;\n+        }\n \n-    fn ancestors_of(region_map: region_map, scope: ast::node_id)\n-                    -> ~[ast::node_id] {\n-        let mut result = ~[scope];\n-        let mut scope = scope;\n-        loop {\n-            match region_map.find(&scope) {\n-                None => return result,\n-                Some(&superscope) => {\n-                    result.push(superscope);\n-                    scope = superscope;\n+        // Do a little breadth-first-search here.  The `queue` list\n+        // doubles as a way to detect if we've seen a particular FR\n+        // before.  Note that we expect this graph to be an *extremely\n+        // shallow* tree.\n+        let mut queue = ~[sub];\n+        let mut i = 0;\n+        while i < queue.len() {\n+            match self.free_region_map.find(&queue[i]) {\n+                Some(parents) => {\n+                    for parents.each |parent| {\n+                        if *parent == sup {\n+                            return true;\n+                        }\n+\n+                        if !queue.contains(parent) {\n+                            queue.push(*parent);\n+                        }\n+                    }\n                 }\n+                None => {}\n             }\n+            i += 1;\n         }\n+        return false;\n     }\n \n-    if scope_a == scope_b { return Some(scope_a); }\n+    fn is_subregion_of(&self,\n+                       sub_region: ty::Region,\n+                       super_region: ty::Region) -> bool\n+    {\n+        /*!\n+         * Determines whether one region is a subregion of another.  This is\n+         * intended to run *after inference* and sadly the logic is somewhat\n+         * duplicated with the code in infer.rs.\n+         */\n+\n+        debug!(\"is_subregion_of(sub_region=%?, super_region=%?)\",\n+               sub_region, super_region);\n+\n+        sub_region == super_region || {\n+            match (sub_region, super_region) {\n+                (_, ty::re_static) => {\n+                    true\n+                }\n \n-    let a_ancestors = ancestors_of(region_map, scope_a);\n-    let b_ancestors = ancestors_of(region_map, scope_b);\n-    let mut a_index = vec::len(a_ancestors) - 1u;\n-    let mut b_index = vec::len(b_ancestors) - 1u;\n+                (ty::re_scope(sub_scope), ty::re_scope(super_scope)) => {\n+                    self.is_sub_scope(sub_scope, super_scope)\n+                }\n \n-    // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n-    // The end of each vector will be the item where the scope is\n-    // defined; if there are any common ancestors, then the tails of\n-    // the vector will be the same.  So basically we want to walk\n-    // backwards from the tail of each vector and find the first point\n-    // where they diverge.  If one vector is a suffix of the other,\n-    // then the corresponding scope is a superscope of the other.\n+                (ty::re_scope(sub_scope), ty::re_free(ref fr)) => {\n+                    self.is_sub_scope(sub_scope, fr.scope_id)\n+                }\n \n-    if a_ancestors[a_index] != b_ancestors[b_index] {\n-        return None;\n+                (ty::re_free(sub_fr), ty::re_free(super_fr)) => {\n+                    self.sub_free_region(sub_fr, super_fr)\n+                }\n+\n+                _ => {\n+                    false\n+                }\n+            }\n+        }\n     }\n \n-    loop {\n-        // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n-        // for all indices between a_index and the end of the array\n-        if a_index == 0u { return Some(scope_a); }\n-        if b_index == 0u { return Some(scope_b); }\n-        a_index -= 1u;\n-        b_index -= 1u;\n+    fn nearest_common_ancestor(&self,\n+                               scope_a: ast::node_id,\n+                               scope_b: ast::node_id) -> Option<ast::node_id>\n+    {\n+        /*!\n+         * Finds the nearest common ancestor (if any) of two scopes.  That\n+         * is, finds the smallest scope which is greater than or equal to\n+         * both `scope_a` and `scope_b`.\n+         */\n+\n+        if scope_a == scope_b { return Some(scope_a); }\n+\n+        let a_ancestors = ancestors_of(self, scope_a);\n+        let b_ancestors = ancestors_of(self, scope_b);\n+        let mut a_index = vec::len(a_ancestors) - 1u;\n+        let mut b_index = vec::len(b_ancestors) - 1u;\n+\n+        // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n+        // The end of each vector will be the item where the scope is\n+        // defined; if there are any common ancestors, then the tails of\n+        // the vector will be the same.  So basically we want to walk\n+        // backwards from the tail of each vector and find the first point\n+        // where they diverge.  If one vector is a suffix of the other,\n+        // then the corresponding scope is a superscope of the other.\n+\n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            return Some(a_ancestors[a_index + 1u]);\n+            return None;\n+        }\n+\n+        loop {\n+            // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n+            // for all indices between a_index and the end of the array\n+            if a_index == 0u { return Some(scope_a); }\n+            if b_index == 0u { return Some(scope_b); }\n+            a_index -= 1u;\n+            b_index -= 1u;\n+            if a_ancestors[a_index] != b_ancestors[b_index] {\n+                return Some(a_ancestors[a_index + 1u]);\n+            }\n+        }\n+\n+        fn ancestors_of(self: &RegionMaps, scope: ast::node_id)\n+            -> ~[ast::node_id]\n+        {\n+            let mut result = ~[scope];\n+            let mut scope = scope;\n+            loop {\n+                match self.scope_map.find(&scope) {\n+                    None => return result,\n+                    Some(&superscope) => {\n+                        result.push(superscope);\n+                        scope = superscope;\n+                    }\n+                }\n+            }\n         }\n     }\n }\n@@ -205,8 +334,7 @@ pub fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n /// Records the current parent (if any) as the parent of `child_id`.\n pub fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     for cx.parent.each |parent_id| {\n-        debug!(\"parent of node %d is node %d\", child_id, *parent_id);\n-        cx.region_map.insert(child_id, *parent_id);\n+        cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n@@ -328,7 +456,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n     // Record the ID of `self`.\n     match *fk {\n         visit::fk_method(_, _, method) => {\n-            cx.region_map.insert(method.self_id, body.node.id);\n+            cx.region_maps.record_parent(method.self_id, body.node.id);\n         }\n         _ => {}\n     }\n@@ -338,19 +466,23 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n            body.node.id, cx.parent, fn_cx.parent);\n \n     for decl.inputs.each |input| {\n-        cx.region_map.insert(input.id, body.node.id);\n+        cx.region_maps.record_parent(input.id, body.node.id);\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n }\n \n pub fn resolve_crate(sess: Session,\n                      def_map: resolve::DefMap,\n-                     crate: @ast::crate)\n-                  -> region_map {\n+                     crate: @ast::crate) -> @mut RegionMaps\n+{\n+    let region_maps = @mut RegionMaps {\n+        scope_map: HashMap::new(),\n+        free_region_map: HashMap::new()\n+    };\n     let cx: ctxt = ctxt {sess: sess,\n                          def_map: def_map,\n-                         region_map: @mut HashMap::new(),\n+                         region_maps: region_maps,\n                          root_exprs: @mut HashSet::new(),\n                          parent: None};\n     let visitor = visit::mk_vt(@visit::Visitor {\n@@ -365,7 +497,7 @@ pub fn resolve_crate(sess: Session,\n         .. *visit::default_visitor()\n     });\n     visit::visit_crate(*crate, cx, visitor);\n-    return cx.region_map;\n+    return region_maps;\n }\n \n // ___________________________________________________________________________"}, {"sha": "3921764e6afa81b4b2032aedc37a32dba539bf30", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 83, "deletions": 57, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -240,7 +240,7 @@ struct ctxt_ {\n     sess: session::Session,\n     def_map: resolve::DefMap,\n \n-    region_map: middle::region::region_map,\n+    region_maps: @mut middle::region::RegionMaps,\n     region_paramd_items: middle::region::region_paramd_items,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n@@ -410,7 +410,7 @@ pub struct param_ty {\n /// Representation of regions:\n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -426,7 +426,7 @@ pub enum Region {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    re_free(node_id, bound_region),\n+    re_free(FreeRegion),\n \n     /// A concrete region naming some expression within the current function.\n     re_scope(node_id),\n@@ -438,9 +438,26 @@ pub enum Region {\n     re_infer(InferRegion)\n }\n \n+pub impl Region {\n+    fn is_bound(&self) -> bool {\n+        match self {\n+            &re_bound(*) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n #[auto_encode]\n #[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n+pub struct FreeRegion {\n+    scope_id: node_id,\n+    bound_region: bound_region\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving(Eq, IterBytes)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -810,7 +827,7 @@ pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n-               region_map: middle::region::region_map,\n+               region_maps: @mut middle::region::RegionMaps,\n                region_paramd_items: middle::region::region_paramd_items,\n                +lang_items: middle::lang_items::LanguageItems,\n                crate: @ast::crate)\n@@ -837,7 +854,7 @@ pub fn mk_ctxt(s: session::Session,\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n-        region_map: region_map,\n+        region_maps: region_maps,\n         region_paramd_items: region_paramd_items,\n         node_types: @mut SmallIntMap::new(),\n         node_type_substs: @mut HashMap::new(),\n@@ -1176,15 +1193,6 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n     }\n }\n \n-// Returns the narrowest lifetime enclosing the evaluation of the expression\n-// with id `id`.\n-pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n-    match cx.region_map.find(&id) {\n-      Some(&encl_scope) => ty::re_scope(encl_scope),\n-      None => ty::re_static\n-    }\n-}\n-\n pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1308,8 +1316,8 @@ pub fn walk_regions_and_ty(\n         fold_regions_and_ty(\n             cx, ty,\n             |r| { walkr(r); r },\n-            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t },\n-            |t| { walkt(t); walk_regions_and_ty(cx, t, walkr, walkt); t });\n+            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t },\n+            |t| { walk_regions_and_ty(cx, t, walkr, walkt); t });\n     }\n }\n \n@@ -2506,43 +2514,52 @@ pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     }\n }\n \n-impl to_bytes::IterBytes for bound_region {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          ty::br_self => 0u8.iter_bytes(lsb0, f),\n-\n-          ty::br_anon(ref idx) =>\n-          to_bytes::iter_bytes_2(&1u8, idx, lsb0, f),\n-\n-          ty::br_named(ref ident) =>\n-          to_bytes::iter_bytes_2(&2u8, ident, lsb0, f),\n+/**\n+ * Enforces an arbitrary but consistent total ordering over\n+ * free regions.  This is needed for establishing a consistent\n+ * LUB in region_inference. */\n+impl cmp::TotalOrd for FreeRegion {\n+    fn cmp(&self, other: &FreeRegion) -> Ordering {\n+        cmp::cmp2(&self.scope_id, &self.bound_region,\n+                  &other.scope_id, &other.bound_region)\n+    }\n+}\n \n-          ty::br_cap_avoid(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&3u8, id, br, lsb0, f),\n+impl cmp::TotalEq for FreeRegion {\n+    fn equals(&self, other: &FreeRegion) -> bool {\n+        *self == *other\n+    }\n+}\n \n-          ty::br_fresh(ref x) =>\n-          to_bytes::iter_bytes_2(&4u8, x, lsb0, f)\n+/**\n+ * Enforces an arbitrary but consistent total ordering over\n+ * bound regions.  This is needed for establishing a consistent\n+ * LUB in region_inference. */\n+impl cmp::TotalOrd for bound_region {\n+    fn cmp(&self, other: &bound_region) -> Ordering {\n+        match (self, other) {\n+            (&ty::br_self, &ty::br_self) => cmp::Equal,\n+            (&ty::br_self, _) => cmp::Less,\n+\n+            (&ty::br_anon(ref a1), &ty::br_anon(ref a2)) => a1.cmp(a2),\n+            (&ty::br_anon(*), _) => cmp::Less,\n+\n+            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.repr.cmp(&a2.repr),\n+            (&ty::br_named(*), _) => cmp::Less,\n+\n+            (&ty::br_cap_avoid(ref a1, @ref b1),\n+             &ty::br_cap_avoid(ref a2, @ref b2)) => cmp::cmp2(a1, b1, a2, b2),\n+            (&ty::br_cap_avoid(*), _) => cmp::Less,\n+\n+            (&ty::br_fresh(ref a1), &ty::br_fresh(ref a2)) => a1.cmp(a2),\n+            (&ty::br_fresh(*), _) => cmp::Less,\n         }\n     }\n }\n \n-impl to_bytes::IterBytes for Region {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        match *self {\n-          re_bound(ref br) =>\n-          to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n-\n-          re_free(ref id, ref br) =>\n-          to_bytes::iter_bytes_3(&1u8, id, br, lsb0, f),\n-\n-          re_scope(ref id) =>\n-          to_bytes::iter_bytes_2(&2u8, id, lsb0, f),\n-\n-          re_infer(ref id) =>\n-          to_bytes::iter_bytes_2(&3u8, id, lsb0, f),\n-\n-          re_static => 4u8.iter_bytes(lsb0, f)\n-        }\n+impl cmp::TotalEq for bound_region {\n+    fn equals(&self, other: &bound_region) -> bool {\n+        *self == *other\n     }\n }\n \n@@ -2856,8 +2873,17 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n      */\n \n     let unadjusted_ty = expr_ty(cx, expr);\n+    adjust_ty(cx, expr.span, unadjusted_ty, cx.adjustments.find(&expr.id))\n+}\n+\n+pub fn adjust_ty(cx: ctxt,\n+                 span: span,\n+                 unadjusted_ty: ty::t,\n+                 adjustment: Option<&@AutoAdjustment>) -> ty::t\n+{\n+    /*! See `expr_ty_adjusted` */\n \n-    return match cx.adjustments.find(&expr.id) {\n+    return match adjustment {\n         None => unadjusted_ty,\n \n         Some(&@AutoAddEnv(r, s)) => {\n@@ -2886,7 +2912,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n                     Some(mt) => { adjusted_ty = mt.ty; }\n                     None => {\n                         cx.sess.span_bug(\n-                            expr.span,\n+                            span,\n                             fmt!(\"The %uth autoderef failed: %s\",\n                                  i, ty_to_str(cx,\n                                               adjusted_ty)));\n@@ -2905,26 +2931,26 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n                         }\n \n                         AutoBorrowVec => {\n-                            borrow_vec(cx, expr, autoref, adjusted_ty)\n+                            borrow_vec(cx, span, autoref, adjusted_ty)\n                         }\n \n                         AutoBorrowVecRef => {\n-                            adjusted_ty = borrow_vec(cx, expr, autoref,\n+                            adjusted_ty = borrow_vec(cx, span, autoref,\n                                                      adjusted_ty);\n                             mk_rptr(cx, autoref.region,\n                                     mt {ty: adjusted_ty, mutbl: ast::m_imm})\n                         }\n \n                         AutoBorrowFn => {\n-                            borrow_fn(cx, expr, autoref, adjusted_ty)\n+                            borrow_fn(cx, span, autoref, adjusted_ty)\n                         }\n                     }\n                 }\n             }\n         }\n     };\n \n-    fn borrow_vec(cx: ctxt, expr: @ast::expr,\n+    fn borrow_vec(cx: ctxt, span: span,\n                   autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_evec(mt, _) => {\n@@ -2938,14 +2964,14 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n             ref s => {\n                 cx.sess.span_bug(\n-                    expr.span,\n+                    span,\n                     fmt!(\"borrow-vec associated with bad sty: %?\",\n                          s));\n             }\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, expr: @ast::expr,\n+    fn borrow_fn(cx: ctxt, span: span,\n                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n@@ -2958,7 +2984,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n             ref s => {\n                 cx.sess.span_bug(\n-                    expr.span,\n+                    span,\n                     fmt!(\"borrow-fn associated with bad sty: %?\",\n                          s));\n             }"}, {"sha": "6bc1317d5f91cb2456fb69c44d227c528ec88058", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -95,6 +95,7 @@ use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{CheckTraitsOnly, DontAutoderefReceiver};\n use middle::typeck::check::method::{TransformTypeNormally};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n@@ -308,10 +309,14 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // the node_id of the body block.\n \n     let (isr, self_info, fn_sig) = {\n-        replace_bound_regions_in_fn_sig(tcx, inherited_isr, self_info, fn_sig,\n-                                        |br| ty::re_free(body.node.id, br))\n+        replace_bound_regions_in_fn_sig(\n+            tcx, inherited_isr, self_info, fn_sig,\n+            |br| ty::re_free(ty::FreeRegion {scope_id: body.node.id,\n+                                             bound_region: br}))\n     };\n \n+    relate_free_regions(tcx, self_info.map(|s| s.self_ty), &fn_sig);\n+\n     let arg_tys = fn_sig.inputs.map(|a| a.ty);\n     let ret_ty = fn_sig.output;\n \n@@ -2841,8 +2846,7 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         _ => {}\n     }\n \n-    let region =\n-        ty::re_scope(*tcx.region_map.get(&local.node.id));\n+    let region = tcx.region_maps.encl_region(local.node.id);\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),"}, {"sha": "5594f2a0f658b0e15eb77658ac66a55c5283114e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 234, "deletions": 71, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -31,13 +31,15 @@ use core::prelude::*;\n \n use middle::freevars::get_freevars;\n use middle::pat_util::pat_bindings;\n-use middle::ty::{encl_region, re_scope};\n+use middle::ty::{re_scope};\n use middle::ty;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::lookup_def;\n+use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n-use util::ppaux::{note_and_explain_region, ty_to_str};\n+use util::ppaux::{note_and_explain_region, ty_to_str,\n+                  region_to_str};\n \n use core::result;\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n@@ -53,12 +55,13 @@ pub struct Rcx {\n \n pub type rvt = visit::vt<@mut Rcx>;\n \n-pub fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n+fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _, _) |\n-        def_self(node_id, _) | def_binding(node_id, _) =>\n-            return encl_region(tcx, node_id),\n+        def_self(node_id, _) | def_binding(node_id, _) => {\n+            tcx.region_maps.encl_region(node_id)\n+        }\n         def_upvar(_, subdef, closure_id, body_id) => {\n             match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n                 BorrowedSigil => encl_region_of_def(fcx, *subdef),\n@@ -113,6 +116,24 @@ pub impl Rcx {\n     fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n+\n+    /// Try to resolve the type for the given node.\n+    fn resolve_expr_type_adjusted(@mut self, expr: @ast::expr) -> ty::t {\n+        let ty_unadjusted = self.resolve_node_type(expr.id);\n+        if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n+            ty_unadjusted\n+        } else {\n+            let tcx = self.fcx.tcx();\n+            let adjustments = self.fcx.inh.adjustments;\n+            match adjustments.find(&expr.id) {\n+                None => ty_unadjusted,\n+                Some(&adjustment) => {\n+                    // FIXME(#3850) --- avoid region scoping errors\n+                    ty::adjust_ty(tcx, expr.span, ty_unadjusted, Some(&adjustment))\n+                }\n+            }\n+        }\n+    }\n }\n \n pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n@@ -129,7 +150,7 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_visitor() -> rvt {\n+fn regionck_visitor() -> rvt {\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n                                   visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n@@ -138,11 +159,11 @@ pub fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-pub fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -173,19 +194,24 @@ pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     }\n }\n \n-pub fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_block(b: &ast::blk, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n-    debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n+fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n+    debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |&adjustment| {\n+        debug!(\"adjustment=%?\", adjustment);\n         match *adjustment {\n             @ty::AutoDerefRef(\n-                ty::AutoDerefRef {\n-                    autoderefs: autoderefs, autoref: Some(ref autoref)}) => {\n-                guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n+            {\n+                let expr_ty = rcx.resolve_node_type(expr.id);\n+                constrain_derefs(rcx, expr, autoderefs, expr_ty);\n+                for opt_autoref.each |autoref| {\n+                    guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                }\n             }\n             _ => {}\n         }\n@@ -271,6 +297,16 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n             }\n         }\n \n+        ast::expr_index(vec_expr, _) => {\n+            let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n+            constrain_index(rcx, expr, vec_type);\n+        }\n+\n+        ast::expr_unary(ast::deref, base) => {\n+            let base_ty = rcx.resolve_node_type(base.id);\n+            constrain_derefs(rcx, expr, 1, base_ty);\n+        }\n+\n         ast::expr_addr_of(_, base) => {\n             guarantor::for_addr_of(rcx, expr, base);\n         }\n@@ -297,11 +333,11 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-pub fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n+fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n-pub fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n+fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n     /*!\n      *\n      * checks the type of the node `id` and reports an error if it\n@@ -314,13 +350,119 @@ pub fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n \n     // find the region where this expr evaluation is taking place\n     let tcx = fcx.ccx.tcx;\n-    let encl_region = ty::encl_region(tcx, id);\n+    let encl_region = match tcx.region_maps.opt_encl_scope(id) {\n+        None => ty::re_static,\n+        Some(r) => ty::re_scope(r)\n+    };\n \n     // Otherwise, look at the type and see if it is a region pointer.\n     constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n }\n \n-pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n+fn encl_region_or_static(rcx: @mut Rcx, expr: @ast::expr) -> ty::Region {\n+    // FIXME(#3850) --- interactions with modes compel overly large granularity\n+    // that is, we would probably prefer to just return re_scope(expr.id)\n+    // here but we cannot just yet.\n+\n+    let tcx = rcx.fcx.tcx();\n+    match tcx.region_maps.opt_encl_scope(expr.id) {\n+        Some(s) => ty::re_scope(s),\n+        None => ty::re_static // occurs in constants\n+    }\n+}\n+\n+fn constrain_derefs(rcx: @mut Rcx,\n+                    deref_expr: @ast::expr,\n+                    derefs: uint,\n+                    mut derefd_ty: ty::t)\n+{\n+    /*!\n+     * Invoked on any dereference that occurs, whether explicitly\n+     * or through an auto-deref.  Checks that if this is a region\n+     * pointer being derefenced, the lifetime of the pointer includes\n+     * the deref expr.\n+     */\n+\n+    let tcx = rcx.fcx.tcx();\n+    let r_deref_expr = encl_region_or_static(rcx, deref_expr);\n+    for uint::range(0, derefs) |i| {\n+        debug!(\"constrain_derefs(deref_expr=%s, derefd_ty=%s, derefs=%?/%?\",\n+               rcx.fcx.expr_to_str(deref_expr),\n+               rcx.fcx.infcx().ty_to_str(derefd_ty),\n+               i, derefs);\n+\n+        match ty::get(derefd_ty).sty {\n+            ty::ty_rptr(r_ptr, _) => {\n+                match rcx.fcx.mk_subr(true, deref_expr.span, r_deref_expr, r_ptr) {\n+                    result::Ok(*) => {}\n+                    result::Err(*) => {\n+                        tcx.sess.span_err(\n+                            deref_expr.span,\n+                            fmt!(\"dereference of reference outside its lifetime\"));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the reference is only valid for \",\n+                            r_ptr,\n+                            \"\");\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        match ty::deref(tcx, derefd_ty, true) {\n+            Some(mt) => derefd_ty = mt.ty,\n+            None => {\n+                tcx.sess.span_bug(\n+                    deref_expr.span,\n+                    fmt!(\"%?'th deref is of a non-deref'able type `%s`\",\n+                         i, rcx.fcx.infcx().ty_to_str(derefd_ty)));\n+            }\n+        }\n+    }\n+}\n+\n+fn constrain_index(rcx: @mut Rcx,\n+                   index_expr: @ast::expr,\n+                   indexed_ty: ty::t)\n+{\n+    /*!\n+     * Invoked on any index expression that occurs.  Checks that if\n+     * this is a slice being indexed, the lifetime of the pointer\n+     * includes the deref expr.\n+     */\n+\n+    let tcx = rcx.fcx.tcx();\n+\n+    debug!(\"constrain_index(index_expr=%s, indexed_ty=%s\",\n+           rcx.fcx.expr_to_str(index_expr),\n+           rcx.fcx.infcx().ty_to_str(indexed_ty));\n+\n+    let r_index_expr = encl_region_or_static(rcx, index_expr);\n+    match ty::get(indexed_ty).sty {\n+        ty::ty_estr(ty::vstore_slice(r_ptr)) |\n+        ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n+            match rcx.fcx.mk_subr(true, index_expr.span, r_index_expr, r_ptr) {\n+                result::Ok(*) => {}\n+                result::Err(*) => {\n+                    tcx.sess.span_err(\n+                        index_expr.span,\n+                        fmt!(\"index of slice outside its lifetime\"));\n+                    note_and_explain_region(\n+                        tcx,\n+                        \"the slice is only valid for \",\n+                        r_ptr,\n+                        \"\");\n+                }\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+}\n+\n+fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     /*!\n      *\n      * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n@@ -340,7 +482,7 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     };\n \n     let tcx = rcx.fcx.tcx();\n-    let encl_region = ty::encl_region(tcx, expr.id);\n+    let encl_region = tcx.region_maps.encl_region(expr.id);\n     match rcx.fcx.mk_subr(true, expr.span, encl_region, region) {\n         result::Ok(()) => {}\n         result::Err(_) => {\n@@ -366,7 +508,7 @@ pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     }\n }\n \n-pub fn constrain_free_variables(\n+fn constrain_free_variables(\n     rcx: @mut Rcx,\n     region: ty::Region,\n     expr: @ast::expr) {\n@@ -402,81 +544,103 @@ pub fn constrain_free_variables(\n     }\n }\n \n-pub fn constrain_regions_in_type_of_node(\n+fn constrain_regions_in_type_of_node(\n     rcx: @mut Rcx,\n     id: ast::node_id,\n     encl_region: ty::Region,\n-    span: span) -> bool {\n+    span: span) -> bool\n+{\n     let tcx = rcx.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty = rcx.resolve_node_type(id);\n+    let ty0 = rcx.resolve_node_type(id);\n+    let adjustment = rcx.fcx.inh.adjustments.find(&id);\n+    let ty = ty::adjust_ty(tcx, span, ty0, adjustment);\n     debug!(\"constrain_regions_in_type_of_node(\\\n-            ty=%s, id=%d, encl_region=%?)\",\n-           ty_to_str(tcx, ty), id, encl_region);\n+            ty=%s, ty0=%s, id=%d, encl_region=%?, adjustment=%?)\",\n+           ty_to_str(tcx, ty), ty_to_str(tcx, ty0),\n+           id, encl_region, adjustment);\n     constrain_regions_in_type(rcx, encl_region, span, ty)\n }\n \n-pub fn constrain_regions_in_type(\n+fn constrain_regions_in_type(\n     rcx: @mut Rcx,\n     encl_region: ty::Region,\n     span: span,\n-    ty: ty::t) -> bool {\n+    ty: ty::t) -> bool\n+{\n     /*!\n      *\n      * Requires that any regions which appear in `ty` must be\n-     * superregions of `encl_region`.  This prevents regions from\n-     * being used outside of the block in which they are valid.\n-     * Recall that regions represent blocks of code or expressions:\n-     * this requirement basically says \"any place that uses or may use\n-     * a region R must be within the block of code that R corresponds\n-     * to.\" */\n+     * superregions of `encl_region`.  Also enforces the constraint\n+     * that given a pointer type `&'r T`, T must not contain regions\n+     * that outlive 'r, as well as analogous constraints for other\n+     * lifetime'd types.\n+     *\n+     * This check prevents regions from being used outside of the block in\n+     * which they are valid.  Recall that regions represent blocks of\n+     * code or expressions: this requirement basically says \"any place\n+     * that uses or may use a region R must be within the block of\n+     * code that R corresponds to.\"\n+     */\n \n     let e = rcx.errors_reported;\n-    ty::walk_regions_and_ty(\n-        rcx.fcx.ccx.tcx, ty,\n-        |r| constrain_region(rcx, encl_region, span, r),\n-        |t| ty::type_has_regions(t));\n-    return (e == rcx.errors_reported);\n+    let tcx = rcx.fcx.ccx.tcx;\n \n-    fn constrain_region(rcx: @mut Rcx,\n-                        encl_region: ty::Region,\n-                        span: span,\n-                        region: ty::Region) {\n-        let tcx = rcx.fcx.ccx.tcx;\n+    debug!(\"constrain_regions_in_type(encl_region=%s, ty=%s)\",\n+           region_to_str(tcx, encl_region),\n+           ty_to_str(tcx, ty));\n \n-        debug!(\"constrain_region(encl_region=%?, region=%?)\",\n-               encl_region, region);\n+    do relate_nested_regions(tcx, Some(encl_region), ty) |r_sub, r_sup| {\n+        debug!(\"relate(r_sub=%s, r_sup=%s)\",\n+               region_to_str(tcx, r_sub),\n+               region_to_str(tcx, r_sup));\n \n-        match region {\n-          ty::re_bound(_) => {\n+        if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type.\n             // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n             // constrained by `encl_region` as they are placeholders\n             // for regions that are as-yet-unknown.\n-            return;\n-          }\n-          _ => ()\n-        }\n-\n-        match rcx.fcx.mk_subr(true, span, encl_region, region) {\n-          result::Err(_) => {\n-            tcx.sess.span_err(\n-                span,\n-                fmt!(\"reference is not valid outside of its lifetime\"));\n-            note_and_explain_region(\n-                tcx,\n-                ~\"the reference is only valid for \",\n-                region,\n-                ~\"\");\n-            rcx.errors_reported += 1u;\n-          }\n-          result::Ok(()) => {\n-          }\n+        } else {\n+            match rcx.fcx.mk_subr(true, span, r_sub, r_sup) {\n+                result::Err(_) => {\n+                    if r_sub == encl_region {\n+                        tcx.sess.span_err(\n+                            span,\n+                            fmt!(\"reference is not valid outside of its lifetime\"));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the reference is only valid for \",\n+                            r_sup,\n+                            \"\");\n+                    } else {\n+                        tcx.sess.span_err(\n+                            span,\n+                            fmt!(\"in type `%s`, pointer has a longer lifetime than \\\n+                                  the data it references\",\n+                                 rcx.fcx.infcx().ty_to_str(ty)));\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"the pointer is valid for \",\n+                            r_sub,\n+                            \"\");\n+                        note_and_explain_region(\n+                            tcx,\n+                            \"but the referenced data is only valid for \",\n+                            r_sup,\n+                            \"\");\n+                    }\n+                    rcx.errors_reported += 1u;\n+                }\n+                result::Ok(()) => {\n+                }\n+            }\n         }\n     }\n+\n+    return (e == rcx.errors_reported);\n }\n \n pub mod guarantor {\n@@ -577,10 +741,12 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug!(\"guarantor::for_autoref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        debug!(\"guarantor::for_autoref(expr=%s, autoref=%?)\",\n+               rcx.fcx.expr_to_str(expr), autoref);\n         let _i = ::util::common::indenter();\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n+        debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n         expr_ct = apply_autoderefs(\n             rcx, expr, autoderefs, expr_ct);\n \n@@ -626,7 +792,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"opt_constrain_region(id=%?, guarantor=%?)\", id, guarantor);\n+        debug!(\"link(id=%?, guarantor=%?)\", id, guarantor);\n \n         let bound = match guarantor {\n             None => {\n@@ -860,8 +1026,6 @@ pub mod guarantor {\n                 match closure_ty.sigil {\n                     ast::BorrowedSigil => BorrowedPointer(closure_ty.region),\n                     ast::OwnedSigil => OwnedPointer,\n-\n-                    // NOTE This is...not quite right.  Deduce a test etc.\n                     ast::ManagedSigil => OtherPointer,\n                 }\n             }\n@@ -972,7 +1136,6 @@ pub fn infallibly_mk_subr(rcx: @mut Rcx,\n                           a: ty::Region,\n                           b: ty::Region) {\n     /*!\n-     *\n      * Constrains `a` to be a subregion of `b`.  In many cases, we\n      * know that this can never yield an error due to the way that\n      * region inferencing works.  Therefore just report a bug if we"}, {"sha": "359f938d0d997a0482253ea9dead0a71c942f3c1", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -99,7 +99,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                       to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n-              ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n+              ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n               ty::re_infer(_) => {\n                 isr\n               }\n@@ -167,10 +167,125 @@ pub fn replace_bound_regions_in_fn_sig(\n               // Free regions like these just stay the same:\n               ty::re_static |\n               ty::re_scope(_) |\n-              ty::re_free(_, _) |\n+              ty::re_free(*) |\n               ty::re_infer(_) => r\n             };\n             r1\n         }\n     }\n }\n+\n+pub fn relate_nested_regions(\n+    tcx: ty::ctxt,\n+    opt_region: Option<ty::Region>,\n+    ty: ty::t,\n+    relate_op: &fn(ty::Region, ty::Region))\n+{\n+    /*!\n+     *\n+     * This rather specialized function walks each region `r` that appear\n+     * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\n+     * here is the region of any enclosing `&'r T` pointer.  If there is\n+     * no enclosing pointer, and `opt_region` is Some, then `opt_region.get()`\n+     * is used instead.  Otherwise, no callback occurs at all).\n+     *\n+     * Here are some examples to give you an intution:\n+     *\n+     * - `relate_nested_regions(Some('r1), &'r2 uint)` invokes\n+     *   - `relate_op('r1, 'r2)`\n+     * - `relate_nested_regions(Some('r1), &'r2 &'r3 uint)` invokes\n+     *   - `relate_op('r1, 'r2)`\n+     *   - `relate_op('r2, 'r3)`\n+     * - `relate_nested_regions(None, &'r2 &'r3 uint)` invokes\n+     *   - `relate_op('r2, 'r3)`\n+     * - `relate_nested_regions(None, &'r2 &'r3 &'r4 uint)` invokes\n+     *   - `relate_op('r2, 'r3)`\n+     *   - `relate_op('r2, 'r4)`\n+     *   - `relate_op('r3, 'r4)`\n+     *\n+     * This function is used in various pieces of code because we enforce the\n+     * constraint that a region pointer cannot outlive the things it points at.\n+     * Hence, in the second example above, `'r2` must be a subregion of `'r3`.\n+     */\n+\n+    let mut the_stack = ~[];\n+    for opt_region.each |&r| { the_stack.push(r); }\n+    walk_ty(tcx, &mut the_stack, ty, relate_op);\n+\n+    fn walk_ty(tcx: ty::ctxt,\n+               the_stack: &mut ~[ty::Region],\n+               ty: ty::t,\n+               relate_op: &fn(ty::Region, ty::Region))\n+    {\n+        match ty::get(ty).sty {\n+            ty::ty_rptr(r, ref mt) |\n+            ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                relate(*the_stack, r, relate_op);\n+                the_stack.push(r);\n+                walk_ty(tcx, the_stack, mt.ty, relate_op);\n+                the_stack.pop();\n+            }\n+            _ => {\n+                ty::fold_regions_and_ty(\n+                    tcx,\n+                    ty,\n+                    |r| { relate(*the_stack, r, relate_op); r },\n+                    |t| { walk_ty(tcx, the_stack, t, relate_op); t },\n+                    |t| { walk_ty(tcx, the_stack, t, relate_op); t });\n+            }\n+        }\n+    }\n+\n+    fn relate(the_stack: &[ty::Region],\n+              r_sub: ty::Region,\n+              relate_op: &fn(ty::Region, ty::Region))\n+    {\n+        for the_stack.each |&r| {\n+            if !r.is_bound() && !r_sub.is_bound() {\n+                relate_op(r, r_sub);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn relate_free_regions(\n+    tcx: ty::ctxt,\n+    self_ty: Option<ty::t>,\n+    fn_sig: &ty::FnSig)\n+{\n+    /*!\n+     * This function populates the region map's `free_region_map`.\n+     * It walks over the transformed self type and argument types\n+     * for each function just before we check the body of that\n+     * function, looking for types where you have a borrowed\n+     * pointer to other borrowed data (e.g., `&'a &'b [uint]`.\n+     * We do not allow borrowed pointers to outlive the things they\n+     * point at, so we can assume that `'a <= 'b`.\n+     *\n+     * Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+     */\n+\n+    debug!(\"relate_free_regions >>\");\n+\n+    let mut all_tys = ~[];\n+    for fn_sig.inputs.each |arg| {\n+        all_tys.push(arg.ty);\n+    }\n+    for self_ty.each |&t| {\n+        all_tys.push(t);\n+    }\n+\n+    for all_tys.each |&t| {\n+        debug!(\"relate_free_regions(t=%s)\", ppaux::ty_to_str(tcx, t));\n+        relate_nested_regions(tcx, None, t, |a, b| {\n+            match (&a, &b) {\n+                (&ty::re_free(free_a), &ty::re_free(free_b)) => {\n+                    tcx.region_maps.relate_free_regions(free_a, free_b);\n+                }\n+                _ => {}\n+            }\n+        })\n+    }\n+\n+    debug!(\"<< relate_free_regions\");\n+}\n\\ No newline at end of file"}, {"sha": "0ef6e2512f3d5b3187fcc9487faa7d9e44a59c18", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -535,7 +535,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // a free region.  So, for example, if the impl type is\n     // \"&'self str\", then this would replace the self type with a free\n     // region `self`.\n-    let dummy_self_r = ty::re_free(cm.body_id, ty::br_self);\n+    let dummy_self_r = ty::re_free(ty::FreeRegion {scope_id: cm.body_id,\n+                                                   bound_region: ty::br_self});\n     let self_ty = replace_bound_self(tcx, self_ty, dummy_self_r);\n \n     // Perform substitutions so that the trait/impl methods are expressed"}, {"sha": "7252566d84c17d0ddaaa73031ea3fb06aba122a8", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 121, "deletions": 44, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -538,10 +538,9 @@ more convincing in the future.\n \n use core::prelude::*;\n \n-use middle::region::is_subregion_of;\n-use middle::region;\n use middle::ty;\n-use middle::ty::{Region, RegionVid, re_static, re_infer, re_free, re_bound};\n+use middle::ty::{FreeRegion, Region, RegionVid};\n+use middle::ty::{re_static, re_infer, re_free, re_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use util::common::indenter;\n@@ -554,6 +553,7 @@ use core::to_bytes;\n use core::uint;\n use core::vec;\n use syntax::codemap::span;\n+use syntax::ast;\n \n #[deriving(Eq)]\n enum Constraint {\n@@ -1025,11 +1025,12 @@ pub impl RegionVarBindings {\n }\n \n priv impl RegionVarBindings {\n-    fn is_subregion_of(&mut self, sub: Region, sup: Region) -> bool {\n-        is_subregion_of(self.tcx.region_map, sub, sup)\n+    fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n+        let rm = self.tcx.region_maps;\n+        rm.is_subregion_of(sub, sup)\n     }\n \n-    fn lub_concrete_regions(&mut self, +a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n         match (a, b) {\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n@@ -1042,17 +1043,17 @@ priv impl RegionVarBindings {\n                       non-concrete regions: %?, %?\", a, b));\n           }\n \n-          (f @ re_free(f_id, _), re_scope(s_id)) |\n-          (re_scope(s_id), f @ re_free(f_id, _)) => {\n+          (f @ re_free(ref fr), re_scope(s_id)) |\n+          (re_scope(s_id), f @ re_free(ref fr)) => {\n             // A \"free\" region can be interpreted as \"some region\n-            // at least as big as the block f_id\".  So, we can\n+            // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            let rm = self.tcx.region_map;\n-            match region::nearest_common_ancestor(rm, f_id, s_id) {\n-              // if the free region's scope `f_id` is bigger than\n+            let rm = self.tcx.region_maps;\n+            match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+              // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n-              Some(r_id) if r_id == f_id => f,\n+              Some(r_id) if r_id == fr.scope_id => f,\n \n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n@@ -1064,32 +1065,67 @@ priv impl RegionVarBindings {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n-            let rm = self.tcx.region_map;\n-            match region::nearest_common_ancestor(rm, a_id, b_id) {\n+            let rm = self.tcx.region_maps;\n+            match rm.nearest_common_ancestor(a_id, b_id) {\n               Some(r_id) => re_scope(r_id),\n               _ => re_static\n             }\n           }\n \n+          (re_free(ref a_fr), re_free(ref b_fr)) => {\n+             self.lub_free_regions(a_fr, b_fr)\n+          }\n+\n           // For these types, we cannot define any additional\n           // relationship:\n           (re_infer(ReSkolemized(*)), _) |\n           (_, re_infer(ReSkolemized(*))) |\n-          (re_free(_, _), re_free(_, _)) |\n           (re_bound(_), re_bound(_)) |\n-          (re_bound(_), re_free(_, _)) |\n+          (re_bound(_), re_free(_)) |\n           (re_bound(_), re_scope(_)) |\n-          (re_free(_, _), re_bound(_)) |\n+          (re_free(_), re_bound(_)) |\n           (re_scope(_), re_bound(_)) => {\n             if a == b {a} else {re_static}\n           }\n         }\n     }\n \n-    fn glb_concrete_regions(&mut self,\n+    fn lub_free_regions(&self,\n+                        a: &FreeRegion,\n+                        b: &FreeRegion) -> ty::Region\n+    {\n+        /*!\n+         * Computes a region that encloses both free region arguments.\n+         * Guarantee that if the same two regions are given as argument,\n+         * in any order, a consistent result is returned.\n+         */\n+\n+        return match a.cmp(b) {\n+            Less => helper(self, a, b),\n+            Greater => helper(self, b, a),\n+            Equal => ty::re_free(*a)\n+        };\n+\n+        fn helper(self: &RegionVarBindings,\n+                  a: &FreeRegion,\n+                  b: &FreeRegion) -> ty::Region\n+        {\n+            let rm = self.tcx.region_maps;\n+            if rm.sub_free_region(*a, *b) {\n+                ty::re_free(*b)\n+            } else if rm.sub_free_region(*b, *a) {\n+                ty::re_free(*a)\n+            } else {\n+                ty::re_static\n+            }\n+        }\n+    }\n+\n+    fn glb_concrete_regions(&self,\n                             +a: Region,\n                             +b: Region)\n                          -> cres<Region> {\n+        debug!(\"glb_concrete_regions(%?, %?)\", a, b);\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -1104,47 +1140,36 @@ priv impl RegionVarBindings {\n                           non-concrete regions: %?, %?\", a, b));\n             }\n \n-            (re_free(f_id, _), s @ re_scope(s_id)) |\n-            (s @ re_scope(s_id), re_free(f_id, _)) => {\n+            (re_free(ref fr), s @ re_scope(s_id)) |\n+            (s @ re_scope(s_id), re_free(ref fr)) => {\n                 // Free region is something \"at least as big as\n-                // `f_id`.\"  If we find that the scope `f_id` is bigger\n+                // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                let rm = self.tcx.region_map;\n-                match region::nearest_common_ancestor(rm, f_id, s_id) {\n-                    Some(r_id) if r_id == f_id => Ok(s),\n+                let rm = self.tcx.region_maps;\n+                match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+                    Some(r_id) if r_id == fr.scope_id => Ok(s),\n                     _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n \n-            (re_scope(a_id), re_scope(b_id)) |\n-            (re_free(a_id, _), re_free(b_id, _)) => {\n-                if a == b {\n-                    // Same scope or same free identifier, easy case.\n-                    Ok(a)\n-                } else {\n-                    // We want to generate the intersection of two\n-                    // scopes or two free regions.  So, if one of\n-                    // these scopes is a subscope of the other, return\n-                    // it.  Otherwise fail.\n-                    let rm = self.tcx.region_map;\n-                    match region::nearest_common_ancestor(rm, a_id, b_id) {\n-                        Some(r_id) if a_id == r_id => Ok(re_scope(b_id)),\n-                        Some(r_id) if b_id == r_id => Ok(re_scope(a_id)),\n-                        _ => Err(ty::terr_regions_no_overlap(b, a))\n-                    }\n-                }\n+            (re_scope(a_id), re_scope(b_id)) => {\n+                self.intersect_scopes(a, b, a_id, b_id)\n+            }\n+\n+            (re_free(ref a_fr), re_free(ref b_fr)) => {\n+                self.glb_free_regions(a_fr, b_fr)\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n             (re_infer(ReSkolemized(*)), _) |\n             (_, re_infer(ReSkolemized(*))) |\n             (re_bound(_), re_bound(_)) |\n-            (re_bound(_), re_free(_, _)) |\n+            (re_bound(_), re_free(_)) |\n             (re_bound(_), re_scope(_)) |\n-            (re_free(_, _), re_bound(_)) |\n+            (re_free(_), re_bound(_)) |\n             (re_scope(_), re_bound(_)) => {\n                 if a == b {\n                     Ok(a)\n@@ -1155,10 +1180,62 @@ priv impl RegionVarBindings {\n         }\n     }\n \n+    fn glb_free_regions(&self,\n+                        a: &FreeRegion,\n+                        b: &FreeRegion) -> cres<ty::Region>\n+    {\n+        /*!\n+         * Computes a region that is enclosed by both free region arguments,\n+         * if any. Guarantees that if the same two regions are given as argument,\n+         * in any order, a consistent result is returned.\n+         */\n+\n+        return match a.cmp(b) {\n+            Less => helper(self, a, b),\n+            Greater => helper(self, b, a),\n+            Equal => Ok(ty::re_free(*a))\n+        };\n+\n+        fn helper(self: &RegionVarBindings,\n+                  a: &FreeRegion,\n+                  b: &FreeRegion) -> cres<ty::Region>\n+        {\n+            let rm = self.tcx.region_maps;\n+            if rm.sub_free_region(*a, *b) {\n+                Ok(ty::re_free(*a))\n+            } else if rm.sub_free_region(*b, *a) {\n+                Ok(ty::re_free(*b))\n+            } else {\n+                self.intersect_scopes(ty::re_free(*a), ty::re_free(*b),\n+                                      a.scope_id, b.scope_id)\n+            }\n+        }\n+    }\n+\n     fn report_type_error(&mut self, span: span, terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n         self.tcx.sess.span_err(span, terr_str);\n     }\n+\n+    fn intersect_scopes(&self,\n+                        region_a: ty::Region,\n+                        region_b: ty::Region,\n+                        scope_a: ast::node_id,\n+                        scope_b: ast::node_id) -> cres<Region>\n+    {\n+        // We want to generate the intersection of two\n+        // scopes or two free regions.  So, if one of\n+        // these scopes is a subscope of the other, return\n+        // it.  Otherwise fail.\n+        debug!(\"intersect_scopes(scope_a=%?, scope_b=%?, region_a=%?, region_b=%?)\",\n+               scope_a, scope_b, region_a, region_b);\n+        let rm = self.tcx.region_maps;\n+        match rm.nearest_common_ancestor(scope_a, scope_b) {\n+            Some(r_id) if scope_a == r_id => Ok(re_scope(scope_b)),\n+            Some(r_id) if scope_b == r_id => Ok(re_scope(scope_a)),\n+            _ => Err(ty::terr_regions_no_overlap(region_a, region_b))\n+        }\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "bf607e2c3624678fcc5e52b511f1cfd357ae9449", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -210,7 +210,9 @@ pub impl Env {\n     }\n \n     fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::re_free(nid, ty::br_anon(id)),\n+        ty::mk_imm_rptr(self.tcx,\n+                        ty::re_free(ty::FreeRegion {scope_id: nid,\n+                                                    bound_region: ty::br_anon(id)}),\n                         self.t_int())\n     }\n "}, {"sha": "f8877f768813dc822a92149773eb14bac8e30982", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -41,9 +41,9 @@ pub trait Repr {\n }\n \n pub fn note_and_explain_region(cx: ctxt,\n-                               prefix: ~str,\n+                               prefix: &str,\n                                region: ty::Region,\n-                               suffix: ~str) {\n+                               suffix: &str) {\n     match explain_region_and_span(cx, region) {\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n@@ -98,23 +98,23 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         }\n       }\n \n-      re_free(id, br) => {\n-        let prefix = match br {\n+      re_free(ref fr) => {\n+        let prefix = match fr.bound_region {\n           br_anon(idx) => fmt!(\"the anonymous lifetime #%u defined on\",\n                                idx + 1),\n           br_fresh(_) => fmt!(\"an anonymous lifetime defined on\"),\n           _ => fmt!(\"the lifetime %s as defined on\",\n-                    bound_region_to_str(cx, br))\n+                    bound_region_to_str(cx, fr.bound_region))\n         };\n \n-        match cx.items.find(&id) {\n+        match cx.items.find(&fr.scope_id) {\n           Some(&ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n           }\n           Some(_) | None => {\n             // this really should not happen\n-            (fmt!(\"%s node %d\", prefix, id), None)\n+            (fmt!(\"%s node %d\", prefix, fr.scope_id), None)\n           }\n         }\n       }\n@@ -215,7 +215,7 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n     match region {\n         re_scope(_) => prefix.to_str(),\n         re_bound(br) => bound_region_to_str_space(cx, prefix, br),\n-        re_free(_, br) => bound_region_to_str_space(cx, prefix, br),\n+        re_free(ref fr) => bound_region_to_str_space(cx, prefix, fr.bound_region),\n         re_infer(ReSkolemized(_, br)) => {\n             bound_region_to_str_space(cx, prefix, br)\n         }\n@@ -225,12 +225,16 @@ pub fn region_to_str_space(cx: ctxt, prefix: &str, region: Region) -> ~str {\n }\n \n pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n+    mt_to_str_wrapped(cx, \"\", m, \"\")\n+}\n+\n+pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = match m.mutbl {\n       ast::m_mutbl => \"mut \",\n       ast::m_imm => \"\",\n       ast::m_const => \"const \"\n     };\n-    return fmt!(\"%s%s\", mstr, ty_to_str(cx, m.ty));\n+    return fmt!(\"%s%s%s%s\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n@@ -250,15 +254,14 @@ pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     }\n }\n \n-pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n+pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n-      ty::vstore_fixed(_) => {\n-        fmt!(\"[%s, .. %s]\", ty, vstore_to_str(cx, vs))\n-      }\n-      ty::vstore_slice(_) => {\n-        fmt!(\"%s %s\", vstore_to_str(cx, vs), ty)\n-      }\n-      _ => fmt!(\"%s[%s]\", vstore_to_str(cx, vs), ty)\n+        ty::vstore_fixed(_) => {\n+            fmt!(\"[%s, .. %s]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n+        }\n+        _ => {\n+            fmt!(\"%s%s\", vstore_to_str(cx, vs), mt_to_str_wrapped(cx, \"[\", mt, \"]\"))\n+        }\n     }\n }\n \n@@ -460,7 +463,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         fmt!(\"%s%s\", trait_store_to_str(cx, s), ty)\n       }\n       ty_evec(ref mt, vs) => {\n-        vstore_ty_to_str(cx, fmt!(\"%s\", mt_to_str(cx, mt)), vs)\n+        vstore_ty_to_str(cx, mt, vs)\n       }\n       ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), ~\"str\"),\n       ty_opaque_box => ~\"@?\","}, {"sha": "54ee8bcc70e3774a5974bc6365b898dbe800896e", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -27,5 +27,6 @@ fn main() {\n         let x: &'blk int = &3;\n         repeater(@x)\n     };\n-    assert!(3 == *(y.get())); //~ ERROR reference is not valid\n+    assert!(3 == *(y.get())); //~ ERROR dereference of reference outside its lifetime\n+    //~^ ERROR reference is not valid outside of its lifetime\n }"}, {"sha": "f7165784c79754bc574cf71baa380b56a4124acc", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -24,9 +24,9 @@ fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n \n fn return_it() -> int {\n     with(|o| o)\n-    //~^ ERROR reference is not valid outside of its lifetime\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n     //~^^ ERROR reference is not valid outside of its lifetime\n-    //~^^^ ERROR cannot infer an appropriate lifetime\n+    //~^^^ ERROR reference is not valid outside of its lifetime\n }\n \n fn main() {"}, {"sha": "e5399fc7fa3b9332e1b91723b494d6382e5b7893", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that callees correctly infer an ordering between free regions\n+// that appear in their parameter list.  See also\n+// regions-free-region-ordering-caller.rs\n+\n+fn ordering1<'a, 'b>(x: &'a &'b uint) -> &'a uint {\n+    // It is safe to assume that 'a <= 'b due to the type of x\n+    let y: &'b uint = &**x;\n+    return y;\n+}\n+\n+fn ordering2<'a, 'b>(x: &'a &'b uint, y: &'a uint) -> &'b uint {\n+    // However, it is not safe to assume that 'b <= 'a\n+    &*y //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n+    // Do not infer an ordering from the return value.\n+    let z: &'b uint = &*x;\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    fail!();\n+}\n+\n+fn ordering4<'a, 'b>(a: &'a uint, b: &'b uint, x: &fn(&'a &'b uint)) {\n+    let z: Option<&'a &'b uint> = None;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "d06dcd8aa86b81d4dab0a01ea03f629f66f7fb34", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test various ways to construct a pointer with a longer lifetime\n+// than the thing it points at and ensure that they result in\n+// errors. See also regions-free-region-ordering-callee.rs\n+\n+struct Paramd<'self> { x: &'self uint }\n+\n+fn call1<'a>(x: &'a uint) {\n+    let y: uint = 3;\n+    let z: &'a &'blk uint = &(&y);\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call2<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let z: Option<&'b &'a uint> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call3<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let y: Paramd<'a> = Paramd { x: a };\n+    let z: Option<&'b Paramd<'a>> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+fn call4<'a, 'b>(a: &'a uint, b: &'b uint) {\n+    let z: Option<&fn(&'a &'b uint)> = None;\n+    //~^ ERROR pointer has a longer lifetime than the data it references\n+}\n+\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "9855a234618ab872f64f69c6aea3291f64965a8a", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3322595e896e95c3e19ca33c854ad529f2ef3c19/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=3322595e896e95c3e19ca33c854ad529f2ef3c19", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test #5723\n+\n+// Test that you cannot escape a borrowed pointer\n+// into a trait.\n+\n struct ctxt { v: uint }\n \n trait get_ctxt {\n@@ -24,8 +29,9 @@ fn make_gc() -> @get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n     return @hc as @get_ctxt;\n+    //^~ ERROR source contains borrowed pointer\n }\n \n fn main() {\n-    make_gc().get_ctxt().v; //~ ERROR illegal borrow\n+    make_gc().get_ctxt().v;\n }"}]}