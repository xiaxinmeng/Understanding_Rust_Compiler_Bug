{"sha": "d8e3557dbae23283f81d7bc45200413dd93ced4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZTM1NTdkYmFlMjMyODNmODFkN2JjNDUyMDA0MTNkZDkzY2VkNGE=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-02T23:08:24Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-02T23:08:24Z"}, "message": "Remove `usable_size` APIs", "tree": {"sha": "a1131d53f204443a6ab0cdf12f51b52b0f48a361", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1131d53f204443a6ab0cdf12f51b52b0f48a361"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8e3557dbae23283f81d7bc45200413dd93ced4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e3557dbae23283f81d7bc45200413dd93ced4a", "html_url": "https://github.com/rust-lang/rust/commit/d8e3557dbae23283f81d7bc45200413dd93ced4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8e3557dbae23283f81d7bc45200413dd93ced4a/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5441faf4e56d136d7c05d5eb55b4a41396edaf", "html_url": "https://github.com/rust-lang/rust/commit/cd5441faf4e56d136d7c05d5eb55b4a41396edaf"}], "stats": {"total": 403, "additions": 134, "deletions": 269}, "files": [{"sha": "73e8121868aba67ea7b38da5affec03f34ea0e50", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -165,8 +165,8 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(alloc(layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n@@ -180,13 +180,13 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr).map(|p| (p, new_size))\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n }\n \n@@ -201,7 +201,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n         match Global.alloc(layout) {\n-            Ok(ptr) => ptr.as_ptr(),\n+            Ok((ptr, _)) => ptr.as_ptr(),\n             Err(_) => handle_alloc_error(layout),\n         }\n     }"}, {"sha": "55944398e16772b65b7533d7722b220be6ebf22c", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -8,7 +8,7 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr =\n+        let (ptr, _) =\n             Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();"}, {"sha": "4729f0290cfca3ce41bdaacb34fa15dbd84eebf1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -200,7 +200,7 @@ impl<T> Box<T> {\n             let ptr = if layout.size() == 0 {\n                 NonNull::dangling()\n             } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n             };\n             Box::from_raw(ptr.as_ptr())\n         }\n@@ -270,7 +270,7 @@ impl<T> Box<[T]> {\n             let ptr = if layout.size() == 0 {\n                 NonNull::dangling()\n             } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n             };\n             Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n         }"}, {"sha": "345834d7daacc3a499374bbee8dc9eb80a0f889c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -72,7 +72,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         RawVec::allocate_in(capacity, true, a)\n     }\n \n-    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n+    fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n@@ -87,7 +87,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let layout = Layout::from_size_align(alloc_size, align).unwrap();\n                 let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n                 match result {\n-                    Ok(ptr) => ptr.cast(),\n+                    Ok((ptr, size)) => {\n+                        capacity = size / elem_size;\n+                        ptr.cast()\n+                    }\n                     Err(_) => handle_alloc_error(layout),\n                 }\n             };\n@@ -280,7 +283,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, ptr) = match self.current_layout() {\n+            let (ptr, new_cap) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +300,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr),\n+                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -310,7 +313,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     let layout = Layout::array::<T>(new_cap).unwrap();\n                     match self.a.alloc(layout) {\n-                        Ok(ptr) => (new_cap, ptr),\n+                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n                         Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n@@ -598,7 +601,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n                 match self.a.realloc(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                    Ok(p) => self.ptr = p.cast().into(),\n+                    Ok((ptr, _)) => self.ptr = ptr.cast().into(),\n                     Err(_) => {\n                         handle_alloc_error(Layout::from_size_align_unchecked(new_size, align))\n                     }\n@@ -631,6 +634,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n     ) -> Result<(), TryReserveError> {\n+        let elem_size = mem::size_of::<T>();\n+\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -662,15 +667,15 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            let ptr = match (res, fallibility) {\n+            let (ptr, new_cap) = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n                 (Err(AllocErr), Fallible) => {\n                     return Err(TryReserveError::AllocError {\n                         layout: new_layout,\n                         non_exhaustive: (),\n                     });\n                 }\n-                (Ok(ptr), _) => ptr,\n+                (Ok((ptr, new_size)), _) => (ptr, new_size / elem_size),\n             };\n \n             self.ptr = ptr.cast().into();"}, {"sha": "860058debe1fda3588b6eb92e9fe141e7d9eafce", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -20,7 +20,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);"}, {"sha": "901cc70a4d82e0d72ddc5c472a0e959d5709bc76", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -923,7 +923,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.as_ptr());"}, {"sha": "fced5e680ea016b5019d3d8adf2dcf7f7f3bb250", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -784,7 +784,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.as_ptr());"}, {"sha": "d159126f426c52070b7290f0025dfe191d093c75", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -20,7 +20,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().0\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "f3a2b73f2b8de92d3d6299ec0db48c853d2ec3db", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 80, "deletions": 224, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -11,12 +11,6 @@ use crate::num::NonZeroUsize;\n use crate::ptr::{self, NonNull};\n use crate::usize;\n \n-/// Represents the combination of a starting address and\n-/// a total capacity of the returned block.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Debug)]\n-pub struct Excess(pub NonNull<u8>, pub usize);\n-\n const fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n }\n@@ -593,13 +587,12 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n-///   (`realloc`, `realloc_excess`), and\n+///   `alloc_zeroed`) or reallocation method (`realloc`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n-///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n-///   passed to a reallocation method (see above) that returns `Ok`.\n+///   method (`dealloc`) or by being passed to a reallocation method\n+///  (see above) that returns `Ok`.\n ///\n /// A note regarding zero-sized types and zero-sized layouts: many\n /// methods in the `AllocRef` trait state that allocation requests\n@@ -625,11 +618,9 @@ pub unsafe trait GlobalAlloc {\n ///\n /// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n ///\n-///    * `use_min` is `self.usable_size(layout).0`, and\n+///    * `use_min` is `layout.size()`, and\n ///\n-///    * `use_max` is the capacity that was (or would have been)\n-///      returned when (if) the block was allocated via a call to\n-///      `alloc_excess` or `realloc_excess`.\n+///    * `use_max` is the capacity that was returned.\n ///\n /// Note that:\n ///\n@@ -643,6 +634,9 @@ pub unsafe trait GlobalAlloc {\n ///    currently allocated via an allocator `a`, then it is legal to\n ///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n ///\n+///  * if an allocator does not support overallocating, it is fine to\n+///    simply return `layout.size()` as the allocated size.\n+///\n /// # Safety\n ///\n /// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n@@ -671,8 +665,9 @@ pub unsafe trait AllocRef {\n     // However in jemalloc for example,\n     // `mallocx(0)` is documented as undefined behavior.)\n \n-    /// Returns a pointer meeting the size and alignment guarantees of\n-    /// `layout`.\n+    /// On success, returns a pointer meeting the size and alignment\n+    /// guarantees of `layout` and the actual size of the allocated block,\n+    /// which must be greater than or equal to `layout.size()`.\n     ///\n     /// If this method returns an `Ok(addr)`, then the `addr` returned\n     /// will be non-null address pointing to a block of storage\n@@ -709,7 +704,7 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -728,48 +723,42 @@ pub unsafe trait AllocRef {\n     ///   to allocate that block of memory.\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n-    // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n-    // usable_size\n-\n-    /// Returns bounds on the guaranteed usable size of a successful\n-    /// allocation created with the specified `layout`.\n-    ///\n-    /// In particular, if one has a memory block allocated via a given\n-    /// allocator `a` and layout `k` where `a.usable_size(k)` returns\n-    /// `(l, u)`, then one can pass that block to `a.dealloc()` with a\n-    /// layout in the size range [l, u].\n-    ///\n-    /// (All implementors of `usable_size` must ensure that\n-    /// `l <= k.size() <= u`)\n-    ///\n-    /// Both the lower- and upper-bounds (`l` and `u` respectively)\n-    /// are provided, because an allocator based on size classes could\n-    /// misbehave if one attempts to deallocate a block without\n-    /// providing a correct value for its size (i.e., one within the\n-    /// range `[l, u]`).\n-    ///\n-    /// Clients who wish to make use of excess capacity are encouraged\n-    /// to use the `alloc_excess` and `realloc_excess` instead, as\n-    /// this method is constrained to report conservative values that\n-    /// serve as valid bounds for *all possible* allocation method\n-    /// calls.\n-    ///\n-    /// However, for clients that do not wish to track the capacity\n-    /// returned by `alloc_excess` locally, this method is likely to\n-    /// produce useful results.\n-    #[inline]\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        (layout.size(), layout.size())\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        let size = layout.size();\n+        let result = self.alloc(layout);\n+        if let Ok((p, _)) = result {\n+            ptr::write_bytes(p.as_ptr(), 0, size);\n+        }\n+        result\n     }\n \n     // == METHODS FOR MEMORY REUSE ==\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n     /// a new layout with `layout`\u2019s alignment and a size given\n-    /// by `new_size`. To\n-    /// accomplish this, this may extend or shrink the allocation\n-    /// referenced by `ptr` to fit the new layout.\n+    /// by `new_size` and the actual size of the allocated block.\n+    /// The latter is greater than or equal to `layout.size()`.\n+    /// To accomplish this, the allocator may extend or shrink\n+    /// the allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block\n     /// referenced by `ptr` has been transferred to this\n@@ -824,23 +813,25 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let old_size = layout.size();\n \n-        if new_size >= old_size {\n-            if let Ok(()) = self.grow_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+        if new_size > old_size {\n+            if let Ok(size) = self.grow_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n         } else if new_size < old_size {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n+        } else {\n+            return Ok((ptr, new_size));\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n-        if let Ok(new_ptr) = result {\n+        if let Ok((new_ptr, _)) = result {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n@@ -877,174 +868,40 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let old_size = layout.size();\n \n-        if new_size >= old_size {\n-            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n-                return Ok(ptr);\n+        if new_size > old_size {\n+            if let Ok(size) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n         } else if new_size < old_size {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n+        } else {\n+            return Ok((ptr, new_size));\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc_zeroed(new_layout);\n-        if let Ok(new_ptr) = result {\n+        if let Ok((new_ptr, _)) = result {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n         result\n     }\n \n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        let size = layout.size();\n-        let p = self.alloc(layout);\n-        if let Ok(p) = p {\n-            ptr::write_bytes(p.as_ptr(), 0, size);\n-        }\n-        p\n-    }\n-\n-    /// Behaves like `alloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let usable_size = self.usable_size(&layout);\n-        self.alloc(layout).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `alloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    /// Also it ensures that the contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let usable_size = self.usable_size(&layout);\n-        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `realloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `realloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_excess(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<Excess, AllocErr> {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let usable_size = self.usable_size(&new_layout);\n-        self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `realloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    /// Also it ensures that the contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `realloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_excess_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<Excess, AllocErr> {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let usable_size = self.usable_size(&new_layout);\n-        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n-    }\n-\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n     /// memory block referenced by `ptr` now fits `new_size`, and thus can\n     /// be used to carry data of a layout of that size and same alignment as\n-    /// `layout`. (The allocator is allowed to\n-    /// expend effort to accomplish this, such as extending the memory block to\n-    /// include successor blocks, or virtual memory tricks.)\n+    /// `layout`. The returned value is the new size of the allocated block.\n+    /// (The allocator is allowed to expend effort to accomplish this, such\n+    /// as extending the memory block to include successor blocks, or virtual\n+    /// memory tricks.)\n     ///\n     /// Regardless of what this method returns, ownership of the\n     /// memory block referenced by `ptr` has not been transferred, and\n@@ -1072,18 +929,17 @@ pub unsafe trait AllocRef {\n     /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n+    #[inline]\n     unsafe fn grow_in_place(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size >= layout.size());\n-        let (_l, u) = self.usable_size(&layout);\n-        // _l <= layout.size()                       [guaranteed by usable_size()]\n-        //       layout.size() <= new_layout.size()  [required by this method]\n-        if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let _ = ptr;\n+        let _ = layout;\n+        let _ = new_size;\n+        Err(CannotReallocInPlace)\n     }\n \n     /// Behaves like `grow_in_place`, but also ensures that the new\n@@ -1108,18 +964,19 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        self.grow_in_place(ptr, layout, new_size)?;\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let size = self.grow_in_place(ptr, layout, new_size)?;\n         ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n-        Ok(())\n+        Ok(size)\n     }\n \n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n     /// memory block referenced by `ptr` now fits `new_size`, and\n     /// thus can only be used to carry data of that smaller\n-    /// layout. (The allocator is allowed to take advantage of this,\n+    /// layout. The returned value is the new size the allocated block.\n+    /// (The allocator is allowed to take advantage of this,\n     /// carving off portions of the block for reuse elsewhere.) The\n     /// truncated contents of the block within the smaller layout are\n     /// unaltered, and ownership of block has not been transferred.\n@@ -1153,17 +1010,16 @@ pub unsafe trait AllocRef {\n     /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n+    #[inline]\n     unsafe fn shrink_in_place(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size <= layout.size());\n-        let (l, _u) = self.usable_size(&layout);\n-        //                      layout.size() <= _u  [guaranteed by usable_size()]\n-        // new_layout.size() <= layout.size()        [required by this method]\n-        if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let _ = ptr;\n+        let _ = layout;\n+        let _ = new_size;\n+        Err(CannotReallocInPlace)\n     }\n }"}, {"sha": "2da18e06d99bf79048e9cedeab4b0971f02aa52d", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -137,13 +137,15 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n+            .ok_or(AllocErr)\n+            .map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n@@ -157,8 +159,10 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n+            .ok_or(AllocErr)\n+            .map(|p| (p, new_size))\n     }\n }\n "}, {"sha": "c275db14b427cfa65c68f8a64ab1cebe1beafffa", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Global.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(ptr, layout.clone());\n@@ -49,7 +49,7 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = System.alloc(layout.clone()).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n         helper::work_with(&ptr);\n         System.dealloc(ptr, layout);"}, {"sha": "e4746d1a7ec0904e5b7be30d05faf749e9d51b6b", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -20,13 +20,13 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Global.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(ptr, layout.clone());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = System.alloc(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n         helper::work_with(&ptr);\n         System.dealloc(ptr, layout);"}, {"sha": "eb6224ad1bbb6d1766f1a5abc6c926570b0b3094", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -41,13 +41,13 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (ptr, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, ret);\n+            println!(\"allocate({:?}) = {:?}\", layout, ptr);\n         }\n \n-        ret.cast().as_ptr()\n+        ptr.cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -63,16 +63,16 @@ unsafe fn test_triangle() -> bool {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n+        let (ptr, _) = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n             .unwrap_or_else(|_| handle_alloc_error(\n                 Layout::from_size_align_unchecked(new.size(), old.align())\n             ));\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\",\n-                     ptr, old, new, ret);\n+                     ptr, old, new, ptr);\n         }\n-        ret.cast().as_ptr()\n+        ptr.cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize { (i+1) * 10 }"}, {"sha": "fe3a864fe4ba58be0286e4a9c98fe8b5d25ecace", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e3557dbae23283f81d7bc45200413dd93ced4a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=d8e3557dbae23283f81d7bc45200413dd93ced4a", "patch": "@@ -24,29 +24,29 @@ struct Ccx {\n     x: isize\n }\n \n-fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n+fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (ptr, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n         &*(ptr.as_ptr() as *const _)\n     }\n }\n \n-fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n+fn h<'a>(bcx: &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n-fn g(fcx : &Fcx) {\n-    let bcx = Bcx { fcx: fcx };\n+fn g(fcx: &Fcx) {\n+    let bcx = Bcx { fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n         Global.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n \n-fn f(ccx : &Ccx) {\n+fn f(ccx: &Ccx) {\n     let a = arena(());\n-    let fcx = Fcx { arena: &a, ccx: ccx };\n+    let fcx = Fcx { arena: &a, ccx };\n     return g(&fcx);\n }\n "}]}