{"sha": "1e3259e119b6370267415b9e07f3ea80869f839d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMzI1OWUxMTliNjM3MDI2NzQxNWI5ZTA3ZjNlYTgwODY5ZjgzOWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-15T19:06:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-15T21:44:06Z"}, "message": "massive refactor of how closures work", "tree": {"sha": "164d059055aef5b9ee59b55b2ae6176d6cccc1f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/164d059055aef5b9ee59b55b2ae6176d6cccc1f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e3259e119b6370267415b9e07f3ea80869f839d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3259e119b6370267415b9e07f3ea80869f839d", "html_url": "https://github.com/rust-lang/rust/commit/1e3259e119b6370267415b9e07f3ea80869f839d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e3259e119b6370267415b9e07f3ea80869f839d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d381cc072a9c9c0fef605c56ed77d538a49c8ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/d381cc072a9c9c0fef605c56ed77d538a49c8ead", "html_url": "https://github.com/rust-lang/rust/commit/d381cc072a9c9c0fef605c56ed77d538a49c8ead"}], "stats": {"total": 1235, "additions": 683, "deletions": 552}, "files": [{"sha": "e5d93baa9d371193da846d5074afc6c3cd14169d", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -73,9 +73,8 @@ const fn_field_code: int = 0;\n const fn_field_box: int = 1;\n \n const closure_elt_tydesc: int = 0;\n-const closure_elt_bindings: int = 1;\n-//const closure_elt_n_ty_params: int = 2;\n-const closure_elt_ty_params: int = 2; // 3;\n+const closure_elt_ty_params: int = 1;\n+const closure_elt_bindings: int = 2;\n \n const vec_elt_fill: int = 0;\n "}, {"sha": "d488a0fa00d668edfdb3d27d03fcbdf65e044300", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -17,7 +17,8 @@ type upcalls =\n      shared_malloc: ValueRef,\n      shared_free: ValueRef,\n      mark: ValueRef,\n-     clone_type_desc: ValueRef,\n+     create_shared_type_desc: ValueRef,\n+     free_shared_type_desc: ValueRef,\n      get_type_desc: ValueRef,\n      vec_grow: ValueRef,\n      vec_push: ValueRef,\n@@ -64,9 +65,11 @@ fn declare_upcalls(targ_cfg: @session::config,\n               dv(\"shared_free\", [T_ptr(T_i8())]),\n           mark:\n               d(\"mark\", [T_ptr(T_i8())], int_t),\n-          clone_type_desc:\n-              d(\"clone_type_desc\", [T_ptr(tydesc_type)],\n+          create_shared_type_desc:\n+              d(\"create_shared_type_desc\", [T_ptr(tydesc_type)],\n                 T_ptr(tydesc_type)),\n+          free_shared_type_desc:\n+              dv(\"free_shared_type_desc\", [T_ptr(tydesc_type)]),\n           get_type_desc:\n               d(\"get_type_desc\",\n                 [T_ptr(T_nil()), size_t,"}, {"sha": "f1222f844333517180ec14a0a252aff39092b4e9", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -51,6 +51,7 @@ const shape_obj: u8 = 19u8;\n const shape_res: u8 = 20u8;\n const shape_var: u8 = 21u8;\n const shape_uniq: u8 = 22u8;\n+const shape_opaque_closure: u8 = 23u8; // the closure itself.\n \n // FIXME: This is a bad API in trans_common.\n fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n@@ -384,9 +385,6 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n         }\n         add_substr(s, sub);\n       }\n-      ty::ty_fn(_, _, _, _, _) {\n-        s += [shape_fn];\n-      }\n       ty::ty_native_fn(_, _) { s += [shape_u32]; }\n       ty::ty_obj(_) { s += [shape_obj]; }\n       ty::ty_res(did, raw_subt, tps) {\n@@ -412,19 +410,18 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n             s += [shape_var, n as u8];\n         } else {\n             // Find the type parameter in the parameter list.\n-            let found = false;\n-            let i = 0u;\n-            while i < vec::len(ty_param_map) {\n-                if n == ty_param_map[i] {\n-                    s += [shape_var, i as u8];\n-                    found = true;\n-                    break;\n-                }\n-                i += 1u;\n+            alt vec::position(n, ty_param_map) {\n+              some(i) { s += [shape_var, i as u8]; }\n+              none. { fail \"ty param not found in ty_param_map\"; }\n             }\n-            assert (found);\n         }\n       }\n+      ty::ty_fn(_, _, _, _, _) {\n+        s += [shape_fn];\n+      }\n+      ty::ty_opaque_closure. {\n+        s += [shape_opaque_closure];\n+      }\n     }\n \n     ret s;"}, {"sha": "c66d02565973d9c7e3cc220c81419ea1345eb92e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 48, "deletions": 276, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -94,7 +94,9 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n     // Arg 1: Env (closure-bindings / self-obj)\n     if is_method {\n         atys += [T_ptr(cx.rust_object_type)];\n-    } else { atys += [T_opaque_closure_ptr(cx)]; }\n+    } else {\n+        atys += [T_opaque_boxed_closure_ptr(cx)];\n+    }\n \n     // Args >2: ty params, if not acquired via capture...\n     if !is_method {\n@@ -124,8 +126,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n     // Check the cache.\n \n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n-    let llty =\n-    alt ty::struct(cx.tcx, t) {\n+    let llty = alt ty::struct(cx.tcx, t) {\n       ty::ty_native(_) { T_ptr(T_i8()) }\n       ty::ty_nil. { T_nil() }\n       ty::ty_bot. {\n@@ -200,6 +201,9 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         }\n         T_struct(tys)\n       }\n+      ty::ty_opaque_closure. {\n+        T_opaque_closure(cx)\n+      }\n     };\n     cx.lltypes.insert(t, llty);\n     ret llty;\n@@ -1295,22 +1299,6 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n \n fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n \n-    fn take_fn_env(cx: @block_ctxt,\n-                   v: ValueRef,\n-                   blk: block(@block_ctxt, ValueRef, ValueRef) -> @block_ctxt)\n-        -> @block_ctxt {\n-        let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n-        let box_ptr_v = Load(cx, box_cell_v);\n-        let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let null_test = IsNull(cx, box_ptr_v);\n-        CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n-        inner_cx = blk(inner_cx, box_cell_v, box_ptr_v);\n-        Br(inner_cx, next_cx.llbb);\n-        ret next_cx;\n-    }\n-\n-\n     let bcx = cx;\n     let tcx = bcx_tcx(cx);\n     // NB: v is an *alias* of type t here, not a direct value.\n@@ -1329,25 +1317,20 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         Store(r.bcx, r.val, v);\n         r.bcx\n       }\n-      ty::ty_fn(ast::proto_bare., _, _, _, _) {\n-        bcx\n-      }\n-      ty::ty_fn(ast::proto_block., _, _, _, _) {\n+      ty::ty_send_type. {\n+        // sendable type descriptors are basically unique pointers,\n+        // they must be cloned when copied:\n+        let r = Load(bcx, v);\n+        let s = Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [r]);\n+        Store(bcx, s, v);\n         bcx\n       }\n-      ty::ty_fn(ast::proto_send., _, _, _, _) {\n-        take_fn_env(bcx, v, { |bcx, _box_cell_v, box_ptr_v|\n-            // Here, box_ptr_v is a unique pointer which\n-            // must be cloned.\n-            call_bound_data_glue_for_closure(\n-                bcx, box_ptr_v, abi::tydesc_field_take_glue);\n-            bcx\n-        })\n+      ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+        trans_closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_native_fn(_, _) | ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n-        take_fn_env(bcx, v, { |bcx, _box_cell_v, box_ptr_v|\n-            incr_refcnt_of_boxed(bcx, box_ptr_v)\n-        })\n+      ty::ty_opaque_closure. {\n+        trans_closure::call_opaque_closure_glue(\n+            bcx, v, abi::tydesc_field_take_glue)\n       }\n       _ when ty::type_is_structural(bcx_tcx(bcx), t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n@@ -1368,17 +1351,17 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n-fn call_bound_data_glue_for_closure(bcx: @block_ctxt,\n-                                    v: ValueRef,\n-                                    field: int) {\n-    // Call through the closure's own fields-drop glue.\n-    let ccx = bcx_ccx(bcx);\n-    let v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n-    let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n-    let bindings = GEPi(bcx, body, [0, abi::closure_elt_bindings]);\n-    let tydescptr = GEPi(bcx, body, [0, abi::closure_elt_tydesc]);\n-    let ti = none;\n-    call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr), field, ti);\n+fn free_box(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n+    ret alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_box(body_mt) {\n+        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n+        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n+        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        trans_free_if_not_gc(bcx, v)\n+      }\n+\n+      _ { fail \"free_box invoked with non-box type\"; }\n+    };\n }\n \n fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n@@ -1387,10 +1370,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     // everything to a pointer to the type that the glue acts on).\n     let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n       ty::ty_box(body_mt) {\n-        let v = PointerCast(bcx, v, type_of_1(bcx, t));\n-        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n-        let bcx = drop_ty(bcx, body, body_mt.ty);\n-        trans_free_if_not_gc(bcx, v)\n+        free_box(bcx, v, t)\n       }\n       ty::ty_uniq(content_mt) {\n         check trans_uniq::type_is_unique_box(bcx, t);\n@@ -1415,23 +1395,17 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n                               abi::tydesc_field_drop_glue, ti);\n         trans_free_if_not_gc(bcx, b)\n       }\n-      ty::ty_fn(ast::proto_bare., _, _, _, _) {\n-        bcx\n-      }\n-      ty::ty_fn(ast::proto_block., _, _, _, _) {\n-        bcx\n-      }\n-      ty::ty_fn(ast::proto_send., _, _, _, _) {\n-        // n.b.: When we drop a function, we actually invoke the\n-        // free glue only on the environment part.\n-        call_bound_data_glue_for_closure(bcx, v, abi::tydesc_field_drop_glue);\n+      ty::ty_send_type. {\n+        // sendable type descriptors are basically unique pointers,\n+        // they must be freed.\n         trans_shared_free(bcx, v)\n       }\n-      ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n-        // n.b.: When we drop a function, we actually invoke the\n-        // free glue only on the environment part.\n-        call_bound_data_glue_for_closure(bcx, v, abi::tydesc_field_drop_glue);\n-        trans_free_if_not_gc(bcx, v)\n+      ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+        trans_closure::make_fn_glue(bcx, v, t, free_ty)\n+      }\n+      ty::ty_opaque_closure. {\n+        trans_closure::call_opaque_closure_glue(\n+            bcx, v, abi::tydesc_field_free_glue)\n       }\n       _ { bcx }\n     };\n@@ -1444,7 +1418,7 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     let bcx =\n         alt ty::struct(ccx.tcx, t) {\n           ty::ty_box(_) { decr_refcnt_maybe_free(bcx, Load(bcx, v0), t) }\n-          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. {\n+          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. | ty::ty_send_type. {\n             free_ty(bcx, Load(bcx, v0), t)\n           }\n           ty::ty_obj(_) {\n@@ -1455,21 +1429,12 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n-          ty::ty_fn(ast::proto_bare., _, _, _, _) {\n-            bcx // No environment to free.\n+          ty::ty_native_fn(_, _) | ty::ty_fn(_, _, _, _, _) {\n+            trans_closure::make_fn_glue(bcx, v0, t, drop_ty)\n           }\n-          ty::ty_fn(ast::proto_block., _, _, _, _) {\n-            bcx // Environment is stack allocated and needs no free.\n-          }\n-          ty::ty_fn(ast::proto_send., _, _, _, _) {\n-            // Environment is a unique pointer.\n-            let box_cell = GEPi(bcx, v0, [0, abi::fn_field_box]);\n-            free_ty(bcx, Load(bcx, box_cell), t)\n-          }\n-          ty::ty_native_fn(_, _) |\n-          ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n-            let box_cell = GEPi(bcx, v0, [0, abi::fn_field_box]);\n-            decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n+          ty::ty_opaque_closure. {\n+            trans_closure::call_opaque_closure_glue(\n+                bcx, v0, abi::tydesc_field_drop_glue)\n           }\n           _ {\n             if ty::type_needs_drop(ccx.tcx, t) &&\n@@ -2614,7 +2579,7 @@ type lval_maybe_callee = {bcx: @block_ctxt,\n                           generic: option::t<generic_info>};\n \n fn null_env_ptr(bcx: @block_ctxt) -> ValueRef {\n-    C_null(T_opaque_closure_ptr(bcx_ccx(bcx)))\n+    C_null(T_opaque_boxed_closure_ptr(bcx_ccx(bcx)))\n }\n \n fn lval_from_local_var(bcx: @block_ctxt, r: local_var_result) -> lval_result {\n@@ -3063,199 +3028,6 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     ret store_in_dest(e_res.bcx, newval, dest);\n }\n \n-// pth is cx.path\n-fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n-                    outgoing_fty: ty::t, args: [option::t<@ast::expr>],\n-                    env_ty: ty::t, ty_param_count: uint,\n-                    target_fn: option::t<ValueRef>)\n-    -> {val: ValueRef, ty: TypeRef} {\n-    // If we supported constraints on record fields, we could make the\n-    // constraints for this function:\n-    /*\n-    : returns_non_ty_var(ccx, outgoing_fty),\n-      type_has_static_size(ccx, incoming_fty) ->\n-    */\n-    // but since we don't, we have to do the checks at the beginning.\n-    let ccx = cx.ccx;\n-    check type_has_static_size(ccx, incoming_fty);\n-\n-    // Here we're not necessarily constructing a thunk in the sense of\n-    // \"function with no arguments\".  The result of compiling 'bind f(foo,\n-    // bar, baz)' would be a thunk that, when called, applies f to those\n-    // arguments and returns the result.  But we're stretching the meaning of\n-    // the word \"thunk\" here to also mean the result of compiling, say, 'bind\n-    // f(foo, _, baz)', or any other bind expression that binds f and leaves\n-    // some (or all) of the arguments unbound.\n-\n-    // Here, 'incoming_fty' is the type of the entire bind expression, while\n-    // 'outgoing_fty' is the type of the function that is having some of its\n-    // arguments bound.  If f is a function that takes three arguments of type\n-    // int and returns int, and we're translating, say, 'bind f(3, _, 5)',\n-    // then outgoing_fty is the type of f, which is (int, int, int) -> int,\n-    // and incoming_fty is the type of 'bind f(3, _, 5)', which is int -> int.\n-\n-    // Once translated, the entire bind expression will be the call f(foo,\n-    // bar, baz) wrapped in a (so-called) thunk that takes 'bar' as its\n-    // argument and that has bindings of 'foo' to 3 and 'baz' to 5 and a\n-    // pointer to 'f' all saved in its environment.  So, our job is to\n-    // construct and return that thunk.\n-\n-    // Give the thunk a name, type, and value.\n-    let s: str = mangle_internal_name_by_path_and_seq(ccx, cx.path, \"thunk\");\n-    let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, sp, incoming_fty));\n-    let llthunk: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n-\n-    // Create a new function context and block context for the thunk, and hold\n-    // onto a pointer to the first block in the function for later use.\n-    let fcx = new_fn_ctxt(cx, sp, llthunk);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-    // Since we might need to construct derived tydescs that depend on\n-    // our bound tydescs, we need to load tydescs out of the environment\n-    // before derived tydescs are constructed. To do this, we load them\n-    // in the load_env block.\n-    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n-\n-    // The 'llenv' that will arrive in the thunk we're creating is an\n-    // environment that will contain the values of its arguments and a pointer\n-    // to the original function.  So, let's create one of those:\n-\n-    // The llenv pointer needs to be the correct size.  That size is\n-    // 'closure_ty', which was determined by trans_bind.\n-    let closure_ty = ty::mk_imm_box(ccx.tcx, env_ty);\n-    // FIXME: would be nice to have a postcondition on mk_imm_box\n-    // (Issue #586)\n-    check (type_has_static_size(ccx, closure_ty));\n-    let llclosure_ptr_ty = type_of(ccx, sp, closure_ty);\n-    let llclosure = PointerCast(load_env_bcx, fcx.llenv, llclosure_ptr_ty);\n-\n-    // \"target\", in this context, means the function that's having some of its\n-    // arguments bound and that will be called inside the thunk we're\n-    // creating.  (In our running example, target is the function f.)  Pick\n-    // out the pointer to the target function from the environment. The\n-    // target function lives in the first binding spot.\n-    let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n-      some(fptr) { (fptr, llvm::LLVMGetUndef(T_opaque_closure_ptr(ccx)), 0) }\n-      none. {\n-        // Silly check\n-        check type_is_tup_like(bcx, closure_ty);\n-        let {bcx: cx, val: pair} =\n-            GEP_tup_like(bcx, closure_ty, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_bindings, 0]);\n-        let lltargetenv =\n-            Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n-        let lltargetfn = Load\n-            (cx, GEPi(cx, pair, [0, abi::fn_field_code]));\n-        bcx = cx;\n-        (lltargetfn, lltargetenv, 1)\n-      }\n-    };\n-\n-    // And then, pick out the target function's own environment.  That's what\n-    // we'll use as the environment the thunk gets.\n-\n-    // Get f's return type, which will also be the return type of the entire\n-    // bind expression.\n-    let outgoing_ret_ty = ty::ty_fn_ret(cx.ccx.tcx, outgoing_fty);\n-\n-    // Get the types of the arguments to f.\n-    let outgoing_args = ty::ty_fn_args(cx.ccx.tcx, outgoing_fty);\n-\n-    // The 'llretptr' that will arrive in the thunk we're creating also needs\n-    // to be the correct type.  Cast it to f's return type, if necessary.\n-    let llretptr = fcx.llretptr;\n-    let ccx = cx.ccx;\n-    if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n-        check non_ty_var(ccx, outgoing_ret_ty);\n-        let llretty = type_of_inner(ccx, sp, outgoing_ret_ty);\n-        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n-    }\n-\n-    // Set up the three implicit arguments to the thunk.\n-    let llargs: [ValueRef] = [llretptr, lltargetenv];\n-\n-    // Copy in the type parameters.\n-    let i: uint = 0u;\n-    while i < ty_param_count {\n-        // Silly check\n-        check type_is_tup_like(load_env_bcx, closure_ty);\n-        let lltyparam_ptr =\n-            GEP_tup_like(load_env_bcx, closure_ty, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_ty_params, i as int]);\n-        load_env_bcx = lltyparam_ptr.bcx;\n-        let td = Load(load_env_bcx, lltyparam_ptr.val);\n-        llargs += [td];\n-        fcx.lltydescs += [td];\n-        i += 1u;\n-    }\n-\n-    let a: uint = 2u; // retptr, env come first\n-    let b: int = starting_idx;\n-    let outgoing_arg_index: uint = 0u;\n-    let llout_arg_tys: [TypeRef] =\n-        type_of_explicit_args(cx.ccx, sp, outgoing_args);\n-    for arg: option::t<@ast::expr> in args {\n-        let out_arg = outgoing_args[outgoing_arg_index];\n-        let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n-        alt arg {\n-          // Arg provided at binding time; thunk copies it from\n-          // closure.\n-          some(e) {\n-            // Silly check\n-            check type_is_tup_like(bcx, closure_ty);\n-            let bound_arg =\n-                GEP_tup_like(bcx, closure_ty, llclosure,\n-                             [0, abi::box_rc_field_body,\n-                              abi::closure_elt_bindings, b]);\n-            bcx = bound_arg.bcx;\n-            let val = bound_arg.val;\n-            if out_arg.mode == ast::by_val { val = Load(bcx, val); }\n-            if out_arg.mode == ast::by_copy {\n-                let {bcx: cx, val: alloc} = alloc_ty(bcx, out_arg.ty);\n-                bcx = memmove_ty(cx, alloc, val, out_arg.ty);\n-                bcx = take_ty(bcx, alloc, out_arg.ty);\n-                val = alloc;\n-            }\n-            // If the type is parameterized, then we need to cast the\n-            // type we actually have to the parameterized out type.\n-            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-                val = PointerCast(bcx, val, llout_arg_ty);\n-            }\n-            llargs += [val];\n-            b += 1;\n-          }\n-\n-          // Arg will be provided when the thunk is invoked.\n-          none. {\n-            let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n-            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-                arg = PointerCast(bcx, arg, llout_arg_ty);\n-            }\n-            llargs += [arg];\n-            a += 1u;\n-          }\n-        }\n-        outgoing_arg_index += 1u;\n-    }\n-\n-    // Cast the outgoing function to the appropriate type.\n-    // This is necessary because the type of the function that we have\n-    // in the closure does not know how many type descriptors the function\n-    // needs to take.\n-    let ccx = bcx_ccx(bcx);\n-\n-    check returns_non_ty_var(ccx, outgoing_fty);\n-    let lltargetty =\n-        type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n-    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n-    Call(bcx, lltargetfn, llargs);\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-    ret {val: llthunk, ty: llthunk_ty};\n-}\n-\n fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n                   &to_zero: [{v: ValueRef, t: ty::t}],\n                   &to_revoke: [{v: ValueRef, t: ty::t}], e: @ast::expr) ->\n@@ -3431,7 +3203,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let llenv;\n     alt f_res.env {\n       null_env. {\n-        llenv = llvm::LLVMGetUndef(T_opaque_closure_ptr(bcx_ccx(cx)));\n+        llenv = llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(bcx_ccx(cx)));\n       }\n       obj_env(e) { llenv = e; }\n       is_closure. {\n@@ -5351,7 +5123,7 @@ fn fill_fn_pair(bcx: @block_ctxt, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n     let llenvblobptr =\n-        PointerCast(bcx, llenvptr, T_opaque_closure_ptr(ccx));\n+        PointerCast(bcx, llenvptr, T_opaque_boxed_closure_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }\n "}, {"sha": "1ee5a9ede676297bdfe3274d77e4d83587d4ae18", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 425, "deletions": 166, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -1,14 +1,17 @@\n import syntax::ast;\n import syntax::ast_util;\n-import lib::llvm::llvm::ValueRef;\n+import lib::llvm::llvm;\n+import llvm::{ValueRef, TypeRef};\n import trans_common::*;\n import trans_build::*;\n import trans::*;\n import middle::freevars::get_freevars;\n import option::{some, none};\n import back::abi;\n import syntax::codemap::span;\n-import back::link::mangle_internal_name_by_path;\n+import back::link::{\n+    mangle_internal_name_by_path,\n+    mangle_internal_name_by_path_and_seq};\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n@@ -22,19 +25,91 @@ import trans::{\n     dest\n };\n \n+// ___Good to know (tm)__________________________________________________\n+//\n+// The layout of a closure environment in memory is\n+// roughly as follows:\n+//\n+// struct closure_box {\n+//    unsigned ref_count; // only used for sharid environments\n+//    struct closure {\n+//      type_desc *tydesc;         // descriptor for the env type\n+//      type_desc *bound_tdescs[]; // bound descriptors\n+//      struct {\n+//          upvar1_t upvar1;\n+//          ...\n+//          upvarN_t upvarN;\n+//      } bound_data;\n+//   };\n+// };\n+//\n+// NB: this is defined in the code in T_closure_ptr and\n+// closure_ty_to_tuple_ty (below).\n+//\n+// Note that the closure carries a type descriptor that describes\n+// itself.  Trippy.  This is needed because the precise types of the\n+// closed over data are lost in the closure type (`fn(T)->U`), so if\n+// we need to take/drop, we must know what data is in the upvars and\n+// so forth.\n+//\n+// The allocation strategy for this closure depends on the closure\n+// type.  For a sendfn, the closure (and the referenced type\n+// descriptors) will be allocated in the exchange heap.  For a fn, the\n+// closure is allocated in the task heap and is reference counted.\n+// For a block, the closure is allocated on the stack.  Note that in\n+// all cases we allocate space for a ref count just to make our lives\n+// easier when upcasting to block(T)->U, in the shape code, and so\n+// forth.\n+//\n+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n tag environment_value {\n     env_expr(@ast::expr);\n     env_direct(ValueRef, ty::t, bool);\n }\n \n+// Given a closure ty, emits a corresponding tuple ty\n+fn mk_closure_ty(tcx: ty::ctxt,\n+                 ck: ty::closure_kind,\n+                 n_bound_tds: uint,\n+                 bound_data_ty: ty::t)\n+    -> ty::t {\n+    let tydesc_ty = alt ck {\n+      ty::closure_block. | ty::closure_shared. { ty::mk_type(tcx) }\n+      ty::closure_send. { ty::mk_send_type(tcx) }\n+    };\n+    ret ty::mk_tup(tcx, [\n+        tydesc_ty,\n+        ty::mk_tup(tcx, vec::init_elt(tydesc_ty, n_bound_tds)),\n+        bound_data_ty]);\n+}\n+\n+fn shared_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n+    let opaque_closure_ty = ty::mk_opaque_closure(tcx);\n+    ret ty::mk_imm_box(tcx, opaque_closure_ty);\n+}\n+\n+fn send_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n+    let opaque_closure_ty = ty::mk_opaque_closure(tcx);\n+    let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), opaque_closure_ty]);\n+    ret ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n+}\n+\n+type closure_result = {\n+    llbox: ValueRef,  // llvalue of boxed environment\n+    box_ty: ty::t,    // type of boxed environment\n+    bcx: @block_ctxt  // final bcx\n+};\n+\n // Given a block context and a list of tydescs and values to bind\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n-                     bound_values: [environment_value],\n-                     mode: closure_constr_mode) ->\n-   {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+fn store_environment(\n+    bcx: @block_ctxt, lltydescs: [ValueRef],\n+    bound_values: [environment_value],\n+    ck: ty::closure_kind)\n+    -> closure_result {\n \n     fn dummy_environment_box(bcx: @block_ctxt, r: result)\n         -> (@block_ctxt, ValueRef, ValueRef) {\n@@ -46,12 +121,16 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         (r.bcx, closure, r.val)\n     }\n \n-    fn clone_tydesc(bcx: @block_ctxt,\n-                    mode: closure_constr_mode,\n-                    td: ValueRef) -> ValueRef {\n-        ret alt mode {\n-          for_block. | for_closure. { td }\n-          for_send. { Call(bcx, bcx_ccx(bcx).upcalls.clone_type_desc, [td]) }\n+    fn maybe_clone_tydesc(bcx: @block_ctxt,\n+                          ck: ty::closure_kind,\n+                          td: ValueRef) -> ValueRef {\n+        ret alt ck {\n+          ty::closure_block. | ty::closure_shared. {\n+            td\n+          }\n+          ty::closure_send. {\n+            Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [td])\n+          }\n         };\n     }\n \n@@ -68,29 +147,9 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n           env_expr(e) { ty::expr_ty(tcx, e) }\n         }];\n     }\n-    let bindings_ty: ty::t = ty::mk_tup(tcx, bound_tys);\n-\n-    // NB: keep this in sync with T_closure_ptr; we're making\n-    // a ty::t structure that has the same \"shape\" as the LLVM type\n-    // it constructs.\n-\n-    // Make a vector that contains ty_param_count copies of tydesc_ty.\n-    // (We'll need room for that many tydescs in the closure.)\n-    let ty_param_count = vec::len(lltydescs);\n-    let tydesc_ty: ty::t = ty::mk_type(tcx);\n-    let captured_tys: [ty::t] = vec::init_elt(tydesc_ty, ty_param_count);\n-\n-    // Get all the types we've got (some of which we synthesized\n-    // ourselves) into a vector.  The whole things ends up looking\n-    // like:\n-\n-    // closure_ty = (\n-    //   tydesc_ty, (bound_ty1, bound_ty2, ...),\n-    //   /*int,*/ (tydesc_ty, tydesc_ty, ...))\n-    let closure_tys: [ty::t] =\n-        [tydesc_ty, bindings_ty,\n-         /*ty::mk_uint(tcx),*/ ty::mk_tup(tcx, captured_tys)];\n-    let closure_ty: ty::t = ty::mk_tup(tcx, closure_tys);\n+    let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n+    let closure_ty =\n+        mk_closure_ty(tcx, ck, vec::len(lltydescs), bound_data_ty);\n \n     let temp_cleanups = [];\n \n@@ -102,14 +161,14 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     // so that it will never drop to zero.  This is a hack and could go away\n     // but then we'd have to modify the code to do the right thing when\n     // casting from a shared closure to a block.\n-    let (bcx, closure, box) = alt mode {\n-      for_closure. {\n+    let (bcx, closure, box) = alt ck {\n+      ty::closure_shared. {\n         let r = trans::trans_malloc_boxed(bcx, closure_ty);\n         add_clean_free(bcx, r.box, false);\n         temp_cleanups += [r.box];\n         (r.bcx, r.body, r.box)\n       }\n-      for_send. {\n+      ty::closure_send. {\n         // Dummy up a box in the exchange heap.\n         let tup_ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n         let box_ty = ty::mk_uniq(tcx, {ty: tup_ty, mut: ast::imm});\n@@ -118,7 +177,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         add_clean_free(bcx, r.val, true);\n         dummy_environment_box(bcx, r)\n       }\n-      for_block. {\n+      ty::closure_block. {\n         // Dummy up a box on the stack,\n         let ty = ty::mk_tup(tcx, [ty::mk_int(tcx), closure_ty]);\n         let r = trans::alloc_ty(bcx, ty);\n@@ -127,30 +186,40 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n     };\n \n     // Store bindings tydesc.\n-    alt mode {\n-      for_closure. | for_send. {\n+    alt ck {\n+      ty::closure_shared. | ty::closure_send. {\n         let bound_tydesc = GEPi(bcx, closure, [0, abi::closure_elt_tydesc]);\n         let ti = none;\n         let tps = tps_fn(vec::len(lltydescs));\n-        let {result:bindings_tydesc, _} =\n-            trans::get_tydesc(bcx, bindings_ty, true, tps, ti);\n+        let {result:closure_td, _} =\n+            trans::get_tydesc(bcx, closure_ty, true, tps, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n         trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-        bcx = bindings_tydesc.bcx;\n-        let td = clone_tydesc(bcx, mode, bindings_tydesc.val);\n+        bcx = closure_td.bcx;\n+        let td = maybe_clone_tydesc(bcx, ck, closure_td.val);\n         Store(bcx, td, bound_tydesc);\n       }\n-      for_block. {}\n+      ty::closure_block. { /* skip this for blocks, not really relevant */ }\n+    }\n+\n+    check type_is_tup_like(bcx, closure_ty);\n+    let box_ty = ty::mk_imm_box(bcx_tcx(bcx), closure_ty);\n+\n+    // If necessary, copy tydescs describing type parameters into the\n+    // appropriate slot in the closure.\n+    let {bcx:bcx, val:ty_params_slot} =\n+        GEP_tup_like_1(bcx, closure_ty, closure,\n+                       [0, abi::closure_elt_ty_params]);\n+    vec::iter2(lltydescs) { |i, td|\n+        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n+        let cloned_td = maybe_clone_tydesc(bcx, ck, td);\n+        Store(bcx, cloned_td, ty_param_slot);\n     }\n \n     // Copy expr values into boxed bindings.\n     // Silly check\n-    check type_is_tup_like(bcx, closure_ty);\n-    let closure_box = box;\n-    let closure_box_ty = ty::mk_imm_box(bcx_tcx(bcx), closure_ty);\n-    let i = 0u;\n-    for bv in bound_values {\n-        let bound = trans::GEP_tup_like_1(bcx, closure_box_ty, closure_box,\n+    vec::iter2(bound_values) { |i, bv|\n+        let bound = trans::GEP_tup_like_1(bcx, box_ty, box,\n                                           [0, abi::box_rc_field_body,\n                                            abi::closure_elt_bindings,\n                                            i as int]);\n@@ -162,150 +231,89 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n             temp_cleanups += [bound.val];\n           }\n           env_direct(val, ty, is_mem) {\n-            alt mode {\n-              for_closure. | for_send. {\n+            alt ck {\n+              ty::closure_shared. | ty::closure_send. {\n                 let val1 = is_mem ? load_if_immediate(bcx, val, ty) : val;\n                 bcx = trans::copy_val(bcx, INIT, bound.val, val1, ty);\n               }\n-              for_block. {\n+              ty::closure_block. {\n                 let addr = is_mem ? val : do_spill_noroot(bcx, val);\n                 Store(bcx, addr, bound.val);\n               }\n             }\n           }\n         }\n-        i += 1u;\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n \n-    // If necessary, copy tydescs describing type parameters into the\n-    // appropriate slot in the closure.\n-    // Silly check as well\n-    //check type_is_tup_like(bcx, closure_ty);\n-    //let {bcx:bcx, val:n_ty_params_slot} =\n-    //    GEP_tup_like(bcx, closure_ty, closure,\n-    //                 [0, abi::closure_elt_n_ty_params]);\n-    //Store(bcx, C_uint(ccx, vec::len(lltydescs)), n_ty_params_slot);\n-    check type_is_tup_like(bcx, closure_ty);\n-    let {bcx:bcx, val:ty_params_slot} =\n-        GEP_tup_like(bcx, closure_ty, closure,\n-                     [0, abi::closure_elt_ty_params]);\n-    i = 0u;\n-    for td: ValueRef in lltydescs {\n-        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n-        let cloned_td = clone_tydesc(bcx, mode, td);\n-        Store(bcx, cloned_td, ty_param_slot);\n-        i += 1u;\n-    }\n-\n-    ret {ptr: box, ptrty: closure_ty, bcx: bcx};\n-}\n-\n-tag closure_constr_mode {\n-    for_block;\n-    for_closure;\n-    for_send;\n+    ret {llbox: box, box_ty: box_ty, bcx: bcx};\n }\n \n // Given a context and a list of upvars, build a closure. This just\n-// collects the upvars and packages them up for build_environment.\n+// collects the upvars and packages them up for store_environment.\n fn build_closure(cx: @block_ctxt,\n                  upvars: @[ast::def],\n-                 mode: closure_constr_mode)\n-    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+                 ck: ty::closure_kind)\n+    -> closure_result {\n     // If we need to, package up the iterator body to call\n     let env_vals = [];\n+    let tcx = bcx_tcx(cx);\n     // Package up the upvars\n-    for def in *upvars {\n+    vec::iter(*upvars) { |def|\n         let lv = trans_local_var(cx, def);\n         let nid = ast_util::def_id_of_def(def).node;\n-        let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n-        alt mode {\n-          for_block. { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n-          for_send. | for_closure. {}\n+        let ty = ty::node_id_to_monotype(tcx, nid);\n+        alt ck {\n+          ty::closure_block. { ty = ty::mk_mut_ptr(tcx, ty); }\n+          ty::closure_send. | ty::closure_shared. {}\n         }\n         env_vals += [env_direct(lv.val, ty, lv.kind == owned)];\n     }\n-    ret build_environment(cx, copy cx.fcx.lltydescs, env_vals, mode);\n-}\n-\n-// Return a pointer to the stored typarams in a closure.\n-// This is awful. Since the size of the bindings stored in the closure might\n-// be dynamically sized, we can't skip past them to get to the tydescs until\n-// we have loaded the tydescs. Thus we use the stored size of the bindings\n-// in the tydesc for the closure to skip over them. Ugh.\n-fn find_environment_tydescs(bcx: @block_ctxt, envty: ty::t, closure: ValueRef)\n-   -> ValueRef {\n-    ret if !ty::type_has_dynamic_size(bcx_tcx(bcx), envty) {\n-\n-            // If we can find the typarams statically, do it\n-            GEPi(bcx, closure,\n-                 [0, abi::box_rc_field_body, abi::closure_elt_ty_params])\n-        } else {\n-            // Ugh. We need to load the size of the bindings out of the\n-            // closure's tydesc and use that to skip over the bindings.\n-            let descsty =\n-                ty::get_element_type(bcx_tcx(bcx), envty,\n-                                     abi::closure_elt_ty_params as uint);\n-            let llenv = GEPi(bcx, closure, [0, abi::box_rc_field_body]);\n-            // Load the tydesc and find the size of the body\n-            let lldesc =\n-                Load(bcx, GEPi(bcx, llenv, [0, abi::closure_elt_tydesc]));\n-            let llsz =\n-                Load(bcx, GEPi(bcx, lldesc, [0, abi::tydesc_field_size]));\n-\n-            // Get the bindings pointer and add the size to it\n-            let llbinds = GEPi(bcx, llenv, [0, abi::closure_elt_bindings]);\n-            bump_ptr(bcx, descsty, llbinds, llsz)\n-        }\n+    ret store_environment(cx, copy cx.fcx.lltydescs, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: @block_ctxt, fcx: @fn_ctxt, envty: ty::t,\n-                    upvars: @[ast::def], mode: closure_constr_mode) {\n+fn load_environment(enclosing_cx: @block_ctxt,\n+                    fcx: @fn_ctxt,\n+                    boxed_closure_ty: ty::t,\n+                    upvars: @[ast::def],\n+                    ck: ty::closure_kind) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n-    let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n-\n     let ccx = bcx_ccx(bcx);\n     let sp = bcx.sp;\n-    // FIXME: should have postcondition on mk_imm_box,\n-    // so this check won't be necessary\n-    check (type_has_static_size(ccx, ty));\n-    let llty = type_of(ccx, sp, ty);\n+    check (type_has_static_size(ccx, boxed_closure_ty));\n+    let llty = type_of(ccx, sp, boxed_closure_ty);\n     let llclosure = PointerCast(bcx, fcx.llenv, llty);\n \n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n     let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n-    let lltydescs = find_environment_tydescs(bcx, envty, llclosure);\n-    let i = 0u;\n-    while i < tydesc_count {\n+    let lltydescs = GEPi(bcx, llclosure,\n+                         [0, abi::box_rc_field_body,\n+                          abi::closure_elt_ty_params]);\n+    uint::range(0u, tydesc_count) { |i|\n         let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n         fcx.lltydescs += [Load(bcx, lltydescptr)];\n-        i += 1u;\n     }\n \n     // Populate the upvars from the environment.\n     let path = [0, abi::box_rc_field_body, abi::closure_elt_bindings];\n-    i = 0u;\n-    // Load the actual upvars.\n-    for upvar_def in *upvars {\n-        // Silly check\n-        check type_is_tup_like(bcx, ty);\n-        let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n+    vec::iter2(*upvars) { |i, upvar_def|\n+        check type_is_tup_like(bcx, boxed_closure_ty);\n+        let upvarptr =\n+            GEP_tup_like(bcx, boxed_closure_ty, llclosure, path + [i as int]);\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n-        alt mode {\n-          for_block. { llupvarptr = Load(bcx, llupvarptr); }\n-          for_send. | for_closure. { }\n+        alt ck {\n+          ty::closure_block. { llupvarptr = Load(bcx, llupvarptr); }\n+          ty::closure_send. | ty::closure_shared. { }\n         }\n         let def_id = ast_util::def_id_of_def(upvar_def);\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n-        i += 1u;\n     }\n }\n \n@@ -320,28 +328,26 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let mode = alt f.proto {\n-      ast::proto_shared(_) { for_closure }\n-      ast::proto_send. { for_send }\n-      ast::proto_bare. | ast::proto_block. { for_block }\n-    };\n-    let env;\n-    alt f.proto {\n-      ast::proto_block. | ast::proto_shared(_) | ast::proto_send. {\n+    let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n         let upvars = get_freevars(ccx.tcx, id);\n-        let env_r = build_closure(bcx, upvars, mode);\n-        env = env_r.ptr;\n-        bcx = env_r.bcx;\n+        let {llbox, box_ty, bcx} = build_closure(bcx, upvars, ck);\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n-            load_environment(bcx, fcx, env_r.ptrty, upvars, mode);\n+            load_environment(bcx, fcx, box_ty, upvars, ck);\n         });\n-      }\n+        llbox\n+    };\n+\n+    let closure = alt f.proto {\n+      ast::proto_block. { trans_closure_env(ty::closure_block) }\n+      ast::proto_shared(_) { trans_closure_env(ty::closure_shared) }\n+      ast::proto_send. { trans_closure_env(ty::closure_send) }\n       ast::proto_bare. {\n-        env = C_null(T_opaque_closure_ptr(ccx));\n+        let closure = C_null(T_opaque_boxed_closure_ptr(ccx));\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n+        closure\n       }\n     };\n-    fill_fn_pair(bcx, get_dest_addr(dest), llfn, env);\n+    fill_fn_pair(bcx, get_dest_addr(dest), llfn, closure);\n     ret bcx;\n }\n \n@@ -410,18 +416,271 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     };\n \n     // Actually construct the closure\n-    let closure = build_environment(bcx, lltydescs, env_vals +\n-                                    vec::map({|x| env_expr(x)}, bound),\n-                                    for_closure);\n-    bcx = closure.bcx;\n+    let {llbox, box_ty, bcx} = store_environment(\n+        bcx, lltydescs,\n+        env_vals + vec::map({|x| env_expr(x)}, bound),\n+        ty::closure_shared);\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         closure.ptrty, ty_param_count, target_res);\n+                         box_ty, ty_param_count, target_res);\n \n     // Fill the function pair\n-    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, closure.ptr);\n+    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n     ret bcx;\n }\n \n+fn make_fn_glue(\n+    cx: @block_ctxt,\n+    v: ValueRef,\n+    t: ty::t,\n+    glue_fn: fn(@block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt)\n+    -> @block_ctxt {\n+    let bcx = cx;\n+    let tcx = bcx_tcx(cx);\n+\n+    let fn_env = lambda(blk: block(@block_ctxt, ValueRef) -> @block_ctxt)\n+        -> @block_ctxt {\n+        let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n+        let box_ptr_v = Load(cx, box_cell_v);\n+        let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n+        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let null_test = IsNull(cx, box_ptr_v);\n+        CondBr(cx, null_test, next_cx.llbb, inner_cx.llbb);\n+        inner_cx = blk(inner_cx, box_cell_v);\n+        Br(inner_cx, next_cx.llbb);\n+        ret next_cx;\n+    };\n+\n+    ret alt ty::struct(tcx, t) {\n+      ty::ty_native_fn(_, _) | ty::ty_fn(ast::proto_bare., _, _, _, _) {\n+        bcx\n+      }\n+      ty::ty_fn(ast::proto_block., _, _, _, _) {\n+        bcx\n+      }\n+      ty::ty_fn(ast::proto_send., _, _, _, _) {\n+        fn_env({ |bcx, box_cell_v|\n+            let box_ty = trans_closure::send_opaque_closure_box_ty(tcx);\n+            glue_fn(bcx, box_cell_v, box_ty)\n+        })\n+      }\n+      ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n+        fn_env({ |bcx, box_cell_v|\n+            let box_ty = trans_closure::shared_opaque_closure_box_ty(tcx);\n+            glue_fn(bcx, box_cell_v, box_ty)\n+        })\n+      }\n+      _ { fail \"make_fn_glue invoked on non-function type\" }\n+    };\n+}\n+\n+fn call_opaque_closure_glue(bcx: @block_ctxt,\n+                            v: ValueRef,     // ptr to an opaque closure\n+                            field: int) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n+    let v = PointerCast(bcx, v, T_ptr(T_opaque_closure(ccx)));\n+    let tydescptr = GEPi(bcx, v, [0, abi::closure_elt_tydesc]);\n+    let tydesc = Load(bcx, tydescptr);\n+    let ti = none;\n+    call_tydesc_glue_full(bcx, v, tydesc, field, ti);\n+    ret bcx;\n+}\n+\n+// pth is cx.path\n+fn trans_bind_thunk(cx: @local_ctxt,\n+                    sp: span,\n+                    incoming_fty: ty::t,\n+                    outgoing_fty: ty::t,\n+                    args: [option::t<@ast::expr>],\n+                    boxed_closure_ty: ty::t,\n+                    ty_param_count: uint,\n+                    target_fn: option::t<ValueRef>)\n+    -> {val: ValueRef, ty: TypeRef} {\n+    // If we supported constraints on record fields, we could make the\n+    // constraints for this function:\n+    /*\n+    : returns_non_ty_var(ccx, outgoing_fty),\n+      type_has_static_size(ccx, incoming_fty) ->\n+    */\n+    // but since we don't, we have to do the checks at the beginning.\n+    let ccx = cx.ccx;\n+    check type_has_static_size(ccx, incoming_fty);\n+\n+    // Here we're not necessarily constructing a thunk in the sense of\n+    // \"function with no arguments\".  The result of compiling 'bind f(foo,\n+    // bar, baz)' would be a thunk that, when called, applies f to those\n+    // arguments and returns the result.  But we're stretching the meaning of\n+    // the word \"thunk\" here to also mean the result of compiling, say, 'bind\n+    // f(foo, _, baz)', or any other bind expression that binds f and leaves\n+    // some (or all) of the arguments unbound.\n+\n+    // Here, 'incoming_fty' is the type of the entire bind expression, while\n+    // 'outgoing_fty' is the type of the function that is having some of its\n+    // arguments bound.  If f is a function that takes three arguments of type\n+    // int and returns int, and we're translating, say, 'bind f(3, _, 5)',\n+    // then outgoing_fty is the type of f, which is (int, int, int) -> int,\n+    // and incoming_fty is the type of 'bind f(3, _, 5)', which is int -> int.\n+\n+    // Once translated, the entire bind expression will be the call f(foo,\n+    // bar, baz) wrapped in a (so-called) thunk that takes 'bar' as its\n+    // argument and that has bindings of 'foo' to 3 and 'baz' to 5 and a\n+    // pointer to 'f' all saved in its environment.  So, our job is to\n+    // construct and return that thunk.\n+\n+    // Give the thunk a name, type, and value.\n+    let s: str = mangle_internal_name_by_path_and_seq(ccx, cx.path, \"thunk\");\n+    let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, sp, incoming_fty));\n+    let llthunk: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n+\n+    // Create a new function context and block context for the thunk, and hold\n+    // onto a pointer to the first block in the function for later use.\n+    let fcx = new_fn_ctxt(cx, sp, llthunk);\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+    // Since we might need to construct derived tydescs that depend on\n+    // our bound tydescs, we need to load tydescs out of the environment\n+    // before derived tydescs are constructed. To do this, we load them\n+    // in the load_env block.\n+    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+\n+    // The 'llenv' that will arrive in the thunk we're creating is an\n+    // environment that will contain the values of its arguments and a pointer\n+    // to the original function.  So, let's create one of those:\n+\n+    // The llenv pointer needs to be the correct size.  That size is\n+    // 'boxed_closure_ty', which was determined by trans_bind.\n+    check (type_has_static_size(ccx, boxed_closure_ty));\n+    let llclosure_ptr_ty = type_of(ccx, sp, boxed_closure_ty);\n+    let llclosure = PointerCast(load_env_bcx, fcx.llenv, llclosure_ptr_ty);\n+\n+    // \"target\", in this context, means the function that's having some of its\n+    // arguments bound and that will be called inside the thunk we're\n+    // creating.  (In our running example, target is the function f.)  Pick\n+    // out the pointer to the target function from the environment. The\n+    // target function lives in the first binding spot.\n+    let (lltargetfn, lltargetenv, starting_idx) = alt target_fn {\n+      some(fptr) {\n+        (fptr, llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(ccx)), 0)\n+      }\n+      none. {\n+        // Silly check\n+        check type_is_tup_like(bcx, boxed_closure_ty);\n+        let {bcx: cx, val: pair} =\n+            GEP_tup_like(bcx, boxed_closure_ty, llclosure,\n+                         [0, abi::box_rc_field_body,\n+                          abi::closure_elt_bindings, 0]);\n+        let lltargetenv =\n+            Load(cx, GEPi(cx, pair, [0, abi::fn_field_box]));\n+        let lltargetfn = Load\n+            (cx, GEPi(cx, pair, [0, abi::fn_field_code]));\n+        bcx = cx;\n+        (lltargetfn, lltargetenv, 1)\n+      }\n+    };\n+\n+    // And then, pick out the target function's own environment.  That's what\n+    // we'll use as the environment the thunk gets.\n+\n+    // Get f's return type, which will also be the return type of the entire\n+    // bind expression.\n+    let outgoing_ret_ty = ty::ty_fn_ret(cx.ccx.tcx, outgoing_fty);\n+\n+    // Get the types of the arguments to f.\n+    let outgoing_args = ty::ty_fn_args(cx.ccx.tcx, outgoing_fty);\n+\n+    // The 'llretptr' that will arrive in the thunk we're creating also needs\n+    // to be the correct type.  Cast it to f's return type, if necessary.\n+    let llretptr = fcx.llretptr;\n+    let ccx = cx.ccx;\n+    if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n+        check non_ty_var(ccx, outgoing_ret_ty);\n+        let llretty = type_of_inner(ccx, sp, outgoing_ret_ty);\n+        llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n+    }\n+\n+    // Set up the three implicit arguments to the thunk.\n+    let llargs: [ValueRef] = [llretptr, lltargetenv];\n+\n+    // Copy in the type parameters.\n+    let i: uint = 0u;\n+    while i < ty_param_count {\n+        // Silly check\n+        check type_is_tup_like(load_env_bcx, boxed_closure_ty);\n+        let lltyparam_ptr =\n+            GEP_tup_like(load_env_bcx, boxed_closure_ty, llclosure,\n+                         [0, abi::box_rc_field_body,\n+                          abi::closure_elt_ty_params, i as int]);\n+        load_env_bcx = lltyparam_ptr.bcx;\n+        let td = Load(load_env_bcx, lltyparam_ptr.val);\n+        llargs += [td];\n+        fcx.lltydescs += [td];\n+        i += 1u;\n+    }\n+\n+    let a: uint = 2u; // retptr, env come first\n+    let b: int = starting_idx;\n+    let outgoing_arg_index: uint = 0u;\n+    let llout_arg_tys: [TypeRef] =\n+        type_of_explicit_args(cx.ccx, sp, outgoing_args);\n+    for arg: option::t<@ast::expr> in args {\n+        let out_arg = outgoing_args[outgoing_arg_index];\n+        let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n+        alt arg {\n+          // Arg provided at binding time; thunk copies it from\n+          // closure.\n+          some(e) {\n+            // Silly check\n+            check type_is_tup_like(bcx, boxed_closure_ty);\n+            let bound_arg =\n+                GEP_tup_like(bcx, boxed_closure_ty, llclosure,\n+                             [0, abi::box_rc_field_body,\n+                              abi::closure_elt_bindings, b]);\n+            bcx = bound_arg.bcx;\n+            let val = bound_arg.val;\n+            if out_arg.mode == ast::by_val { val = Load(bcx, val); }\n+            if out_arg.mode == ast::by_copy {\n+                let {bcx: cx, val: alloc} = alloc_ty(bcx, out_arg.ty);\n+                bcx = memmove_ty(cx, alloc, val, out_arg.ty);\n+                bcx = take_ty(bcx, alloc, out_arg.ty);\n+                val = alloc;\n+            }\n+            // If the type is parameterized, then we need to cast the\n+            // type we actually have to the parameterized out type.\n+            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n+                val = PointerCast(bcx, val, llout_arg_ty);\n+            }\n+            llargs += [val];\n+            b += 1;\n+          }\n+\n+          // Arg will be provided when the thunk is invoked.\n+          none. {\n+            let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n+            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n+                arg = PointerCast(bcx, arg, llout_arg_ty);\n+            }\n+            llargs += [arg];\n+            a += 1u;\n+          }\n+        }\n+        outgoing_arg_index += 1u;\n+    }\n+\n+    // Cast the outgoing function to the appropriate type.\n+    // This is necessary because the type of the function that we have\n+    // in the closure does not know how many type descriptors the function\n+    // needs to take.\n+    let ccx = bcx_ccx(bcx);\n+\n+    check returns_non_ty_var(ccx, outgoing_fty);\n+    let lltargetty =\n+        type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n+    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n+    Call(bcx, lltargetfn, llargs);\n+    build_return(bcx);\n+    finish_fn(fcx, lltop);\n+    ret {val: llthunk, ty: llthunk_ty};\n+}\n+"}, {"sha": "889ba2e44a12f1e79fa8ace08473f3484aeaf94e", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -536,7 +536,7 @@ fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n-    ret T_struct([T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n+    ret T_struct([T_ptr(tfn), T_opaque_boxed_closure_ptr(cx)]);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n@@ -688,21 +688,34 @@ fn T_typaram(tn: type_names) -> TypeRef {\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(cx: @crate_ctxt, llbindings_ty: TypeRef,\n-                 n_ty_params: uint) -> TypeRef {\n+fn T_closure(cx: @crate_ctxt,\n+             llbindings_ty: TypeRef,\n+             n_ty_params: uint) -> TypeRef {\n+    ret T_struct([T_ptr(cx.tydesc_type),\n+                  T_captured_tydescs(cx, n_ty_params),\n+                  llbindings_ty])\n+}\n+\n+fn T_opaque_closure(cx: @crate_ctxt) -> TypeRef {\n+    let s = \"closure\";\n+    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    let t = T_closure(cx, T_nil(), 0u);\n+    cx.tn.associate(s, t);\n+    ret t;\n+}\n+\n+fn T_boxed_closure_ptr(cx: @crate_ctxt, llbindings_ty: TypeRef,\n+                     n_ty_params: uint) -> TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n-    ret T_ptr(T_box(cx, T_struct([T_ptr(cx.tydesc_type),\n-                                  llbindings_ty,\n-                                  //cx.int_type,\n-                                  T_captured_tydescs(cx, n_ty_params)])));\n+    ret T_ptr(T_box(cx, T_closure(cx, llbindings_ty, n_ty_params)));\n }\n \n-fn T_opaque_closure_ptr(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_boxed_closure_ptr(cx: @crate_ctxt) -> TypeRef {\n     let s = \"*closure\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n-    let t = T_closure_ptr(cx, T_nil(), 0u);\n+    let t = T_boxed_closure_ptr(cx, T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }"}, {"sha": "4637a85f71860ed31180ce90aa0cadff05eb7d32", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -85,9 +85,11 @@ export mk_rec;\n export mk_tag;\n export mk_tup;\n export mk_type;\n+export mk_send_type;\n export mk_uint;\n export mk_uniq;\n export mk_var;\n+export mk_opaque_closure;\n export mode;\n export mt;\n export node_type_table;\n@@ -114,6 +116,7 @@ export ty_bool;\n export ty_bot;\n export ty_box;\n export ty_constr;\n+export ty_opaque_closure;\n export ty_constr_arg;\n export ty_float;\n export ty_fn;\n@@ -134,6 +137,7 @@ export ty_tag;\n export ty_to_machine_ty;\n export ty_tup;\n export ty_type;\n+export ty_send_type;\n export ty_uint;\n export ty_uniq;\n export ty_var;\n@@ -179,6 +183,10 @@ export unify;\n export variant_info;\n export walk_ty;\n export occurs_check_fails;\n+export closure_kind;\n+export closure_block;\n+export closure_shared;\n+export closure_send;\n \n // Data types\n \n@@ -249,6 +257,12 @@ type raw_t =\n \n type t = uint;\n \n+tag closure_kind {\n+    closure_block;\n+    closure_shared;\n+    closure_send;\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n tag sty {\n@@ -274,10 +288,11 @@ tag sty {\n \n     ty_param(uint, ast::kind); // fn/tag type param\n \n-    ty_type;\n+    ty_type; // type_desc*\n+    ty_send_type; // type_desc* that has been cloned into exchange heap\n     ty_native(def_id);\n     ty_constr(t, [@type_constr]);\n-    // TODO: ty_fn_arg(t), for a possibly-aliased function argument\n+    ty_opaque_closure; // type of a captured environment.\n }\n \n // In the middle end, constraints have a def_id attached, referring\n@@ -344,9 +359,13 @@ const idx_str: uint = 16u;\n \n const idx_type: uint = 17u;\n \n-const idx_bot: uint = 18u;\n+const idx_send_type: uint = 18u;\n+\n+const idx_bot: uint = 19u;\n \n-const idx_first_others: uint = 19u;\n+const idx_opaque_closure: uint = 20u;\n+\n+const idx_first_others: uint = 21u;\n \n type type_store = interner::interner<@raw_t>;\n \n@@ -374,7 +393,9 @@ fn populate_type_store(cx: ctxt) {\n     intern(cx, ty_int(ast::ty_char), none);\n     intern(cx, ty_str, none);\n     intern(cx, ty_type, none);\n+    intern(cx, ty_send_type, none);\n     intern(cx, ty_bot, none);\n+    intern(cx, ty_opaque_closure, none);\n     assert (vec::len(cx.ts.vect) == idx_first_others);\n }\n \n@@ -443,7 +464,9 @@ fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n     }\n     alt st {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+        /* no-op */\n+      }\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n       ty_tag(_, tys) {\n@@ -600,8 +623,14 @@ fn mk_param(cx: ctxt, n: uint, k: ast::kind) -> t {\n \n fn mk_type(_cx: ctxt) -> t { ret idx_type; }\n \n+fn mk_send_type(_cx: ctxt) -> t { ret idx_send_type; }\n+\n fn mk_native(cx: ctxt, did: def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n+fn mk_opaque_closure(_cx: ctxt) -> t {\n+    ret idx_opaque_closure;\n+}\n+\n // Returns the one-level-deep type structure of the given type.\n pure fn struct(cx: ctxt, typ: t) -> sty { interner::get(*cx.ts, typ).struct }\n \n@@ -618,7 +647,9 @@ type ty_walk = fn@(t);\n fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+        /* no-op */\n+      }\n       ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_tag(tid, subtys) {\n         for subty: t in subtys { walk_ty(cx, walker, subty); }\n@@ -670,7 +701,9 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     }\n     alt struct(cx, ty) {\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n+      ty_str. | ty_send_type. | ty_type. | ty_native(_) | ty_opaque_closure. {\n+        /* no-op */\n+      }\n       ty_box(tm) {\n         ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -799,11 +832,7 @@ fn type_is_structural(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n-    ret alt struct(cx, ty) {\n-          ty_res(_, _, _) { false }\n-          ty_fn(proto_block., _, _, _, _) { false }\n-          _ { true }\n-        };\n+    ret ast::kind_can_be_copied(type_kind(cx, ty));\n }\n \n fn type_is_sequence(cx: ctxt, ty: t) -> bool {\n@@ -896,7 +925,7 @@ pure fn type_is_unique(cx: ctxt, ty: t) -> bool {\n pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_nil. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type. | ty_native(_) | ty_ptr(_) { true }\n+      ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { true }\n       _ { false }\n     }\n }\n@@ -970,20 +999,13 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       // Scalar and unique types are sendable\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_native(_) | ty_ptr(_) |\n-      ty_type. | ty_str. | ty_native_fn(_, _) { ast::kind_sendable }\n+      ty_send_type. | ty_str. | ty_native_fn(_, _) { ast::kind_sendable }\n+      ty_type. { kind_copyable }\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n-      // FIXME: the environment capture mode is not fully encoded\n-      // here yet, leading to weirdness around closure.\n-      ty_fn(proto, _, _, _, _) {\n-        alt proto {\n-          ast::proto_block. { ast::kind_noncopyable }\n-          ast::proto_shared(_) { ast::kind_copyable }\n-          ast::proto_send. { ast::kind_sendable }\n-          ast::proto_bare. { ast::kind_sendable }\n-        }\n-      }\n+      ty_fn(proto, _, _, _, _) { ast::proto_kind(proto) }\n+      ty_opaque_closure. { kind_noncopyable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) { ast::kind_copyable }\n@@ -1151,7 +1173,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       // Scalar types\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n+      ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n       ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _) | ty_obj(_) {\n@@ -1250,6 +1272,13 @@ fn hash_type_structure(st: sty) -> uint {\n         h += (h << 5u) + hash_ty(subty);\n         ret h;\n     }\n+    fn hash_subtys(id: uint, subtys: [t]) -> uint {\n+        let h = id;\n+        vec::iter(subtys) { |subty|\n+            h = hash_subty(h, subty);\n+        }\n+        ret h;\n+    }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let h = id;\n         h += (h << 5u) + hash_def(h, c.node.id);\n@@ -1309,11 +1338,7 @@ fn hash_type_structure(st: sty) -> uint {\n         for f: field in fields { h += (h << 5u) + hash_ty(f.mt.ty); }\n         ret h;\n       }\n-      ty_tup(ts) {\n-        let h = 25u;\n-        for tt in ts { h += (h << 5u) + hash_ty(tt); }\n-        ret h;\n-      }\n+      ty_tup(ts) { ret hash_subtys(25u, ts); }\n \n       // ???\n       ty_fn(_, args, rty, _, _) {\n@@ -1333,15 +1358,16 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n       ty_res(did, sub, tps) {\n         let h = hash_subty(hash_def(18u, did), sub);\n-        for tp: t in tps { h += (h << 5u) + hash_ty(tp); }\n-        ret h;\n+        ret hash_subtys(h, tps);\n       }\n       ty_constr(t, cs) {\n         let h = 36u;\n         for c: @type_constr in cs { h += (h << 5u) + hash_type_constr(h, c); }\n         ret h;\n       }\n-      ty_uniq(mt) { let h = 37u; h += (h << 5u) + hash_ty(mt.ty); ret h; }\n+      ty_uniq(mt) { ret hash_subty(37u, mt.ty); }\n+      ty_send_type. { ret 38u; }\n+      ty_opaque_closure. { ret 39u; }\n     }\n }\n \n@@ -2213,7 +2239,7 @@ mod unify {\n             ret ures_ok(actual);\n           }\n           ty::ty_bool. | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty::ty_str. | ty::ty_type. {\n+          ty::ty_str. | ty::ty_type. | ty::ty_send_type. {\n             ret struct_cmp(cx, expected, actual);\n           }\n           ty::ty_native(ex_id) {"}, {"sha": "f05751ae08105b47da476968e0c63b0ceb173f78", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -137,6 +137,15 @@ tag proto {\n     proto_block;\n }\n \n+fn proto_kind(p: proto) -> kind {\n+    alt p {\n+      ast::proto_block. { ast::kind_noncopyable }\n+      ast::proto_shared(_) { ast::kind_copyable }\n+      ast::proto_send. { ast::kind_sendable }\n+      ast::proto_bare. { ast::kind_sendable }\n+    }\n+}\n+\n tag binop {\n     add;\n     sub;"}, {"sha": "c4d9eb6a5a4248bf3cf738d49a176aa189764037", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -23,7 +23,6 @@ const uint8_t CMP_EQ = 0u;\n const uint8_t CMP_LT = 1u;\n const uint8_t CMP_LE = 2u;\n \n-\n // Type parameters\n \n type_param *\n@@ -50,9 +49,11 @@ type_param::make(const type_desc **tydescs, unsigned n_tydescs,\n type_param *\n type_param::from_fn_shape(const uint8_t *sp, ptr dp, arena &arena) {\n     const type_desc *tydesc = bump_dp<const type_desc *>(dp);\n-    const type_desc **descs = (const type_desc **)(dp + tydesc->size);\n+    const type_desc **tydescs = (const type_desc **)dp;\n     unsigned n_tydescs = tydesc->n_obj_params & 0x7fffffff;\n-    return make(descs, n_tydescs, arena);\n+    for (unsigned i = 0; i < n_tydescs; i++)\n+        bump_dp<const type_desc*>(dp);\n+    return make(tydescs, n_tydescs, arena);\n }\n \n // Constructs type parameters from an object shape. This is also a bit messy,\n@@ -250,7 +251,6 @@ size_of::walk_struct(const uint8_t *end_sp) {\n     sa = struct_sa;\n }\n \n-\n // Copy constructors\n \n #if 0"}, {"sha": "e6f3cfcd3d3b13335173e4f74005b2e7a5f13a6c", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -336,16 +336,13 @@ class type_param {\n                        (unsigned long)n_obj_params, tydesc,\n                        dp + sizeof(uintptr_t) + tydesc->size);\n                 n_obj_params &= 0x7fffffff;\n-                // FIXME: Is this right?\n-                first_param = (const type_desc **)\n-                    (dp + sizeof(uintptr_t) + tydesc->size);\n+                first_param = (const type_desc **)(dp + sizeof(uintptr_t));\n             } else {\n                 // Object closure.\n                 DPRINT(\"n_obj_params OBJ %lu, tydesc %p, starting at %p\\n\",\n                        (unsigned long)n_obj_params, tydesc,\n                        dp + sizeof(uintptr_t) * 2);\n-                first_param = (const type_desc **)\n-                    (dp + sizeof(uintptr_t) * 2);\n+                first_param = (const type_desc **)(dp + sizeof(uintptr_t) * 2);\n             }\n             return make(first_param, n_obj_params, arena);\n         }\n@@ -568,6 +565,7 @@ class print : public ctxt<print> {\n \n     void walk_fn()  { DPRINT(\"fn\"); }\n     void walk_obj() { DPRINT(\"obj\"); }\n+    void walk_closure();\n \n     template<typename T>\n     void walk_number() {}\n@@ -612,6 +610,7 @@ class size_of : public ctxt<size_of> {\n     void walk_box()     { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_fn()      { sa.set(sizeof(void *)*2, sizeof(void *)); }\n     void walk_obj()     { sa.set(sizeof(void *)*2, sizeof(void *)); }\n+    void walk_closure();\n \n     void walk_vec(bool is_pod, uint16_t sp_size) {\n         sa.set(sizeof(void *), sizeof(void *));"}, {"sha": "0c015f13d05b959e97c7ab3acbee01e323e83cb2", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 91, "deletions": 38, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -18,10 +18,11 @@\n \n extern \"C\" void record_sp(void *limit);\n \n-/**\n+/**********************************************************************\n  * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n  * This is used by the C compiler to call native functions and by other\n- * upcalls to switch to the C stack.\n+ * upcalls to switch to the C stack.  The return value is passed through a\n+ * field in the args parameter.\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n@@ -44,6 +45,8 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n     task->record_stack_limit();\n }\n \n+/**********************************************************************/\n+\n struct s_fail_args {\n     char const *expr;\n     char const *file;\n@@ -67,6 +70,10 @@ upcall_fail(char const *expr,\n     SWITCH_STACK(&args, upcall_s_fail);\n }\n \n+/**********************************************************************\n+ * Allocate an object in the task-local heap.\n+ */\n+\n struct s_malloc_args {\n     uintptr_t retval;\n     size_t nbytes;\n@@ -107,6 +114,10 @@ upcall_malloc(size_t nbytes, type_desc *td) {\n     return args.retval;\n }\n \n+/**********************************************************************\n+ * Called whenever an object in the task-local heap is freed.\n+ */\n+\n struct s_free_args {\n     void *ptr;\n     uintptr_t is_gc;\n@@ -128,15 +139,16 @@ upcall_s_free(s_free_args *args) {\n     task->free(args->ptr, (bool) args->is_gc);\n }\n \n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n extern \"C\" CDECL void\n upcall_free(void* ptr, uintptr_t is_gc) {\n     s_free_args args = {ptr, is_gc};\n     SWITCH_STACK(&args, upcall_s_free);\n }\n \n+/**********************************************************************\n+ * Allocate an object in the exchange heap.\n+ */\n+\n struct s_shared_malloc_args {\n     uintptr_t retval;\n     size_t nbytes;\n@@ -167,13 +179,14 @@ upcall_shared_malloc(size_t nbytes, type_desc *td) {\n     return args.retval;\n }\n \n+/**********************************************************************\n+ * Called whenever an object in the exchange heap is freed.\n+ */\n+\n struct s_shared_free_args {\n     void *ptr;\n };\n \n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n extern \"C\" CDECL void\n upcall_s_shared_free(s_shared_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n@@ -186,21 +199,25 @@ upcall_s_shared_free(s_shared_free_args *args) {\n     task->kernel->free(args->ptr);\n }\n \n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n extern \"C\" CDECL void\n upcall_shared_free(void* ptr) {\n     s_shared_free_args args = {ptr};\n     SWITCH_STACK(&args, upcall_s_shared_free);\n }\n \n-struct s_clone_type_desc_args {\n+/**********************************************************************\n+ * Called to deep copy a type descriptor onto the exchange heap.\n+ * Used when sending closures.  It's possible that we should have\n+ * a central hashtable to avoid copying and re-copying the same \n+ * type descriptors.\n+ */\n+\n+struct s_create_shared_type_desc_args {\n     const type_desc *td;\n     type_desc *res;\n };\n \n-void upcall_s_clone_type_desc(s_clone_type_desc_args *args)\n+void upcall_s_create_shared_type_desc(s_create_shared_type_desc_args *args)\n {\n     rust_task *task = rust_scheduler::get_task();\n     LOG_UPCALL_ENTRY(task);\n@@ -209,28 +226,57 @@ void upcall_s_clone_type_desc(s_clone_type_desc_args *args)\n     const type_desc *td = args->td;\n     int n_descs = td->n_descs;\n     size_t sz = sizeof(type_desc) + sizeof(type_desc*) * n_descs;\n-    args->res = (type_desc*) task->kernel->malloc(sz, \"clone_type_desc\");\n+    args->res = (type_desc*) task->kernel->malloc(sz, \"create_shared_type_desc\");\n     memcpy(args->res, td, sizeof(type_desc));\n \n     // Recursively copy any referenced descriptors:\n-    for (int i = 0; i < n_descs; i++) {\n-        s_clone_type_desc_args rec_args = { td->descs[i], 0 };\n-        upcall_s_clone_type_desc(&rec_args);\n-        args->res->descs[i] = rec_args.res;\n+    if (n_descs == 0) {\n+        args->res->first_param = NULL;\n+    } else {\n+        args->res->first_param = &args->res->descs[1];\n+        args->res->descs[0] = args->res;\n+        for (int i = 1; i < n_descs; i++) {\n+            s_create_shared_type_desc_args rec_args = { td->descs[i], 0 };\n+            upcall_s_create_shared_type_desc(&rec_args);\n+            args->res->descs[i] = rec_args.res;\n+        }\n     }\n }\n \n-/**\n- * Called to deep-clone type descriptors so they can be attached to a sendable\n- * function.  Eventually this should perhaps move to a centralized hashtable.\n- */\n extern \"C\" CDECL type_desc *\n-upcall_clone_type_desc(type_desc *td) {\n-    s_clone_type_desc_args args = { td, 0 };\n-    SWITCH_STACK(&args, upcall_s_clone_type_desc);\n+upcall_create_shared_type_desc(type_desc *td) {\n+    s_create_shared_type_desc_args args = { td, 0 };\n+    SWITCH_STACK(&args, upcall_s_create_shared_type_desc);\n     return args.res;\n }\n \n+/**********************************************************************\n+ * Called to deep free a type descriptor from the exchange heap.\n+ */\n+\n+void upcall_s_free_shared_type_desc(type_desc *td)\n+{\n+    rust_task *task = rust_scheduler::get_task();\n+    LOG_UPCALL_ENTRY(task);\n+\n+    // Recursively free any referenced descriptors:\n+    for (unsigned i = 1; i < td->n_descs; i++) {\n+        upcall_s_free_shared_type_desc((type_desc*) td->descs[i]);\n+    }\n+\n+    task->kernel->free(td);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_free_shared_type_desc(type_desc *td) {\n+    SWITCH_STACK(td, upcall_s_free_shared_type_desc);\n+}\n+\n+/**********************************************************************\n+ * Called to intern a task-local type descriptor into the hashtable\n+ * associated with each scheduler.\n+ */\n+\n struct s_get_type_desc_args {\n     type_desc *retval;\n     size_t size;\n@@ -267,6 +313,8 @@ upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n     return args.retval;\n }\n \n+/**********************************************************************/\n+\n struct s_vec_grow_args {\n     rust_vec** vp;\n     size_t new_sz;\n@@ -305,6 +353,8 @@ copy_elements(rust_task *task, type_desc *elem_t,\n     }\n }\n \n+/**********************************************************************/\n+\n struct s_vec_push_args {\n     rust_vec** vp;\n     type_desc* elt_ty;\n@@ -331,6 +381,11 @@ upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n     upcall_s_vec_push(&args);\n }\n \n+/**********************************************************************\n+ * Returns a token that can be used to deallocate all of the allocated space\n+ * space in the dynamic stack.\n+ */\n+\n struct s_dynastack_mark_args {\n     void *retval;\n };\n@@ -340,17 +395,19 @@ upcall_s_dynastack_mark(s_dynastack_mark_args *args) {\n     args->retval = rust_scheduler::get_task()->dynastack.mark();\n }\n \n-/**\n- * Returns a token that can be used to deallocate all of the allocated space\n- * space in the dynamic stack.\n- */\n extern \"C\" CDECL void *\n upcall_dynastack_mark() {\n     s_dynastack_mark_args args = {0};\n     SWITCH_STACK(&args, upcall_s_dynastack_mark);\n     return args.retval;\n }\n \n+/**********************************************************************\n+ * Allocates space in the dynamic stack and returns it.\n+ *\n+ * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n+ */\n+\n struct s_dynastack_alloc_args {\n     void *retval;\n     size_t sz;\n@@ -363,18 +420,18 @@ upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n         rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n-/**\n- * Allocates space in the dynamic stack and returns it.\n- *\n- * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n- */\n extern \"C\" CDECL void *\n upcall_dynastack_alloc(size_t sz) {\n     s_dynastack_alloc_args args = {0, sz};\n     SWITCH_STACK(&args, upcall_s_dynastack_alloc);\n     return args.retval;\n }\n \n+/**********************************************************************\n+ * Allocates space associated with a type descriptor in the dynamic stack and\n+ * returns it.\n+ */\n+\n struct s_dynastack_alloc_2_args {\n     void *retval;\n     size_t sz;\n@@ -389,10 +446,6 @@ upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n         rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n-/**\n- * Allocates space associated with a type descriptor in the dynamic stack and\n- * returns it.\n- */\n extern \"C\" CDECL void *\n upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n     s_dynastack_alloc_2_args args = {0, sz, ty};"}, {"sha": "c1365f1685d5583602a5e413d6bcb98ee199ab6c", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/1e3259e119b6370267415b9e07f3ea80869f839d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=1e3259e119b6370267415b9e07f3ea80869f839d", "patch": "@@ -58,7 +58,8 @@ upcall_dynastack_free\n upcall_dynastack_mark\n upcall_fail\n upcall_free\n-upcall_clone_type_desc\n+upcall_create_shared_type_desc\n+upcall_free_shared_type_desc\n upcall_get_type_desc\n upcall_log_type\n upcall_malloc"}]}