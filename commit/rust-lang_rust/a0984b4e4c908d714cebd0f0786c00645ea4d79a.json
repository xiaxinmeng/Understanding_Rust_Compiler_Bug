{"sha": "a0984b4e4c908d714cebd0f0786c00645ea4d79a", "node_id": "C_kwDOAAsO6NoAKGEwOTg0YjRlNGM5MDhkNzE0Y2ViZDBmMDc4NmMwMDY0NWVhNGQ3OWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-16T02:18:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-16T02:18:42Z"}, "message": "Auto merge of #92598 - Badel2:panic-update-hook, r=yaahc\n\nImplement `panic::update_hook`\n\nAdd a new function `panic::update_hook` to allow creating panic hooks that forward the call to the previously set panic hook, without race conditions. It works by taking a closure that transforms the old panic hook into a new one, while ensuring that during the execution of the closure no other thread can modify the panic hook. This is a small function so I hope it can be discussed here without a formal RFC, however if you prefer I can write one.\n\nConsider the following example:\n\n```rust\nlet prev = panic::take_hook();\npanic::set_hook(Box::new(move |info| {\n    println!(\"panic handler A\");\n    prev(info);\n}));\n```\n\nThis is a common pattern in libraries that need to do something in case of panic: log panic to a file, record code coverage, send panic message to a monitoring service, print custom message with link to github to open a new issue, etc. However it is impossible to avoid race conditions with the current API, because two threads can execute in this order:\n\n* Thread A calls `panic::take_hook()`\n* Thread B calls `panic::take_hook()`\n* Thread A calls `panic::set_hook()`\n* Thread B calls `panic::set_hook()`\n\nAnd the result is that the original panic hook has been lost, as well as the panic hook set by thread A. The resulting panic hook will be the one set by thread B, which forwards to the default panic hook. This is not considered a big issue because the panic handler setup is usually run during initialization code, probably before spawning any other threads.\n\nUsing the new `panic::update_hook` function, this race condition is impossible, and the result will be either `A, B, original` or `B, A, original`.\n\n```rust\npanic::update_hook(|prev| {\n    Box::new(move |info| {\n        println!(\"panic handler A\");\n        prev(info);\n    })\n});\n```\n\nI found one real world use case here: https://github.com/dtolnay/proc-macro2/blob/988cf403e741aadfd5340bbf67e35e1062a526aa/src/detection.rs#L32 the workaround is to detect the race condition and panic in that case.\n\nThe pattern of `take_hook` + `set_hook` is very common, you can see some examples in this pull request, so I think it's natural to have a function that combines them both. Also using `update_hook` instead of `take_hook` + `set_hook` reduces the number of calls to `HOOK_LOCK.write()` from 2 to 1, but I don't expect this to make any difference in performance.\n\n### Unresolved questions:\n\n* `panic::update_hook` takes a closure, if that closure panics the error message is \"panicked while processing panic\" which is not nice. This is a consequence of holding the `HOOK_LOCK` while executing the closure. Could be avoided using `catch_unwind`?\n\n* Reimplement `panic::set_hook` as `panic::update_hook(|_prev| hook)`?", "tree": {"sha": "2ba2d7d8b1f5472dfba12c8edf602bb7e0245c82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ba2d7d8b1f5472dfba12c8edf602bb7e0245c82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0984b4e4c908d714cebd0f0786c00645ea4d79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0984b4e4c908d714cebd0f0786c00645ea4d79a", "html_url": "https://github.com/rust-lang/rust/commit/a0984b4e4c908d714cebd0f0786c00645ea4d79a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0984b4e4c908d714cebd0f0786c00645ea4d79a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d61cd2eda81b595862635914bd0224402a4a26", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d61cd2eda81b595862635914bd0224402a4a26", "html_url": "https://github.com/rust-lang/rust/commit/f9d61cd2eda81b595862635914bd0224402a4a26"}, {"sha": "0c58586c9cbdd4db62c9c127ba89fd4d1d53acd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c58586c9cbdd4db62c9c127ba89fd4d1d53acd7", "html_url": "https://github.com/rust-lang/rust/commit/0c58586c9cbdd4db62c9c127ba89fd4d1d53acd7"}], "stats": {"total": 130, "additions": 124, "deletions": 6}, "files": [{"sha": "7b8eeb90b5a80ff7980c9ab8461c2e13b5ad2019", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -38,6 +38,7 @@\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n #![feature(nonnull_slice_from_raw_parts)]\n+#![feature(panic_update_hook)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "b93d7938bc9a5cd1e5a8db56734d4992633b2ecb", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -1783,12 +1783,11 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n fn panic_safe() {\n-    let prev = panic::take_hook();\n-    panic::set_hook(Box::new(move |info| {\n+    panic::update_hook(move |prev, info| {\n         if !SILENCE_PANIC.with(|s| s.get()) {\n             prev(info);\n         }\n-    }));\n+    });\n \n     let mut rng = thread_rng();\n "}, {"sha": "9e9750eb8de4031dddb7facb7fb9ec35efa75b19", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -310,16 +310,15 @@ impl Bridge<'_> {\n         // NB. the server can't do this because it may use a different libstd.\n         static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n         HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-            let prev = panic::take_hook();\n-            panic::set_hook(Box::new(move |info| {\n+            panic::update_hook(move |prev, info| {\n                 let show = BridgeState::with(|state| match state {\n                     BridgeState::NotConnected => true,\n                     BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n                 });\n                 if show {\n                     prev(info)\n                 }\n-            }));\n+            });\n         });\n \n         BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))"}, {"sha": "c5afca6d56a2d29a33255a1330dc74b579541284", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -30,6 +30,7 @@\n #![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n+#![feature(panic_update_hook)]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]"}, {"sha": "02ecf2e3e822e091a041f4c6608e190323725b1e", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -36,6 +36,9 @@ pub use core::panic::panic_2021;\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use crate::panicking::{set_hook, take_hook};\n \n+#[unstable(feature = \"panic_update_hook\", issue = \"92649\")]\n+pub use crate::panicking::update_hook;\n+\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use core::panic::{Location, PanicInfo};\n "}, {"sha": "44f573297eed1ac2af92c473b2092a3c502cd08d", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -76,6 +76,12 @@ enum Hook {\n     Custom(*mut (dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send)),\n }\n \n+impl Hook {\n+    fn custom(f: impl Fn(&PanicInfo<'_>) + 'static + Sync + Send) -> Self {\n+        Self::Custom(Box::into_raw(Box::new(f)))\n+    }\n+}\n+\n static HOOK_LOCK: StaticRWLock = StaticRWLock::new();\n static mut HOOK: Hook = Hook::Default;\n \n@@ -118,6 +124,11 @@ pub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n     }\n \n+    // SAFETY:\n+    //\n+    // - `HOOK` can only be modified while holding write access to `HOOK_LOCK`.\n+    // - The argument of `Box::from_raw` is always a valid pointer that was created using\n+    // `Box::into_raw`.\n     unsafe {\n         let guard = HOOK_LOCK.write();\n         let old_hook = HOOK;\n@@ -167,6 +178,11 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n         panic!(\"cannot modify the panic hook from a panicking thread\");\n     }\n \n+    // SAFETY:\n+    //\n+    // - `HOOK` can only be modified while holding write access to `HOOK_LOCK`.\n+    // - The argument of `Box::from_raw` is always a valid pointer that was created using\n+    // `Box::into_raw`.\n     unsafe {\n         let guard = HOOK_LOCK.write();\n         let hook = HOOK;\n@@ -180,6 +196,69 @@ pub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n     }\n }\n \n+/// Atomic combination of [`take_hook`] and [`set_hook`]. Use this to replace the panic handler with\n+/// a new panic handler that does something and then executes the old handler.\n+///\n+/// [`take_hook`]: ./fn.take_hook.html\n+/// [`set_hook`]: ./fn.set_hook.html\n+///\n+/// # Panics\n+///\n+/// Panics if called from a panicking thread.\n+///\n+/// # Examples\n+///\n+/// The following will print the custom message, and then the normal output of panic.\n+///\n+/// ```should_panic\n+/// #![feature(panic_update_hook)]\n+/// use std::panic;\n+///\n+/// // Equivalent to\n+/// // let prev = panic::take_hook();\n+/// // panic::set_hook(move |info| {\n+/// //     println!(\"...\");\n+/// //     prev(info);\n+/// // );\n+/// panic::update_hook(move |prev, info| {\n+///     println!(\"Print custom message and execute panic handler as usual\");\n+///     prev(info);\n+/// });\n+///\n+/// panic!(\"Custom and then normal\");\n+/// ```\n+#[unstable(feature = \"panic_update_hook\", issue = \"92649\")]\n+pub fn update_hook<F>(hook_fn: F)\n+where\n+    F: Fn(&(dyn Fn(&PanicInfo<'_>) + Send + Sync + 'static), &PanicInfo<'_>)\n+        + Sync\n+        + Send\n+        + 'static,\n+{\n+    if thread::panicking() {\n+        panic!(\"cannot modify the panic hook from a panicking thread\");\n+    }\n+\n+    // SAFETY:\n+    //\n+    // - `HOOK` can only be modified while holding write access to `HOOK_LOCK`.\n+    // - The argument of `Box::from_raw` is always a valid pointer that was created using\n+    // `Box::into_raw`.\n+    unsafe {\n+        let guard = HOOK_LOCK.write();\n+        let old_hook = HOOK;\n+        HOOK = Hook::Default;\n+\n+        let prev = match old_hook {\n+            Hook::Default => Box::new(default_hook),\n+            Hook::Custom(ptr) => Box::from_raw(ptr),\n+        };\n+\n+        HOOK = Hook::custom(move |info| hook_fn(&prev, info));\n+        drop(guard);\n+    }\n+}\n+\n fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled."}, {"sha": "4dd08ba4ad4e2f266b0d2a45d2b4acb8066c9472", "filename": "src/test/ui/panics/panic-handler-chain-update-hook.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a0984b4e4c908d714cebd0f0786c00645ea4d79a/src%2Ftest%2Fui%2Fpanics%2Fpanic-handler-chain-update-hook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0984b4e4c908d714cebd0f0786c00645ea4d79a/src%2Ftest%2Fui%2Fpanics%2Fpanic-handler-chain-update-hook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fpanic-handler-chain-update-hook.rs?ref=a0984b4e4c908d714cebd0f0786c00645ea4d79a", "patch": "@@ -0,0 +1,36 @@\n+// run-pass\n+// needs-unwind\n+#![allow(stable_features)]\n+\n+// ignore-emscripten no threads support\n+\n+#![feature(std_panic)]\n+#![feature(panic_update_hook)]\n+\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::panic;\n+use std::thread;\n+\n+static A: AtomicUsize = AtomicUsize::new(0);\n+static B: AtomicUsize = AtomicUsize::new(0);\n+static C: AtomicUsize = AtomicUsize::new(0);\n+\n+fn main() {\n+    panic::set_hook(Box::new(|_| { A.fetch_add(1, Ordering::SeqCst); }));\n+    panic::update_hook(|prev, info| {\n+        B.fetch_add(1, Ordering::SeqCst);\n+        prev(info);\n+    });\n+    panic::update_hook(|prev, info| {\n+        C.fetch_add(1, Ordering::SeqCst);\n+        prev(info);\n+    });\n+\n+    let _ = thread::spawn(|| {\n+        panic!();\n+    }).join();\n+\n+    assert_eq!(1, A.load(Ordering::SeqCst));\n+    assert_eq!(1, B.load(Ordering::SeqCst));\n+    assert_eq!(1, C.load(Ordering::SeqCst));\n+}"}]}