{"sha": "d6e55e97ff7060a2d752ff2413211adc7f8f4469", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZTU1ZTk3ZmY3MDYwYTJkNzUyZmYyNDEzMjExYWRjN2Y4ZjQ0Njk=", "commit": {"author": {"name": "Andy Weiss", "email": "dragonbear@google.com", "date": "2020-04-17T06:21:49Z"}, "committer": {"name": "Andy Weiss", "email": "dragonbear@google.com", "date": "2020-04-22T04:07:43Z"}, "message": "Make lint also capture blocks and closures, adjust language to mention other mutex types", "tree": {"sha": "8475c76863fb8a7f063c64c792813556074b3667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8475c76863fb8a7f063c64c792813556074b3667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6e55e97ff7060a2d752ff2413211adc7f8f4469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e55e97ff7060a2d752ff2413211adc7f8f4469", "html_url": "https://github.com/rust-lang/rust/commit/d6e55e97ff7060a2d752ff2413211adc7f8f4469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6e55e97ff7060a2d752ff2413211adc7f8f4469/comments", "author": {"login": "rokob", "id": 831355, "node_id": "MDQ6VXNlcjgzMTM1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/831355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rokob", "html_url": "https://github.com/rokob", "followers_url": "https://api.github.com/users/rokob/followers", "following_url": "https://api.github.com/users/rokob/following{/other_user}", "gists_url": "https://api.github.com/users/rokob/gists{/gist_id}", "starred_url": "https://api.github.com/users/rokob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rokob/subscriptions", "organizations_url": "https://api.github.com/users/rokob/orgs", "repos_url": "https://api.github.com/users/rokob/repos", "events_url": "https://api.github.com/users/rokob/events{/privacy}", "received_events_url": "https://api.github.com/users/rokob/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rokob", "id": 831355, "node_id": "MDQ6VXNlcjgzMTM1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/831355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rokob", "html_url": "https://github.com/rokob", "followers_url": "https://api.github.com/users/rokob/followers", "following_url": "https://api.github.com/users/rokob/following{/other_user}", "gists_url": "https://api.github.com/users/rokob/gists{/gist_id}", "starred_url": "https://api.github.com/users/rokob/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rokob/subscriptions", "organizations_url": "https://api.github.com/users/rokob/orgs", "repos_url": "https://api.github.com/users/rokob/repos", "events_url": "https://api.github.com/users/rokob/events{/privacy}", "received_events_url": "https://api.github.com/users/rokob/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54e7f7e5f2d38ef74e5e3e8de44beccc251cf5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/54e7f7e5f2d38ef74e5e3e8de44beccc251cf5d7", "html_url": "https://github.com/rust-lang/rust/commit/54e7f7e5f2d38ef74e5e3e8de44beccc251cf5d7"}], "stats": {"total": 135, "additions": 94, "deletions": 41}, "files": [{"sha": "b2aa3437923ddda751e2233a980d0edebf70aced", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d6e55e97ff7060a2d752ff2413211adc7f8f4469/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e55e97ff7060a2d752ff2413211adc7f8f4469/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=d6e55e97ff7060a2d752ff2413211adc7f8f4469", "patch": "@@ -1,20 +1,24 @@\n use crate::utils::{match_def_path, paths, span_lint_and_note};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, FnDecl, HirId, IsAsync};\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for calls to await while holding a MutexGuard.\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// non-async-aware MutexGuard.\n     ///\n-    /// **Why is this bad?** This is almost certainly an error which can result\n-    /// in a deadlock because the reactor will invoke code not visible to the\n-    /// currently visible scope.\n+    /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n+    /// are not designed to operator in an async context across await points.\n     ///\n-    /// **Known problems:** Detects only specifically named guard types:\n-    /// MutexGuard, RwLockReadGuard, and RwLockWriteGuard.\n+    /// There are two potential solutions. One is to use an asynx-aware Mutex\n+    /// type. Many asynchronous foundation crates provide such a Mutex type. The\n+    /// other solution is to ensure the mutex is unlocked before calling await,\n+    /// either by introducing a scope or an explicit call to Drop::drop.\n+    ///\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n@@ -27,6 +31,7 @@ declare_clippy_lint! {\n     ///   bar.await;\n     /// }\n     /// ```\n+    ///\n     /// Use instead:\n     /// ```rust,ignore\n     /// use std::sync::Mutex;\n@@ -47,43 +52,41 @@ declare_clippy_lint! {\n declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n \n impl LateLintPass<'_, '_> for AwaitHoldingLock {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'_, '_>,\n-        fn_kind: FnKind<'_>,\n-        _: &FnDecl<'_>,\n-        _: &Body<'_>,\n-        span: Span,\n-        _: HirId,\n-    ) {\n-        if !is_async_fn(fn_kind) {\n-            return;\n+    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &'_ Body<'_>) {\n+        use AsyncGeneratorKind::{Block, Closure, Fn};\n+        match body.generator_kind {\n+            Some(GeneratorKind::Async(Block))\n+            | Some(GeneratorKind::Async(Closure))\n+            | Some(GeneratorKind::Async(Fn)) => {\n+                let body_id = BodyId {\n+                    hir_id: body.value.hir_id,\n+                };\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+                let tables = cx.tcx.typeck_tables_of(def_id);\n+                check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n+            },\n+            _ => {},\n         }\n+    }\n+}\n \n-        for ty_cause in &cx.tables.generator_interior_types {\n-            if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n-                if is_mutex_guard(cx, adt.did) {\n-                    span_lint_and_note(\n-                        cx,\n-                        AWAIT_HOLDING_LOCK,\n-                        ty_cause.span,\n-                        \"this MutexGuard is held across an 'await' point\",\n-                        ty_cause.scope_span.unwrap_or(span),\n-                        \"these are all the await points this lock is held through\",\n-                    );\n-                }\n+fn check_interior_types(cx: &LateContext<'_, '_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+    for ty_cause in ty_causes {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n+            if is_mutex_guard(cx, adt.did) {\n+                span_lint_and_note(\n+                    cx,\n+                    AWAIT_HOLDING_LOCK,\n+                    ty_cause.span,\n+                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n+                    ty_cause.scope_span.unwrap_or(span),\n+                    \"these are all the await points this lock is held through\",\n+                );\n             }\n         }\n     }\n }\n \n-fn is_async_fn(fn_kind: FnKind<'_>) -> bool {\n-    fn_kind.header().map_or(false, |h| match h.asyncness {\n-        IsAsync::Async => true,\n-        IsAsync::NotAsync => false,\n-    })\n-}\n-\n fn is_mutex_guard(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n     match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)"}, {"sha": "5c1fdd83efb0da25f4578355532ee4101126cb11", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6e55e97ff7060a2d752ff2413211adc7f8f4469/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e55e97ff7060a2d752ff2413211adc7f8f4469/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=d6e55e97ff7060a2d752ff2413211adc7f8f4469", "patch": "@@ -34,9 +34,31 @@ async fn also_bad(x: &Mutex<u32>) -> u32 {\n     first + second + third\n }\n \n+async fn not_good(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n+}\n+\n fn main() {\n     let m = Mutex::new(100);\n     good(&m);\n     bad(&m);\n     also_bad(&m);\n+    not_good(&m);\n+    block_bad(&m);\n }"}, {"sha": "8c47cb37d8c997230423bf3c4b899fa31e455ac1", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6e55e97ff7060a2d752ff2413211adc7f8f4469/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6e55e97ff7060a2d752ff2413211adc7f8f4469/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=d6e55e97ff7060a2d752ff2413211adc7f8f4469", "patch": "@@ -1,4 +1,4 @@\n-error: this MutexGuard is held across an 'await' point\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n   --> $DIR/await_holding_lock.rs:7:9\n    |\n LL |     let guard = x.lock().unwrap();\n@@ -13,7 +13,7 @@ LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this MutexGuard is held across an 'await' point\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n   --> $DIR/await_holding_lock.rs:28:9\n    |\n LL |     let guard = x.lock().unwrap();\n@@ -31,5 +31,33 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:41:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:41:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:52:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:52:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 4 previous errors\n "}]}