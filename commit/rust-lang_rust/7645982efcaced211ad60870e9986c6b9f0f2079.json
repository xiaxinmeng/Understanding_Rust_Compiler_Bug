{"sha": "7645982efcaced211ad60870e9986c6b9f0f2079", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NDU5ODJlZmNhY2VkMjExYWQ2MDg3MGU5OTg2YzZiOWYwZjIwNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-04T18:06:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-04T18:06:49Z"}, "message": "auto merge of #14623 : exscape/rust-fork/master, r=alexcrichton\n\nUnlike ImmutableClonableVector::permutations() which returns an iterator,\r\ncloning the entire array each iteration, these methods mutate the vector in-place.\r\nFor that reason, these methods are much faster; between 35-55 times faster,\r\ndepending on the benchmark. They also generate permutations in lexicographical order.", "tree": {"sha": "9bc510310e7824f9f7979e15a94acb7c81d4fc12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bc510310e7824f9f7979e15a94acb7c81d4fc12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7645982efcaced211ad60870e9986c6b9f0f2079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7645982efcaced211ad60870e9986c6b9f0f2079", "html_url": "https://github.com/rust-lang/rust/commit/7645982efcaced211ad60870e9986c6b9f0f2079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7645982efcaced211ad60870e9986c6b9f0f2079/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6401b52263336c22879d4ffae3eded97949ee7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6401b52263336c22879d4ffae3eded97949ee7b", "html_url": "https://github.com/rust-lang/rust/commit/a6401b52263336c22879d4ffae3eded97949ee7b"}, {"sha": "3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5d6fd25486b29a70adfda6cb917ced614bc6d2", "html_url": "https://github.com/rust-lang/rust/commit/3b5d6fd25486b29a70adfda6cb917ced614bc6d2"}], "stats": {"total": 142, "additions": 142, "deletions": 0}, "files": [{"sha": "8f66279a9a32f8079c5cd304324472862a943b26", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/7645982efcaced211ad60870e9986c6b9f0f2079/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7645982efcaced211ad60870e9986c6b9f0f2079/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=7645982efcaced211ad60870e9986c6b9f0f2079", "patch": "@@ -712,13 +712,103 @@ pub trait MutableOrdVector<T> {\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     fn sort(self);\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful, `false` if the slice is at the last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = &mut [0, 1, 2];\n+    /// v.next_permutation();\n+    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// v.next_permutation();\n+    /// assert_eq!(v, &mut [1, 0, 2]);\n+    /// ```\n+    fn next_permutation(self) -> bool;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful, `false` if the slice is at the first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v = &mut [1, 0, 2];\n+    /// v.prev_permutation();\n+    /// assert_eq!(v, &mut [0, 2, 1]);\n+    /// v.prev_permutation();\n+    /// assert_eq!(v, &mut [0, 1, 2]);\n+    /// ```\n+    fn prev_permutation(self) -> bool;\n }\n \n impl<'a, T: Ord> MutableOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n         self.sort_by(|a,b| a.cmp(b))\n     }\n+\n+    fn next_permutation(self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly decreasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] >= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the last-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Find the rightmost element larger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j] <= self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 3: Swap that element with the pivot\n+        self.swap(j, i-1);\n+\n+        // Step 4: Reverse the (previously) weakly decreasing part\n+        self.mut_slice_from(i).reverse();\n+\n+        true\n+    }\n+\n+    fn prev_permutation(self) -> bool {\n+        // These cases only have 1 permutation each, so we can't do anything.\n+        if self.len() < 2 { return false; }\n+\n+        // Step 1: Identify the longest, rightmost weakly increasing part of the vector\n+        let mut i = self.len() - 1;\n+        while i > 0 && self[i-1] <= self[i] {\n+            i -= 1;\n+        }\n+\n+        // If that is the entire vector, this is the first-ordered permutation.\n+        if i == 0 {\n+            return false;\n+        }\n+\n+        // Step 2: Reverse the weakly increasing part\n+        self.mut_slice_from(i).reverse();\n+\n+        // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n+        let mut j = self.len() - 1;\n+        while j >= i && self[j-1] < self[i-1]  {\n+            j -= 1;\n+        }\n+\n+        // Step 4: Swap that element with the pivot\n+        self.swap(i-1, j);\n+\n+        true\n+    }\n }\n \n /// Unsafe operations\n@@ -1229,6 +1319,58 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_lexicographic_permutations() {\n+        let v : &mut[int] = &mut[1, 2, 3, 4, 5];\n+        assert!(v.prev_permutation() == false);\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 3, 5, 4]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[1, 2, 3, 4, 5]);\n+        assert!(v.next_permutation());\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 4, 3, 5]);\n+        assert!(v.next_permutation());\n+        assert_eq!(v, &mut[1, 2, 4, 5, 3]);\n+\n+        let v : &mut[int] = &mut[1, 0, 0, 0];\n+        assert!(v.next_permutation() == false);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 1, 0, 0]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 0, 1, 0]);\n+        assert!(v.prev_permutation());\n+        assert_eq!(v, &mut[0, 0, 0, 1]);\n+        assert!(v.prev_permutation() == false);\n+    }\n+\n+    #[test]\n+    fn test_lexicographic_permutations_empty_and_short() {\n+        let empty : &mut[int] = &mut[];\n+        assert!(empty.next_permutation() == false);\n+        assert_eq!(empty, &mut[]);\n+        assert!(empty.prev_permutation() == false);\n+        assert_eq!(empty, &mut[]);\n+\n+        let one_elem : &mut[int] = &mut[4];\n+        assert!(one_elem.prev_permutation() == false);\n+        assert_eq!(one_elem, &mut[4]);\n+        assert!(one_elem.next_permutation() == false);\n+        assert_eq!(one_elem, &mut[4]);\n+\n+        let two_elem : &mut[int] = &mut[1, 2];\n+        assert!(two_elem.prev_permutation() == false);\n+        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem.next_permutation());\n+        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem.next_permutation() == false);\n+        assert_eq!(two_elem, &mut[2, 1]);\n+        assert!(two_elem.prev_permutation());\n+        assert_eq!(two_elem, &mut[1, 2]);\n+        assert!(two_elem.prev_permutation() == false);\n+        assert_eq!(two_elem, &mut[1, 2]);\n+    }\n+\n     #[test]\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());"}]}