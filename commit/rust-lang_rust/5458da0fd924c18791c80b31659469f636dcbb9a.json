{"sha": "5458da0fd924c18791c80b31659469f636dcbb9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NThkYTBmZDkyNGMxODc5MWM4MGIzMTY1OTQ2OWY2MzZkY2JiOWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T13:25:53Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:08:14Z"}, "message": "Remove some checks and associated FIXMEs from trans code\n\nSuch intentions are better tracked in the bug tracker, don't need\nto litter the code with repetetive comments.", "tree": {"sha": "abe4fbac07afa61945ae7a07beab9b4e0c0ad322", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abe4fbac07afa61945ae7a07beab9b4e0c0ad322"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5458da0fd924c18791c80b31659469f636dcbb9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5458da0fd924c18791c80b31659469f636dcbb9a", "html_url": "https://github.com/rust-lang/rust/commit/5458da0fd924c18791c80b31659469f636dcbb9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5458da0fd924c18791c80b31659469f636dcbb9a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "789a1ae356f75ed7db75afd485e009ce32b2bd74", "url": "https://api.github.com/repos/rust-lang/rust/commits/789a1ae356f75ed7db75afd485e009ce32b2bd74", "html_url": "https://github.com/rust-lang/rust/commit/789a1ae356f75ed7db75afd485e009ce32b2bd74"}], "stats": {"total": 157, "additions": 37, "deletions": 120}, "files": [{"sha": "9e09a81253fe4cd73dbd01e5036e774d16f94d01", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -63,7 +63,6 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     }\n }\n \n-// FIXME: invariant -- pat_id is bound in the def_map?\n fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(ccx.tcx, vdef.enm);\n@@ -499,20 +498,13 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef], f: mk_fail,\n           _ { }\n         }\n     }\n-    let else_cx =\n-        alt kind {\n-          no_branch | single { bcx }\n-          _ { sub_block(bcx, \"match_else\") }\n-        };\n-    let sw;\n-    if kind == switch {\n-        sw = Switch(bcx, test_val, else_cx.llbb, opts.len());\n-        // FIXME This statement is purely here as a work-around for a bug that\n-        // I expect to be the same as issue #951. If I remove it, sw ends up\n-        // holding a corrupted value (when the compiler is optimized).\n-        // This can be removed after our next LLVM upgrade.\n-        val_ty(sw);\n-    } else { sw = C_int(ccx, 0); } // Placeholder for when not using a switch\n+    let else_cx = alt kind {\n+      no_branch | single { bcx }\n+      _ { sub_block(bcx, \"match_else\") }\n+    };\n+    let sw = if kind == switch {\n+        Switch(bcx, test_val, else_cx.llbb, opts.len())\n+    } else { C_int(ccx, 0) }; // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n@@ -694,9 +686,6 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = node_id_type(bcx, pat.id);\n-            // FIXME: Could constrain pat_bind to make this\n-            // check unnecessary.\n-            check (type_has_static_size(ccx, ty));\n             let llty = type_of(ccx, ty);\n             let alloc = alloca(bcx, llty);\n             bcx = copy_val(bcx, INIT, alloc,"}, {"sha": "f772f3a05c51ed61652d0e704017cc2645871ed7", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -186,10 +186,6 @@ fn type_of_ty_param_bounds_and_ty\n         // fall through\n       }\n     }\n-    // FIXME: could have a precondition on tpt, but that\n-    // doesn't work right now because one predicate can't imply\n-    // another\n-    check type_has_static_size(ccx, t);\n     type_of(ccx, t)\n }\n \n@@ -523,7 +519,6 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n     let box_ptr = ty::mk_imm_box(bcx.tcx(), t);\n-    check (type_has_static_size(ccx, box_ptr));\n     let llty = type_of(ccx, box_ptr);\n \n     // Get the tydesc for the body:\n@@ -792,7 +787,6 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     ret llfn;\n }\n \n-// FIXME: was this causing the leak?\n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n@@ -1218,7 +1212,6 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                 j += 1u;\n             }\n           }\n-          // Precondition?\n           _ { cx.tcx().sess.bug(\"iter_variant: not a function type\"); }\n         }\n         ret cx;\n@@ -1460,7 +1453,6 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_box(_) | ty::ty_opaque_box {\n         decr_refcnt_maybe_free(bcx, v, t)\n       }\n-      // Precondition?\n       _ { bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\"); }\n     }\n }\n@@ -1608,9 +1600,8 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n         revoke_clean(cx, src_val);\n         ret cx;\n     }\n-    /* FIXME: suggests a type constraint */\n     cx.sess().bug(\"unexpected type in trans::move_val: \" +\n-                             ty_to_str(tcx, t));\n+                  ty_to_str(tcx, t));\n }\n \n fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n@@ -1718,9 +1709,7 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n       ast::eq | ast::ne { llop = C_u8(abi::cmp_glue_op_eq); }\n       ast::lt | ast::ge { llop = C_u8(abi::cmp_glue_op_lt); }\n       ast::le | ast::gt { llop = C_u8(abi::cmp_glue_op_le); }\n-      // Precondition?\n-      _ { cx.tcx().sess.bug(\"trans_compare got\\\n-              non-comparison-op\"); }\n+      _ { cx.tcx().sess.bug(\"trans_compare got non-comparison-op\"); }\n     }\n \n     let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n@@ -2000,7 +1989,6 @@ fn store_in_dest(bcx: block, val: ValueRef, dest: dest) -> block {\n fn get_dest_addr(dest: dest) -> ValueRef {\n     alt dest {\n        save_in(a) { a }\n-       // Precondition?\n        _ { fail \"get_dest_addr: not a save_in\"; }\n     }\n }\n@@ -2079,7 +2067,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     -> block {\n     let next_cx = sub_block(cx, \"while next\");\n     let cond_cx = loop_scope_block(cx, cont_self, next_cx,\n-                                            \"while cond\", body.span);\n+                                   \"while cond\", body.span);\n     let body_cx = scope_block(cond_cx, \"while loop body\");\n     Br(cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n@@ -2483,9 +2471,9 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n               some(origin) { // An impl method\n                 ret impl::trans_method_callee(bcx, e.id, base, origin);\n               }\n-              // Precondition?\n-              _ { bcx.tcx().sess.span_bug(e.span, \"trans_callee: weird\\\n-                    expr\"); }\n+              _ {\n+                bcx.ccx().sess.span_bug(e.span, \"trans_callee: weird expr\");\n+              }\n             }\n         }\n       }\n@@ -2515,7 +2503,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         let ccx = cx.ccx();\n         let sub = trans_temp_expr(cx, base);\n         let t = expr_ty(cx, base);\n-        let val = alt ty::get(t).struct {\n+        let val = alt check ty::get(t).struct {\n           ty::ty_box(_) {\n             GEPi(sub.bcx, sub.val, [0, abi::box_field_body])\n           }\n@@ -2524,18 +2512,12 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n           }\n           ty::ty_enum(_, _) {\n             let ety = expr_ty(cx, e);\n-            let ellty =\n-                if check type_has_static_size(ccx, ety) {\n+            let ellty = if check type_has_static_size(ccx, ety) {\n                 T_ptr(type_of(ccx, ety))\n             } else { T_typaram_ptr(ccx.tn) };\n             PointerCast(sub.bcx, sub.val, ellty)\n           }\n           ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n-          // Precondition?\n-          _ {\n-            cx.tcx().sess.span_bug(e.span, \"trans_lval:\\\n-                                               Weird argument in deref\");\n-          }\n         };\n         ret lval_owned(sub.bcx, val);\n       }\n@@ -2602,9 +2584,6 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let e_res = trans_temp_expr(cx, e);\n     let ll_t_in = val_ty(e_res.val);\n     let t_in = expr_ty(cx, e);\n-    // Check should be avoidable because it's a cast.\n-    // FIXME: Constrain types so as to avoid this check.\n-    check (type_has_static_size(ccx, t_out));\n     let ll_t_out = type_of(ccx, t_out);\n \n     enum kind { pointer, integral, float, enum_, other, }\n@@ -3210,11 +3189,6 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         ret trans_ret(bcx, ex);\n       }\n       ast::expr_be(ex) {\n-        // Ideally, the expr_be enum would have a precondition\n-        // that is_call_expr(ex) -- but we don't support that\n-        // yet\n-        // FIXME\n-        check (ast_util::is_call_expr(ex));\n         ret trans_be(bcx, ex);\n       }\n       ast::expr_fail(expr) {\n@@ -3526,9 +3500,7 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n \n fn build_return(bcx: block) { Br(bcx, bcx.fcx.llreturn); }\n \n-// fn trans_be(cx: &block, e: &@ast::expr) -> result {\n-fn trans_be(cx: block, e: @ast::expr) : ast_util::is_call_expr(e) ->\n-   block {\n+fn trans_be(cx: block, e: @ast::expr) -> block {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n@@ -4399,13 +4371,11 @@ fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n-\n     ret struct_elt(llpairty, 0u);\n }\n \n fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id) {\n-    // FIXME: pull this out\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n@@ -4461,7 +4431,6 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let vecarg_ty: ty::arg =\n             {mode: ast::expl(ast::by_val),\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm})};\n-        // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, [vecarg_ty], nt, []);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n@@ -4600,10 +4569,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n       ast::item_const(_, _) {\n         let typ = ty::node_id_to_type(ccx.tcx, i.id);\n         let s = mangle_exported_name(ccx, my_path, typ);\n-        // FIXME: Could follow from a constraint on types of const\n-        // items\n         let g = str::as_buf(s, {|buf|\n-            check (type_has_static_size(ccx, typ));\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n         });\n         ccx.item_symbols.insert(i.id, s);\n@@ -4639,7 +4605,6 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n-        // FIXME: how to get rid of this check?\n         register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n                          \"res_dtor\", tps, i.id, t);\n       }"}, {"sha": "cb2fff553fef7cefbeeb8607f8ba151860fcd79f", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -718,17 +718,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                     param_bounds: [ty::param_bounds],\n                     target_info: target_info)\n     -> {val: ValueRef, ty: TypeRef} {\n-\n-    // If we supported constraints on record fields, we could make the\n-    // constraints for this function:\n-    /*\n-    : returns_non_ty_var(outgoing_fty),\n-      type_has_static_size(ccx, incoming_fty) ->\n-    */\n-    // but since we don't, we have to do the checks at the beginning.\n     let tcx = ccx.tcx;\n-    check type_has_static_size(ccx, incoming_fty);\n-\n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n             cdata_ty=%s,param_bounds=%?]\",\n            ty_to_str(tcx, incoming_fty),"}, {"sha": "34bdf846d4d2113d544e7cb0f2c80252467aff10", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -294,7 +294,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n     if did.crate == ast::local_crate {\n         alt ccx.item_ids.find(did.node) {\n           some(x) { ret x; }\n-          _ { ccx.tcx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n+          _ { ccx.sess.bug(\"get_res_dtor: can't find resource dtor!\"); }\n         }\n     }\n \n@@ -364,8 +364,8 @@ type block = @{\n // First two args are retptr, env\n const first_tp_arg: uint = 2u;\n \n-// FIXME: we should be able to use option<@block_parent> here but\n-// the infinite-enum check in rustboot gets upset.\n+// FIXME move blocks to a class once those are finished, and simply use\n+// option<block> for this.\n enum block_parent { parent_none, parent_some(block), }\n \n type result = {bcx: block, val: ValueRef};"}, {"sha": "63a3ddfbea9fcd6aded3c38e09aa152b34986e8e", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -601,7 +601,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n                                         mutbl: mt.mutbl}) }\n           _ {\n-            cx.tcx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n+            cx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n           }\n         };\n         ret @{node: ty, span: span};\n@@ -611,7 +611,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n       ast::ty_box(mt) {\n         let inner_t = alt ty::get(t).struct {\n           ty::ty_box(boxed) { boxed.ty }\n-          _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n+          _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n         let box = create_boxed_type(cx, t, inner_t, ty.span, md);\n@@ -622,7 +622,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n         let inner_t = alt ty::get(t).struct {\n           ty::ty_uniq(boxed) { boxed.ty }\n           // Hoping we'll have a way to eliminate this check soon.\n-          _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n+          _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n         let md = create_ty(cx, inner_t, mt.ty);\n         ret create_pointer_type(cx, t, ty.span, md);"}, {"sha": "e26075d60ad8270b6586148f3a1fb1a54867744b", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -53,7 +53,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n                      tps + m.tps, none, m.id);\n           }\n           _ {\n-            ccx.tcx.sess.bug(\"Unbound id in trans_impl\");\n+            ccx.sess.bug(\"Unbound id in trans_impl\");\n           }\n         }\n     }\n@@ -337,7 +337,7 @@ fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n                                target)\n           }\n           _ {\n-            ccx.tcx.sess.span_bug(it.span, \"No matching method \\\n+            ccx.sess.span_bug(it.span, \"No matching method \\\n                in trans_impl_vtable\");\n           }\n         }"}, {"sha": "4ffbc57692b5e78adc8e5548d022bb415f6eea7c", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -34,10 +34,7 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n         let llretty = type_of(ccx, ret_ty);\n         (llargtys, llretty, ret_ty)\n       }\n-      _ {\n-          // Precondition?\n-          ccx.tcx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\");\n-      }\n+      _ { ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\"); }\n     }\n }\n "}, {"sha": "ce1c67826b744b25b0ec999347011c7c88e76117", "filename": "src/comp/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fshape.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -118,11 +118,6 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n                 // when in fact it has minimum size sizeof(int).\n                 bounded = false;\n             } else {\n-                // Could avoid this check: the constraint should\n-                // follow from how elem_t doesn't contain params.\n-                // (Could add a postcondition to type_contains_params,\n-                // once we implement Issue #586.)\n-                check (trans::common::type_has_static_size(ccx, elem_t));\n                 let llty = base::type_of(ccx, elem_t);\n                 min_size += llsize_of_real(ccx, llty);\n                 min_align += llalign_of_real(ccx, llty);\n@@ -176,11 +171,6 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     ret result;\n }\n \n-// Computes the static size of a enum, without using mk_tup(), which is\n-// bad for performance.\n-//\n-// FIXME: Migrate trans over to use this.\n-\n fn round_up(size: u16, align: u8) -> u16 {\n     assert (align >= 1u8);\n     let alignment = align as u16;\n@@ -198,10 +188,6 @@ fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n         // We increment a \"virtual data pointer\" to compute the size.\n         let lltys = [];\n         for typ: ty::t in variants[vid].args {\n-            // FIXME: there should really be a postcondition\n-            // on enum_variants that would obviate the need for\n-            // this check. (Issue #586)\n-            check (trans::common::type_has_static_size(ccx, typ));\n             lltys += [base::type_of(ccx, typ)];\n         }\n \n@@ -439,7 +425,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         s += shape_of(ccx, inner_t, ty_param_map);\n       }\n       ty::ty_var(_) | ty::ty_self(_) {\n-        ccx.tcx.sess.bug(\"shape_of: unexpected type struct found\");\n+        ccx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n \n@@ -651,36 +637,33 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n                                False);\n }\n \n+// Computes the static size of a enum, without using mk_tup(), which is\n+// bad for performance.\n+//\n+// FIXME: Migrate trans over to use this.\n+\n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n-    : type_has_static_size(cx, t) -> uint {\n+fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n       ty::ty_enum(tid, subtys) {\n         // Compute max(variant sizes).\n-\n         let max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n         for variant: ty::variant_info in *variants {\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n-\n             tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n             // Here we possibly do a recursive call.\n-\n-            // FIXME: Avoid this check. Since the parent has static\n-            // size, any field must as well. There should be a way to\n-            // express that with constrained types.\n-            check (type_has_static_size(cx, tup_ty));\n             let this_size =\n                 llsize_of_real(cx, base::type_of(cx, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);\n         ret max_size;\n       }\n-      _ { cx.tcx.sess.bug(\"static_size_of_enum called on non-enum\"); }\n+      _ { cx.sess.bug(\"static_size_of_enum called on non-enum\"); }\n     }\n }\n \n@@ -761,9 +744,7 @@ fn dynamic_metrics(cx: block, t: ty::t) -> metrics {\n         { bcx: bcx, sz: sz, align: C_int(ccx, 1) }\n       }\n       _ {\n-        // Precondition?\n-        cx.tcx().sess.bug(\"dynamic_metrics: type has static \\\n-          size\");\n+        cx.tcx().sess.bug(\"dynamic_metrics: type has static size\");\n       }\n     }\n }"}, {"sha": "a48b5403d1ea6f79d48bbb358f6d45785b08e600", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5458da0fd924c18791c80b31659469f636dcbb9a/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5458da0fd924c18791c80b31659469f636dcbb9a", "patch": "@@ -132,9 +132,8 @@ fn trans_str(bcx: block, s: str, dest: dest) -> block {\n \n     let ccx = bcx.ccx();\n     let llcstr = C_cstr(ccx, s);\n-    let bcx =\n-        call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n-                     C_uint(ccx, veclen)).bcx;\n+    let bcx = call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n+                           C_uint(ccx, veclen)).bcx;\n     ret base::store_in_dest(bcx, sptr, dest);\n }\n \n@@ -151,13 +150,9 @@ fn trans_append(cx: block, vec_ty: ty::t, lhsptr: ValueRef,\n             (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n              PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)))\n         };\n-    let strings = alt ty::get(vec_ty).struct {\n+    let strings = alt check ty::get(vec_ty).struct {\n       ty::ty_str { true }\n       ty::ty_vec(_) { false }\n-      _ {\n-          // precondition?\n-          cx.tcx().sess.bug(\"Bad argument type in trans_append\");\n-      }\n     };\n \n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);"}]}