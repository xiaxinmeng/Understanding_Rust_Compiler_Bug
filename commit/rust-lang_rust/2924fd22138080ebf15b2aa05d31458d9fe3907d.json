{"sha": "2924fd22138080ebf15b2aa05d31458d9fe3907d", "node_id": "C_kwDOAAsO6NoAKDI5MjRmZDIyMTM4MDgwZWJmMTViMmFhMDVkMzE0NThkOWZlMzkwN2Q", "commit": {"author": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-25T07:04:51Z"}, "committer": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-28T10:37:35Z"}, "message": "Implement custom QoS-aware thread pool\n\nThis code replaces the thread pool implementation we were using\npreviously (from the `threadpool` crate). By making the thread pool\naware of QoS, each job spawned on the thread pool can have a different\nQoS class.\n\nThis commit also replaces every QoS class used previously with Default\nas a temporary measure so that each usage can be chosen deliberately.", "tree": {"sha": "6edc359419ef18a6576fc7ad122c3bc7cc3be9e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6edc359419ef18a6576fc7ad122c3bc7cc3be9e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2924fd22138080ebf15b2aa05d31458d9fe3907d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAAGgAAAATZWNkc2Etc2hhMi1uaXN0cDI1NgAAAAhuaXN0cDI1NgAAAE\nEEtPEPU+w9oQ90uLBc4R0g0O7C/w+fcT4a+R4nvkvJXioSPGOafBHNQJufyTj3tLLeNtO4\n1H9ztJfn/DlLu2mXigAAAANnaXQAAAAAAAAABnNoYTUxMgAAAGMAAAATZWNkc2Etc2hhMi\n1uaXN0cDI1NgAAAEgAAAAgH7NmUG8C9rSYPW6WZ8wrO9mbBpMckcQMphIN4FhjAjYAAAAg\nFaKNy8Bg2iMv2Im11dWzkTg8wnZ8B9lfWcPDPOE00dE=\n-----END SSH SIGNATURE-----", "payload": "tree 6edc359419ef18a6576fc7ad122c3bc7cc3be9e2\nparent f6e3a87bf9478574f8c64ac2efec125bc19b1c64\nauthor Luna Razzaghipour <lunarazzaghipour@gmail.com> 1684998291 +1000\ncommitter Luna Razzaghipour <lunarazzaghipour@gmail.com> 1685270255 +1000\n\nImplement custom QoS-aware thread pool\n\nThis code replaces the thread pool implementation we were using\npreviously (from the `threadpool` crate). By making the thread pool\naware of QoS, each job spawned on the thread pool can have a different\nQoS class.\n\nThis commit also replaces every QoS class used previously with Default\nas a temporary measure so that each usage can be chosen deliberately.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2924fd22138080ebf15b2aa05d31458d9fe3907d", "html_url": "https://github.com/rust-lang/rust/commit/2924fd22138080ebf15b2aa05d31458d9fe3907d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2924fd22138080ebf15b2aa05d31458d9fe3907d/comments", "author": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e3a87bf9478574f8c64ac2efec125bc19b1c64", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e3a87bf9478574f8c64ac2efec125bc19b1c64", "html_url": "https://github.com/rust-lang/rust/commit/f6e3a87bf9478574f8c64ac2efec125bc19b1c64"}], "stats": {"total": 277, "additions": 184, "deletions": 93}, "files": [{"sha": "322a67383b0302ff0c9cf6d48c935751a4b27351", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -1518,7 +1518,6 @@ dependencies = [\n  \"syntax\",\n  \"test-utils\",\n  \"thiserror\",\n- \"threadpool\",\n  \"tikv-jemallocator\",\n  \"toolchain\",\n  \"tracing\",\n@@ -1712,6 +1711,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"always-assert\",\n  \"backtrace\",\n+ \"crossbeam-channel\",\n  \"jod-thread\",\n  \"libc\",\n  \"miow\",\n@@ -1823,15 +1823,6 @@ dependencies = [\n  \"once_cell\",\n ]\n \n-[[package]]\n-name = \"threadpool\"\n-version = \"1.8.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n-dependencies = [\n- \"num_cpus\",\n-]\n-\n [[package]]\n name = \"tikv-jemalloc-ctl\"\n version = \"0.5.0\""}, {"sha": "190205a2cde83dcfba11cc56de100fe0ee038a37", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -90,7 +90,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<StateChange>();\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Default)\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n@@ -409,7 +409,7 @@ impl CargoHandle {\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Default)\n             .name(\"CargoHandle\".to_owned())\n             .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");"}, {"sha": "8c8a93bcb8fee2fb165ee49ed9b0283ee7d1aa5d", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn parallel_prime_caches(\n             let worker = prime_caches_worker.clone();\n             let db = db.snapshot();\n \n-            stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+            stdx::thread::Builder::new(stdx::thread::QoSClass::Default)\n                 .allow_leak(true)\n                 .spawn(move || Cancelled::catch(|| worker(db)))\n                 .expect(\"failed to spawn thread\");"}, {"sha": "97bd9209206012cf52ee83e5b39ef4c11acf8469", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -31,7 +31,6 @@ oorandom = \"11.1.3\"\n rustc-hash = \"1.1.0\"\n serde_json = { workspace = true, features = [\"preserve_order\"] }\n serde.workspace = true\n-threadpool = \"1.8.1\"\n rayon = \"1.6.1\"\n num_cpus = \"1.15.0\"\n mimalloc = { version = \"0.1.30\", default-features = false, optional = true }"}, {"sha": "eba19333116a65861362fd72890502f5297b9655", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -85,7 +85,7 @@ fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n             // will make actions like hitting enter in the editor slow.\n             // rust-analyzer does not block the editor\u2019s render loop,\n             // so we don\u2019t use User Interactive.\n-            with_extra_thread(\"LspServer\", stdx::thread::QoSClass::UserInitiated, run_server)?;\n+            with_extra_thread(\"LspServer\", stdx::thread::QoSClass::Default, run_server)?;\n         }\n         flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,"}, {"sha": "c4731340ba2eb341da2ba4c7779e04f40f950819", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -4,6 +4,7 @@ use std::{fmt, panic, thread};\n use ide::Cancelled;\n use lsp_server::ExtractError;\n use serde::{de::DeserializeOwned, Serialize};\n+use stdx::thread::QoSClass;\n \n use crate::{\n     global_state::{GlobalState, GlobalStateSnapshot},\n@@ -102,7 +103,7 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn({\n+        self.global_state.task_pool.handle.spawn(QoSClass::Default, {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = panic::catch_unwind(move || {\n@@ -128,6 +129,44 @@ impl<'a> RequestDispatcher<'a> {\n         &mut self,\n         f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n     ) -> &mut Self\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n+        R::Result: Serialize,\n+    {\n+        self.on_with_qos::<R>(QoSClass::Default, f)\n+    }\n+\n+    /// Dispatches a latency-sensitive request onto the thread pool.\n+    pub(crate) fn on_latency_sensitive<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> &mut Self\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n+        R::Result: Serialize,\n+    {\n+        self.on_with_qos::<R>(QoSClass::Default, f)\n+    }\n+\n+    pub(crate) fn finish(&mut self) {\n+        if let Some(req) = self.req.take() {\n+            tracing::error!(\"unknown request: {:?}\", req);\n+            let response = lsp_server::Response::new_err(\n+                req.id,\n+                lsp_server::ErrorCode::MethodNotFound as i32,\n+                \"unknown request\".to_string(),\n+            );\n+            self.global_state.respond(response);\n+        }\n+    }\n+\n+    fn on_with_qos<R>(\n+        &mut self,\n+        qos_class: QoSClass,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> &mut Self\n     where\n         R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n@@ -138,7 +177,7 @@ impl<'a> RequestDispatcher<'a> {\n             None => return self,\n         };\n \n-        self.global_state.task_pool.handle.spawn({\n+        self.global_state.task_pool.handle.spawn(qos_class, {\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = panic::catch_unwind(move || {\n@@ -155,18 +194,6 @@ impl<'a> RequestDispatcher<'a> {\n         self\n     }\n \n-    pub(crate) fn finish(&mut self) {\n-        if let Some(req) = self.req.take() {\n-            tracing::error!(\"unknown request: {:?}\", req);\n-            let response = lsp_server::Response::new_err(\n-                req.id,\n-                lsp_server::ErrorCode::MethodNotFound as i32,\n-                \"unknown request\".to_string(),\n-            );\n-            self.global_state.respond(response);\n-        }\n-    }\n-\n     fn parse<R>(&mut self) -> Option<(lsp_server::Request, R::Params, String)>\n     where\n         R: lsp_types::request::Request,"}, {"sha": "2d871748c3c887443372545c5a4d08542eae1f13", "filename": "crates/rust-analyzer/src/handlers/notification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers%2Fnotification.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -291,7 +291,7 @@ fn run_flycheck(state: &mut GlobalState, vfs_path: VfsPath) -> bool {\n             }\n             Ok(())\n         };\n-        state.task_pool.handle.spawn_with_sender(move |_| {\n+        state.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Default, move |_| {\n             if let Err(e) = std::panic::catch_unwind(task) {\n                 tracing::error!(\"flycheck task panicked: {e:?}\")\n             }"}, {"sha": "ae9f6ff7ee24b4f7e7e34ee4f1224edfe52c938a", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -397,7 +397,7 @@ impl GlobalState {\n         tracing::debug!(%cause, \"will prime caches\");\n         let num_worker_threads = self.config.prime_caches_num_threads();\n \n-        self.task_pool.handle.spawn_with_sender({\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Default, {\n             let analysis = self.snapshot().analysis;\n             move |sender| {\n                 sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n@@ -678,7 +678,24 @@ impl GlobalState {\n             .on_sync::<lsp_types::request::SelectionRangeRequest>(handlers::handle_selection_range)\n             .on_sync::<lsp_ext::MatchingBrace>(handlers::handle_matching_brace)\n             .on_sync::<lsp_ext::OnTypeFormatting>(handlers::handle_on_type_formatting)\n-            // All other request handlers:\n+            // We can\u2019t run latency-sensitive request handlers which do semantic\n+            // analysis on the main thread because that would block other\n+            // requests. Instead, we run these request handlers on higher QoS\n+            // threads in the threadpool.\n+            .on_latency_sensitive::<lsp_types::request::Completion>(handlers::handle_completion)\n+            .on_latency_sensitive::<lsp_types::request::ResolveCompletionItem>(\n+                handlers::handle_completion_resolve,\n+            )\n+            .on_latency_sensitive::<lsp_types::request::SemanticTokensFullRequest>(\n+                handlers::handle_semantic_tokens_full,\n+            )\n+            .on_latency_sensitive::<lsp_types::request::SemanticTokensFullDeltaRequest>(\n+                handlers::handle_semantic_tokens_full_delta,\n+            )\n+            .on_latency_sensitive::<lsp_types::request::SemanticTokensRangeRequest>(\n+                handlers::handle_semantic_tokens_range,\n+            )\n+            // All other request handlers\n             .on::<lsp_ext::FetchDependencyList>(handlers::fetch_dependency_list)\n             .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n@@ -706,8 +723,6 @@ impl GlobalState {\n             .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)\n             .on_no_retry::<lsp_types::request::InlayHintRequest>(handlers::handle_inlay_hints)\n             .on::<lsp_types::request::InlayHintResolveRequest>(handlers::handle_inlay_hints_resolve)\n-            .on::<lsp_types::request::Completion>(handlers::handle_completion)\n-            .on::<lsp_types::request::ResolveCompletionItem>(handlers::handle_completion_resolve)\n             .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)\n             .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)\n             .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)\n@@ -725,15 +740,6 @@ impl GlobalState {\n             .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n                 handlers::handle_call_hierarchy_outgoing,\n             )\n-            .on::<lsp_types::request::SemanticTokensFullRequest>(\n-                handlers::handle_semantic_tokens_full,\n-            )\n-            .on::<lsp_types::request::SemanticTokensFullDeltaRequest>(\n-                handlers::handle_semantic_tokens_full_delta,\n-            )\n-            .on::<lsp_types::request::SemanticTokensRangeRequest>(\n-                handlers::handle_semantic_tokens_range,\n-            )\n             .on::<lsp_types::request::WillRenameFiles>(handlers::handle_will_rename_files)\n             .on::<lsp_ext::Ssr>(handlers::handle_ssr)\n             .finish();\n@@ -781,7 +787,7 @@ impl GlobalState {\n         tracing::trace!(\"updating notifications for {:?}\", subscriptions);\n \n         let snapshot = self.snapshot();\n-        self.task_pool.handle.spawn(move || {\n+        self.task_pool.handle.spawn(stdx::thread::QoSClass::Default, move || {\n             let _p = profile::span(\"publish_diagnostics\");\n             let diagnostics = subscriptions\n                 .into_iter()"}, {"sha": "7070950638d9cd394f5ec76aa745d8e2a9c84ffe", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -185,7 +185,7 @@ impl GlobalState {\n     pub(crate) fn fetch_workspaces(&mut self, cause: Cause) {\n         tracing::info!(%cause, \"will fetch workspaces\");\n \n-        self.task_pool.handle.spawn_with_sender({\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Default, {\n             let linked_projects = self.config.linked_projects();\n             let detached_files = self.config.detached_files().to_vec();\n             let cargo_config = self.config.cargo();\n@@ -260,7 +260,7 @@ impl GlobalState {\n         tracing::info!(%cause, \"will fetch build data\");\n         let workspaces = Arc::clone(&self.workspaces);\n         let config = self.config.cargo();\n-        self.task_pool.handle.spawn_with_sender(move |sender| {\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Default, move |sender| {\n             sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n \n             let progress = {\n@@ -280,7 +280,7 @@ impl GlobalState {\n         let dummy_replacements = self.config.dummy_replacements().clone();\n         let proc_macro_clients = self.proc_macro_clients.clone();\n \n-        self.task_pool.handle.spawn_with_sender(move |sender| {\n+        self.task_pool.handle.spawn_with_sender(stdx::thread::QoSClass::Default, move |sender| {\n             sender.send(Task::LoadProcMacros(ProcMacroProgress::Begin)).unwrap();\n \n             let dummy_replacements = &dummy_replacements;"}, {"sha": "f055de40d067cdc4e886635b03201e24d8198241", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -1,76 +1,42 @@\n-//! A thin wrapper around `ThreadPool` to make sure that we join all things\n-//! properly.\n-use std::sync::{Arc, Barrier};\n+//! A thin wrapper around [`stdx::thread::Pool`] which threads a sender through spawned jobs.\n+//! It is used in [`crate::global_state::GlobalState`] throughout the main loop.\n \n use crossbeam_channel::Sender;\n+use stdx::thread::{Pool, QoSClass};\n \n pub(crate) struct TaskPool<T> {\n     sender: Sender<T>,\n-    inner: threadpool::ThreadPool,\n+    pool: Pool,\n }\n \n impl<T> TaskPool<T> {\n     pub(crate) fn new_with_threads(sender: Sender<T>, threads: usize) -> TaskPool<T> {\n-        const STACK_SIZE: usize = 8 * 1024 * 1024;\n-\n-        let inner = threadpool::Builder::new()\n-            .thread_name(\"Worker\".into())\n-            .thread_stack_size(STACK_SIZE)\n-            .num_threads(threads)\n-            .build();\n-\n-        // Set QoS of all threads in threadpool.\n-        let barrier = Arc::new(Barrier::new(threads + 1));\n-        for _ in 0..threads {\n-            let barrier = barrier.clone();\n-            inner.execute(move || {\n-                stdx::thread::set_current_thread_qos_class(stdx::thread::QoSClass::Utility);\n-                barrier.wait();\n-            });\n-        }\n-        barrier.wait();\n-\n-        TaskPool { sender, inner }\n+        TaskPool { sender, pool: Pool::new(threads) }\n     }\n \n-    pub(crate) fn spawn<F>(&mut self, task: F)\n+    pub(crate) fn spawn<F>(&mut self, qos_class: QoSClass, task: F)\n     where\n         F: FnOnce() -> T + Send + 'static,\n         T: Send + 'static,\n     {\n-        self.inner.execute({\n+        self.pool.spawn(qos_class, {\n             let sender = self.sender.clone();\n-            move || {\n-                if stdx::thread::IS_QOS_AVAILABLE {\n-                    debug_assert_eq!(\n-                        stdx::thread::get_current_thread_qos_class(),\n-                        Some(stdx::thread::QoSClass::Utility)\n-                    );\n-                }\n-\n-                sender.send(task()).unwrap()\n-            }\n+            move || sender.send(task()).unwrap()\n         })\n     }\n \n-    pub(crate) fn spawn_with_sender<F>(&mut self, task: F)\n+    pub(crate) fn spawn_with_sender<F>(&mut self, qos_class: QoSClass, task: F)\n     where\n         F: FnOnce(Sender<T>) + Send + 'static,\n         T: Send + 'static,\n     {\n-        self.inner.execute({\n+        self.pool.spawn(qos_class, {\n             let sender = self.sender.clone();\n             move || task(sender)\n         })\n     }\n \n     pub(crate) fn len(&self) -> usize {\n-        self.inner.queued_count()\n-    }\n-}\n-\n-impl<T> Drop for TaskPool<T> {\n-    fn drop(&mut self) {\n-        self.inner.join()\n+        self.pool.len()\n     }\n }"}, {"sha": "a67f36ae9006ade358ff2435eb47f0aeffda1f00", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -16,6 +16,7 @@ libc = \"0.2.135\"\n backtrace = { version = \"0.3.65\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n jod-thread = \"0.1.2\"\n+crossbeam-channel = \"0.5.5\"\n # Think twice before adding anything here\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "8630961f85bc7b9d579a2922d4dc35b29aef0c0a", "filename": "crates/stdx/src/thread.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2Fsrc%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2Fsrc%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -13,6 +13,9 @@\n \n use std::fmt;\n \n+mod pool;\n+pub use pool::Pool;\n+\n pub fn spawn<F, T>(qos_class: QoSClass, f: F) -> JoinHandle<T>\n where\n     F: FnOnce() -> T,\n@@ -152,6 +155,8 @@ pub enum QoSClass {\n     /// performance, responsiveness and efficiency.\n     Utility,\n \n+    Default,\n+\n     /// TLDR: tasks that block using your app\n     ///\n     /// Contract:\n@@ -229,6 +234,7 @@ mod imp {\n         let c = match class {\n             QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n             QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n+            QoSClass::Default => libc::qos_class_t::QOS_CLASS_DEFAULT,\n             QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n             QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n         };"}, {"sha": "b4ab9cb292ce400dde9a1842ce49fb6262004228", "filename": "crates/stdx/src/thread/pool.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread%2Fpool.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -0,0 +1,95 @@\n+//! [`Pool`] implements a basic custom thread pool\n+//! inspired by the [`threadpool` crate](http://docs.rs/threadpool).\n+//! It allows the spawning of tasks under different QoS classes.\n+//! rust-analyzer uses this to prioritize work based on latency requirements.\n+//!\n+//! The thread pool is implemented entirely using\n+//! the threading utilities in [`crate::thread`].\n+\n+use std::sync::{\n+    atomic::{AtomicUsize, Ordering},\n+    Arc,\n+};\n+\n+use crossbeam_channel::{Receiver, Sender};\n+\n+use super::{\n+    get_current_thread_qos_class, set_current_thread_qos_class, Builder, JoinHandle, QoSClass,\n+    IS_QOS_AVAILABLE,\n+};\n+\n+pub struct Pool {\n+    // `_handles` is never read: the field is present\n+    // only for its `Drop` impl.\n+\n+    // The worker threads exit once the channel closes;\n+    // make sure to keep `job_sender` above `handles`\n+    // so that the channel is actually closed\n+    // before we join the worker threads!\n+    job_sender: Sender<Job>,\n+    _handles: Vec<JoinHandle>,\n+    extant_tasks: Arc<AtomicUsize>,\n+}\n+\n+struct Job {\n+    requested_qos_class: QoSClass,\n+    f: Box<dyn FnOnce() + Send + 'static>,\n+}\n+\n+impl Pool {\n+    pub fn new(threads: usize) -> Pool {\n+        const STACK_SIZE: usize = 8 * 1024 * 1024;\n+        const INITIAL_QOS_CLASS: QoSClass = QoSClass::Utility;\n+\n+        let (job_sender, job_receiver) = crossbeam_channel::unbounded();\n+        let extant_tasks = Arc::new(AtomicUsize::new(0));\n+\n+        let mut handles = Vec::with_capacity(threads);\n+        for _ in 0..threads {\n+            let handle = Builder::new(INITIAL_QOS_CLASS)\n+                .stack_size(STACK_SIZE)\n+                .name(\"Worker\".into())\n+                .spawn({\n+                    let extant_tasks = Arc::clone(&extant_tasks);\n+                    let job_receiver: Receiver<Job> = job_receiver.clone();\n+                    move || {\n+                        let mut current_qos_class = INITIAL_QOS_CLASS;\n+                        for job in job_receiver {\n+                            if job.requested_qos_class != current_qos_class {\n+                                set_current_thread_qos_class(job.requested_qos_class);\n+                                current_qos_class = job.requested_qos_class;\n+                            }\n+                            extant_tasks.fetch_add(1, Ordering::SeqCst);\n+                            (job.f)();\n+                            extant_tasks.fetch_sub(1, Ordering::SeqCst);\n+                        }\n+                    }\n+                })\n+                .expect(\"failed to spawn thread\");\n+\n+            handles.push(handle);\n+        }\n+\n+        Pool { _handles: handles, extant_tasks, job_sender }\n+    }\n+\n+    pub fn spawn<F>(&self, qos_class: QoSClass, f: F)\n+    where\n+        F: FnOnce() + Send + 'static,\n+    {\n+        let f = Box::new(move || {\n+            if IS_QOS_AVAILABLE {\n+                debug_assert_eq!(get_current_thread_qos_class(), Some(qos_class));\n+            }\n+\n+            f()\n+        });\n+\n+        let job = Job { requested_qos_class: qos_class, f };\n+        self.job_sender.send(job).unwrap();\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.extant_tasks.load(Ordering::SeqCst)\n+    }\n+}"}, {"sha": "90a7d7d6c0e51065e5d0ed9b304f3465a5e4f420", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2924fd22138080ebf15b2aa05d31458d9fe3907d/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=2924fd22138080ebf15b2aa05d31458d9fe3907d", "patch": "@@ -34,7 +34,7 @@ impl loader::Handle for NotifyHandle {\n     fn spawn(sender: loader::Sender) -> NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n-        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Default)\n             .name(\"VfsLoader\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");"}]}