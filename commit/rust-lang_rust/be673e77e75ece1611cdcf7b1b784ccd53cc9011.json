{"sha": "be673e77e75ece1611cdcf7b1b784ccd53cc9011", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNjczZTc3ZTc1ZWNlMTYxMWNkY2Y3YjFiNzg0Y2NkNTNjYzkwMTE=", "commit": {"author": {"name": "G\u00e1bor Lehel", "email": "glaebhoerl@gmail.com", "date": "2014-03-16T21:46:04Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-04-01T05:42:31Z"}, "message": "syntax: allow stmt/expr macro invocations to be delimited by [].\n\nthis is useful for macros like vec! which construct containers", "tree": {"sha": "83f60a5f11809e936f289734e924d6918880d832", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83f60a5f11809e936f289734e924d6918880d832"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be673e77e75ece1611cdcf7b1b784ccd53cc9011", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be673e77e75ece1611cdcf7b1b784ccd53cc9011", "html_url": "https://github.com/rust-lang/rust/commit/be673e77e75ece1611cdcf7b1b784ccd53cc9011", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be673e77e75ece1611cdcf7b1b784ccd53cc9011/comments", "author": {"login": "glaebhoerl", "id": 1216629, "node_id": "MDQ6VXNlcjEyMTY2Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/1216629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glaebhoerl", "html_url": "https://github.com/glaebhoerl", "followers_url": "https://api.github.com/users/glaebhoerl/followers", "following_url": "https://api.github.com/users/glaebhoerl/following{/other_user}", "gists_url": "https://api.github.com/users/glaebhoerl/gists{/gist_id}", "starred_url": "https://api.github.com/users/glaebhoerl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glaebhoerl/subscriptions", "organizations_url": "https://api.github.com/users/glaebhoerl/orgs", "repos_url": "https://api.github.com/users/glaebhoerl/repos", "events_url": "https://api.github.com/users/glaebhoerl/events{/privacy}", "received_events_url": "https://api.github.com/users/glaebhoerl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64", "html_url": "https://github.com/rust-lang/rust/commit/b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64"}], "stats": {"total": 79, "additions": 45, "deletions": 34}, "files": [{"sha": "83cc92d48284a1d580a7227e999c8ad3ac83472b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=be673e77e75ece1611cdcf7b1b784ccd53cc9011", "patch": "@@ -1881,12 +1881,9 @@ impl<'a> Parser<'a> {\n             if self.token == token::NOT {\n                 // MACRO INVOCATION expression\n                 self.bump();\n-                match self.token {\n-                    token::LPAREN | token::LBRACE => {}\n-                    _ => self.fatal(\"expected open delimiter\")\n-                };\n \n-                let ket = token::flip_delimiter(&self.token);\n+                let ket = token::close_delimiter_for(&self.token)\n+                                .unwrap_or_else(|| self.fatal(\"expected open delimiter\"));\n                 self.bump();\n \n                 let tts = self.parse_seq_to_end(&ket,\n@@ -2109,8 +2106,8 @@ impl<'a> Parser<'a> {\n             TTTok(p.span, p.bump_and_get())\n         }\n \n-        match self.token {\n-            token::EOF => {\n+        match (&self.token, token::close_delimiter_for(&self.token)) {\n+            (&token::EOF, _) => {\n                 let open_braces = self.open_braces.clone();\n                 for sp in open_braces.iter() {\n                     self.span_note(*sp, \"Did you mean to close this delimiter?\");\n@@ -2119,9 +2116,7 @@ impl<'a> Parser<'a> {\n                 // if we give it one\n                 self.fatal(\"this file contains an un-closed delimiter \");\n             }\n-            token::LPAREN | token::LBRACE | token::LBRACKET => {\n-                let close_delim = token::flip_delimiter(&self.token);\n-\n+            (_, Some(close_delim)) => {\n                 // Parse the open delimiter.\n                 self.open_braces.push(self.span);\n                 let mut result = vec!(parse_any_tt_tok(self));\n@@ -2157,13 +2152,12 @@ impl<'a> Parser<'a> {\n         // the interpolation of Matcher's\n         maybe_whole!(self, NtMatchers);\n         let mut name_idx = 0u;\n-        match self.token {\n-            token::LBRACE | token::LPAREN | token::LBRACKET => {\n-                let other_delimiter = token::flip_delimiter(&self.token);\n+        match token::close_delimiter_for(&self.token) {\n+            Some(other_delimiter) => {\n                 self.bump();\n                 self.parse_matcher_subseq_upto(&mut name_idx, &other_delimiter)\n             }\n-            _ => self.fatal(\"expected open delimiter\")\n+            None => self.fatal(\"expected open delimiter\")\n         }\n     }\n \n@@ -3138,7 +3132,7 @@ impl<'a> Parser<'a> {\n             let pth = self.parse_path(NoTypesAllowed).path;\n             self.bump();\n \n-            let id = if self.token == token::LPAREN || self.token == token::LBRACE {\n+            let id = if token::close_delimiter_for(&self.token).is_some() {\n                 token::special_idents::invalid // no special identifier\n             } else {\n                 self.parse_ident()\n@@ -3147,10 +3141,9 @@ impl<'a> Parser<'a> {\n             // check that we're pointing at delimiters (need to check\n             // again after the `if`, because of `parse_ident`\n             // consuming more tokens).\n-            let (bra, ket) = match self.token {\n-                token::LPAREN => (token::LPAREN, token::RPAREN),\n-                token::LBRACE => (token::LBRACE, token::RBRACE),\n-                _ => {\n+            let (bra, ket) = match token::close_delimiter_for(&self.token) {\n+                Some(ket) => (self.token.clone(), ket),\n+                None      => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n                     let ident_str = if id == token::special_idents::invalid {\n@@ -4724,15 +4717,14 @@ impl<'a> Parser<'a> {\n                 token::special_idents::invalid // no special identifier\n             };\n             // eat a matched-delimiter token tree:\n-            let tts = match self.token {\n-                token::LPAREN | token::LBRACE => {\n-                    let ket = token::flip_delimiter(&self.token);\n+            let tts = match token::close_delimiter_for(&self.token) {\n+                Some(ket) => {\n                     self.bump();\n                     self.parse_seq_to_end(&ket,\n                                           seq_sep_none(),\n                                           |p| p.parse_token_tree())\n                 }\n-                _ => self.fatal(\"expected open delimiter\")\n+                None => self.fatal(\"expected open delimiter\")\n             };\n             // single-variant-enum... :\n             let m = ast::MacInvocTT(pth, tts, EMPTY_CTXT);"}, {"sha": "ff1509fe23a762c5d2bfed1b5aa39e09b09ede20", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=be673e77e75ece1611cdcf7b1b784ccd53cc9011", "patch": "@@ -297,21 +297,17 @@ pub fn can_begin_expr(t: &Token) -> bool {\n     }\n }\n \n-/// what's the opposite delimiter?\n-pub fn flip_delimiter(t: &token::Token) -> token::Token {\n+/// Returns the matching close delimiter if this is an open delimiter,\n+/// otherwise `None`.\n+pub fn close_delimiter_for(t: &Token) -> Option<Token> {\n     match *t {\n-      LPAREN => RPAREN,\n-      LBRACE => RBRACE,\n-      LBRACKET => RBRACKET,\n-      RPAREN => LPAREN,\n-      RBRACE => LBRACE,\n-      RBRACKET => LBRACKET,\n-      _ => fail!()\n+        LPAREN   => Some(RPAREN),\n+        LBRACE   => Some(RBRACE),\n+        LBRACKET => Some(RBRACKET),\n+        _        => None\n     }\n }\n \n-\n-\n pub fn is_lit(t: &Token) -> bool {\n     match *t {\n       LIT_CHAR(_) => true,"}, {"sha": "87b18f841ed28f4691d7bbc7904340ba527e0a86", "filename": "src/test/run-pass/vec-macro-with-brackets.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be673e77e75ece1611cdcf7b1b784ccd53cc9011/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs?ref=be673e77e75ece1611cdcf7b1b784ccd53cc9011", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! vec [\n+    ($($e:expr),*) => ({\n+        let mut _temp = ::std::vec::Vec::new();\n+        $(_temp.push($e);)*\n+        _temp\n+    })\n+]\n+\n+pub fn main() {\n+    let my_vec = vec![1, 2, 3, 4, 5];\n+}"}]}