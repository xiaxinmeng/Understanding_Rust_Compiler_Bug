{"sha": "a75e7f76865b5359b72bd8400a30083364ef180d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3NWU3Zjc2ODY1YjUzNTliNzJiZDg0MDBhMzAwODMzNjRlZjE4MGQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-21T08:32:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-21T08:32:27Z"}, "message": "don't allocate statics unless a reference to them is created", "tree": {"sha": "b7df496ea792793a24a088a5901c599242d55059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7df496ea792793a24a088a5901c599242d55059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a75e7f76865b5359b72bd8400a30083364ef180d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYCdKbAAoJEFbW7qD8Z6xGzo8P/0u2c4NwJ6fTlwTqTFcKkZZQ\nUZ6kqqkePyg+yXlrsJx32I1i27+eNascJ8yoL5VfiAdmgrsOnnOun9mDf252cXrO\nFnWFfnOn21NaJkgHKxAmmRnOm+k62Ds6A8vHhXSn0egB9GiTbmcfXnIvvMLodphA\nzsMWXKI78qELbdcT4zGFrNn8WHVxQ5R91NGYizH6Z7m9Jd6/4owVTIK+fxySItHO\ntDyZ94rG+59m0xBtKSGjD26Vu+lplrvCoLK6oEXaOb/RCtmP5vCJp1eUBiTHC3gH\n2Q83gL0MrNhfPJOPjXHfOdNiQG7yqxVXv4AOi4mxr7McvdQ2/SVXYfPGBbXJhZaW\n3el/71p629nbAGSXKeEFAh8DGI/lIBrbEM1MqtfGEa8njj7aDCvFkIfgHLhXuj1O\ntcrGi2LbbGAfKROvZpLBtfp5fqiEL9AX0/SlZUik1tNkJs0yebZ3nKuU59To/NZl\n+TwROTG/zmeYQluNJ2FRDR+6VBn+0el+DtY7SLGnE5Ik+bKNCUaGdmZvZdaOEKYC\ngxcQYiTUPGvIDvvERLbjrs3iCXdIlnFPqAG2zeGEsAAc0/jVMqEkYSM96d16BMKu\nUqZycudVilv4mP3px20PzC+FrUG89mIdf92+PGxwyS5H89K2CvfLkQCxg0HqNY5N\nTjOmNYzulfHCMB43jt+3\n=gZiZ\n-----END PGP SIGNATURE-----", "payload": "tree b7df496ea792793a24a088a5901c599242d55059\nparent bef879083e10461b5a3897e85958a289299594c9\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477038747 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477038747 +0200\n\ndon't allocate statics unless a reference to them is created"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a75e7f76865b5359b72bd8400a30083364ef180d", "html_url": "https://github.com/rust-lang/rust/commit/a75e7f76865b5359b72bd8400a30083364ef180d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a75e7f76865b5359b72bd8400a30083364ef180d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bef879083e10461b5a3897e85958a289299594c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bef879083e10461b5a3897e85958a289299594c9", "html_url": "https://github.com/rust-lang/rust/commit/bef879083e10461b5a3897e85958a289299594c9"}], "stats": {"total": 221, "additions": 149, "deletions": 72}, "files": [{"sha": "405a8b41c6cdc1feabccd3bb990775010a64ab45", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 140, "deletions": 60, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/a75e7f76865b5359b72bd8400a30083364ef180d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a75e7f76865b5359b72bd8400a30083364ef180d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=a75e7f76865b5359b72bd8400a30083364ef180d", "patch": "@@ -15,7 +15,7 @@ use std::rc::Rc;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer, AllocId};\n+use memory::{Memory, Pointer};\n use primval::{self, PrimVal, PrimValKind};\n pub use self::value::Value;\n \n@@ -41,8 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n-    // FIXME(solson): Change from Pointer to Value.\n-    statics: HashMap<ConstantId<'tcx>, Pointer>,\n+    statics: HashMap<ConstantId<'tcx>, Constant<'tcx>>,\n \n     /// The virtual call stack.\n     stack: Vec<Frame<'a, 'tcx>>,\n@@ -111,9 +110,11 @@ pub enum Lvalue<'tcx> {\n     Local {\n         frame: usize,\n         local: mir::Local,\n-    }\n+    },\n+\n+    Static(ConstantId<'tcx>),\n \n-    // TODO(solson): Static/Const? None/Never?\n+    // TODO(solson): None/Never?\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -130,9 +131,9 @@ pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Owned(Rc<mir::Mir<'tcx>>)\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n /// Uniquely identifies a specific constant or static\n-struct ConstantId<'tcx> {\n+pub struct ConstantId<'tcx> {\n     /// the def id of the constant/static or in case of promoteds, the def id of the function they belong to\n     def_id: DefId,\n     /// In case of statics and constants this is `Substs::empty()`, so only promoteds and associated\n@@ -143,18 +144,36 @@ struct ConstantId<'tcx> {\n     kind: ConstantKind,\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n enum ConstantKind {\n     Promoted(mir::Promoted),\n     /// Statics, constants and associated constants\n     Global,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct Constant<'tcx> {\n+    data: Option<Value>,\n+    mutable: bool,\n+    ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Constant<'tcx> {\n+    fn uninitialized(ty: Ty<'tcx>) -> Self {\n+        Constant {\n+            data: None,\n+            mutable: true,\n+            ty: ty,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// The stackframe existed to compute the initial value of a static/constant, make sure the\n-    /// static isn't modifyable afterwards\n-    Freeze(AllocId),\n+    /// static isn't modifyable afterwards. The allocation of the result is frozen iff it's an\n+    /// actual allocation. `PrimVal`s are unmodifyable anyway.\n+    Freeze,\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n@@ -380,7 +399,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n         match frame.return_to_block {\n-            StackPopCleanup::Freeze(alloc_id) => self.memory.freeze(alloc_id)?,\n+            StackPopCleanup::Freeze => if let Lvalue::Static(id) = frame.return_lvalue {\n+                let static_value = self.statics\n+                                       .get_mut(&id)\n+                                       .expect(\"static should have been cached (freeze)\");\n+                if let Value::ByRef(ptr) = static_value.data.expect(\"static should have been initialized\") {\n+                    self.memory.freeze(ptr.alloc_id)?;\n+                }\n+                assert!(static_value.mutable);\n+                static_value.mutable = false;\n+            } else {\n+                bug!(\"StackPopCleanup::Freeze on: {:?}\", frame.return_lvalue);\n+            },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n         }\n@@ -817,9 +847,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 substs: substs,\n                                 kind: ConstantKind::Global,\n                             };\n-                            let static_ptr = *self.statics.get(&cid)\n-                                .expect(\"static should have been cached (rvalue)\");\n-                            Value::ByRef(static_ptr)\n+                            self.read_lvalue(Lvalue::Static(cid))?\n                         }\n                     }\n \n@@ -829,9 +857,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             substs: self.substs(),\n                             kind: ConstantKind::Promoted(index),\n                         };\n-                        let static_ptr = *self.statics.get(&cid)\n-                            .expect(\"a promoted constant hasn't been precomputed\");\n-                        Value::ByRef(static_ptr)\n+                        self.read_lvalue(Lvalue::Static(cid))?\n                     }\n                 };\n \n@@ -864,6 +890,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n             }\n+            Lvalue::Static(cid) => Ok(self.statics\n+                                          .get(&cid)\n+                                          .expect(\"static not cached\")\n+                                          .data\n+                                          .expect(\"static not initialized\")),\n         }\n     }\n \n@@ -886,9 +917,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     substs: substs,\n                     kind: ConstantKind::Global,\n                 };\n-                let ptr = *self.statics.get(&cid)\n-                    .expect(\"static should have been cached (lvalue)\");\n-                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+                Lvalue::Static(cid)\n             }\n \n             Projection(ref proj) => return self.eval_lvalue_projection(proj),\n@@ -1078,8 +1107,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn force_allocation(&mut self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n-                let ptr = match self.stack[frame].get_local(local) {\n-                    Some(Value::ByRef(ptr)) => ptr,\n+                match self.stack[frame].get_local(local) {\n+                    Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n                     opt_val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let substs = self.stack[frame].substs;\n@@ -1088,12 +1117,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         if let Some(val) = opt_val {\n                             self.write_value_to_ptr(val, ptr, ty)?;\n                         }\n-                        ptr\n+                        Lvalue::from_ptr(ptr)\n                     }\n-                };\n-                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+                }\n             }\n             Lvalue::Ptr { .. } => lvalue,\n+            Lvalue::Static(cid) => {\n+                let static_val = *self.statics.get(&cid).expect(\"static not cached\");\n+                match static_val.data {\n+                    Some(Value::ByRef(ptr)) => Lvalue::from_ptr(ptr),\n+                    _ => {\n+                        let ptr = self.alloc_ptr_with_substs(static_val.ty, cid.substs)?;\n+                        if let Some(val) = static_val.data {\n+                            self.write_value_to_ptr(val, ptr, static_val.ty)?;\n+                        }\n+                        if !static_val.mutable {\n+                            self.memory.freeze(ptr.alloc_id)?;\n+                        }\n+                        let lval = self.statics.get_mut(&cid).expect(\"already checked\");\n+                        *lval = Constant {\n+                            data: Some(Value::ByRef(ptr)),\n+                            .. static_val\n+                        };\n+                        Lvalue::from_ptr(ptr)\n+                    },\n+                }\n+            }\n         };\n         Ok(new_lvalue)\n     }\n@@ -1173,6 +1222,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.stack[frame].set_local(local, Value::ByVal(val));\n                 Ok(())\n             }\n+            Lvalue::Static(cid) => {\n+                let static_val = self.statics.get_mut(&cid).expect(\"static not cached\");\n+                assert!(static_val.mutable);\n+                static_val.data = Some(Value::ByVal(val));\n+                Ok(())\n+            }\n         }\n     }\n \n@@ -1183,48 +1238,73 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match dest {\n+            Lvalue::Static(cid) => {\n+                let dest = *self.statics.get_mut(&cid).expect(\"static should be cached\");\n+                assert!(dest.mutable);\n+                self.write_value_to_dest(\n+                    src_val,\n+                    |this, val| *this.statics.get_mut(&cid).expect(\"already checked\") = Constant { data: Some(val), ..dest },\n+                    dest.data,\n+                    dest_ty,\n+                )\n+            },\n+\n             Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_value_to_ptr(src_val, ptr, dest_ty)?;\n+                self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n-            // The cases here can be a bit subtle. Read carefully!\n             Lvalue::Local { frame, local } => {\n-                let dest_val = self.stack[frame].get_local(local);\n-\n-                if let Some(Value::ByRef(dest_ptr)) = dest_val {\n-                    // If the local value is already `ByRef` (that is, backed by an `Allocation`),\n-                    // then we must write the new value into this allocation, because there may be\n-                    // other pointers into the allocation. These other pointers are logically\n-                    // pointers into the local variable, and must be able to observe the change.\n-                    //\n-                    // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n-                    // knew for certain that there were no outstanding pointers to this local.\n-                    self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n-\n-                } else if let Value::ByRef(src_ptr) = src_val {\n-                    // If the local value is not `ByRef`, then we know there are no pointers to it\n-                    // and we can simply overwrite the `Value` in the locals array directly.\n-                    //\n-                    // In this specific case, where the source value is `ByRef`, we must duplicate\n-                    // the allocation, because this is a by-value operation. It would be incorrect\n-                    // if they referred to the same allocation, since then a change to one would\n-                    // implicitly change the other.\n-                    //\n-                    // TODO(solson): It would be valid to attempt reading a primitive value out of\n-                    // the source and writing that into the destination without making an\n-                    // allocation. This would be a pure optimization.\n-                    let dest_ptr = self.alloc_ptr(dest_ty)?;\n-                    self.copy(src_ptr, dest_ptr, dest_ty)?;\n-                    self.stack[frame].set_local(local, Value::ByRef(dest_ptr));\n-\n-                } else {\n-                    // Finally, we have the simple case where neither source nor destination are\n-                    // `ByRef`. We may simply copy the source value over the the destintion local.\n-                    self.stack[frame].set_local(local, src_val);\n-                }\n+                let dest = self.stack[frame].get_local(local);\n+                self.write_value_to_dest(\n+                    src_val,\n+                    |this, val| this.stack[frame].set_local(local, val),\n+                    dest,\n+                    dest_ty,\n+                )\n             }\n         }\n+    }\n+\n+    // The cases here can be a bit subtle. Read carefully!\n+    fn write_value_to_dest<F: FnOnce(&mut Self, Value)>(\n+        &mut self,\n+        src_val: Value,\n+        write_dest: F,\n+        dest_val: Option<Value>,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        if let Some(Value::ByRef(dest_ptr)) = dest_val {\n+            // If the local value is already `ByRef` (that is, backed by an `Allocation`),\n+            // then we must write the new value into this allocation, because there may be\n+            // other pointers into the allocation. These other pointers are logically\n+            // pointers into the local variable, and must be able to observe the change.\n+            //\n+            // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n+            // knew for certain that there were no outstanding pointers to this local.\n+            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n+\n+        } else if let Value::ByRef(src_ptr) = src_val {\n+            // If the local value is not `ByRef`, then we know there are no pointers to it\n+            // and we can simply overwrite the `Value` in the locals array directly.\n+            //\n+            // In this specific case, where the source value is `ByRef`, we must duplicate\n+            // the allocation, because this is a by-value operation. It would be incorrect\n+            // if they referred to the same allocation, since then a change to one would\n+            // implicitly change the other.\n+            //\n+            // TODO(solson): It would be valid to attempt reading a primitive value out of\n+            // the source and writing that into the destination without making an\n+            // allocation. This would be a pure optimization.\n+            let dest_ptr = self.alloc_ptr(dest_ty)?;\n+            self.copy(src_ptr, dest_ptr, dest_ty)?;\n+            write_dest(self, Value::ByRef(dest_ptr));\n+\n+        } else {\n+            // Finally, we have the simple case where neither source nor destination are\n+            // `ByRef`. We may simply copy the source value over the the destintion local.\n+            write_dest(self, src_val);\n+        }\n         Ok(())\n     }\n "}, {"sha": "6c7d61b54e405ade1bcfb0e0adb3c0c05b55e98e", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a75e7f76865b5359b72bd8400a30083364ef180d/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a75e7f76865b5359b72bd8400a30083364ef180d/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=a75e7f76865b5359b72bd8400a30083364ef180d", "patch": "@@ -9,6 +9,7 @@ use super::{\n     Lvalue,\n     ConstantKind,\n     StackPopCleanup,\n+    Constant,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n@@ -128,15 +129,13 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         }\n         self.try(|this| {\n             let mir = this.ecx.load_mir(def_id)?;\n-            // FIXME(solson): Don't allocate a pointer unconditionally.\n-            let ptr = this.ecx.alloc_ptr_with_substs(mir.return_ty, substs)?;\n-            this.ecx.statics.insert(cid.clone(), ptr);\n+            this.ecx.statics.insert(cid.clone(), Constant::uninitialized(mir.return_ty));\n             let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n-                StackPopCleanup::Freeze(ptr.alloc_id)\n+                StackPopCleanup::Freeze\n             } else {\n                 StackPopCleanup::None\n             };\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::from_ptr(ptr), cleanup)\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Lvalue::Static(cid.clone()), cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -167,6 +166,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 }\n             },\n             mir::Literal::Promoted { index } => {\n+                let mir = self.mir.promoted[index].clone();\n                 let cid = ConstantId {\n                     def_id: self.def_id,\n                     substs: self.substs,\n@@ -175,19 +175,16 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 if self.ecx.statics.contains_key(&cid) {\n                     return;\n                 }\n-                let mir = self.mir.promoted[index].clone();\n-                let return_ty = mir.return_ty;\n                 self.try(|this| {\n-                    // FIXME(solson): Don't allocate a pointer unconditionally.\n-                    let return_ptr = this.ecx.alloc_ptr_with_substs(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n-                    this.ecx.statics.insert(cid.clone(), return_ptr);\n+                    let ty = this.ecx.monomorphize(mir.return_ty, this.substs);\n+                    this.ecx.statics.insert(cid.clone(), Constant::uninitialized(ty));\n                     this.ecx.push_stack_frame(this.def_id,\n                                               constant.span,\n                                               mir,\n                                               this.substs,\n-                                              Lvalue::from_ptr(return_ptr),\n-                                              StackPopCleanup::Freeze(return_ptr.alloc_id))\n+                                              Lvalue::Static(cid.clone()),\n+                                              StackPopCleanup::Freeze)\n                 });\n             }\n         }"}]}