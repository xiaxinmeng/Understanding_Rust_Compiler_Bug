{"sha": "7664dfe4331265d0b2b1ffb89c92d443886bec0b", "node_id": "C_kwDOAAsO6NoAKDc2NjRkZmU0MzMxMjY1ZDBiMmIxZmZiODljOTJkNDQzODg2YmVjMGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T00:33:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T00:33:43Z"}, "message": "Auto merge of #111925 - Manishearth:rollup-z6z6l2v, r=Manishearth\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #111741 (Use `ObligationCtxt` in custom type ops)\n - #111840 (Expose more information in `get_body_with_borrowck_facts`)\n - #111876 (Roll compiler_builtins to 0.1.92)\n - #111912 (Use `Option::is_some_and` and `Result::is_ok_and` in the compiler  )\n - #111915 (libtest: Improve error when missing `-Zunstable-options`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "09c5b7ca62f2202c566ff9a70760ce4284646506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09c5b7ca62f2202c566ff9a70760ce4284646506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7664dfe4331265d0b2b1ffb89c92d443886bec0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7664dfe4331265d0b2b1ffb89c92d443886bec0b", "html_url": "https://github.com/rust-lang/rust/commit/7664dfe4331265d0b2b1ffb89c92d443886bec0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7664dfe4331265d0b2b1ffb89c92d443886bec0b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096309e6dc4378e175e524e963332d1a3830ed63", "url": "https://api.github.com/repos/rust-lang/rust/commits/096309e6dc4378e175e524e963332d1a3830ed63", "html_url": "https://github.com/rust-lang/rust/commit/096309e6dc4378e175e524e963332d1a3830ed63"}, {"sha": "8038606bf32df8595811176e7299ef88133f9c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/8038606bf32df8595811176e7299ef88133f9c92", "html_url": "https://github.com/rust-lang/rust/commit/8038606bf32df8595811176e7299ef88133f9c92"}], "stats": {"total": 795, "additions": 417, "deletions": 378}, "files": [{"sha": "c7f39357534428c21bb27555688d3b4f2b5cd866", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -726,9 +726,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.91\"\n+version = \"0.1.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"571298a3cce7e2afbd3d61abb91a18667d5ab25993ec577a88ee8ac45f00cc3a\"\n+checksum = \"64518f1ae689f74db058bbfb3238dfe6eb53f59f4ae712f1ff4348628522e190\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\","}, {"sha": "4360fbeb9bbc1f828f550f908a80d6fbfd11497e", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -2391,10 +2391,10 @@ pub struct FnDecl {\n \n impl FnDecl {\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map_or(false, Param::is_self)\n+        self.inputs.get(0).is_some_and(Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map_or(false, |arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n+        self.inputs.last().is_some_and(|arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n     }\n }\n "}, {"sha": "15fe29580c29ce9acb1da1bd0209ff86651e6539", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -149,7 +149,7 @@ impl Attribute {\n     }\n \n     pub fn may_have_doc_links(&self) -> bool {\n-        self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n+        self.doc_str().is_some_and(|s| comments::may_have_doc_links(s.as_str()))\n     }\n \n     pub fn is_proc_macro_attr(&self) -> bool {\n@@ -441,12 +441,12 @@ impl NestedMetaItem {\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n     pub fn has_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n+        self.meta_item().is_some_and(|meta_item| meta_item.has_name(name))\n     }\n \n     /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+        self.meta_item().is_some_and(|meta_item| meta_item.is_word())\n     }\n \n     /// Gets a list of inner meta items from a list `MetaItem` type."}, {"sha": "7ef39f8026b209f0fd15a10a74b5f1e9f1d2abad", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -607,7 +607,7 @@ impl Token {\n     /// Returns `true` if the token is an identifier whose name is the given\n     /// string slice.\n     pub fn is_ident_named(&self, name: Symbol) -> bool {\n-        self.ident().map_or(false, |(ident, _)| ident.name == name)\n+        self.ident().is_some_and(|(ident, _)| ident.name == name)\n     }\n \n     /// Returns `true` if the token is an interpolated path."}, {"sha": "50eb92125b9450d15d54091823de59ccc96adf16", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -392,8 +392,7 @@ fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitErr\n         // Small bases are lexed as if they were base 10, e.g, the string\n         // might be `0b10201`. This will cause the conversion above to fail,\n         // but these kinds of errors are already reported by the lexer.\n-        let from_lexer =\n-            base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+        let from_lexer = base < 10 && s.chars().any(|c| c.to_digit(10).is_some_and(|d| d >= base));\n         if from_lexer { LitError::LexerError } else { LitError::IntTooLarge(base) }\n     })\n }"}, {"sha": "04ed27678765259a9cc47ce1eec644b3699a9f2b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -348,7 +348,7 @@ impl<'a> AstValidator<'a> {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n \n-        if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n+        if source_map.span_to_snippet(end).is_ok_and(|s| s == \";\") {\n             end\n         } else {\n             sp.shrink_to_hi()"}, {"sha": "274f931e43f9dcb683bd1af2cbb27079d739c4d1", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -317,8 +317,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n                 let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n-                let links_to_llvm =\n-                    link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n+                let links_to_llvm = link_name.is_some_and(|val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {\n                     gate_feature_post!(\n                         &self,"}, {"sha": "6be20b0974ddb6c74e74650401b72dc2da8bf533", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -30,7 +30,7 @@ pub struct BorrowSet<'tcx> {\n     /// Map from local to all the borrows on that local.\n     pub local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n-    pub(crate) locals_state_at_exit: LocalsStateAtExit,\n+    pub locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n@@ -153,7 +153,7 @@ impl<'tcx> BorrowSet<'tcx> {\n         self.activation_map.get(&location).map_or(&[], |activations| &activations[..])\n     }\n \n-    pub(crate) fn len(&self) -> usize {\n+    pub fn len(&self) -> usize {\n         self.location_map.len()\n     }\n "}, {"sha": "dc20b371d92e028337fb566364d9f5b918ded1e1", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 86, "deletions": 9, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -3,22 +3,95 @@\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::IndexSlice;\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_middle::mir::Body;\n+use rustc_middle::mir::{Body, Promoted};\n use rustc_middle::ty::TyCtxt;\n+use std::rc::Rc;\n+\n+use crate::borrow_set::BorrowSet;\n \n pub use super::{\n+    constraints::OutlivesConstraint,\n+    dataflow::{calculate_borrows_out_of_scope_at_location, BorrowIndex, Borrows},\n     facts::{AllFacts as PoloniusInput, RustcFacts},\n     location::{LocationTable, RichLocation},\n     nll::PoloniusOutput,\n-    BodyWithBorrowckFacts,\n+    place_ext::PlaceExt,\n+    places_conflict::{places_conflict, PlaceConflictBias},\n+    region_infer::RegionInferenceContext,\n };\n \n-/// This function computes Polonius facts for the given body. It makes a copy of\n-/// the body because it needs to regenerate the region identifiers. This function\n-/// should never be invoked during a typical compilation session due to performance\n-/// issues with Polonius.\n+/// Options determining the output behavior of [`get_body_with_borrowck_facts`].\n+///\n+/// If executing under `-Z polonius` the choice here has no effect, and everything as if\n+/// [`PoloniusOutputFacts`](ConsumerOptions::PoloniusOutputFacts) had been selected\n+/// will be retrieved.\n+#[derive(Debug, Copy, Clone)]\n+pub enum ConsumerOptions {\n+    /// Retrieve the [`Body`] along with the [`BorrowSet`](super::borrow_set::BorrowSet)\n+    /// and [`RegionInferenceContext`]. If you would like the body only, use\n+    /// [`TyCtxt::mir_promoted`].\n+    ///\n+    /// These can be used in conjunction with [`calculate_borrows_out_of_scope_at_location`].\n+    RegionInferenceContext,\n+    /// The recommended option. Retrieves the maximal amount of information\n+    /// without significant slowdowns.\n+    ///\n+    /// Implies [`RegionInferenceContext`](ConsumerOptions::RegionInferenceContext),\n+    /// and additionally retrieve the [`LocationTable`] and [`PoloniusInput`] that\n+    /// would be given to Polonius. Critically, this does not run Polonius, which\n+    /// one may want to avoid due to performance issues on large bodies.\n+    PoloniusInputFacts,\n+    /// Implies [`PoloniusInputFacts`](ConsumerOptions::PoloniusInputFacts),\n+    /// and additionally runs Polonius to calculate the [`PoloniusOutput`].\n+    PoloniusOutputFacts,\n+}\n+\n+impl ConsumerOptions {\n+    /// Should the Polonius input facts be computed?\n+    pub(crate) fn polonius_input(&self) -> bool {\n+        matches!(self, Self::PoloniusInputFacts | Self::PoloniusOutputFacts)\n+    }\n+    /// Should we run Polonius and collect the output facts?\n+    pub(crate) fn polonius_output(&self) -> bool {\n+        matches!(self, Self::PoloniusOutputFacts)\n+    }\n+}\n+\n+/// A `Body` with information computed by the borrow checker. This struct is\n+/// intended to be consumed by compiler consumers.\n+///\n+/// We need to include the MIR body here because the region identifiers must\n+/// match the ones in the Polonius facts.\n+pub struct BodyWithBorrowckFacts<'tcx> {\n+    /// A mir body that contains region identifiers.\n+    pub body: Body<'tcx>,\n+    /// The mir bodies of promoteds.\n+    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n+    /// The set of borrows occurring in `body` with data about them.\n+    pub borrow_set: Rc<BorrowSet<'tcx>>,\n+    /// Context generated during borrowck, intended to be passed to\n+    /// [`calculate_borrows_out_of_scope_at_location`].\n+    pub region_inference_context: Rc<RegionInferenceContext<'tcx>>,\n+    /// The table that maps Polonius points to locations in the table.\n+    /// Populated when using [`ConsumerOptions::PoloniusInputFacts`]\n+    /// or [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub location_table: Option<LocationTable>,\n+    /// Polonius input facts.\n+    /// Populated when using [`ConsumerOptions::PoloniusInputFacts`]\n+    /// or [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub input_facts: Option<Box<PoloniusInput>>,\n+    /// Polonius output facts. Populated when using\n+    /// [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub output_facts: Option<Rc<PoloniusOutput>>,\n+}\n+\n+/// This function computes borrowck facts for the given body. The [`ConsumerOptions`]\n+/// determine which facts are returned. This function makes a copy of the body because\n+/// it needs to regenerate the region identifiers. It should never be invoked during a\n+/// typical compilation session due to the unnecessary overhead of returning\n+/// [`BodyWithBorrowckFacts`].\n ///\n /// Note:\n /// *   This function will panic if the required body was already stolen. This\n@@ -28,10 +101,14 @@ pub use super::{\n ///     that shows how to do this at `tests/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n-pub fn get_body_with_borrowck_facts(tcx: TyCtxt<'_>, def: LocalDefId) -> BodyWithBorrowckFacts<'_> {\n+pub fn get_body_with_borrowck_facts(\n+    tcx: TyCtxt<'_>,\n+    def: LocalDefId,\n+    options: ConsumerOptions,\n+) -> BodyWithBorrowckFacts<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n-    *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n+    *super::do_mir_borrowck(&infcx, input_body, promoted, Some(options)).1.unwrap()\n }"}, {"sha": "2daa82aef39577dffab0dc4ae78410da408dc41e", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -228,27 +228,32 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n     }\n }\n \n+pub fn calculate_borrows_out_of_scope_at_location<'tcx>(\n+    body: &Body<'tcx>,\n+    regioncx: &RegionInferenceContext<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n+) -> FxIndexMap<Location, Vec<BorrowIndex>> {\n+    let mut prec = OutOfScopePrecomputer::new(body, regioncx);\n+    for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n+        let borrow_region = borrow_data.region;\n+        let location = borrow_data.reserve_location;\n+\n+        prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n+    }\n+\n+    prec.borrows_out_of_scope_at_location\n+}\n+\n impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    pub(crate) fn new(\n+    pub fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: &'a RegionInferenceContext<'tcx>,\n         borrow_set: &'a BorrowSet<'tcx>,\n     ) -> Self {\n-        let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n-        for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n-            let borrow_region = borrow_data.region;\n-            let location = borrow_data.reserve_location;\n-\n-            prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n-        }\n-\n-        Borrows {\n-            tcx,\n-            body,\n-            borrow_set,\n-            borrows_out_of_scope_at_location: prec.borrows_out_of_scope_at_location,\n-        }\n+        let borrows_out_of_scope_at_location =\n+            calculate_borrows_out_of_scope_at_location(body, nonlexical_regioncx, borrow_set);\n+        Borrows { tcx, body, borrow_set, borrows_out_of_scope_at_location }\n     }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {"}, {"sha": "f41795d60a0b4d219c2454888a6e6d7b488f66ee", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> ToUniverseInfo<'tcx>\n     }\n }\n \n-impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F, G>> {\n+impl<'tcx, F> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F>> {\n     fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         // We can't rerun custom type ops.\n         UniverseInfo::other()"}, {"sha": "1d430a93a876d2c9588f2c50d7a52e7223977fc2", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     let path_span = path_span.unwrap();\n                     // path_span is only present in the case of closure capture\n                     assert!(matches!(later_use_kind, LaterUseKind::ClosureCapture));\n-                    if !borrow_span.map_or(false, |sp| sp.overlaps(var_or_use_span)) {\n+                    if !borrow_span.is_some_and(|sp| sp.overlaps(var_or_use_span)) {\n                         let path_label = \"used here by closure\";\n                         let capture_kind_label = message;\n                         err.span_label(\n@@ -224,12 +224,9 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                             if info.tail_result_is_ignored {\n                                 // #85581: If the first mutable borrow's scope contains\n                                 // the second borrow, this suggestion isn't helpful.\n-                                if !multiple_borrow_span\n-                                    .map(|(old, new)| {\n-                                        old.to(info.span.shrink_to_hi()).contains(new)\n-                                    })\n-                                    .unwrap_or(false)\n-                                {\n+                                if !multiple_borrow_span.is_some_and(|(old, new)| {\n+                                    old.to(info.span.shrink_to_hi()).contains(new)\n+                                }) {\n                                     err.span_suggestion_verbose(\n                                         info.span.shrink_to_hi(),\n                                         \"consider adding semicolon after the expression so its \\"}, {"sha": "20370e4c6ac3cc17ff84876ab31bfeda4f5d9c4c", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1156,7 +1156,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 ty::Adt(def, ..) => Some(def.did()),\n                                 _ => None,\n                             });\n-                    let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+                    let is_option_or_result = parent_self_ty.is_some_and(|def_id| {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {"}, {"sha": "4bde372c847dd1b169ac2d3469f834430ec4c304", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -289,8 +289,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .body\n                     .local_decls\n                     .get(local)\n-                    .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local]))\n-                    .unwrap_or(false) =>\n+                    .is_some_and(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) =>\n             {\n                 let decl = &self.body.local_decls[local];\n                 err.span_label(span, format!(\"cannot {act}\"));\n@@ -443,7 +442,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .sess\n                     .source_map()\n                     .span_to_snippet(span)\n-                    .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n+                    .is_ok_and(|snippet| snippet.starts_with(\"&mut \")) =>\n             {\n                 err.span_label(span, format!(\"cannot {act}\"));\n                 err.span_suggestion("}, {"sha": "b6eb9ae980e4e28501d68ad28e8e91994ef76f03", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -125,8 +125,7 @@ impl OutlivesSuggestionBuilder {\n                     |(r, _)| {\n                         self.constraints_to_add\n                             .get(r)\n-                            .map(|r_outlived| r_outlived.as_slice().contains(fr))\n-                            .unwrap_or(false)\n+                            .is_some_and(|r_outlived| r_outlived.as_slice().contains(fr))\n                     },\n                 );\n "}, {"sha": "5124aa459b65058afcd19c2ae43c38c976cc6119", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -61,7 +61,7 @@ use crate::session_diagnostics::VarNeedNotMut;\n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n-use facts::AllFacts;\n+use consumers::{BodyWithBorrowckFacts, ConsumerOptions};\n \n use self::path_utils::*;\n \n@@ -143,23 +143,23 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: LocalDefId) -> &BorrowCheckResult<'_> {\n         tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n-    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n+    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, None).0;\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)\n }\n \n /// Perform the actual borrow checking.\n ///\n-/// If `return_body_with_facts` is true, then return the body with non-erased\n-/// region ids on which the borrow checking was performed together with Polonius\n-/// facts.\n+/// Use `consumer_options: None` for the default behavior of returning\n+/// [`BorrowCheckResult`] only. Otherwise, return [`BodyWithBorrowckFacts`] according\n+/// to the given [`ConsumerOptions`].\n #[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.def_id()), level = \"debug\")]\n fn do_mir_borrowck<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexSlice<Promoted, Body<'tcx>>,\n-    return_body_with_facts: bool,\n+    consumer_options: Option<ConsumerOptions>,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.def_id().expect_local();\n     debug!(?def);\n@@ -240,8 +240,6 @@ fn do_mir_borrowck<'tcx>(\n     let borrow_set =\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n-    let use_polonius = return_body_with_facts || infcx.tcx.sess.opts.unstable_opts.polonius;\n-\n     // Compute non-lexical lifetimes.\n     let nll::NllOutput {\n         regioncx,\n@@ -261,7 +259,7 @@ fn do_mir_borrowck<'tcx>(\n         &mdpe.move_data,\n         &borrow_set,\n         &upvars,\n-        use_polonius,\n+        consumer_options,\n     );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -441,13 +439,16 @@ fn do_mir_borrowck<'tcx>(\n         tainted_by_errors,\n     };\n \n-    let body_with_facts = if return_body_with_facts {\n-        let output_facts = mbcx.polonius_output.expect(\"Polonius output was not computed\");\n+    let body_with_facts = if consumer_options.is_some() {\n+        let output_facts = mbcx.polonius_output;\n         Some(Box::new(BodyWithBorrowckFacts {\n             body: body_owned,\n-            input_facts: *polonius_input.expect(\"Polonius input facts were not generated\"),\n+            promoted,\n+            borrow_set,\n+            region_inference_context: regioncx,\n+            location_table: polonius_input.as_ref().map(|_| location_table_owned),\n+            input_facts: polonius_input,\n             output_facts,\n-            location_table: location_table_owned,\n         }))\n     } else {\n         None\n@@ -458,22 +459,6 @@ fn do_mir_borrowck<'tcx>(\n     (result, body_with_facts)\n }\n \n-/// A `Body` with information computed by the borrow checker. This struct is\n-/// intended to be consumed by compiler consumers.\n-///\n-/// We need to include the MIR body here because the region identifiers must\n-/// match the ones in the Polonius facts.\n-pub struct BodyWithBorrowckFacts<'tcx> {\n-    /// A mir body that contains region identifiers.\n-    pub body: Body<'tcx>,\n-    /// Polonius input facts.\n-    pub input_facts: AllFacts,\n-    /// Polonius output facts.\n-    pub output_facts: Rc<self::nll::PoloniusOutput>,\n-    /// The table that maps Polonius points to locations in the table.\n-    pub location_table: LocationTable,\n-}\n-\n pub struct BorrowckInferCtxt<'cx, 'tcx> {\n     pub(crate) infcx: &'cx InferCtxt<'tcx>,\n     pub(crate) reg_var_to_origin: RefCell<FxIndexMap<ty::RegionVid, RegionCtxt>>,"}, {"sha": "889acb3acbed7579183ead34a160356bab333fe1", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -27,6 +27,7 @@ use rustc_mir_dataflow::ResultsCursor;\n use crate::{\n     borrow_set::BorrowSet,\n     constraint_generation,\n+    consumers::ConsumerOptions,\n     diagnostics::RegionErrors,\n     facts::{AllFacts, AllFactsExt, RustcFacts},\n     invalidation,\n@@ -165,10 +166,14 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n     upvars: &[Upvar<'tcx>],\n-    use_polonius: bool,\n+    consumer_options: Option<ConsumerOptions>,\n ) -> NllOutput<'tcx> {\n+    let polonius_input = consumer_options.map(|c| c.polonius_input()).unwrap_or_default()\n+        || infcx.tcx.sess.opts.unstable_opts.polonius;\n+    let polonius_output = consumer_options.map(|c| c.polonius_output()).unwrap_or_default()\n+        || infcx.tcx.sess.opts.unstable_opts.polonius;\n     let mut all_facts =\n-        (use_polonius || AllFacts::enabled(infcx.tcx)).then_some(AllFacts::default());\n+        (polonius_input || AllFacts::enabled(infcx.tcx)).then_some(AllFacts::default());\n \n     let universal_regions = Rc::new(universal_regions);\n \n@@ -189,7 +194,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n             move_data,\n             elements,\n             upvars,\n-            use_polonius,\n+            polonius_input,\n         );\n \n     if let Some(all_facts) = &mut all_facts {\n@@ -284,7 +289,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n             all_facts.write_to_dir(dir_path, location_table).unwrap();\n         }\n \n-        if use_polonius {\n+        if polonius_output {\n             let algorithm =\n                 env::var(\"POLONIUS_ALGORITHM\").unwrap_or_else(|_| String::from(\"Hybrid\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();"}, {"sha": "d521d0db21323df8526d25c5309cf5302f122dc3", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::mir::{Body, Mutability, Place};\n use rustc_middle::ty::{self, TyCtxt};\n \n /// Extension methods for the `Place` type.\n-pub(crate) trait PlaceExt<'tcx> {\n+pub trait PlaceExt<'tcx> {\n     /// Returns `true` if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true"}, {"sha": "25c485b814f4a1ae1220bce79757c8d2e5dab821", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -16,15 +16,15 @@ use std::iter;\n /// being run in the calling context, the conservative choice is to assume the compared indices\n /// are disjoint (and therefore, do not overlap).\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub(crate) enum PlaceConflictBias {\n+pub enum PlaceConflictBias {\n     Overlap,\n     NoOverlap,\n }\n \n /// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n-pub(crate) fn places_conflict<'tcx>(\n+pub fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: Place<'tcx>,"}, {"sha": "50b246b1478fcb2109a8968a995140ac082054c4", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -585,6 +585,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n+    /// Returns an iterator over all the outlives constraints.\n+    pub fn outlives_constraints(&self) -> impl Iterator<Item = OutlivesConstraint<'tcx>> + '_ {\n+        self.constraints.outlives().iter().copied()\n+    }\n+\n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n     pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         self.universal_regions.annotate(tcx, err)\n@@ -712,7 +717,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(skip(self, _body), level = \"debug\")]\n     fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n         debug!(\"constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n+            let mut constraints: Vec<_> = self.outlives_constraints().collect();\n             constraints.sort_by_key(|c| (c.sup, c.sub));\n             constraints\n                 .into_iter()"}, {"sha": "9290e7479144ade256caeb11b57b91bca5b8ca1b", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -159,7 +159,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// Returns `true` if the region `r` contains the given element.\n     pub(crate) fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n-        self.points.row(row).map_or(false, |r| r.contains(index))\n+        self.points.row(row).is_some_and(|r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`"}, {"sha": "95dcc8d4b1916f1b24fc64ecbe1778ae52ba57c6", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1,13 +1,13 @@\n use std::fmt;\n \n-use rustc_infer::infer::{canonical::Canonical, InferOk};\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n-use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n+use rustc_trait_selection::traits::ObligationCause;\n \n use crate::diagnostics::{ToUniverseInfo, UniverseInfo};\n \n@@ -219,20 +219,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let cause = ObligationCause::dummy_with_span(span);\n         let param_env = self.param_env;\n-        let op = |infcx: &'_ _| {\n-            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n-            let user_ty = ocx.normalize(&cause, param_env, user_ty);\n-            ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n-            if !ocx.select_all_or_error().is_empty() {\n-                return Err(NoSolution);\n-            }\n-            Ok(InferOk { value: (), obligations: vec![] })\n-        };\n-\n         self.fully_perform_op(\n             Locations::All(span),\n             ConstraintCategory::Boring,\n-            type_op::custom::CustomTypeOp::new(op, || \"ascribe_user_type_skip_wf\".to_string()),\n+            type_op::custom::CustomTypeOp::new(\n+                |ocx| {\n+                    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+                    ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n+                    Ok(())\n+                },\n+                \"ascribe_user_type_skip_wf\",\n+            ),\n         )\n         .unwrap_or_else(|err| {\n             span_mirbug!("}, {"sha": "162828ee80b442b3a392f2ccaf799314c171a3b2", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -20,7 +20,7 @@ use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n-    InferCtxt, InferOk, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n+    InferCtxt, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n };\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n@@ -211,16 +211,16 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                     Locations::All(body.span),\n                     ConstraintCategory::OpaqueType,\n                     CustomTypeOp::new(\n-                        |infcx| {\n-                            infcx.register_member_constraints(\n+                        |ocx| {\n+                            ocx.infcx.register_member_constraints(\n                                 param_env,\n                                 opaque_type_key,\n                                 decl.hidden_type.ty,\n                                 decl.hidden_type.span,\n                             );\n-                            Ok(InferOk { value: (), obligations: vec![] })\n+                            Ok(())\n                         },\n-                        || \"opaque_type_map\".to_string(),\n+                        \"opaque_type_map\",\n                     ),\n                 )\n                 .unwrap();\n@@ -2695,8 +2695,9 @@ impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n     type ErrorInfo = InstantiateOpaqueType<'tcx>;\n \n     fn fully_perform(mut self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n-        let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n-            Ok(InferOk { value: (), obligations: self.obligations.clone() })\n+        let (mut output, region_constraints) = scrape_region_constraints(infcx, |ocx| {\n+            ocx.register_obligations(self.obligations.clone());\n+            Ok(())\n         })?;\n         self.region_constraints = Some(region_constraints);\n         output.error_info = Some(self);"}, {"sha": "dd1f89e5b9157f15c7380682c3f9b0eec15e9a79", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -185,17 +185,25 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     }\n \n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n-        self.type_checker\n-            .fully_perform_op(\n-                self.locations,\n-                self.category,\n-                InstantiateOpaqueType {\n-                    obligations,\n-                    // These fields are filled in during execution of the operation\n-                    base_universe: None,\n-                    region_constraints: None,\n-                },\n-            )\n-            .unwrap();\n+        match self.type_checker.fully_perform_op(\n+            self.locations,\n+            self.category,\n+            InstantiateOpaqueType {\n+                obligations,\n+                // These fields are filled in during execution of the operation\n+                base_universe: None,\n+                region_constraints: None,\n+            },\n+        ) {\n+            Ok(()) => {}\n+            Err(_) => {\n+                // It's a bit redundant to delay a bug here, but I'd rather\n+                // delay more bugs than accidentally not delay a bug at all.\n+                self.type_checker.tcx().sess.delay_span_bug(\n+                    self.locations.span(self.type_checker.body),\n+                    \"errors selecting obligation during MIR typeck\",\n+                );\n+            }\n+        };\n     }\n }"}, {"sha": "49401e9ca94960669b17ba704360074b6009ed72", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -119,7 +119,7 @@ impl<'ast> visit::Visitor<'ast> for CfgFinder {\n         self.has_cfg_or_cfg_attr = self.has_cfg_or_cfg_attr\n             || attr\n                 .ident()\n-                .map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n+                .is_some_and(|ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n     }\n }\n "}, {"sha": "84e09cf0abe4fe54d1f82263d110a1f8c0c733b5", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -432,11 +432,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let is_cold = if fn_sig.abi() == Abi::RustCold {\n         true\n     } else {\n-        instance\n-            .map(|inst| {\n-                fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n-            })\n-            .unwrap_or(false)\n+        instance.is_some_and(|inst| {\n+            fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n+        })\n     };\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n@@ -470,7 +468,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     // Pass the caller location for `#[track_caller]`.\n-    if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n+    if instance.is_some_and(|inst| inst.def.requires_caller_location(fx.tcx)) {\n         let caller_location = fx.get_caller_location(source_info);\n         args.push(CallArgument { value: caller_location, is_owned: false });\n     }"}, {"sha": "9c6a0fae327cf2999c680095bfbb6b74bcc9415d", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -630,11 +630,11 @@ fn codegen_stmt<'tcx>(\n                     let to_ty = fx.monomorphize(to_ty);\n \n                     fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-                        ty.builtin_deref(true)\n-                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                        ty.builtin_deref(true).is_some_and(\n+                            |ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n                                 has_ptr_meta(fx.tcx, pointee_ty)\n-                            })\n-                            .unwrap_or(false)\n+                            },\n+                        )\n                     }\n \n                     if is_fat_ptr(fx, from_ty) {"}, {"sha": "21a1ac348443ecb74b639445b14544f3229343d6", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -163,7 +163,7 @@ impl CoverageMapGenerator {\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n             let CodeRegion { file_name, start_line, start_col, end_line, end_col } = *region;\n-            let same_file = current_file_name.map_or(false, |p| p == file_name);\n+            let same_file = current_file_name.is_some_and(|p| p == file_name);\n             if !same_file {\n                 if current_file_name.is_some() {\n                     current_file_id += 1;"}, {"sha": "c24854b27a02e9095e106ed9c271478fae11e3b8", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -125,8 +125,7 @@ impl CodegenCx<'_, '_> {\n \n         // Thread-local variables generally don't support copy relocations.\n         let is_thread_local_var = llvm::LLVMIsAGlobalVariable(llval)\n-            .map(|v| llvm::LLVMIsThreadLocal(v) == llvm::True)\n-            .unwrap_or(false);\n+            .is_some_and(|v| llvm::LLVMIsThreadLocal(v) == llvm::True);\n         if is_thread_local_var {\n             return false;\n         }"}, {"sha": "1f5f5b69d4dc884266001b381455686bf0aac1df", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1031,7 +1031,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         });\n \n         let needs_location =\n-            instance.map_or(false, |i| i.def.requires_caller_location(self.cx.tcx()));\n+            instance.is_some_and(|i| i.def.requires_caller_location(self.cx.tcx()));\n         if needs_location {\n             let mir_args = if let Some(num_untupled) = num_untupled {\n                 first_args.len() + num_untupled"}, {"sha": "138bc3eb74a4fb350209435f025c192737c8403e", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -944,7 +944,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate)\n                     };\n                     let feature_gate_declared = gate_declared(gate);\n-                    let implied_gate_declared = implied_by.map(gate_declared).unwrap_or(false);\n+                    let implied_gate_declared = implied_by.is_some_and(gate_declared);\n                     if !feature_gate_declared && !implied_gate_declared {\n                         self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n                         return;\n@@ -971,7 +971,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 // have no `rustc_const_stable` attributes to be const-unstable as well. This\n                 // should be fixed later.\n                 let callee_is_unstable_unmarked = tcx.lookup_const_stability(callee).is_none()\n-                    && tcx.lookup_stability(callee).map_or(false, |s| s.is_unstable());\n+                    && tcx.lookup_stability(callee).is_some_and(|s| s.is_unstable());\n                 if callee_is_unstable_unmarked {\n                     trace!(\"callee_is_unstable_unmarked\");\n                     // We do not use `const` modifiers for intrinsic \"functions\", as intrinsics are"}, {"sha": "8ebfee8878cbbc8ccc506178be688a610c3cf4a6", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -139,5 +139,5 @@ fn is_parent_const_stable_trait(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         return false;\n     }\n \n-    tcx.lookup_const_stability(parent.owner).map_or(false, |stab| stab.is_const_stable())\n+    tcx.lookup_const_stability(parent.owner).is_some_and(|stab| stab.is_const_stable())\n }"}, {"sha": "a47908648ba16531299cee070f182bc4a141dae9", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -366,7 +366,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map_or(false, |errors| errors.contains(v.key()));\n+                        .is_some_and(|errors| errors.contains(v.key()));\n \n                 if already_failed {\n                     Err(())"}, {"sha": "40aa69e5a41058826a92195611eda17712009509", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1315,7 +1315,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str, extra_info:\n     }\n \n     // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").is_some_and(|x| &x != \"0\");\n \n     let num_frames = if backtrace { None } else { Some(2) };\n "}, {"sha": "6d944e513145699d772984b589973d244066224a", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -285,15 +285,11 @@ pub trait Emitter: Translate {\n                     format!(\n                         \"help: {}{}: `{}`\",\n                         &msg,\n-                        if self\n-                            .source_map()\n-                            .map(|sm| is_case_difference(\n-                                sm,\n-                                substitution,\n-                                sugg.substitutions[0].parts[0].span,\n-                            ))\n-                            .unwrap_or(false)\n-                        {\n+                        if self.source_map().is_some_and(|sm| is_case_difference(\n+                            sm,\n+                            substitution,\n+                            sugg.substitutions[0].parts[0].span,\n+                        )) {\n                             \" (notice the capitalization)\"\n                         } else {\n                             \"\""}, {"sha": "3dec0d9299c4ebcfa377dda41829e6d632382295", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1437,7 +1437,7 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map_or(false, |c| {\n+        self.flags.treat_err_as_bug.is_some_and(|c| {\n             self.err_count() + self.lint_err_count + self.delayed_bug_count() >= c.get()\n         })\n     }\n@@ -1603,7 +1603,7 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+        if self.flags.treat_err_as_bug.is_some_and(|c| {\n             self.err_count() + self.lint_err_count + self.delayed_bug_count() + 1 >= c.get()\n         }) {\n             // FIXME: don't abort here if report_delayed_bugs is off"}, {"sha": "4671adccc54160437305107ee36669c41f7b158d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -780,7 +780,7 @@ impl SyntaxExtension {\n         let allow_internal_unsafe = attr::contains_name(attrs, sym::allow_internal_unsafe);\n         let local_inner_macros = attr::find_by_name(attrs, sym::macro_export)\n             .and_then(|macro_export| macro_export.meta_item_list())\n-            .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n+            .is_some_and(|l| attr::list_contains_name(&l, sym::local_inner_macros));\n         let collapse_debuginfo = attr::contains_name(attrs, sym::collapse_debuginfo);\n         tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n@@ -1449,7 +1449,7 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n                                     && version\n                                         .next()\n                                         .and_then(|c| c.parse::<u32>().ok())\n-                                        .map_or(false, |v| v < 6)\n+                                        .is_some_and(|v| v < 6)\n                             };\n \n                             if crate_matches {"}, {"sha": "ce0093c7d4c0ee723a75d080b4ad30552ad41bb3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1599,7 +1599,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     cfg_pos = Some(pos); // a cfg attr found, no need to search anymore\n                     break;\n                 } else if attr_pos.is_none()\n-                    && !name.map_or(false, rustc_feature::is_builtin_attr_name)\n+                    && !name.is_some_and(rustc_feature::is_builtin_attr_name)\n                 {\n                     attr_pos = Some(pos); // a non-cfg attr found, still may find a cfg attr\n                 }\n@@ -1647,7 +1647,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             let current_span = if let Some(sp) = span { sp.to(attr.span) } else { attr.span };\n             span = Some(current_span);\n \n-            if attrs.peek().map_or(false, |next_attr| next_attr.doc_str().is_some()) {\n+            if attrs.peek().is_some_and(|next_attr| next_attr.doc_str().is_some()) {\n                 continue;\n             }\n \n@@ -1950,6 +1950,6 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n \n     fn proc_macro_hygiene(&self) -> bool {\n-        self.features.map_or(false, |features| features.proc_macro_hygiene)\n+        self.features.is_some_and(|features| features.proc_macro_hygiene)\n     }\n }"}, {"sha": "06f4a0b5eef847846099010442dfdb27efa00673", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -861,11 +861,11 @@ pub fn is_builtin_attr_name(name: Symbol) -> bool {\n /// Whether this builtin attribute is only used in the local crate.\n /// If so, it is not encoded in the crate metadata.\n pub fn is_builtin_only_local(name: Symbol) -> bool {\n-    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some_and(|attr| attr.only_local)\n }\n \n pub fn is_valid_for_get_attr(name: Symbol) -> bool {\n-    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| match attr.duplicates {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some_and(|attr| match attr.duplicates {\n         WarnFollowing | ErrorFollowing | ErrorPreceding | FutureWarnFollowing\n         | FutureWarnPreceding => true,\n         DuplicatesOk | WarnFollowingWordOnly => false,"}, {"sha": "beb6307846d3e8d0e1ee683f60157b11e2ffa77a", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -84,14 +84,13 @@ impl UnstableFeatures {\n     pub fn from_environment(krate: Option<&str>) -> Self {\n         // `true` if this is a feature-staged build, i.e., on the beta or stable channel.\n         let disable_unstable_features =\n-            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").map(|s| s != \"0\").unwrap_or(false);\n+            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some_and(|s| s != \"0\");\n         // Returns whether `krate` should be counted as unstable\n-        let is_unstable_crate = |var: &str| {\n-            krate.map_or(false, |name| var.split(',').any(|new_krate| new_krate == name))\n-        };\n+        let is_unstable_crate =\n+            |var: &str| krate.is_some_and(|name| var.split(',').any(|new_krate| new_krate == name));\n         // `true` if we should enable unstable features for bootstrapping.\n-        let bootstrap = std::env::var(\"RUSTC_BOOTSTRAP\")\n-            .map_or(false, |var| var == \"1\" || is_unstable_crate(&var));\n+        let bootstrap =\n+            std::env::var(\"RUSTC_BOOTSTRAP\").is_ok_and(|var| var == \"1\" || is_unstable_crate(&var));\n         match (disable_unstable_features, bootstrap) {\n             (_, true) => UnstableFeatures::Cheat,\n             (true, _) => UnstableFeatures::Disallow,"}, {"sha": "e84473109176150b147e501235885bb0d9b81e45", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -787,7 +787,7 @@ pub struct WhereBoundPredicate<'hir> {\n impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n-        self.bounded_ty.as_generic_param().map_or(false, |(def_id, _)| def_id == param_def_id)\n+        self.bounded_ty.as_generic_param().is_some_and(|(def_id, _)| def_id == param_def_id)\n     }\n }\n "}, {"sha": "5fb06cf94652ea5d9876ac80512e1be8bb5a39ac", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -2625,7 +2625,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     && tcx.all_impls(*trait_def_id)\n                         .any(|impl_def_id| {\n                             let trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                            trait_ref.map_or(false, |trait_ref| {\n+                            trait_ref.is_some_and(|trait_ref| {\n                                 let impl_ = trait_ref.subst(\n                                     tcx,\n                                     infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n@@ -3654,7 +3654,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ..\n         }) = tcx.hir().get_by_def_id(parent_id) && self_ty.hir_id == impl_self_ty.hir_id\n         {\n-            if !of_trait_ref.trait_def_id().map_or(false, |def_id| def_id.is_local()) {\n+            if !of_trait_ref.trait_def_id().is_some_and(|def_id| def_id.is_local()) {\n                 return;\n             }\n             let of_trait_span = of_trait_ref.path.span;\n@@ -3693,7 +3693,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .source_map()\n                     .span_to_prev_source(self_ty.span)\n                     .ok()\n-                    .map_or(false, |s| s.trim_end().ends_with('<'));\n+                    .is_some_and(|s| s.trim_end().ends_with('<'));\n \n             let is_global = poly_trait_ref.trait_ref.path.is_global();\n "}, {"sha": "933923f9dfc2d2659d73db5c0f59e0da17642498", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -800,16 +800,15 @@ fn check_impl_items_against_trait<'tcx>(\n \n             let is_implemented = leaf_def\n                 .as_ref()\n-                .map_or(false, |node_item| node_item.item.defaultness(tcx).has_value());\n+                .is_some_and(|node_item| node_item.item.defaultness(tcx).has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n \n             // true if this item is specifically implemented in this impl\n-            let is_implemented_here = leaf_def\n-                .as_ref()\n-                .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n+            let is_implemented_here =\n+                leaf_def.as_ref().is_some_and(|node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n                 let full_impl_span =\n@@ -1082,8 +1081,8 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>)\n         let layout = tcx.layout_of(param_env.and(ty));\n         // We are currently checking the type this field came from, so it must be local\n         let span = tcx.hir().span_if_local(field.did).unwrap();\n-        let zst = layout.map_or(false, |layout| layout.is_zst());\n-        let align1 = layout.map_or(false, |layout| layout.align.abi.bytes() == 1);\n+        let zst = layout.is_ok_and(|layout| layout.is_zst());\n+        let align1 = layout.is_ok_and(|layout| layout.align.abi.bytes() == 1);\n         if !zst {\n             return (span, zst, align1, None);\n         }"}, {"sha": "b403ee96b42298df750bed96dc856f19c9991d5e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -179,7 +179,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Impl(impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n-                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n+                .is_some_and(|trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n                 let mut err ="}, {"sha": "ca0d5509c5768e761a3de5c9ec40a222f6ad7655", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -819,7 +819,7 @@ fn convert_variant(\n         recovered,\n         adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive)\n             || variant_did\n-                .map_or(false, |variant_did| tcx.has_attr(variant_did, sym::non_exhaustive)),\n+                .is_some_and(|variant_did| tcx.has_attr(variant_did, sym::non_exhaustive)),\n     )\n }\n \n@@ -1025,7 +1025,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n             is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.args().args)\n         }\n         Path(hir::QPath::Resolved(ty_opt, hir::Path { segments, .. })) => {\n-            ty_opt.map_or(false, is_suggestable_infer_ty)\n+            ty_opt.is_some_and(is_suggestable_infer_ty)\n                 || segments.iter().any(|segment| are_suggestable_generic_args(segment.args().args))\n         }\n         _ => false,"}, {"sha": "ee3457282d3311a7df19a88f63d54a99b3bbc792", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     ) -> String {\n         let fn_sig = self.tcx.hir().get_if_local(self.def_id).and_then(hir::Node::fn_sig);\n         let is_used_in_input = |def_id| {\n-            fn_sig.map_or(false, |fn_sig| {\n+            fn_sig.is_some_and(|fn_sig| {\n                 fn_sig.decl.inputs.iter().any(|ty| match ty.kind {\n                     hir::TyKind::Path(hir::QPath::Resolved(\n                         None,"}, {"sha": "98c683f0200a3edfad24de17995e8406d24cc4ed", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         .sess\n                         .source_map()\n                         .span_to_snippet(self.expr_span)\n-                        .map_or(false, |snip| snip.starts_with('('));\n+                        .is_ok_and(|snip| snip.starts_with('('));\n \n                     // Very crude check to see whether the expression must be wrapped\n                     // in parentheses for the suggestion to work (issue #89497)."}, {"sha": "08c4082e885d9109f2a51b23a7e50aee405ebf5c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1814,7 +1814,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             .span_to_snippet(return_sp)\n             .unwrap_or_else(|_| \"dyn Trait\".to_string());\n         let mut snippet_iter = snippet.split_whitespace();\n-        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        let has_impl = snippet_iter.next().is_some_and(|s| s == \"impl\");\n         // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n         let mut is_object_safe = false;\n         if let hir::FnRetTy::Return(ty) = fn_output\n@@ -1834,7 +1834,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     bound\n                         .trait_ref()\n                         .and_then(|t| t.trait_def_id())\n-                        .map_or(false, |def_id| {\n+                        .is_some_and(|def_id| {\n                             fcx.tcx.check_is_object_safe(def_id)\n                         })\n                 })"}, {"sha": "b50630e636b2ea2b6588e2a532564bfd8dfc3be2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1748,8 +1748,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             |err: &mut Diagnostic,\n              found_to_exp_is_fallible: bool,\n              exp_to_found_is_fallible: bool| {\n-                let exp_is_lhs =\n-                    expected_ty_expr.map(|e| self.tcx.hir().is_lhs(e.hir_id)).unwrap_or(false);\n+                let exp_is_lhs = expected_ty_expr.is_some_and(|e| self.tcx.hir().is_lhs(e.hir_id));\n \n                 if exp_is_lhs {\n                     return;"}, {"sha": "19ff77d8349aaba921b6df447d9bb2ac4dce3c3c", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .borrow()\n                 .adjustments()\n                 .get(base.hir_id)\n-                .map_or(false, |x| x.iter().any(|adj| matches!(adj.kind, Adjust::Deref(_))))\n+                .is_some_and(|x| x.iter().any(|adj| matches!(adj.kind, Adjust::Deref(_))))\n         });\n         if !is_named {\n             self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span });"}, {"sha": "2fdcd09b9a2f46893b1b5c8c59965d2768d28daf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1017,23 +1017,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .typeck_results\n             .borrow()\n             .expr_ty_adjusted_opt(rcvr)\n-            .and_then(|ty| expected.map(|expected_ty| expected_ty.peel_refs() == ty.peel_refs()))\n-            .unwrap_or(false);\n+            .zip(expected)\n+            .is_some_and(|(ty, expected_ty)| expected_ty.peel_refs() == ty.peel_refs());\n \n         let prev_call_mutates_and_returns_unit = || {\n             self.typeck_results\n                 .borrow()\n                 .type_dependent_def_id(expr.hir_id)\n                 .map(|def_id| self.tcx.fn_sig(def_id).skip_binder().skip_binder())\n                 .and_then(|sig| sig.inputs_and_output.split_last())\n-                .map(|(output, inputs)| {\n+                .is_some_and(|(output, inputs)| {\n                     output.is_unit()\n                         && inputs\n                             .get(0)\n                             .and_then(|self_ty| self_ty.ref_mutability())\n-                            .map_or(false, rustc_ast::Mutability::is_mut)\n+                            .is_some_and(rustc_ast::Mutability::is_mut)\n                 })\n-                .unwrap_or(false)\n         };\n \n         if !(rcvr_has_the_expected_type || prev_call_mutates_and_returns_unit()) {\n@@ -1200,10 +1199,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let has_self = path_segs\n-            .last()\n-            .map(|PathSeg(def_id, _)| tcx.generics_of(*def_id).has_self)\n-            .unwrap_or(false);\n+        let has_self =\n+            path_segs.last().is_some_and(|PathSeg(def_id, _)| tcx.generics_of(*def_id).has_self);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n             let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id).subst_identity());"}, {"sha": "72c42f8e78952a710b9113b36c1d772291a5ea29", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -876,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut errors = errors.into_iter().peekable();\n         let mut only_extras_so_far = errors\n             .peek()\n-            .map_or(false, |first| matches!(first, Error::Extra(arg_idx) if arg_idx.index() == 0));\n+            .is_some_and(|first| matches!(first, Error::Extra(arg_idx) if arg_idx.index() == 0));\n         let mut suggestions = vec![];\n         while let Some(error) = errors.next() {\n             only_extras_so_far &= matches!(error, Error::Extra(_));"}, {"sha": "ecafbd668e22de207d8d3dbf78121bafb72949f1", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -193,7 +193,7 @@ impl DropRanges {\n             .get(&TrackedValue::Temporary(hir_id))\n             .or(self.tracked_value_map.get(&TrackedValue::Variable(hir_id)))\n             .cloned()\n-            .map_or(false, |tracked_value_id| {\n+            .is_some_and(|tracked_value_id| {\n                 self.expect_node(location.into()).drop_state.contains(tracked_value_id)\n             })\n     }"}, {"sha": "95fb32ee1cdf899e8c58c5490bb82360c8371390", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -130,7 +130,7 @@ impl<'tcx> Inherited<'tcx> {\n         // (*) binder skipped\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n             && let Some(ty) = self.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| self.root_var(t))\n-            && self.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+            && self.tcx.lang_items().sized_trait().is_some_and(|st| st != tpred.trait_ref.def_id)\n         {\n             let new_self_ty = self.tcx.types.unit;\n "}, {"sha": "78171e0b20e8cc2cf11f303830fc567954d661f1", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -411,7 +411,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             Res::Local(var_id) => {\n-                if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n+                if self.upvars.is_some_and(|upvars| upvars.contains_key(&var_id)) {\n                     self.cat_upvar(hir_id, var_id)\n                 } else {\n                     Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Local(var_id), Vec::new()))"}, {"sha": "ba21edea30b1cb5cffeb6b3af3706c11f9ef1814", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pick.autoderefs += 1;\n                     pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n                         mutbl,\n-                        unsize: pick.autoref_or_ptr_adjustment.map_or(false, |a| a.get_unsize()),\n+                        unsize: pick.autoref_or_ptr_adjustment.is_some_and(|a| a.get_unsize()),\n                     })\n                 }\n "}, {"sha": "8555c20204ad656676202c5994d9275ca8246a59", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let is_write = sugg_span.ctxt().outer_expn_data().macro_def_id.map_or(false, |def_id| {\n+        let is_write = sugg_span.ctxt().outer_expn_data().macro_def_id.is_some_and(|def_id| {\n             tcx.is_diagnostic_item(sym::write_macro, def_id)\n                 || tcx.is_diagnostic_item(sym::writeln_macro, def_id)\n         }) && item_name.name == Symbol::intern(\"write_fmt\");\n@@ -1522,7 +1522,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let span_included = match parent_expr.kind {\n                         hir::ExprKind::Struct(_, eps, _) => {\n-                            eps.len() > 0 && eps.last().map_or(false, |ep| ep.span.contains(span))\n+                            eps.len() > 0 && eps.last().is_some_and(|ep| ep.span.contains(span))\n                         }\n                         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n                         hir::ExprKind::Call(ref func, ..) => func.span.contains(span),\n@@ -1781,7 +1781,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ProbeScope::TraitsInScope,\n                                 return_type,\n                             )\n-                            .map_or(false, |pick| {\n+                            .is_ok_and(|pick| {\n                                 !never_mention_traits\n                                     .iter()\n                                     .flatten()\n@@ -2468,7 +2468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // implement the `AsRef` trait.\n                         let skip = skippable.contains(&did)\n                             || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name))\n-                            || inputs_len.map_or(false, |inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().skip_binder().inputs().len() != inputs_len);\n+                            || inputs_len.is_some_and(|inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().skip_binder().inputs().len() != inputs_len);\n                         // Make sure the method is defined for the *actual* receiver: we don't\n                         // want to treat `Box<Self>` as a receiver if it only works because of\n                         // an autoderef to `&self`\n@@ -2755,7 +2755,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n                             let imp_simp =\n                                 simplify_type(self.tcx, imp.self_ty(), TreatParams::ForLookup);\n-                            imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n+                            imp_simp.is_some_and(|s| s == simp_rcvr_ty)\n                         })\n                     {\n                         explicitly_negative.push(candidate);\n@@ -2893,7 +2893,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did().is_local(),\n                 ty::Foreign(did) => did.is_local(),\n-                ty::Dynamic(tr, ..) => tr.principal().map_or(false, |d| d.def_id().is_local()),\n+                ty::Dynamic(tr, ..) => tr.principal().is_some_and(|d| d.def_id().is_local()),\n                 ty::Param(_) => true,\n \n                 // Everything else (primitive types, etc.) is effectively"}, {"sha": "b8bf2b6912039bfd4ea217dab1b18289494d9ea4", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -549,9 +549,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let to_owned_msg = \"create an owned `String` from a string reference\";\n \n         let string_type = self.tcx.lang_items().string();\n-        let is_std_string = |ty: Ty<'tcx>| {\n-            ty.ty_adt_def().map_or(false, |ty_def| Some(ty_def.did()) == string_type)\n-        };\n+        let is_std_string =\n+            |ty: Ty<'tcx>| ty.ty_adt_def().is_some_and(|ty_def| Some(ty_def.did()) == string_type);\n \n         match (lhs_ty.kind(), rhs_ty.kind()) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n@@ -760,8 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             traits::BinOp {\n                 rhs_span: opt_rhs_expr.map(|expr| expr.span),\n-                is_lit: opt_rhs_expr\n-                    .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                is_lit: opt_rhs_expr.is_some_and(|expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n                 output_ty: expected.only_has_type(self),\n             },\n         );"}, {"sha": "e2b1dc007ba6d0e2b270986c8895a25fdb0a1a2b", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n                         // This helps avoid accidental drops.\n                         if inside_union\n-                            && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n+                            && source.ty_adt_def().is_some_and(|adt| adt.is_manually_drop())\n                         {\n                             let mut err = self.tcx.sess.struct_span_err(\n                                 expr.span,"}, {"sha": "9458099f56ff97600be27412c3c308b79547e717", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -972,15 +972,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut obligations_should_hold = Vec::new();\n         // Checks if a root variable implements any of the auto traits\n         for check_trait in auto_traits_def_id.iter() {\n-            obligations_should_hold.push(\n-                check_trait\n-                    .map(|check_trait| {\n-                        self.infcx\n-                            .type_implements_trait(check_trait, [ty], self.param_env)\n-                            .must_apply_modulo_regions()\n-                    })\n-                    .unwrap_or(false),\n-            );\n+            obligations_should_hold.push(check_trait.is_some_and(|check_trait| {\n+                self.infcx\n+                    .type_implements_trait(check_trait, [ty], self.param_env)\n+                    .must_apply_modulo_regions()\n+            }));\n         }\n \n         let mut problematic_captures = FxHashMap::default();\n@@ -996,15 +992,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Checks if a capture implements any of the auto traits\n             let mut obligations_holds_for_capture = Vec::new();\n             for check_trait in auto_traits_def_id.iter() {\n-                obligations_holds_for_capture.push(\n-                    check_trait\n-                        .map(|check_trait| {\n-                            self.infcx\n-                                .type_implements_trait(check_trait, [ty], self.param_env)\n-                                .must_apply_modulo_regions()\n-                        })\n-                        .unwrap_or(false),\n-                );\n+                obligations_holds_for_capture.push(check_trait.is_some_and(|check_trait| {\n+                    self.infcx\n+                        .type_implements_trait(check_trait, [ty], self.param_env)\n+                        .must_apply_modulo_regions()\n+                }));\n             }\n \n             let mut capture_problems = FxHashSet::default();"}, {"sha": "15bc3b4e388dc444ac0b14979cef323d40ea7520", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1544,7 +1544,7 @@ impl<T: Idx> GrowableBitSet<T> {\n     #[inline]\n     pub fn contains(&self, elem: T) -> bool {\n         let (word_index, mask) = word_index_and_mask(elem);\n-        self.bit_set.words.get(word_index).map_or(false, |word| (word & mask) != 0)\n+        self.bit_set.words.get(word_index).is_some_and(|word| (word & mask) != 0)\n     }\n \n     #[inline]\n@@ -1818,7 +1818,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.row(row).map_or(false, |r| r.contains(column))\n+        self.row(row).is_some_and(|r| r.contains(column))\n     }\n \n     /// Adds the bits from row `read` to the bits from row `write`, and"}, {"sha": "d3cf267dc9d79c8894257de1794166cad13ee3ee", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -248,7 +248,7 @@ impl<I: Idx> IntervalSet<I> {\n     fn check_invariants(&self) -> bool {\n         let mut current: Option<u32> = None;\n         for (start, end) in &self.map {\n-            if start > end || current.map_or(false, |x| x + 1 >= *start) {\n+            if start > end || current.is_some_and(|x| x + 1 >= *start) {\n                 return false;\n             }\n             current = Some(*end);\n@@ -321,6 +321,6 @@ impl<R: Idx, C: Step + Idx> SparseIntervalMatrix<R, C> {\n     }\n \n     pub fn contains(&self, row: R, point: C) -> bool {\n-        self.row(row).map_or(false, |r| r.contains(point))\n+        self.row(row).is_some_and(|r| r.contains(point))\n     }\n }"}, {"sha": "35c05e80badeb7abe6e8a5ce39f666fb18cf0331", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1825,7 +1825,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         s\n                     };\n                     if !(values.expected.is_simple_text() && values.found.is_simple_text())\n-                        || (exp_found.map_or(false, |ef| {\n+                        || (exp_found.is_some_and(|ef| {\n                             // This happens when the type error is a subset of the expectation,\n                             // like when you have two references but one is `usize` and the other\n                             // is `f32`. In those cases we still want to show the `note`. If the\n@@ -1877,7 +1877,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let exp_found = match terr {\n             // `terr` has more accurate type information than `exp_found` in match expressions.\n             ty::error::TypeError::Sorts(terr)\n-                if exp_found.map_or(false, |ef| terr.found == ef.found) =>\n+                if exp_found.is_some_and(|ef| terr.found == ef.found) =>\n             {\n                 Some(terr)\n             }\n@@ -1961,7 +1961,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n                         && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n                         && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n-                        && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n+                        && code.chars().next().is_some_and(|c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n                     {\n                         suggestions.push(TypeErrorAdditionalDiags::MeantByteLiteral { span, code: escape_literal(code) })\n                     }\n@@ -2329,7 +2329,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         .source_map()\n                         .span_to_prev_source(p.span.shrink_to_hi())\n                         .ok()\n-                        .map_or(false, |s| *s.as_bytes().last().unwrap() == b'&')\n+                        .is_some_and(|s| *s.as_bytes().last().unwrap() == b'&')\n                     {\n                         add_lt_suggs\n                             .push(Some("}, {"sha": "f3b2ec4c5e3833599e37160525e9fcf13060717f", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -671,7 +671,7 @@ impl<'tcx> InferSource<'tcx> {\n                 receiver.span.from_expansion()\n             }\n             InferSourceKind::ClosureReturn { data, should_wrap_expr, .. } => {\n-                data.span().from_expansion() || should_wrap_expr.map_or(false, Span::from_expansion)\n+                data.span().from_expansion() || should_wrap_expr.is_some_and(Span::from_expansion)\n             }\n         };\n         source_from_expansion || self.span.from_expansion()\n@@ -984,7 +984,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     ) -> impl Iterator<Item = InsertableGenericArgs<'tcx>> + 'a {\n         let tcx = self.infcx.tcx;\n         let have_turbofish = path.segments.iter().any(|segment| {\n-            segment.args.map_or(false, |args| args.args.iter().any(|arg| arg.is_ty_or_const()))\n+            segment.args.is_some_and(|args| args.args.iter().any(|arg| arg.is_ty_or_const()))\n         });\n         // The last segment of a path often has `Res::Err` and the\n         // correct `Res` is the one of the whole path."}, {"sha": "213b3f0fe0ed56c275bff712f45d6fa9f994f6eb", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n+            def_id.as_local().is_some_and(|def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,"}, {"sha": "358d412a4d8e20271e100138fa77f7e7b72743a3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -961,7 +961,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n                 Some(sugared_span.map_or(attr.span, |span| span.with_hi(attr.span.hi())));\n         }\n \n-        if attrs.peek().map_or(false, |next_attr| next_attr.is_doc_comment()) {\n+        if attrs.peek().is_some_and(|next_attr| next_attr.is_doc_comment()) {\n             continue;\n         }\n "}, {"sha": "6f773e04a97d78a368f295dff4a21b641a834ec9", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -383,9 +383,8 @@ impl LateLintPass<'_> for Diagnostics {\n         debug!(?span, ?def_id, ?substs);\n         let has_attr = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs)\n             .ok()\n-            .and_then(|inst| inst)\n-            .map(|inst| cx.tcx.has_attr(inst.def_id(), sym::rustc_lint_diagnostics))\n-            .unwrap_or(false);\n+            .flatten()\n+            .is_some_and(|inst| cx.tcx.has_attr(inst.def_id(), sym::rustc_lint_diagnostics));\n         if !has_attr {\n             return;\n         }"}, {"sha": "b218cc5789df1f9e72303e431130be9cb253d2c8", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -128,7 +128,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             // No clue where this argument is coming from.\n             return lint;\n         }\n-        if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n+        if arg_macro.is_some_and(|id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n             lint.note(fluent::lint_supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {"}, {"sha": "4bf4fda8292b629671ef26d47c583ff62fda212e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -677,7 +677,7 @@ pub fn transparent_newtype_field<'a, 'tcx>(\n     let param_env = tcx.param_env(variant.def_id);\n     variant.fields.iter().find(|field| {\n         let field_ty = tcx.type_of(field.did).subst_identity();\n-        let is_zst = tcx.layout_of(param_env.and(field_ty)).map_or(false, |layout| layout.is_zst());\n+        let is_zst = tcx.layout_of(param_env.and(field_ty)).is_ok_and(|layout| layout.is_zst());\n         !is_zst\n     })\n }"}, {"sha": "8f75fa11dd9a2e70cf73f7b174b591994f577f95", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -664,8 +664,8 @@ trait UnusedDelimLint {\n             _ => return,\n         };\n         let keep_space = (\n-            left_pos.map_or(false, |s| s >= value.span.lo()),\n-            right_pos.map_or(false, |s| s <= value.span.hi()),\n+            left_pos.is_some_and(|s| s >= value.span.lo()),\n+            right_pos.is_some_and(|s| s <= value.span.hi()),\n         );\n         self.emit_unused_delims(cx, value.span, spans, ctx.into(), keep_space);\n     }"}, {"sha": "491978d7e8fdfe9eca9e672c5b34ae179912b7e2", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n \n         let private_dep =\n-            self.sess.opts.externs.get(name.as_str()).map_or(false, |e| e.is_private_dep);\n+            self.sess.opts.externs.get(name.as_str()).is_some_and(|e| e.is_private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;"}, {"sha": "ceb348f34690e307eae30302d55406886169ad77", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -567,7 +567,7 @@ impl<'a> CrateLocator<'a> {\n         let mut err_data: Option<Vec<PathBuf>> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            if flavor == CrateFlavor::Rmeta && lib.metadata().map_or(false, |m| m.len() == 0) {\n+            if flavor == CrateFlavor::Rmeta && lib.metadata().is_ok_and(|m| m.len() == 0) {\n                 // Empty files will cause get_metadata_section to fail. Rmeta\n                 // files can be empty, for example with binaries (which can\n                 // often appear with `cargo check` when checking a library as\n@@ -602,7 +602,7 @@ impl<'a> CrateLocator<'a> {\n                     }\n                 };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n-            if slot.as_ref().map_or(false, |s| s.0 != hash) {\n+            if slot.as_ref().is_some_and(|s| s.0 != hash) {\n                 if let Some(candidates) = err_data {\n                     return Err(CrateError::MultipleCandidates(\n                         self.crate_name,"}, {"sha": "cc4e60cf6ac589d9e3e83e7a0fe0b7e61bd40a84", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .expect(\"argument names not encoded for a function\")\n             .decode((self, sess))\n             .nth(0)\n-            .map_or(false, |ident| ident.name == kw::SelfLower)\n+            .is_some_and(|ident| ident.name == kw::SelfLower)\n     }\n \n     fn get_associated_item_or_field_def_ids("}, {"sha": "d1ddc8fc1fd2e38ff483b28b05d6e6be06af7bbf", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -410,7 +410,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.parent_id(hir_id);\n-        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n+        assert!(self.find(parent).is_some_and(|n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n         parent\n     }\n "}, {"sha": "45a07fdd29327ba54417f025ef61bbded1dc8fd6", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n     pub fn is_foreign_item(self, def_id: impl Into<DefId>) -> bool {\n         self.opt_parent(def_id.into())\n-            .map_or(false, |parent| matches!(self.def_kind(parent), DefKind::ForeignMod))\n+            .is_some_and(|parent| matches!(self.def_kind(parent), DefKind::ForeignMod))\n     }\n }\n "}, {"sha": "f45cf788dd91cf24ee2962e0d6b8b6b2c2849060", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -94,8 +94,7 @@ pub struct EffectiveVisibilities<Id = LocalDefId> {\n \n impl EffectiveVisibilities {\n     pub fn is_public_at_level(&self, id: LocalDefId, level: Level) -> bool {\n-        self.effective_vis(id)\n-            .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n+        self.effective_vis(id).is_some_and(|effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n     /// See `Level::Reachable`."}, {"sha": "6354c0aabde7c9b1325bb36ea6253ff568272155", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -375,7 +375,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let parent_def_id = self.hir().get_parent_item(id);\n                 let skip = self\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n-                    .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n+                    .is_some_and(|parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 // #[deprecated] doesn't emit a notice if we're not on the\n                 // topmost deprecation. For example, if a struct is deprecated,"}, {"sha": "6c931a24462cf731a016e736f03082ec261f3682", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -2341,7 +2341,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n+        self.is_late_bound_map(id.owner).is_some_and(|set| set.contains(&id.local_id))\n     }\n \n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n@@ -2474,7 +2474,7 @@ pub fn provide(providers: &mut Providers) {\n         |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n     providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n-        tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n+        tcx.lang_items().panic_impl().is_some_and(|did| did.is_local())\n     };\n     providers.source_span = |tcx, def_id| tcx.untracked.source_span.get(def_id).unwrap_or(DUMMY_SP);\n }"}, {"sha": "b0ffe78299de91b451ab2a4a901eb22a9b118820", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> Generics {\n             .iter()\n             .rev()\n             .take_while(|param| {\n-                param.default_value(tcx).map_or(false, |default| {\n+                param.default_value(tcx).is_some_and(|default| {\n                     default.subst(tcx, substs) == substs[param.index as usize]\n                 })\n             })"}, {"sha": "e641d1ef1be6fdafaa0bda14c2c1afdefb040e9f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -659,7 +659,7 @@ fn polymorphize<'tcx>(\n     } else {\n         None\n     };\n-    let has_upvars = upvars_ty.map_or(false, |ty| !ty.tuple_fields().is_empty());\n+    let has_upvars = upvars_ty.is_some_and(|ty| !ty.tuple_fields().is_empty());\n     debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n \n     struct PolymorphizationFolder<'tcx> {"}, {"sha": "c51548501ef29898d7e9290c3d7368b3505dc863", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -2220,8 +2220,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         let impl_trait_ref2 = self.impl_trait_ref(def_id2);\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if impl_trait_ref1.map_or(false, |tr| tr.subst_identity().references_error())\n-            || impl_trait_ref2.map_or(false, |tr| tr.subst_identity().references_error())\n+        if impl_trait_ref1.is_some_and(|tr| tr.subst_identity().references_error())\n+            || impl_trait_ref2.is_some_and(|tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n@@ -2242,7 +2242,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let is_marker_overlap = {\n             let is_marker_impl = |trait_ref: Option<EarlyBinder<TraitRef<'_>>>| -> bool {\n-                trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n+                trait_ref.is_some_and(|tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n             is_marker_impl(impl_trait_ref1) && is_marker_impl(impl_trait_ref2)\n         };"}, {"sha": "ab4cd24881f6a6e63c4bd4e42c413f2162bdd5c4", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             let popped = this.block_context.pop();\n-            assert!(popped.map_or(false, |bf| bf.is_statement()));\n+            assert!(popped.is_some_and(|bf| bf.is_statement()));\n         }\n \n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             unpack!(block = this.expr_into_dest(destination, block, expr));\n             let popped = this.block_context.pop();\n \n-            assert!(popped.map_or(false, |bf| bf.is_tail_expr()));\n+            assert!(popped.is_some_and(|bf| bf.is_tail_expr()));\n         } else {\n             // If a block has no trailing expression, then it is given an implicit return type.\n             // This return type is usually `()`, unless the block is diverging, in which case the"}, {"sha": "7331f8ecaa96502f4dcab3258f8fe43f7ddcd323", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -325,10 +325,10 @@ impl DropTree {\n         entry_points.sort();\n \n         for (drop_idx, drop_data) in self.drops.iter_enumerated().rev() {\n-            if entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+            if entry_points.last().is_some_and(|entry_point| entry_point.0 == drop_idx) {\n                 let block = *blocks[drop_idx].get_or_insert_with(|| T::make_block(cfg));\n                 needs_block[drop_idx] = Block::Own;\n-                while entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+                while entry_points.last().is_some_and(|entry_point| entry_point.0 == drop_idx) {\n                     let entry_block = entry_points.pop().unwrap().1;\n                     T::add_entry(cfg, entry_block, block);\n                 }\n@@ -731,7 +731,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn leave_top_scope(&mut self, block: BasicBlock) -> BasicBlock {\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let needs_cleanup = self.scopes.scopes.last().map_or(false, |scope| scope.needs_cleanup());\n+        let needs_cleanup = self.scopes.scopes.last().is_some_and(|scope| scope.needs_cleanup());\n         let is_generator = self.generator_kind.is_some();\n         let unwind_to = if needs_cleanup { self.diverge_cleanup() } else { DropIdx::MAX };\n "}, {"sha": "b20495d602e59562af7d9b171a782282b6af37a1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> Cx<'tcx> {\n                         } else if let Some(box_item) = tcx.lang_items().owned_box() {\n                             if let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, fn_path)) = fun.kind\n                                 && let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = ty.kind\n-                                && path.res.opt_def_id().map_or(false, |did| did == box_item)\n+                                && path.res.opt_def_id().is_some_and(|did| did == box_item)\n                                 && fn_path.ident.name == sym::new\n                                 && let [value] = args\n                             {\n@@ -956,7 +956,7 @@ impl<'tcx> Cx<'tcx> {\n         let is_upvar = self\n             .tcx\n             .upvars_mentioned(self.body_owner)\n-            .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n+            .is_some_and(|upvars| upvars.contains_key(&var_hir_id));\n \n         debug!(\n             \"convert_var({:?}): is_upvar={}, body_owner={:?}\","}, {"sha": "0fe49b8a1bbf08b0ecc7250e0506c38dd3cc8170", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -363,7 +363,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n-            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n+            if r_bits.is_some_and(|b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", location);\n                 let source_info = self.body().source_info(location);\n                 let panic = AssertKind::Overflow("}, {"sha": "5ce96012b908662e49268a80c8da8c28a7c6951a", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -108,7 +108,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n \n         // If multiple different locals are copied to the return place. We can't pick a\n         // single one to rename.\n-        if copied_to_return_place.map_or(false, |old| old != returned_local) {\n+        if copied_to_return_place.is_some_and(|old| old != returned_local) {\n             return None;\n         }\n "}, {"sha": "1e6ac54964f99146c1256fced271d4c8961ade3d", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -72,7 +72,7 @@ fn has_cfg_or_cfg_attr(attrs: &[Attribute]) -> bool {\n     // Therefore, the absence of a literal `cfg` or `cfg_attr` guarantees that\n     // we don't need to do any eager expansion.\n     attrs.iter().any(|attr| {\n-        attr.ident().map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr)\n+        attr.ident().is_some_and(|ident| ident.name == sym::cfg || ident.name == sym::cfg_attr)\n     })\n }\n "}, {"sha": "c14540396857477dd3c73efea847dad01ef97572", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -845,7 +845,7 @@ impl<'a> Parser<'a> {\n         //\n         // `x.foo::<u32>>>(3)`\n         let parsed_angle_bracket_args =\n-            segment.args.as_ref().map_or(false, |args| args.is_angle_bracketed());\n+            segment.args.as_ref().is_some_and(|args| args.is_angle_bracketed());\n \n         debug!(\n             \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n@@ -2610,7 +2610,7 @@ impl<'a> Parser<'a> {\n         let TyKind::Path(qself, path) = &ty.kind else { return Ok(()) };\n         let qself_position = qself.as_ref().map(|qself| qself.position);\n         for (i, segments) in path.segments.windows(2).enumerate() {\n-            if qself_position.map(|pos| i < pos).unwrap_or(false) {\n+            if qself_position.is_some_and(|pos| i < pos) {\n                 continue;\n             }\n             if let [a, b] = segments {"}, {"sha": "1b28f3c97e8f674d2e6d94bc3f19fd2503ffb848", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1188,7 +1188,7 @@ impl<'a> Parser<'a> {\n                             // `token.kind` should not be compared here.\n                             // This is because the `snapshot.token.kind` is treated as the same as\n                             // that of the open delim in `TokenTreesReader::parse_token_tree`, even if they are different.\n-                            self.span_to_snippet(close_paren).map_or(false, |snippet| snippet == \")\")\n+                            self.span_to_snippet(close_paren).is_ok_and(|snippet| snippet == \")\")\n                         {\n                             let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n@@ -2078,7 +2078,7 @@ impl<'a> Parser<'a> {\n                     // Therefore, `token.kind` should not be compared here.\n                     if snapshot\n                         .span_to_snippet(snapshot.token.span)\n-                        .map_or(false, |snippet| snippet == \"]\") =>\n+                        .is_ok_and(|snippet| snippet == \"]\") =>\n                 {\n                     return Err(errors::MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n@@ -2773,7 +2773,7 @@ impl<'a> Parser<'a> {\n                 // We might have a `=>` -> `=` or `->` typo (issue #89396).\n                 if TokenKind::FatArrow\n                     .similar_tokens()\n-                    .map_or(false, |similar_tokens| similar_tokens.contains(&this.token.kind))\n+                    .is_some_and(|similar_tokens| similar_tokens.contains(&this.token.kind))\n                 {\n                     err.span_suggestion(\n                         this.token.span,\n@@ -3059,7 +3059,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            let is_shorthand = parsed_field.as_ref().map_or(false, |f| f.is_shorthand);\n+            let is_shorthand = parsed_field.as_ref().is_some_and(|f| f.is_shorthand);\n             // A shorthand field can be turned into a full field with `:`.\n             // We should point this out.\n             self.check_or_expected(!is_shorthand, TokenType::Token(token::Colon));"}, {"sha": "3783ec41b7e23a7bb93b6c40afce6f3436ddf453", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -699,7 +699,7 @@ impl<'a> Parser<'a> {\n                         // ```\n                         && self\n                             .span_to_snippet(self.prev_token.span)\n-                            .map_or(false, |snippet| snippet == \"}\")\n+                            .is_ok_and(|snippet| snippet == \"}\")\n                         && self.token.kind == token::Semi;\n                     let mut semicolon_span = self.token.span;\n                     if !is_unnecessary_semicolon {"}, {"sha": "c3189d1fefe40f4255b0158097cb111db85b6d36", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1816,7 +1816,7 @@ impl CheckAttrVisitor<'_> {\n             || (is_simd && is_c)\n             || (int_reprs == 1\n                 && is_c\n-                && item.map_or(false, |item| {\n+                && item.is_some_and(|item| {\n                     if let ItemLike::Item(item) = item {\n                         return is_c_like_enum(item);\n                     }\n@@ -2095,7 +2095,7 @@ impl CheckAttrVisitor<'_> {\n                 | sym::feature\n                 | sym::repr\n                 | sym::target_feature\n-        ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n+        ) && attr.meta_item_list().is_some_and(|list| list.is_empty())\n         {\n             errors::UnusedNote::EmptyList { name: attr.name_or_empty() }\n         } else if matches!("}, {"sha": "b81b7ad6013b5df0e354deed34001339304b9e92", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -554,10 +554,8 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         let is_const = self.tcx.is_const_fn(def_id.to_def_id())\n             || self.tcx.is_const_trait_impl_raw(def_id.to_def_id());\n-        let is_stable = self\n-            .tcx\n-            .lookup_stability(def_id)\n-            .map_or(false, |stability| stability.level.is_stable());\n+        let is_stable =\n+            self.tcx.lookup_stability(def_id).is_some_and(|stability| stability.level.is_stable());\n         let missing_const_stability_attribute = self.tcx.lookup_const_stability(def_id).is_none();\n         let is_reachable = self.effective_visibilities.is_reachable(def_id);\n \n@@ -772,7 +770,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     // needs to have an error emitted.\n                     if features.const_trait_impl\n                         && *constness == hir::Constness::Const\n-                        && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n+                        && const_stab.is_some_and(|(stab, _)| stab.is_const_stable())\n                     {\n                         self.tcx.sess.emit_err(errors::TraitImplConstStable { span: item.span });\n                     }\n@@ -809,15 +807,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n             );\n \n             let is_allowed_through_unstable_modules = |def_id| {\n-                self.tcx\n-                    .lookup_stability(def_id)\n-                    .map(|stab| match stab.level {\n-                        StabilityLevel::Stable { allowed_through_unstable_modules, .. } => {\n-                            allowed_through_unstable_modules\n-                        }\n-                        _ => false,\n-                    })\n-                    .unwrap_or(false)\n+                self.tcx.lookup_stability(def_id).is_some_and(|stab| match stab.level {\n+                    StabilityLevel::Stable { allowed_through_unstable_modules, .. } => {\n+                        allowed_through_unstable_modules\n+                    }\n+                    _ => false,\n+                })\n             };\n \n             if item_is_allowed && !is_allowed_through_unstable_modules(def_id) {"}, {"sha": "c0d7386dd6adb88cc224b03177ab984a879406c7", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -656,7 +656,7 @@ impl<K: DepKind> DepGraphData<K> {\n     /// current compilation session. Used in various assertions\n     #[inline]\n     pub fn is_index_green(&self, prev_index: SerializedDepNodeIndex) -> bool {\n-        self.colors.get(prev_index).map_or(false, |c| c.is_green())\n+        self.colors.get(prev_index).is_some_and(|c| c.is_green())\n     }\n \n     #[inline]\n@@ -677,7 +677,7 @@ impl<K: DepKind> DepGraphData<K> {\n impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.as_ref().map_or(false, |data| data.dep_node_exists(dep_node))\n+        self.data.as_ref().is_some_and(|data| data.dep_node_exists(dep_node))\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if\n@@ -955,7 +955,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// Returns true if the given node has been marked as green during the\n     /// current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n-        self.node_color(dep_node).map_or(false, |c| c.is_green())\n+        self.node_color(dep_node).is_some_and(|c| c.is_green())\n     }\n \n     /// This method loads all on-disk cacheable query results into memory, so"}, {"sha": "e673d5b8c6ee984da06b25db9117f32dfae7a693", "filename": "compiler/rustc_query_system/src/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -24,7 +24,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n             .iter()\n             .filter(|attr| {\n                 !attr.is_doc_comment()\n-                    && !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n+                    && !attr.ident().is_some_and(|ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n \n@@ -38,7 +38,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n     fn hash_attr(&mut self, attr: &ast::Attribute, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(!attr.ident().map_or(false, |ident| self.is_ignored_attr(ident.name)));\n+        debug_assert!(!attr.ident().is_some_and(|ident| self.is_ignored_attr(ident.name)));\n         debug_assert!(!attr.is_doc_comment());\n \n         let ast::Attribute { kind, id: _, style, span } = attr;"}, {"sha": "72777733345134f96f7d92ba9956523dc521cc2d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     expn_id,\n                     self.def_span(def_id),\n                     // FIXME: Account for `#[no_implicit_prelude]` attributes.\n-                    parent.map_or(false, |module| module.no_implicit_prelude),\n+                    parent.is_some_and(|module| module.no_implicit_prelude),\n                 ));\n             }\n         }"}, {"sha": "dc35c8b176f5cbb6de8c397378b5be6bdf4d9f8b", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -117,16 +117,11 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n         match item.kind {\n             ast::UseTreeKind::Simple(Some(ident)) => {\n                 if ident.name == kw::Underscore\n-                    && !self\n-                        .r\n-                        .import_res_map\n-                        .get(&id)\n-                        .map(|per_ns| {\n-                            per_ns.iter().filter_map(|res| res.as_ref()).any(|res| {\n-                                matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n-                            })\n+                    && !self.r.import_res_map.get(&id).is_some_and(|per_ns| {\n+                        per_ns.iter().filter_map(|res| res.as_ref()).any(|res| {\n+                            matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n                         })\n-                        .unwrap_or(false)\n+                    })\n                 {\n                     self.unused_import(self.base_id).add(id);\n                 }\n@@ -469,7 +464,7 @@ impl Resolver<'_, '_> {\n                 .r\n                 .extern_prelude\n                 .get(&extern_crate.ident)\n-                .map_or(false, |entry| !entry.introduced_by_item)\n+                .is_some_and(|entry| !entry.introduced_by_item)\n             {\n                 continue;\n             }"}, {"sha": "8c6ac822a77a738dc7605d312c3cb8a88a7112f9", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1843,7 +1843,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None,\n                 )\n             }\n-        } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+        } else if ident.name.as_str().chars().next().is_some_and(|c| c.is_ascii_uppercase()) {\n             // Check whether the name refers to an item in the value namespace.\n             let binding = if let Some(ribs) = ribs {\n                 self.resolve_ident_in_lexical_scope(\n@@ -2165,7 +2165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let is_definitely_crate = import\n                     .module_path\n                     .first()\n-                    .map_or(false, |f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n+                    .is_some_and(|f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n \n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);"}, {"sha": "df65825802e126fd95736f41ac47e9aeac2c411e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -197,8 +197,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             .sess\n                             .source_map()\n                             .span_to_snippet(span)\n-                            .map(|snippet| snippet.ends_with(')'))\n-                            .unwrap_or(false)\n+                            .is_ok_and(|snippet| snippet.ends_with(')'))\n                     }\n                     Res::Def(\n                         DefKind::Ctor(..) | DefKind::AssocFn | DefKind::Const | DefKind::AssocConst,\n@@ -722,7 +721,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         if let TypoCandidate::Shadowed(res, Some(sugg_span)) = typo_sugg\n             && res\n                 .opt_def_id()\n-                .map_or(false, |id| id.is_local() || is_in_same_file(span, sugg_span))\n+                .is_some_and(|id| id.is_local() || is_in_same_file(span, sugg_span))\n         {\n             err.span_label(\n                 sugg_span,\n@@ -856,7 +855,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             // The current function has a `self` parameter, but we were unable to resolve\n             // a reference to `self`. This can only happen if the `self` identifier we\n             // are resolving came from a different hygiene context.\n-            if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+            if fn_kind.decl().inputs.get(0).is_some_and(|p| p.is_self()) {\n                 err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n             } else {\n                 let doesnt = if is_assoc_fn {\n@@ -1632,7 +1631,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             .tcx\n                             .fn_arg_names(def_id)\n                             .first()\n-                            .map_or(false, |ident| ident.name == kw::SelfLower),\n+                            .is_some_and(|ident| ident.name == kw::SelfLower),\n                     };\n                     if has_self {\n                         return Some(AssocSuggestion::MethodWithSelf { called });\n@@ -1931,10 +1930,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n                 match kind {\n                     CtorKind::Const => false,\n-                    CtorKind::Fn => !self\n-                        .r\n-                        .field_def_ids(def_id)\n-                        .map_or(false, |field_ids| field_ids.is_empty()),\n+                    CtorKind::Fn => {\n+                        !self.r.field_def_ids(def_id).is_some_and(|field_ids| field_ids.is_empty())\n+                    }\n                 }\n             };\n "}, {"sha": "3d2bd8429068e50c3cc147c16abe016fdeef2d81", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1477,7 +1477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn is_builtin_macro(&mut self, res: Res) -> bool {\n-        self.get_macro(res).map_or(false, |macro_data| macro_data.ext.builtin_name.is_some())\n+        self.get_macro(res).is_some_and(|macro_data| macro_data.ext.builtin_name.is_some())\n     }\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {"}, {"sha": "df5c16a9375fbf07773ff2320b9834c09a42dc6f", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -823,8 +823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let is_allowed = |feature| {\n                     self.active_features.contains(&feature) || span.allows_unstable(feature)\n                 };\n-                let allowed_by_implication =\n-                    implied_by.map(|feature| is_allowed(feature)).unwrap_or(false);\n+                let allowed_by_implication = implied_by.is_some_and(|feature| is_allowed(feature));\n                 if !is_allowed(feature) && !allowed_by_implication {\n                     let lint_buffer = &mut self.lint_buffer;\n                     let soft_handler ="}, {"sha": "6c8c8e484f93954bd2d3f29ace28df1a4e04e900", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1907,7 +1907,7 @@ fn collect_print_requests(\n     error_format: ErrorOutputType,\n ) -> Vec<PrintRequest> {\n     let mut prints = Vec::<PrintRequest>::new();\n-    if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n+    if cg.target_cpu.as_ref().is_some_and(|s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);\n         cg.target_cpu = None;\n     };"}, {"sha": "bbe52dbced071d93a477f2d2948864a8a00aeb91", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1378,8 +1378,8 @@ pub fn build_session(\n         .lint_opts\n         .iter()\n         .rfind(|&(key, _)| *key == \"warnings\")\n-        .map_or(false, |&(_, level)| level == lint::Allow);\n-    let cap_lints_allow = sopts.lint_cap.map_or(false, |cap| cap == lint::Allow);\n+        .is_some_and(|&(_, level)| level == lint::Allow);\n+    let cap_lints_allow = sopts.lint_cap.is_some_and(|cap| cap == lint::Allow);\n     let can_emit_warnings = !(warnings_allow || cap_lints_allow);\n \n     let sysroot = match &sopts.maybe_sysroot {"}, {"sha": "3d3833dfdab14cf3ab7e130fc90cd668243f6969", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -754,7 +754,7 @@ impl Span {\n         self.ctxt()\n             .outer_expn_data()\n             .allow_internal_unstable\n-            .map_or(false, |features| features.iter().any(|&f| f == feature))\n+            .is_some_and(|features| features.iter().any(|&f| f == feature))\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`."}, {"sha": "1824510a9742e032660b3db7a920d2ca950096b2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -639,7 +639,7 @@ impl SourceMap {\n         self.span_to_source(sp, |src, start_index, end_index| {\n             Ok(src.get(start_index..end_index).is_some())\n         })\n-        .map_or(false, |is_accessible| is_accessible)\n+        .is_ok_and(|is_accessible| is_accessible)\n     }\n \n     /// Returns the source snippet as `String` corresponding to the given `Span`.\n@@ -835,7 +835,7 @@ impl SourceMap {\n             }\n             return Ok(true);\n         })\n-        .map_or(false, |is_accessible| is_accessible)\n+        .is_ok_and(|is_accessible| is_accessible)\n     }\n \n     /// Given a `Span`, tries to get a shorter span ending just after the first occurrence of `char`\n@@ -967,7 +967,7 @@ impl SourceMap {\n         for _ in 0..limit.unwrap_or(100_usize) {\n             sp = self.next_point(sp);\n             if let Ok(ref snippet) = self.span_to_snippet(sp) {\n-                if expect.map_or(false, |es| snippet == es) {\n+                if expect.is_some_and(|es| snippet == es) {\n                     break;\n                 }\n                 if expect.is_none() && snippet.chars().any(|c| !c.is_whitespace()) {"}, {"sha": "9fa49123a868ec9b7725c88be22d635d922aedda", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -818,7 +818,7 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                 let field = variant.fields.iter().find(|field| {\n                     let ty = tcx.type_of(field.did).subst_identity();\n                     let is_zst =\n-                        tcx.layout_of(param_env.and(ty)).map_or(false, |layout| layout.is_zst());\n+                        tcx.layout_of(param_env.and(ty)).is_ok_and(|layout| layout.is_zst());\n                     !is_zst\n                 });\n                 if let Some(field) = field {"}, {"sha": "f722f281314e6224162e0af939bddda27e44abcf", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -358,7 +358,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Can only unsize to an object-safe type\n                     if data\n                         .principal_def_id()\n-                        .map_or(false, |def_id| !tcx.check_is_object_safe(def_id))\n+                        .is_some_and(|def_id| !tcx.check_is_object_safe(def_id))\n                     {\n                         return Err(NoSolution);\n                     }"}, {"sha": "aacbfbd3c877ad24dca065a6adebd5140bb88370", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -706,7 +706,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             }\n             ty::Dynamic(tt, ..) => {\n                 let principal = tt.principal().map(|p| p.def_id());\n-                if principal.map_or(false, |p| self.def_id_is_local(p)) {\n+                if principal.is_some_and(|p| self.def_id_is_local(p)) {\n                     ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n                 } else {\n                     self.found_non_local_ty(ty)"}, {"sha": "a10ececbb1ea7e972f3577ea411565bc2ad26800", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -437,7 +437,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // 1) strictly implied by another error.\n                     // 2) implied by an error with a smaller index.\n                     for error2 in error_set {\n-                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                        if error2.index.is_some_and(|index2| is_suppressed[index2]) {\n                             // Avoid errors being suppressed by already-suppressed\n                             // errors, to prevent all errors from being suppressed\n                             // at once."}, {"sha": "82bad96ea42db40654fcbd5a44b84e469873a003", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -420,7 +420,7 @@ fn suggest_restriction<'tcx>(\n ) {\n     if hir_generics.where_clause_span.from_expansion()\n         || hir_generics.where_clause_span.desugaring_kind().is_some()\n-        || projection.map_or(false, |projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n+        || projection.is_some_and(|projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n     {\n         return;\n     }\n@@ -2936,7 +2936,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                     \"note_obligation_cause_code: check for async fn\"\n                                 );\n                                 if is_future\n-                                    && obligated_types.last().map_or(false, |ty| match ty.kind() {\n+                                    && obligated_types.last().is_some_and(|ty| match ty.kind() {\n                                         ty::Generator(last_def_id, ..) => {\n                                             tcx.generator_is_async(*last_def_id)\n                                         }"}, {"sha": "3d6c1d9e2b02e8503b5d44ab8c291d3e79235a61", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1,32 +1,31 @@\n use crate::infer::canonical::query_response;\n-use crate::infer::{InferCtxt, InferOk};\n+use crate::infer::InferCtxt;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCtxt;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_span::source_map::DUMMY_SP;\n \n use std::fmt;\n \n-pub struct CustomTypeOp<F, G> {\n+pub struct CustomTypeOp<F> {\n     closure: F,\n-    description: G,\n+    description: &'static str,\n }\n \n-impl<F, G> CustomTypeOp<F, G> {\n-    pub fn new<'tcx, R>(closure: F, description: G) -> Self\n+impl<F> CustomTypeOp<F> {\n+    pub fn new<'tcx, R>(closure: F, description: &'static str) -> Self\n     where\n-        F: FnOnce(&InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n-        G: Fn() -> String,\n+        F: FnOnce(&ObligationCtxt<'_, 'tcx>) -> Fallible<R>,\n     {\n         CustomTypeOp { closure, description }\n     }\n }\n \n-impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R: fmt::Debug> super::TypeOp<'tcx> for CustomTypeOp<F>\n where\n-    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n-    G: Fn() -> String,\n+    F: FnOnce(&ObligationCtxt<'_, 'tcx>) -> Fallible<R>,\n {\n     type Output = R;\n     /// We can't do any custom error reporting for `CustomTypeOp`, so\n@@ -41,24 +40,21 @@ where\n             info!(\"fully_perform({:?})\", self);\n         }\n \n-        Ok(scrape_region_constraints(infcx, || (self.closure)(infcx))?.0)\n+        Ok(scrape_region_constraints(infcx, self.closure)?.0)\n     }\n }\n \n-impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n-where\n-    G: Fn() -> String,\n-{\n+impl<F> fmt::Debug for CustomTypeOp<F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", (self.description)())\n+        self.description.fmt(f)\n     }\n }\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'tcx>,\n-    op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n+    op: impl FnOnce(&ObligationCtxt<'_, 'tcx>) -> Fallible<R>,\n ) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n@@ -72,16 +68,20 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         pre_obligations,\n     );\n \n-    let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    let ocx = ObligationCtxt::new(infcx);\n-    ocx.register_obligations(obligations);\n-    let errors = ocx.select_all_or_error();\n-    if !errors.is_empty() {\n-        infcx.tcx.sess.diagnostic().delay_span_bug(\n-            DUMMY_SP,\n-            format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n-        );\n-    }\n+    let value = infcx.commit_if_ok(|_| {\n+        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+        let value = op(&ocx)?;\n+        let errors = ocx.select_all_or_error();\n+        if errors.is_empty() {\n+            Ok(value)\n+        } else {\n+            infcx.tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n+            );\n+            Err(NoSolution)\n+        }\n+    })?;\n \n     let region_obligations = infcx.take_registered_region_obligations();\n     let region_constraint_data = infcx.take_and_reset_region_constraints();"}, {"sha": "3baf1c97c9f46539d81d803da9dc94cca2bedc22", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1793,12 +1793,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(DefineOpaqueTypes::No, obligation.predicate, infer_projection)\n-            .map_or(false, |InferOk { obligations, value: () }| {\n+            .is_ok_and(|InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n                     nested_obligations.into_iter().chain(obligations),\n                 )\n-                .map_or(false, |res| res.may_apply())\n+                .is_ok_and(|res| res.may_apply())\n             });\n \n         if is_match {"}, {"sha": "824abc72a223df7812fb59eb0944c6ded4cce8f9", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -16,7 +16,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2.143\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.91\" }\n+compiler_builtins = { version = \"0.1.92\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.13\", default-features = false, features = ['rustc-dep-of-std'] }"}, {"sha": "6ac3b3eaa797b16e2377e6ee53eb41276504676a", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -404,13 +404,13 @@ fn get_format(\n         Some(\"terse\") => OutputFormat::Terse,\n         Some(\"json\") => {\n             if !allow_unstable {\n-                return Err(\"The \\\"json\\\" format is only accepted on the nightly compiler\".into());\n+                return Err(\"The \\\"json\\\" format is only accepted on the nightly compiler with -Z unstable-options\".into());\n             }\n             OutputFormat::Json\n         }\n         Some(\"junit\") => {\n             if !allow_unstable {\n-                return Err(\"The \\\"junit\\\" format is only accepted on the nightly compiler\".into());\n+                return Err(\"The \\\"junit\\\" format is only accepted on the nightly compiler with -Z unstable-options\".into());\n             }\n             OutputFormat::Junit\n         }"}, {"sha": "b59a65a713f953c8d1b60788500c43079a565c92", "filename": "tests/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -18,7 +18,7 @@ extern crate rustc_interface;\n extern crate rustc_middle;\n extern crate rustc_session;\n \n-use rustc_borrowck::consumers::BodyWithBorrowckFacts;\n+use rustc_borrowck::consumers::{self, BodyWithBorrowckFacts, ConsumerOptions};\n use rustc_driver::Compilation;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -102,7 +102,7 @@ impl rustc_driver::Callbacks for CompilerCalls {\n             println!(\"Bodies retrieved for:\");\n             for (def_id, body) in bodies {\n                 println!(\"{}\", def_id);\n-                assert!(body.input_facts.cfg_edge.len() > 0);\n+                assert!(body.input_facts.unwrap().cfg_edge.len() > 0);\n             }\n         });\n \n@@ -127,7 +127,8 @@ thread_local! {\n }\n \n fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> ProvidedValue<'tcx> {\n-    let body_with_facts = rustc_borrowck::consumers::get_body_with_borrowck_facts(tcx, def_id);\n+    let opts = ConsumerOptions::PoloniusInputFacts;\n+    let body_with_facts = consumers::get_body_with_borrowck_facts(tcx, def_id, opts);\n     // SAFETY: The reader casts the 'static lifetime to 'tcx before using it.\n     let body_with_facts: BodyWithBorrowckFacts<'static> =\n         unsafe { std::mem::transmute(body_with_facts) };"}, {"sha": "5d8b37554417e210ef9e2b6ea4f559addf0d5b7e", "filename": "tests/ui/test-attrs/tests-listing-format-json-without-unstableopts.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7664dfe4331265d0b2b1ffb89c92d443886bec0b/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7664dfe4331265d0b2b1ffb89c92d443886bec0b/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr?ref=7664dfe4331265d0b2b1ffb89c92d443886bec0b", "patch": "@@ -1 +1 @@\n-error: The \"json\" format is only accepted on the nightly compiler\n+error: The \"json\" format is only accepted on the nightly compiler with -Z unstable-options"}]}