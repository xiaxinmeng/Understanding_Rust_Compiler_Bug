{"sha": "30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjM5ZmVlOWRkYWFjYmUwZGMwYTYyYjVhN2ZlZjYzMzhhOTBhMDA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-19T01:49:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-19T01:49:08Z"}, "message": "Rollup merge of #82238 - petrochenkov:nocratemod, r=Aaron1011\n\nast: Keep expansion status for out-of-line module items\n\nI.e. whether a module `mod foo;` is already loaded from a file or not.\nThis is a pre-requisite to correctly treating inner attributes on such modules (https://github.com/rust-lang/rust/issues/81661).\n\nWith this change AST structures for `mod` items diverge even more for AST structure for the crate root, which previously used `ast::Mod`.\nTherefore this PR removes `ast::Mod` from `ast::Crate` in the first commit, these two things are sufficiently different from each other, at least at syntactic level.\nCustomization points for visiting a \"`mod` item or crate root\" were also removed from AST visitors (`fn visit_mod`).\n`ast::Mod` itself was refactored away in the second commit in favor of `ItemKind::Mod(Unsafe, ModKind)`.", "tree": {"sha": "42475839b09338a40ebf58f52595dd862b0d1608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42475839b09338a40ebf58f52595dd862b0d1608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgLxkVCRBK7hj4Ov3rIwAAdHIIAFwm1EmgHNtWUeoj7E4Xgozs\nHDHFAtjYqW73qrzKgGYeDhkqrqxNPDKOVxndtjpyKllcbUtxek0y6LM6jwCvn8V9\nZnNufagq8CudZVRldVw+FEUO9BV9CkjQWQllg5slzfaG/OvTPLrOjRXWtpWpsHg1\nZhRkiHeHS8E49oAy2Dpu+pwKQsiNuARHB7xgfD7wvzTXtV00oPPbForCUASdWDiX\nWsDhZvZ3DvAfd2nOI84hNdE/LCOKeAhi+MBICPHlrIRWZT/nvyZwOfAoRPpB6HIV\nMsNxsouP/bKzOye44h925iCu1lVKnOycMoeOc+hFgIBl/ZFx6OCVTDdkQJFDae4=\n=KJG8\n-----END PGP SIGNATURE-----\n", "payload": "tree 42475839b09338a40ebf58f52595dd862b0d1608\nparent f8b61d852c2de4632278322d6d00a7f066277e14\nparent 4a8816512477513f57986685738cd065e72c4908\nauthor Dylan DPC <dylan.dpc@gmail.com> 1613699348 +0100\ncommitter GitHub <noreply@github.com> 1613699348 +0100\n\nRollup merge of #82238 - petrochenkov:nocratemod, r=Aaron1011\n\nast: Keep expansion status for out-of-line module items\n\nI.e. whether a module `mod foo;` is already loaded from a file or not.\nThis is a pre-requisite to correctly treating inner attributes on such modules (https://github.com/rust-lang/rust/issues/81661).\n\nWith this change AST structures for `mod` items diverge even more for AST structure for the crate root, which previously used `ast::Mod`.\nTherefore this PR removes `ast::Mod` from `ast::Crate` in the first commit, these two things are sufficiently different from each other, at least at syntactic level.\nCustomization points for visiting a \"`mod` item or crate root\" were also removed from AST visitors (`fn visit_mod`).\n`ast::Mod` itself was refactored away in the second commit in favor of `ItemKind::Mod(Unsafe, ModKind)`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "html_url": "https://github.com/rust-lang/rust/commit/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8b61d852c2de4632278322d6d00a7f066277e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b61d852c2de4632278322d6d00a7f066277e14", "html_url": "https://github.com/rust-lang/rust/commit/f8b61d852c2de4632278322d6d00a7f066277e14"}, {"sha": "4a8816512477513f57986685738cd065e72c4908", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8816512477513f57986685738cd065e72c4908", "html_url": "https://github.com/rust-lang/rust/commit/4a8816512477513f57986685738cd065e72c4908"}], "stats": {"total": 497, "additions": 227, "deletions": 270}, "files": [{"sha": "3550055ac10d3ce384cdc312df57e50a8394e231", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -486,8 +486,8 @@ pub struct WhereEqPredicate {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub module: Mod,\n     pub attrs: Vec<Attribute>,\n+    pub items: Vec<P<Item>>,\n     pub span: Span,\n     /// The order of items in the HIR is unrelated to the order of\n     /// items in the AST. However, we generate proc macro harnesses\n@@ -2299,21 +2299,22 @@ impl FnRetTy {\n     }\n }\n \n-/// Module declaration.\n-///\n-/// E.g., `mod foo;` or `mod foo { .. }`.\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n+pub enum Inline {\n+    Yes,\n+    No,\n+}\n+\n+/// Module item kind.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct Mod {\n-    /// A span from the first token past `{` to the last token until `}`.\n-    /// For `mod foo;`, the inner span ranges from the first token\n-    /// to the last token in the external file.\n-    pub inner: Span,\n-    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n-    /// semantically by Rust.\n-    pub unsafety: Unsafe,\n-    pub items: Vec<P<Item>>,\n-    /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n-    pub inline: bool,\n+pub enum ModKind {\n+    /// Module with inlined definition `mod foo { ... }`,\n+    /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n+    /// The inner span is from the first token past `{` to the last token until `}`,\n+    /// or from the first to the last token in the loaded file.\n+    Loaded(Vec<P<Item>>, Inline, Span),\n+    /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n+    Unloaded,\n }\n \n /// Foreign module declaration.\n@@ -2710,7 +2711,9 @@ pub enum ItemKind {\n     /// A module declaration (`mod`).\n     ///\n     /// E.g., `mod foo;` or `mod foo { .. }`.\n-    Mod(Mod),\n+    /// `unsafe` keyword on modules is accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    Mod(Unsafe, ModKind),\n     /// An external module (`extern`).\n     ///\n     /// E.g., `extern {}` or `extern \"C\" {}`."}, {"sha": "c286738811ca13c27648c1da000c6ed5f72bb64b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -170,10 +170,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_ty_constraint(t, self);\n     }\n \n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        noop_visit_mod(m, self);\n-    }\n-\n     fn visit_foreign_mod(&mut self, nm: &mut ForeignMod) {\n         noop_visit_foreign_mod(nm, self);\n     }\n@@ -917,7 +913,13 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n             visit_opt(body, |body| vis.visit_block(body));\n         }\n-        ItemKind::Mod(m) => vis.visit_mod(m),\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, inner_span) => {\n+                vis.visit_span(inner_span);\n+                items.flat_map_in_place(|item| vis.flat_map_item(item));\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n         ItemKind::GlobalAsm(_ga) => {}\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n@@ -998,14 +1000,10 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     vis.visit_asyncness(asyncness);\n }\n \n-pub fn noop_visit_mod<T: MutVisitor>(module: &mut Mod, vis: &mut T) {\n-    let Mod { inner, unsafety: _, items, inline: _ } = module;\n-    vis.visit_span(inner);\n-    items.flat_map_in_place(|item| vis.flat_map_item(item));\n-}\n-\n+// FIXME: Avoid visiting the crate as a `Mod` item, flat map only the inner items if possible,\n+// or make crate visiting first class if necessary.\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n-    visit_clobber(krate, |Crate { module, attrs, span, proc_macros }| {\n+    visit_clobber(krate, |Crate { attrs, items, span, proc_macros }| {\n         let item_vis =\n             Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n         let item = P(Item {\n@@ -1014,19 +1012,20 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: item_vis,\n             span,\n-            kind: ItemKind::Mod(module),\n+            kind: ItemKind::Mod(Unsafe::No, ModKind::Loaded(items, Inline::Yes, span)),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n \n         let len = items.len();\n         if len == 0 {\n-            let module = Mod { inner: span, unsafety: Unsafe::No, items: vec![], inline: true };\n-            Crate { module, attrs: vec![], span, proc_macros }\n+            Crate { attrs: vec![], items: vec![], span, proc_macros }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n             match kind {\n-                ItemKind::Mod(module) => Crate { module, attrs, span, proc_macros },\n+                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => {\n+                    Crate { attrs, items, span, proc_macros }\n+                }\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n         } else {"}, {"sha": "32b9dd46baef446dc6b2f78d88e6393de49f4133", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -74,7 +74,7 @@ impl<'a> FnKind<'a> {\n /// Each method of the `Visitor` trait is a hook to be potentially\n /// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n-/// e.g., the `visit_mod` method by default calls `visit::walk_mod`.\n+/// e.g., the `visit_item` method by default calls `visit::walk_item`.\n ///\n /// If you want to ensure that your code handles every variant\n /// explicitly, you need to override each method. (And you also need\n@@ -87,9 +87,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_ident(&mut self, ident: Ident) {\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n-        walk_mod(self, m);\n-    }\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n@@ -238,14 +235,10 @@ pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n }\n \n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, &krate.attrs, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_item, &krate.items);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n }\n \n-pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n-    walk_list!(visitor, visit_item, &module.items);\n-}\n-\n pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -297,7 +290,12 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(ref module) => visitor.visit_mod(module, item.span, &item.attrs, item.id),\n+        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, _inner_span) => {\n+                walk_list!(visitor, visit_item, items)\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }"}, {"sha": "8b740b77740892d875b3df8d64640a07f25578e3", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -15,11 +15,11 @@ use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n-\n use smallvec::{smallvec, SmallVec};\n-use std::collections::BTreeSet;\n use tracing::debug;\n \n+use std::mem;\n+\n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n@@ -34,25 +34,6 @@ impl ItemLowerer<'_, '_, '_> {\n }\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n-    fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-        let def_id = self.lctx.lower_node_id(n).expect_owner();\n-\n-        self.lctx.modules.insert(\n-            def_id,\n-            hir::ModuleItems {\n-                items: BTreeSet::new(),\n-                trait_items: BTreeSet::new(),\n-                impl_items: BTreeSet::new(),\n-                foreign_items: BTreeSet::new(),\n-            },\n-        );\n-\n-        let old = self.lctx.current_module;\n-        self.lctx.current_module = def_id;\n-        visit::walk_mod(self, m);\n-        self.lctx.current_module = old;\n-    }\n-\n     fn visit_item(&mut self, item: &'a Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n@@ -67,10 +48,18 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(box ImplKind { ref of_trait, .. }) = item.kind {\n-                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                } else {\n-                    visit::walk_item(this, item);\n+                match item.kind {\n+                    ItemKind::Mod(..) => {\n+                        let def_id = this.lctx.lower_node_id(item.id).expect_owner();\n+                        let old_current_module =\n+                            mem::replace(&mut this.lctx.current_module, def_id);\n+                        visit::walk_item(this, item);\n+                        this.lctx.current_module = old_current_module;\n+                    }\n+                    ItemKind::Impl(box ImplKind { ref of_trait, .. }) => {\n+                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                    }\n+                    _ => visit::walk_item(this, item),\n                 }\n             });\n         }\n@@ -94,13 +83,13 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n                 let hir_item = lctx.lower_trait_item(item);\n                 let id = hir_item.trait_item_id();\n                 lctx.trait_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().trait_items.insert(id);\n             }\n             AssocCtxt::Impl => {\n                 let hir_item = lctx.lower_impl_item(item);\n                 let id = hir_item.impl_item_id();\n                 lctx.impl_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().impl_items.insert(id);\n             }\n         });\n \n@@ -113,7 +102,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n             let hir_item = lctx.lower_foreign_item(item);\n             let id = hir_item.foreign_item_id();\n             lctx.foreign_items.insert(id, hir_item);\n-            lctx.modules.get_mut(&lctx.current_module).unwrap().foreign_items.insert(id);\n+            lctx.modules.entry(lctx.current_module).or_default().foreign_items.insert(id);\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -157,7 +146,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n-        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n \n         // this vector is only used when walking over impl headers,\n         // input types, and the like, and should not be non-empty in\n@@ -172,12 +161,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         res\n     }\n \n-    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod<'hir> {\n+    pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n-            inner: m.inner,\n-            item_ids: self\n-                .arena\n-                .alloc_from_iter(m.items.iter().flat_map(|x| self.lower_item_id(x))),\n+            inner,\n+            item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_id(x))),\n         }\n     }\n \n@@ -327,7 +314,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+                ModKind::Loaded(items, _, inner_span) => {\n+                    hir::ItemKind::Mod(self.lower_mod(items, *inner_span))\n+                }\n+                ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n+            },\n             ItemKind::ForeignMod(ref fm) => {\n                 if fm.abi.is_none() {\n                     self.maybe_lint_missing_abi(span, id, abi::Abi::C);"}, {"sha": "05b417effd491688e9782633fc90e3c3f4a6c706", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -560,7 +560,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.lower_mod(&c.module);\n+        let module = self.lower_mod(&c.items, c.span);\n         let attrs = self.lower_attrs(&c.attrs);\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n@@ -608,7 +608,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n         let id = hir::ItemId { def_id: item.def_id };\n         self.items.insert(id, item);\n-        self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n+        self.modules.entry(self.current_module).or_default().items.insert(id);\n         id\n     }\n "}, {"sha": "563bcda51906575cefaf6602b1553caa42bba11e", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1054,12 +1054,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+            ItemKind::Mod(unsafety, ref mod_kind) => {\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n+                if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n+                    && !self.session.contains_name(&item.attrs, sym::path)\n+                {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "fb7e0d3450fde5a0f1b1cf422838fa73a4d37574", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -20,10 +20,6 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) {\n-        self.count += 1;\n-        walk_mod(self, m)\n-    }\n     fn visit_foreign_item(&mut self, i: &ForeignItem) {\n         self.count += 1;\n         walk_foreign_item(self, i)"}, {"sha": "82f6e936b766eb041a8bc4458abab9fd25d56772", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{GenericArg, MacArgs};\n+use rustc_ast::{GenericArg, MacArgs, ModKind};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -87,7 +87,6 @@ pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n-    is_expanded: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -103,12 +102,8 @@ pub fn print_crate<'a>(\n     is_expanded: bool,\n     edition: Edition,\n ) -> String {\n-    let mut s = State {\n-        s: pp::mk_printer(),\n-        comments: Some(Comments::new(sm, filename, input)),\n-        ann,\n-        is_expanded,\n-    };\n+    let mut s =\n+        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann };\n \n     if is_expanded && !krate.attrs.iter().any(|attr| attr.has_name(sym::no_core)) {\n         // We need to print `#![no_std]` (and its feature gate) so that\n@@ -132,7 +127,10 @@ pub fn print_crate<'a>(\n         }\n     }\n \n-    s.print_mod(&krate.module, &krate.attrs);\n+    s.print_inner_attributes(&krate.attrs);\n+    for item in &krate.items {\n+        s.print_item(item);\n+    }\n     s.print_remaining_comments();\n     s.ann.post(&mut s, AnnNode::Crate(krate));\n     s.s.eof()\n@@ -853,7 +851,7 @@ impl<'a> PrintState<'a> for State<'a> {\n \n impl<'a> State<'a> {\n     pub fn new() -> State<'a> {\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false }\n+        State { s: pp::mk_printer(), comments: None, ann: &NoAnn }\n     }\n \n     // Synthesizes a comment that was not textually present in the original source\n@@ -891,13 +889,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &ast::Mod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &_mod.items {\n-            self.print_item(item);\n-        }\n-    }\n-\n     crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n@@ -1139,23 +1130,29 @@ impl<'a> State<'a> {\n                 let body = body.as_deref();\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n-            ast::ItemKind::Mod(ref _mod) => {\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n                 self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(_mod.unsafety);\n+                    s.print_unsafety(unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n \n-                if _mod.inline || self.is_expanded {\n-                    self.nbsp();\n-                    self.bopen();\n-                    self.print_mod(_mod, &item.attrs);\n-                    self.bclose(item.span);\n-                } else {\n-                    self.s.word(\";\");\n-                    self.end(); // end inner head-block\n-                    self.end(); // end outer head-block\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        self.bclose(item.span);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.s.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {"}, {"sha": "71bbae1161b4bebcef863c749dde5e5f53697b2b", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -91,7 +91,7 @@ pub fn inject(\n     }\n \n     let decls = mk_decls(&mut krate, &mut cx, &macros);\n-    krate.module.items.push(decls);\n+    krate.items.push(decls);\n \n     krate\n }"}, {"sha": "3a81d076dc52fdbd6ea2db324bdc90bee7cc40f0", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -44,7 +44,7 @@ pub fn inject(\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &name in names.iter().rev() {\n         let ident = if rust_2018 { Ident::new(name, span) } else { Ident::new(name, call_site) };\n-        krate.module.items.insert(\n+        krate.items.insert(\n             0,\n             cx.item(\n                 span,\n@@ -79,7 +79,7 @@ pub fn inject(\n         })),\n     );\n \n-    krate.module.items.insert(0, use_item);\n+    krate.items.insert(0, use_item);\n \n     krate\n }"}, {"sha": "28e8259784387078e064de865d09c7c62e8cb286", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1,10 +1,10 @@\n // Code that generates a test runner to run all the tests in a crate\n \n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{attr, ModKind};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n@@ -89,7 +89,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n-        c.module.items.push(mk_main(&mut self.cx));\n+        c.items.push(mk_main(&mut self.cx));\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -103,18 +103,22 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(mut module) = item.kind {\n+        if let ast::ItemKind::Mod(..) = item.kind {\n             let tests = mem::take(&mut self.tests);\n-            noop_visit_mod(&mut module, self);\n+            noop_visit_item_kind(&mut item.kind, self);\n             let mut tests = mem::replace(&mut self.tests, tests);\n \n             if !tests.is_empty() {\n                 let parent =\n                     if item.id == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { item.id };\n                 // Create an identifier that will hygienically resolve the test\n                 // case name, even in another module.\n+                let inner_span = match item.kind {\n+                    ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) => span,\n+                    _ => unreachable!(),\n+                };\n                 let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n-                    module.inner,\n+                    inner_span,\n                     AstPass::TestHarness,\n                     &[],\n                     Some(parent),\n@@ -126,7 +130,6 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }"}, {"sha": "ad04fa9a95816b64e5c7cb88613f90c6835aa3b1", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -209,7 +209,7 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n-            krate.module.items = Vec::new();\n+            krate.items = Vec::new();\n             Features::default()\n         }\n         Some(attrs) => {"}, {"sha": "5a4737842f0af0e4e0a26fee4c01a5f03853a69b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -12,8 +12,8 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AttrItem, AttrStyle, Block, ItemKind, LitKind, MacArgs};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n@@ -350,6 +350,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx, monotonic }\n     }\n \n+    // FIXME: Avoid visiting the crate as a `Mod` item,\n+    // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n@@ -362,12 +364,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.root_path = module.directory.clone();\n         self.cx.current_expansion.module = Rc::new(module);\n \n-        let orig_mod_span = krate.module.inner;\n-\n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            kind: ast::ItemKind::Mod(krate.module),\n+            kind: ast::ItemKind::Mod(\n+                Unsafe::No,\n+                ModKind::Loaded(krate.items, Inline::Yes, krate.span)\n+            ),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility {\n@@ -379,28 +382,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item {\n+                attrs,\n+                kind: ast::ItemKind::Mod(_, ModKind::Loaded(items, ..)),\n+                ..\n+            }) => {\n                 krate.attrs = attrs;\n-                krate.module = module;\n+                krate.items = items;\n             }\n             None => {\n                 // Resolution failed so we return an empty expansion\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n             }\n             Some(ast::Item { span, kind, .. }) => {\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n                 self.cx.span_err(\n                     span,\n                     &format!(\n@@ -814,7 +811,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(module) if !module.inline => {\n+                    ast::ItemKind::Mod(_, mod_kind)\n+                        if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n+                    {\n                         feature_err(\n                             self.parse_sess,\n                             sym::proc_macro_hygiene,\n@@ -1271,52 +1270,47 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n+            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n                 let sess = &self.cx.sess.parse_sess;\n                 let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n \n                 let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n                 let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = if old_mod.inline {\n-                    // Inline `mod foo { ... }`, but we still need to push directories.\n-                    item.attrs = attrs;\n-                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                } else {\n-                    // We have an outline `mod foo;` so we need to parse the file.\n-                    let (new_mod, dir) = parse_external_mod(\n-                        &self.cx.sess,\n-                        ident,\n-                        span,\n-                        old_mod.unsafety,\n-                        dir,\n-                        &mut attrs,\n-                        pushed,\n-                    );\n-\n-                    let krate = ast::Crate {\n-                        span: new_mod.inner,\n-                        module: new_mod,\n-                        attrs,\n-                        proc_macros: vec![],\n-                    };\n-                    if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                        extern_mod_loaded(&krate, ident);\n+                let Directory { ownership, path } = match mod_kind {\n+                    ModKind::Loaded(_, Inline::Yes, _) => {\n+                        // Inline `mod foo { ... }`, but we still need to push directories.\n+                        item.attrs = attrs;\n+                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n+                    }\n+                    ModKind::Loaded(_, Inline::No, _) => {\n+                        panic!(\"`mod` item is loaded from a file for the second time\")\n                     }\n+                    ModKind::Unloaded => {\n+                        // We have an outline `mod foo;` so we need to parse the file.\n+                        let (items, inner_span, dir) =\n+                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+\n+                        let krate =\n+                            ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n+                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n+                            extern_mod_loaded(&krate, ident);\n+                        }\n \n-                    *old_mod = krate.module;\n-                    item.attrs = krate.attrs;\n-                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                    item = match self.configure(item) {\n-                        Some(node) => node,\n-                        None => {\n-                            if *pushed {\n-                                sess.included_mod_stack.borrow_mut().pop();\n+                        *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n+                        item.attrs = krate.attrs;\n+                        // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n+                        item = match self.configure(item) {\n+                            Some(node) => node,\n+                            None => {\n+                                if *pushed {\n+                                    sess.included_mod_stack.borrow_mut().pop();\n+                                }\n+                                return Default::default();\n                             }\n-                            return Default::default();\n-                        }\n-                    };\n-                    dir\n+                        };\n+                        dir\n+                    }\n                 };\n \n                 // Set the module info before we flat map."}, {"sha": "076d3b02be93fb45b565a17e4ac8cd6dec12074e", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1,4 +1,5 @@\n-use rustc_ast::{token, Attribute, Mod, Unsafe};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{token, Attribute, Item};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n@@ -42,11 +43,10 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n-    unsafety: Unsafe,\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n     pop_mod_stack: &mut bool,\n-) -> (Mod, Directory) {\n+) -> (Vec<P<Item>>, Span, Directory) {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n@@ -62,26 +62,22 @@ crate fn parse_external_mod(\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let mut module = parser.parse_mod(&token::Eof, unsafety)?;\n-        module.0.inline = false;\n-        module\n+        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        attrs.append(&mut inner_attrs);\n+        (items, inner_span)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n-        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n-        (module, Vec::new())\n-    });\n-    attrs.append(&mut new_attrs);\n+    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n \n-    // Extract the directory path for submodules of `module`.\n-    let path = sess.source_map().span_to_unmapped_path(module.inner);\n+    // Extract the directory path for submodules of  the module.\n+    let path = sess.source_map().span_to_unmapped_path(inner_span);\n     let mut path = match path {\n         FileName::Real(name) => name.into_local_path(),\n         other => PathBuf::from(other.to_string()),\n     };\n     path.pop();\n \n-    (module, Directory { ownership, path })\n+    (items, inner_span, Directory { ownership, path })\n }\n \n fn error_on_circular_module<'a>("}, {"sha": "7e7155ad27876bff0571d97c42305eb518be8ade", "filename": "compiler/rustc_expand/src/mut_visit/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -7,8 +7,8 @@ use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n // This version doesn't care about getting comments or doc-strings in.\n-fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n-    s.print_mod(&krate.module, &krate.attrs)\n+fn print_crate_items(krate: &ast::Crate) -> String {\n+    krate.items.iter().map(|i| pprust::item_to_string(i)).collect::<Vec<_>>().join(\" \")\n }\n \n // Change every identifier to \"zz\".\n@@ -46,7 +46,7 @@ fn ident_transformation() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string()\n         );\n     })\n@@ -66,7 +66,7 @@ fn ident_transformation_in_defs() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string()\n         );\n     })"}, {"sha": "56f25ffdb0187cf7bc4ea2a8f8c3ea7c17d25898", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -309,8 +309,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.kind {\n-            assert!(m.items.len() == 2);\n+        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n+            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n         } else {\n             panic!();\n         }"}, {"sha": "4df8c44e62b38a0506cb89cce4bca53ef3c21d94", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -616,7 +616,7 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Default, Encodable, Debug, HashStable_Generic)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate"}, {"sha": "cc3bf4095fdef300fc8d3c7e1cb7aad65bf4eaf7", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -188,13 +188,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_ident, ident);\n     }\n \n-    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_early_pass!(self, check_mod, m, s, n);\n-        self.check_id(n);\n-        ast_visit::walk_mod(self, m);\n-        run_early_pass!(self, check_mod_post, m, s, n);\n-    }\n-\n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_early_pass!(cx, check_local, l);"}, {"sha": "ffbed3a0aff2d111ad897e81ad520085622e26f6", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -160,8 +160,6 @@ macro_rules! early_lint_methods {\n             fn check_ident(a: Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n-            fn check_mod(a: &ast::Mod, b: Span, c: ast::NodeId);\n-            fn check_mod_post(a: &ast::Mod, b: Span, c: ast::NodeId);\n             fn check_foreign_item(a: &ast::ForeignItem);\n             fn check_foreign_item_post(a: &ast::ForeignItem);\n             fn check_item(a: &ast::Item);"}, {"sha": "0f907859a19a681d90ff554360a7cad0efc1e622", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -25,47 +25,36 @@ use tracing::debug;\n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n-        let lo = self.token.span;\n-        let (module, attrs) = self.parse_mod(&token::Eof, Unsafe::No)?;\n-        let span = lo.to(self.token.span);\n+        let (attrs, items, span) = self.parse_mod(&token::Eof)?;\n         let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n-        Ok(ast::Crate { attrs, module, span, proc_macros })\n+        Ok(ast::Crate { attrs, items, span, proc_macros })\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n         let unsafety = self.parse_unsafety();\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n-        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            (Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false }, Vec::new())\n+        let mod_kind = if self.eat(&token::Semi) {\n+            ModKind::Unloaded\n         } else {\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            self.parse_mod(&token::CloseDelim(token::Brace), unsafety)?\n+            let (mut inner_attrs, items, inner_span) =\n+                self.parse_mod(&token::CloseDelim(token::Brace))?;\n+            attrs.append(&mut inner_attrs);\n+            ModKind::Loaded(items, Inline::Yes, inner_span)\n         };\n-        attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(module)))\n+        Ok((id, ItemKind::Mod(unsafety, mod_kind)))\n     }\n \n     /// Parses the contents of a module (inner attributes followed by module items).\n     pub fn parse_mod(\n         &mut self,\n         term: &TokenKind,\n-        unsafety: Unsafe,\n-    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+    ) -> PResult<'a, (Vec<Attribute>, Vec<P<Item>>, Span)> {\n         let lo = self.token.span;\n         let attrs = self.parse_inner_attributes()?;\n-        let module = self.parse_mod_items(term, lo, unsafety)?;\n-        Ok((module, attrs))\n-    }\n \n-    /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(\n-        &mut self,\n-        term: &TokenKind,\n-        inner_lo: Span,\n-        unsafety: Unsafe,\n-    ) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = self.parse_item(ForceCollect::No)? {\n             items.push(item);\n@@ -82,9 +71,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n-\n-        Ok(Mod { inner: inner_lo.to(hi), unsafety, items, inline: true })\n+        Ok((attrs, items, lo.to(self.prev_token.span)))\n     }\n }\n "}, {"sha": "fac28281593c81b7609c15f026af3cb58ecf2078", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -124,11 +124,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'v hir::Mod<'v>, _s: Span, n: hir::HirId) {\n-        self.record(\"Mod\", Id::None, m);\n-        hir_visit::walk_mod(self, m, n)\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem<'v>) {\n         self.record(\"ForeignItem\", Id::Node(i.hir_id()), i);\n         hir_visit::walk_foreign_item(self, i)\n@@ -252,11 +247,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n }\n \n impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n-    fn visit_mod(&mut self, m: &'v ast::Mod, _s: Span, _a: &[ast::Attribute], _n: NodeId) {\n-        self.record(\"Mod\", Id::None, m);\n-        ast_visit::walk_mod(self, m)\n-    }\n-\n     fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n         self.record(\"ForeignItem\", Id::None, i);\n         ast_visit::walk_foreign_item(self, i)"}, {"sha": "09ab84eaeb613d4111d99c9464092c3506da5ae4", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1023,7 +1023,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 });\n             }\n \n-            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n+            ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n                 self.with_scope(item.id, |this| {\n                     visit::walk_item(this, item);\n                 });"}, {"sha": "77fbbaa1532af38a15fa6b4967ff79688fa34ab6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -11,6 +11,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(bool_to_option)]\n+#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n #![feature(nll)]\n@@ -23,11 +24,12 @@ use Determinacy::*;\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n+use rustc_ast::ptr::P;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{ItemKind, Path};\n+use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n@@ -59,6 +61,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n+use std::ops::ControlFlow;\n use std::{cmp, fmt, iter, ptr};\n use tracing::debug;\n \n@@ -283,36 +286,29 @@ struct UsePlacementFinder {\n impl UsePlacementFinder {\n     fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n         let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n-        visit::walk_crate(&mut finder, krate);\n+        if let ControlFlow::Continue(..) = finder.check_mod(&krate.items, CRATE_NODE_ID) {\n+            visit::walk_crate(&mut finder, krate);\n+        }\n         (finder.span, finder.found_use)\n     }\n-}\n \n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n-    fn visit_mod(\n-        &mut self,\n-        module: &'tcx ast::Mod,\n-        _: Span,\n-        _: &[ast::Attribute],\n-        node_id: NodeId,\n-    ) {\n+    fn check_mod(&mut self, items: &[P<ast::Item>], node_id: NodeId) -> ControlFlow<()> {\n         if self.span.is_some() {\n-            return;\n+            return ControlFlow::Break(());\n         }\n         if node_id != self.target_module {\n-            visit::walk_mod(self, module);\n-            return;\n+            return ControlFlow::Continue(());\n         }\n         // find a use statement\n-        for item in &module.items {\n+        for item in items {\n             match item.kind {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if !item.span.from_expansion() {\n                         self.span = Some(item.span.shrink_to_lo());\n                         self.found_use = true;\n-                        return;\n+                        return ControlFlow::Break(());\n                     }\n                 }\n                 // don't place use before extern crate\n@@ -337,6 +333,18 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 }\n             }\n         }\n+        ControlFlow::Continue(())\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_item(&mut self, item: &'tcx ast::Item) {\n+        if let ItemKind::Mod(_, ModKind::Loaded(items, ..)) = &item.kind {\n+            if let ControlFlow::Break(..) = self.check_mod(items, item.id) {\n+                return;\n+            }\n+        }\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "0307875c154b8bc291f608841b70dd4eba35bb85", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "d26530efe3ecd7fb337cb57afb0e5b0700685013", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "56befe3a0a75d7eff1216f6c2080a11176b488c9", "filename": "src/test/ui/issues/issue-49040.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49040.stderr?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -7,10 +7,8 @@ LL | #![allow(unused_variables)];\n error[E0601]: `main` function not found in crate `issue_49040`\n   --> $DIR/issue-49040.rs:1:1\n    |\n-LL | / #![allow(unused_variables)];\n-LL | |\n-LL | | fn foo() {}\n-   | |__^ consider adding a `main` function to `$DIR/issue-49040.rs`\n+LL | #![allow(unused_variables)];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider adding a `main` function to `$DIR/issue-49040.rs`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9ff7ef7cc3b55e17cb9acf107a732c5fb11e8ce5", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=30f39fee9ddaacbe0dc0a62b5a7fef6338a90a00", "patch": "@@ -241,9 +241,12 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && eq_generics(lg, rg)\n                 && both(lb, rb, |l, r| eq_block(l, r))\n         }\n-        (Mod(l), Mod(r)) => {\n-            l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind))\n-        }\n+        (Mod(lu, lmk), Mod(ru, rmk)) => lu == ru && match (lmk, rmk) {\n+            (ModKind::Loaded(litems, linline, _), ModKind::Loaded(ritems, rinline, _)) =>\n+                linline == rinline && over(litems, ritems, |l, r| eq_item(l, r, eq_item_kind)),\n+            (ModKind::Unloaded, ModKind::Unloaded) => true,\n+            _ => false,\n+        },\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n                 && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))"}]}