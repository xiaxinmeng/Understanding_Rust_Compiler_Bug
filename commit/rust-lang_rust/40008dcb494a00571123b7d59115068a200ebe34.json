{"sha": "40008dcb494a00571123b7d59115068a200ebe34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMDA4ZGNiNDk0YTAwNTcxMTIzYjdkNTkxMTUwNjhhMjAwZWJlMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T23:36:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-24T23:36:52Z"}, "message": "Auto merge of #71539 - Dylan-DPC:rollup-a2vbfh9, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #69456 (fix misleading type annotation diagonstics)\n - #71330 (Only run dataflow for const qualification if type-based check would fail)\n - #71480 (Improve PanicInfo examples readability)\n - #71485 (Add BinaryHeap::retain as suggested in #42849)\n - #71512 (Remove useless \"\" args)\n - #71527 (Miscellaneous cleanup in `check_consts`)\n - #71534 (Avoid unused Option::map results)\n - #71535 (Fix typos in docs for keyword \"in\")\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2fd39a8435e3a41236e0820e08646e9e7a1508ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fd39a8435e3a41236e0820e08646e9e7a1508ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40008dcb494a00571123b7d59115068a200ebe34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40008dcb494a00571123b7d59115068a200ebe34", "html_url": "https://github.com/rust-lang/rust/commit/40008dcb494a00571123b7d59115068a200ebe34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40008dcb494a00571123b7d59115068a200ebe34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "html_url": "https://github.com/rust-lang/rust/commit/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69"}, {"sha": "32fb77d9516ec8d781b998e5d314dc7b6a7954d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/32fb77d9516ec8d781b998e5d314dc7b6a7954d8", "html_url": "https://github.com/rust-lang/rust/commit/32fb77d9516ec8d781b998e5d314dc7b6a7954d8"}], "stats": {"total": 638, "additions": 451, "deletions": 187}, "files": [{"sha": "e6560771c0ee71a59f835cdc1f82fe43767ce130", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -93,12 +93,12 @@ static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n ];\n \n fn print_error(tool: &str, submodule: &str) {\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"We detected that this PR updated '{}', but its tests failed.\", tool);\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do intend to update '{}', please check the error messages above and\", tool);\n     eprintln!(\"commit another update.\");\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");"}, {"sha": "8e170d970bc57260d9915274ed41170f72957d50", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -665,6 +665,34 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n         DrainSorted { inner: self }\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns\n+    /// `false`. The elements are visited in unsorted (and unspecified) order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_retain)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    ///\n+    /// heap.retain(|x| x % 2 == 0); // only keep even numbers\n+    ///\n+    /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n+    /// ```\n+    #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n+    pub fn retain<F>(&mut self, f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.data.retain(f);\n+        self.rebuild();\n+    }\n }\n \n impl<T> BinaryHeap<T> {"}, {"sha": "62084ccf53c5929f78edcd6c7e1dff45ea614de4", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -372,6 +372,14 @@ fn assert_covariance() {\n     }\n }\n \n+#[test]\n+fn test_retain() {\n+    let mut a = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    a.retain(|x| x % 2 == 0);\n+\n+    assert_eq!(a.into_sorted_vec(), [-10, 2, 4])\n+}\n+\n // old binaryheap failed this test\n //\n // Integrity means that all elements are present after a comparison panics,"}, {"sha": "78d49558262e36f2afecd675b8d705bbd7da96a0", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -14,6 +14,7 @@\n #![feature(binary_heap_drain_sorted)]\n #![feature(vec_remove_item)]\n #![feature(split_inclusive)]\n+#![feature(binary_heap_retain)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "575f51d0a7d56052289dd382ab5cbb55db0eefb2", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -77,7 +77,11 @@ impl<'a> PanicInfo<'a> {\n     /// use std::panic;\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n-    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n+    ///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n+    ///         println!(\"panic occurred: {:?}\", s);\n+    ///     } else {\n+    ///         println!(\"panic occurred\");\n+    ///     }\n     /// }));\n     ///\n     /// panic!(\"Normal panic\");\n@@ -112,8 +116,10 @@ impl<'a> PanicInfo<'a> {\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n     ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n-    ///             location.line());\n+    ///         println!(\"panic occurred in file '{}' at line {}\",\n+    ///             location.file(),\n+    ///             location.line(),\n+    ///         );\n     ///     } else {\n     ///         println!(\"panic occurred but can't get location information...\");\n     ///     }"}, {"sha": "c2b2e7ce59f3711a1a27bbc3dfd2c14fbbe2572c", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -98,7 +98,7 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n                         }\n                     }\n \n-                    diagnostic.map(|d| {\n+                    if let Some(d) = diagnostic {\n                         struct_span_err!(d, attr.span, E0633, \"malformed `unwind` attribute input\")\n                             .span_label(attr.span, \"invalid argument\")\n                             .span_suggestions(\n@@ -110,7 +110,7 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n                                 Applicability::MachineApplicable,\n                             )\n                             .emit();\n-                    });\n+                    };\n                 }\n             }\n         }"}, {"sha": "972e75d201b90964dbc095f8822809f797780a04", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1172,10 +1172,10 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             // ignore derives so they remain unused\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n \n-            if attr.is_some() {\n+            if let Some(ref attr_value) = attr {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n                 // expansion will eat the attribute so it won't error later.\n-                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+                self.cfg.maybe_emit_expr_attr_err(attr_value);\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self\n@@ -1322,8 +1322,8 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             // Ignore derives so they remain unused.\n             let (attr, after_derive) = self.classify_nonitem(&mut expr);\n \n-            if attr.is_some() {\n-                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+            if let Some(ref attr_value) = attr {\n+                self.cfg.maybe_emit_expr_attr_err(attr_value);\n \n                 return self\n                     .collect_attr("}, {"sha": "30cddac6aac91afd8df0fd90a00756fb07721281", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -246,7 +246,7 @@ impl DefPath {\n \n         let mut opt_delimiter = None;\n         for component in &self.data {\n-            opt_delimiter.map(|d| s.push(d));\n+            s.extend(opt_delimiter);\n             opt_delimiter = Some('-');\n             if component.disambiguator == 0 {\n                 write!(s, \"{}\", component.data.as_symbol()).unwrap();"}, {"sha": "8b53019106537275eaa40a8c2e051fbb78f07d8e", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -755,7 +755,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n             ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n                 err.span_label(then, \"expected because of this\");\n-                outer.map(|sp| err.span_label(sp, \"`if` and `else` have incompatible types\"));\n+                if let Some(sp) = outer {\n+                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n+                }\n                 if let Some(sp) = semicolon {\n                     err.span_suggestion_short(\n                         sp,"}, {"sha": "53f52038ed0222676ab2e1f0642f368e05ebfc8c", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -17,23 +17,27 @@ use std::borrow::Cow;\n struct FindHirNodeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target: GenericArg<'tcx>,\n+    target_span: Span,\n     found_node_ty: Option<Ty<'tcx>>,\n     found_local_pattern: Option<&'tcx Pat<'tcx>>,\n     found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>, target_span: Span) -> Self {\n         Self {\n             infcx,\n             target,\n+            target_span,\n             found_node_ty: None,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n             found_closure: None,\n             found_method_call: None,\n+            found_exact_method_call: None,\n         }\n     }\n \n@@ -103,6 +107,17 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::MethodCall(_, call_span, exprs) = expr.kind {\n+            if call_span == self.target_span\n+                && Some(self.target)\n+                    == self.infcx.in_progress_tables.and_then(|tables| {\n+                        tables.borrow().node_type_opt(exprs.first().unwrap().hir_id).map(Into::into)\n+                    })\n+            {\n+                self.found_exact_method_call = Some(&expr);\n+                return;\n+            }\n+        }\n         if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n@@ -234,7 +249,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into());\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -287,14 +302,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n         };\n \n-        let ty_msg = match local_visitor.found_node_ty {\n-            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+        let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n+            (_, Some(_)) => String::new(),\n+            (Some(ty::TyS { kind: ty::Closure(_, substs), .. }), _) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+            (Some(ty), _) if is_named_and_not_impl_trait(ty) => {\n                 let ty = ty_to_string(ty);\n                 format!(\" for `{}`\", ty)\n             }\n@@ -370,7 +386,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => \"a type\".to_string(),\n         };\n \n-        if let Some(pattern) = local_visitor.found_arg_pattern {\n+        if let Some(e) = local_visitor.found_exact_method_call {\n+            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n+                // Suggest specifying type params or point out the return type of the call:\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n+                //    |\n+                // LL |     let _ = x.into_iter().sum() as f64;\n+                //    |                           ^^^\n+                //    |                           |\n+                //    |                           cannot infer type for `S`\n+                //    |                           help: consider specifying the type argument in\n+                //    |                           the method call: `sum::<S>`\n+                //    |\n+                //    = note: type must be known at this point\n+                //\n+                // or\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/issue-65611.rs:59:20\n+                //    |\n+                // LL |     let x = buffer.last().unwrap().0.clone();\n+                //    |             -------^^^^--\n+                //    |             |      |\n+                //    |             |      cannot infer type for `T`\n+                //    |             this method call resolves to `std::option::Option<&T>`\n+                //    |\n+                //    = note: type must be known at this point\n+                self.annotate_method_call(segment, e, &mut err);\n+            }\n+        } else if let Some(pattern) = local_visitor.found_arg_pattern {\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:"}, {"sha": "e7a863c63ccaaa43bae17772834e8fd41e671083", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -101,9 +101,15 @@ fn dump_crates(cstore: &CStore) {\n         info!(\"  hash: {}\", data.hash());\n         info!(\"  reqd: {:?}\", data.dep_kind());\n         let CrateSource { dylib, rlib, rmeta } = data.source();\n-        dylib.as_ref().map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n-        rlib.as_ref().map(|rl| info!(\"   rlib: {}\", rl.0.display()));\n-        rmeta.as_ref().map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n+        if let Some(dylib) = dylib {\n+            info!(\"  dylib: {}\", dylib.0.display());\n+        }\n+        if let Some(rlib) = rlib {\n+            info!(\"   rlib: {}\", rlib.0.display());\n+        }\n+        if let Some(rmeta) = rmeta {\n+            info!(\"   rmeta: {}\", rmeta.0.display());\n+        }\n     });\n }\n "}, {"sha": "b87429199ec3a0f421b96137848165e8a69424dc", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -3,7 +3,6 @@\n use rustc_errors::struct_span_err;\n use rustc_hir::lang_items;\n use rustc_hir::{def_id::DefId, HirId};\n-use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -28,70 +27,100 @@ use crate::dataflow::{self, Analysis};\n // We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n // through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`\n // kills locals upon `StorageDead` because a local will never be used after a `StorageDead`.\n-pub type IndirectlyMutableResults<'mir, 'tcx> =\n+type IndirectlyMutableResults<'mir, 'tcx> =\n     dataflow::ResultsCursor<'mir, 'tcx, MaybeMutBorrowedLocals<'mir, 'tcx>>;\n \n-struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n-            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(ccx.body);\n-\n-        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n-        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(ccx, decl.ty) {\n-                in_any_value_of_ty.insert(local);\n-            }\n-        }\n+type QualifResults<'mir, 'tcx, Q> =\n+    dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'mir, 'mir, 'tcx, Q>>;\n \n-        QualifCursor { cursor, in_any_value_of_ty }\n-    }\n-}\n-\n-pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n-    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n+#[derive(Default)]\n+pub struct Qualifs<'mir, 'tcx> {\n+    has_mut_interior: Option<QualifResults<'mir, 'tcx, HasMutInterior>>,\n+    needs_drop: Option<QualifResults<'mir, 'tcx, NeedsDrop>>,\n+    indirectly_mutable: Option<IndirectlyMutableResults<'mir, 'tcx>>,\n }\n \n-impl Qualifs<'a, 'mir, 'tcx> {\n-    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n-        self.indirectly_mutable.seek_before(location);\n-        self.indirectly_mutable.get().contains(local)\n+impl Qualifs<'mir, 'tcx> {\n+    fn indirectly_mutable(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let indirectly_mutable = self.indirectly_mutable.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n+\n+            // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n+            // allowed in a const.\n+            //\n+            // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n+            // without breaking stable code?\n+            MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n+                .unsound_ignore_borrow_on_drop()\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        indirectly_mutable.seek_before(location);\n+        indirectly_mutable.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(&mut self, local: Local, location: Location) -> bool {\n-        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+    fn needs_drop(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.needs_drop.cursor.seek_before(location);\n-        self.needs_drop.cursor.get().contains(local) || self.indirectly_mutable(local, location)\n+        let needs_drop = self.needs_drop.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(NeedsDrop, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        needs_drop.seek_before(location);\n+        needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(&mut self, local: Local, location: Location) -> bool {\n-        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+    fn has_mut_interior(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.has_mut_interior.cursor.seek_before(location);\n-        self.has_mut_interior.cursor.get().contains(local)\n-            || self.indirectly_mutable(local, location)\n+        let has_mut_interior = self.has_mut_interior.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(HasMutInterior, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        has_mut_interior.seek_before(location);\n+        has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n-    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &'mir ConstCx<'mir, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n@@ -114,49 +143,31 @@ impl Qualifs<'a, 'mir, 'tcx> {\n         let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n-            needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n-            has_mut_interior: self.has_mut_interior(RETURN_PLACE, return_loc),\n+            needs_drop: self.needs_drop(ccx, RETURN_PLACE, return_loc),\n+            has_mut_interior: self.has_mut_interior(ccx, RETURN_PLACE, return_loc),\n         }\n     }\n }\n \n-pub struct Validator<'a, 'mir, 'tcx> {\n-    ccx: &'a ConstCx<'mir, 'tcx>,\n-    qualifs: Qualifs<'a, 'mir, 'tcx>,\n+pub struct Validator<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n-impl Deref for Validator<'_, 'mir, 'tcx> {\n+impl Deref for Validator<'mir, 'tcx> {\n     type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.ccx\n     }\n }\n \n-impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n-\n-        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n-\n-        // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n-        // allowed in a const.\n-        //\n-        // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n-        // without breaking stable code?\n-        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-            .unsound_ignore_borrow_on_drop()\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(body);\n-\n-        let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n-\n-        Validator { span: ccx.body.span, ccx, qualifs }\n+impl Validator<'mir, 'tcx> {\n+    pub fn new(ccx: &'mir ConstCx<'mir, 'tcx>) -> Self {\n+        Validator { span: ccx.body.span, ccx, qualifs: Default::default() }\n     }\n \n     pub fn check_body(&mut self) {\n@@ -205,7 +216,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     where\n         O: NonConstOp,\n     {\n-        trace!(\"check_op: op={:?}\", op);\n+        debug!(\"check_op: op={:?}\", op);\n \n         if op.is_allowed_in_item(self) {\n             return;\n@@ -239,7 +250,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &BasicBlockData<'tcx>) {\n         trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n \n@@ -345,7 +356,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n-                    &mut |local| self.qualifs.has_mut_interior(local, location),\n+                    &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n                     place.as_ref(),\n                 );\n \n@@ -386,15 +397,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_local(&mut self, place_local: &Local, context: PlaceContext, location: Location) {\n-        trace!(\n-            \"visit_local: place_local={:?} context={:?} location={:?}\",\n-            place_local,\n-            context,\n-            location,\n-        );\n-    }\n-\n     fn visit_operand(&mut self, op: &Operand<'tcx>, location: Location) {\n         self.super_operand(op, location);\n         if let Operand::Constant(c) = op {\n@@ -571,7 +573,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop(local, location)\n+                    self.qualifs.needs_drop(self.ccx, local, location)\n                 } else {\n                     true\n                 };"}, {"sha": "b9d61458a839b5cb76c5a0353e1937d365206060", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1388,7 +1388,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        fake_borrows.as_mut().map(|fb| fb.insert(match_place));\n+        if let Some(fb) = fake_borrows {\n+            fb.insert(match_place);\n+        }\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)"}, {"sha": "9264fc8a7351828fa76f5ece2cd74f9cf2975c70", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1206,8 +1206,8 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {\n-        make_unclosed_delims_error(unmatched, sess).map(|mut e| {\n+        if let Some(mut e) = make_unclosed_delims_error(unmatched, sess) {\n             e.emit();\n-        });\n+        }\n     }\n }"}, {"sha": "09b3d44020d8160b486cfaa94e70ad1796a4f87e", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -68,7 +68,9 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n             hir::ExprKind::Break(label, ref opt_expr) => {\n-                opt_expr.as_ref().map(|e| self.visit_expr(e));\n+                if let Some(e) = opt_expr {\n+                    self.visit_expr(e);\n+                }\n \n                 if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n                     // If we emitted an error about an unlabeled break in a labeled"}, {"sha": "5150b278a77222549a9607970ba86625f39eb4ec", "filename": "src/librustc_query_system/query/job.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_query_system%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_query_system%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fquery%2Fjob.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -133,7 +133,11 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n     /// as there are no concurrent jobs which could be waiting on us\n     pub fn signal_complete(self) {\n         #[cfg(parallel_compiler)]\n-        self.latch.map(|latch| latch.set());\n+        {\n+            if let Some(latch) = self.latch {\n+                latch.set();\n+            }\n+        }\n     }\n }\n "}, {"sha": "f369e827a402b29c6dd34f6d6d03bfa9165b3451", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1996,7 +1996,9 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.visit_expr(cond);\n                     this.visit_block(then);\n                 });\n-                opt_else.as_ref().map(|expr| self.visit_expr(expr));\n+                if let Some(expr) = opt_else {\n+                    self.visit_expr(expr);\n+                }\n             }\n \n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),"}, {"sha": "77aa7230aa893fbdf7031385a7f3797cda37155b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -499,7 +499,9 @@ impl<'a> ModuleData<'a> {\n         F: FnMut(&mut R, Ident, Namespace, &'a NameBinding<'a>),\n     {\n         for (key, name_resolution) in resolver.as_mut().resolutions(self).borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(resolver, key.ident, key.ns, binding));\n+            if let Some(binding) = name_resolution.borrow().binding {\n+                f(resolver, key.ident, key.ns, binding);\n+            }\n         }\n     }\n "}, {"sha": "d904046331723ac1c419b8f100ded4cf3860f730", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -979,20 +979,21 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).map(|o| o.as_string()\n-                                    .map(|s| base.options.$key_name = s.to_string()));\n+                if let Some(s) = obj.find(&name).and_then(Json::as_string) {\n+                    base.options.$key_name = s.to_string();\n+                }\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..])\n-                    .map(|o| o.as_boolean()\n-                         .map(|s| base.options.$key_name = s));\n+                if let Some(s) = obj.find(&name).and_then(Json::as_boolean) {\n+                    base.options.$key_name = s;\n+                }\n             } );\n             ($key_name:ident, Option<u64>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..])\n-                    .map(|o| o.as_u64()\n-                         .map(|s| base.options.$key_name = Some(s)));\n+                if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n+                    base.options.$key_name = Some(s);\n+                }\n             } );\n             ($key_name:ident, MergeFunctions) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n@@ -1034,19 +1035,19 @@ impl Target {\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).map(|o| o.as_array()\n-                    .map(|v| base.options.$key_name = v.iter()\n-                        .map(|a| a.as_string().unwrap().to_string()).collect()\n-                        )\n-                    );\n+                if let Some(v) = obj.find(&name).and_then(Json::as_array) {\n+                    base.options.$key_name = v.iter()\n+                        .map(|a| a.as_string().unwrap().to_string())\n+                        .collect();\n+                }\n             } );\n             ($key_name:ident, opt_list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(&name[..]).map(|o| o.as_array()\n-                    .map(|v| base.options.$key_name = Some(v.iter()\n-                        .map(|a| a.as_string().unwrap().to_string()).collect())\n-                        )\n-                    );\n+                if let Some(v) = obj.find(&name).and_then(Json::as_array) {\n+                    base.options.$key_name = Some(v.iter()\n+                        .map(|a| a.as_string().unwrap().to_string())\n+                        .collect());\n+                }\n             } );\n             ($key_name:ident, optional) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");"}, {"sha": "c7d749815febb9555612ce2ca7130150cf6f7b5a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -213,7 +213,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             None,\n         );\n \n-        assoc_bindings.first().map(|b| Self::prohibit_assoc_ty_binding(self.tcx(), b.span));\n+        if let Some(b) = assoc_bindings.first() {\n+            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+        }\n \n         substs\n     }\n@@ -1095,7 +1097,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n-        assoc_bindings.first().map(|b| AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span));\n+        if let Some(b) = assoc_bindings.first() {\n+            AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+        }\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n "}, {"sha": "c75283e419a6d5da928552e1c75a46afbcecfaa1", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -36,7 +36,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        self.demand_suptype_diag(sp, expected, actual).map(|mut e| e.emit());\n+        if let Some(mut e) = self.demand_suptype_diag(sp, expected, actual) {\n+            e.emit();\n+        }\n     }\n \n     pub fn demand_suptype_diag("}, {"sha": "b7e86c0791f634d8b27925613bdcd41a4ac9e8a5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -4492,15 +4492,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => Err(ErrorReported),\n             };\n             if item_name.name != kw::Invalid {\n-                self.report_method_error(\n+                if let Some(mut e) = self.report_method_error(\n                     span,\n                     ty,\n                     item_name,\n                     SelfSource::QPath(qself),\n                     error,\n                     None,\n-                )\n-                .map(|mut e| e.emit());\n+                ) {\n+                    e.emit();\n+                }\n             }\n             result\n         });"}, {"sha": "8e109efbcb576362ddd10f25e477d8fd8af07dc5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -104,7 +104,9 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) {\n-        self.demand_eqtype_pat_diag(cause_span, expected, actual, ti).map(|mut err| err.emit());\n+        if let Some(mut err) = self.demand_eqtype_pat_diag(cause_span, expected, actual, ti) {\n+            err.emit();\n+        }\n     }\n }\n \n@@ -449,12 +451,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x, y| {\n             if let Some((_, x_ty, x_span)) = x {\n-                self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n+                if let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti) {\n                     if let Some((_, y_ty, y_span)) = y {\n                         self.endpoint_has_type(&mut err, y_span, y_ty);\n                     }\n                     err.emit();\n-                });\n+                };\n             }\n         };\n         demand_eqtype(lhs, rhs);\n@@ -852,8 +854,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type-check the tuple struct pattern against the expected type.\n         let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, ti);\n-        let had_err = diag.is_some();\n-        diag.map(|mut err| err.emit());\n+        let had_err = if let Some(mut err) = diag {\n+            err.emit();\n+            true\n+        } else {\n+            false\n+        };\n \n         // Type-check subpatterns.\n         if subpats.len() == variant.fields.len()"}, {"sha": "c5bf151bc1e11083ff42ba0e7293ee9052792a84", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -165,12 +165,18 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n                                 let mut adjustments = tables.adjustments_mut();\n-                                adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n-                                adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n+                                if let Some(a) = adjustments.get_mut(lhs.hir_id) {\n+                                    a.pop();\n+                                }\n+                                if let Some(a) = adjustments.get_mut(rhs.hir_id) {\n+                                    a.pop();\n+                                }\n                             }\n                         }\n                         hir::ExprKind::AssignOp(..) => {\n-                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n+                            if let Some(a) = tables.adjustments_mut().get_mut(lhs.hir_id) {\n+                                a.pop();\n+                            }\n                         }\n                         _ => {}\n                     }\n@@ -215,7 +221,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     tables.type_dependent_defs_mut().remove(e.hir_id);\n                     tables.node_substs_mut().remove(e.hir_id);\n \n-                    tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n+                    if let Some(a) = tables.adjustments_mut().get_mut(base.hir_id) {\n                         // Discard the need for a mutable borrow\n \n                         // Extra adjustment made when indexing causes a drop\n@@ -229,7 +235,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             // So the borrow discard actually happens here\n                             a.pop();\n                         }\n-                    });\n+                    }\n                 }\n             }\n         }"}, {"sha": "63ab0ef5f1728129f0a12bd5e3b60c61af9a2dd5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1599,7 +1599,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n                 let mut param_names = vec![];\n-                reg.clean(cx).map(|b| param_names.push(GenericBound::Outlives(b)));\n+                if let Some(b) = reg.clean(cx) {\n+                    param_names.push(GenericBound::Outlives(b));\n+                }\n                 for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path =\n@@ -1662,10 +1664,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             tr\n                         } else if let ty::Predicate::TypeOutlives(pred) = *predicate {\n                             // these should turn up at the end\n-                            pred.skip_binder()\n-                                .1\n-                                .clean(cx)\n-                                .map(|r| regions.push(GenericBound::Outlives(r)));\n+                            if let Some(r) = pred.skip_binder().1.clean(cx) {\n+                                regions.push(GenericBound::Outlives(r));\n+                            }\n                             return None;\n                         } else {\n                             return None;"}, {"sha": "37540295774754a7d8939ab3cc2a6a1d06eb32a9", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -94,7 +94,7 @@ impl TocBuilder {\n         loop {\n             match self.chain.pop() {\n                 Some(mut next) => {\n-                    this.map(|e| next.children.entries.push(e));\n+                    next.children.entries.extend(this);\n                     if next.level < level {\n                         // this is the parent we want, so return it to\n                         // its rightful place.\n@@ -105,7 +105,7 @@ impl TocBuilder {\n                     }\n                 }\n                 None => {\n-                    this.map(|e| self.top_level.entries.push(e));\n+                    self.top_level.entries.extend(this);\n                     return;\n                 }\n             }"}, {"sha": "6fbb0139b0ecafc11ff08948d39239cee02e073f", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -685,12 +685,12 @@ mod impl_keyword {}\n /// ## Literal Examples:\n ///\n ///    * `for _ **in** 1..3 {}` - Iterate over an exclusive range up to but excluding 3.\n-///    * `for _ **in** 1..=3 {}` - Iterate over an inclusive range up to and includeing 3.\n+///    * `for _ **in** 1..=3 {}` - Iterate over an inclusive range up to and including 3.\n ///\n /// (Read more about [range patterns])\n ///\n /// [`Iterator`]: ../book/ch13-04-performance.html\n-/// [`range patterns`]: ../reference/patterns.html?highlight=range#range-patterns\n+/// [range patterns]: ../reference/patterns.html?highlight=range#range-patterns\n /// [`for`]: keyword.for.html\n mod in_keyword {}\n "}, {"sha": "fd9d61e99c2cd2d3b39f935c94cf5573422e3501", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -91,7 +91,7 @@ impl<T> Packet<T> {\n     //\n     // This can only be called at channel-creation time\n     pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n-        token.map(|token| {\n+        if let Some(token) = token {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             self.to_wake.store(unsafe { token.cast_to_usize() }, Ordering::SeqCst);\n@@ -118,7 +118,7 @@ impl<T> Packet<T> {\n             unsafe {\n                 *self.steals.get() = -1;\n             }\n-        });\n+        }\n \n         // When the shared packet is constructed, we grabbed this lock. The\n         // purpose of this lock is to ensure that abort_selection() doesn't"}, {"sha": "79123903e92a5ac2cdd01676076efdc151778aa0", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -343,8 +343,12 @@ impl<T> Packet<T> {\n         mem::drop(guard);\n \n         // only outside of the lock do we wake up the pending threads\n-        pending_sender1.map(|t| t.signal());\n-        pending_sender2.map(|t| t.signal());\n+        if let Some(token) = pending_sender1 {\n+            token.signal();\n+        }\n+        if let Some(token) = pending_sender2 {\n+            token.signal();\n+        }\n     }\n \n     // Prepares this shared packet for a channel clone, essentially just bumping\n@@ -410,7 +414,9 @@ impl<T> Packet<T> {\n         while let Some(token) = queue.dequeue() {\n             token.signal();\n         }\n-        waiter.map(|t| t.signal());\n+        if let Some(token) = waiter {\n+            token.signal();\n+        }\n     }\n }\n "}, {"sha": "ee621a8cb147309deb514880bb1cf5e3eb806b14", "filename": "src/test/ui/issues/issue-17252.stderr", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17252.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1,11 +1,22 @@\n-error[E0391]: cycle detected when const checking `FOO`\n-  --> $DIR/issue-17252.rs:1:20\n+error[E0391]: cycle detected when normalizing `FOO`\n+   |\n+note: ...which requires const-evaluating + checking `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n+   |\n+LL | const FOO: usize = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n    |\n LL | const FOO: usize = FOO;\n-   |                    ^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `FOO`...\n+  --> $DIR/issue-17252.rs:1:1\n    |\n-   = note: ...which again requires const checking `FOO`, completing the cycle\n-note: cycle used when const checking `main::{{constant}}#0`\n+LL | const FOO: usize = FOO;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires normalizing `FOO`, completing the cycle\n+note: cycle used when const-evaluating `main::{{constant}}#0`\n   --> $DIR/issue-17252.rs:4:18\n    |\n LL |     let _x: [u8; FOO]; // caused stack overflow prior to fix"}, {"sha": "b6c85b9e22749c9053cb5000a4d34efcc0744174", "filename": "src/test/ui/issues/issue-23302-1.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-1.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1,15 +1,26 @@\n-error[E0391]: cycle detected when const checking `X::A::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `X::A::{{constant}}#0`\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires const checking `X::A::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `X::A::{{constant}}#0`\n+note: ...which requires const-evaluating + checking `X::A::{{constant}}#0`...\n   --> $DIR/issue-23302-1.rs:4:9\n    |\n LL |     A = X::A as isize,\n    |         ^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `X::A::{{constant}}#0`...\n+  --> $DIR/issue-23302-1.rs:4:9\n+   |\n+LL |     A = X::A as isize,\n+   |         ^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `X::A as isize`...\n+   = note: ...which again requires const-evaluating + checking `X::A::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-23302-1.rs:3:1\n+   |\n+LL | enum X {\n+   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d014922fe2069a5c5838c8e7f5578fdaab635d39", "filename": "src/test/ui/issues/issue-23302-2.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-2.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1,15 +1,26 @@\n-error[E0391]: cycle detected when const checking `Y::A::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `Y::A::{{constant}}#0`\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires const checking `Y::A::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Y::A::{{constant}}#0`\n+note: ...which requires const-evaluating + checking `Y::A::{{constant}}#0`...\n   --> $DIR/issue-23302-2.rs:4:9\n    |\n LL |     A = Y::B as isize,\n    |         ^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `Y::A::{{constant}}#0`...\n+  --> $DIR/issue-23302-2.rs:4:9\n+   |\n+LL |     A = Y::B as isize,\n+   |         ^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `Y::B as isize`...\n+   = note: ...which again requires const-evaluating + checking `Y::A::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-23302-2.rs:3:1\n+   |\n+LL | enum Y {\n+   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b30b1214271a06354e0900c238c621e744a244c0", "filename": "src/test/ui/issues/issue-23302-3.stderr", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23302-3.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1,20 +1,38 @@\n-error[E0391]: cycle detected when const checking `A`\n-  --> $DIR/issue-23302-3.rs:1:16\n+error[E0391]: cycle detected when const-evaluating + checking `A`\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires const checking `B`...\n-  --> $DIR/issue-23302-3.rs:3:16\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-23302-3.rs:1:1\n    |\n-LL | const B: i32 = A;\n-   |                ^\n-   = note: ...which again requires const checking `A`, completing the cycle\n-note: cycle used when processing `A`\n+LL | const A: i32 = B;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `A`...\n   --> $DIR/issue-23302-3.rs:1:1\n    |\n LL | const A: i32 = B;\n    | ^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `B`...\n+note: ...which requires const-evaluating + checking `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `B`...\n+  --> $DIR/issue-23302-3.rs:3:1\n+   |\n+LL | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `A`...\n+   = note: ...which again requires const-evaluating + checking `A`, completing the cycle\n+   = note: cycle used when running analysis passes on this crate\n \n error: aborting due to previous error\n "}, {"sha": "7c2da9dce6e9da41cc45a1809c0d2efa07257910", "filename": "src/test/ui/issues/issue-36163.stderr", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36163.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -1,20 +1,48 @@\n-error[E0391]: cycle detected when const checking `Foo::B::{{constant}}#0`\n+error[E0391]: cycle detected when const-evaluating + checking `Foo::B::{{constant}}#0`\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n    |\n-note: ...which requires const checking `A`...\n-  --> $DIR/issue-36163.rs:1:18\n+note: ...which requires const-evaluating + checking `Foo::B::{{constant}}#0`...\n+  --> $DIR/issue-36163.rs:4:9\n    |\n-LL | const A: isize = Foo::B as isize;\n-   |                  ^^^^^^^^^^^^^^^\n-   = note: ...which again requires const checking `Foo::B::{{constant}}#0`, completing the cycle\n-note: cycle used when processing `Foo::B::{{constant}}#0`\n+LL |     B = A,\n+   |         ^\n+note: ...which requires const-evaluating `Foo::B::{{constant}}#0`...\n   --> $DIR/issue-36163.rs:4:9\n    |\n LL |     B = A,\n    |         ^\n+   = note: ...which requires normalizing `A`...\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating + checking `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const-evaluating `A`...\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | const A: isize = Foo::B as isize;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires normalizing `A`...\n+   = note: ...which again requires const-evaluating + checking `Foo::B::{{constant}}#0`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/issue-36163.rs:1:1\n+   |\n+LL | / const A: isize = Foo::B as isize;\n+LL | |\n+LL | | enum Foo {\n+LL | |     B = A,\n+LL | | }\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n \n error: aborting due to previous error\n "}, {"sha": "017654554be16086ee9ac3373b49673277e8a95b", "filename": "src/test/ui/issues/issue-69455.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for #69455: projection predicate was not satisfied.\n+// Compiler should indicate the correct location of the\n+// unsatisfied projection predicate\n+\n+pub trait Test<Rhs = Self> {\n+    type Output;\n+\n+    fn test(self, rhs: Rhs) -> Self::Output;\n+}\n+\n+impl Test<u32> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u32) -> u64 {\n+        self + (other as u64)\n+    }\n+}\n+\n+impl Test<u64> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u64) -> u64 {\n+        (self + other) as u64\n+    }\n+}\n+\n+fn main() {\n+    let xs: Vec<u64> = vec![1, 2, 3];\n+    println!(\"{}\", 23u64.test(xs.iter().sum())); //~ ERROR: type annotations needed [E0284]\n+}"}, {"sha": "4caa1aca9fd21535e7d8efebe6b74fb3698055f2", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40008dcb494a00571123b7d59115068a200ebe34/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=40008dcb494a00571123b7d59115068a200ebe34", "patch": "@@ -0,0 +1,17 @@\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:26\n+   |\n+LL |     type Output;\n+   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n+...\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n+   |                    ------^^^^-----------------\n+   |                    |     |\n+   |                    |     cannot infer type for type `u64`\n+   |                    this method call resolves to `<Self as Test<Rhs>>::Output`\n+   |\n+   = note: cannot satisfy `<u64 as Test<_>>::Output == _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}]}