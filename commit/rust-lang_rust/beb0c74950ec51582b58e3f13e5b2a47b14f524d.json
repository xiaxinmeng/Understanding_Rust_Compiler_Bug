{"sha": "beb0c74950ec51582b58e3f13e5b2a47b14f524d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYjBjNzQ5NTBlYzUxNTgyYjU4ZTNmMTNlNWIyYTQ3YjE0ZjUyNGQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-18T06:40:55Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-19T04:01:29Z"}, "message": "Combine all builtin early lints and use a separate walk for plugin lints. Add a -Z no-interleave-lints option to allow benchmarking lints", "tree": {"sha": "7024257787ed5afca55b626afdc80263e8ea07c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7024257787ed5afca55b626afdc80263e8ea07c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/beb0c74950ec51582b58e3f13e5b2a47b14f524d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/beb0c74950ec51582b58e3f13e5b2a47b14f524d", "html_url": "https://github.com/rust-lang/rust/commit/beb0c74950ec51582b58e3f13e5b2a47b14f524d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/beb0c74950ec51582b58e3f13e5b2a47b14f524d/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f001287c90e98d72296eb2a20e3cbe34b977f587", "url": "https://api.github.com/repos/rust-lang/rust/commits/f001287c90e98d72296eb2a20e3cbe34b977f587", "html_url": "https://github.com/rust-lang/rust/commit/f001287c90e98d72296eb2a20e3cbe34b977f587"}], "stats": {"total": 767, "additions": 551, "deletions": 216}, "files": [{"sha": "0d2dc8382024f9268e222cb05f8bc8fa4846a33d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -374,6 +374,10 @@ declare_lint! {\n pub struct HardwiredLints;\n \n impl LintPass for HardwiredLints {\n+    fn name(&self) -> &'static str {\n+        \"HardwiredLints\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n             ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,"}, {"sha": "e426858349368c6d253f4405d06fd7c4bb41c064", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 203, "deletions": 120, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -18,8 +18,8 @@ use self::TargetLint::*;\n \n use std::slice;\n use rustc_data_structures::sync::ReadGuard;\n-use lint::{EarlyLintPassObject, LateLintPassObject};\n-use lint::{Level, Lint, LintId, LintPass, LintBuffer};\n+use lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use lint::builtin::BuiltinLintDiagnostics;\n use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n@@ -28,6 +28,7 @@ use session::{config, early_error, Session};\n use ty::{self, TyCtxt, Ty};\n use ty::layout::{LayoutError, LayoutOf, TyLayout};\n use util::nodemap::FxHashMap;\n+use util::common::time;\n \n use std::default::Default as StdDefault;\n use syntax::ast;\n@@ -74,7 +75,6 @@ pub struct LintSession<'a, PassObject> {\n     passes: Option<Vec<PassObject>>,\n }\n \n-\n /// Lints that are buffered up early on in the `Session` before the\n /// `LintLevels` is calculated\n #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -175,18 +175,25 @@ impl LintStore {\n     pub fn register_early_pass(&mut self,\n                                sess: Option<&Session>,\n                                from_plugin: bool,\n+                               register_only: bool,\n                                pass: EarlyLintPassObject) {\n         self.push_pass(sess, from_plugin, &pass);\n-        self.early_passes.as_mut().unwrap().push(pass);\n+        if !register_only {\n+            self.early_passes.as_mut().unwrap().push(pass);\n+        }\n     }\n \n     pub fn register_pre_expansion_pass(\n         &mut self,\n         sess: Option<&Session>,\n+        from_plugin: bool,\n+        register_only: bool,\n         pass: EarlyLintPassObject,\n     ) {\n-        self.push_pass(sess, false, &pass);\n-        self.pre_expansion_passes.as_mut().unwrap().push(pass);\n+        self.push_pass(sess, from_plugin, &pass);\n+        if !register_only {\n+            self.pre_expansion_passes.as_mut().unwrap().push(pass);\n+        }\n     }\n \n     pub fn register_late_pass(&mut self,\n@@ -535,6 +542,11 @@ pub struct EarlyContext<'a> {\n     buffered: LintBuffer,\n }\n \n+pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n+    context: EarlyContext<'a>,\n+    pass: T,\n+}\n+\n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n@@ -560,8 +572,6 @@ pub trait LintContext<'tcx>: Sized {\n     fn lints(&self) -> &LintStore;\n     fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject>;\n     fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject>;\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n     fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n                                            lint: &'static Lint,\n@@ -624,45 +634,70 @@ pub trait LintContext<'tcx>: Sized {\n     fn lint(&self, lint: &'static Lint, msg: &str) {\n         self.lookup_and_emit(lint, None as Option<Span>, msg);\n     }\n-\n-    /// Merge the lints specified by any lint attributes into the\n-    /// current lint context, call the provided function, then reset the\n-    /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n-                          attrs: &'tcx [ast::Attribute],\n-                          f: F)\n-        where F: FnOnce(&mut Self);\n }\n \n \n impl<'a> EarlyContext<'a> {\n     fn new(\n         sess: &'a Session,\n         krate: &'a ast::Crate,\n-        passes: Option<Vec<EarlyLintPassObject>>,\n         buffered: LintBuffer,\n     ) -> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n             lint_sess: LintSession {\n                 lints: sess.lint_store.borrow(),\n-                passes,\n+                passes: None,\n             },\n             builder: LintLevelSets::builder(sess),\n             buffered,\n         }\n     }\n+}\n \n+macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n+impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     fn check_id(&mut self, id: ast::NodeId) {\n-        for early_lint in self.buffered.take(id) {\n-            self.lookup_and_emit_with_diagnostics(early_lint.lint_id.lint,\n-                                                  Some(early_lint.span.clone()),\n-                                                  &early_lint.msg,\n-                                                  early_lint.diagnostic);\n+        for early_lint in self.context.buffered.take(id) {\n+            self.context.lookup_and_emit_with_diagnostics(\n+                early_lint.lint_id.lint,\n+                Some(early_lint.span.clone()),\n+                &early_lint.msg,\n+                early_lint.diagnostic\n+            );\n         }\n     }\n+\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &'a [ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let push = self.context.builder.push(attrs);\n+        self.check_id(id);\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.context.builder.pop(push);\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: enter_attrs({:?})\", attrs);\n+        run_early_pass!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n+        run_early_pass!(self, exit_lint_attrs, attrs);\n+    }\n }\n \n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n@@ -685,16 +720,6 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n         &mut self.lint_sess\n     }\n \n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        run_lints!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        run_lints!(self, exit_lint_attrs, attrs);\n-    }\n-\n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n@@ -706,20 +731,6 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n             None => self.tcx.struct_lint_node(lint, id, msg),\n         }\n     }\n-\n-    fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n-                          attrs: &'tcx [ast::Attribute],\n-                          f: F)\n-        where F: FnOnce(&mut Self)\n-    {\n-        let prev = self.last_ast_node_with_lint_attrs;\n-        self.last_ast_node_with_lint_attrs = id;\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-        self.last_ast_node_with_lint_attrs = prev;\n-    }\n }\n \n impl<'a> LintContext<'a> for EarlyContext<'a> {\n@@ -742,40 +753,43 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n         &mut self.lint_sess\n     }\n \n-    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: enter_attrs({:?})\", attrs);\n-        run_lints!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: exit_attrs({:?})\", attrs);\n-        run_lints!(self, exit_lint_attrs, attrs);\n-    }\n-\n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n                                   msg: &str)\n                                   -> DiagnosticBuilder<'_> {\n         self.builder.struct_lint(lint, span.map(|s| s.into()), msg)\n     }\n+}\n \n+impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n                           id: ast::NodeId,\n-                          attrs: &'a [ast::Attribute],\n+                          attrs: &'tcx [ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let push = self.builder.push(attrs);\n-        self.check_id(id);\n+        let prev = self.last_ast_node_with_lint_attrs;\n+        self.last_ast_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n         f(self);\n         self.exit_attrs(attrs);\n-        self.builder.pop(push);\n+        self.last_ast_node_with_lint_attrs = prev;\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        run_lints!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        run_lints!(self, exit_lint_attrs, attrs);\n     }\n-}\n \n-impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     fn with_param_env<F>(&mut self, id: ast::NodeId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n@@ -1008,26 +1022,26 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n+impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n     fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_lints!(cx, check_item, it);\n+            run_early_pass!(cx, check_item, it);\n             ast_visit::walk_item(cx, it);\n-            run_lints!(cx, check_item_post, it);\n+            run_early_pass!(cx, check_item_post, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n         self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_lints!(cx, check_foreign_item, it);\n+            run_early_pass!(cx, check_foreign_item, it);\n             ast_visit::walk_foreign_item(cx, it);\n-            run_lints!(cx, check_foreign_item_post, it);\n+            run_early_pass!(cx, check_foreign_item_post, it);\n         })\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         let mut visit_subpats = true;\n-        run_lints!(self, check_pat, p, &mut visit_subpats);\n+        run_early_pass!(self, check_pat, p, &mut visit_subpats);\n         self.check_id(p.id);\n         if visit_subpats {\n             ast_visit::walk_pat(self, p);\n@@ -1036,23 +1050,23 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n-            run_lints!(cx, check_expr, e);\n+            run_early_pass!(cx, check_expr, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n \n     fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n-        run_lints!(self, check_stmt, s);\n+        run_early_pass!(self, check_stmt, s);\n         self.check_id(s.id);\n         ast_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, decl: &'a ast::FnDecl,\n                 span: Span, id: ast::NodeId) {\n-        run_lints!(self, check_fn, fk, decl, span, id);\n+        run_early_pass!(self, check_fn, fk, decl, span, id);\n         self.check_id(id);\n         ast_visit::walk_fn(self, fk, decl, span);\n-        run_lints!(self, check_fn_post, fk, decl, span, id);\n+        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -1061,120 +1075,120 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n                         g: &'a ast::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n-        run_lints!(self, check_struct_def, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n         self.check_id(s.id());\n         ast_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n         self.with_lint_attrs(s.id, &s.attrs, |cx| {\n-            run_lints!(cx, check_struct_field, s);\n+            run_early_pass!(cx, check_struct_field, s);\n             ast_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n         self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n-            run_lints!(cx, check_variant, v, g);\n+            run_early_pass!(cx, check_variant, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n-            run_lints!(cx, check_variant_post, v, g);\n+            run_early_pass!(cx, check_variant_post, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        run_lints!(self, check_ty, t);\n+        run_early_pass!(self, check_ty, t);\n         self.check_id(t.id);\n         ast_visit::walk_ty(self, t);\n     }\n \n     fn visit_ident(&mut self, ident: ast::Ident) {\n-        run_lints!(self, check_ident, ident);\n+        run_early_pass!(self, check_ident, ident);\n     }\n \n     fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_lints!(self, check_mod, m, s, n);\n+        run_early_pass!(self, check_mod, m, s, n);\n         self.check_id(n);\n         ast_visit::walk_mod(self, m);\n-        run_lints!(self, check_mod_post, m, s, n);\n+        run_early_pass!(self, check_mod_post, m, s, n);\n     }\n \n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n-            run_lints!(cx, check_local, l);\n+            run_early_pass!(cx, check_local, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'a ast::Block) {\n-        run_lints!(self, check_block, b);\n+        run_early_pass!(self, check_block, b);\n         self.check_id(b.id);\n         ast_visit::walk_block(self, b);\n-        run_lints!(self, check_block_post, b);\n+        run_early_pass!(self, check_block_post, b);\n     }\n \n     fn visit_arm(&mut self, a: &'a ast::Arm) {\n-        run_lints!(self, check_arm, a);\n+        run_early_pass!(self, check_arm, a);\n         ast_visit::walk_arm(self, a);\n     }\n \n     fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n-        run_lints!(self, check_expr_post, e);\n+        run_early_pass!(self, check_expr_post, e);\n     }\n \n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n-        run_lints!(self, check_generic_param, param);\n+        run_early_pass!(self, check_generic_param, param);\n         ast_visit::walk_generic_param(self, param);\n     }\n \n     fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        run_lints!(self, check_generics, g);\n+        run_early_pass!(self, check_generics, g);\n         ast_visit::walk_generics(self, g);\n     }\n \n     fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n-        run_lints!(self, check_where_predicate, p);\n+        run_early_pass!(self, check_where_predicate, p);\n         ast_visit::walk_where_predicate(self, p);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n-        run_lints!(self, check_poly_trait_ref, t, m);\n+        run_early_pass!(self, check_poly_trait_ref, t, m);\n         ast_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n         self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n-            run_lints!(cx, check_trait_item, trait_item);\n+            run_early_pass!(cx, check_trait_item, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n-            run_lints!(cx, check_trait_item_post, trait_item);\n+            run_early_pass!(cx, check_trait_item_post, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n         self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n-            run_lints!(cx, check_impl_item, impl_item);\n+            run_early_pass!(cx, check_impl_item, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);\n-            run_lints!(cx, check_impl_item_post, impl_item);\n+            run_early_pass!(cx, check_impl_item_post, impl_item);\n         });\n     }\n \n     fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n-        run_lints!(self, check_lifetime, lt);\n+        run_early_pass!(self, check_lifetime, lt);\n         self.check_id(lt.id);\n     }\n \n     fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n-        run_lints!(self, check_path, p, id);\n+        run_early_pass!(self, check_path, p, id);\n         self.check_id(id);\n         ast_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n-        run_lints!(self, check_attribute, attr);\n+        run_early_pass!(self, check_attribute, attr);\n     }\n \n     fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        run_lints!(self, check_mac_def, mac, id);\n+        run_early_pass!(self, check_mac_def, mac, id);\n         self.check_id(id);\n     }\n \n@@ -1186,7 +1200,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         // want to get #53686 fixed quickly. -nmatsakis\n         ast_visit::walk_path(self, &mac.node.path);\n \n-        run_lints!(self, check_mac, mac);\n+        run_early_pass!(self, check_mac, mac);\n     }\n }\n \n@@ -1231,43 +1245,112 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.sess.lint_store.borrow_mut().late_passes = passes;\n }\n \n-pub fn check_ast_crate(\n+struct EarlyLintPassObjects<'a> {\n+    lints: &'a mut [EarlyLintPassObject],\n+}\n+\n+impl LintPass for EarlyLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+\n+    fn get_lints(&self) -> LintArray {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_early_lint_pass_impl_methods {\n+    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! early_lint_pass_impl {\n+    ([], [$($methods:tt)*]) => (\n+        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n+            expand_early_lint_pass_impl_methods!([$($methods)*]);\n+        }\n+    )\n+}\n+\n+early_lint_methods!(early_lint_pass_impl, []);\n+\n+\n+fn early_lint_crate<T: EarlyLintPass>(\n+    sess: &Session,\n+    krate: &ast::Crate,\n+    pass: T,\n+    buffered: LintBuffer,\n+) -> LintBuffer {\n+    let mut cx = EarlyContextAndPass {\n+        context: EarlyContext::new(sess, krate, buffered),\n+        pass,\n+    };\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_early_pass!(cx, check_crate, krate);\n+\n+        ast_visit::walk_crate(cx, krate);\n+\n+        run_early_pass!(cx, check_crate_post, krate);\n+    });\n+    cx.context.buffered\n+}\n+\n+pub fn check_ast_crate<T: EarlyLintPass>(\n     sess: &Session,\n     krate: &ast::Crate,\n     pre_expansion: bool,\n+    builtin_lints: T,\n ) {\n-    let (passes, buffered) = if pre_expansion {\n+    let (mut passes, mut buffered) = if pre_expansion {\n         (\n-            sess.lint_store.borrow_mut().pre_expansion_passes.take(),\n+            sess.lint_store.borrow_mut().pre_expansion_passes.take().unwrap(),\n             LintBuffer::default(),\n         )\n     } else {\n         (\n-            sess.lint_store.borrow_mut().early_passes.take(),\n+            sess.lint_store.borrow_mut().early_passes.take().unwrap(),\n             sess.buffered_lints.borrow_mut().take().unwrap(),\n         )\n     };\n-    let (passes, buffered) = {\n-        let mut cx = EarlyContext::new(sess, krate, passes, buffered);\n \n-        // Visit the whole crate.\n-        cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n-            // since the root module isn't visited as an item (because it isn't an\n-            // item), warn for it here.\n-            run_lints!(cx, check_crate, krate);\n+    if !sess.opts.debugging_opts.no_interleave_lints {\n+        buffered = early_lint_crate(sess, krate, builtin_lints, buffered);\n \n-            ast_visit::walk_crate(cx, krate);\n-\n-            run_lints!(cx, check_crate_post, krate);\n-        });\n-        (cx.lint_sess.passes, cx.buffered)\n-    };\n+        if !passes.is_empty() {\n+            buffered = early_lint_crate(\n+                sess,\n+                krate,\n+                EarlyLintPassObjects { lints: &mut passes[..] },\n+                buffered,\n+            );\n+        }\n+    } else {\n+        for pass in &mut passes {\n+            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n+                early_lint_crate(\n+                    sess,\n+                    krate,\n+                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                    buffered,\n+                )\n+            });\n+        }\n+    }\n \n     // Put the lint store levels and passes back in the session.\n     if pre_expansion {\n-        sess.lint_store.borrow_mut().pre_expansion_passes = passes;\n+        sess.lint_store.borrow_mut().pre_expansion_passes = Some(passes);\n     } else {\n-        sess.lint_store.borrow_mut().early_passes = passes;\n+        sess.lint_store.borrow_mut().early_passes = Some(passes);\n     }\n \n     // All of the buffered lints should have been emitted at this point."}, {"sha": "0f20081270f46aed87e792018a0b60a1a02105e1", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 139, "deletions": 52, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -36,7 +36,6 @@ use syntax::source_map::{MultiSpan, ExpnFormat};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n use syntax::symbol::Symbol;\n-use syntax::visit as ast_visit;\n use syntax_pos::Span;\n use ty::TyCtxt;\n use ty::query::Providers;\n@@ -162,6 +161,8 @@ macro_rules! lint_array {\n pub type LintArray = Vec<&'static Lint>;\n \n pub trait LintPass {\n+    fn name(&self) -> &'static str;\n+\n     /// Get descriptions of the lints this `LintPass` object can emit.\n     ///\n     /// N.B., there is no enforcement that the object only emits lints it registered.\n@@ -308,6 +309,10 @@ macro_rules! declare_combined_late_lint_pass {\n         }\n \n         impl LintPass for $name {\n+            fn name(&self) -> &'static str {\n+                panic!()\n+            }\n+\n             fn get_lints(&self) -> LintArray {\n                 let mut lints = Vec::new();\n                 $(lints.extend_from_slice(&self.$passes.get_lints());)*\n@@ -317,57 +322,139 @@ macro_rules! declare_combined_late_lint_pass {\n     )\n }\n \n-pub trait EarlyLintPass: LintPass {\n-    fn check_ident(&mut self, _: &EarlyContext<'_>, _: ast::Ident) { }\n-    fn check_crate(&mut self, _: &EarlyContext<'_>, _: &ast::Crate) { }\n-    fn check_crate_post(&mut self, _: &EarlyContext<'_>, _: &ast::Crate) { }\n-    fn check_mod(&mut self, _: &EarlyContext<'_>, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_mod_post(&mut self, _: &EarlyContext<'_>, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &EarlyContext<'_>, _: &ast::ForeignItem) { }\n-    fn check_foreign_item_post(&mut self, _: &EarlyContext<'_>, _: &ast::ForeignItem) { }\n-    fn check_item(&mut self, _: &EarlyContext<'_>, _: &ast::Item) { }\n-    fn check_item_post(&mut self, _: &EarlyContext<'_>, _: &ast::Item) { }\n-    fn check_local(&mut self, _: &EarlyContext<'_>, _: &ast::Local) { }\n-    fn check_block(&mut self, _: &EarlyContext<'_>, _: &ast::Block) { }\n-    fn check_block_post(&mut self, _: &EarlyContext<'_>, _: &ast::Block) { }\n-    fn check_stmt(&mut self, _: &EarlyContext<'_>, _: &ast::Stmt) { }\n-    fn check_arm(&mut self, _: &EarlyContext<'_>, _: &ast::Arm) { }\n-    fn check_pat(&mut self, _: &EarlyContext<'_>, _: &ast::Pat, _: &mut bool) { }\n-    fn check_expr(&mut self, _: &EarlyContext<'_>, _: &ast::Expr) { }\n-    fn check_expr_post(&mut self, _: &EarlyContext<'_>, _: &ast::Expr) { }\n-    fn check_ty(&mut self, _: &EarlyContext<'_>, _: &ast::Ty) { }\n-    fn check_generic_param(&mut self, _: &EarlyContext<'_>, _: &ast::GenericParam) { }\n-    fn check_generics(&mut self, _: &EarlyContext<'_>, _: &ast::Generics) { }\n-    fn check_where_predicate(&mut self, _: &EarlyContext<'_>, _: &ast::WherePredicate) { }\n-    fn check_poly_trait_ref(&mut self, _: &EarlyContext<'_>, _: &ast::PolyTraitRef,\n-                            _: &ast::TraitBoundModifier) { }\n-    fn check_fn(&mut self, _: &EarlyContext<'_>,\n-        _: ast_visit::FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n-    fn check_fn_post(&mut self, _: &EarlyContext<'_>,\n-        _: ast_visit::FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &EarlyContext<'_>, _: &ast::TraitItem) { }\n-    fn check_trait_item_post(&mut self, _: &EarlyContext<'_>, _: &ast::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &EarlyContext<'_>, _: &ast::ImplItem) { }\n-    fn check_impl_item_post(&mut self, _: &EarlyContext<'_>, _: &ast::ImplItem) { }\n-    fn check_struct_def(&mut self, _: &EarlyContext<'_>,\n-        _: &ast::VariantData, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n-    fn check_struct_def_post(&mut self, _: &EarlyContext<'_>,\n-        _: &ast::VariantData, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &EarlyContext<'_>, _: &ast::StructField) { }\n-    fn check_variant(&mut self, _: &EarlyContext<'_>, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_variant_post(&mut self, _: &EarlyContext<'_>, _: &ast::Variant, _: &ast::Generics) { }\n-    fn check_lifetime(&mut self, _: &EarlyContext<'_>, _: &ast::Lifetime) { }\n-    fn check_path(&mut self, _: &EarlyContext<'_>, _: &ast::Path, _: ast::NodeId) { }\n-    fn check_attribute(&mut self, _: &EarlyContext<'_>, _: &ast::Attribute) { }\n-    fn check_mac_def(&mut self, _: &EarlyContext<'_>, _: &ast::MacroDef, _id: ast::NodeId) { }\n-    fn check_mac(&mut self, _: &EarlyContext<'_>, _: &ast::Mac) { }\n-\n-    /// Called when entering a syntax node that can have lint attributes such\n-    /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &EarlyContext<'_>, _: &[ast::Attribute]) { }\n-\n-    /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &EarlyContext<'_>, _: &[ast::Attribute]) { }\n+#[macro_export]\n+macro_rules! early_lint_methods {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            fn check_ident(a: ast::Ident);\n+            fn check_crate(a: &ast::Crate);\n+            fn check_crate_post(a: &ast::Crate);\n+            fn check_mod(a: &ast::Mod, b: Span, c: ast::NodeId);\n+            fn check_mod_post(a: &ast::Mod, b: Span, c: ast::NodeId);\n+            fn check_foreign_item(a: &ast::ForeignItem);\n+            fn check_foreign_item_post(a: &ast::ForeignItem);\n+            fn check_item(a: &ast::Item);\n+            fn check_item_post(a: &ast::Item);\n+            fn check_local(a: &ast::Local);\n+            fn check_block(a: &ast::Block);\n+            fn check_block_post(a: &ast::Block);\n+            fn check_stmt(a: &ast::Stmt);\n+            fn check_arm(a: &ast::Arm);\n+            fn check_pat(a: &ast::Pat, b: &mut bool); // FIXME: &mut bool looks just broken\n+            fn check_expr(a: &ast::Expr);\n+            fn check_expr_post(a: &ast::Expr);\n+            fn check_ty(a: &ast::Ty);\n+            fn check_generic_param(a: &ast::GenericParam);\n+            fn check_generics(a: &ast::Generics);\n+            fn check_where_predicate(a: &ast::WherePredicate);\n+            fn check_poly_trait_ref(a: &ast::PolyTraitRef,\n+                                    b: &ast::TraitBoundModifier);\n+            fn check_fn(a: syntax::visit::FnKind<'_>, b: &ast::FnDecl, c: Span, d_: ast::NodeId);\n+            fn check_fn_post(\n+                a: syntax::visit::FnKind<'_>,\n+                b: &ast::FnDecl,\n+                c: Span,\n+                d: ast::NodeId\n+            );\n+            fn check_trait_item(a: &ast::TraitItem);\n+            fn check_trait_item_post(a: &ast::TraitItem);\n+            fn check_impl_item(a: &ast::ImplItem);\n+            fn check_impl_item_post(a: &ast::ImplItem);\n+            fn check_struct_def(\n+                a: &ast::VariantData,\n+                b: ast::Ident,\n+                c: &ast::Generics,\n+                d: ast::NodeId\n+            );\n+            fn check_struct_def_post(\n+                a: &ast::VariantData,\n+                b: ast::Ident,\n+                c: &ast::Generics,\n+                d: ast::NodeId\n+            );\n+            fn check_struct_field(a: &ast::StructField);\n+            fn check_variant(a: &ast::Variant, b: &ast::Generics);\n+            fn check_variant_post(a: &ast::Variant, b: &ast::Generics);\n+            fn check_lifetime(a: &ast::Lifetime);\n+            fn check_path(a: &ast::Path, b: ast::NodeId);\n+            fn check_attribute(a: &ast::Attribute);\n+            fn check_mac_def(a: &ast::MacroDef, b: ast::NodeId);\n+            fn check_mac(a: &ast::Mac);\n+\n+            /// Called when entering a syntax node that can have lint attributes such\n+            /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n+            fn enter_lint_attrs(a: &[ast::Attribute]);\n+\n+            /// Counterpart to `enter_lint_attrs`.\n+            fn exit_lint_attrs(a: &[ast::Attribute]);\n+        ]);\n+    )\n+}\n+\n+macro_rules! expand_early_lint_pass_methods {\n+    ($context:ty, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(#[inline(always)] fn $name(&mut self, _: $context, $(_: $arg),*) {})*\n+    )\n+}\n+\n+macro_rules! declare_early_lint_pass {\n+    ([], [$($methods:tt)*]) => (\n+        pub trait EarlyLintPass: LintPass {\n+            expand_early_lint_pass_methods!(&EarlyContext<'_>, [$($methods)*]);\n+        }\n+    )\n+}\n+\n+early_lint_methods!(declare_early_lint_pass, []);\n+\n+#[macro_export]\n+macro_rules! expand_combined_early_lint_pass_method {\n+    ([$($passes:ident),*], $self: ident, $name: ident, $params:tt) => ({\n+        $($self.$passes.$name $params;)*\n+    })\n+}\n+\n+#[macro_export]\n+macro_rules! expand_combined_early_lint_pass_methods {\n+    ($passes:tt, [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+            expand_combined_early_lint_pass_method!($passes, self, $name, (context, $($param),*));\n+        })*\n+    )\n+}\n+\n+#[macro_export]\n+macro_rules! declare_combined_early_lint_pass {\n+    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], $methods:tt) => (\n+        #[allow(non_snake_case)]\n+        $v struct $name {\n+            $($passes: $passes,)*\n+        }\n+\n+        impl $name {\n+            $v fn new() -> Self {\n+                Self {\n+                    $($passes: $constructor,)*\n+                }\n+            }\n+        }\n+\n+        impl EarlyLintPass for $name {\n+            expand_combined_early_lint_pass_methods!([$($passes),*], $methods);\n+        }\n+\n+        impl LintPass for $name {\n+            fn name(&self) -> &'static str {\n+                panic!()\n+            }\n+\n+            fn get_lints(&self) -> LintArray {\n+                let mut lints = Vec::new();\n+                $(lints.extend_from_slice(&self.$passes.get_lints());)*\n+                lints\n+            }\n+        }\n+    )\n }\n \n /// A lint pass boxed up as a trait object."}, {"sha": "ffd6525e6e70de8c003217ebcd9545382650cec5", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -1364,6 +1364,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n     no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n         \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n+    no_interleave_lints: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't interleave execution of lints; allows benchmarking individual lints\"),\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n     self_profile: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "495df73e5e9c9aa53e46787cb99b8c076442ce72", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -898,7 +898,7 @@ where\n     sess.track_errors(|| {\n         let mut ls = sess.lint_store.borrow_mut();\n         for pass in early_lint_passes {\n-            ls.register_early_pass(Some(sess), true, pass);\n+            ls.register_early_pass(Some(sess), true, false, pass);\n         }\n         for pass in late_lint_passes {\n             ls.register_late_pass(Some(sess), true, pass);\n@@ -919,7 +919,11 @@ where\n     }\n \n     time(sess, \"pre ast expansion lint checks\", || {\n-        lint::check_ast_crate(sess, &krate, true)\n+        lint::check_ast_crate(\n+            sess,\n+            &krate,\n+            true,\n+            rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n     });\n \n     let mut resolver = Resolver::new(\n@@ -1131,7 +1135,7 @@ where\n     });\n \n     time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(sess, &krate, false)\n+        lint::check_ast_crate(sess, &krate, false, rustc_lint::BuiltinCombinedEarlyLintPass::new())\n     });\n \n     // Discard hygiene data, which isn't required after lowering to HIR."}, {"sha": "7b48ab459748d6bfbc0d26ad13fc4c55da6e6d75", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -60,6 +60,10 @@ declare_lint! {\n pub struct WhileTrue;\n \n impl LintPass for WhileTrue {\n+    fn name(&self) -> &'static str {\n+        \"WhileTrue\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(WHILE_TRUE)\n     }\n@@ -109,6 +113,10 @@ impl BoxPointers {\n }\n \n impl LintPass for BoxPointers {\n+    fn name(&self) -> &'static str {\n+        \"BoxPointers\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_POINTERS)\n     }\n@@ -158,6 +166,10 @@ declare_lint! {\n pub struct NonShorthandFieldPatterns;\n \n impl LintPass for NonShorthandFieldPatterns {\n+    fn name(&self) -> &'static str {\n+        \"NonShorthandFieldPatterns\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n     }\n@@ -211,6 +223,10 @@ declare_lint! {\n pub struct UnsafeCode;\n \n impl LintPass for UnsafeCode {\n+    fn name(&self) -> &'static str {\n+        \"UnsafeCode\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSAFE_CODE)\n     }\n@@ -373,6 +389,10 @@ impl MissingDoc {\n }\n \n impl LintPass for MissingDoc {\n+    fn name(&self) -> &'static str {\n+        \"MissingDoc\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_DOCS)\n     }\n@@ -519,6 +539,10 @@ declare_lint! {\n pub struct MissingCopyImplementations;\n \n impl LintPass for MissingCopyImplementations {\n+    fn name(&self) -> &'static str {\n+        \"MissingCopyImplementations\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n     }\n@@ -586,6 +610,10 @@ impl MissingDebugImplementations {\n }\n \n impl LintPass for MissingDebugImplementations {\n+    fn name(&self) -> &'static str {\n+        \"MissingDebugImplementations\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n     }\n@@ -643,6 +671,10 @@ declare_lint! {\n pub struct AnonymousParameters;\n \n impl LintPass for AnonymousParameters {\n+    fn name(&self) -> &'static str {\n+        \"AnonymousParameters\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ANONYMOUS_PARAMETERS)\n     }\n@@ -707,6 +739,10 @@ impl DeprecatedAttr {\n }\n \n impl LintPass for DeprecatedAttr {\n+    fn name(&self) -> &'static str {\n+        \"DeprecatedAttr\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!()\n     }\n@@ -747,6 +783,10 @@ declare_lint! {\n pub struct UnusedDocComment;\n \n impl LintPass for UnusedDocComment {\n+    fn name(&self) -> &'static str {\n+        \"UnusedDocComment\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array![UNUSED_DOC_COMMENTS]\n     }\n@@ -787,6 +827,10 @@ declare_lint! {\n pub struct PluginAsLibrary;\n \n impl LintPass for PluginAsLibrary {\n+    fn name(&self) -> &'static str {\n+        \"PluginAsLibrary\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array![PLUGIN_AS_LIBRARY]\n     }\n@@ -839,6 +883,10 @@ declare_lint! {\n pub struct InvalidNoMangleItems;\n \n impl LintPass for InvalidNoMangleItems {\n+    fn name(&self) -> &'static str {\n+        \"InvalidNoMangleItems\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NO_MANGLE_CONST_ITEMS,\n                     NO_MANGLE_GENERIC_ITEMS)\n@@ -910,6 +958,10 @@ declare_lint! {\n }\n \n impl LintPass for MutableTransmutes {\n+    fn name(&self) -> &'static str {\n+        \"MutableTransmutes\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(MUTABLE_TRANSMUTES)\n     }\n@@ -970,6 +1022,10 @@ declare_lint! {\n }\n \n impl LintPass for UnstableFeatures {\n+    fn name(&self) -> &'static str {\n+        \"UnstableFeatures\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n@@ -997,6 +1053,10 @@ declare_lint! {\n }\n \n impl LintPass for UnionsWithDropFields {\n+    fn name(&self) -> &'static str {\n+        \"UnionsWithDropFields\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNIONS_WITH_DROP_FIELDS)\n     }\n@@ -1029,6 +1089,10 @@ declare_lint! {\n }\n \n impl LintPass for UnreachablePub {\n+    fn name(&self) -> &'static str {\n+        \"UnreachablePub\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNREACHABLE_PUB)\n     }\n@@ -1099,6 +1163,10 @@ declare_lint! {\n }\n \n impl LintPass for TypeAliasBounds {\n+    fn name(&self) -> &'static str {\n+        \"TypeAliasBounds\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TYPE_ALIAS_BOUNDS)\n     }\n@@ -1203,6 +1271,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n pub struct UnusedBrokenConst;\n \n impl LintPass for UnusedBrokenConst {\n+    fn name(&self) -> &'static str {\n+        \"UnusedBrokenConst\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!()\n     }\n@@ -1249,6 +1321,10 @@ declare_lint! {\n }\n \n impl LintPass for TrivialConstraints {\n+    fn name(&self) -> &'static str {\n+        \"TrivialConstraints\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(TRIVIAL_BOUNDS)\n     }\n@@ -1303,6 +1379,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n pub struct SoftLints;\n \n impl LintPass for SoftLints {\n+    fn name(&self) -> &'static str {\n+        \"SoftLints\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n             WHILE_TRUE,\n@@ -1337,6 +1417,10 @@ declare_lint! {\n pub struct EllipsisInclusiveRangePatterns;\n \n impl LintPass for EllipsisInclusiveRangePatterns {\n+    fn name(&self) -> &'static str {\n+        \"EllipsisInclusiveRangePatterns\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS)\n     }\n@@ -1411,6 +1495,10 @@ impl UnnameableTestItems {\n }\n \n impl LintPass for UnnameableTestItems {\n+    fn name(&self) -> &'static str {\n+        \"UnnameableTestItems\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNNAMEABLE_TEST_ITEMS)\n     }\n@@ -1454,6 +1542,10 @@ declare_lint! {\n pub struct KeywordIdents;\n \n impl LintPass for KeywordIdents {\n+    fn name(&self) -> &'static str {\n+        \"KeywordIdents\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(KEYWORD_IDENTS)\n     }\n@@ -1559,6 +1651,10 @@ impl EarlyLintPass for KeywordIdents {\n pub struct ExplicitOutlivesRequirements;\n \n impl LintPass for ExplicitOutlivesRequirements {\n+    fn name(&self) -> &'static str {\n+        \"ExplicitOutlivesRequirements\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array![EXPLICIT_OUTLIVES_REQUIREMENTS]\n     }"}, {"sha": "fedc0410f2402c5c628ab5e2c3adb53adc07cbbe", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -39,7 +39,7 @@ mod types;\n mod unused;\n \n use rustc::lint;\n-use rustc::lint::{LateContext, LateLintPass, LintPass, LintArray};\n+use rustc::lint::{EarlyContext, LateContext, LateLintPass, EarlyLintPass, LintPass, LintArray};\n use rustc::lint::builtin::{\n     BARE_TRAIT_OBJECTS,\n     ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n@@ -71,57 +71,68 @@ use unused::*;\n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n \n+macro_rules! pre_expansion_lint_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            KeywordIdents: KeywordIdents,\n+        ]);\n+    )\n+}\n+\n+macro_rules! early_lint_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            UnusedParens: UnusedParens,\n+            UnusedImportBraces: UnusedImportBraces,\n+            UnsafeCode: UnsafeCode,\n+            AnonymousParameters: AnonymousParameters,\n+            UnusedDocComment: UnusedDocComment,\n+            EllipsisInclusiveRangePatterns: EllipsisInclusiveRangePatterns,\n+            NonCamelCaseTypes: NonCamelCaseTypes,\n+            DeprecatedAttr: DeprecatedAttr::new(),\n+        ]);\n+    )\n+}\n+\n+macro_rules! declare_combined_early_pass {\n+    ([$name:ident], $passes:tt) => (\n+        early_lint_methods!(declare_combined_early_lint_pass, [pub $name, $passes]);\n+    )\n+}\n+\n+pre_expansion_lint_passes!(declare_combined_early_pass, [BuiltinCombinedPreExpansionLintPass]);\n+early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n-    macro_rules! add_early_builtin {\n-        ($sess:ident, $($name:ident),*,) => (\n-            {$(\n-                store.register_early_pass($sess, false, box $name);\n-            )*}\n-        )\n-    }\n-\n-    macro_rules! add_pre_expansion_builtin {\n-        ($sess:ident, $($name:ident),*,) => (\n-            {$(\n-                store.register_pre_expansion_pass($sess, box $name);\n-            )*}\n-        )\n-    }\n-\n-    macro_rules! add_early_builtin_with_new {\n-        ($sess:ident, $($name:ident),*,) => (\n-            {$(\n-                store.register_early_pass($sess, false, box $name::new());\n-            )*}\n-        )\n-    }\n-\n     macro_rules! add_lint_group {\n         ($sess:ident, $name:expr, $($lint:ident),*) => (\n             store.register_group($sess, false, $name, None, vec![$(LintId::of($lint)),*]);\n         )\n     }\n \n-    add_pre_expansion_builtin!(sess,\n-        KeywordIdents,\n-    );\n-\n-    add_early_builtin!(sess,\n-                       UnusedParens,\n-                       UnusedImportBraces,\n-                       UnsafeCode,\n-                       AnonymousParameters,\n-                       UnusedDocComment,\n-                       EllipsisInclusiveRangePatterns,\n-                       NonCamelCaseTypes,\n-                       );\n+    macro_rules! register_passes {\n+        ([$method:ident], [$($passes:ident: $constructor:expr,)*]) => (\n+            $(\n+                store.$method(sess, false, false, box $constructor);\n+            )*\n+        )\n+    }\n \n-    add_early_builtin_with_new!(sess,\n-                                DeprecatedAttr,\n-                                );\n+    if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n+        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass]);\n+        early_lint_passes!(register_passes, [register_early_pass]);\n+    } else {\n+        store.register_pre_expansion_pass(\n+            sess,\n+            false,\n+            true,\n+            box BuiltinCombinedPreExpansionLintPass::new()\n+        );\n+        store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n+    }\n \n     late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n         HardwiredLints: HardwiredLints,"}, {"sha": "256d28a39794e964a085a126b42ab43ad8d72524", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -105,6 +105,10 @@ impl NonCamelCaseTypes {\n }\n \n impl LintPass for NonCamelCaseTypes {\n+    fn name(&self) -> &'static str {\n+        \"NonCamelCaseTypes\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_CAMEL_CASE_TYPES)\n     }\n@@ -235,6 +239,10 @@ impl NonSnakeCase {\n }\n \n impl LintPass for NonSnakeCase {\n+    fn name(&self) -> &'static str {\n+        \"NonSnakeCase\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_SNAKE_CASE)\n     }\n@@ -381,6 +389,10 @@ impl NonUpperCaseGlobals {\n }\n \n impl LintPass for NonUpperCaseGlobals {\n+    fn name(&self) -> &'static str {\n+        \"NonUpperCaseGlobals\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NON_UPPER_CASE_GLOBALS)\n     }"}, {"sha": "aa6f396145473d225a7733df67f1e63f47ec7aa9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -53,6 +53,10 @@ impl TypeLimits {\n }\n \n impl LintPass for TypeLimits {\n+    fn name(&self) -> &'static str {\n+        \"TypeLimits\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_COMPARISONS,\n                     OVERFLOWING_LITERALS)\n@@ -783,6 +787,10 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n pub struct ImproperCTypes;\n \n impl LintPass for ImproperCTypes {\n+    fn name(&self) -> &'static str {\n+        \"ImproperCTypes\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(IMPROPER_CTYPES)\n     }\n@@ -809,6 +817,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n pub struct VariantSizeDifferences;\n \n impl LintPass for VariantSizeDifferences {\n+    fn name(&self) -> &'static str {\n+        \"VariantSizeDifferences\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(VARIANT_SIZE_DIFFERENCES)\n     }"}, {"sha": "a05ad95a49de7e078229dfaced670d404295b609", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/beb0c74950ec51582b58e3f13e5b2a47b14f524d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=beb0c74950ec51582b58e3f13e5b2a47b14f524d", "patch": "@@ -33,6 +33,10 @@ declare_lint! {\n pub struct UnusedResults;\n \n impl LintPass for UnusedResults {\n+    fn name(&self) -> &'static str {\n+        \"UnusedResults\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n     }\n@@ -198,6 +202,10 @@ declare_lint! {\n pub struct PathStatements;\n \n impl LintPass for PathStatements {\n+    fn name(&self) -> &'static str {\n+        \"PathStatements\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PATH_STATEMENTS)\n     }\n@@ -223,6 +231,10 @@ declare_lint! {\n pub struct UnusedAttributes;\n \n impl LintPass for UnusedAttributes {\n+    fn name(&self) -> &'static str {\n+        \"UnusedAttributes\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ATTRIBUTES)\n     }\n@@ -365,6 +377,10 @@ impl UnusedParens {\n }\n \n impl LintPass for UnusedParens {\n+    fn name(&self) -> &'static str {\n+        \"UnusedParens\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_PARENS)\n     }\n@@ -483,6 +499,10 @@ impl UnusedImportBraces {\n }\n \n impl LintPass for UnusedImportBraces {\n+    fn name(&self) -> &'static str {\n+        \"UnusedImportBraces\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n@@ -506,6 +526,10 @@ declare_lint! {\n pub struct UnusedAllocation;\n \n impl LintPass for UnusedAllocation {\n+    fn name(&self) -> &'static str {\n+        \"UnusedAllocation\"\n+    }\n+\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_ALLOCATION)\n     }"}]}