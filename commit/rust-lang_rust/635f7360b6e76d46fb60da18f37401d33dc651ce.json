{"sha": "635f7360b6e76d46fb60da18f37401d33dc651ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNWY3MzYwYjZlNzZkNDZmYjYwZGExOGYzNzQwMWQzM2RjNjUxY2U=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-08-12T19:00:46Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-08-19T22:52:12Z"}, "message": "Rework Rc for FCP of #27718\n\n* Add `Rc::would_unwrap(&Self) -> bool` to introspect whether try_unwrap would succeed,\n  because it's destructive (unlike get_mut).\n* Move `rc.downgrade()` to `Rc::downgrade(&Self)` per conventions.\n* Deprecate `Rc::weak_count` and `Rc::strong_count` for questionable utility.\n* Deprecate `Rc::is_unique` for questionable semantics (there are two kinds of\n  uniqueness with Weak pointers in play).\n* Rename `rc.make_unique()` to `Rc::make_mut(&mut Self)` per conventions, to\n  avoid uniqueness terminology, and to clarify the relation to `Rc::get_mut`.", "tree": {"sha": "68b1b7beed603728706a54525f41d840ae9dc96d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68b1b7beed603728706a54525f41d840ae9dc96d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/635f7360b6e76d46fb60da18f37401d33dc651ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/635f7360b6e76d46fb60da18f37401d33dc651ce", "html_url": "https://github.com/rust-lang/rust/commit/635f7360b6e76d46fb60da18f37401d33dc651ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/635f7360b6e76d46fb60da18f37401d33dc651ce/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca2057ed5fb7af3f8905b2bc01f72fa001c35c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca2057ed5fb7af3f8905b2bc01f72fa001c35c8", "html_url": "https://github.com/rust-lang/rust/commit/aca2057ed5fb7af3f8905b2bc01f72fa001c35c8"}], "stats": {"total": 199, "additions": 117, "deletions": 82}, "files": [{"sha": "e0ff3a1bca0306a30c13b53928cb5a4831927e4b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 117, "deletions": 82, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/635f7360b6e76d46fb60da18f37401d33dc651ce/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/635f7360b6e76d46fb60da18f37401d33dc651ce/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=635f7360b6e76d46fb60da18f37401d33dc651ce", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(27718): rc_counts stuff is useful internally, but was previously public\n+#![allow(deprecated)]\n+\n //! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n //! The `Rc<T>` type provides shared ownership of an immutable value.\n@@ -126,8 +129,8 @@\n //!\n //!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n //!     // the RefCell holding the Owner's Gadgets.\n-//!     gadget_owner.gadgets.borrow_mut().push(gadget1.clone().downgrade());\n-//!     gadget_owner.gadgets.borrow_mut().push(gadget2.clone().downgrade());\n+//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));\n+//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));\n //!\n //!     // Iterate over our Gadgets, printing their details out\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n@@ -161,7 +164,7 @@ use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::intrinsics::{assume, drop_in_place, abort};\n use core::marker::{self, Unsize};\n-use core::mem::{self, align_of, size_of, align_of_val, size_of_val, forget};\n+use core::mem::{self, align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n use core::ops::{CoerceUnsized, Deref};\n use core::ptr;\n@@ -218,10 +221,10 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Unwraps the contained value if the `Rc<T>` is unique.\n+    /// Unwraps the contained value if the `Rc<T>` has only one strong reference.\n+    /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// If the `Rc<T>` is not unique, an `Err` is returned with the same\n-    /// `Rc<T>`.\n+    /// Otherwise, an `Err` is returned with the same `Rc<T>`.\n     ///\n     /// # Examples\n     ///\n@@ -238,22 +241,32 @@ impl<T> Rc<T> {\n     /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn try_unwrap(rc: Rc<T>) -> Result<T, Rc<T>> {\n-        if Rc::is_unique(&rc) {\n+    #[unstable(feature = \"rc_unique\", reason=  \"needs FCP\", issue = \"27718\")]\n+    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n+        if Rc::would_unwrap(&this) {\n             unsafe {\n-                let val = ptr::read(&*rc); // copy the contained object\n-                // destruct the box and skip our Drop\n-                // we can ignore the refcounts because we know we're unique\n-                deallocate(*rc._ptr as *mut u8, size_of::<RcBox<T>>(),\n-                            align_of::<RcBox<T>>());\n-                forget(rc);\n+                let val = ptr::read(&*this); // copy the contained object\n+\n+                // Indicate to Weaks that they can't be promoted by decrememting\n+                // the strong count, and then remove the implicit \"strong weak\"\n+                // pointer while also handling drop logic by just crafting a\n+                // fake Weak.\n+                this.dec_strong();\n+                let _weak = Weak { _ptr: this._ptr };\n+                forget(this);\n                 Ok(val)\n             }\n         } else {\n-            Err(rc)\n+            Err(this)\n         }\n     }\n+\n+    /// Checks if `Rc::try_unwrap` would return `Ok`.\n+    #[unstable(feature = \"rc_would_unwrap\", reason = \"just added for niche usecase\",\n+               issue = \"27718\")]\n+    pub fn would_unwrap(this: &Self) -> bool {\n+        Rc::strong_count(&this) == 1\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {\n@@ -268,33 +281,33 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Rc::downgrade(&five);\n     /// ```\n-    #[unstable(feature = \"rc_weak\",\n-               reason = \"Weak pointers may not belong in this module\",\n-               issue = \"27718\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n+    #[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn downgrade(this: &Self) -> Weak<T> {\n+        this.inc_weak();\n+        Weak { _ptr: this._ptr }\n     }\n \n     /// Get the number of weak references to this value.\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", issue = \"27718\")]\n-    pub fn weak_count(this: &Rc<T>) -> usize { this.weak() - 1 }\n+    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"not clearly useful\")]\n+    pub fn weak_count(this: &Self) -> usize { this.weak() - 1 }\n \n     /// Get the number of strong references to this value.\n     #[inline]\n-    #[unstable(feature = \"rc_counts\", issue= \"27718\")]\n-    pub fn strong_count(this: &Rc<T>) -> usize { this.strong() }\n+    #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"not clearly useful\")]\n+    pub fn strong_count(this: &Self) -> usize { this.strong() }\n \n     /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n     /// the same inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_unique)]\n+    /// #![feature(rc_counts)]\n     ///\n     /// use std::rc::Rc;\n     ///\n@@ -303,13 +316,14 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::is_unique(&five));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn is_unique(rc: &Rc<T>) -> bool {\n-        Rc::weak_count(rc) == 0 && Rc::strong_count(rc) == 1\n+    #[unstable(feature = \"rc_counts\", reason = \"uniqueness has unclear meaning\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"uniqueness has unclear meaning\")]\n+    pub fn is_unique(this: &Self) -> bool {\n+        Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the contained value if the `Rc<T>` is\n-    /// unique.\n+    /// Returns a mutable reference to the contained value if the `Rc<T>` has\n+    /// one strong reference and no weak references.\n     ///\n     /// Returns `None` if the `Rc<T>` is not unique.\n     ///\n@@ -328,10 +342,10 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::get_mut(&mut x).is_none());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn get_mut(rc: &mut Rc<T>) -> Option<&mut T> {\n-        if Rc::is_unique(rc) {\n-            let inner = unsafe { &mut **rc._ptr };\n+    #[unstable(feature = \"rc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n+        if Rc::is_unique(this) {\n+            let inner = unsafe { &mut **this._ptr };\n             Some(&mut inner.value)\n         } else {\n             None\n@@ -340,34 +354,62 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Make a mutable reference from the given `Rc<T>`.\n+    #[inline]\n+    #[unstable(feature = \"rc_unique\", reason = \"renamed to Rc::make_mut\", issue = \"27718\")]\n+    #[deprecated(since = \"1.4.0\", reason = \"renamed to Rc::make_mut\")]\n+    pub fn make_unique(&mut self) -> &mut T {\n+        Rc::make_mut(self)\n+    }\n+\n+    /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n+    /// data if the `Rc<T>` doesn't have one strong reference and no weak\n+    /// references.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(rc_unique)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n-    /// let mut five = Rc::new(5);\n+    /// let mut data = Rc::new(5);\n+    ///\n+    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n+    /// let mut other_data = data.clone(); // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;             // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;       // Won't clone anything\n+    ///\n+    /// // Note: data and other_data now point to different numbers\n+    /// assert_eq!(*data, 8);\n+    /// assert_eq!(*other_data, 12);\n     ///\n-    /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"rc_unique\", issue = \"27718\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n-        if !Rc::is_unique(self) {\n-            *self = Rc::new((**self).clone())\n+    #[unstable(feature = \"rc_unique\", reason = \"needs FCP\", issue = \"27718\")]\n+    pub fn make_mut(this: &mut Self) -> &mut T {\n+        if Rc::strong_count(this) != 1 {\n+            // Gotta clone the data, there are other Rcs\n+            *this = Rc::new((**this).clone())\n+        } else if Rc::weak_count(this) != 0 {\n+            // Can just steal the data, all that's left is Weaks\n+            unsafe {\n+                let mut swap = Rc::new(ptr::read(&(**this._ptr).value));\n+                mem::swap(this, &mut swap);\n+                swap.dec_strong();\n+                // Remove implicit strong-weak ref (no need to craft a fake\n+                // Weak here -- we know other Weaks can clean up for us)\n+                swap.dec_weak();\n+                forget(swap);\n+            }\n         }\n         // This unsafety is ok because we're guaranteed that the pointer\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut **self._ptr };\n+        let inner = unsafe { &mut **this._ptr };\n         &mut inner.value\n     }\n }\n@@ -413,7 +455,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as *const () as usize != mem::POST_DROP_USIZE {\n+                ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     // destroy the contained object\n@@ -653,9 +695,7 @@ impl<T> fmt::Pointer for Rc<T> {\n ///\n /// See the [module level documentation](./index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n pub struct Weak<T: ?Sized> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n@@ -667,11 +707,7 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n impl<T: ?Sized> Weak<T> {\n-\n     /// Upgrades a weak reference to a strong reference.\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n@@ -688,10 +724,11 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// let weak_five = five.downgrade();\n+    /// let weak_five = Rc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n     /// ```\n+    #[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -717,15 +754,15 @@ impl<T: ?Sized> Drop for Weak<T> {\n     ///\n     /// {\n     ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Rc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explicit drop\n     /// }\n     /// {\n     ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n+    ///     let weak_five = Rc::downgrade(&five);\n     ///\n     ///     // stuff\n     ///\n@@ -735,7 +772,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as *const () as usize != mem::POST_DROP_USIZE {\n+                ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared.\n@@ -748,9 +785,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"rc_weak\",\n-           reason = \"Weak pointers may not belong in this module.\",\n-           issue = \"27718\")]\n+#[unstable(feature = \"rc_weak\", reason = \"needs FCP\", issue = \"27718\")]\n impl<T: ?Sized> Clone for Weak<T> {\n \n     /// Makes a clone of the `Weak<T>`.\n@@ -764,7 +799,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let weak_five = Rc::new(5).downgrade();\n+    /// let weak_five = Rc::downgrade(&Rc::new(5));\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -888,14 +923,14 @@ mod tests {\n     #[test]\n     fn test_live() {\n         let x = Rc::new(5);\n-        let y = x.downgrade();\n+        let y = Rc::downgrade(&x);\n         assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n     fn test_dead() {\n         let x = Rc::new(5);\n-        let y = x.downgrade();\n+        let y = Rc::downgrade(&x);\n         drop(x);\n         assert!(y.upgrade().is_none());\n     }\n@@ -907,7 +942,7 @@ mod tests {\n         }\n \n         let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = a.clone().downgrade();\n+        let b = Rc::downgrade(&a.clone());\n         *a.x.borrow_mut() = Some(b);\n \n         // hopefully we don't double-free (or leak)...\n@@ -921,7 +956,7 @@ mod tests {\n         assert!(!Rc::is_unique(&x));\n         drop(y);\n         assert!(Rc::is_unique(&x));\n-        let w = x.downgrade();\n+        let w = Rc::downgrade(&x);\n         assert!(!Rc::is_unique(&x));\n         drop(w);\n         assert!(Rc::is_unique(&x));\n@@ -931,7 +966,7 @@ mod tests {\n     fn test_strong_count() {\n         let a = Rc::new(0u32);\n         assert!(Rc::strong_count(&a) == 1);\n-        let w = a.downgrade();\n+        let w = Rc::downgrade(&a);\n         assert!(Rc::strong_count(&a) == 1);\n         let b = w.upgrade().expect(\"upgrade of live rc failed\");\n         assert!(Rc::strong_count(&b) == 2);\n@@ -949,7 +984,7 @@ mod tests {\n         let a = Rc::new(0u32);\n         assert!(Rc::strong_count(&a) == 1);\n         assert!(Rc::weak_count(&a) == 0);\n-        let w = a.downgrade();\n+        let w = Rc::downgrade(&a);\n         assert!(Rc::strong_count(&a) == 1);\n         assert!(Rc::weak_count(&a) == 1);\n         drop(w);\n@@ -969,8 +1004,8 @@ mod tests {\n         let _y = x.clone();\n         assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n         let x = Rc::new(5);\n-        let _w = x.downgrade();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(5)));\n+        let _w = Rc::downgrade(&x);\n+        assert_eq!(Rc::try_unwrap(x), Ok(5));\n     }\n \n     #[test]\n@@ -982,7 +1017,7 @@ mod tests {\n         assert!(Rc::get_mut(&mut x).is_none());\n         drop(y);\n         assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = x.downgrade();\n+        let _w = Rc::downgrade(&x);\n         assert!(Rc::get_mut(&mut x).is_none());\n     }\n \n@@ -992,13 +1027,13 @@ mod tests {\n         let mut cow1 = cow0.clone();\n         let mut cow2 = cow1.clone();\n \n-        assert!(75 == *cow0.make_unique());\n-        assert!(75 == *cow1.make_unique());\n-        assert!(75 == *cow2.make_unique());\n+        assert!(75 == *Rc::make_mut(&mut cow0));\n+        assert!(75 == *Rc::make_mut(&mut cow1));\n+        assert!(75 == *Rc::make_mut(&mut cow2));\n \n-        *cow0.make_unique() += 1;\n-        *cow1.make_unique() += 2;\n-        *cow2.make_unique() += 3;\n+        *Rc::make_mut(&mut cow0) += 1;\n+        *Rc::make_mut(&mut cow1) += 2;\n+        *Rc::make_mut(&mut cow2) += 3;\n \n         assert!(76 == *cow0);\n         assert!(77 == *cow1);\n@@ -1020,7 +1055,7 @@ mod tests {\n         assert!(75 == *cow1);\n         assert!(75 == *cow2);\n \n-        *cow0.make_unique() += 1;\n+        *Rc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(75 == *cow1);\n@@ -1036,12 +1071,12 @@ mod tests {\n     #[test]\n     fn test_cowrc_clone_weak() {\n         let mut cow0 = Rc::new(75);\n-        let cow1_weak = cow0.downgrade();\n+        let cow1_weak = Rc::downgrade(&cow0);\n \n         assert!(75 == *cow0);\n         assert!(75 == *cow1_weak.upgrade().unwrap());\n \n-        *cow0.make_unique() += 1;\n+        *Rc::make_mut(&mut cow0) += 1;\n \n         assert!(76 == *cow0);\n         assert!(cow1_weak.upgrade().is_none());"}]}