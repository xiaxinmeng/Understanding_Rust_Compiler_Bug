{"sha": "f73f675a864e966aedde79f8d2a8c821128e6b10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3M2Y2NzVhODY0ZTk2NmFlZGRlNzlmOGQyYThjODIxMTI4ZTZiMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-07T04:24:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-07T04:24:15Z"}, "message": "Auto merge of #42494 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #42409, #42415, #42429, #42438, #42466, #42469, #42485\n- Failed merges:", "tree": {"sha": "64406498277539f36e4054bcc1a4b2b5cbaeb13d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64406498277539f36e4054bcc1a4b2b5cbaeb13d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f73f675a864e966aedde79f8d2a8c821128e6b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f73f675a864e966aedde79f8d2a8c821128e6b10", "html_url": "https://github.com/rust-lang/rust/commit/f73f675a864e966aedde79f8d2a8c821128e6b10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f73f675a864e966aedde79f8d2a8c821128e6b10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21d0f9144489b043f5b493c998de1c8afedb1321", "url": "https://api.github.com/repos/rust-lang/rust/commits/21d0f9144489b043f5b493c998de1c8afedb1321", "html_url": "https://github.com/rust-lang/rust/commit/21d0f9144489b043f5b493c998de1c8afedb1321"}, {"sha": "24f48d030e0d328cbd470fa4c999a794b6f838ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/24f48d030e0d328cbd470fa4c999a794b6f838ea", "html_url": "https://github.com/rust-lang/rust/commit/24f48d030e0d328cbd470fa4c999a794b6f838ea"}], "stats": {"total": 272, "additions": 149, "deletions": 123}, "files": [{"sha": "385376333c1d7ce106677a6f1451d43025aecd68", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -338,7 +338,6 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n             continue\n         }\n \n-        println!(\"doc tests for: {}\", p.display());\n         markdown_test(build, compiler, &p);\n     }\n }\n@@ -375,6 +374,7 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n         return;\n     }\n \n+    println!(\"doc tests for: {}\", markdown.display());\n     let mut cmd = Command::new(build.rustdoc(compiler));\n     build.add_rustc_lib_path(compiler, &mut cmd);\n     build.add_rust_test_threads(&mut cmd);"}, {"sha": "9a07e8a8b1091da983213917f9ab46fd7be21630", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -276,6 +276,10 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     if build.is_rust_llvm(target) {\n         cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n     }\n+    if let Some(ref cfg_file) = build.flags.config {\n+        let cfg_path = t!(PathBuf::from(cfg_file).canonicalize());\n+        cargo.env(\"CFG_LLVM_TOML\", cfg_path.into_os_string());\n+    }\n     cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n     let target_config = build.config.target_config.get(target);\n     if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {"}, {"sha": "99000a031feab4aca7fc82363af4b99865d1f39b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -35,6 +35,8 @@ macro_rules! panic {\n /// This will invoke the [`panic!`] macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n ///\n+/// # Uses\n+///\n /// Assertions are always checked in both debug and release builds, and cannot\n /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n /// release builds by default.\n@@ -45,7 +47,9 @@ macro_rules! panic {\n /// Other use-cases of `assert!` include [testing] and enforcing run-time\n /// invariants in safe code (whose violation cannot result in unsafety).\n ///\n-/// This macro has a second version, where a custom panic message can\n+/// # Custom Messages\n+///\n+/// This macro has a second form, where a custom panic message can\n /// be provided with or without arguments for formatting.\n ///\n /// [`panic!`]: macro.panic.html\n@@ -85,14 +89,15 @@ macro_rules! assert {\n     );\n }\n \n-/// Asserts that two expressions are equal to each other.\n+/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Like [`assert!`], this macro has a second version, where a custom\n+/// Like [`assert!`], this macro has a second form, where a custom\n /// panic message can be provided.\n ///\n+/// [`PartialEq`]: cmp/trait.PartialEq.html\n /// [`assert!`]: macro.assert.html\n ///\n /// # Examples\n@@ -130,14 +135,15 @@ macro_rules! assert_eq {\n     });\n }\n \n-/// Asserts that two expressions are not equal to each other.\n+/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Like `assert!()`, this macro has a second version, where a custom\n+/// Like [`assert!`], this macro has a second form, where a custom\n /// panic message can be provided.\n ///\n+/// [`PartialEq`]: cmp/trait.PartialEq.html\n /// [`assert!`]: macro.assert.html\n ///\n /// # Examples\n@@ -183,6 +189,8 @@ macro_rules! assert_ne {\n /// Like [`assert!`], this macro also has a second version, where a custom panic\n /// message can be provided.\n ///\n+/// # Uses\n+///\n /// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert!` statements unless `-C debug-assertions` is passed to the"}, {"sha": "05df84708e05d3aa1629e00c2826dc827c7c7575", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -205,7 +205,7 @@ pub trait Unsize<T: ?Sized> {\n /// but not `Copy`.\n ///\n /// [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n-/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation need only return `*self`\n+/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`\n /// (see the example above).\n ///\n /// ## When can my type be `Copy`?"}, {"sha": "c500d770cef0583b2a6e2fe6e9070eb5854845a0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -17,11 +17,11 @@ use hir;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum CtorKind {\n-    // Constructor function automatically created by a tuple struct/variant.\n+    /// Constructor function automatically created by a tuple struct/variant.\n     Fn,\n-    // Constructor constant automatically created by a unit struct/variant.\n+    /// Constructor constant automatically created by a unit struct/variant.\n     Const,\n-    // Unusable name in value namespace created by a struct variant.\n+    /// Unusable name in value namespace created by a struct variant.\n     Fictive,\n }\n \n@@ -109,17 +109,21 @@ impl PathResolution {\n     }\n }\n \n-// Definition mapping\n+/// Definition mapping\n pub type DefMap = NodeMap<PathResolution>;\n-// This is the replacement export map. It maps a module to all of the exports\n-// within.\n+\n+/// This is the replacement export map. It maps a module to all of the exports\n+/// within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub ident: ast::Ident, // The name of the target.\n-    pub def: Def, // The definition of the target.\n-    pub span: Span, // The span of the target definition.\n+    /// The name of the target.\n+    pub ident: ast::Ident,\n+    /// The definition of the target.\n+    pub def: Def,\n+    /// The span of the target definition.\n+    pub span: Span,\n }\n \n impl CtorKind {\n@@ -160,6 +164,7 @@ impl Def {\n         }\n     }\n \n+    /// A human readable kind name\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n             Def::Fn(..) => \"function\","}, {"sha": "ce2baa738975b683b5cdc2d4aec1b458cc691f7e", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -187,6 +187,7 @@ impl fmt::Debug for DefId {\n \n \n impl DefId {\n+    /// Make a local `DefId` with the given index.\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }\n     }"}, {"sha": "a6ab67e04693d4f9805546a5c9abda0084a795ef", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -8,37 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Lowers the AST to the HIR.\n-//\n-// Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n-// much like a fold. Where lowering involves a bit more work things get more\n-// interesting and there are some invariants you should know about. These mostly\n-// concern spans and ids.\n-//\n-// Spans are assigned to AST nodes during parsing and then are modified during\n-// expansion to indicate the origin of a node and the process it went through\n-// being expanded. Ids are assigned to AST nodes just before lowering.\n-//\n-// For the simpler lowering steps, ids and spans should be preserved. Unlike\n-// expansion we do not preserve the process of lowering in the spans, so spans\n-// should not be modified here. When creating a new node (as opposed to\n-// 'folding' an existing one), then you create a new id using `next_id()`.\n-//\n-// You must ensure that ids are unique. That means that you should only use the\n-// id from an AST node in a single HIR node (you can assume that AST node ids\n-// are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-// If you do, you must then set the new node's id to a fresh one.\n-//\n-// Spans are used for error messages and for tools to map semantics back to\n-// source code. It is therefore not as important with spans as ids to be strict\n-// about use (you can't break the compiler by screwing up a span). Obviously, a\n-// HIR node can only have a single span. But multiple nodes can have the same\n-// span and spans don't need to be kept in order, etc. Where code is preserved\n-// by lowering, it should have the same span as in the AST. Where HIR nodes are\n-// new it is probably best to give a span for the whole AST node being lowered.\n-// All nodes should have real spans, don't use dummy spans. Tools are likely to\n-// get confused if the spans from leaf AST nodes occur in multiple places\n-// in the HIR, especially for multiple identifiers.\n+//! Lowers the AST to the HIR.\n+//!\n+//! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n+//! much like a fold. Where lowering involves a bit more work things get more\n+//! interesting and there are some invariants you should know about. These mostly\n+//! concern spans and ids.\n+//!\n+//! Spans are assigned to AST nodes during parsing and then are modified during\n+//! expansion to indicate the origin of a node and the process it went through\n+//! being expanded. Ids are assigned to AST nodes just before lowering.\n+//!\n+//! For the simpler lowering steps, ids and spans should be preserved. Unlike\n+//! expansion we do not preserve the process of lowering in the spans, so spans\n+//! should not be modified here. When creating a new node (as opposed to\n+//! 'folding' an existing one), then you create a new id using `next_id()`.\n+//!\n+//! You must ensure that ids are unique. That means that you should only use the\n+//! id from an AST node in a single HIR node (you can assume that AST node ids\n+//! are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n+//! If you do, you must then set the new node's id to a fresh one.\n+//!\n+//! Spans are used for error messages and for tools to map semantics back to\n+//! source code. It is therefore not as important with spans as ids to be strict\n+//! about use (you can't break the compiler by screwing up a span). Obviously, a\n+//! HIR node can only have a single span. But multiple nodes can have the same\n+//! span and spans don't need to be kept in order, etc. Where code is preserved\n+//! by lowering, it should have the same span as in the AST. Where HIR nodes are\n+//! new it is probably best to give a span for the whole AST node being lowered.\n+//! All nodes should have real spans, don't use dummy spans. Tools are likely to\n+//! get confused if the spans from leaf AST nodes occur in multiple places\n+//! in the HIR, especially for multiple identifiers.\n \n use hir;\n use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n@@ -70,8 +70,10 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n+\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n+\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -102,14 +104,14 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    // Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n+    /// Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n-    // Obtain the resolution for a node id\n+    /// Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n-    // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n-    // This should only return `None` during testing.\n+    /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n+    /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n }\n "}, {"sha": "81a8984e7530eb011811736a16c97eecff9661cc", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -133,7 +133,6 @@ enum Node {\n     Region(ty::RegionKind),\n }\n \n-// type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),"}, {"sha": "f62470fab723ec1ad4676cc069b1c81839ca83f6", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -35,31 +35,31 @@ use std::u32;\n \n mod graphviz;\n \n-// A constraint that influences the inference process.\n+/// A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum Constraint<'tcx> {\n-    // One region variable is subregion of another\n+    /// One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n-    // Concrete region is subregion of region variable\n+    /// Concrete region is subregion of region variable\n     ConstrainRegSubVar(Region<'tcx>, RegionVid),\n \n-    // Region variable is subregion of concrete region. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// Region variable is subregion of concrete region. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainVarSubReg(RegionVid, Region<'tcx>),\n \n-    // A constraint where neither side is a variable. This does not\n-    // directly affect inference, but instead is checked after\n-    // inference is complete.\n+    /// A constraint where neither side is a variable. This does not\n+    /// directly affect inference, but instead is checked after\n+    /// inference is complete.\n     ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n-// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n-// associated type) must outlive the region `R`. `T` is known to\n-// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n-// `i`. Inference variables may be involved (but this verification\n-// step doesn't influence inference).\n+/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// associated type) must outlive the region `R`. `T` is known to\n+/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// `i`. Inference variables may be involved (but this verification\n+/// step doesn't influence inference).\n #[derive(Debug)]\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n@@ -74,29 +74,29 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-// When we introduce a verification step, we wish to test that a\n-// particular region (let's call it `'min`) meets some bound.\n-// The bound is described the by the following grammar:\n+/// When we introduce a verification step, we wish to test that a\n+/// particular region (let's call it `'min`) meets some bound.\n+/// The bound is described the by the following grammar:\n #[derive(Debug)]\n pub enum VerifyBound<'tcx> {\n-    // B = exists {R} --> some 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive all\n-    // regions in {R}, so if any of those outlives 'min, then the\n-    // bound is met.\n+    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive all\n+    /// regions in {R}, so if any of those outlives 'min, then the\n+    /// bound is met.\n     AnyRegion(Vec<Region<'tcx>>),\n \n-    // B = forall {R} --> all 'r in {R} must outlive 'min\n-    //\n-    // Put another way, the subject value is known to outlive some\n-    // region in {R}, so if all of those outlives 'min, then the bound\n-    // is met.\n+    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    ///\n+    /// Put another way, the subject value is known to outlive some\n+    /// region in {R}, so if all of those outlives 'min, then the bound\n+    /// is met.\n     AllRegions(Vec<Region<'tcx>>),\n \n-    // B = exists {B} --> 'min must meet some bound b in {B}\n+    /// B = exists {B} --> 'min must meet some bound b in {B}\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    // B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// B = forall {B} --> 'min must meet all bounds b in {B}\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -183,56 +183,57 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n-    // Constraints of the form `A <= B` introduced by the region\n-    // checker.  Here at least one of `A` and `B` must be a region\n-    // variable.\n+    /// Constraints of the form `A <= B` introduced by the region\n+    /// checker.  Here at least one of `A` and `B` must be a region\n+    /// variable.\n     constraints: RefCell<FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n-    // A \"verify\" is something that we need to verify after inference is\n-    // done, but which does not directly affect inference in any way.\n-    //\n-    // An example is a `A <= B` where neither `A` nor `B` are\n-    // inference variables.\n+    /// A \"verify\" is something that we need to verify after inference is\n+    /// done, but which does not directly affect inference in any way.\n+    ///\n+    /// An example is a `A <= B` where neither `A` nor `B` are\n+    /// inference variables.\n     verifys: RefCell<Vec<Verify<'tcx>>>,\n \n-    // A \"given\" is a relationship that is known to hold. In particular,\n-    // we often know from closure fn signatures that a particular free\n-    // region must be a subregion of a region variable:\n-    //\n-    //    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    //\n-    // In situations like this, `'b` is in fact a region variable\n-    // introduced by the call to `iter()`, and `'a` is a bound region\n-    // on the closure (as indicated by the `<'a>` prefix). If we are\n-    // naive, we wind up inferring that `'b` must be `'static`,\n-    // because we require that it be greater than `'a` and we do not\n-    // know what `'a` is precisely.\n-    //\n-    // This hashmap is used to avoid that naive scenario. Basically we\n-    // record the fact that `'a <= 'b` is implied by the fn signature,\n-    // and then ignore the constraint when solving equations. This is\n-    // a bit of a hack but seems to work.\n+    /// A \"given\" is a relationship that is known to hold. In particular,\n+    /// we often know from closure fn signatures that a particular free\n+    /// region must be a subregion of a region variable:\n+    ///\n+    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n+    ///\n+    /// In situations like this, `'b` is in fact a region variable\n+    /// introduced by the call to `iter()`, and `'a` is a bound region\n+    /// on the closure (as indicated by the `<'a>` prefix). If we are\n+    /// naive, we wind up inferring that `'b` must be `'static`,\n+    /// because we require that it be greater than `'a` and we do not\n+    /// know what `'a` is precisely.\n+    ///\n+    /// This hashmap is used to avoid that naive scenario. Basically we\n+    /// record the fact that `'a <= 'b` is implied by the fn signature,\n+    /// and then ignore the constraint when solving equations. This is\n+    /// a bit of a hack but seems to work.\n     givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n     skolemization_count: Cell<u32>,\n     bound_count: Cell<u32>,\n \n-    // The undo log records actions that might later be undone.\n-    //\n-    // Note: when the undo_log is empty, we are not actively\n-    // snapshotting. When the `start_snapshot()` method is called, we\n-    // push an OpenSnapshot entry onto the list to indicate that we\n-    // are now actively snapshotting. The reason for this is that\n-    // otherwise we end up adding entries for things like the lower\n-    // bound on a variable and so forth, which can never be rolled\n-    // back.\n+    /// The undo log records actions that might later be undone.\n+    ///\n+    /// Note: when the undo_log is empty, we are not actively\n+    /// snapshotting. When the `start_snapshot()` method is called, we\n+    /// push an OpenSnapshot entry onto the list to indicate that we\n+    /// are now actively snapshotting. The reason for this is that\n+    /// otherwise we end up adding entries for things like the lower\n+    /// bound on a variable and so forth, which can never be rolled\n+    /// back.\n     undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n+\n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n-    // This contains the results of inference.  It begins as an empty\n-    // option and only acquires a value after inference is complete.\n+    /// This contains the results of inference.  It begins as an empty\n+    /// option and only acquires a value after inference is complete.\n     values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n "}, {"sha": "ce5d58f5800c788c413d98bd42e087e72ec086c4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -1363,7 +1363,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             m.push_str(&(if n == 1 {\n                 help_name\n             } else {\n-                format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                format!(\"one of {}'s {} {}lifetimes\", help_name, n,\n                         if have_bound_regions { \"free \" } else { \"\" } )\n             })[..]);\n "}, {"sha": "bdfc0a2fe855ccf0df522b661f5012ad2557895e", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -61,6 +61,11 @@ fn main() {\n \n     println!(\"cargo:rerun-if-changed={}\", llvm_config.display());\n \n+    if let Some(cfg_toml) = env::var_os(\"CFG_LLVM_TOML\") {\n+        let cfg_path = PathBuf::from(cfg_toml);\n+        println!(\"cargo:rerun-if-changed={}\", cfg_path.display());\n+    }\n+\n     // Test whether we're cross-compiling LLVM. This is a pretty rare case\n     // currently where we're producing an LLVM for a different platform than\n     // what this build script is currently running on."}, {"sha": "6b5caff27e8f020b7fdfcd74e199c7ebd29ac2b9", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -81,6 +81,7 @@ pub struct Symbol(u32);\n \n // The interner in thread-local, so `Symbol` shouldn't move between threads.\n impl !Send for Symbol { }\n+impl !Sync for Symbol { }\n \n impl Symbol {\n     /// Maps a string to its interned representation."}, {"sha": "9b8c7b250763ef100c3cda9fa2e1f2d55b05bc1f", "filename": "src/test/compile-fail/issue-26638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26638.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -10,7 +10,7 @@\n \n fn parse_type(iter: Box<Iterator<Item=&str>+'static>) -> &str { iter.next() }\n //~^ ERROR missing lifetime specifier [E0106]\n-//~^^ HELP 2 elided lifetimes\n+//~^^ HELP 2 lifetimes\n \n fn parse_type_2(iter: fn(&u8)->&u8) -> &str { iter() }\n //~^ ERROR missing lifetime specifier [E0106]"}, {"sha": "e3f55ae51e8b65f28e98459167ecb378107a9a6c", "filename": "src/test/compile-fail/issue-30255.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Fissue-30255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Fissue-30255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30255.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -17,19 +17,19 @@ struct S<'a> {\n \n fn f(a: &S, b: i32) -> &i32 {\n //~^ ERROR missing lifetime specifier [E0106]\n-//~^^ HELP does not say which one of `a`'s 2 elided lifetimes it is borrowed from\n+//~^^ HELP does not say which one of `a`'s 2 lifetimes it is borrowed from\n     panic!();\n }\n \n fn g(a: &S, b: bool, c: &i32) -> &i32 {\n //~^ ERROR missing lifetime specifier [E0106]\n-//~^^ HELP does not say whether it is borrowed from one of `a`'s 2 elided lifetimes or `c`\n+//~^^ HELP does not say whether it is borrowed from one of `a`'s 2 lifetimes or `c`\n     panic!();\n }\n \n fn h(a: &bool, b: bool, c: &S, d: &i32) -> &i32 {\n //~^ ERROR missing lifetime specifier [E0106]\n-//~^^ HELP does not say whether it is borrowed from `a`, one of `c`'s 2 elided lifetimes, or `d`\n+//~^^ HELP does not say whether it is borrowed from `a`, one of `c`'s 2 lifetimes, or `d`\n     panic!();\n }\n "}, {"sha": "2d9de57a2659f52b8b59c6cdfe51637b7b178826", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f73f675a864e966aedde79f8d2a8c821128e6b10/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=f73f675a864e966aedde79f8d2a8c821128e6b10", "patch": "@@ -28,7 +28,7 @@ struct Foo<'a> {\n // Lifetime annotation needed because we have two lifetimes: one as a parameter\n // and one on the reference.\n fn h(_x: &Foo) -> &isize { //~ ERROR missing lifetime specifier\n-//~^ HELP the signature does not say which one of `_x`'s 2 elided lifetimes it is borrowed from\n+//~^ HELP the signature does not say which one of `_x`'s 2 lifetimes it is borrowed from\n     panic!()\n }\n "}]}