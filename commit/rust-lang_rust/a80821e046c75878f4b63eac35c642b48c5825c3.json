{"sha": "a80821e046c75878f4b63eac35c642b48c5825c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MDgyMWUwNDZjNzU4NzhmNGI2M2VhYzM1YzY0MmI0OGM1ODI1YzM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-30T20:35:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-30T20:35:58Z"}, "message": "also combine re-locking into the dequeue-and-unblock operation", "tree": {"sha": "efa3e16cfc6ff410a60019d3621c5c5b61c3ccc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa3e16cfc6ff410a60019d3621c5c5b61c3ccc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a80821e046c75878f4b63eac35c642b48c5825c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a80821e046c75878f4b63eac35c642b48c5825c3", "html_url": "https://github.com/rust-lang/rust/commit/a80821e046c75878f4b63eac35c642b48c5825c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a80821e046c75878f4b63eac35c642b48c5825c3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7589bc7ba92df64cbf3cab214724a6d500a0e2b3", "html_url": "https://github.com/rust-lang/rust/commit/7589bc7ba92df64cbf3cab214724a6d500a0e2b3"}], "stats": {"total": 45, "additions": 23, "deletions": 22}, "files": [{"sha": "2669776db5bad860af1a8f0acb0549ebbd8acf2c", "filename": "src/shims/sync.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a80821e046c75878f4b63eac35c642b48c5825c3/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80821e046c75878f4b63eac35c642b48c5825c3/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=a80821e046c75878f4b63eac35c642b48c5825c3", "patch": "@@ -606,9 +606,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.rwlock_is_locked(id) {\n                 // No more readers owning the lock. Give it to a writer if there\n                 // is any.\n-                if let Some(writer) = this.rwlock_dequeue_and_unblock_writer(id) {\n-                    this.rwlock_writer_lock(id, writer);\n-                }\n+                this.rwlock_dequeue_and_lock_writer(id);\n             }\n             Ok(0)\n         } else if Some(active_thread) == this.rwlock_writer_unlock(id) {\n@@ -617,13 +615,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We are prioritizing writers here against the readers. As a\n             // result, not only readers can starve writers, but also writers can\n             // starve readers.\n-            if let Some(writer) = this.rwlock_dequeue_and_unblock_writer(id) {\n-                // Give the lock to another writer.\n-                this.rwlock_writer_lock(id, writer);\n+            if this.rwlock_dequeue_and_lock_writer(id) {\n+                // Someone got the write lock, nice.\n             } else {\n                 // Give the lock to all readers.\n-                while let Some(reader) = this.rwlock_dequeue_and_unblock_reader(id) {\n-                    this.rwlock_reader_lock(id, reader);\n+                while this.rwlock_dequeue_and_lock_reader(id) {\n+                    // Rinse and repeat.\n                 }\n             }\n             Ok(0)"}, {"sha": "723815dbf226ec8b9ff08ebfdebe86a16bbde265", "filename": "src/sync.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a80821e046c75878f4b63eac35c642b48c5825c3/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80821e046c75878f4b63eac35c642b48c5825c3/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=a80821e046c75878f4b63eac35c642b48c5825c3", "patch": "@@ -170,9 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex.owner = None;\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n-                if let Some(new_owner) = this.mutex_dequeue_and_unblock(id) {\n-                    this.mutex_lock(id, new_owner);\n-                }\n+                this.mutex_dequeue_and_lock(id);\n             }\n             Ok(Some(old_lock_count))\n         } else {\n@@ -182,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    /// Put the thread into the queue waiting for the lock.\n+    /// Put the thread into the queue waiting for the mutex.\n     fn mutex_enqueue_and_block(&mut self, id: MutexId, thread: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(this.mutex_is_locked(id), \"queing on unlocked mutex\");\n@@ -191,14 +189,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    /// Take a thread out of the queue waiting for the lock.\n-    fn mutex_dequeue_and_unblock(&mut self, id: MutexId) -> Option<ThreadId> {\n+    /// Take a thread out of the queue waiting for the mutex, and lock\n+    /// the mutex for it. Returns `true` if some thread has the mutex now.\n+    fn mutex_dequeue_and_lock(&mut self, id: MutexId) -> bool {\n         let this = self.eval_context_mut();\n         if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n             this.unblock_thread(thread);\n-            Some(thread)\n+            this.mutex_lock(id, thread);\n+            true\n         } else {\n-            None\n+            false\n         }\n     }\n \n@@ -266,13 +266,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Take a reader out the queue waiting for the lock.\n-    fn rwlock_dequeue_and_unblock_reader(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    /// Returns `true` if some thread got the rwlock.\n+    fn rwlock_dequeue_and_lock_reader(&mut self, id: RwLockId) -> bool {\n         let this = self.eval_context_mut();\n         if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n             this.unblock_thread(reader);\n-            Some(reader)\n+            this.rwlock_reader_lock(id, reader);\n+            true\n         } else {\n-            None\n+            false\n         }\n     }\n \n@@ -306,13 +308,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Take the writer out the queue waiting for the lock.\n-    fn rwlock_dequeue_and_unblock_writer(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    /// Returns `true` if some thread got the rwlock.\n+    fn rwlock_dequeue_and_lock_writer(&mut self, id: RwLockId) -> bool {\n         let this = self.eval_context_mut();\n         if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n             this.unblock_thread(writer);\n-            Some(writer)\n+            this.rwlock_writer_lock(id, writer);\n+            true\n         } else {\n-            None\n+            false\n         }\n     }\n "}]}