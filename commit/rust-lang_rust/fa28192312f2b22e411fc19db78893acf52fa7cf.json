{"sha": "fa28192312f2b22e411fc19db78893acf52fa7cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMjgxOTIzMTJmMmIyMmU0MTFmYzE5ZGI3ODg5M2FjZjUyZmE3Y2Y=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-20T22:07:35Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-20T22:07:35Z"}, "message": "Write better docs for std::io\n\nThis is the landing page for all of io, so we should have more than just\na sentence here.", "tree": {"sha": "f87289fe0584e47cab778e01adc47f2537829f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f87289fe0584e47cab778e01adc47f2537829f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa28192312f2b22e411fc19db78893acf52fa7cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa28192312f2b22e411fc19db78893acf52fa7cf", "html_url": "https://github.com/rust-lang/rust/commit/fa28192312f2b22e411fc19db78893acf52fa7cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa28192312f2b22e411fc19db78893acf52fa7cf/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e51763e6428580f2b3275cd7076492376801a1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e51763e6428580f2b3275cd7076492376801a1e", "html_url": "https://github.com/rust-lang/rust/commit/4e51763e6428580f2b3275cd7076492376801a1e"}], "stats": {"total": 229, "additions": 229, "deletions": 0}, "files": [{"sha": "3016cfa8fe5e359c0e8247874d54aec1fd3cbbfe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/fa28192312f2b22e411fc19db78893acf52fa7cf/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa28192312f2b22e411fc19db78893acf52fa7cf/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fa28192312f2b22e411fc19db78893acf52fa7cf", "patch": "@@ -9,6 +9,235 @@\n // except according to those terms.\n \n //! Traits, helpers, and type definitions for core I/O functionality.\n+//!\n+//! The `std::io` module contains a number of common things you'll need\n+//! when doing input and output. The most core part of this module is\n+//! the [`Read`][read] and [`Write`][write] traits, which provide the\n+//! most general interface for reading and writing input and output.\n+//!\n+//! [read]: trait.Read.html\n+//! [write]: trait.Write.html\n+//!\n+//! # Read and Write\n+//!\n+//! Because they are traits, they're implemented by a number of other types,\n+//! and you can implement them for your types too. As such, you'll see a\n+//! few different types of I/O throughout the documentation in this module:\n+//! `File`s, `TcpStream`s, and somtimes even `Vec<T>`s. For example, `Read`\n+//! adds a `read()` method, which we can use on `File`s:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//! use std::fs::File;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let mut f = try!(File::open(\"foo.txt\"));\n+//! let mut buffer = [0; 10];\n+//!\n+//! // read up to 10 bytes\n+//! try!(f.read(&mut buffer));\n+//!\n+//! println!(\"The bytes: {:?}\", buffer);\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! `Read` and `Write` are so important, implementors of the two traits have a\n+//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n+//! of 'a type that implements the `Read` trait'. Much easier!\n+//!\n+//! ## Seek and BufRead\n+//!\n+//! Beyond that, there are two important traits that are provided: [`Seek`][seek]\n+//! and [`BufRead`][bufread]. Both of these build on top of a reader to control\n+//! how the reading happens. `Seek` lets you control where the next byte is\n+//! coming from:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//! use std::io::SeekFrom;\n+//! use std::fs::File;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let mut f = try!(File::open(\"foo.txt\"));\n+//! let mut buffer = [0; 10];\n+//!\n+//! // skip to the last 10 bytes of the file\n+//! try!(f.seek(SeekFrom::End(-10)));\n+//!\n+//! // read up to 10 bytes\n+//! try!(f.read(&mut buffer));\n+//!\n+//! println!(\"The bytes: {:?}\", buffer);\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! [seek]: trait.Seek.html\n+//! [bufread]: trait.BufRead.html\n+//!\n+//! `BufRead` uses an internal buffer to provide a number of other ways to read, but\n+//! to show it off, we'll need to talk about buffers in general. Keep reading!\n+//!\n+//! ## BufReader and BufWriter\n+//!\n+//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n+//! making near-constant calls to the operating system. To help with this,\n+//! `std::io` comes with two structs, `BufReader` and `BufWriter`, which wrap\n+//! readers and writers. The wrapper uses a buffer, reducing the number of\n+//! calls and providing nicer methods for accessing exactly what you want.\n+//!\n+//! For example, `BufReader` works with the `BufRead` trait to add extra\n+//! methods to any reader:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//! use std::io::BufReader;\n+//! use std::fs::File;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let f = try!(File::open(\"foo.txt\"));\n+//! let mut reader = BufReader::new(f);\n+//! let mut buffer = String::new();\n+//!\n+//! // read a line into buffer\n+//! try!(reader.read_line(&mut buffer));\n+//!\n+//! println!(\"{}\", buffer);\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! `BufWriter` doesn't add any new ways of writing, it just buffers every call\n+//! to [`write()`][write]:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//! use std::io::BufWriter;\n+//! use std::fs::File;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let f = try!(File::create(\"foo.txt\"));\n+//! {\n+//!     let mut writer = BufWriter::new(f);\n+//!\n+//!     // write a byte to the buffer\n+//!     try!(writer.write(&[42]));\n+//!\n+//! } // the buffer is flushed once writer goes out of scope\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! [write]: trait.Write.html#tymethod.write\n+//!\n+//! ## Standard input and output\n+//!\n+//! A very common source of input is standard input:\n+//!\n+//! ```\n+//! use std::io;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let mut input = String::new();\n+//!\n+//! try!(io::stdin().read_line(&mut input));\n+//!\n+//! println!(\"You typed: {}\", input.trim());\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! And a very common source of output is standard output:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! try!(io::stdout().write(&[42]));\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! Of course, using `io::stdout()` directly is less comon than something like\n+//! `println!`.\n+//!\n+//! ## Iterator types\n+//!\n+//! A large number of the structures provided by `std::io` are for various\n+//! ways of iterating over I/O. For example, `Lines` is used to split over\n+//! lines:\n+//!\n+//! ```\n+//! use std::io;\n+//! use std::io::prelude::*;\n+//! use std::io::BufReader;\n+//! use std::fs::File;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! let f = try!(File::open(\"foo.txt\"));\n+//! let mut reader = BufReader::new(f);\n+//!\n+//! for line in reader.lines() {\n+//!     let line = try!(line);\n+//!     println!(\"{}\", line);\n+//! }\n+//!\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! ## Functions\n+//!\n+//! There are a number of [functions][functions] that offer access to various\n+//! features. For example, we can use three of these functions to copy everything\n+//! from standard input to standard output:\n+//!\n+//! ```\n+//! use std::io;\n+//!\n+//! # fn foo() -> io::Result<()> {\n+//! try!(io::copy(&mut io::stdin(), &mut io::stdout()));\n+//! # Ok(())\n+//! # }\n+//! ```\n+//!\n+//! [functions]: #functions\n+//!\n+//! ## io::Result\n+//!\n+//! Last, but certainly not least, is [`io::Result`][result]. This type is used\n+//! as the return type of many `std::io` functions that can cause an error, and\n+//! can be returned from your own functions as well. Many of the examples in this\n+//! module use the [`try!`][try] macro:\n+//!\n+//! ```\n+//! use std::io;\n+//!\n+//! fn read_input() -> io::Result<()> {\n+//!     let mut input = String::new();\n+//!\n+//!     try!(io::stdin().read_line(&mut input));\n+//!\n+//!     println!(\"You typed: {}\", input.trim());\n+//!\n+//!     Ok(())\n+//! }\n+//! ```\n+//!\n+//! The return type of `read_input()`, `io::Result<()>`, is a very common type\n+//! for functions which don't have a 'real' return value, but do want to return\n+//! errors if they happen. In this case, the only purpose of this function is\n+//! to read the line and print it, so we use use `()`.\n+//!\n+//! [result]: type.Result.html\n+//! [try]: macro.try!.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}