{"sha": "873022797ae7f09872738c7367d8d658a1a34ad5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MzAyMjc5N2FlN2YwOTg3MjczOGM3MzY3ZDhkNjU4YTFhMzRhZDU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-04-22T11:06:24Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-04-24T22:05:10Z"}, "message": "Speed up BTreeMap iteration by intertwined descend to the initial leaf edges", "tree": {"sha": "5566d20651f18ec2bbd0cd4ab1d72ea54ba1529e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5566d20651f18ec2bbd0cd4ab1d72ea54ba1529e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/873022797ae7f09872738c7367d8d658a1a34ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/873022797ae7f09872738c7367d8d658a1a34ad5", "html_url": "https://github.com/rust-lang/rust/commit/873022797ae7f09872738c7367d8d658a1a34ad5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/873022797ae7f09872738c7367d8d658a1a34ad5/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5c66c6a30cb770da3da953fa911b6c7a5769bb", "html_url": "https://github.com/rust-lang/rust/commit/8f5c66c6a30cb770da3da953fa911b6c7a5769bb"}], "stats": {"total": 76, "additions": 47, "deletions": 29}, "files": [{"sha": "b3158c97bfc51af60f63a873c797d149cac9dd5d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/873022797ae7f09872738c7367d8d658a1a34ad5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/873022797ae7f09872738c7367d8d658a1a34ad5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=873022797ae7f09872738c7367d8d658a1a34ad5", "patch": "@@ -1545,16 +1545,10 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n-        if let Some(root) = me.root.as_mut() {\n-            let root1 = unsafe { ptr::read(root).into_ref() };\n-            let root2 = unsafe { ptr::read(root).into_ref() };\n-            let len = me.length;\n-\n-            IntoIter {\n-                front: Some(root1.first_leaf_edge()),\n-                back: Some(root2.last_leaf_edge()),\n-                length: len,\n-            }\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n+\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n             IntoIter { front: None, back: None, length: 0 }\n         }\n@@ -2042,6 +2036,7 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n@@ -2126,6 +2121,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2150,12 +2172,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n-                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -2182,19 +2204,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            range: if let Some(root) = &mut self.root {\n-                let root1 = root.as_mut();\n-                let root2 = unsafe { ptr::read(&root1) };\n-                RangeMut {\n-                    front: Some(root1.first_leaf_edge()),\n-                    back: Some(root2.last_leaf_edge()),\n-                    _marker: PhantomData,\n-                }\n-            } else {\n-                RangeMut { front: None, back: None, _marker: PhantomData }\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n "}]}