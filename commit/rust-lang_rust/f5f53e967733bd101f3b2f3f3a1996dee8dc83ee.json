{"sha": "f5f53e967733bd101f3b2f3f3a1996dee8dc83ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZjUzZTk2NzczM2JkMTAxZjNiMmYzZjNhMTk5NmRlZThkYzgzZWU=", "commit": {"author": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-02T13:52:12Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-02T13:52:12Z"}, "message": "Revert \"correct subtle bug in the type variable code\"\n\nThis reverts commit ccd92c2a4e5ed634bbbd6d3a5bd491c47b80f642.\n\nThis commit is the source of a major perf regression, and was not\nintended to be included in #47861. At some point I must have\naccidentally re-added the commit.", "tree": {"sha": "65c16c2dfcad1d8b874ebf17c195c226d02ac945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65c16c2dfcad1d8b874ebf17c195c226d02ac945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee", "html_url": "https://github.com/rust-lang/rust/commit/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee/comments", "author": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba", "html_url": "https://github.com/rust-lang/rust/commit/9cb18a92ad87852c4c5d6726b8fbe8c38deda4ba"}], "stats": {"total": 167, "additions": 107, "deletions": 60}, "files": [{"sha": "66360ea50bbe004d2f8879ed7dce20d81ab69e5f", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 107, "deletions": 60, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f53e967733bd101f3b2f3f3a1996dee8dc83ee/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=f5f53e967733bd101f3b2f3f3a1996dee8dc83ee", "patch": "@@ -16,15 +16,11 @@ use std::cmp;\n use std::marker::PhantomData;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n \n pub struct TypeVariableTable<'tcx> {\n-    /// Extra data for each type variable, such as the origin. This is\n-    /// not stored in the unification table since, when we inquire\n-    /// after the origin of a variable X, we want the origin of **that\n-    /// variable X**, not the origin of some other variable Y with\n-    /// which X has been unified.\n-    var_data: Vec<TypeVariableData>,\n+    values: sv::SnapshotVec<Delegate>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X == ?Y`. This table also stores, for each key,\n@@ -118,20 +114,21 @@ impl<'tcx> TypeVariableValue<'tcx> {\n }\n \n pub struct Snapshot<'tcx> {\n-    /// number of variables at the time of the snapshot\n-    num_vars: usize,\n-\n-    /// snapshot from the `eq_relations` table\n+    snapshot: sv::Snapshot,\n     eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n-\n-    /// snapshot from the `sub_relations` table\n     sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n }\n \n+struct Instantiate {\n+    vid: ty::TyVid,\n+}\n+\n+struct Delegate;\n+\n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n-            var_data: Vec::new(),\n+            values: sv::SnapshotVec::new(),\n             eq_relations: ut::UnificationTable::new(),\n             sub_relations: ut::UnificationTable::new(),\n         }\n@@ -142,15 +139,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.var_data[vid.index as usize].diverging\n+        self.values.get(vid.index as usize).diverging\n     }\n \n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n-        &self.var_data[vid.index as usize].origin\n+        &self.values.get(vid.index as usize).origin\n     }\n \n     /// Records that `a == b`, depending on `dir`.\n@@ -182,6 +179,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                       \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n                       vid, ty, self.eq_relations.probe_value(vid));\n         self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n+\n+        // Hack: we only need this so that `types_escaping_snapshot`\n+        // can see what has been unified; see the Delegate impl for\n+        // more details.\n+        self.values.record(Instantiate { vid: vid });\n     }\n \n     /// Creates a new type variable.\n@@ -204,8 +206,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        assert_eq!(self.var_data.len(), sub_key.index as usize);\n-        self.var_data.push(TypeVariableData { origin, diverging });\n+        let index = self.values.push(TypeVariableData {\n+            origin,\n+            diverging,\n+        });\n+        assert_eq!(eq_key.vid.index, index as u32);\n \n         debug!(\"new_var(index={:?}, diverging={:?}, origin={:?}\", eq_key.vid, diverging, origin);\n \n@@ -214,7 +219,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     /// Returns the number of type variables created thus far.\n     pub fn num_vars(&self) -> usize {\n-        self.var_data.len()\n+        self.values.len()\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `eq_relations`\n@@ -270,7 +275,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n-            num_vars: self.var_data.len(),\n+            snapshot: self.values.start_snapshot(),\n             eq_snapshot: self.eq_relations.snapshot(),\n             sub_snapshot: self.sub_relations.snapshot(),\n         }\n@@ -280,21 +285,30 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// snapshots created since that point must already have been\n     /// committed or rolled back.\n     pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n-        debug!(\"type_variables::rollback_to(num_vars = {})\", num_vars);\n-        assert!(self.var_data.len() >= num_vars);\n+        debug!(\"rollback_to{:?}\", {\n+            for action in self.values.actions_since_snapshot(&s.snapshot) {\n+                match *action {\n+                    sv::UndoLog::NewElem(index) => {\n+                        debug!(\"inference variable _#{}t popped\", index)\n+                    }\n+                    _ => { }\n+                }\n+            }\n+        });\n+\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.rollback_to(snapshot);\n         self.eq_relations.rollback_to(eq_snapshot);\n         self.sub_relations.rollback_to(sub_snapshot);\n-        self.var_data.truncate(num_vars);\n     }\n \n     /// Commits all changes since the snapshot was created, making\n     /// them permanent (unless this snapshot was created within\n     /// another snapshot). Any snapshots created since that point\n     /// must already have been committed or rolled back.\n     pub fn commit(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { num_vars, eq_snapshot, sub_snapshot } = s;\n-        debug!(\"type_variables::commit(num_vars = {})\", num_vars);\n+        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n+        self.values.commit(snapshot);\n         self.eq_relations.commit(eq_snapshot);\n         self.sub_relations.commit(sub_snapshot);\n     }\n@@ -303,12 +317,19 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// ty-variables created during the snapshot, and the values\n     /// `{V2}` are the root variables that they were unified with,\n     /// along with their origin.\n-    pub fn types_created_since_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> TypeVariableMap {\n-        self.var_data\n+    pub fn types_created_since_snapshot(&mut self, s: &Snapshot<'tcx>) -> TypeVariableMap {\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+\n+        actions_since_snapshot\n             .iter()\n-            .enumerate()\n-            .skip(snapshot.num_vars) // skip those that existed when snapshot was taken\n-            .map(|(index, data)| (ty::TyVid { index: index as u32 }, data.origin))\n+            .filter_map(|action| match action {\n+                &sv::UndoLog::NewElem(index) => Some(ty::TyVid { index: index as u32 }),\n+                _ => None,\n+            })\n+            .map(|vid| {\n+                let origin = self.values.get(vid.index as usize).origin.clone();\n+                (vid, origin)\n+            })\n             .collect()\n     }\n \n@@ -318,42 +339,47 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// a type variable `V0`, then we started the snapshot, then we\n     /// created a type variable `V1`, unifed `V0` with `T0`, and\n     /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, snapshot: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n-        // We want to select only those instantiations that have\n-        // occurred since the snapshot *and* which affect some\n-        // variable that existed prior to the snapshot. This code just\n-        // affects all instantiatons that ever occurred which affect\n-        // variables prior to the snapshot.\n-        //\n-        // It's hard to do better than this, though, without changing\n-        // the unification table to prefer \"lower\" vids -- the problem\n-        // is that we may have a variable X (from before the snapshot)\n-        // and Y (from after the snapshot) which get unified, with Y\n-        // chosen as the new root. Now we are \"instantiating\" Y with a\n-        // value, but it escapes into X, but we wouldn't readily see\n-        // that. (In fact, earlier revisions of this code had this\n-        // bug; it was introduced when we added the `eq_relations`\n-        // table, but it's hard to create rust code that triggers it.)\n-        //\n-        // We could tell the table to prefer lower vids, and then we would\n-        // see the case above, but we would get less-well-balanced trees.\n-        //\n-        // Since I hope to kill the leak-check in this branch, and\n-        // that's the code which uses this logic anyway, I'm going to\n-        // use the less efficient algorithm for now.\n-        let mut escaping_types = Vec::with_capacity(snapshot.num_vars);\n-        escaping_types.extend(\n-            (0..snapshot.num_vars) // for all variables that pre-exist the snapshot, collect..\n-                .map(|i| ty::TyVid { index: i as u32 })\n-                .filter_map(|vid| self.probe(vid).known())); // ..types they are instantiated with.\n-        debug!(\"types_escaping_snapshot = {:?}\", escaping_types);\n+    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n+        let mut new_elem_threshold = u32::MAX;\n+        let mut escaping_types = Vec::new();\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n+        for action in actions_since_snapshot {\n+            match *action {\n+                sv::UndoLog::NewElem(index) => {\n+                    // if any new variables were created during the\n+                    // snapshot, remember the lower index (which will\n+                    // always be the first one we see). Note that this\n+                    // action must precede those variables being\n+                    // specified.\n+                    new_elem_threshold = cmp::min(new_elem_threshold, index as u32);\n+                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n+                }\n+\n+                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n+                    if vid.index < new_elem_threshold {\n+                        // quick check to see if this variable was\n+                        // created since the snapshot started or not.\n+                        let escaping_type = match self.eq_relations.probe_value(vid) {\n+                            TypeVariableValue::Unknown { .. } => bug!(),\n+                            TypeVariableValue::Known { value } => value,\n+                        };\n+                        escaping_types.push(escaping_type);\n+                    }\n+                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n+                }\n+\n+                _ => { }\n+            }\n+        }\n+\n         escaping_types\n     }\n \n     /// Returns indices of all variables that are not yet\n     /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {\n-        (0..self.var_data.len())\n+        (0..self.values.len())\n             .filter_map(|i| {\n                 let vid = ty::TyVid { index: i as u32 };\n                 match self.probe(vid) {\n@@ -364,6 +390,27 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n }\n+\n+impl sv::SnapshotVecDelegate for Delegate {\n+    type Value = TypeVariableData;\n+    type Undo = Instantiate;\n+\n+    fn reverse(_values: &mut Vec<TypeVariableData>, _action: Instantiate) {\n+        // We don't actually have to *do* anything to reverse an\n+        // instanation; the value for a variable is stored in the\n+        // `eq_relations` and hence its rollback code will handle\n+        // it. In fact, we could *almost* just remove the\n+        // `SnapshotVec` entirely, except that we would have to\n+        // reproduce *some* of its logic, since we want to know which\n+        // type variables have been instantiated since the snapshot\n+        // was started, so we can implement `types_escaping_snapshot`.\n+        //\n+        // (If we extended the `UnificationTable` to let us see which\n+        // values have been unified and so forth, that might also\n+        // suffice.)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n \n /// These structs (a newtyped TyVid) are used as the unification key"}]}