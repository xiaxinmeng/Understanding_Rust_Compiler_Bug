{"sha": "c6e4db620a7d2f569f11dcab627430921ea8aacf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ZTRkYjYyMGE3ZDJmNTY5ZjExZGNhYjYyNzQzMDkyMWVhOGFhY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T19:35:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T19:35:33Z"}, "message": "Auto merge of #77198 - jonas-schievink:rollup-i59i41h, r=jonas-schievink\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #76932 (Relax promises about condition variable.)\n - #76973 (Unstably allow assume intrinsic in const contexts)\n - #77005 (BtreeMap: refactoring around edges)\n - #77066 (Fix dest prop miscompilation around references)\n - #77073 (dead_code: look at trait impls even if they don't contain items)\n - #77086 (Include libunwind in the rust-src component.)\n - #77097 (Make [].as_[mut_]ptr_range() (unstably) const.)\n - #77106 (clarify that `changelog-seen = 1` goes to the beginning of config.toml)\n - #77120 (Add `--keep-stage-std` to `x.py` for keeping only standard library artifacts)\n - #77126 (Invalidate local LLVM cache less often)\n - #77146 (Install std for non-host targets)\n - #77155 (remove enum name from ImplSource variants)\n - #77176 (Removing erroneous semicolon in transmute documentation)\n - #77183 (Allow multiple allow_internal_unstable attributes)\n - #77189 (Remove extra space from vec drawing)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "dfa187e5fe5ae7ff68b6e624532a60069473848c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa187e5fe5ae7ff68b6e624532a60069473848c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6e4db620a7d2f569f11dcab627430921ea8aacf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e4db620a7d2f569f11dcab627430921ea8aacf", "html_url": "https://github.com/rust-lang/rust/commit/c6e4db620a7d2f569f11dcab627430921ea8aacf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6e4db620a7d2f569f11dcab627430921ea8aacf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10ef7f9ebf8a497fe2ef8aa0d32b3776e85134a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/10ef7f9ebf8a497fe2ef8aa0d32b3776e85134a1", "html_url": "https://github.com/rust-lang/rust/commit/10ef7f9ebf8a497fe2ef8aa0d32b3776e85134a1"}, {"sha": "d72b7cc3298b2d651832ba789faf3665e01981de", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72b7cc3298b2d651832ba789faf3665e01981de", "html_url": "https://github.com/rust-lang/rust/commit/d72b7cc3298b2d651832ba789faf3665e01981de"}], "stats": {"total": 1028, "additions": 576, "deletions": 452}, "files": [{"sha": "03dbcc450246f742fbca3d6859f346790b0219db", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1022,14 +1022,21 @@ pub fn find_transparency(\n \n pub fn allow_internal_unstable<'a>(\n     sess: &'a Session,\n-    attrs: &[Attribute],\n+    attrs: &'a [Attribute],\n ) -> Option<impl Iterator<Item = Symbol> + 'a> {\n-    let attr = sess.find_by_name(attrs, sym::allow_internal_unstable)?;\n-    let list = attr.meta_item_list().or_else(|| {\n-        sess.diagnostic()\n-            .span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n-        None\n-    })?;\n+    let attrs = sess.filter_by_name(attrs, sym::allow_internal_unstable);\n+    let list = attrs\n+        .filter_map(move |attr| {\n+            attr.meta_item_list().or_else(|| {\n+                sess.diagnostic().span_err(\n+                    attr.span,\n+                    \"`allow_internal_unstable` expects a list of feature names\",\n+                );\n+                None\n+            })\n+        })\n+        .flatten();\n+\n     Some(list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {"}, {"sha": "ccd294d92b2f473f8036f2a0f595ec04c2e400a3", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -5,9 +5,9 @@ use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n-    /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n-    /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n-    /// add them to librustc_codegen_llvm/context.rs\n+    /// Remember to add all intrinsics here, in `compiler/rustc_typeck/src/check/mod.rs`,\n+    /// and in `library/core/src/intrinsics.rs`; if you need access to any LLVM intrinsics,\n+    /// add them to `compiler/rustc_codegen_llvm/src/context.rs`.\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "496174b28efac4cd65257d1b09d01fad33a53d50", "filename": "compiler/rustc_error_codes/src/error_codes/E0092.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -12,8 +12,8 @@ extern \"rust-intrinsic\" {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in `librustc_codegen_llvm/intrinsic.rs` and in\n-`libcore/intrinsics.rs` in the Rust source code. Example:\n+functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n+`library/core/src/intrinsics.rs` in the Rust source code. Example:\n \n ```\n #![feature(intrinsics)]"}, {"sha": "6d58e50ec8813d515f80c6925995c75890e18743", "filename": "compiler/rustc_error_codes/src/error_codes/E0093.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -17,8 +17,8 @@ fn main() {\n ```\n \n Please check you didn't make a mistake in the function's name. All intrinsic\n-functions are defined in `librustc_codegen_llvm/intrinsic.rs` and in\n-`libcore/intrinsics.rs` in the Rust source code. Example:\n+functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n+`library/core/src/intrinsics.rs` in the Rust source code. Example:\n \n ```\n #![feature(intrinsics)]"}, {"sha": "1dd6d590d908f36888dbda90131a49860c1fc5ea", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -28,7 +28,6 @@ pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, Selecti\n \n pub type CanonicalChalkEnvironmentAndGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n \n-pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n \n pub use self::chalk::{ChalkEnvironmentAndGoal, RustInterner as ChalkRustInterner};\n@@ -418,10 +417,10 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///\n ///     // Case B: ImplSource must be provided by caller. This applies when\n ///     // type is a type parameter.\n-///     param.clone();    // ImplSourceParam\n+///     param.clone();    // ImplSource::Param\n ///\n ///     // Case C: A mix of cases A and B.\n-///     mixed.clone();    // ImplSource(Impl_1, [ImplSourceParam])\n+///     mixed.clone();    // ImplSource(Impl_1, [ImplSource::Param])\n /// }\n /// ```\n ///\n@@ -431,72 +430,72 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n-    ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n+    UserDefined(ImplSourceUserDefinedData<'tcx, N>),\n \n     /// ImplSource for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n-    ImplSourceAutoImpl(ImplSourceAutoImplData<N>),\n+    AutoImpl(ImplSourceAutoImplData<N>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n     /// any).\n-    ImplSourceParam(Vec<N>),\n+    Param(Vec<N>),\n \n     /// Virtual calls through an object.\n-    ImplSourceObject(ImplSourceObjectData<'tcx, N>),\n+    Object(ImplSourceObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n-    ImplSourceBuiltin(ImplSourceBuiltinData<N>),\n+    Builtin(ImplSourceBuiltinData<N>),\n \n     /// ImplSource automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `ImplSourceUserDefined` in spirit, but the\n+    /// of the closure expression. This is a `ImplSource::UserDefined` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    ImplSourceClosure(ImplSourceClosureData<'tcx, N>),\n+    Closure(ImplSourceClosureData<'tcx, N>),\n \n     /// Same as above, but for a function pointer type with the given signature.\n-    ImplSourceFnPointer(ImplSourceFnPointerData<'tcx, N>),\n+    FnPointer(ImplSourceFnPointerData<'tcx, N>),\n \n     /// ImplSource for a builtin `DeterminantKind` trait implementation.\n-    ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData),\n+    DiscriminantKind(ImplSourceDiscriminantKindData),\n \n     /// ImplSource automatically generated for a generator.\n-    ImplSourceGenerator(ImplSourceGeneratorData<'tcx, N>),\n+    Generator(ImplSourceGeneratorData<'tcx, N>),\n \n     /// ImplSource for a trait alias.\n-    ImplSourceTraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n+    TraitAlias(ImplSourceTraitAliasData<'tcx, N>),\n }\n \n impl<'tcx, N> ImplSource<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {\n-            ImplSourceUserDefined(i) => i.nested,\n-            ImplSourceParam(n) => n,\n-            ImplSourceBuiltin(i) => i.nested,\n-            ImplSourceAutoImpl(d) => d.nested,\n-            ImplSourceClosure(c) => c.nested,\n-            ImplSourceGenerator(c) => c.nested,\n-            ImplSourceObject(d) => d.nested,\n-            ImplSourceFnPointer(d) => d.nested,\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n-            ImplSourceTraitAlias(d) => d.nested,\n+            ImplSource::UserDefined(i) => i.nested,\n+            ImplSource::Param(n) => n,\n+            ImplSource::Builtin(i) => i.nested,\n+            ImplSource::AutoImpl(d) => d.nested,\n+            ImplSource::Closure(c) => c.nested,\n+            ImplSource::Generator(c) => c.nested,\n+            ImplSource::Object(d) => d.nested,\n+            ImplSource::FnPointer(d) => d.nested,\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n+            ImplSource::TraitAlias(d) => d.nested,\n         }\n     }\n \n     pub fn borrow_nested_obligations(&self) -> &[N] {\n         match &self {\n-            ImplSourceUserDefined(i) => &i.nested[..],\n-            ImplSourceParam(n) => &n[..],\n-            ImplSourceBuiltin(i) => &i.nested[..],\n-            ImplSourceAutoImpl(d) => &d.nested[..],\n-            ImplSourceClosure(c) => &c.nested[..],\n-            ImplSourceGenerator(c) => &c.nested[..],\n-            ImplSourceObject(d) => &d.nested[..],\n-            ImplSourceFnPointer(d) => &d.nested[..],\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n-            ImplSourceTraitAlias(d) => &d.nested[..],\n+            ImplSource::UserDefined(i) => &i.nested[..],\n+            ImplSource::Param(n) => &n[..],\n+            ImplSource::Builtin(i) => &i.nested[..],\n+            ImplSource::AutoImpl(d) => &d.nested[..],\n+            ImplSource::Closure(c) => &c.nested[..],\n+            ImplSource::Generator(c) => &c.nested[..],\n+            ImplSource::Object(d) => &d.nested[..],\n+            ImplSource::FnPointer(d) => &d.nested[..],\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n+            ImplSource::TraitAlias(d) => &d.nested[..],\n         }\n     }\n \n@@ -505,42 +504,42 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n         F: FnMut(N) -> M,\n     {\n         match self {\n-            ImplSourceUserDefined(i) => ImplSourceUserDefined(ImplSourceUserDefinedData {\n+            ImplSource::UserDefined(i) => ImplSource::UserDefined(ImplSourceUserDefinedData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceParam(n) => ImplSourceParam(n.into_iter().map(f).collect()),\n-            ImplSourceBuiltin(i) => ImplSourceBuiltin(ImplSourceBuiltinData {\n+            ImplSource::Param(n) => ImplSource::Param(n.into_iter().map(f).collect()),\n+            ImplSource::Builtin(i) => ImplSource::Builtin(ImplSourceBuiltinData {\n                 nested: i.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceObject(o) => ImplSourceObject(ImplSourceObjectData {\n+            ImplSource::Object(o) => ImplSource::Object(ImplSourceObjectData {\n                 upcast_trait_ref: o.upcast_trait_ref,\n                 vtable_base: o.vtable_base,\n                 nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceAutoImpl(d) => ImplSourceAutoImpl(ImplSourceAutoImplData {\n+            ImplSource::AutoImpl(d) => ImplSource::AutoImpl(ImplSourceAutoImplData {\n                 trait_def_id: d.trait_def_id,\n                 nested: d.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceClosure(c) => ImplSourceClosure(ImplSourceClosureData {\n+            ImplSource::Closure(c) => ImplSource::Closure(ImplSourceClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceGenerator(c) => ImplSourceGenerator(ImplSourceGeneratorData {\n+            ImplSource::Generator(c) => ImplSource::Generator(ImplSourceGeneratorData {\n                 generator_def_id: c.generator_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceFnPointer(p) => ImplSourceFnPointer(ImplSourceFnPointerData {\n+            ImplSource::FnPointer(p) => ImplSource::FnPointer(ImplSourceFnPointerData {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData) => {\n-                ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData)\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n+                ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n             }\n-            ImplSourceTraitAlias(d) => ImplSourceTraitAlias(ImplSourceTraitAliasData {\n+            ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n                 nested: d.nested.into_iter().map(f).collect(),"}, {"sha": "b8f6675b8e2197778c53271ad1c3093ba10258a3", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -7,25 +7,25 @@ use std::fmt;\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            super::ImplSourceUserDefined(ref v) => write!(f, \"{:?}\", v),\n+            super::ImplSource::UserDefined(ref v) => write!(f, \"{:?}\", v),\n \n-            super::ImplSourceAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+            super::ImplSource::AutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::ImplSourceClosure(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Closure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceGenerator(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Generator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceFnPointer(ref d) => write!(f, \"ImplSourceFnPointer({:?})\", d),\n+            super::ImplSource::FnPointer(ref d) => write!(f, \"({:?})\", d),\n \n-            super::ImplSourceDiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceObject(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceParam(ref n) => write!(f, \"ImplSourceParam({:?})\", n),\n+            super::ImplSource::Param(ref n) => write!(f, \"ImplSourceParamData({:?})\", n),\n \n-            super::ImplSourceBuiltin(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::Builtin(ref d) => write!(f, \"{:?}\", d),\n \n-            super::ImplSourceTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+            super::ImplSource::TraitAlias(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n@@ -96,7 +96,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n-            \"ImplSourceTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            \"ImplSourceTraitAliasData(alias_def_id={:?}, substs={:?}, nested={:?})\",\n             self.alias_def_id, self.substs, self.nested\n         )\n     }"}, {"sha": "d3b6d706337edb90e445a67486b06fdef60f2453", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -435,6 +435,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // These just return their argument\n                 self.copy_op(args[0], dest)?;\n             }\n+            sym::assume => {\n+                let cond = self.read_scalar(args[0])?.check_init()?.to_bool()?;\n+                if !cond {\n+                    throw_ub_format!(\"`assume` intrinsic called with `false`\");\n+                }\n+            }\n             _ => return Ok(false),\n         }\n "}, {"sha": "9f200ca62b8c606c6ae2d62980c8b41ffe985506", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -390,9 +390,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let mut args = args.to_vec();\n                 // We have to implement all \"object safe receivers\".  Currently we\n-                // support built-in pointers (&, &mut, Box) as well as unsized-self.  We do\n+                // support built-in pointers `(&, &mut, Box)` as well as unsized-self.  We do\n                 // not yet support custom self types.\n-                // Also see librustc_codegen_llvm/abi.rs and librustc_codegen_llvm/mir/block.rs.\n+                // Also see `compiler/rustc_codegen_llvm/src/abi.rs` and `compiler/rustc_codegen_ssa/src/mir/block.rs`.\n                 let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n                     Some(_) => {\n                         // Built-in pointer."}, {"sha": "d2586f0f84dffbe79a97a7d89f2798b89f89cc9b", "filename": "compiler/rustc_mir/src/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -21,7 +21,7 @@ pub fn custom_coerce_unsize_info<'tcx>(\n     });\n \n     match tcx.codegen_fulfill_obligation((ty::ParamEnv::reveal_all(), trait_ref)) {\n-        Ok(traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n+        Ok(traits::ImplSource::UserDefined(traits::ImplSourceUserDefinedData {\n             impl_def_id,\n             ..\n         })) => tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap(),"}, {"sha": "97d261760772b1f58c9c9ebb521ba9e4a700390b", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -905,7 +905,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n             // FIXME: This can be smarter and take `StorageDead` into account (which\n             // invalidates borrows).\n             if self.ever_borrowed_locals.contains(dest.local)\n-                && self.ever_borrowed_locals.contains(src.local)\n+                || self.ever_borrowed_locals.contains(src.local)\n             {\n                 return;\n             }"}, {"sha": "98ded4189cf1966dee590491f19efa8edf25e52a", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -369,7 +369,7 @@ fn has_allow_dead_code_or_lang_attr(\n //         - This is because lang items are always callable from elsewhere.\n //   or\n //   2) We are not sure to be live or not\n-//     * Implementation of a trait method\n+//     * Implementations of traits and trait methods\n struct LifeSeeder<'k, 'tcx> {\n     worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate<'k>,\n@@ -415,6 +415,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Impl { ref of_trait, items, .. } => {\n+                if of_trait.is_some() {\n+                    self.worklist.push(item.hir_id);\n+                }\n                 for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if of_trait.is_some()"}, {"sha": "35bfeff10b4aa7e7451cd89380c0fe34cb035358", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             ));\n \n             match result {\n-                Ok(Some(ImplSource::ImplSourceUserDefined(_))) => {\n+                Ok(Some(ImplSource::UserDefined(_))) => {\n                     debug!(\n                         \"find_auto_trait_generics({:?}): \\\n                          manual impl found, bailing out\",\n@@ -315,9 +315,8 @@ impl AutoTraitFinder<'tcx> {\n                     // If we see an explicit negative impl (e.g., `impl !Send for MyStruct`),\n                     // we immediately bail out, since it's impossible for us to continue.\n \n-                    if let ImplSource::ImplSourceUserDefined(ImplSourceUserDefinedData {\n-                        impl_def_id,\n-                        ..\n+                    if let ImplSource::UserDefined(ImplSourceUserDefinedData {\n+                        impl_def_id, ..\n                     }) = impl_source\n                     {\n                         // Blame 'tidy' for the weird bracket placement."}, {"sha": "ef8f7b69b5d6067a27e04bbd01ca468be47b4e95", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1000,15 +1000,15 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n         };\n \n         let eligible = match &impl_source {\n-            super::ImplSourceClosure(_)\n-            | super::ImplSourceGenerator(_)\n-            | super::ImplSourceFnPointer(_)\n-            | super::ImplSourceObject(_)\n-            | super::ImplSourceTraitAlias(_) => {\n+            super::ImplSource::Closure(_)\n+            | super::ImplSource::Generator(_)\n+            | super::ImplSource::FnPointer(_)\n+            | super::ImplSource::Object(_)\n+            | super::ImplSource::TraitAlias(_) => {\n                 debug!(\"assemble_candidates_from_impls: impl_source={:?}\", impl_source);\n                 true\n             }\n-            super::ImplSourceUserDefined(impl_data) => {\n+            super::ImplSource::UserDefined(impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // codegen (i.e., projection mode is not \"any\"), and the\n@@ -1060,7 +1060,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     }\n                 }\n             }\n-            super::ImplSourceDiscriminantKind(..) => {\n+            super::ImplSource::DiscriminantKind(..) => {\n                 // While `DiscriminantKind` is automatically implemented for every type,\n                 // the concrete discriminant may not be known yet.\n                 //\n@@ -1100,7 +1100,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     | ty::Error(_) => false,\n                 }\n             }\n-            super::ImplSourceParam(..) => {\n+            super::ImplSource::Param(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:\n                 //\n@@ -1128,7 +1128,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // in `assemble_candidates_from_param_env`.\n                 false\n             }\n-            super::ImplSourceAutoImpl(..) | super::ImplSourceBuiltin(..) => {\n+            super::ImplSource::AutoImpl(..) | super::ImplSource::Builtin(..) => {\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n                     obligation.cause.span,\n@@ -1186,20 +1186,20 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     impl_source: Selection<'tcx>,\n ) -> Progress<'tcx> {\n     match impl_source {\n-        super::ImplSourceUserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n-        super::ImplSourceGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n-        super::ImplSourceClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n-        super::ImplSourceFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::ImplSourceDiscriminantKind(data) => {\n+        super::ImplSource::UserDefined(data) => confirm_impl_candidate(selcx, obligation, data),\n+        super::ImplSource::Generator(data) => confirm_generator_candidate(selcx, obligation, data),\n+        super::ImplSource::Closure(data) => confirm_closure_candidate(selcx, obligation, data),\n+        super::ImplSource::FnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::ImplSource::DiscriminantKind(data) => {\n             confirm_discriminant_kind_candidate(selcx, obligation, data)\n         }\n-        super::ImplSourceObject(_) => {\n+        super::ImplSource::Object(_) => {\n             confirm_object_candidate(selcx, obligation, obligation_trait_ref)\n         }\n-        super::ImplSourceAutoImpl(..)\n-        | super::ImplSourceParam(..)\n-        | super::ImplSourceBuiltin(..)\n-        | super::ImplSourceTraitAlias(..) =>\n+        super::ImplSource::AutoImpl(..)\n+        | super::ImplSource::Param(..)\n+        | super::ImplSource::Builtin(..)\n+        | super::ImplSource::TraitAlias(..) =>\n         // we don't create Select candidates with this kind of resolution\n         {\n             span_bug!("}, {"sha": "88b656ce6808273c8e37b0d8decf56f4e533ceef", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -19,16 +19,12 @@ use crate::traits::project::{self, normalize_with_depth};\n use crate::traits::select::TraitObligationExt;\n use crate::traits::util;\n use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::ImplSource;\n use crate::traits::Normalized;\n use crate::traits::OutputTypeParameterMismatch;\n use crate::traits::Selection;\n use crate::traits::TraitNotObjectSafe;\n use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n-use crate::traits::{\n-    ImplSourceAutoImpl, ImplSourceBuiltin, ImplSourceClosure, ImplSourceDiscriminantKind,\n-    ImplSourceFnPointer, ImplSourceGenerator, ImplSourceObject, ImplSourceParam,\n-    ImplSourceTraitAlias, ImplSourceUserDefined,\n-};\n use crate::traits::{\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceDiscriminantKindData, ImplSourceFnPointerData, ImplSourceGeneratorData,\n@@ -55,67 +51,67 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match candidate {\n             BuiltinCandidate { has_nested } => {\n                 let data = self.confirm_builtin_candidate(obligation, has_nested);\n-                Ok(ImplSourceBuiltin(data))\n+                Ok(ImplSource::Builtin(data))\n             }\n \n             ParamCandidate(param) => {\n                 let obligations = self.confirm_param_candidate(obligation, param);\n-                Ok(ImplSourceParam(obligations))\n+                Ok(ImplSource::Param(obligations))\n             }\n \n             ImplCandidate(impl_def_id) => {\n-                Ok(ImplSourceUserDefined(self.confirm_impl_candidate(obligation, impl_def_id)))\n+                Ok(ImplSource::UserDefined(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n             AutoImplCandidate(trait_def_id) => {\n                 let data = self.confirm_auto_impl_candidate(obligation, trait_def_id);\n-                Ok(ImplSourceAutoImpl(data))\n+                Ok(ImplSource::AutoImpl(data))\n             }\n \n             ProjectionCandidate => {\n                 self.confirm_projection_candidate(obligation);\n-                Ok(ImplSourceParam(Vec::new()))\n+                Ok(ImplSource::Param(Vec::new()))\n             }\n \n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n-                Ok(ImplSourceClosure(vtable_closure))\n+                Ok(ImplSource::Closure(vtable_closure))\n             }\n \n             GeneratorCandidate => {\n                 let vtable_generator = self.confirm_generator_candidate(obligation)?;\n-                Ok(ImplSourceGenerator(vtable_generator))\n+                Ok(ImplSource::Generator(vtable_generator))\n             }\n \n             FnPointerCandidate => {\n                 let data = self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(ImplSourceFnPointer(data))\n+                Ok(ImplSource::FnPointer(data))\n             }\n \n             DiscriminantKindCandidate => {\n-                Ok(ImplSourceDiscriminantKind(ImplSourceDiscriminantKindData))\n+                Ok(ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData))\n             }\n \n             TraitAliasCandidate(alias_def_id) => {\n                 let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n-                Ok(ImplSourceTraitAlias(data))\n+                Ok(ImplSource::TraitAlias(data))\n             }\n \n             ObjectCandidate => {\n                 let data = self.confirm_object_candidate(obligation);\n-                Ok(ImplSourceObject(data))\n+                Ok(ImplSource::Object(data))\n             }\n \n             BuiltinObjectCandidate => {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n                 // no additional obligations to prove and no types in particular to unify, etc.\n-                Ok(ImplSourceParam(Vec::new()))\n+                Ok(ImplSource::Param(Vec::new()))\n             }\n \n             BuiltinUnsizeCandidate => {\n                 let data = self.confirm_builtin_unsize_candidate(obligation)?;\n-                Ok(ImplSourceBuiltin(data))\n+                Ok(ImplSource::Builtin(data))\n             }\n         }\n     }"}, {"sha": "220f4cec742f1f5aa80114258dec6c48b4da5e43", "filename": "compiler/rustc_ty/src/instance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Finstance.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -119,9 +119,9 @@ fn resolve_associated_item<'tcx>(\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     Ok(match vtbl {\n-        traits::ImplSourceUserDefined(impl_data) => {\n+        traits::ImplSource::UserDefined(impl_data) => {\n             debug!(\n-                \"resolving ImplSourceUserDefined: {:?}, {:?}, {:?}, {:?}\",\n+                \"resolving ImplSource::UserDefined: {:?}, {:?}, {:?}, {:?}\",\n                 param_env, trait_item, rcvr_substs, impl_data\n             );\n             assert!(!rcvr_substs.needs_infer());\n@@ -216,13 +216,13 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSourceGenerator(generator_data) => Some(Instance {\n+        traits::ImplSource::Generator(generator_data) => Some(Instance {\n             def: ty::InstanceDef::Item(ty::WithOptConstParam::unknown(\n                 generator_data.generator_def_id,\n             )),\n             substs: generator_data.substs,\n         }),\n-        traits::ImplSourceClosure(closure_data) => {\n+        traits::ImplSource::Closure(closure_data) => {\n             let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n@@ -231,18 +231,18 @@ fn resolve_associated_item<'tcx>(\n                 trait_closure_kind,\n             ))\n         }\n-        traits::ImplSourceFnPointer(ref data) => match data.fn_ty.kind() {\n+        traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n             ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n                 def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n                 substs: rcvr_substs,\n             }),\n             _ => None,\n         },\n-        traits::ImplSourceObject(ref data) => {\n+        traits::ImplSource::Object(ref data) => {\n             let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n-        traits::ImplSourceBuiltin(..) => {\n+        traits::ImplSource::Builtin(..) => {\n             if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n                 let name = tcx.item_name(def_id);\n@@ -271,10 +271,10 @@ fn resolve_associated_item<'tcx>(\n                 None\n             }\n         }\n-        traits::ImplSourceAutoImpl(..)\n-        | traits::ImplSourceParam(..)\n-        | traits::ImplSourceTraitAlias(..)\n-        | traits::ImplSourceDiscriminantKind(..) => None,\n+        traits::ImplSource::AutoImpl(..)\n+        | traits::ImplSource::Param(..)\n+        | traits::ImplSource::TraitAlias(..)\n+        | traits::ImplSource::DiscriminantKind(..) => None,\n     })\n }\n "}, {"sha": "2ee867c2dd648cace4e3dd1015a29ffce6d44fee", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -106,8 +106,8 @@ pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n     }\n }\n \n-/// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n-/// and in libcore/intrinsics.rs\n+/// Remember to add all intrinsics here, in `compiler/rustc_codegen_llvm/src/intrinsic.rs`,\n+/// and in `library/core/src/intrinsics.rs`.\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();"}, {"sha": "c1ba29284da16b73956a7fab4dea6a16cd0e160d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1306,7 +1306,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .at(&ObligationCause::dummy(), self.param_env)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n-                    Ok(Some(traits::ImplSource::ImplSourceUserDefined(ref impl_data))) => {\n+                    Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n                         // to that impl.\n                         ImplSource(impl_data.impl_def_id)"}, {"sha": "c5efb8ed5e51cef43075490a418ec6ab7047bb57", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -36,8 +36,8 @@ changelog-seen = 1\n # toolchain or changing LLVM locally, you probably want to set this to true.\n #\n # It's currently false by default due to being newly added; please file bugs if\n-# enabling this did not work for you on Linux (macOS and Windows support is\n-# coming soon).\n+# enabling this did not work for you on x86_64-unknown-linux-gnu.\n+# Other target triples are currently not supported; see #77084.\n #\n # We also currently only support this when building LLVM for the build triple.\n #\n@@ -380,7 +380,7 @@ changelog-seen = 1\n \n # Whether or not to leave debug! and trace! calls in the rust binary.\n # Overrides the `debug-assertions` option, if defined.\n-# \n+#\n # Defaults to rust.debug-assertions value\n #debug-logging = debug-assertions\n "}, {"sha": "c3f27c105994fc81cdf046442201b345fbf5b36f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 99, "deletions": 110, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -47,8 +47,7 @@ const KV_IDX_CENTER: usize = B - 1;\n const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n \n-/// The underlying representation of leaf nodes.\n-#[repr(C)]\n+/// The underlying representation of leaf nodes and part of the representation of internal nodes.\n struct LeafNode<K, V> {\n     /// We want to be covariant in `K` and `V`.\n     parent: Option<NonNull<InternalNode<K, V>>>,\n@@ -59,9 +58,6 @@ struct LeafNode<K, V> {\n     parent_idx: MaybeUninit<u16>,\n \n     /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n@@ -92,7 +88,9 @@ impl<K, V> LeafNode<K, V> {\n /// node, allowing code to act on leaf and internal nodes generically without having to even check\n /// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n+// gdb_providers.py uses this type name for introspection.\n struct InternalNode<K, V> {\n+    // gdb_providers.py uses this field name for introspection.\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n@@ -183,9 +181,9 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n-    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of\n-    /// `pop_internal_level`.\n+    /// Adds a new internal node with a single edge pointing to the previous root node,\n+    /// make that new node the root node, and return it. This increases the height by 1\n+    /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n@@ -322,7 +320,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node.\n+    /// Exposes the leaf portion of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -351,7 +349,22 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     unsafe fn val_at(&self, idx: usize) -> &V {\n         unsafe { self.reborrow().into_val_at(idx) }\n     }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Borrows a reference to the contents of one of the edges that delimit\n+    /// the elements of the node, without invalidating other references.\n+    ///\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn edge_at(&self, idx: usize) -> &BoxedNode<K, V> {\n+        debug_assert!(idx <= self.len());\n+        let node = self.as_internal_ptr();\n+        unsafe { (*node).edges.get_unchecked(idx).assume_init_ref() }\n+    }\n+}\n \n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n     /// that points to the current node. Returns `Err(self)` if the current node has\n@@ -457,7 +470,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// Exposes the leaf portion of any leaf or internal node for writing.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -483,18 +496,49 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n     }\n \n-    fn keys_mut(&mut self) -> &mut [K] {\n+    fn keys_mut(&mut self) -> &mut [K]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the key slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    fn vals_mut(&mut self) -> &mut [V] {\n+    fn vals_mut(&mut self) -> &mut [V]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the value slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n+                self.len(),\n+            )\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    fn edges_mut(&mut self) -> &mut [BoxedNode<K, V>] {\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n+                self.len() + 1,\n+            )\n+        }\n     }\n }\n \n@@ -513,26 +557,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // SAFETY: The keys of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        // SAFETY: The values of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n     unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n@@ -584,8 +608,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n-    pub fn push_front(&mut self, key: K, val: V) {\n-        assert!(self.len() < CAPACITY);\n+    fn push_front(&mut self, key: K, val: V) {\n+        debug_assert!(self.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -597,18 +621,17 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// # Safety\n-    /// 'first' and 'after_last' must be in range.\n-    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n-        debug_assert!(first <= self.len());\n-        debug_assert!(after_last <= self.len() + 1);\n-        for i in first..after_last {\n+    /// Every item returned by `range` is a valid edge index for the node.\n+    unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {\n+        for i in range {\n+            debug_assert!(i <= self.len());\n             unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n         }\n     }\n \n     fn correct_all_childrens_parent_links(&mut self) {\n         let len = self.len();\n-        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n+        unsafe { self.correct_childrens_parent_links(0..=len) };\n     }\n }\n \n@@ -658,10 +681,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node and returns the pair.\n     /// If this is an internal node, also removes the edge that was to the right\n-    /// of that pair and returns the orphaned node that this edge owned with its\n-    /// parent erased.\n-    pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -670,9 +692,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let val = ptr::read(self.val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n-                ForceResult::Internal(mut internal) => {\n-                    let edge =\n-                        ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n+                ForceResult::Internal(internal) => {\n+                    let edge = ptr::read(internal.edge_at(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n                     Some(new_root)\n@@ -684,10 +705,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n-    /// also removes the edge that was to the left of that pair.\n-    pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// Removes a key/value pair from the beginning of this node and returns the pair.\n+    /// If this is an internal node, also removes the edge that was to the left\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -697,20 +719,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let edge = slice_remove(\n-                        slice::from_raw_parts_mut(\n-                            MaybeUninit::slice_as_mut_ptr(&mut internal.as_internal_mut().edges),\n-                            old_len + 1,\n-                        ),\n-                        0,\n-                    );\n-\n+                    let edge = slice_remove(internal.edges_mut(), 0);\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n \n-                    for i in 0..old_len {\n-                        Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n-                    }\n+                    internal.correct_childrens_parent_links(0..old_len);\n \n                     Some(new_root)\n                 }\n@@ -898,7 +911,6 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n     fn leafy_insert_fit(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n@@ -936,18 +948,18 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let val_ptr = match insertion {\n+            let mut insertion_edge = match insertion {\n                 InsertionPlace::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n                         insert_idx,\n                     )\n-                    .insert_fit(key, val)\n                 },\n             };\n+            let val_ptr = insertion_edge.insert_fit(key, val);\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), val_ptr)\n         }\n     }\n@@ -970,25 +982,13 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but in an internal module\n-        debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n             self.leafy_insert_fit(key, val);\n \n-            slice_insert(\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::slice_as_mut_ptr(&mut self.node.as_internal_mut().edges),\n-                    self.node.len(),\n-                ),\n-                self.idx + 1,\n-                edge.node,\n-            );\n-\n-            for i in (self.idx + 1)..(self.node.len() + 1) {\n-                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n-            }\n+            self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n     }\n \n@@ -1131,12 +1131,12 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n             ptr::copy_nonoverlapping(\n                 self.node.key_at(self.idx + 1),\n-                new_node.keys.as_mut_ptr() as *mut K,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.val_at(self.idx + 1),\n-                new_node.vals.as_mut_ptr() as *mut V,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.vals),\n                 new_len,\n             );\n \n@@ -1215,9 +1215,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n \n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            for i in 0..(new_len + 1) {\n-                Handle::new_edge(new_root.node_as_mut().cast_unchecked(), i).correct_parent_link();\n-            }\n+            new_root.node_as_mut().cast_unchecked().correct_childrens_parent_links(0..=new_len);\n \n             (self.node, k, v, new_root)\n         }\n@@ -1260,28 +1258,25 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.as_internal_mut().edges, self.idx + 1);\n-            for i in self.idx + 1..self.node.len() {\n-                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n-            }\n+            slice_remove(&mut self.node.edges_mut(), self.idx + 1);\n+            let self_len = self.node.len();\n+            self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n             self.node.as_leaf_mut().len -= 1;\n \n             left_node.as_leaf_mut().len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n-                let mut left_node = left_node.cast_unchecked();\n-                let mut right_node = right_node.cast_unchecked();\n+                let mut left_node = left_node.cast_unchecked::<marker::Internal>();\n+                let right_node = right_node.cast_unchecked::<marker::Internal>();\n                 ptr::copy_nonoverlapping(\n-                    right_node.as_internal().edges.as_ptr(),\n-                    left_node.as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n+                    right_node.edge_at(0),\n+                    left_node.edges_mut().as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n-                for i in left_len + 1..left_len + right_len + 2 {\n-                    Handle::new_edge(left_node.reborrow_mut(), i).correct_parent_link();\n-                }\n+                left_node.correct_childrens_parent_links(left_len + 1..=left_len + 1 + right_len);\n \n                 Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n@@ -1371,14 +1366,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     // Make room for stolen edges.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n-                    right.correct_childrens_parent_links(count, count + right_len + 1);\n+                    right.correct_childrens_parent_links(count..count + right_len + 1);\n \n                     move_edges(left, new_left_len + 1, right, 0, count);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1430,12 +1423,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     // Fix right indexing.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n-                    right.correct_childrens_parent_links(0, new_right_len + 1);\n+                    right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1466,7 +1457,7 @@ unsafe fn move_edges<K, V>(\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n     unsafe {\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n-        dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+        dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n }\n \n@@ -1568,9 +1559,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n                         move_edges(left, left_new_len + 1, right, 1, right_new_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                    _ => {\n-                        unreachable!();\n-                    }\n+                    _ => unreachable!(),\n                 }\n             }\n         }"}, {"sha": "cfa899377942d86e6f56f58fa294dd3023940f1b", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -2099,7 +2099,6 @@ impl<T> Extend<T> for Vec<T> {\n /// |  slice::Iter                    |  |                     |\n /// |  Iterator<Item = &Clone>        |  +---------------------+\n /// +---------------------------------+\n-///\n /// ```\n trait SpecFromIter<T, I> {\n     fn from_iter(iter: I) -> Self;"}, {"sha": "243fc7bfaa51f090ff7a672eac19e6b7185b9877", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1,7 +1,7 @@\n //! Compiler intrinsics.\n //!\n-//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n-//! The corresponding const implementations are in `librustc_mir/interpret/intrinsics.rs`\n+//! The corresponding definitions are in `compiler/rustc_codegen_llvm/src/intrinsic.rs`.\n+//! The corresponding const implementations are in `compiler/rustc_mir/src/interpret/intrinsics.rs`\n //!\n //! # Const intrinsics\n //!\n@@ -10,7 +10,7 @@\n //!\n //! In order to make an intrinsic usable at compile-time, one needs to copy the implementation\n //! from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to\n-//! `librustc_mir/interpret/intrinsics.rs` and add a\n+//! `compiler/rustc_mir/src/interpret/intrinsics.rs` and add a\n //! `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` to the intrinsic.\n //!\n //! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n@@ -733,6 +733,7 @@ extern \"rust-intrinsic\" {\n     /// own, or if it does not enable any significant optimizations.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n@@ -904,7 +905,7 @@ extern \"rust-intrinsic\" {\n     /// let raw_bytes = [0x78, 0x56, 0x34, 0x12];\n     ///\n     /// let num = unsafe {\n-    ///     std::mem::transmute::<[u8; 4], u32>(raw_bytes);\n+    ///     std::mem::transmute::<[u8; 4], u32>(raw_bytes)\n     /// };\n     ///\n     /// // use `u32::from_ne_bytes` instead"}, {"sha": "12dcd6c6ba8d04087838c8f3205c71ae5c71c76e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -433,8 +433,9 @@ impl<T> [T] {\n     /// assert_eq!(x, &[3, 4, 6]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n+    pub const fn as_mut_ptr(&mut self) -> *mut T {\n         self as *mut [T] as *mut T\n     }\n \n@@ -469,8 +470,9 @@ impl<T> [T] {\n     ///\n     /// [`as_ptr`]: #method.as_ptr\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn as_ptr_range(&self) -> Range<*const T> {\n+    pub const fn as_ptr_range(&self) -> Range<*const T> {\n         let start = self.as_ptr();\n         // SAFETY: The `add` here is safe, because:\n         //\n@@ -510,8 +512,9 @@ impl<T> [T] {\n     ///\n     /// [`as_mut_ptr`]: #method.as_mut_ptr\n     #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n+    pub const fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n         let start = self.as_mut_ptr();\n         // SAFETY: See as_ptr_range() above for why `add` here is safe.\n         let end = unsafe { start.add(self.len()) };"}, {"sha": "de163a60c98f42686e4a1277b234c55befb5698e", "filename": "library/core/tests/intrinsics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fintrinsics.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1,4 +1,5 @@\n use core::any::TypeId;\n+use core::intrinsics::assume;\n \n #[test]\n fn test_typeid_sized_types() {\n@@ -20,3 +21,17 @@ fn test_typeid_unsized_types() {\n     assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n     assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n }\n+\n+// Check that `const_assume` feature allow `assume` intrinsic\n+// to be used in const contexts.\n+#[test]\n+fn test_assume_can_be_in_const_contexts() {\n+    const unsafe fn foo(x: usize, y: usize) -> usize {\n+        // SAFETY: the entire function is not safe,\n+        // but it is just an example not used elsewhere.\n+        unsafe { assume(y != 0) };\n+        x / y\n+    }\n+    let rs = unsafe { foo(42, 97) };\n+    assert_eq!(rs, 0);\n+}"}, {"sha": "8d86349244b0908f2a96d3e3c061f0ae0568ccde", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -8,6 +8,8 @@\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n+#![feature(const_assume)]\n+#![feature(core_intrinsics)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(debug_non_exhaustive)]"}, {"sha": "5597bbb93d236fc711c0793e54c051127c191b25", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -175,7 +175,7 @@ pub struct _TypeDescriptor {\n // to be able to catch Rust panics by simply declaring a `struct rust_panic`.\n //\n // When modifying, make sure that the type name string exactly matches\n-// the one used in src/librustc_codegen_llvm/intrinsic.rs.\n+// the one used in `compiler/rustc_codegen_llvm/src/intrinsic.rs`.\n const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {"}, {"sha": "7e2155dae6fce6ebe2610f012f7c877107ecf398", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -78,13 +78,9 @@ impl WaitTimeoutResult {\n /// and a mutex. The predicate is always verified inside of the mutex before\n /// determining that a thread must block.\n ///\n-/// Functions in this module will block the current **thread** of execution and\n-/// are bindings to system-provided condition variables where possible. Note\n-/// that this module places one additional restriction over the system condition\n-/// variables: each condvar can be used with precisely one mutex at runtime. Any\n-/// attempt to use multiple mutexes on the same condition variable will result\n-/// in a runtime panic. If this is not desired, then the unsafe primitives in\n-/// `sys` do not have this restriction but may result in undefined behavior.\n+/// Functions in this module will block the current **thread** of execution.\n+/// Note that any attempt to use multiple mutexes on the same condition\n+/// variable may result in a runtime panic.\n ///\n /// # Examples\n ///\n@@ -159,10 +155,8 @@ impl Condvar {\n     ///\n     /// # Panics\n     ///\n-    /// This function will [`panic!`] if it is used with more than one mutex\n-    /// over time. Each condition variable is dynamically bound to exactly one\n-    /// mutex to ensure defined behavior across platforms. If this functionality\n-    /// is not desired, then unsafe primitives in `sys` are provided.\n+    /// This function may [`panic!`] if it is used with more than one mutex\n+    /// over time.\n     ///\n     /// [`notify_one`]: Self::notify_one\n     /// [`notify_all`]: Self::notify_all"}, {"sha": "1510f4d59fa3474c66e31fecc6fd1c182ca3e16d", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -15,6 +15,10 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - Make the default stage for x.py configurable [#76625](https://github.com/rust-lang/rust/pull/76625)\n - Add a dedicated debug-logging option [#76588](https://github.com/rust-lang/rust/pull/76588)\n - Add sample defaults for x.py [#76628](https://github.com/rust-lang/rust/pull/76628)\n+- Add `--keep-stage-std`, which behaves like `keep-stage` but allows the stage\n+  0 compiler artifacts (i.e., stage1/bin/rustc) to be rebuilt if changed\n+  [#77120](https://github.com/rust-lang/rust/pull/77120).\n+\n \n ## [Version 0] - 2020-09-11\n "}, {"sha": "6af13fc83d0ef94131a0d6d79c09fed1583513ce", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -40,7 +40,7 @@ fn check_version(config: &Config) -> Option<String> {\n         }\n     } else {\n         msg.push_str(\"warning: x.py has made several changes recently you may want to look at\\n\");\n-        format!(\"add `changelog-seen = {}` to `config.toml`\", VERSION)\n+        format!(\"add `changelog-seen = {}` at the top of `config.toml`\", VERSION)\n     };\n \n     msg.push_str(\"help: consider looking at the changes in `src/bootstrap/CHANGELOG.md`\\n\");"}, {"sha": "5c9184f450687c74a387e3dea13154f000069d81", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -424,8 +424,19 @@ def download_stage0(self):\n                     rustfmt_stamp.write(self.date + self.rustfmt_channel)\n \n         if self.downloading_llvm():\n-            llvm_sha = subprocess.check_output([\"git\", \"log\", \"--author=bors\",\n-                \"--format=%H\", \"-n1\"]).decode(sys.getdefaultencoding()).strip()\n+            # We want the most recent LLVM submodule update to avoid downloading\n+            # LLVM more often than necessary.\n+            #\n+            # This git command finds that commit SHA, looking for bors-authored\n+            # merges that modified src/llvm-project.\n+            #\n+            # This works even in a repository that has not yet initialized\n+            # submodules.\n+            llvm_sha = subprocess.check_output([\n+                \"git\", \"log\", \"--author=bors\", \"--format=%H\", \"-n1\",\n+                \"-m\", \"--first-parent\",\n+                \"--\", \"src/llvm-project\"\n+            ]).decode(sys.getdefaultencoding()).strip()\n             llvm_assertions = self.get_toml('assertions', 'llvm') == 'true'\n             if self.program_out_of_date(self.llvm_stamp(), llvm_sha + str(llvm_assertions)):\n                 self._download_ci_llvm(llvm_sha, llvm_assertions)"}, {"sha": "40bf6c48296b2eaf98d55ae9a592301b8a8e6bd8", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -59,7 +59,9 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n-        if builder.config.keep_stage.contains(&compiler.stage) {\n+        if builder.config.keep_stage.contains(&compiler.stage)\n+            || builder.config.keep_stage_std.contains(&compiler.stage)\n+        {\n             builder.info(\"Warning: Using a potentially old libstd. This may not behave well.\");\n             builder.ensure(StdLink { compiler, target_compiler: compiler, target });\n             return;\n@@ -472,6 +474,7 @@ impl Step for Rustc {\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n+            builder.info(\"Warning: Use `--keep-stage-std` if you want to rebuild the compiler when it changes\");\n             builder.ensure(RustcLink { compiler, target_compiler: compiler, target });\n             return;\n         }"}, {"sha": "53fef7a838df62dc11152491dea44a32ac0d1719", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -71,6 +71,7 @@ pub struct Config {\n     pub on_fail: Option<String>,\n     pub stage: u32,\n     pub keep_stage: Vec<u32>,\n+    pub keep_stage_std: Vec<u32>,\n     pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n@@ -539,6 +540,7 @@ impl Config {\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n+        config.keep_stage_std = flags.keep_stage_std;\n         config.bindir = \"bin\".into(); // default\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;"}, {"sha": "f1202c82ba690b61db8f6ad4b5df2d9ed248dc60", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1033,7 +1033,7 @@ impl Step for Src {\n         copy_src_dirs(\n             builder,\n             &builder.src,\n-            &[\"library\"],\n+            &[\"library\", \"src/llvm-project/libunwind\"],\n             &[\n                 // not needed and contains symlinks which rustup currently\n                 // chokes on when unpacking."}, {"sha": "dad31fc77be17677c8e1e61b9ca1aeea96fe6c1a", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -19,6 +19,7 @@ pub struct Flags {\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Vec<u32>,\n+    pub keep_stage_std: Vec<u32>,\n \n     pub host: Option<Vec<TargetSelection>>,\n     pub target: Option<Vec<TargetSelection>>,\n@@ -144,6 +145,13 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             (pass multiple times to keep e.g., both stages 0 and 1)\",\n             \"N\",\n         );\n+        opts.optmulti(\n+            \"\",\n+            \"keep-stage-std\",\n+            \"stage(s) of the standard library to keep without recompiling \\\n+            (pass multiple times to keep e.g., both stages 0 and 1)\",\n+            \"N\",\n+        );\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         let j_msg = format!(\n             \"number of jobs to run in parallel; \\\n@@ -510,7 +518,9 @@ Arguments:\n                 println!(\"--stage not supported for x.py check, always treated as stage 0\");\n                 process::exit(1);\n             }\n-            if matches.opt_str(\"keep-stage\").is_some() {\n+            if matches.opt_str(\"keep-stage\").is_some()\n+                || matches.opt_str(\"keep-stage-std\").is_some()\n+            {\n                 println!(\"--keep-stage not supported for x.py check, only one stage available\");\n                 process::exit(1);\n             }\n@@ -528,6 +538,11 @@ Arguments:\n                 .into_iter()\n                 .map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n                 .collect(),\n+            keep_stage_std: matches\n+                .opt_strs(\"keep-stage-std\")\n+                .into_iter()\n+                .map(|j| j.parse().expect(\"`keep-stage-std` should be a number\"))\n+                .collect(),\n             host: if matches.opt_present(\"host\") {\n                 Some(\n                     split(&matches.opt_strs(\"host\"))"}, {"sha": "074f5cd73f32c4ec528342920f1b2eac5317866d", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -192,7 +192,7 @@ install!((self, builder, _config),\n         builder.ensure(dist::Docs { host: self.target });\n         install_docs(builder, self.compiler.stage, self.target);\n     };\n-    Std, \"library/std\", true, only_hosts: true, {\n+    Std, \"library/std\", true, only_hosts: false, {\n         for target in &builder.targets {\n             builder.ensure(dist::Std {\n                 compiler: self.compiler,"}, {"sha": "99d3a278d69228422629c2d4723df63eb5bff112", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -24,10 +24,10 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc9\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n-alloc3 (size: 168, align: 1) {\n+alloc9 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n     0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc4\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "d6e49892d4c6ad7d90a7db15a837bed49d7f290c", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -24,10 +24,10 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc3 (size: 180, align: 1) {\n+alloc9 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n     0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc4\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............"}, {"sha": "3475d41b50fbdf6f4932b8d3df7220a4b153db0b", "filename": "src/test/mir-opt/dest-prop/simple.nrvo.DestinationPropagation.diff", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -10,22 +10,18 @@\n       let mut _5: &mut [u8; 1024];         // in scope 0 at $DIR/simple.rs:6:10: 6:18\n       let mut _6: &mut [u8; 1024];         // in scope 0 at $DIR/simple.rs:6:10: 6:18\n       scope 1 {\n--         debug buf => _2;                 // in scope 1 at $DIR/simple.rs:5:9: 5:16\n-+         debug buf => _0;                 // in scope 1 at $DIR/simple.rs:5:9: 5:16\n+          debug buf => _2;                 // in scope 1 at $DIR/simple.rs:5:9: 5:16\n       }\n   \n       bb0: {\n--         StorageLive(_2);                 // scope 0 at $DIR/simple.rs:5:9: 5:16\n--         _2 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:5:19: 5:28\n-+         nop;                             // scope 0 at $DIR/simple.rs:5:9: 5:16\n-+         _0 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:5:19: 5:28\n+          StorageLive(_2);                 // scope 0 at $DIR/simple.rs:5:9: 5:16\n+          _2 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:5:19: 5:28\n           StorageLive(_3);                 // scope 1 at $DIR/simple.rs:6:5: 6:19\n           StorageLive(_4);                 // scope 1 at $DIR/simple.rs:6:5: 6:9\n           _4 = _1;                         // scope 1 at $DIR/simple.rs:6:5: 6:9\n           StorageLive(_5);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n           StorageLive(_6);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n--         _6 = &mut _2;                    // scope 1 at $DIR/simple.rs:6:10: 6:18\n-+         _6 = &mut _0;                    // scope 1 at $DIR/simple.rs:6:10: 6:18\n+          _6 = &mut _2;                    // scope 1 at $DIR/simple.rs:6:10: 6:18\n           _5 = &mut (*_6);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n           _3 = move _4(move _5) -> bb1;    // scope 1 at $DIR/simple.rs:6:5: 6:19\n       }\n@@ -35,10 +31,8 @@\n           StorageDead(_4);                 // scope 1 at $DIR/simple.rs:6:18: 6:19\n           StorageDead(_6);                 // scope 1 at $DIR/simple.rs:6:19: 6:20\n           StorageDead(_3);                 // scope 1 at $DIR/simple.rs:6:19: 6:20\n--         _0 = _2;                         // scope 1 at $DIR/simple.rs:7:5: 7:8\n--         StorageDead(_2);                 // scope 0 at $DIR/simple.rs:8:1: 8:2\n-+         nop;                             // scope 1 at $DIR/simple.rs:7:5: 7:8\n-+         nop;                             // scope 0 at $DIR/simple.rs:8:1: 8:2\n+          _0 = _2;                         // scope 1 at $DIR/simple.rs:7:5: 7:8\n+          StorageDead(_2);                 // scope 0 at $DIR/simple.rs:8:1: 8:2\n           return;                          // scope 0 at $DIR/simple.rs:8:2: 8:2\n       }\n   }"}, {"sha": "99ea92299c61a9f9440234d736577d4942f1ddea", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.32bit.diff", "status": "modified", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -3,168 +3,176 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue-73223.rs:1:11: 1:11\n-      let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n-      let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let mut _1: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let _2: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n       let mut _4: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _5: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _7: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _8: &std::fmt::Arguments;    // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _9: std::fmt::Arguments;         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _10: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _11: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _12: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _13: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _14: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _9: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _10: &std::fmt::Arguments;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _11: std::fmt::Arguments;        // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _12: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _13: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _14: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       let _15: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _16: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _16: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       let mut _17: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _18: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       scope 1 {\n-          debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n+          debug split => _2;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _3: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _3;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n+              let _5: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let _6: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _13;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _15;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _5;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _6;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _20;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      debug arg1 => _23;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg0 => _21;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg1 => _24;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _19;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _18: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _19: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _20: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _21;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _19: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _20: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _21: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                       scope 8 {\n-                          debug x => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _22;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _21: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _22: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _23: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _24;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _22: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _24: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n-                      debug pieces => (_9.0: &[&str]); // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      debug args => _25;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _24: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _25: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      debug pieces => _25; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      debug args => _27;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _25: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _26: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _27: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n-          debug v => _1;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n+          debug v => _2;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n       scope 7 {\n       }\n       scope 9 {\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          ((_2 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          discriminant(_2) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          _1 = ((_2 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-          StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          ((_3 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          ((_1 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          discriminant(_1) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          _2 = ((_1 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n+          StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n+          ((_3 as Some).0: i32) = _2;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n           discriminant(_3) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          (_4.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.0: &i32) = &_2;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_4.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          _13 = (_4.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _15 = (_4.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _5 = (_4.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _6 = (_4.1: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = (*_13);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = Eq(move _7, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _5 = Not(move _6);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(_5) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _9 = (*_5);                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _8 = Eq(move _9, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = Not(move _8);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(_7) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }\n   \n       bb2: {\n-          (_9.0: &[&str]) = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _25 = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          (_12.0: &&i32) = &_13;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _14 = &_15;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_12.1: &&i32) = move _14;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_14);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _20 = (_12.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _23 = (_12.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _19 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_13);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_15);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = _5;                        // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_14.0: &&i32) = &_15;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_16);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _16 = &_6;                       // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_14.1: &&i32) = move _16;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageDead(_16);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _21 = (_14.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _24 = (_14.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _20 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _18 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _19) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_19);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _19 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _20) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb3: {\n-          (_16.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _20) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _21) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb4: {\n-          (_16.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _18; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _22 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _19; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_19);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _23 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _21 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _22) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_22);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _22 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _23) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb5: {\n-          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_18.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _24) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb6: {\n-          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _21; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _11 = [move _16, move _17];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_18.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _22; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_22);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _13 = [move _17, move _18];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _12 = &_13;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _27 = move _12 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_26);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          discriminant(_26) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.0: &[&str]) = move _25;     // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _26; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.2: &[std::fmt::ArgumentV1]) = move _27; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_26);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n           _10 = &_11;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _25 = move _10 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          discriminant(_24) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_9.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _24; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_9.2: &[std::fmt::ArgumentV1]) = move _25; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _8 = &_9;                        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          begin_panic_fmt(move _8);        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          begin_panic_fmt(move _10);       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's> fn(&'r std::fmt::Arguments<'s>) -> ! {std::rt::begin_panic_fmt}, val: Value(Scalar(<ZST>)) }"}, {"sha": "99ea92299c61a9f9440234d736577d4942f1ddea", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.64bit.diff", "status": "modified", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -3,168 +3,176 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue-73223.rs:1:11: 1:11\n-      let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n-      let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let mut _1: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let _2: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n       let mut _4: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _5: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _7: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _8: &std::fmt::Arguments;    // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _9: std::fmt::Arguments;         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _10: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _11: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _12: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _13: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _14: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _9: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _10: &std::fmt::Arguments;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _11: std::fmt::Arguments;        // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _12: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _13: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _14: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       let _15: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _16: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _16: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       let mut _17: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _18: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       scope 1 {\n-          debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n+          debug split => _2;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _3: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _3;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n+              let _5: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+              let _6: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _13;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _15;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _5;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _6;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _20;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      debug arg1 => _23;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg0 => _21;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg1 => _24;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _19;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _18: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _19: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _20: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _21;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _19: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _20: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _21: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                       scope 8 {\n-                          debug x => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _22;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _21: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _22: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _23: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _24;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _22: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _24: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n-                      debug pieces => (_9.0: &[&str]); // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      debug args => _25;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _24: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _25: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      debug pieces => _25; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      debug args => _27;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _25: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _26: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _27: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n-          debug v => _1;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n+          debug v => _2;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n       scope 7 {\n       }\n       scope 9 {\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          ((_2 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          discriminant(_2) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          _1 = ((_2 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-          StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          ((_3 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n+          StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          ((_1 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          discriminant(_1) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          _2 = ((_1 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n+          StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n+          ((_3 as Some).0: i32) = _2;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n           discriminant(_3) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          (_4.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.0: &i32) = &_2;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_4.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          _13 = (_4.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _15 = (_4.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _5 = (_4.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _6 = (_4.1: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = (*_13);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = Eq(move _7, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _5 = Not(move _6);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(_5) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _9 = (*_5);                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _8 = Eq(move _9, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = Not(move _8);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_8);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(_7) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }\n   \n       bb2: {\n-          (_9.0: &[&str]) = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _25 = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          (_12.0: &&i32) = &_13;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _14 = &_15;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_12.1: &&i32) = move _14;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_14);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _20 = (_12.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _23 = (_12.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _19 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_13);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_15);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = _5;                        // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_14.0: &&i32) = &_15;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_16);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _16 = &_6;                       // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_14.1: &&i32) = move _16;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageDead(_16);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _21 = (_14.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _24 = (_14.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _20 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _18 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _19) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_19);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _19 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _20) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb3: {\n-          (_16.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _20) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _21) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb4: {\n-          (_16.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _18; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _22 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _19; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_19);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _23 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _21 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _22) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_22);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _22 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _23) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb5: {\n-          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_18.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _24) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb6: {\n-          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _21; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _11 = [move _16, move _17];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_18.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _22; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_22);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _13 = [move _17, move _18];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _12 = &_13;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _27 = move _12 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_26);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          discriminant(_26) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.0: &[&str]) = move _25;     // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _26; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_11.2: &[std::fmt::ArgumentV1]) = move _27; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_26);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n           _10 = &_11;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _25 = move _10 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          discriminant(_24) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_9.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _24; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_9.2: &[std::fmt::ArgumentV1]) = move _25; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _8 = &_9;                        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          begin_panic_fmt(move _8);        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          begin_panic_fmt(move _10);       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's> fn(&'r std::fmt::Arguments<'s>) -> ! {std::rt::begin_panic_fmt}, val: Value(Scalar(<ZST>)) }"}, {"sha": "8f8d753d0a75fa5b25c6a96b28684245859e5f95", "filename": "src/test/ui/const-generics/issues/issue-70225.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70225.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+#![deny(dead_code)]\n+\n+// We previously incorrectly linted `L` as unused here.\n+const L: usize = 3;\n+\n+fn main() {\n+    let p = Printer {};\n+    p.print();\n+}\n+\n+trait Print<const N: usize> {\n+    fn print(&self) -> usize {\n+        3\n+    }\n+}\n+\n+struct Printer {}\n+impl Print<L> for Printer {}"}, {"sha": "eb4d6cb380efe78e78d5898f99e5343800bc87fc", "filename": "src/test/ui/internal/auxiliary/internal_unstable.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Fauxiliary%2Finternal_unstable.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -52,6 +52,15 @@ macro_rules! access_field_allow {\n     ($e: expr) => { $e.x }\n }\n \n+// regression test for #77088\n+#[stable(feature = \"stable\", since = \"1.0.0\")]\n+#[allow_internal_unstable(struct_field)]\n+#[allow_internal_unstable(struct2_field)]\n+#[macro_export]\n+macro_rules! access_field_allow2 {\n+    ($e: expr) => { $e.x }\n+}\n+\n #[stable(feature = \"stable\", since = \"1.0.0\")]\n #[allow_internal_unstable()]\n #[macro_export]"}, {"sha": "94bd6aab23bffe6a4f5d16c3ca23569f0445a729", "filename": "src/test/ui/internal/internal-unstable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -28,6 +28,7 @@ fn main() {\n     construct_unstable_allow!(0);\n     |x: internal_unstable::Foo| { call_method_allow!(x) };\n     |x: internal_unstable::Bar| { access_field_allow!(x) };\n+    |x: internal_unstable::Bar| { access_field_allow2!(x) }; // regression test for #77088\n \n     // bad.\n     pass_through_allow!(internal_unstable::unstable()); //~ ERROR use of unstable"}, {"sha": "2e6360c75c42af9f4ecd0909e921fff942e3e32b", "filename": "src/test/ui/internal/internal-unstable.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -1,29 +1,29 @@\n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:33:25\n+  --> $DIR/internal-unstable.rs:34:25\n    |\n LL |     pass_through_allow!(internal_unstable::unstable());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:35:27\n+  --> $DIR/internal-unstable.rs:36:27\n    |\n LL |     pass_through_noallow!(internal_unstable::unstable());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:39:22\n+  --> $DIR/internal-unstable.rs:40:22\n    |\n LL |     println!(\"{:?}\", internal_unstable::unstable());\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:41:10\n+  --> $DIR/internal-unstable.rs:42:10\n    |\n LL |     bar!(internal_unstable::unstable());\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c7dd3cf810938604ddc5ea1fbe602f8b6f450e8d", "filename": "src/test/ui/issues/issue-77002.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Fissues%2Fissue-77002.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Fissues%2Fissue-77002.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77002.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Zmir-opt-level=2 -Copt-level=0\n+// run-pass\n+\n+type M = [i64; 2];\n+\n+fn f(a: &M) -> M {\n+    let mut b: M = M::default();\n+    b[0] = a[0] * a[0];\n+    b\n+}\n+\n+fn main() {\n+    let mut a: M = [1, 1];\n+    a = f(&a);\n+    assert_eq!(a[0], 1);\n+}"}, {"sha": "92e389a938ab336be556bc4bb47a180d027a0a8a", "filename": "src/test/ui/lint/dead-code/trait-impl.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6e4db620a7d2f569f11dcab627430921ea8aacf/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftrait-impl.rs?ref=c6e4db620a7d2f569f11dcab627430921ea8aacf", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+#![deny(dead_code)]\n+\n+enum Foo {\n+    Bar,\n+}\n+\n+fn main() {\n+    let p = [0; 0];\n+    p.bar();\n+}\n+\n+trait Bar {\n+    fn bar(&self) -> usize {\n+        3\n+    }\n+}\n+\n+impl Bar for [u32; Foo::Bar as usize] {}"}]}