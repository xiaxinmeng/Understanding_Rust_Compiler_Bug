{"sha": "81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjYyZDIzYTY0YzdlYjdlYTEwY2I3YmJmMzE2ZjE3ZDc4ZGM0YmM=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-09T01:19:31Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-09T01:19:31Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "ec06c6081d4459911079b176bb557fa3d92ea2cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec06c6081d4459911079b176bb557fa3d92ea2cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "html_url": "https://github.com/rust-lang/rust/commit/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32d749c77562c5004f4b4e87f205758c7653e29d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32d749c77562c5004f4b4e87f205758c7653e29d", "html_url": "https://github.com/rust-lang/rust/commit/32d749c77562c5004f4b4e87f205758c7653e29d"}, {"sha": "23939cabcc10ecc045a97361df182b9b4db32953", "url": "https://api.github.com/repos/rust-lang/rust/commits/23939cabcc10ecc045a97361df182b9b4db32953", "html_url": "https://github.com/rust-lang/rust/commit/23939cabcc10ecc045a97361df182b9b4db32953"}], "stats": {"total": 585, "additions": 304, "deletions": 281}, "files": [{"sha": "d3ecabb9beb0ea4b4d5575c460d75faf221f525d", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 254, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "patch": "@@ -14,10 +14,10 @@\n //!\n //! ## Collecting RawItems\n //!\n-//!  This happens in the `raw` module, which parses a single source file into a\n-//!  set of top-level items. Nested imports are desugared to flat imports in\n-//!  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n-//!  TokenTree).\n+//! This happens in the `raw` module, which parses a single source file into a\n+//! set of top-level items. Nested imports are desugared to flat imports in this\n+//! phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+//! TokenTree).\n //!\n //! ## Collecting Modules\n //!\n@@ -44,14 +44,14 @@\n //! Macros from other crates (including proc-macros) can be used with\n //! `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n //! unexpanded macros. On every iteration, we try to resolve each macro call\n-//! path and, upon success, we run macro expansion and \"collect module\" phase\n-//! on the result\n+//! path and, upon success, we run macro expansion and \"collect module\" phase on\n+//! the result\n \n-// FIXME: review privacy of submodules\n pub mod raw;\n pub mod per_ns;\n mod collector;\n mod mod_resolution;\n+mod path_resolution;\n \n #[cfg(test)]\n mod tests;\n@@ -65,14 +65,15 @@ use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use test_utils::tested_by;\n \n use crate::{\n     builtin_type::BuiltinType,\n     db::DefDatabase2,\n-    nameres::{diagnostics::DefDiagnostic, per_ns::PerNs, raw::ImportId},\n-    path::{Path, PathKind},\n-    AdtId, AstId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId, TraitId,\n+    nameres::{\n+        diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n+    },\n+    path::Path,\n+    AstId, CrateModuleId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -195,45 +196,6 @@ pub struct Resolution {\n     pub import: Option<ImportId>,\n }\n \n-impl Resolution {\n-    fn from_macro(macro_: MacroDefId) -> Self {\n-        Resolution { def: PerNs::macros(macro_), import: None }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-struct ResolvePathResult {\n-    resolved_def: PerNs,\n-    segment_index: Option<usize>,\n-    reached_fixedpoint: ReachedFixedPoint,\n-}\n-\n-impl ResolvePathResult {\n-    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n-        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n-    }\n-\n-    fn with(\n-        resolved_def: PerNs,\n-        reached_fixedpoint: ReachedFixedPoint,\n-        segment_index: Option<usize>,\n-    ) -> ResolvePathResult {\n-        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ResolveMode {\n-    Import,\n-    Other,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-enum ReachedFixedPoint {\n-    Yes,\n-    No,\n-}\n-\n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(\n         // Note that this doesn't have `+ AstDatabase`!\n@@ -296,210 +258,6 @@ impl CrateDefMap {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n-\n-    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n-    // the result.\n-    fn resolve_path_fp_with_macro(\n-        &self,\n-        db: &impl DefDatabase2,\n-        mode: ResolveMode,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> ResolvePathResult {\n-        let mut segments = path.segments.iter().enumerate();\n-        let mut curr_per_ns: PerNs = match path.kind {\n-            PathKind::DollarCrate(krate) => {\n-                if krate == self.krate {\n-                    tested_by!(macro_dollar_crate_self);\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n-                } else {\n-                    let def_map = db.crate_def_map(krate);\n-                    let module = ModuleId { krate, module_id: def_map.root };\n-                    tested_by!(macro_dollar_crate_other);\n-                    PerNs::types(module.into())\n-                }\n-            }\n-            PathKind::Crate => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n-            }\n-            PathKind::Self_ => {\n-                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n-            }\n-            // plain import or absolute path in 2015: crate-relative with\n-            // fallback to extern prelude (with the simplification in\n-            // rust-lang/rust#57745)\n-            // FIXME there must be a nicer way to write this condition\n-            PathKind::Plain | PathKind::Abs\n-                if self.edition == Edition::Edition2015\n-                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n-            {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n-            }\n-            PathKind::Plain => {\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name)\n-            }\n-            PathKind::Super => {\n-                if let Some(p) = self.modules[original_module].parent {\n-                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n-                } else {\n-                    log::debug!(\"super path in root module\");\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-                }\n-            }\n-            PathKind::Abs => {\n-                // 2018-style absolute path -- only extern prelude\n-                let segment = match segments.next() {\n-                    Some((_, segment)) => segment,\n-                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n-                };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n-                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n-                    PerNs::types(*def)\n-                } else {\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n-                }\n-            }\n-            PathKind::Type(_) => {\n-                // This is handled in `infer::infer_path_expr`\n-                // The result returned here does not matter\n-                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n-            }\n-        };\n-\n-        for (i, segment) in segments {\n-            let curr = match curr_per_ns.take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because `curr_per_ns` might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDefId::ModuleId(module) => {\n-                    if module.krate != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n-                        log::debug!(\"resolving {:?} in other crate\", path);\n-                        let defp_map = db.crate_def_map(module.krate);\n-                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n-                        return ResolvePathResult::with(\n-                            def,\n-                            ReachedFixedPoint::Yes,\n-                            s.map(|s| s + i),\n-                        );\n-                    }\n-\n-                    // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.module_id].scope.get(&segment.name) {\n-                        Some(res) => res.def,\n-                        _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n-                        }\n-                    }\n-                }\n-                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n-                    // enum variant\n-                    tested_by!(can_import_enum_variant);\n-                    let enum_data = db.enum_data(e);\n-                    match enum_data.variant(&segment.name) {\n-                        Some(local_id) => {\n-                            let variant = EnumVariantId { parent: e, local_id };\n-                            PerNs::both(variant.into(), variant.into())\n-                        }\n-                        None => {\n-                            return ResolvePathResult::with(\n-                                PerNs::types(e.into()),\n-                                ReachedFixedPoint::Yes,\n-                                Some(i),\n-                            );\n-                        }\n-                    }\n-                }\n-                s => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated item\n-                    log::debug!(\n-                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n-                        curr,\n-                    );\n-\n-                    return ResolvePathResult::with(\n-                        PerNs::types(s),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-            };\n-        }\n-        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n-    }\n-\n-    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n-        let from_crate_root =\n-            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n-\n-        from_crate_root.or(from_extern_prelude)\n-    }\n-\n-    fn resolve_name_in_module(\n-        &self,\n-        db: &impl DefDatabase2,\n-        module: CrateModuleId,\n-        name: &Name,\n-    ) -> PerNs {\n-        // Resolve in:\n-        //  - legacy scope of macro\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_legacy_macro =\n-            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n-        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, name);\n-\n-        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n-    }\n-\n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n-    }\n-\n-    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n-        if let Some(prelude) = self.prelude {\n-            let keep;\n-            let def_map = if prelude.krate == self.krate {\n-                self\n-            } else {\n-                // Extend lifetime\n-                keep = db.crate_def_map(prelude.krate);\n-                &keep\n-            };\n-            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n }\n \n mod diagnostics {"}, {"sha": "aacd50df8862cd9eb2c480b06e43768e4b32400d", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     attr::Attr,\n     db::DefDatabase2,\n     nameres::{\n-        diagnostics::DefDiagnostic, mod_resolution::ModDir, per_ns::PerNs, raw, CrateDefMap,\n-        ModuleData, ReachedFixedPoint, Resolution, ResolveMode,\n+        diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n+        per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n     AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n@@ -182,7 +182,11 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(self.def_map.root, None, &[(name, Resolution::from_macro(macro_))]);\n+            self.update(\n+                self.def_map.root,\n+                None,\n+                &[(name, Resolution { def: PerNs::macros(macro_), import: None })],\n+            );\n         }\n     }\n "}, {"sha": "95692f82611aef6a64e59a30d79dc87197c8a440", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "patch": "@@ -0,0 +1,261 @@\n+//! This modules implements a function to resolve a path `foo::bar::baz` to a\n+//! def, which is used within the name resolution.\n+//!\n+//! When name resolution is finished, the result of resolving a path is either\n+//! `Some(def)` or `None`. However, when we are in process of resolving imports\n+//! or macros, there's a third possibility:\n+//!\n+//!   I can't resolve this path right now, but I might be resolve this path\n+//!   later, when more macros are expanded.\n+//!\n+//! `ReachedFixedPoint` signals about this.\n+\n+use hir_expand::name::Name;\n+use ra_db::Edition;\n+use test_utils::tested_by;\n+\n+use crate::{\n+    db::DefDatabase2,\n+    nameres::{per_ns::PerNs, CrateDefMap},\n+    path::{Path, PathKind},\n+    AdtId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct ResolvePathResult {\n+    pub(super) resolved_def: PerNs,\n+    pub(super) segment_index: Option<usize>,\n+    pub(super) reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        resolved_def: PerNs,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n+impl CrateDefMap {\n+    pub(super) fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n+\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    pub(super) fn resolve_path_fp_with_macro(\n+        &self,\n+        db: &impl DefDatabase2,\n+        mode: ResolveMode,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> ResolvePathResult {\n+        let mut segments = path.segments.iter().enumerate();\n+        let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    let def_map = db.crate_def_map(krate);\n+                    let module = ModuleId { krate, module_id: def_map.root };\n+                    tested_by!(macro_dollar_crate_other);\n+                    PerNs::types(module.into())\n+                }\n+            }\n+            PathKind::Crate => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(ModuleId { krate: self.krate, module_id: original_module }.into())\n+            }\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // FIXME there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n+            }\n+            PathKind::Plain => {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n+            }\n+            PathKind::Super => {\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(ModuleId { krate: self.krate, module_id: p }.into())\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+                }\n+            }\n+            PathKind::Abs => {\n+                // 2018-style absolute path -- only extern prelude\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n+                };\n+                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                    log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n+                    PerNs::types(*def)\n+                } else {\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                }\n+            }\n+            PathKind::Type(_) => {\n+                // This is handled in `infer::infer_path_expr`\n+                // The result returned here does not matter\n+                return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+            }\n+        };\n+\n+        for (i, segment) in segments {\n+            let curr = match curr_per_ns.take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because `curr_per_ns` might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                }\n+            };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDefId::ModuleId(module) => {\n+                    if module.krate != self.krate {\n+                        let path =\n+                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n+                        return ResolvePathResult::with(\n+                            def,\n+                            ReachedFixedPoint::Yes,\n+                            s.map(|s| s + i),\n+                        );\n+                    }\n+\n+                    // Since it is a qualified path here, it should not contains legacy macros\n+                    match self[module.module_id].scope.get(&segment.name) {\n+                        Some(res) => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n+                        }\n+                    }\n+                }\n+                ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                    // enum variant\n+                    tested_by!(can_import_enum_variant);\n+                    let enum_data = db.enum_data(e);\n+                    match enum_data.variant(&segment.name) {\n+                        Some(local_id) => {\n+                            let variant = EnumVariantId { parent: e, local_id };\n+                            PerNs::both(variant.into(), variant.into())\n+                        }\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types(e.into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n+                    }\n+                }\n+                s => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated item\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types(s),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n+            };\n+        }\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n+    }\n+\n+    fn resolve_name_in_module(\n+        &self,\n+        db: &impl DefDatabase2,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> PerNs {\n+        // Resolve in:\n+        //  - legacy scope of macro\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_legacy_macro =\n+            self[module].scope.get_legacy_macro(name).map_or_else(PerNs::none, PerNs::macros);\n+        let from_scope = self[module].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+        let from_crate_root =\n+            self[self.root].scope.get(name).map_or_else(PerNs::none, |res| res.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase2, name: &Name) -> PerNs {\n+        if let Some(prelude) = self.prelude {\n+            let keep;\n+            let def_map = if prelude.krate == self.krate {\n+                self\n+            } else {\n+                // Extend lifetime\n+                keep = db.crate_def_map(prelude.krate);\n+                &keep\n+            };\n+            def_map[prelude.module_id].scope.get(name).map_or_else(PerNs::none, |res| res.def)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+}"}, {"sha": "369376f30935b7899f63232b21461638578abada", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=81662d23a64c7eb7ea10cb7bbf316f17d78dc4bc", "patch": "@@ -88,7 +88,7 @@ impl RawItems {\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n     }\n \n-    pub fn items(&self) -> &[RawItem] {\n+    pub(super) fn items(&self) -> &[RawItem] {\n         &self.items\n     }\n }\n@@ -125,31 +125,31 @@ impl Index<Macro> for RawItems {\n type Attrs = Option<Arc<[Attr]>>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub struct RawItem {\n+pub(super) struct RawItem {\n     attrs: Attrs,\n-    pub kind: RawItemKind,\n+    pub(super) kind: RawItemKind,\n }\n \n impl RawItem {\n-    pub fn attrs(&self) -> &[Attr] {\n+    pub(super) fn attrs(&self) -> &[Attr] {\n         self.attrs.as_ref().map_or(&[], |it| &*it)\n     }\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub enum RawItemKind {\n+pub(super) enum RawItemKind {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Module(RawId);\n+pub(super) struct Module(RawId);\n impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub enum ModuleData {\n+pub(super) enum ModuleData {\n     Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n@@ -160,26 +160,26 @@ impl_arena_id!(ImportId);\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub path: Path,\n-    pub alias: Option<Name>,\n-    pub is_glob: bool,\n-    pub is_prelude: bool,\n-    pub is_extern_crate: bool,\n-    pub is_macro_use: bool,\n+    pub(super) path: Path,\n+    pub(super) alias: Option<Name>,\n+    pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n+    pub(super) is_extern_crate: bool,\n+    pub(super) is_macro_use: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Def(RawId);\n+pub(super) struct Def(RawId);\n impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub struct DefData {\n-    pub name: Name,\n-    pub kind: DefKind,\n+pub(super) struct DefData {\n+    pub(super) name: Name,\n+    pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub enum DefKind {\n+pub(super) enum DefKind {\n     Function(FileAstId<ast::FnDef>),\n     Struct(FileAstId<ast::StructDef>),\n     Union(FileAstId<ast::StructDef>),\n@@ -191,15 +191,15 @@ pub enum DefKind {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Macro(RawId);\n+pub(super) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n-pub struct MacroData {\n-    pub ast_id: FileAstId<ast::MacroCall>,\n-    pub path: Path,\n-    pub name: Option<Name>,\n-    pub export: bool,\n+pub(super) struct MacroData {\n+    pub(super) ast_id: FileAstId<ast::MacroCall>,\n+    pub(super) path: Path,\n+    pub(super) name: Option<Name>,\n+    pub(super) export: bool,\n }\n \n struct RawItemsCollector {"}]}