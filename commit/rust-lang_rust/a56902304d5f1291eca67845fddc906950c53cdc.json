{"sha": "a56902304d5f1291eca67845fddc906950c53cdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NjkwMjMwNGQ1ZjEyOTFlY2E2Nzg0NWZkZGM5MDY5NTBjNTNjZGM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-15T21:59:22Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-15T22:31:19Z"}, "message": "Make fixed length vecs implicitly copyable. Clean up some other kind code. Closes #2629", "tree": {"sha": "7120e8d82a33de02097ca06a24f139a950a429d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7120e8d82a33de02097ca06a24f139a950a429d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a56902304d5f1291eca67845fddc906950c53cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a56902304d5f1291eca67845fddc906950c53cdc", "html_url": "https://github.com/rust-lang/rust/commit/a56902304d5f1291eca67845fddc906950c53cdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a56902304d5f1291eca67845fddc906950c53cdc/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "999ab5418a769cfcbde7c7291785bb98c5fd2a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/999ab5418a769cfcbde7c7291785bb98c5fd2a5f", "html_url": "https://github.com/rust-lang/rust/commit/999ab5418a769cfcbde7c7291785bb98c5fd2a5f"}], "stats": {"total": 42, "additions": 18, "deletions": 24}, "files": [{"sha": "8af47f10bb4bad20279b43c6613ba6007e06cb29", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a56902304d5f1291eca67845fddc906950c53cdc/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56902304d5f1291eca67845fddc906950c53cdc/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=a56902304d5f1291eca67845fddc906950c53cdc", "patch": "@@ -1387,13 +1387,8 @@ fn kind_top() -> kind {\n     kind_(0xffffffffu32)\n }\n \n-fn remove_const(k: kind, tm: mt) -> kind {\n-    if tm.mutbl == ast::m_mutbl {\n-        k - kind_const()\n-    }\n-    else {\n-        k\n-    }\n+fn remove_const(k: kind) -> kind {\n+    k - kind_const()\n }\n \n fn remove_implicit(k: kind) -> kind {\n@@ -1475,10 +1470,11 @@ fn test_kinds() {\n // Return the most permissive kind that a composite object containing a field\n // with the given mutability can have.\n // This is used to prevent objects containing mutable state from being\n-// implicitly copied.\n+// implicitly copied and to compute whether things have const kind.\n fn mutability_kind(m: mutability) -> kind {\n     alt (m) {\n-      m_mutbl | m_const { remove_implicit(kind_top()) }\n+      m_mutbl { remove_const(remove_implicit(kind_top())) }\n+      m_const { remove_implicit(kind_top()) }\n       m_imm { kind_top() }\n     }\n }\n@@ -1528,18 +1524,18 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // Unique boxes and vecs have the kind of their contained type,\n       // but unique boxes can't be implicitly copyable.\n       ty_uniq(tm) {\n-        remove_implicit(remove_const(type_kind(cx, tm.ty), tm))\n+        remove_implicit(mutable_type_kind(cx, tm))\n       }\n       // Implicit copyability of vecs is configurable\n       ty_vec(tm) {\n-          let k = if cx.vecs_implicitly_copyable {\n+          if cx.vecs_implicitly_copyable {\n               mutable_type_kind(cx, tm)\n-          } else { remove_implicit(type_kind(cx, tm.ty)) };\n-          remove_const(k, tm)\n+          } else { remove_implicit(mutable_type_kind(cx, tm)) }\n       }\n \n-      // Slice and refcounted evecs are copyable; uniques and interiors\n-      // depend on the their contained type, but aren't implicitly copyable.\n+      // Slices, refcounted evecs are copyable; uniques depend on the their\n+      // contained type, but aren't implicitly copyable.  Fixed vectors have\n+      // the kind of the element they contain, taking mutability into account.\n       ty_evec(tm, vstore_box) |\n       ty_evec(tm, vstore_slice(_)) {\n         if kind_lteq(kind_const(), type_kind(cx, tm.ty)) {\n@@ -1549,23 +1545,24 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             kind_implicitly_copyable()\n         }\n       }\n-      ty_evec(tm, vstore_uniq) |\n+      ty_evec(tm, vstore_uniq) {\n+        remove_implicit(mutable_type_kind(cx, tm))\n+      }\n       ty_evec(tm, vstore_fixed(_)) {\n-        remove_implicit(remove_const(type_kind(cx, tm.ty), tm))\n+        mutable_type_kind(cx, tm)\n       }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n       ty_estr(vstore_slice(_)) { kind_implicitly_copyable() | kind_const() }\n-      ty_estr(vstore_uniq) |\n-      ty_estr(vstore_fixed(_)) { kind_sendable() | kind_const() }\n+      ty_estr(vstore_uniq) { kind_sendable() | kind_const() }\n+      ty_estr(vstore_fixed(_)) { kind_implicitly_sendable() | kind_const() }\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         let mut lowest = kind_top();\n         for flds.each {|f|\n             lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n-            lowest = remove_const(lowest, f.mt);\n         }\n         lowest\n       }\n@@ -1614,10 +1611,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         (kind_const() & type_kind(cx, inner)) | kind_send_only()\n       }\n       ty_param(_, did) {\n-        // FIXME: type params shouldn't be implicitly copyable (#2449)\n-        let k = param_bounds_to_kind(cx.ty_param_bounds.get(did.node));\n-        if kind_can_be_copied(k)\n-            { raise_kind(k, kind_implicitly_copyable()) } else { k }\n+        param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n       // FIXME: is self ever const?"}]}