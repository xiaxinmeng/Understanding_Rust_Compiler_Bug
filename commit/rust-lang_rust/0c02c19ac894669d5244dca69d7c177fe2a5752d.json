{"sha": "0c02c19ac894669d5244dca69d7c177fe2a5752d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMDJjMTlhYzg5NDY2OWQ1MjQ0ZGNhNjlkN2MxNzdmZTJhNTc1MmQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-23T14:37:01Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:22:32Z"}, "message": "Remove duplicate logic in compute_missing_constructors\n\nThis is equivalent to the previous code in terms of performance. The\nexpensive path is clearly identical. The fast path is also the same,\nbecause in both cases we loop until we get a non-empty `refined_ctors`,\nand then stop there. So the new code doesn't compute anything more\nthan the previous did.", "tree": {"sha": "ad02863293b36dde75a4faf9514206439d5a1584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad02863293b36dde75a4faf9514206439d5a1584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c02c19ac894669d5244dca69d7c177fe2a5752d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c02c19ac894669d5244dca69d7c177fe2a5752d", "html_url": "https://github.com/rust-lang/rust/commit/0c02c19ac894669d5244dca69d7c177fe2a5752d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c02c19ac894669d5244dca69d7c177fe2a5752d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e734bef414ec7d9482adababb5abe4d547ce867", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e734bef414ec7d9482adababb5abe4d547ce867", "html_url": "https://github.com/rust-lang/rust/commit/5e734bef414ec7d9482adababb5abe4d547ce867"}], "stats": {"total": 119, "additions": 35, "deletions": 84}, "files": [{"sha": "a87965979e017c9c6a24d1d13c27bf471dc30d96", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 35, "deletions": 84, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0c02c19ac894669d5244dca69d7c177fe2a5752d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c02c19ac894669d5244dca69d7c177fe2a5752d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=0c02c19ac894669d5244dca69d7c177fe2a5752d", "patch": "@@ -1255,41 +1255,17 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-// A request for missing constructor data in terms of either:\n-// - whether or not there any missing constructors; or\n-// - the actual set of missing constructors.\n-#[derive(PartialEq)]\n-enum MissingCtorsInfo {\n-    Emptiness,\n-    Ctors,\n-}\n-\n-// Used by `compute_missing_ctors`.\n-#[derive(Debug, PartialEq)]\n-enum MissingCtors<'tcx> {\n-    Empty,\n-    NonEmpty,\n-\n-    // Note that the Vec can be empty.\n-    Ctors(Vec<Constructor<'tcx>>),\n-}\n-\n-// When `info` is `MissingCtorsInfo::Ctors`, compute a set of constructors\n-// equivalent to `all_ctors \\ used_ctors`. When `info` is\n-// `MissingCtorsInfo::Emptiness`, just determines if that set is empty or not.\n-// (The split logic gives a performance win, because we always need to know if\n-// the set is empty, but we rarely need the full set, and it can be expensive\n-// to compute the full set.)\n-fn compute_missing_ctors<'tcx>(\n-    info: MissingCtorsInfo,\n+type MissingConstructors<'a, 'tcx, F> =\n+    std::iter::FlatMap<std::slice::Iter<'a, Constructor<'tcx>>, Vec<Constructor<'tcx>>, F>;\n+// Compute a set of constructors equivalent to `all_ctors \\ used_ctors`. This\n+// returns an iterator, so that we only construct the whole set if needed.\n+fn compute_missing_ctors<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    all_ctors: &Vec<Constructor<'tcx>>,\n-    used_ctors: &Vec<Constructor<'tcx>>,\n-) -> MissingCtors<'tcx> {\n-    let mut missing_ctors = vec![];\n-\n-    for req_ctor in all_ctors {\n+    all_ctors: &'a Vec<Constructor<'tcx>>,\n+    used_ctors: &'a Vec<Constructor<'tcx>>,\n+) -> MissingConstructors<'a, 'tcx, impl FnMut(&'a Constructor<'tcx>) -> Vec<Constructor<'tcx>>> {\n+    all_ctors.iter().flat_map(move |req_ctor| {\n         let mut refined_ctors = vec![req_ctor.clone()];\n         for used_ctor in used_ctors {\n             if used_ctor == req_ctor {\n@@ -1303,32 +1279,19 @@ fn compute_missing_ctors<'tcx>(\n             }\n \n             // If the constructor patterns that have been considered so far\n-            // already cover the entire range of values, then we the\n+            // already cover the entire range of values, then we know the\n             // constructor is not missing, and we can move on to the next one.\n             if refined_ctors.is_empty() {\n                 break;\n             }\n         }\n+\n         // If a constructor has not been matched, then it is missing.\n         // We add `refined_ctors` instead of `req_ctor`, because then we can\n         // provide more detailed error information about precisely which\n         // ranges have been omitted.\n-        if info == MissingCtorsInfo::Emptiness {\n-            if !refined_ctors.is_empty() {\n-                // The set is non-empty; return early.\n-                return MissingCtors::NonEmpty;\n-            }\n-        } else {\n-            missing_ctors.extend(refined_ctors);\n-        }\n-    }\n-\n-    if info == MissingCtorsInfo::Emptiness {\n-        // If we reached here, the set is empty.\n-        MissingCtors::Empty\n-    } else {\n-        MissingCtors::Ctors(missing_ctors)\n-    }\n+        refined_ctors\n+    })\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html.\n@@ -1459,22 +1422,19 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // needed for that case.\n \n         // Missing constructors are those that are not matched by any\n-        // non-wildcard patterns in the current column. We always determine if\n-        // the set is empty, but we only fully construct them on-demand,\n-        // because they're rarely used and can be big.\n-        let cheap_missing_ctors = compute_missing_ctors(\n-            MissingCtorsInfo::Emptiness,\n-            cx.tcx,\n-            cx.param_env,\n-            &all_ctors,\n-            &used_ctors,\n-        );\n+        // non-wildcard patterns in the current column. To determine if\n+        // the set is empty, we can check that `.peek().is_none()`, so\n+        // we only fully construct them on-demand, because they're rarely used and can be big.\n+        let mut missing_ctors =\n+            compute_missing_ctors(cx.tcx, cx.param_env, &all_ctors, &used_ctors).peekable();\n \n         let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n         debug!(\n-            \"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-            cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive\n+            \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n+            missing_ctors.peek().is_none(),\n+            is_privately_empty,\n+            is_declared_nonexhaustive\n         );\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n@@ -1483,7 +1443,8 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             || is_declared_nonexhaustive\n             || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n-        if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n+        if missing_ctors.peek().is_none() && !is_non_exhaustive {\n+            drop(missing_ctors); // It was borrowing `all_ctors`, which we want to move.\n             split_grouped_constructors(\n                 cx.tcx,\n                 cx.param_env,\n@@ -1561,28 +1522,18 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                             })\n                             .collect()\n                     } else {\n-                        let expensive_missing_ctors = compute_missing_ctors(\n-                            MissingCtorsInfo::Ctors,\n-                            cx.tcx,\n-                            cx.param_env,\n-                            &all_ctors,\n-                            &used_ctors,\n-                        );\n-                        if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n-                            pats.into_iter()\n-                                .flat_map(|witness| {\n-                                    missing_ctors.iter().map(move |ctor| {\n-                                        // Extends the witness with a \"wild\" version of this\n-                                        // constructor, that matches everything that can be built with\n-                                        // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                        // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                        witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                                    })\n+                        let missing_ctors: Vec<_> = missing_ctors.collect();\n+                        pats.into_iter()\n+                            .flat_map(|witness| {\n+                                missing_ctors.iter().map(move |ctor| {\n+                                    // Extends the witness with a \"wild\" version of this\n+                                    // constructor, that matches everything that can be built with\n+                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n+                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n                                 })\n-                                .collect()\n-                        } else {\n-                            bug!(\"cheap missing ctors\")\n-                        }\n+                            })\n+                            .collect()\n                     };\n                     UsefulWithWitness(new_witnesses)\n                 }"}]}