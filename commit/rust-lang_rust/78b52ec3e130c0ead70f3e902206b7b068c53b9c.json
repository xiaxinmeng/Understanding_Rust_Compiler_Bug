{"sha": "78b52ec3e130c0ead70f3e902206b7b068c53b9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YjUyZWMzZTEzMGMwZWFkNzBmM2U5MDIyMDZiN2IwNjhjNTNiOWM=", "commit": {"author": {"name": "Stuart Dootson", "email": "stuart.dootson@gmail.com", "date": "2016-07-26T05:20:01Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-07-26T05:20:01Z"}, "message": "Add `use` declaration re-ordering (#1104)\n\n* Add config options for combinations of lines and items\r\n\r\n* Reordering of import lines implemented.\r\n\r\n* Changed nested matches to tuple pattern matching\r\n\r\n* Added ordering of path list items to the ordering of use declarations\r\n\r\n* Move `format_imports` and `format_import` methods to `imports.rs`\r\n\r\n* Add comment to explain how `use` declarations are split off while walking through a module\r\n\r\n* Change `ImportReordering` config option to separate boolean options", "tree": {"sha": "70a399c24c85eaa55f65b77756cd620921a8bb3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a399c24c85eaa55f65b77756cd620921a8bb3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78b52ec3e130c0ead70f3e902206b7b068c53b9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78b52ec3e130c0ead70f3e902206b7b068c53b9c", "html_url": "https://github.com/rust-lang/rust/commit/78b52ec3e130c0ead70f3e902206b7b068c53b9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78b52ec3e130c0ead70f3e902206b7b068c53b9c/comments", "author": {"login": "studoot", "id": 799344, "node_id": "MDQ6VXNlcjc5OTM0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/799344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/studoot", "html_url": "https://github.com/studoot", "followers_url": "https://api.github.com/users/studoot/followers", "following_url": "https://api.github.com/users/studoot/following{/other_user}", "gists_url": "https://api.github.com/users/studoot/gists{/gist_id}", "starred_url": "https://api.github.com/users/studoot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/studoot/subscriptions", "organizations_url": "https://api.github.com/users/studoot/orgs", "repos_url": "https://api.github.com/users/studoot/repos", "events_url": "https://api.github.com/users/studoot/events{/privacy}", "received_events_url": "https://api.github.com/users/studoot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9750fb7fca8dfc16752c79f1e0b5f4a2d73c4563", "url": "https://api.github.com/repos/rust-lang/rust/commits/9750fb7fca8dfc16752c79f1e0b5f4a2d73c4563", "html_url": "https://github.com/rust-lang/rust/commit/9750fb7fca8dfc16752c79f1e0b5f4a2d73c4563"}], "stats": {"total": 332, "additions": 287, "deletions": 45}, "files": [{"sha": "9cd15bc0e332212801df2012b74b7b8c2699e431", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -391,6 +391,8 @@ create_config! {\n     chain_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indentation of chain\";\n     chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n+    reorder_imported_names: bool, false,\n+        \"Reorder lists of names in import statements alphabetically\";\n     single_line_if_else_max_width: usize, 50, \"Maximum line length for single line if-else \\\n                                                 expressions. A value of zero means always break \\\n                                                 if-else expressions.\";"}, {"sha": "36953463d3840edfc92e1acb868993c1db49c796", "filename": "src/imports.rs", "status": "modified", "additions": 167, "deletions": 3, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -9,13 +9,120 @@\n // except according to those terms.\n \n use Indent;\n+use utils;\n+use syntax::codemap::{self, BytePos, Span};\n use codemap::SpanUtils;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, definitive_tactic};\n use types::rewrite_path;\n use rewrite::{Rewrite, RewriteContext};\n+use visitor::FmtVisitor;\n+use std::cmp::Ordering;\n \n-use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::{ast, ptr};\n+\n+fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n+    match a {\n+        &ast::ViewPath_::ViewPathSimple(_, ref p) => p,\n+        &ast::ViewPath_::ViewPathGlob(ref p) => p,\n+        &ast::ViewPath_::ViewPathList(ref p, _) => p,\n+    }\n+}\n+\n+fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n+}\n+\n+fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    for segment in a.segments.iter().zip(b.segments.iter()) {\n+        let ord = compare_path_segments(segment.0, segment.1);\n+        if ord != Ordering::Equal {\n+            return ord;\n+        }\n+    }\n+    a.segments.len().cmp(&b.segments.len())\n+}\n+\n+fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Ordering {\n+    let name_ordering = match a.node.name() {\n+        Some(a_name) => {\n+            match b.node.name() {\n+                Some(b_name) => a_name.name.as_str().cmp(&b_name.name.as_str()),\n+                None => Ordering::Greater,\n+            }\n+        }\n+        None => {\n+            match b.node.name() {\n+                Some(_) => Ordering::Less,\n+                None => Ordering::Equal,\n+            }\n+        }\n+    };\n+    if name_ordering == Ordering::Equal {\n+        match a.node.rename() {\n+            Some(a_rename) => {\n+                match b.node.rename() {\n+                    Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n+                    None => Ordering::Greater,\n+                }\n+            }\n+            None => {\n+                match b.node.name() {\n+                    Some(_) => Ordering::Less,\n+                    None => Ordering::Equal,\n+                }\n+            }\n+        }\n+    } else {\n+        name_ordering\n+    }\n+}\n+\n+fn compare_path_list_item_lists(a_items: &Vec<ast::PathListItem>,\n+                                b_items: &Vec<ast::PathListItem>)\n+                                -> Ordering {\n+    let mut a = a_items.clone();\n+    let mut b = b_items.clone();\n+    a.sort_by(|a, b| compare_path_list_items(a, b));\n+    b.sort_by(|a, b| compare_path_list_items(a, b));\n+    for comparison_pair in a.iter().zip(b.iter()) {\n+        let ord = compare_path_list_items(comparison_pair.0, comparison_pair.1);\n+        if ord != Ordering::Equal {\n+            return ord;\n+        }\n+    }\n+    a.len().cmp(&b.len())\n+}\n+\n+fn compare_view_path_types(a: &ast::ViewPath_, b: &ast::ViewPath_) -> Ordering {\n+    use syntax::ast::ViewPath_::*;\n+    match (a, b) {\n+        (&ViewPathSimple(..), &ViewPathSimple(..)) => Ordering::Equal,\n+        (&ViewPathSimple(..), _) => Ordering::Less,\n+        (&ViewPathGlob(_), &ViewPathSimple(..)) => Ordering::Greater,\n+        (&ViewPathGlob(_), &ViewPathGlob(_)) => Ordering::Equal,\n+        (&ViewPathGlob(_), &ViewPathList(..)) => Ordering::Less,\n+        (&ViewPathList(_, ref a_items), &ViewPathList(_, ref b_items)) => {\n+            compare_path_list_item_lists(a_items, b_items)\n+        }\n+        (&ViewPathList(..), _) => Ordering::Greater,\n+    }\n+}\n+\n+fn compare_view_paths(a: &ast::ViewPath_, b: &ast::ViewPath_) -> Ordering {\n+    match compare_paths(path_of(a), path_of(b)) {\n+        Ordering::Equal => compare_view_path_types(a, b),\n+        cmp => cmp,\n+    }\n+}\n+\n+fn compare_use_items(a: &ast::Item, b: &ast::Item) -> Option<Ordering> {\n+    match (&a.node, &b.node) {\n+        (&ast::ItemKind::Use(ref a_vp), &ast::ItemKind::Use(ref b_vp)) => {\n+            Some(compare_view_paths(&a_vp.node, &b_vp.node))\n+        }\n+        _ => None,\n+    }\n+}\n \n // TODO (some day) remove unused imports, expand globs, compress many single\n // imports into a list import.\n@@ -50,6 +157,63 @@ impl Rewrite for ast::ViewPath {\n     }\n }\n \n+impl<'a> FmtVisitor<'a> {\n+    pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n+        let mut last_pos =\n+            use_items.first().map(|p_i| p_i.span.lo - BytePos(1)).unwrap_or(self.last_pos);\n+        let prefix = codemap::mk_sp(self.last_pos, last_pos);\n+        let mut ordered_use_items = use_items.iter()\n+            .map(|p_i| {\n+                let new_item = (&*p_i, last_pos);\n+                last_pos = p_i.span.hi;\n+                new_item\n+            })\n+            .collect::<Vec<_>>();\n+        // Order the imports by view-path & other import path properties\n+        ordered_use_items.sort_by(|a, b| compare_use_items(a.0, b.0).unwrap());\n+        // First, output the span before the first import\n+        self.format_missing(prefix.hi);\n+        for ordered in ordered_use_items {\n+            // Fake out the formatter by setting `self.last_pos` to the appropriate location before\n+            // each item before visiting it.\n+            self.last_pos = ordered.1;\n+            self.visit_item(&ordered.0);\n+        }\n+        self.last_pos = last_pos;\n+    }\n+\n+    pub fn format_import(&mut self, vis: &ast::Visibility, vp: &ast::ViewPath, span: Span) {\n+        let vis = utils::format_visibility(vis);\n+        let mut offset = self.block_indent;\n+        offset.alignment += vis.len() + \"use \".len();\n+        // 1 = \";\"\n+        match vp.rewrite(&self.get_context(),\n+                         self.config.max_width - offset.width() - 1,\n+                         offset) {\n+            Some(ref s) if s.is_empty() => {\n+                // Format up to last newline\n+                let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n+                let span_end = match self.snippet(prev_span).rfind('\\n') {\n+                    Some(offset) => self.last_pos + BytePos(offset as u32),\n+                    None => source!(self, span).lo,\n+                };\n+                self.format_missing(span_end);\n+                self.last_pos = source!(self, span).hi;\n+            }\n+            Some(ref s) => {\n+                let s = format!(\"{}use {};\", vis, s);\n+                self.format_missing_with_indent(source!(self, span).lo);\n+                self.buffer.push_str(&s);\n+                self.last_pos = source!(self, span).hi;\n+            }\n+            None => {\n+                self.format_missing_with_indent(source!(self, span).lo);\n+                self.format_missing(source!(self, span).hi);\n+            }\n+        }\n+    }\n+}\n+\n fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String {\n     let path_item_str = if let ast::PathListItemKind::Ident { name, .. } = vpi.node {\n         // A name.\n@@ -138,7 +302,7 @@ pub fn rewrite_use_list(width: usize,\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self { 0 } else { 1 };\n \n-    if context.config.reorder_imports {\n+    if context.config.reorder_imported_names {\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n "}, {"sha": "0978e552837e94e5593c8af063ee6ea6f71014d2", "filename": "src/utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -224,6 +224,13 @@ macro_rules! msg {\n     )\n }\n \n+// For format_missing and last_pos, need to use the source callsite (if applicable).\n+// Required as generated code spans aren't guaranteed to follow on from the last span.\n+macro_rules! source {\n+    ($this:ident, $sp: expr) => {\n+        $this.codemap.source_callsite($sp)\n+    }\n+}\n \n // Wraps string-like values in an Option. Returns Some when the string adheres\n // to the Rewrite constraints defined for the Rewrite trait and else otherwise."}, {"sha": "b60c51566808cd5cc1426f60e4d314a6a6ed09db", "filename": "src/visitor.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, visit};\n+use syntax::{ast, ptr, visit};\n use syntax::codemap::{self, CodeMap, Span, BytePos};\n use syntax::parse::ParseSess;\n \n@@ -23,11 +23,10 @@ use comment::rewrite_comment;\n use macros::rewrite_macro;\n use items::{rewrite_static, rewrite_associated_type, rewrite_type_alias, format_impl, format_trait};\n \n-// For format_missing and last_pos, need to use the source callsite (if applicable).\n-// Required as generated code spans aren't guaranteed to follow on from the last span.\n-macro_rules! source {\n-    ($this:ident, $sp: expr) => {\n-        $this.codemap.source_callsite($sp)\n+fn is_use_item(item: &ast::Item) -> bool {\n+    match item.node {\n+        ast::ItemKind::Use(_) => true,\n+        _ => false,\n     }\n }\n \n@@ -191,7 +190,7 @@ impl<'a> FmtVisitor<'a> {\n         self.visit_block(b)\n     }\n \n-    fn visit_item(&mut self, item: &ast::Item) {\n+    pub fn visit_item(&mut self, item: &ast::Item) {\n         // This is where we bail out if there is a skip attribute. This is only\n         // complex in the module case. It is complex because the module could be\n         // in a seperate file and there might be attributes in both files, but\n@@ -502,8 +501,24 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn walk_mod_items(&mut self, m: &ast::Mod) {\n-        for item in &m.items {\n-            self.visit_item(&item);\n+        let mut items_left: &[ptr::P<ast::Item>] = &m.items;\n+        while !items_left.is_empty() {\n+            // If the next item is a `use` declaration, then extract it and any subsequent `use`s\n+            // to be potentially reordered within `format_imports`. Otherwise, just format the\n+            // next item for output.\n+            if self.config.reorder_imports && is_use_item(&*items_left[0]) {\n+                let use_item_length =\n+                    items_left.iter().take_while(|ppi| is_use_item(&***ppi)).count();\n+                let (use_items, rest) = items_left.split_at(use_item_length);\n+                self.format_imports(use_items);\n+                items_left = rest;\n+            } else {\n+                // `unwrap()` is safe here because we know `items_left`\n+                // has elements from the loop condition\n+                let (item, rest) = items_left.split_first().unwrap();\n+                self.visit_item(&item);\n+                items_left = rest;\n+            }\n         }\n     }\n \n@@ -547,37 +562,6 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing(filemap.end_pos);\n     }\n \n-    fn format_import(&mut self, vis: &ast::Visibility, vp: &ast::ViewPath, span: Span) {\n-        let vis = utils::format_visibility(vis);\n-        let mut offset = self.block_indent;\n-        offset.alignment += vis.len() + \"use \".len();\n-        // 1 = \";\"\n-        match vp.rewrite(&self.get_context(),\n-                         self.config.max_width - offset.width() - 1,\n-                         offset) {\n-            Some(ref s) if s.is_empty() => {\n-                // Format up to last newline\n-                let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n-                let span_end = match self.snippet(prev_span).rfind('\\n') {\n-                    Some(offset) => self.last_pos + BytePos(offset as u32),\n-                    None => source!(self, span).lo,\n-                };\n-                self.format_missing(span_end);\n-                self.last_pos = source!(self, span).hi;\n-            }\n-            Some(ref s) => {\n-                let s = format!(\"{}use {};\", vis, s);\n-                self.format_missing_with_indent(source!(self, span).lo);\n-                self.buffer.push_str(&s);\n-                self.last_pos = source!(self, span).hi;\n-            }\n-            None => {\n-                self.format_missing_with_indent(source!(self, span).lo);\n-                self.format_missing(source!(self, span).hi);\n-            }\n-        }\n-    }\n-\n     pub fn get_context(&self) -> RewriteContext {\n         RewriteContext {\n             parse_session: self.parse_session,"}, {"sha": "b61f26771f60c513731fdd6f47c3cdfeaabb241d", "filename": "tests/source/imports-reorder-lines-and-items.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder-lines-and-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder-lines-and-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports-reorder-lines-and-items.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -0,0 +1,9 @@\n+// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n+\n+use std::str;\n+use std::cmp::{d, c, b, a};\n+use std::ddd::aaa;\n+use std::ddd::{d as p, c as g, b, a};\n+// This comment should stay with `use std::ddd:bbb;`\n+use std::ddd::bbb;"}, {"sha": "a855a9642351eae382d93b16e2de41b4d1d26b53", "filename": "tests/source/imports-reorder-lines.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports-reorder-lines.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -0,0 +1,34 @@\n+// rustfmt-reorder_imports: true\n+\n+use std::str;\n+use std::cmp::{d, c, b, a};\n+use std::cmp::{b, e, g, f};\n+use std::ddd::aaa;\n+// This comment should stay with `use std::ddd;`\n+use std::ddd;\n+use std::ddd::bbb;\n+\n+mod test {\n+}\n+\n+use aaa::bbb;\n+use aaa;\n+use aaa::*;\n+\n+mod test {}\n+// If item names are equal, order by rename\n+\n+use test::{a as bb, b};\n+use test::{a as aa, c};\n+\n+mod test {}\n+// If item names are equal, order by rename - no rename comes before a rename\n+\n+use test::{a as bb, b};\n+use test::{a, c};\n+\n+mod test {}\n+// `self` always comes first\n+\n+use test::{a as aa, c};\n+use test::{self as bb, b};"}, {"sha": "4ad9e4b08d31b6b2ab173ae790017ea0670b733c", "filename": "tests/source/imports-reorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Fsource%2Fimports-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports-reorder.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -1,4 +1,4 @@\n-// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n \n use path::{C,/*A*/ A, B /* B */, self /* self */};\n "}, {"sha": "fb2e0347aac5c8f7cc70dc1983e7e70ba72afbf8", "filename": "tests/target/imports-reorder-lines-and-items.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports-reorder-lines-and-items.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -0,0 +1,9 @@\n+// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n+\n+use std::cmp::{a, b, c, d};\n+use std::ddd::{a, b, c as g, d as p};\n+use std::ddd::aaa;\n+// This comment should stay with `use std::ddd:bbb;`\n+use std::ddd::bbb;\n+use std::str;"}, {"sha": "7c8735c2dd56640575fcbd01db615d388e952f6f", "filename": "tests/target/imports-reorder-lines.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports-reorder-lines.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -0,0 +1,33 @@\n+// rustfmt-reorder_imports: true\n+\n+use std::cmp::{d, c, b, a};\n+use std::cmp::{b, e, g, f};\n+// This comment should stay with `use std::ddd;`\n+use std::ddd;\n+use std::ddd::aaa;\n+use std::ddd::bbb;\n+use std::str;\n+\n+mod test {}\n+\n+use aaa;\n+use aaa::*;\n+use aaa::bbb;\n+\n+mod test {}\n+// If item names are equal, order by rename\n+\n+use test::{a as aa, c};\n+use test::{a as bb, b};\n+\n+mod test {}\n+// If item names are equal, order by rename - no rename comes before a rename\n+\n+use test::{a, c};\n+use test::{a as bb, b};\n+\n+mod test {}\n+// `self` always comes first\n+\n+use test::{self as bb, b};\n+use test::{a as aa, c};"}, {"sha": "32b5ee156cc5fa32691be600a10360cd62d1a9d3", "filename": "tests/target/imports-reorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b52ec3e130c0ead70f3e902206b7b068c53b9c/tests%2Ftarget%2Fimports-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports-reorder.rs?ref=78b52ec3e130c0ead70f3e902206b7b068c53b9c", "patch": "@@ -1,4 +1,4 @@\n-// rustfmt-reorder_imports: true\n+// rustfmt-reorder_imported_names: true\n \n use path::{self /* self */, /* A */ A, B /* B */, C};\n "}]}