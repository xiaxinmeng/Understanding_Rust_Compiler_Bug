{"sha": "1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNjJmNWZmNzRlOGM2ZDQzNDAwMWQ0NTcxZTVmMjhhZTI3MDVlZDk=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-11T23:49:02Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-12T22:13:18Z"}, "message": "Get rid of all of the remaining /~s in the code base.", "tree": {"sha": "062b0fa7b1f70838d8964a0f14b7d44ee83c5062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/062b0fa7b1f70838d8964a0f14b7d44ee83c5062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "html_url": "https://github.com/rust-lang/rust/commit/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46fba10fe82ef9a584118b8d2298cdfc49320c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/46fba10fe82ef9a584118b8d2298cdfc49320c85", "html_url": "https://github.com/rust-lang/rust/commit/46fba10fe82ef9a584118b8d2298cdfc49320c85"}], "stats": {"total": 138, "additions": 68, "deletions": 70}, "files": [{"sha": "fbe8bd85b66b2d36a265645cbb76a1f2773dc921", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -30,8 +30,6 @@ def scrub(b):\n                 \"xfail-fast\" in s or\n                 \"xfail-win32\" in s):\n             stage2_tests.append(t)\n-            if \"main(args: [str]/~)\" in s:\n-                take_args[t] = True\n             if \"main(args: [str])\" in s:\n                 take_args[t] = True\n             if \"main(args: ~[str])\" in s:"}, {"sha": "1784acc1414cf575d1a8a82acd60cb572b0a30e0", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -32,7 +32,7 @@ export unwrap;\n  * # WARNING\n  *\n  * For maximum performance, this type is implemented using some rather\n- * unsafe code.  In particular, this innocent looking `[mut A]/~` pointer\n+ * unsafe code.  In particular, this innocent looking `~[mut A]` pointer\n  * *may be null!*  Therefore, it is important you not reach into the\n  * data structure manually but instead use the provided extensions.\n  *"}, {"sha": "1ba6e75a1ec8d983a1041a4745bd2913c52348e0", "filename": "src/libcore/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -236,7 +236,7 @@ fn to_str(num: float, digits: uint) -> str {\n  * # Return value\n  *\n  * `none` if the string did not represent a valid number.  Otherwise,\n- * `some(n)` where `n` is the floating-point number represented by `[num]/~`.\n+ * `some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n fn from_str(num: str) -> option<float> {\n    if num == \"inf\" {\n@@ -261,7 +261,7 @@ fn from_str(num: str) -> option<float> {\n       _ { ret none; }\n    }\n \n-   //Determine if first char is '-'/'+'. Set ~[pos] and ~[neg] accordingly.\n+   //Determine if first char is '-'/'+'. Set [pos] and [neg] accordingly.\n    let mut neg = false;               //Sign of the result\n    alt str::char_at(num, 0u) {\n       '-' {"}, {"sha": "f7f6f9ca03bc79fdd2fdc59aa2d8b5415318e1be", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -247,8 +247,8 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n  *         if x == uint::max_value { ret err(\"overflow\"); }\n  *         else { ret ok(x+1u); }\n  *     }\n- *     map([1u, 2u, 3u]/~, inc_conditionally).chain {|incd|\n- *         assert incd == [2u, 3u, 4u]/~;\n+ *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n+ *         assert incd == ~[2u, 3u, 4u];\n  *     }\n  */\n fn map_vec<T,U:copy,V:copy>("}, {"sha": "b07c9465df7785b2b03e0336bf238d110186ea6c", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -39,7 +39,7 @@ unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n  *\n  * # Example\n  *\n- *     assert transmute(\"L\") == [76u8, 0u8]/~;\n+ *     assert transmute(\"L\") == ~[76u8, 0u8];\n  */\n unsafe fn transmute<L, G>(-thing: L) -> G {\n     let newthing = reinterpret_cast(thing);"}, {"sha": "c4929f86d5fa47daeb7f965251690451b9579f3b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -666,14 +666,14 @@ pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n  *\n  * Flattens a vector of vectors of T into a single vector of T.\n  */\n-pure fn concat<T: copy>(v: &[[T]/~]) -> ~[T] {\n+pure fn concat<T: copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n /// Concatenate a vector of vectors, placing a given separator between each\n-pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n+pure fn connect<T: copy>(v: &[~[T]], sep: T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {"}, {"sha": "e6df8e1d8985d4c44279f960c40c453209da1a22", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -28,21 +28,21 @@\n  *     }\n  *\n  *     fn print_usage(program: str) {\n- *         io::println(\"Usage: \" + program + \" [options]/~\");\n+ *         io::println(\"Usage: \" + program + \" [options]\");\n  *         io::println(\"-o\\t\\tOutput\");\n  *         io::println(\"-h --help\\tUsage\");\n  *     }\n  *\n- *     fn main(args: [str]/~) {\n+ *     fn main(args: ~[str]) {\n  *         check vec::is_not_empty(args);\n  *\n  *         let program : str = vec::head(args);\n  *\n- *         let opts = [\n+ *         let opts = ~[\n  *             optopt(\"o\"),\n  *             optflag(\"h\"),\n  *             optflag(\"help\")\n- *         ]/~;\n+ *         ];\n  *         let match = alt getopts(vec::tail(args), opts) {\n  *             result::ok(m) { m }\n  *             result::err(f) { fail fail_str(f) }"}, {"sha": "abb548655d47f62785798cac8e6668d8face16bf", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -84,12 +84,12 @@ enum ip_get_addr_err {\n  *\n  * # Returns\n  *\n- * A `result<[ip_addr]/~, ip_get_addr_err>` instance that will contain\n+ * A `result<~[ip_addr], ip_get_addr_err>` instance that will contain\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n  */\n fn get_addr(++node: str, iotask: iotask)\n-        -> result::result<[ip_addr]/~, ip_get_addr_err> unsafe {\n+        -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n     do comm::listen |output_ch| {\n         do str::unpack_slice(node) |node_ptr, len| {\n             log(debug, #fmt(\"slice len %?\", len));\n@@ -249,7 +249,7 @@ mod v6 {\n }\n \n type get_addr_data = {\n-    output_ch: comm::chan<result::result<[ip_addr]/~,ip_get_addr_err>>\n+    output_ch: comm::chan<result::result<~[ip_addr],ip_get_addr_err>>\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n@@ -259,7 +259,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n         *get_addr_data;\n     if status == 0i32 {\n         if res != (ptr::null::<addrinfo>()) {\n-            let mut out_vec = []/~;\n+            let mut out_vec = ~[];\n             log(debug, #fmt(\"initial addrinfo: %?\", res));\n             let mut curr_addr = res;\n             loop {\n@@ -278,7 +278,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                         result::err(get_addr_unknown_error));\n                     break;\n                 };\n-                out_vec += [new_ip_addr]/~;\n+                out_vec += ~[new_ip_addr];\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {"}, {"sha": "17ffae1b5f444128691bae74ad93079a1b69c152", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -248,7 +248,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n  * # Arguments\n  *\n  * * sock - a `tcp_socket` to write to\n- * * raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n+ * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n@@ -284,7 +284,7 @@ fn write(sock: tcp_socket, raw_write_data: ~[u8])\n  * # Arguments\n  *\n  * * sock - a `tcp_socket` to write to\n- * * raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n+ * * raw_write_data - a vector of `~[u8]` that will be written to the stream.\n  * This value must remain valid for the duration of the `write` call\n  *\n  * # Returns\n@@ -331,7 +331,7 @@ fn read_start(sock: tcp_socket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n fn read_stop(sock: tcp_socket,\n-             -read_port: comm::port<result::result<[u8]/~, tcp_err_data>>) ->\n+             -read_port: comm::port<result::result<~[u8], tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n     log(debug, #fmt(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(*sock.socket_data);\n@@ -360,7 +360,7 @@ fn read(sock: tcp_socket, timeout_msecs: uint)\n }\n \n /**\n- * Reads a single chunk of data; returns a `future::future<[u8]/~>`\n+ * Reads a single chunk of data; returns a `future::future<~[u8]>`\n  * immediately\n  *\n  * Does a non-blocking read operation for a single chunk of data from a\n@@ -731,7 +731,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n-    tcp_socket_buf(@{ sock: sock, mut buf: []/~ })\n+    tcp_socket_buf(@{ sock: sock, mut buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n@@ -741,7 +741,7 @@ impl tcp_socket for tcp_socket {\n         read_start(self)\n     }\n     fn read_stop(-read_port:\n-                 comm::port<result::result<[u8]/~, tcp_err_data>>) ->\n+                 comm::port<result::result<~[u8], tcp_err_data>>) ->\n         result::result<(), tcp_err_data> {\n         read_stop(self, read_port)\n     }\n@@ -765,14 +765,14 @@ impl tcp_socket for tcp_socket {\n \n /// Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n-    fn read_bytes(amt: uint) -> [u8]/~ {\n+    fn read_bytes(amt: uint) -> ~[u8] {\n         let has_amt_available =\n             vec::len((*(self.data)).buf) >= amt;\n         if has_amt_available {\n             // no arbitrary-length shift in vec::?\n-            let mut ret_buf = []/~;\n+            let mut ret_buf = ~[];\n             while vec::len(ret_buf) < amt {\n-                ret_buf += [vec::shift((*(self.data)).buf)]/~;\n+                ret_buf += ~[vec::shift((*(self.data)).buf)];\n             }\n             ret_buf\n         }\n@@ -782,7 +782,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n                 let err_data = read_result.get_err();\n                 log(debug, #fmt(\"ERROR sock_buf as io::reader.read err %? %?\",\n                                  err_data.err_name, err_data.err_msg));\n-                []/~\n+                ~[]\n             }\n             else {\n                 let new_chunk = result::unwrap(read_result);\n@@ -811,7 +811,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n \n /// Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n-    fn write(data: [const u8]/&) unsafe {\n+    fn write(data: &[const u8]) unsafe {\n         let socket_data_ptr =\n             ptr::addr_of(*((*(self.data)).sock).socket_data);\n         let w_result = write_common_impl(socket_data_ptr,\n@@ -1221,7 +1221,7 @@ type tcp_socket_data = {\n \n type tcp_buffered_socket_data = {\n     sock: tcp_socket,\n-    mut buf: [u8]/~\n+    mut buf: ~[u8]\n };\n \n //#[cfg(test)]"}, {"sha": "e0adae610ba32983ada3f7e417aa133ad1adbc05", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -146,7 +146,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n /**\n  * Fancy quicksort. Sorts a mut vector in place.\n  *\n- * Based on algorithm presented by [Sedgewick and Bentley]/~\n+ * Based on algorithm presented by ~[Sedgewick and Bentley]\n  * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n  * According to these slides this is the algorithm of choice for\n  * 'randomly ordered keys, abstract compare' & 'small number of key values'."}, {"sha": "24d0442dfe2ea9c3df24379ba926c5ff9b3b5ac9", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -23,7 +23,7 @@ const color_bright_magenta: u8 = 13u8;\n const color_bright_cyan: u8 = 14u8;\n const color_bright_white: u8 = 15u8;\n \n-fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]/~); }\n+fn esc(writer: io::writer) { writer.write(~[0x1bu8, '[' as u8]); }\n \n /// Reset the foreground and background colors to default\n fn reset(writer: io::writer) {"}, {"sha": "8407a18c54988cccb3fa3c4055ac1065e82eb1d8", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -819,8 +819,8 @@ unsafe fn ip6_addr(ip: str, port: int)\n }\n unsafe fn ip4_name(src: &sockaddr_in) -> str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n-    let dst: [u8]/~ = [0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8]/~;\n+    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+                     0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n     let size = 16 as libc::size_t;\n     do vec::as_buf(dst) |dst_buf| {\n         rustrt::rust_uv_ip4_name(src as *sockaddr_in,\n@@ -836,12 +836,12 @@ unsafe fn ip4_name(src: &sockaddr_in) -> str {\n }\n unsafe fn ip6_name(src: &sockaddr_in6) -> str {\n     // ipv6 addr max size: 45 + 1 trailing null byte\n-    let dst: [u8]/~ = [0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n+    let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n-                       0u8,0u8,0u8,0u8,0u8,0u8]/~;\n+                       0u8,0u8,0u8,0u8,0u8,0u8];\n     let size = 46 as libc::size_t;\n     do vec::as_buf(dst) |dst_buf| {\n         let src_unsafe_ptr = src as *sockaddr_in6;"}, {"sha": "296a8ba0d97f76e7043f0d7646cd99040da92706", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -162,7 +162,7 @@ impl methods for state {\n         cx.ty_path(path(self.name).add_tys(cx.ty_vars(self.ty_params)))\n     }\n \n-    fn to_type_decls(cx: ext_ctxt) -> [@ast::item]/~ {\n+    fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n         // `ping_message`. The first contains data that the user cares\n@@ -171,7 +171,7 @@ impl methods for state {\n \n         let name = self.data_name();\n \n-        let mut items_msg = []/~;\n+        let mut items_msg = ~[];\n \n         for self.messages.each |m| {\n             let message(_, tys, this, next, next_tys) = m;\n@@ -197,7 +197,7 @@ impl methods for state {\n         ~[cx.item_enum_poly(name, items_msg, self.ty_params)]\n     }\n \n-    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> [@ast::item]/~ {\n+    fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n         let dir = alt dir {\n           send { (*self).dir }\n           recv { (*self).dir.reverse() }\n@@ -285,7 +285,7 @@ impl methods for protocol {\n                   start_state.to_ty(cx).to_source(),\n                   body.to_source()),\n             cx.cfg(),\n-            []/~,\n+            ~[],\n             ast::public,\n             cx.parse_sess()).get()\n     }\n@@ -325,7 +325,7 @@ impl of to_source for @ast::item {\n     }\n }\n \n-impl of to_source for [@ast::item]/~ {\n+impl of to_source for ~[@ast::item] {\n     fn to_source() -> str {\n         str::connect(self.map(|i| i.to_source()), \"\\n\\n\")\n     }\n@@ -337,7 +337,7 @@ impl of to_source for @ast::ty {\n     }\n }\n \n-impl of to_source for [@ast::ty]/~ {\n+impl of to_source for ~[@ast::ty] {\n     fn to_source() -> str {\n         str::connect(self.map(|i| i.to_source()), \", \")\n     }\n@@ -361,7 +361,7 @@ impl parse_utils for ext_ctxt {\n             \"***protocol expansion***\",\n             @(copy s),\n             self.cfg(),\n-            []/~,\n+            ~[],\n             ast::public,\n             self.parse_sess());\n         alt res {\n@@ -382,13 +382,13 @@ impl parse_utils for ext_ctxt {\n     }\n }\n \n-impl methods<A: copy, B: copy> for ([A]/~, [B]/~) {\n-    fn zip() -> [(A, B)]/~ {\n+impl methods<A: copy, B: copy> for (~[A], ~[B]) {\n+    fn zip() -> ~[(A, B)] {\n         let (a, b) = self;\n         vec::zip(a, b)\n     }\n \n-    fn map<C>(f: fn(A, B) -> C) -> [C]/~ {\n+    fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n         let (a, b) = self;\n         vec::map2(a, b, f)\n     }"}, {"sha": "b10a05d8ca45065e35d243c801ae5bf27e83bb71", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -50,15 +50,15 @@ impl parser_attr for parser {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     break;\n                 }\n-                attrs += [self.parse_attribute(ast::attr_outer)]/~;\n+                attrs += ~[self.parse_attribute(ast::attr_outer)];\n               }\n               token::DOC_COMMENT(s) {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                         *self.get_str(s), self.span.lo, self.span.hi);\n                 if attr.node.style != ast::attr_outer {\n                   self.fatal(\"expected outer comment\");\n                 }\n-                attrs += [attr]/~;\n+                attrs += ~[attr];\n                 self.bump();\n               }\n               _ {\n@@ -105,14 +105,14 @@ impl parser_attr for parser {\n                 let attr = self.parse_attribute(ast::attr_inner);\n                 if self.token == token::SEMI {\n                     self.bump();\n-                    inner_attrs += [attr]/~;\n+                    inner_attrs += ~[attr];\n                 } else {\n                     // It's not really an inner attribute\n                     let outer_attr =\n                         spanned(attr.span.lo, attr.span.hi,\n                             {style: ast::attr_outer, value: attr.node.value,\n                              is_sugared_doc: false});\n-                    next_outer_attrs += [outer_attr]/~;\n+                    next_outer_attrs += ~[outer_attr];\n                     break;\n                 }\n               }\n@@ -121,9 +121,9 @@ impl parser_attr for parser {\n                         *self.get_str(s), self.span.lo, self.span.hi);\n                 self.bump();\n                 if attr.node.style == ast::attr_inner {\n-                  inner_attrs += [attr]/~;\n+                  inner_attrs += ~[attr];\n                 } else {\n-                  next_outer_attrs += [attr]/~;\n+                  next_outer_attrs += ~[attr];\n                   break;\n                 }\n               }"}, {"sha": "e05887d28b4cc6a8c2ae2195abfd72d10e0d33ce", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -39,7 +39,7 @@ fn doc_comment_style(comment: str) -> ast::attr_style {\n fn strip_doc_comment_decoration(comment: str) -> str {\n \n     /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: [str]/~) -> [str]/~ {\n+    fn vertical_trim(lines: ~[str]) -> ~[str] {\n         let mut i = 0u, j = lines.len();\n         while i < j && lines[i].trim().is_empty() {\n             i += 1u;\n@@ -51,7 +51,7 @@ fn strip_doc_comment_decoration(comment: str) -> str {\n     }\n \n     // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: [str]/~, chars: str, max: option<uint>) -> [str]/~ {\n+    fn block_trim(lines: ~[str], chars: str, max: option<uint>) -> ~[str] {\n \n         let mut i = max.get_default(uint::max_value);\n         for lines.each |line| {\n@@ -136,7 +136,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n \n \n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: [cmnt]/~) {\n+                                                        &comments: ~[cmnt]) {\n     #debug(\">>> shebang comment\");\n     let p = rdr.chpos;\n     #debug(\"<<< shebang comment\");\n@@ -148,7 +148,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n }\n \n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: [cmnt]/~) {\n+                                                        &comments: ~[cmnt]) {\n     #debug(\">>> line comments\");\n     let p = rdr.chpos;\n     let mut lines: ~[str] = ~[];\n@@ -191,7 +191,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: ~[str],\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n-                                                        &comments: [cmnt]/~) {\n+                                                        &comments: ~[cmnt]) {\n     #debug(\">>> block comment\");\n     let p = rdr.chpos;\n     let mut lines: ~[str] = ~[];"}, {"sha": "b93f3a4bc2da93d22088b10e5fff2b4468f007b4", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -52,11 +52,11 @@ fn thread_ring(i: uint,\n     };\n }\n \n-fn main(args: [str]/~) {\n+fn main(args: ~[str]) {\n     let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        [\"\", \"100\", \"10000\"]/~\n+        ~[\"\", \"100\", \"10000\"]\n     } else if args.len() <= 1u {\n-        [\"\", \"100\", \"1000\"]/~\n+        ~[\"\", \"100\", \"1000\"]\n     } else {\n         copy args\n     }; \n@@ -70,23 +70,23 @@ fn main(args: [str]/~) {\n     let start = time::precise_time_s();\n \n     // create the ring\n-    let mut futures = []/~;\n+    let mut futures = ~[];\n \n     for uint::range(1u, num_tasks) |i| {\n         //#error(\"spawning %?\", i);\n         let (new_chan, num_port) = ring::init();\n         let num_chan2 = ~mut none;\n         *num_chan2 <-> num_chan;\n         let num_port = ~mut some(num_port);\n-        futures += [future::spawn(|move num_chan2, move num_port| {\n+        futures += ~[future::spawn(|move num_chan2, move num_port| {\n             let mut num_chan = none;\n             num_chan <-> *num_chan2;\n             let mut num_port1 = none;\n             num_port1 <-> *num_port;\n             thread_ring(i, msg_per_task,\n                         option::unwrap(num_chan),\n                         option::unwrap(num_port1))\n-        })]/~;\n+        })];\n         num_chan = some(new_chan);\n     };\n "}, {"sha": "54cb1058796e02fb2b8af10fcedab1cf66c1370b", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c62f5ff74e8c6d434001d4571e5f28ae2705ed9/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=1c62f5ff74e8c6d434001d4571e5f28ae2705ed9", "patch": "@@ -254,23 +254,23 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n     }\n \n     fn visit_evec_box(mtbl: uint, inner: *tydesc) -> bool {\n-        self.align_to::<[u8]/@>();\n+        self.align_to::<@[u8]>();\n         if ! self.inner.visit_evec_box(mtbl, inner) { ret false; }\n-        self.bump_past::<[u8]/@>();\n+        self.bump_past::<@[u8]>();\n         true\n     }\n \n     fn visit_evec_uniq(mtbl: uint, inner: *tydesc) -> bool {\n-        self.align_to::<[u8]/~>();\n+        self.align_to::<~[u8]>();\n         if ! self.inner.visit_evec_uniq(mtbl, inner) { ret false; }\n-        self.bump_past::<[u8]/~>();\n+        self.bump_past::<~[u8]>();\n         true\n     }\n \n     fn visit_evec_slice(mtbl: uint, inner: *tydesc) -> bool {\n-        self.align_to::<[u8]/&static>();\n+        self.align_to::<&static.[u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { ret false; }\n-        self.bump_past::<[u8]/&static>();\n+        self.bump_past::<&static.[u8]>();\n         true\n     }\n "}]}