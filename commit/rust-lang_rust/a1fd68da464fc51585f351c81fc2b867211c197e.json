{"sha": "a1fd68da464fc51585f351c81fc2b867211c197e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZmQ2OGRhNDY0ZmM1MTU4NWYzNTFjODFmYzJiODY3MjExYzE5N2U=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-09-07T05:35:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-07T05:35:14Z"}, "message": "Merge pull request #1948 from topecongiro/issue-1137\n\nUse write_list() to format imports", "tree": {"sha": "f78148bf193d71fe9a8d76f0cd6befdd69526ffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f78148bf193d71fe9a8d76f0cd6befdd69526ffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1fd68da464fc51585f351c81fc2b867211c197e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fd68da464fc51585f351c81fc2b867211c197e", "html_url": "https://github.com/rust-lang/rust/commit/a1fd68da464fc51585f351c81fc2b867211c197e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1fd68da464fc51585f351c81fc2b867211c197e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6a5fa881b2400dd93383cca056bfde784869a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6a5fa881b2400dd93383cca056bfde784869a8", "html_url": "https://github.com/rust-lang/rust/commit/3b6a5fa881b2400dd93383cca056bfde784869a8"}, {"sha": "903d815228d6d3a0afdce19defe5beafe9b039da", "url": "https://api.github.com/repos/rust-lang/rust/commits/903d815228d6d3a0afdce19defe5beafe9b039da", "html_url": "https://github.com/rust-lang/rust/commit/903d815228d6d3a0afdce19defe5beafe9b039da"}], "stats": {"total": 289, "additions": 147, "deletions": 142}, "files": [{"sha": "7cfe5d8b6b9808f0b3e2e1122f4ef36caa93a3cd", "filename": "src/imports.rs", "status": "modified", "additions": 106, "deletions": 86, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a1fd68da464fc51585f351c81fc2b867211c197e/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fd68da464fc51585f351c81fc2b867211c197e/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=a1fd68da464fc51585f351c81fc2b867211c197e", "patch": "@@ -8,20 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp::{self, Ordering};\n+use std::cmp::Ordering;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{BytePos, Span};\n \n-use Shape;\n+use {Shape, Spanned};\n use codemap::SpanUtils;\n+use comment::combine_strs_with_missing_comments;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, DefinitiveListTactic, ListFormatting,\n             ListItem, Separator, SeparatorPlace, SeparatorTactic};\n use rewrite::{Rewrite, RewriteContext};\n use types::{rewrite_path, PathContext};\n-use utils;\n-use visitor::FmtVisitor;\n+use utils::{format_visibility, mk_sp};\n+use visitor::{rewrite_extern_crate, FmtVisitor};\n \n fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n     match *a {\n@@ -185,95 +186,115 @@ impl Rewrite for ast::ViewPath {\n     }\n }\n \n-impl<'a> FmtVisitor<'a> {\n-    pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n-        // Find the location immediately before the first use item in the run. This must not lie\n-        // before the current `self.last_pos`\n-        let pos_before_first_use_item = use_items\n-            .first()\n-            .map(|p_i| {\n-                cmp::max(\n-                    self.last_pos,\n-                    p_i.attrs\n-                        .iter()\n-                        .map(|attr| attr.span.lo())\n-                        .min()\n-                        .unwrap_or(p_i.span.lo()),\n-                )\n-            })\n-            .unwrap_or(self.last_pos);\n-        // Construct a list of pairs, each containing a `use` item and the start of span before\n-        // that `use` item.\n-        let mut last_pos_of_prev_use_item = pos_before_first_use_item;\n-        let mut ordered_use_items = use_items\n-            .iter()\n-            .map(|p_i| {\n-                let new_item = (&*p_i, last_pos_of_prev_use_item);\n-                last_pos_of_prev_use_item = p_i.span.hi();\n-                new_item\n-            })\n-            .collect::<Vec<_>>();\n-        let pos_after_last_use_item = last_pos_of_prev_use_item;\n-        // Order the imports by view-path & other import path properties\n-        ordered_use_items.sort_by(|a, b| {\n-            compare_use_items(&self.get_context(), a.0, b.0).unwrap()\n-        });\n-        // First, output the span before the first import\n-        let prev_span_str = self.snippet(utils::mk_sp(self.last_pos, pos_before_first_use_item));\n-        // Look for purely trailing space at the start of the prefix snippet before a linefeed, or\n-        // a prefix that's entirely horizontal whitespace.\n-        let prefix_span_start = match prev_span_str.find('\\n') {\n-            Some(offset) if prev_span_str[..offset].trim().is_empty() => {\n-                self.last_pos + BytePos(offset as u32)\n-            }\n-            None if prev_span_str.trim().is_empty() => pos_before_first_use_item,\n-            _ => self.last_pos,\n-        };\n-        // Look for indent (the line part preceding the use is all whitespace) and excise that\n-        // from the prefix\n-        let span_end = match prev_span_str.rfind('\\n') {\n-            Some(offset) if prev_span_str[offset..].trim().is_empty() => {\n-                self.last_pos + BytePos(offset as u32)\n+// Rewrite `use foo;` WITHOUT attributes.\n+fn rewrite_import(\n+    context: &RewriteContext,\n+    vis: &ast::Visibility,\n+    vp: &ast::ViewPath,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<String> {\n+    let vis = format_visibility(vis);\n+    // 4 = `use `, 1 = `;`\n+    let rw = shape\n+        .offset_left(vis.len() + 4)\n+        .and_then(|shape| shape.sub_width(1))\n+        .and_then(|shape| match vp.node {\n+            // If we have an empty path list with no attributes, we erase it\n+            ast::ViewPath_::ViewPathList(_, ref path_list)\n+                if path_list.is_empty() && attrs.is_empty() =>\n+            {\n+                Some(\"\".into())\n             }\n-            _ => pos_before_first_use_item,\n-        };\n+            _ => vp.rewrite(context, shape),\n+        });\n+    match rw {\n+        Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n+        _ => rw,\n+    }\n+}\n \n-        self.last_pos = prefix_span_start;\n-        self.format_missing(span_end);\n-        for ordered in ordered_use_items {\n-            // Fake out the formatter by setting `self.last_pos` to the appropriate location before\n-            // each item before visiting it.\n-            self.last_pos = ordered.1;\n-            self.visit_item(ordered.0);\n+fn rewrite_imports(\n+    context: &RewriteContext,\n+    use_items: &[ptr::P<ast::Item>],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n+    let items = itemize_list(\n+        context.codemap,\n+        use_items.iter(),\n+        \"\",\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n+        |item| {\n+            let attrs_str = try_opt!(item.attrs.rewrite(context, shape));\n+\n+            let missed_span = if item.attrs.is_empty() {\n+                mk_sp(item.span.lo(), item.span.lo())\n+            } else {\n+                mk_sp(item.attrs.last().unwrap().span.hi(), item.span.lo())\n+            };\n+\n+            let item_str = match item.node {\n+                ast::ItemKind::Use(ref vp) => {\n+                    try_opt!(rewrite_import(context, &item.vis, vp, &item.attrs, shape))\n+                }\n+                ast::ItemKind::ExternCrate(..) => try_opt!(rewrite_extern_crate(context, item)),\n+                _ => return None,\n+            };\n+\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &item_str,\n+                missed_span,\n+                shape,\n+                false,\n+            )\n+        },\n+        span.lo(),\n+        span.hi(),\n+        false,\n+    );\n+    let mut item_pair_vec: Vec<_> = items.zip(use_items.iter()).collect();\n+    item_pair_vec.sort_by(|a, b| compare_use_items(context, a.1, b.1).unwrap());\n+    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape: shape,\n+        ends_with_newline: true,\n+        preserve_newline: false,\n+        config: context.config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}\n+\n+impl<'a> FmtVisitor<'a> {\n+    pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n+        if use_items.is_empty() {\n+            return;\n         }\n-        self.last_pos = pos_after_last_use_item;\n+\n+        let lo = use_items.first().unwrap().span().lo();\n+        let hi = use_items.last().unwrap().span().hi();\n+        let span = mk_sp(lo, hi);\n+        let rw = rewrite_imports(&self.get_context(), use_items, self.shape(), span);\n+        self.push_rewrite(span, rw);\n     }\n \n-    pub fn format_import(\n-        &mut self,\n-        vis: &ast::Visibility,\n-        vp: &ast::ViewPath,\n-        span: Span,\n-        attrs: &[ast::Attribute],\n-    ) {\n-        let vis = utils::format_visibility(vis);\n-        // 4 = `use `, 1 = `;`\n-        let rw = self.shape()\n-            .offset_left(vis.len() + 4)\n-            .and_then(|shape| shape.sub_width(1))\n-            .and_then(|shape| match vp.node {\n-                // If we have an empty path list with no attributes, we erase it\n-                ast::ViewPath_::ViewPathList(_, ref path_list)\n-                    if path_list.is_empty() && attrs.is_empty() =>\n-                {\n-                    Some(\"\".into())\n-                }\n-                _ => vp.rewrite(&self.get_context(), shape),\n-            });\n+    pub fn format_import(&mut self, item: &ast::Item, vp: &ast::ViewPath) {\n+        let span = item.span;\n+        let shape = self.shape();\n+        let rw = rewrite_import(&self.get_context(), &item.vis, vp, &item.attrs, shape);\n         match rw {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n-                let prev_span = utils::mk_sp(self.last_pos, source!(self, span).lo());\n+                let prev_span = mk_sp(self.last_pos, source!(self, span).lo());\n                 let span_end = match self.snippet(prev_span).rfind('\\n') {\n                     Some(offset) => self.last_pos + BytePos(offset as u32),\n                     None => source!(self, span).lo(),\n@@ -282,7 +303,6 @@ impl<'a> FmtVisitor<'a> {\n                 self.last_pos = source!(self, span).hi();\n             }\n             Some(ref s) => {\n-                let s = format!(\"{}use {};\", vis, s);\n                 self.format_missing_with_indent(source!(self, span).lo());\n                 self.buffer.push_str(&s);\n                 self.last_pos = source!(self, span).hi();"}, {"sha": "832883c2c3e42444d0e22948803738ab25c6bceb", "filename": "src/visitor.rs", "status": "modified", "additions": 41, "deletions": 51, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a1fd68da464fc51585f351c81fc2b867211c197e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fd68da464fc51585f351c81fc2b867211c197e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a1fd68da464fc51585f351c81fc2b867211c197e", "patch": "@@ -22,8 +22,9 @@ use comment::{contains_comment, recover_missing_comment_in_span, CodeCharKind, C\n               FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n-use items::{format_impl, format_trait, rewrite_associated_impl_type, rewrite_associated_type,\n-            rewrite_static, rewrite_type_alias};\n+use items::{format_impl, format_struct, format_struct_struct, format_trait,\n+            rewrite_associated_impl_type, rewrite_associated_type, rewrite_static,\n+            rewrite_type_alias};\n use lists::{itemize_list, write_list, DefinitiveListTactic, ListFormatting, SeparatorPlace,\n             SeparatorTactic};\n use macros::{rewrite_macro, MacroPosition};\n@@ -296,7 +297,8 @@ impl<'a> FmtVisitor<'a> {\n         // complex in the module case. It is complex because the module could be\n         // in a separate file and there might be attributes in both files, but\n         // the AST lumps them all together.\n-        let mut attrs = item.attrs.clone();\n+        let filterd_attrs;\n+        let mut attrs = &item.attrs;\n         match item.node {\n             ast::ItemKind::Mod(ref m) => {\n                 let outer_file = self.codemap.lookup_char_pos(item.span.lo()).file;\n@@ -314,7 +316,7 @@ impl<'a> FmtVisitor<'a> {\n                 } else {\n                     // Module is not inline and should not be skipped. We want\n                     // to process only the attributes in the current file.\n-                    let filterd_attrs = item.attrs\n+                    filterd_attrs = item.attrs\n                         .iter()\n                         .filter_map(|a| {\n                             let attr_file = self.codemap.lookup_char_pos(a.span.lo()).file;\n@@ -328,7 +330,7 @@ impl<'a> FmtVisitor<'a> {\n                     // Assert because if we should skip it should be caught by\n                     // the above case.\n                     assert!(!self.visit_attrs(&filterd_attrs, ast::AttrStyle::Outer));\n-                    attrs = filterd_attrs;\n+                    attrs = &filterd_attrs;\n                 }\n             }\n             _ => if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n@@ -338,62 +340,38 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         match item.node {\n-            ast::ItemKind::Use(ref vp) => {\n-                self.format_import(&item.vis, vp, item.span, &item.attrs);\n-            }\n+            ast::ItemKind::Use(ref vp) => self.format_import(&item, vp),\n             ast::ItemKind::Impl(..) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n                 let snippet = self.snippet(item.span);\n                 let where_span_end = snippet\n                     .find_uncommented(\"{\")\n                     .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo());\n-                if let Some(impl_str) =\n-                    format_impl(&self.get_context(), item, self.block_indent, where_span_end)\n-                {\n-                    self.buffer.push_str(&impl_str);\n-                    self.last_pos = source!(self, item.span).hi();\n-                }\n+                let rw = format_impl(&self.get_context(), item, self.block_indent, where_span_end);\n+                self.push_rewrite(item.span, rw);\n             }\n             ast::ItemKind::Trait(..) => {\n-                self.format_missing_with_indent(item.span.lo());\n-                if let Some(trait_str) = format_trait(&self.get_context(), item, self.block_indent)\n-                {\n-                    self.buffer.push_str(&trait_str);\n-                    self.last_pos = source!(self, item.span).hi();\n-                }\n+                let rw = format_trait(&self.get_context(), item, self.block_indent);\n+                self.push_rewrite(item.span, rw);\n             }\n             ast::ItemKind::ExternCrate(_) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                let new_str = self.snippet(item.span);\n-                if contains_comment(&new_str) {\n-                    self.buffer.push_str(&new_str)\n-                } else {\n-                    let no_whitespace =\n-                        &new_str.split_whitespace().collect::<Vec<&str>>().join(\" \");\n-                    self.buffer\n-                        .push_str(&Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"));\n-                }\n-                self.last_pos = source!(self, item.span).hi();\n+                let rw = rewrite_extern_crate(&self.get_context(), item);\n+                self.push_rewrite(item.span, rw);\n             }\n             ast::ItemKind::Struct(ref def, ref generics) => {\n-                let rewrite = {\n-                    let indent = self.block_indent;\n-                    let context = self.get_context();\n-                    ::items::format_struct(\n-                        &context,\n-                        \"struct \",\n-                        item.ident,\n-                        &item.vis,\n-                        def,\n-                        Some(generics),\n-                        item.span,\n-                        indent,\n-                        None,\n-                    ).map(|s| match *def {\n-                        ast::VariantData::Tuple(..) => s + \";\",\n-                        _ => s,\n-                    })\n-                };\n+                let rewrite = format_struct(\n+                    &self.get_context(),\n+                    \"struct \",\n+                    item.ident,\n+                    &item.vis,\n+                    def,\n+                    Some(generics),\n+                    item.span,\n+                    self.block_indent,\n+                    None,\n+                ).map(|s| match *def {\n+                    ast::VariantData::Tuple(..) => s + \";\",\n+                    _ => s,\n+                });\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Enum(ref def, ref generics) => {\n@@ -474,7 +452,7 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Union(ref def, ref generics) => {\n-                let rewrite = ::items::format_struct_struct(\n+                let rewrite = format_struct_struct(\n                     &self.get_context(),\n                     \"union \",\n                     item.ident,\n@@ -1042,3 +1020,15 @@ fn get_derive_args(context: &RewriteContext, attr: &ast::Attribute) -> Option<Ve\n         _ => None,\n     })\n }\n+\n+// Rewrite `extern crate foo;` WITHOUT attributes.\n+pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Option<String> {\n+    assert!(is_extern_crate(item));\n+    let new_str = context.snippet(item.span);\n+    Some(if contains_comment(&new_str) {\n+        new_str\n+    } else {\n+        let no_whitespace = &new_str.split_whitespace().collect::<Vec<&str>>().join(\" \");\n+        String::from(&*Regex::new(r\"\\s;\").unwrap().replace(no_whitespace, \";\"))\n+    })\n+}"}, {"sha": "29460da50aaf230f88475ffd8cf05af95fd1eb72", "filename": "tests/target/configs-reorder_imports_in_group-false.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1fd68da464fc51585f351c81fc2b867211c197e/tests%2Ftarget%2Fconfigs-reorder_imports_in_group-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fd68da464fc51585f351c81fc2b867211c197e/tests%2Ftarget%2Fconfigs-reorder_imports_in_group-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-reorder_imports_in_group-false.rs?ref=a1fd68da464fc51585f351c81fc2b867211c197e", "patch": "@@ -5,7 +5,6 @@\n use dolor;\n /// This comment should stay with `use ipsum;`\n use ipsum;\n-\n use lorem;\n use sit;\n use std::io;"}, {"sha": "7f38fe75a8f91ce9c4cbcc3fc04ccdd18bf57f06", "filename": "tests/target/issue-1124.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1fd68da464fc51585f351c81fc2b867211c197e/tests%2Ftarget%2Fissue-1124.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fd68da464fc51585f351c81fc2b867211c197e/tests%2Ftarget%2Fissue-1124.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1124.rs?ref=a1fd68da464fc51585f351c81fc2b867211c197e", "patch": "@@ -12,10 +12,6 @@ mod a {\n }\n \n use a;\n-\n-\n-\n use x;\n-\n use y;\n use z;"}]}