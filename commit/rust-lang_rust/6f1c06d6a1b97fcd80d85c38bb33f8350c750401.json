{"sha": "6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMWMwNmQ2YTFiOTdmY2Q4MGQ4NWMzOGJiMzNmODM1MGM3NTA0MDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-03T10:42:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-03T10:42:02Z"}, "message": "auto merge of #13244 : cmr/rust/tbaa, r=alexcrichton", "tree": {"sha": "01d0f0d3b8b0d413e21f3f65db252731b8189a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d0f0d3b8b0d413e21f3f65db252731b8189a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "html_url": "https://github.com/rust-lang/rust/commit/6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bda3df6ff894e9b522ede02b15b6772c99e7362", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bda3df6ff894e9b522ede02b15b6772c99e7362", "html_url": "https://github.com/rust-lang/rust/commit/7bda3df6ff894e9b522ede02b15b6772c99e7362"}, {"sha": "46790a7d27be661e94716a5ff8f17688f384a9a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/46790a7d27be661e94716a5ff8f17688f384a9a4", "html_url": "https://github.com/rust-lang/rust/commit/46790a7d27be661e94716a5ff8f17688f384a9a4"}], "stats": {"total": 1162, "additions": 49, "deletions": 1113}, "files": [{"sha": "c722beb43ae955c9e7ebdc487638dad5cf422cf2", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -8,44 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub static rc_base_field_refcnt: uint = 0u;\n-\n-pub static task_field_refcnt: uint = 0u;\n-\n-pub static task_field_stk: uint = 2u;\n-\n-pub static task_field_runtime_sp: uint = 3u;\n-\n-pub static task_field_rust_sp: uint = 4u;\n-\n-pub static task_field_gc_alloc_chain: uint = 5u;\n-\n-pub static task_field_dom: uint = 6u;\n-\n-pub static n_visible_task_fields: uint = 7u;\n-\n-pub static dom_field_interrupt_flag: uint = 1u;\n-\n-pub static frame_glue_fns_field_mark: uint = 0u;\n-\n-pub static frame_glue_fns_field_drop: uint = 1u;\n-\n-pub static frame_glue_fns_field_reloc: uint = 2u;\n-\n pub static box_field_refcnt: uint = 0u;\n pub static box_field_tydesc: uint = 1u;\n-pub static box_field_prev: uint = 2u;\n-pub static box_field_next: uint = 3u;\n pub static box_field_body: uint = 4u;\n \n-pub static general_code_alignment: uint = 16u;\n-\n-pub static tydesc_field_size: uint = 0u;\n-pub static tydesc_field_align: uint = 1u;\n-pub static tydesc_field_drop_glue: uint = 2u;\n pub static tydesc_field_visit_glue: uint = 3u;\n-pub static tydesc_field_name_offset: uint = 4u;\n-pub static n_tydesc_fields: uint = 5u;\n \n // The two halves of a closure: code and environment.\n pub static fn_field_code: uint = 0u;\n@@ -64,5 +31,3 @@ pub static vec_elt_elems: uint = 2u;\n \n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;\n-\n-pub static abi_version: uint = 1u;"}, {"sha": "6de7bb59b6180ea82ee96d0bf6881d7154a47b9f", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -87,29 +87,6 @@ impl<'a> Archive<'a> {\n         Archive { sess: sess, dst: dst }\n     }\n \n-    /// Read a file in the archive\n-    pub fn read(&self, file: &str) -> Vec<u8> {\n-        // Apparently if \"ar p\" is used on windows, it generates a corrupt file\n-        // which has bad headers and LLVM will immediately choke on it\n-        if cfg!(windows) {\n-            let loc = TempDir::new(\"rsar\").unwrap();\n-            let archive = os::make_absolute(&self.dst);\n-            run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n-                                                      &Path::new(file)]);\n-            let result: Vec<u8> =\n-                fs::File::open(&loc.path().join(file)).read_to_end()\n-                                                      .unwrap()\n-                                                      .move_iter()\n-                                                      .collect();\n-            result\n-        } else {\n-            run_ar(self.sess,\n-                   \"p\",\n-                   None,\n-                   [&self.dst, &Path::new(file)]).output.move_iter().collect()\n-        }\n-    }\n-\n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {"}, {"sha": "e9292f54a4b266f6c7c27152f130d44596087416", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -687,16 +687,6 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     exported_name(path, hash, ccx.link_meta.crateid.version_or_default())\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n-                                         t: ty::t,\n-                                         name: &str) -> ~str {\n-    let s = ppaux::ty_to_short_str(ccx.tcx(), t);\n-    let path = [PathName(token::intern(name)),\n-                PathName(token::intern(s))];\n-    let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.as_slice()), None)\n-}\n-\n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {"}, {"sha": "a733d2672e820292b1fecb05b1a6ea0a64a1e518", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(non_uppercase_pattern_statics)]\n #![allow(non_camel_case_types)]\n+#![allow(dead_code)]\n \n use std::c_str::ToCStr;\n use std::cell::RefCell;\n@@ -1911,42 +1912,6 @@ pub fn mk_target_data(string_rep: &str) -> TargetData {\n     }\n }\n \n-/* Memory-managed interface to pass managers. */\n-\n-pub struct pass_manager_res {\n-    pub pm: PassManagerRef,\n-}\n-\n-impl Drop for pass_manager_res {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposePassManager(self.pm);\n-        }\n-    }\n-}\n-\n-pub fn pass_manager_res(pm: PassManagerRef) -> pass_manager_res {\n-    pass_manager_res {\n-        pm: pm\n-    }\n-}\n-\n-pub struct PassManager {\n-    pub llpm: PassManagerRef,\n-    dtor: @pass_manager_res\n-}\n-\n-pub fn mk_pass_manager() -> PassManager {\n-    unsafe {\n-        let llpm = llvm::LLVMCreatePassManager();\n-\n-        PassManager {\n-            llpm: llpm,\n-            dtor: @pass_manager_res(llpm)\n-        }\n-    }\n-}\n-\n /* Memory-managed interface to object files. */\n \n pub struct ObjectFile {"}, {"sha": "264829b18a309453d318327537b153883b2509aa", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -73,8 +73,6 @@ pub static tag_crate_dep: uint = 0x19;\n pub static tag_crate_hash: uint = 0x1a;\n pub static tag_crate_crateid: uint = 0x1b;\n \n-pub static tag_parent_item: uint = 0x1c;\n-\n pub static tag_crate_dep_crateid: uint = 0x1d;\n pub static tag_crate_dep_hash: uint = 0x1e;\n \n@@ -94,10 +92,8 @@ pub static tag_path_len: uint = 0x25;\n pub static tag_path_elem_mod: uint = 0x26;\n pub static tag_path_elem_name: uint = 0x27;\n pub static tag_item_field: uint = 0x28;\n-pub static tag_struct_mut: uint = 0x29;\n \n pub static tag_item_variances: uint = 0x2a;\n-pub static tag_mod_impl_trait: uint = 0x2b;\n /*\n   trait items contain tag_item_trait_method elements,\n   impl items contain tag_item_impl_method elements, and classes\n@@ -108,7 +104,6 @@ pub static tag_mod_impl_trait: uint = 0x2b;\n  */\n pub static tag_item_impl_method: uint = 0x2c;\n pub static tag_item_trait_method_explicit_self: uint = 0x2d;\n-pub static tag_item_trait_method_self_ty_region: uint = 0x2e;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n@@ -173,12 +168,8 @@ pub static tag_lang_items_item_id: uint = 0x4a;\n pub static tag_lang_items_item_node_id: uint = 0x4b;\n \n pub static tag_item_unnamed_field: uint = 0x4c;\n-pub static tag_items_data_item_struct_ctor: uint = 0x4d;\n pub static tag_items_data_item_visibility: uint = 0x4e;\n \n-pub static tag_link_args: uint = 0x4f;\n-pub static tag_link_args_arg: uint = 0x50;\n-\n pub static tag_item_method_tps: uint = 0x51;\n pub static tag_item_method_fty: uint = 0x52;\n "}, {"sha": "4300c2eedbf6d03de76c35f43b4f000be6cc8e71", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -37,12 +37,6 @@ pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: &cstore::CStore, def: ast::DefId)\n-                         -> uint {\n-    let cdata = cstore.get_crate_data(def.krate).data();\n-    return decoder::get_type_param_count(cdata, def.node);\n-}\n-\n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item(cstore: &cstore::CStore,\n                       cnum: ast::CrateNum,\n@@ -244,21 +238,6 @@ pub fn get_impl_vtables(tcx: &ty::ctxt,\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n-pub fn get_impl_method(cstore: &cstore::CStore,\n-                       def: ast::DefId,\n-                       mname: ast::Ident)\n-                    -> Option<ast::DefId> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_method(cstore.intr.clone(), cdata, def.node, mname)\n-}\n-\n-pub fn get_item_visibility(cstore: &cstore::CStore,\n-                           def_id: ast::DefId)\n-                        -> ast::Visibility {\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_visibility(cdata, def_id.node)\n-}\n-\n pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> Vec<(cstore::NativeLibaryKind, ~str)> {"}, {"sha": "e3a3239bdb5b852d11accd3aa22dd4c9db4610fa", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -23,7 +23,6 @@ use std::rc::Rc;\n use collections::HashMap;\n use syntax::ast;\n use syntax::parse::token::IdentInterner;\n-use syntax::crateid::CrateId;\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -98,19 +97,10 @@ impl CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn get_crate_id(&self, cnum: ast::CrateNum) -> CrateId {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_id(cdata.data())\n-    }\n-\n     pub fn set_crate_data(&self, cnum: ast::CrateNum, data: @crate_metadata) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn have_crate_data(&self, cnum: ast::CrateNum) -> bool {\n-        self.metas.borrow().contains_key(&cnum)\n-    }\n-\n     pub fn iter_crate_data(&self, i: |ast::CrateNum, @crate_metadata|) {\n         for (&k, &v) in self.metas.borrow().iter() {\n             i(k, v);"}, {"sha": "dc8acf63719d8258cdd9ac46142edc8ead1c8fbf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -279,13 +279,6 @@ fn item_region_param_defs(item_doc: ebml::Doc, cdata: Cmd)\n     Rc::new(v)\n }\n \n-fn item_ty_param_count(item: ebml::Doc) -> uint {\n-    let mut n = 0u;\n-    reader::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n-                      |_p| { n += 1u; true } );\n-    n\n-}\n-\n fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n@@ -420,10 +413,6 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     }\n }\n \n-pub fn get_type_param_count(data: &[u8], id: ast::NodeId) -> uint {\n-    item_ty_param_count(lookup_item(id, data))\n-}\n-\n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n                       tcx: &ty::ctxt) -> Option<@ty::TraitRef>\n@@ -449,20 +438,6 @@ pub fn get_impl_vtables(cdata: Cmd,\n }\n \n \n-pub fn get_impl_method(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                       name: ast::Ident) -> Option<ast::DefId> {\n-    let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n-    let mut found = None;\n-    reader::tagged_docs(find_item(id, items), tag_item_impl_method, |mid| {\n-        let m_did = reader::with_doc_data(mid, parse_def_id);\n-        if item_name(&*intr, find_item(m_did.node, items)) == name {\n-            found = Some(translate_def_id(cdata, m_did));\n-        }\n-        true\n-    });\n-    found\n-}\n-\n pub fn get_symbol(data: &[u8], id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n@@ -475,14 +450,6 @@ pub enum DefLike {\n     DlField\n }\n \n-pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n-    match def_like {\n-        DlDef(def) => return def,\n-        DlImpl(..) => fail!(\"found impl in def_like_to_def\"),\n-        DlField => fail!(\"found field in def_like_to_def\")\n-    }\n-}\n-\n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     let root = reader::Doc(cdata.data());\n@@ -1030,11 +997,6 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n-                        -> ast::Visibility {\n-    item_visibility(lookup_item(id, cdata.data()))\n-}\n-\n fn get_meta_items(md: ebml::Doc) -> Vec<@ast::MetaItem> {\n     let mut items: Vec<@ast::MetaItem> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n@@ -1103,7 +1065,7 @@ fn list_crate_attributes(md: ebml::Doc, hash: &Svh,\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n-    return get_attributes(reader::Doc(data));\n+    get_attributes(reader::Doc(data))\n }\n \n #[deriving(Clone)]"}, {"sha": "b83f42da0a05681129522e205728ef45f60941dd", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -84,12 +84,6 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.target_triple)\n     }\n \n-    pub fn get_target_lib_file_path(&self, file: &Path) -> Path {\n-        let mut p = self.get_target_lib_path();\n-        p.push(file);\n-        p\n-    }\n-\n     pub fn search(&self, pick: pick) {\n         self.for_each_lib_search_path(|lib_search_path| {\n             debug!(\"searching {}\", lib_search_path.display());"}, {"sha": "e6f6a87be4fdcc41db014e2a242ea4bf3adb5840", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -111,13 +111,6 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n-pub fn encode_exported_macro(ebml_w: &mut Encoder, i: &ast::Item) {\n-    match i.node {\n-        ast::ItemMac(..) => encode_ast(ebml_w, ast::IIItem(@i.clone())),\n-        _ => fail!(\"expected a macro\")\n-    }\n-}\n-\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: &ty::ctxt,\n                            maps: &Maps,\n@@ -173,13 +166,6 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n     }\n }\n \n-pub fn decode_exported_macro(par_doc: ebml::Doc) -> @ast::Item {\n-    match decode_ast(par_doc) {\n-        ast::IIItem(item) => item,\n-        _ => fail!(\"expected item\")\n-    }\n-}\n-\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n "}, {"sha": "6f4f2f6345eb48fa0fe161caa0bfab9d08a8accf", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -326,6 +326,7 @@ pub struct RestrictionSet {\n     bits: u32\n }\n \n+#[allow(dead_code)] // potentially useful\n pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0010};\n@@ -334,10 +335,6 @@ impl RestrictionSet {\n     pub fn intersects(&self, restr: RestrictionSet) -> bool {\n         (self.bits & restr.bits) != 0\n     }\n-\n-    pub fn contains_all(&self, restr: RestrictionSet) -> bool {\n-        (self.bits & restr.bits) == restr.bits\n-    }\n }\n \n impl BitOr<RestrictionSet,RestrictionSet> for RestrictionSet {\n@@ -862,17 +859,6 @@ impl<'a> BorrowckCtxt<'a> {\n     pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n         self.mc().cmt_to_str(cmt)\n     }\n-\n-    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n-        self.mc().mut_to_str(mutbl)\n-    }\n-\n-    pub fn mut_to_keyword(&self, mutbl: ast::Mutability) -> &'static str {\n-        match mutbl {\n-            ast::MutImmutable => \"\",\n-            ast::MutMutable => \"mut\",\n-        }\n-    }\n }\n \n impl DataFlowOperator for LoanDataFlowOperator {"}, {"sha": "97ea996bb7e458e3dd53aecd37b2c375e4b38118", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -15,6 +15,8 @@ Uses `Graph` as the underlying representation.\n \n */\n \n+#![allow(dead_code)] // still a WIP, #6298\n+\n use middle::graph;\n use middle::ty;\n use middle::typeck;"}, {"sha": "bd45956fbb2ac9610ba4a0fc340af12da3324498", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -521,11 +521,3 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n pub fn compare_lit_exprs(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n-\n-pub fn lit_expr_eq(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n-    compare_lit_exprs(tcx, a, b).map(|val| val == 0)\n-}\n-\n-pub fn lit_eq(a: &Lit, b: &Lit) -> Option<bool> {\n-    compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|val| val == 0)\n-}"}, {"sha": "92d359887b98f00aa6c48789e280580d1688cb38", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -246,31 +246,6 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    pub fn each_bit_on_entry(&mut self,\n-                             id: ast::NodeId,\n-                             f: |uint| -> bool)\n-                             -> bool {\n-        //! Iterates through each bit that is set on entry to `id`.\n-        //! Only useful after `propagate()` has been called.\n-\n-        let (start, end) = self.compute_id_range(id);\n-        let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry(id={:?}, on_entry={})\",\n-               id, bits_to_str(on_entry));\n-        self.each_bit(on_entry, f)\n-    }\n-\n-    pub fn each_gen_bit(&mut self, id: ast::NodeId, f: |uint| -> bool)\n-                        -> bool {\n-        //! Iterates through each bit in the gen set for `id`.\n-\n-        let (start, end) = self.compute_id_range(id);\n-        let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id={:?}, gens={})\",\n-               id, bits_to_str(gens));\n-        self.each_bit(gens, f)\n-    }\n-\n     pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n                                -> bool {\n         //! Iterates through each bit in the gen set for `id`."}, {"sha": "d6adb19419b517b0f1375ebdca2e8a522b00fa78", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -145,7 +145,3 @@ pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n         Some(&d) => return d\n     }\n }\n-\n-pub fn has_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> bool {\n-    !get_freevars(tcx, fid).is_empty()\n-}"}, {"sha": "e4603b7eae2601f7e3feb1dccda8da33431ec7f8", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -34,6 +34,8 @@ be indexed by the direction (see the type `Direction`).\n \n */\n \n+#![allow(dead_code)] // still WIP\n+\n use std::uint;\n \n pub struct Graph<N,E> {"}, {"sha": "a667e81f349fe63fb9804e88825cfca06d2c1c22", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -450,17 +450,6 @@ fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     }\n }\n \n-pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n-    if !ty::type_is_sendable(cx.tcx, ty) {\n-        cx.tcx.sess.span_err(\n-            sp, format!(\"value has non-sendable type `{}`\",\n-                     ty_to_str(cx.tcx, ty)));\n-        false\n-    } else {\n-        true\n-    }\n-}\n-\n pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {"}, {"sha": "7fca0e56aa21f67aa4cd802579459a3597c2baed", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -96,6 +96,7 @@ impl LanguageItems {\n     }\n \n     $(\n+        #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {\n             *self.items.get($variant as uint)\n         }"}, {"sha": "e376e66ca6f90c8ba76612db0c44e5d14e8c5aab", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -64,7 +64,7 @@\n \n use middle::ty;\n use middle::typeck;\n-use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n+use util::ppaux::{ty_to_str, Repr};\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -674,20 +674,6 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    /// inherited mutability: used in cases where the mutability of a\n-    /// component is inherited from the base it is a part of. For\n-    /// example, a record field is mutable if it is declared mutable\n-    /// or if the container is mutable.\n-    pub fn inherited_mutability(&mut self,\n-                                base_m: MutabilityCategory,\n-                                interior_m: ast::Mutability)\n-                                -> MutabilityCategory {\n-        match interior_m {\n-            MutImmutable => base_m.inherit(),\n-            MutMutable => McDeclared\n-        }\n-    }\n-\n     pub fn cat_field<N:ast_node>(&mut self,\n                                  node: &N,\n                                  base_cmt: cmt,\n@@ -1114,13 +1100,6 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         Ok(())\n     }\n \n-    pub fn mut_to_str(&mut self, mutbl: ast::Mutability) -> ~str {\n-        match mutbl {\n-          MutMutable => ~\"mutable\",\n-          MutImmutable => ~\"immutable\"\n-        }\n-    }\n-\n     pub fn cmt_to_str(&self, cmt: cmt) -> ~str {\n         match cmt.cat {\n           cat_static_item => {\n@@ -1174,48 +1153,6 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n           }\n         }\n     }\n-\n-    pub fn region_to_str(&self, r: ty::Region) -> ~str {\n-        region_ptr_to_str(self.tcx(), r)\n-    }\n-}\n-\n-/// The node_id here is the node of the expression that references the field.\n-/// This function looks it up in the def map in case the type happens to be\n-/// an enum to determine which variant is in use.\n-pub fn field_mutbl(tcx: &ty::ctxt,\n-                   base_ty: ty::t,\n-                   // FIXME #6993: change type to Name\n-                   f_name: ast::Ident,\n-                   node_id: ast::NodeId)\n-                -> Option<ast::Mutability> {\n-    // Need to refactor so that struct/enum fields can be treated uniformly.\n-    match ty::get(base_ty).sty {\n-      ty::ty_struct(did, _) => {\n-        let r = ty::lookup_struct_fields(tcx, did);\n-        for fld in r.iter() {\n-            if fld.name == f_name.name {\n-                return Some(ast::MutImmutable);\n-            }\n-        }\n-      }\n-      ty::ty_enum(..) => {\n-        match tcx.def_map.borrow().get_copy(&node_id) {\n-          ast::DefVariant(_, variant_id, _) => {\n-            let r = ty::lookup_struct_fields(tcx, variant_id);\n-            for fld in r.iter() {\n-                if fld.name == f_name.name {\n-                    return Some(ast::MutImmutable);\n-                }\n-            }\n-          }\n-          _ => {}\n-        }\n-      }\n-      _ => { }\n-    }\n-\n-    return None;\n }\n \n pub enum InteriorSafety {"}, {"sha": "2d50d2e0f772b45376ed17d392f02f598823496c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -86,12 +86,6 @@ pub fn pat_bindings(dm: resolve::DefMap,\n     });\n }\n \n-pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> Vec<NodeId> {\n-    let mut found = Vec::new();\n-    pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n-    return found;\n-}\n-\n /// Checks if the pattern contains any patterns that bind something to\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {"}, {"sha": "ad940113a86c498c8c2e74f38549e087d325fdd1", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -149,6 +149,7 @@ impl RegionMaps {\n         self.scope_map.borrow().find(&id).map(|x| *x)\n     }\n \n+    #[allow(dead_code)] // used in middle::cfg\n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         match self.scope_map.borrow().find(&id) {\n@@ -203,12 +204,6 @@ impl RegionMaps {\n         return Some(id);\n     }\n \n-    pub fn encl_region(&self, id: ast::NodeId) -> ty::Region {\n-        //! Returns the narrowest scope region that encloses `id`, if any.\n-\n-        ty::ReScope(self.encl_scope(id))\n-    }\n-\n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the lifetime of the variable `id`.\n "}, {"sha": "b42721b754b54f788f47c0f548871c6cbd9dc62a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -644,25 +644,6 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     }\n }\n \n-/// Access a field, at a point when the value's case is known.\n-pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n-    match *r {\n-        CEnum(..) => {\n-            ccx.sess().bug(\"deref of c-like enum\")\n-        }\n-        Univariant(ref st, _) => {\n-            *st.fields.get(0)\n-        }\n-        General(_, ref cases) => {\n-            assert!(cases.len() == 1);\n-            *cases.get(0).fields.get(0)\n-        }\n-        NullablePointer{ .. } => {\n-            ccx.sess().bug(\"deref of nullable ptr\")\n-        }\n-    }\n-}\n-\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n                        ix: uint) -> ValueRef {\n@@ -896,11 +877,3 @@ fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint)\n         real_ix = real_ix + 1;\n     }\n }\n-\n-/// Is it safe to bitcast a value to the one field of its one variant?\n-pub fn is_newtypeish(r: &Repr) -> bool {\n-    match *r {\n-        Univariant(ref st, false) => st.fields.len() == 1,\n-        _ => false\n-    }\n-}"}, {"sha": "133634a9e791cf94dfb36144d1cfb9bb48fff279", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -77,13 +77,11 @@ use std::cell::{Cell, RefCell};\n use std::libc::c_uint;\n use std::local_data;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n-use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n@@ -447,10 +445,6 @@ pub fn malloc_general<'a>(bcx: &'a Block<'a>, t: ty::t, heap: heap)\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {\n-    get_tydesc(ccx, t).tydesc\n-}\n-\n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     match ccx.tydescs.borrow().find(&t) {\n         Some(&inf) => return inf,\n@@ -464,6 +458,7 @@ pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     return inf;\n }\n \n+#[allow(dead_code)] // useful\n pub fn set_optimize_for_size(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::OptimizeForSizeAttribute)\n }\n@@ -472,6 +467,7 @@ pub fn set_no_inline(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::NoInlineAttribute)\n }\n \n+#[allow(dead_code)] // useful\n pub fn set_no_unwind(f: ValueRef) {\n     lib::llvm::SetFunctionAttribute(f, lib::llvm::NoUnwindAttribute)\n }\n@@ -667,19 +663,6 @@ pub fn compare_scalar_values<'a>(\n pub type val_and_ty_fn<'r,'b> =\n     'r |&'b Block<'b>, ValueRef, ty::t| -> &'b Block<'b>;\n \n-pub fn load_inbounds<'a>(cx: &'a Block<'a>, p: ValueRef, idxs: &[uint])\n-                     -> ValueRef {\n-    return Load(cx, GEPi(cx, p, idxs));\n-}\n-\n-pub fn store_inbounds<'a>(\n-                      cx: &'a Block<'a>,\n-                      v: ValueRef,\n-                      p: ValueRef,\n-                      idxs: &[uint]) {\n-    Store(cx, v, GEPi(cx, p, idxs));\n-}\n-\n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'r,\n                           'b>(\n@@ -975,29 +958,6 @@ pub fn need_invoke(bcx: &Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n-    if ty::type_is_bot(t) {\n-        return C_null(Type::i8p(bcx.ccx()));\n-    }\n-    let llptr = alloc_ty(bcx, t, \"\");\n-    Store(bcx, v, llptr);\n-    return llptr;\n-}\n-\n-// Since this function does *not* root, it is the caller's responsibility to\n-// ensure that the referent is pointed to by a root.\n-pub fn do_spill_noroot(cx: &Block, v: ValueRef) -> ValueRef {\n-    let llptr = alloca(cx, val_ty(v), \"\");\n-    Store(cx, v, llptr);\n-    return llptr;\n-}\n-\n-pub fn spill_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = push_ctxt(\"spill_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n-    return v;\n-}\n-\n pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n@@ -1040,20 +1000,6 @@ pub fn raw_block<'a>(\n     Block::new(llbb, is_lpad, None, fcx)\n }\n \n-pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n-    for s in b.stmts.iter() {\n-        match s.node {\n-          ast::StmtDecl(d, _) => {\n-            match d.node {\n-              ast::DeclLocal(ref local) => it(*local),\n-              _ => {} /* fall through */\n-            }\n-          }\n-          _ => {} /* fall through */\n-        }\n-    }\n-}\n-\n pub fn with_cond<'a>(\n                  bcx: &'a Block<'a>,\n                  val: ValueRef,\n@@ -1173,10 +1119,6 @@ pub fn arrayalloca(cx: &Block, ty: Type, v: ValueRef) -> ValueRef {\n     return ArrayAlloca(cx, ty, v);\n }\n \n-pub struct BasicBlocks {\n-    sa: BasicBlockRef,\n-}\n-\n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n@@ -2142,11 +2084,6 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n     llfn\n }\n \n-pub fn vp2i(cx: &Block, v: ValueRef) -> ValueRef {\n-    let ccx = cx.ccx();\n-    return PtrToInt(cx, v, ccx.int_type);\n-}\n-\n pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstPtrToInt(v, ccx.int_type.to_ref());\n@@ -2315,18 +2252,6 @@ pub fn declare_intrinsics(ccx: &mut CrateContext) {\n     }\n }\n \n-pub fn trap(bcx: &Block) {\n-    match bcx.ccx().intrinsics.find_equiv(& &\"llvm.trap\") {\n-      Some(&x) => { Call(bcx, x, [], []); },\n-      _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n-    }\n-}\n-\n-pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n-    let path = [PathName(token::intern(name))];\n-    link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n-}\n-\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n "}, {"sha": "f40a9ede8622e268c916faa2506bf8f85c0399e9", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)] // FFI wrappers\n \n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};"}, {"sha": "07017de2bc2bcd1dadf67c5882860ccc95385f30", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(dead_code)] // FFI wrappers\n+\n use lib;\n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};"}, {"sha": "2c9be587eaa9ec3bbdfa81b4cc6b191e5d3a5522", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -79,10 +79,6 @@ impl ArgType {\n         }\n     }\n \n-    pub fn is_direct(&self) -> bool {\n-        return self.kind == Direct;\n-    }\n-\n     pub fn is_indirect(&self) -> bool {\n         return self.kind == Indirect;\n     }"}, {"sha": "dae4b2b471b309ba6c8323b8a930a6e28276d004", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -512,48 +512,6 @@ pub fn trans_lang_call<'a>(\n                              dest)\n }\n \n-pub fn trans_lang_call_with_type_params<'a>(\n-                                        bcx: &'a Block<'a>,\n-                                        did: ast::DefId,\n-                                        args: &[ValueRef],\n-                                        type_params: &[ty::t],\n-                                        dest: expr::Dest)\n-                                        -> &'a Block<'a> {\n-    let fty;\n-    if did.krate == ast::LOCAL_CRATE {\n-        fty = ty::node_id_to_type(bcx.tcx(), did.node);\n-    } else {\n-        fty = csearch::get_type(bcx.tcx(), did).ty;\n-    }\n-\n-    return callee::trans_call_inner(\n-        bcx,\n-        None,\n-        fty,\n-        |bcx, _| {\n-            let callee =\n-                trans_fn_ref_with_vtables_to_callee(bcx, did, 0,\n-                                                    type_params,\n-                                                    None);\n-\n-            let new_llval;\n-            match callee.data {\n-                Fn(llfn) => {\n-                    let substituted = ty::subst_tps(callee.bcx.tcx(),\n-                                                    type_params,\n-                                                    None,\n-                                                    fty);\n-                    let llfnty = type_of::type_of(callee.bcx.ccx(),\n-                                                      substituted);\n-                    new_llval = PointerCast(callee.bcx, llfn, llfnty);\n-                }\n-                _ => fail!()\n-            }\n-            Callee { bcx: callee.bcx, data: Fn(new_llval) }\n-        },\n-        ArgVals(args), Some(dest)).bcx;\n-}\n-\n pub fn trans_call_inner<'a>(\n                         bcx: &'a Block<'a>,\n                         call_info: Option<NodeInfo>,"}, {"sha": "4833a233423851e3106c5845f23213d530999c2b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -24,7 +24,6 @@ use middle::trans::datum;\n use middle::trans::datum::{Datum, Lvalue};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n-use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -456,14 +455,6 @@ impl<'a> Block<'a> {\n         e.repr(self.tcx())\n     }\n \n-    pub fn expr_is_lval(&self, e: &ast::Expr) -> bool {\n-        ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n-    }\n-\n-    pub fn expr_kind(&self, e: &ast::Expr) -> ty::ExprKind {\n-        ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n-    }\n-\n     pub fn def(&self, nid: ast::NodeId) -> ast::Def {\n         match self.tcx().def_map.borrow().find(&nid) {\n             Some(&v) => v,\n@@ -504,13 +495,6 @@ pub fn rslt<'a>(bcx: &'a Block<'a>, val: ValueRef) -> Result<'a> {\n     }\n }\n \n-impl<'a> Result<'a> {\n-    pub fn unpack(&self, bcx: &mut &'a Block<'a>) -> ValueRef {\n-        *bcx = self.bcx;\n-        return self.val;\n-    }\n-}\n-\n pub fn val_ty(v: ValueRef) -> Type {\n     unsafe {\n         Type::from_ref(llvm::LLVMTypeOf(v))\n@@ -749,22 +733,6 @@ pub struct mono_id_ {\n \n pub type mono_id = @mono_id_;\n \n-pub fn umax(cx: &Block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n-    return build::Select(cx, cond, b, a);\n-}\n-\n-pub fn umin(cx: &Block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n-    return build::Select(cx, cond, a, b);\n-}\n-\n-pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n-    let bumped = build::Add(cx, off, mask);\n-    return build::And(cx, bumped, build::Not(cx, mask));\n-}\n-\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n@@ -928,14 +896,6 @@ pub fn find_vtable(tcx: &ty::ctxt,\n     param_bounds.get(n_bound).clone()\n }\n \n-pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {\n-    substs {\n-        regions: ty::ErasedRegions,\n-        self_ty: None,\n-        tps: tps\n-    }\n-}\n-\n pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n                                        -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().codemap().lookup_char_pos(span.lo);"}, {"sha": "f98a77eed65a004ce886ba8fcfd29c63f3bfd818", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -20,7 +20,6 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::builder::Builder;\n-use middle::trans::common::{C_i32, C_null};\n use middle::trans::common::{mono_id,ExternMap,tydesc_info,BuilderRef_res,Stats};\n use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n@@ -30,7 +29,6 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n-use std::libc::c_uint;\n use std::ptr;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n@@ -51,45 +49,45 @@ pub struct CrateContext {\n     pub link_meta: LinkMeta,\n     pub drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n     pub tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n-    // Set when running emit_tydescs to enforce that no more tydescs are\n-    // created.\n+    /// Set when running emit_tydescs to enforce that no more tydescs are\n+    /// created.\n     pub finished_tydescs: Cell<bool>,\n-    // Track mapping of external ids to local items imported for inlining\n+    /// Track mapping of external ids to local items imported for inlining\n     pub external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n-    // Backwards version of the `external` map (inlined items to where they\n-    // came from)\n+    /// Backwards version of the `external` map (inlined items to where they\n+    /// came from)\n     pub external_srcs: RefCell<NodeMap<ast::DefId>>,\n-    // A set of static items which cannot be inlined into other crates. This\n-    // will pevent in IIItem() structures from being encoded into the metadata\n-    // that is generated\n+    /// A set of static items which cannot be inlined into other crates. This\n+    /// will pevent in IIItem() structures from being encoded into the metadata\n+    /// that is generated\n     pub non_inlineable_statics: RefCell<NodeSet>,\n-    // Cache instances of monomorphized functions\n+    /// Cache instances of monomorphized functions\n     pub monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n     pub monomorphizing: RefCell<DefIdMap<uint>>,\n-    // Cache generated vtables\n+    /// Cache generated vtables\n     pub vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n-    // Cache of constant strings,\n+    /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<HashMap<InternedString, ValueRef>>,\n \n-    // Reverse-direction for const ptrs cast from globals.\n-    // Key is an int, cast from a ValueRef holding a *T,\n-    // Val is a ValueRef holding a *[T].\n-    //\n-    // Needed because LLVM loses pointer->pointee association\n-    // when we ptrcast, and we have to ptrcast during translation\n-    // of a [T] const because we form a slice, a [*T,int] pair, not\n-    // a pointer to an LLVM array type.\n+    /// Reverse-direction for const ptrs cast from globals.\n+    /// Key is an int, cast from a ValueRef holding a *T,\n+    /// Val is a ValueRef holding a *[T].\n+    ///\n+    /// Needed because LLVM loses pointer->pointee association\n+    /// when we ptrcast, and we have to ptrcast during translation\n+    /// of a [T] const because we form a slice, a [*T,int] pair, not\n+    /// a pointer to an LLVM array type.\n     pub const_globals: RefCell<HashMap<int, ValueRef>>,\n \n-    // Cache of emitted const values\n+    /// Cache of emitted const values\n     pub const_values: RefCell<NodeMap<ValueRef>>,\n \n-    // Cache of external const values\n+    /// Cache of external const values\n     pub extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n     pub impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n-    // Cache of closure wrappers for bare fn's.\n+    /// Cache of closure wrappers for bare fn's.\n     pub closure_bare_wrapper_cache: RefCell<HashMap<ValueRef, ValueRef>>,\n \n     pub lltypes: RefCell<HashMap<ty::t, Type>>,\n@@ -104,9 +102,9 @@ pub struct CrateContext {\n     pub int_type: Type,\n     pub opaque_vec_type: Type,\n     pub builder: BuilderRef_res,\n-    // Set when at least one function uses GC. Needed so that\n-    // decl_gc_metadata knows whether to link to the module metadata, which\n-    // is not emitted by LLVM's GC pass when no functions use GC.\n+    /// Set when at least one function uses GC. Needed so that\n+    /// decl_gc_metadata knows whether to link to the module metadata, which\n+    /// is not emitted by LLVM's GC pass when no functions use GC.\n     pub uses_gc: bool,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext>,\n }\n@@ -232,36 +230,6 @@ impl CrateContext {\n         Builder::new(self)\n     }\n \n-    pub fn const_inbounds_gepi(&self,\n-                               pointer: ValueRef,\n-                               indices: &[uint]) -> ValueRef {\n-        debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n-               self.tn.val_to_str(pointer), indices);\n-        let v: Vec<ValueRef> =\n-            indices.iter().map(|i| C_i32(self, *i as i32)).collect();\n-        unsafe {\n-            llvm::LLVMConstInBoundsGEP(pointer,\n-                                       v.as_ptr(),\n-                                       indices.len() as c_uint)\n-        }\n-    }\n-\n-    pub fn offsetof_gep(&self,\n-                        llptr_ty: Type,\n-                        indices: &[uint]) -> ValueRef {\n-        /*!\n-         * Returns the offset of applying the given GEP indices\n-         * to an instance of `llptr_ty`. Similar to `offsetof` in C,\n-         * except that `llptr_ty` must be a pointer type.\n-         */\n-\n-        unsafe {\n-            let null = C_null(llptr_ty);\n-            llvm::LLVMConstPtrToInt(self.const_inbounds_gepi(null, indices),\n-                                    self.int_type.to_ref())\n-        }\n-    }\n-\n     pub fn tydesc_type(&self) -> Type {\n         self.tn.find_type(\"tydesc\").unwrap()\n     }"}, {"sha": "500a36c5dee60f7fc32527779158c1d425d5609c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -24,12 +24,10 @@ use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n-use middle::trans::write_guard;\n use middle::ty;\n use util::ppaux::{ty_to_str};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n \n /**\n  * A `Datum` encapsulates the result of evaluating an expression.  It\n@@ -160,10 +158,6 @@ pub fn rvalue_scratch_datum(bcx: &Block,\n     Datum(scratch, ty, Rvalue(ByRef))\n }\n \n-pub fn is_by_value_type(ccx: &CrateContext, ty: ty::t) -> bool {\n-    appropriate_rvalue_mode(ccx, ty) == ByValue\n-}\n-\n pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: ty::t) -> RvalueMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n@@ -389,10 +383,7 @@ impl Datum<Expr> {\n         }\n     }\n \n-    pub fn is_by_ref(&self) -> bool {\n-        self.kind.is_by_ref()\n-    }\n-\n+    #[allow(dead_code)] // potentially useful\n     pub fn assert_lvalue(self, bcx: &Block) -> Datum<Lvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n@@ -632,6 +623,7 @@ impl<K:KindOps> Datum<K> {\n         glue::take_ty(bcx, dst, self.ty)\n     }\n \n+    #[allow(dead_code)] // useful for debugging\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         format!(\"Datum({}, {}, {:?})\",\n              ccx.tn.val_to_str(self.val),\n@@ -645,16 +637,6 @@ impl<K:KindOps> Datum<K> {\n         appropriate_rvalue_mode(ccx, self.ty)\n     }\n \n-    pub fn root_and_write_guard<'a>(\n-                                &self,\n-                                bcx: &'a Block<'a>,\n-                                span: Span,\n-                                expr_id: ast::NodeId,\n-                                derefs: uint)\n-                                -> &'a Block<'a> {\n-        write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n-    }\n-\n     pub fn to_llscalarish<'a>(self, bcx: &'a Block<'a>) -> ValueRef {\n         /*!\n          * Converts `self` into a by-value `ValueRef`. Consumes this\n@@ -688,39 +670,13 @@ impl<'a, K:KindOps> DatumBlock<'a, K> {\n }\n \n impl<'a> DatumBlock<'a, Expr> {\n-    pub fn assert_by_ref(self) -> DatumBlock<'a, Expr> {\n-        assert!(self.datum.kind.is_by_ref());\n-        self\n-    }\n-\n-    pub fn store_to(self, dst: ValueRef) -> &'a Block<'a> {\n-        let DatumBlock { bcx, datum } = self;\n-        datum.store_to(bcx, dst)\n-    }\n-\n     pub fn store_to_dest(self,\n                          dest: expr::Dest,\n                          expr_id: ast::NodeId) -> &'a Block<'a> {\n         let DatumBlock { bcx, datum } = self;\n         datum.store_to_dest(bcx, dest, expr_id)\n     }\n \n-    pub fn shallow_copy(self, dst: ValueRef) -> &'a Block<'a> {\n-        self.datum.shallow_copy(self.bcx, dst)\n-    }\n-\n-    pub fn ccx(&self) -> &'a CrateContext {\n-        self.bcx.ccx()\n-    }\n-\n-    pub fn tcx(&self) -> &'a ty::ctxt {\n-        self.bcx.tcx()\n-    }\n-\n-    pub fn to_str(&self) -> ~str {\n-        self.datum.to_str(self.ccx())\n-    }\n-\n     pub fn to_llbool(self) -> Result<'a> {\n         let DatumBlock { datum, bcx } = self;\n         rslt(bcx, datum.to_llbool(bcx))"}, {"sha": "a206d42e5899916b6fe9ddeded2a6c9fbc257e48", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -74,22 +74,6 @@ pub fn trans_impl(ccx: &CrateContext,\n     }\n }\n \n-/// Translates a (possibly monomorphized) method body.\n-///\n-/// Parameters:\n-/// * `method`: the AST node for the method\n-/// * `param_substs`: if this is a generic method, the current values for\n-///   type parameters and so forth, else None\n-/// * `llfn`: the LLVM ValueRef for the method\n-///\n-pub fn trans_method(ccx: &CrateContext, method: &ast::Method,\n-                    param_substs: Option<@param_substs>,\n-                    llfn: ValueRef) -> ValueRef {\n-    trans_fn(ccx, method.decl, method.body,\n-             llfn, param_substs, method.id, []);\n-    llfn\n-}\n-\n pub fn trans_method_callee<'a>(\n                            bcx: &'a Block<'a>,\n                            method_call: MethodCall,"}, {"sha": "7ad9010829c7fc8755419cff13266789fdad25ce", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -46,10 +46,6 @@ impl<'a> Reflector<'a> {\n         C_uint(self.bcx.ccx(), u)\n     }\n \n-    pub fn c_int(&mut self, i: int) -> ValueRef {\n-        C_int(self.bcx.ccx(), i)\n-    }\n-\n     pub fn c_bool(&mut self, b: bool) -> ValueRef {\n         C_bool(self.bcx.ccx(), b)\n     }"}, {"sha": "d8154c6b1f5b5818871d4bca3c41a77d922e9c72", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -55,14 +55,6 @@ pub fn get_fill(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n \n-pub fn set_fill(bcx: &Block, vptr: ValueRef, fill: ValueRef) {\n-    Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n-}\n-\n-pub fn get_alloc(bcx: &Block, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n-}\n-\n pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n@@ -102,15 +94,6 @@ pub fn alloc_raw<'a>(\n     }\n }\n \n-pub fn alloc_uniq_raw<'a>(\n-                      bcx: &'a Block<'a>,\n-                      unit_ty: ty::t,\n-                      fill: ValueRef,\n-                      alloc: ValueRef)\n-                      -> Result<'a> {\n-    alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n-}\n-\n pub fn alloc_uniq_vec<'a>(\n                  bcx: &'a Block<'a>,\n                  unit_ty: ty::t,\n@@ -693,19 +676,6 @@ pub fn iter_vec_raw<'r,\n     }\n }\n \n-pub fn iter_vec_uniq<'r,\n-                     'b>(\n-                     bcx: &'b Block<'b>,\n-                     vptr: ValueRef,\n-                     vec_ty: ty::t,\n-                     fill: ValueRef,\n-                     f: iter_vec_block<'r,'b>)\n-                     -> &'b Block<'b> {\n-    let _icx = push_ctxt(\"tvec::iter_vec_uniq\");\n-    let data_ptr = get_dataptr(bcx, vptr);\n-    iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n-}\n-\n pub fn iter_vec_unboxed<'r,\n                         'b>(\n                         bcx: &'b Block<'b>,"}, {"sha": "55ffa951cf2d7f62b45d81d50db571c9e2a914b4", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -20,7 +20,6 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n use std::cast;\n-use std::slice;\n \n use std::libc::{c_uint};\n \n@@ -135,10 +134,6 @@ impl Type {\n         }\n     }\n \n-    pub fn size_t(ccx: &CrateContext) -> Type {\n-        Type::int(ccx)\n-    }\n-\n     pub fn func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n         ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n@@ -151,10 +146,6 @@ impl Type {\n                                    args.len() as c_uint, True))\n     }\n \n-    pub fn ptr(ty: Type) -> Type {\n-        ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n-    }\n-\n     pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n         ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n@@ -259,17 +250,6 @@ impl Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n-    pub fn get_field(&self, idx: uint) -> Type {\n-        unsafe {\n-            let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n-            let mut elems = slice::from_elem(num_fields, 0 as TypeRef);\n-\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), elems.as_mut_ptr());\n-\n-            Type::from_ref(elems[idx])\n-        }\n-    }\n-\n     pub fn is_packed(&self) -> bool {\n         unsafe {\n             llvm::LLVMIsPackedStruct(self.to_ref()) == True"}, {"sha": "f9296926c748a22128e63c4296658fca631bb435", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 209, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -411,9 +411,6 @@ pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), needs_infer)\n }\n-pub fn type_has_regions(t: t) -> bool {\n-    tbox_has_flag(get(t), has_regions)\n-}\n pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n@@ -1506,10 +1503,6 @@ pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: &ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n-    ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n-}\n-\n // Substitute *only* type parameters.  Used in trans where regions are erased.\n pub fn subst_tps(tcx: &ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n@@ -1623,27 +1616,13 @@ pub fn type_is_structural(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_sequence(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_str(_) | ty_vec(_, _) => true,\n-      _ => false\n-    }\n-}\n-\n pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n     }\n }\n \n-pub fn type_is_str(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_str(_) => true,\n-      _ => false\n-    }\n-}\n-\n pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_str(_) => return mk_mach_uint(ast::TyU8),\n@@ -1672,20 +1651,6 @@ pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n     }\n }\n \n-pub fn get_element_type(ty: t, i: uint) -> t {\n-    match get(ty).sty {\n-      ty_tup(ref ts) => return *ts.get(i),\n-      _ => fail!(\"get_element_type called on invalid type\")\n-    }\n-}\n-\n-pub fn type_is_box(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_box(_) => return true,\n-      _ => return false\n-    }\n-}\n-\n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) => true,\n@@ -1700,35 +1665,13 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_slice(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_)) => true,\n-      _ => return false\n-    }\n-}\n-\n-pub fn type_is_unique_box(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_uniq(_) => return true,\n-      _ => return false\n-    }\n-}\n-\n pub fn type_is_unsafe_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pub fn type_is_vec(ty: t) -> bool {\n-    return match get(ty).sty {\n-          ty_vec(_, _) | ty_unboxed_vec(_) => true,\n-          ty_str(_) => true,\n-          _ => false\n-        };\n-}\n-\n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) | ty_vec(_, vstore_uniq) | ty_str(vstore_uniq) => true,\n@@ -1920,10 +1863,6 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_bounds(&self, cx: &ctxt, bbs: BuiltinBounds) -> bool {\n-        bbs.iter().all(|bb| self.meets_bound(cx, bb))\n-    }\n-\n     pub fn meets_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n             BoundStatic => self.is_static(cx),\n@@ -2021,10 +1960,6 @@ impl TypeContents {\n         v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n-    pub fn inverse(&self) -> TypeContents {\n-        TypeContents { bits: !self.bits }\n-    }\n-\n     pub fn has_dtor(&self) -> bool {\n         self.intersects(TC::OwnsDtor)\n     }\n@@ -2054,10 +1989,6 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_has_dtor(cx: &ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).has_dtor()\n-}\n-\n pub fn type_is_static(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n@@ -2649,14 +2580,8 @@ pub fn type_is_machine(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_enum(ty: t) -> bool {\n-    match get(ty).sty {\n-      ty_enum(_, _) => return true,\n-      _ => return false\n-    }\n-}\n-\n // Is the type's representation size known at compile time?\n+#[allow(dead_code)] // leaving in for DST\n pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n     match get(ty).sty {\n         // FIXME(#6308) add trait, vec, str, etc here.\n@@ -2688,14 +2613,6 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-pub fn type_param(ty: t) -> Option<uint> {\n-    match get(ty).sty {\n-      ty_param(p) => return Some(p.idx),\n-      _ => {/* fall through */ }\n-    }\n-    return None;\n-}\n-\n // Returns the type and mutability of *t.\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n@@ -2758,10 +2675,6 @@ pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n     }\n }\n \n-fn node_id_has_type_params(cx: &ctxt, id: ast::NodeId) -> bool {\n-    cx.node_type_substs.borrow().contains_key(&id)\n-}\n-\n pub fn fn_is_variadic(fty: t) -> bool {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.variadic,\n@@ -2802,16 +2715,6 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     }\n }\n \n-pub fn ty_fn_purity(fty: t) -> ast::Purity {\n-    match get(fty).sty {\n-        ty_bare_fn(ref f) => f.purity,\n-        ty_closure(ref f) => f.purity,\n-        ref s => {\n-            fail!(\"ty_fn_purity() called on non-fn type: {:?}\", s)\n-        }\n-    }\n-}\n-\n pub fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n@@ -2830,14 +2733,6 @@ pub fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-pub fn ty_vstore(ty: t) -> vstore {\n-    match get(ty).sty {\n-        ty_vec(_, vstore) => vstore,\n-        ty_str(vstore) => vstore,\n-        ref s => fail!(\"ty_vstore() called on invalid sty: {:?}\", s)\n-    }\n-}\n-\n pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: t) -> Region {\n@@ -2853,49 +2748,6 @@ pub fn ty_region(tcx: &ctxt,\n     }\n }\n \n-pub fn replace_fn_sig(cx: &ctxt, fsty: &sty, new_sig: FnSig) -> t {\n-    match *fsty {\n-        ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n-        ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..**f}),\n-        ref s => {\n-            cx.sess.bug(\n-                format!(\"ty_fn_sig() called on non-fn type: {:?}\", s));\n-        }\n-    }\n-}\n-\n-pub fn replace_closure_return_type(tcx: &ctxt, fn_type: t, ret_type: t) -> t {\n-    /*!\n-     *\n-     * Returns a new function type based on `fn_type` but returning a value of\n-     * type `ret_type` instead. */\n-\n-    match ty::get(fn_type).sty {\n-        ty::ty_closure(ref fty) => {\n-            ty::mk_closure(tcx, ClosureTy {\n-                sig: FnSig {output: ret_type, ..fty.sig.clone()},\n-                ..(**fty).clone()\n-            })\n-        }\n-        _ => {\n-            tcx.sess.bug(format!(\n-                \"replace_fn_ret() invoked with non-fn-type: {}\",\n-                ty_to_str(tcx, fn_type)));\n-        }\n-    }\n-}\n-\n-// Returns a vec of all the input and output types of fty.\n-pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n-    sig.inputs.iter().map(|a| *a).collect::<Vec<_>>().append_one(sig.output)\n-}\n-\n-// Type accessors for AST nodes\n-pub fn block_ty(cx: &ctxt, b: &ast::Block) -> t {\n-    return node_id_to_type(cx, b.id);\n-}\n-\n-\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n@@ -3187,6 +3039,7 @@ pub struct ParamsTy {\n     pub ty: t\n }\n \n+#[allow(dead_code)] // this may be useful?\n pub fn expr_ty_params_and_ty(cx: &ctxt,\n                              expr: &ast::Expr)\n                           -> ParamsTy {\n@@ -3196,10 +3049,6 @@ pub fn expr_ty_params_and_ty(cx: &ctxt,\n     }\n }\n \n-pub fn expr_has_ty_params(cx: &ctxt, expr: &ast::Expr) -> bool {\n-    return node_id_has_type_params(cx, expr.id);\n-}\n-\n pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n                                    -> Rc<Vec<TypeParameterDef>> {\n     match origin {\n@@ -3423,12 +3272,6 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n     }\n }\n \n-pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n-    let mut i = 0u;\n-    for f in fields.iter() { if f.ident.name == name { return Some(i); } i += 1u; }\n-    return None;\n-}\n-\n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n@@ -3664,14 +3507,6 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n     }\n }\n \n-pub fn def_has_ty_params(def: ast::Def) -> bool {\n-    match def {\n-      ast::DefFn(_, _) | ast::DefVariant(_, _, _) | ast::DefStruct(_)\n-        => true,\n-      _ => false\n-    }\n-}\n-\n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n }\n@@ -3850,8 +3685,8 @@ pub fn try_add_builtin_trait(tcx: &ctxt,\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n-      ty_trait(~TyTrait { def_id: id, .. }) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n-      _ => None\n+        ty_trait(~TyTrait { def_id: id, .. }) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n+        _ => None\n     }\n }\n \n@@ -4247,18 +4082,6 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     }\n }\n \n-pub fn lookup_struct_field(cx: &ctxt,\n-                           parent: ast::DefId,\n-                           field_id: ast::DefId)\n-                        -> field_ty {\n-    let r = lookup_struct_fields(cx, parent);\n-    match r.iter().find(\n-                 |f| f.id.node == field_id.node) {\n-        Some(t) => *t,\n-        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n-    }\n-}\n-\n fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n     fields.iter().map(|field| {\n         match field.node.kind {\n@@ -4368,13 +4191,6 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n }\n \n-pub fn ty_params_to_tys(tcx: &ctxt, generics: &ast::Generics) -> Vec<t> {\n-    Vec::from_fn(generics.ty_params.len(), |i| {\n-        let id = generics.ty_params.get(i).id;\n-        ty::mk_param(tcx, i, ast_util::local_def(id))\n-    })\n-}\n-\n /// Returns an equivalent type with all the typedefs and self regions removed.\n pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n@@ -4554,19 +4370,6 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n-pub fn count_traits_and_supertraits(tcx: &ctxt,\n-                                    type_param_defs: &[TypeParameterDef]) -> uint {\n-    let mut total = 0;\n-    for type_param_def in type_param_defs.iter() {\n-        each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds.as_slice(), |_| {\n-            total += 1;\n-            true\n-        });\n-    }\n-    return total;\n-}\n-\n pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().find_copy(&tydesc_lang_item)\n@@ -5050,12 +4853,4 @@ impl BorrowKind {\n             UniqueImmBorrow => \"uniquely immutable\",\n         }\n     }\n-\n-    pub fn to_short_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mut\",\n-            ImmBorrow => \"imm\",\n-            UniqueImmBorrow => \"own\",\n-        }\n-    }\n }"}, {"sha": "5752a928358831ca541e9e541e3720f60f554d14", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -510,27 +510,6 @@ fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n     fcx\n }\n \n-pub fn check_no_duplicate_fields(tcx: &ty::ctxt,\n-                                 fields: Vec<(ast::Ident, Span)>) {\n-    let mut field_names = HashMap::new();\n-\n-    for p in fields.iter() {\n-        let (id, sp) = *p;\n-        let orig_sp = field_names.find(&id).map(|x| *x);\n-        match orig_sp {\n-            Some(orig_sp) => {\n-                tcx.sess.span_err(sp, format!(\"duplicate field name {} in record type declaration\",\n-                                              token::get_ident(id)));\n-                tcx.sess.span_note(orig_sp, \"first declaration of this field occurred here\");\n-                break;\n-            }\n-            None => {\n-                field_names.insert(id, sp);\n-            }\n-        }\n-    }\n-}\n-\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n@@ -1010,10 +989,6 @@ impl<'a> FnCtxt<'a> {\n         }\n     }\n \n-    pub fn block_region(&self) -> ty::Region {\n-        ty::ReScope(self.region_lb.get())\n-    }\n-\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: ty::t) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n@@ -1100,18 +1075,6 @@ impl<'a> FnCtxt<'a> {\n         }\n     }\n \n-    pub fn node_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n-        match self.inh.node_type_substs.borrow().find(&id) {\n-            Some(ts) => (*ts).clone(),\n-            None => {\n-                self.tcx().sess.bug(\n-                    format!(\"no type substs for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_str(id),\n-                            self.tag()));\n-            }\n-        }\n-    }\n-\n     pub fn method_ty_substs(&self, id: ast::NodeId) -> ty::substs {\n         match self.inh.method_map.borrow().find(&MethodCall::expr(id)) {\n             Some(method) => method.substs.clone(),\n@@ -1167,11 +1130,6 @@ impl<'a> FnCtxt<'a> {\n         }\n     }\n \n-    pub fn can_mk_assignty(&self, sub: ty::t, sup: ty::t)\n-                           -> Result<(), ty::type_err> {\n-        infer::can_mk_coercety(self.infcx(), sub, sup)\n-    }\n-\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,\n@@ -3309,10 +3267,6 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block(fcx0: &FnCtxt, blk: &ast::Block)  {\n-    check_block_with_expected(fcx0, blk, None)\n-}\n-\n pub fn check_block_with_expected(fcx: &FnCtxt,\n                                  blk: &ast::Block,\n                                  expected: Option<ty::t>) {"}, {"sha": "4a03e32dee8245a20f8e3f2f65064643796a5325", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -373,28 +373,6 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n     })\n }\n \n-pub fn eq_opt_regions<C:Combine>(\n-    this: &C,\n-    a: Option<ty::Region>,\n-    b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n-\n-    match (a, b) {\n-        (None, None) => Ok(None),\n-        (Some(a), Some(b)) => eq_regions(this, a, b).then(|| Ok(Some(a))),\n-        (_, _) => {\n-            // If these two substitutions are for the same type (and\n-            // they should be), then the type should either\n-            // consistently have a region parameter or not have a\n-            // region parameter.\n-            this.infcx().tcx.sess.bug(\n-                format!(\"substitution a had opt_region {} and \\\n-                      b had opt_region {}\",\n-                     a.inf_str(this.infcx()),\n-                     b.inf_str(this.infcx())));\n-        }\n-    }\n-}\n-\n pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {"}, {"sha": "bde750eb6f0de3dd89484fe2786ed472ce249956", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -31,10 +31,6 @@ pub struct Lub<'f>(CombineFields<'f>);  // least-upper-bound: common supertype\n \n impl<'f> Lub<'f> {\n     pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Lub(ref v) = *self; v }\n-    pub fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n-    pub fn ty_bot(&self, b: ty::t) -> cres<ty::t> {\n-        self.bot_ty(b) // commutative\n-    }\n }\n \n impl<'f> Combine for Lub<'f> {"}, {"sha": "e01e34a0e5afd2802603e4d1d42f46ed8bc1322f", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -421,19 +421,6 @@ pub fn mk_coercety(cx: &InferCtxt,\n     })\n }\n \n-pub fn can_mk_coercety(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n-    indent(|| {\n-        cx.probe(|| {\n-            let trace = TypeTrace {\n-                origin: Misc(codemap::DUMMY_SP),\n-                values: Types(expected_found(true, a, b))\n-            };\n-            Coerce(cx.combine_fields(true, trace)).tys(a, b)\n-        })\n-    }).to_ures()\n-}\n-\n // See comment on the type `resolve_state` below\n pub fn resolve_type(cx: &InferCtxt,\n                     a: ty::t,\n@@ -631,10 +618,6 @@ impl<'a> InferCtxt<'a> {\n         result\n     }\n \n-    pub fn next_int_var(&self) -> ty::t {\n-        ty::mk_int_var(self.tcx, self.next_int_var_id())\n-    }\n-\n     pub fn next_float_var_id(&self) -> FloatVid {\n         let mut float_var_counter = self.float_var_counter.get();\n         let mut float_var_bindings = self.float_var_bindings.borrow_mut();\n@@ -644,21 +627,10 @@ impl<'a> InferCtxt<'a> {\n         result\n     }\n \n-    pub fn next_float_var(&self) -> ty::t {\n-        ty::mk_float_var(self.tcx, self.next_float_var_id())\n-    }\n-\n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n-    pub fn next_region_vars(&self,\n-                            origin: RegionVariableOrigin,\n-                            count: uint)\n-                            -> Vec<ty::Region> {\n-        Vec::from_fn(count, |_| self.next_region_var(origin))\n-    }\n-\n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n                                 defs: &[ty::RegionParameterDef])"}, {"sha": "5348a623d86cc3d82f8d154eba4a19a670b69c6e", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -52,7 +52,7 @@ use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n-use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n+use middle::typeck::infer::unresolved_ty;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n@@ -64,14 +64,12 @@ pub static resolve_nested_tvar: uint = 0b0000000001;\n pub static resolve_rvar: uint        = 0b0000000010;\n pub static resolve_ivar: uint        = 0b0000000100;\n pub static resolve_fvar: uint        = 0b0000001000;\n-pub static resolve_fnvar: uint       = 0b0000010000;\n-pub static resolve_all: uint         = 0b0000011111;\n+pub static resolve_all: uint         = 0b0000001111;\n pub static force_tvar: uint          = 0b0000100000;\n pub static force_rvar: uint          = 0b0001000000;\n pub static force_ivar: uint          = 0b0010000000;\n pub static force_fvar: uint          = 0b0100000000;\n-pub static force_fnvar: uint         = 0b1000000000;\n-pub static force_all: uint           = 0b1111100000;\n+pub static force_all: uint           = 0b0111100000;\n \n pub static not_regions: uint         = !(force_rvar | resolve_rvar);\n \n@@ -204,15 +202,6 @@ impl<'a> ResolveState<'a> {\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    pub fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n-        match r {\n-          ty::ReInfer(ty::ReVar(rid2)) => {\n-            self.err = Some(region_var_bound_by_region_var(rid, rid2));\n-          }\n-          _ => { }\n-        }\n-    }\n-\n     pub fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n         if self.v_seen.contains(&vid) {\n             self.err = Some(cyclic_ty(vid));"}, {"sha": "fb82bf9968afc1b80ceb4cfa4178c905003bb134", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -264,15 +264,6 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n         tcx.node_type_substs.borrow_mut().insert(node_id, substs);\n     }\n }\n-pub fn write_tpt_to_tcx(tcx: &ty::ctxt,\n-                        node_id: ast::NodeId,\n-                        tpt: &ty::ty_param_substs_and_ty) {\n-    write_ty_to_tcx(tcx, node_id, tpt.ty);\n-    if !tpt.substs.tps.is_empty() {\n-        write_substs_to_tcx(tcx, node_id, tpt.substs.tps.clone());\n-    }\n-}\n-\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     match tcx.def_map.borrow().find(&id) {\n         Some(&x) => x,"}, {"sha": "2abbd916d76276bee065f027c581ba9c8d4f88df", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -14,7 +14,6 @@ use middle::ty;\n use std::cell::Cell;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n \n /// Defines strategies for handling regions that are omitted.  For\n /// example, if one writes the type `&Foo`, then the lifetime of\n@@ -72,10 +71,3 @@ impl RegionScope for BindingRscope {\n                                                    ty::BrAnon(idx + i))))\n     }\n }\n-\n-pub fn bound_type_regions(defs: &[ty::RegionParameterDef])\n-                          -> OwnedSlice<ty::Region> {\n-    assert!(defs.iter().all(|def| def.def_id.krate == ast::LOCAL_CRATE));\n-    defs.iter().enumerate().map(\n-        |(i, def)| ty::ReEarlyBound(def.def_id.node, i, def.name)).collect()\n-}"}, {"sha": "ce8a34c4c23f5f5314c3fcb9da9314722eaadabd", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_camel_case_types)]\n \n use syntax::ast;\n-use syntax::codemap::{Span};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -64,12 +63,6 @@ pub fn indenter() -> _indenter {\n     _indenter(())\n }\n \n-pub fn field_expr(f: ast::Field) -> @ast::Expr { return f.expr; }\n-\n-pub fn field_exprs(fields: Vec<ast::Field> ) -> Vec<@ast::Expr> {\n-    fields.move_iter().map(|f| f.expr).collect()\n-}\n-\n struct LoopQueryVisitor<'a> {\n     p: 'a |&ast::Expr_| -> bool,\n     flag: bool,\n@@ -120,16 +113,3 @@ pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n     visit::walk_block(&mut v, b, ());\n     return v.flag;\n }\n-\n-pub fn local_rhs_span(l: &ast::Local, def: Span) -> Span {\n-    match l.init {\n-      Some(i) => return i.span,\n-      _ => return def\n-    }\n-}\n-\n-pub fn pluralize(n: uint, s: ~str) -> ~str {\n-    if n == 1 { s }\n-    else { format!(\"{}s\", s) }\n-}\n-"}, {"sha": "0f7de94a92d8c0a1746ac2d027108dc8a4700516", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f1c06d6a1b97fcd80d85c38bb33f8350c750401/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6f1c06d6a1b97fcd80d85c38bb33f8350c750401", "patch": "@@ -58,14 +58,6 @@ pub fn note_and_explain_region(cx: &ctxt,\n     }\n }\n \n-/// Returns a string like \"the block at 27:31\" that attempts to explain a\n-/// lifetime in a way it might plausibly be understood.\n-pub fn explain_region(cx: &ctxt, region: ty::Region) -> ~str {\n-  let (res, _) = explain_region_and_span(cx, region);\n-  return res;\n-}\n-\n-\n pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n@@ -165,42 +157,6 @@ pub fn bound_region_to_str(cx: &ctxt,\n     }\n }\n \n-pub fn ReScope_id_to_str(cx: &ctxt, node_id: ast::NodeId) -> ~str {\n-    match cx.map.find(node_id) {\n-      Some(ast_map::NodeBlock(ref blk)) => {\n-        format!(\"<block at {}>\",\n-             cx.sess.codemap().span_to_str(blk.span))\n-      }\n-      Some(ast_map::NodeExpr(expr)) => {\n-        match expr.node {\n-          ast::ExprCall(..) => {\n-            format!(\"<call at {}>\",\n-                 cx.sess.codemap().span_to_str(expr.span))\n-          }\n-          ast::ExprMatch(..) => {\n-            format!(\"<match at {}>\",\n-                 cx.sess.codemap().span_to_str(expr.span))\n-          }\n-          ast::ExprAssignOp(..) |\n-          ast::ExprUnary(..) |\n-          ast::ExprBinary(..) |\n-          ast::ExprIndex(..) => {\n-            format!(\"<method at {}>\",\n-                 cx.sess.codemap().span_to_str(expr.span))\n-          }\n-          _ => {\n-            format!(\"<expression at {}>\",\n-                 cx.sess.codemap().span_to_str(expr.span))\n-          }\n-        }\n-      }\n-      None => {\n-        format!(\"<unknown-{}>\", node_id)\n-      }\n-      _ => cx.sess.bug(format!(\"ReScope refers to {}\", cx.map.node_to_str(node_id)))\n-    }\n-}\n-\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n@@ -280,10 +236,6 @@ pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn tys_to_str(cx: &ctxt, ts: &[t]) -> ~str {\n-    vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n-}\n-\n pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> ~str {\n     format!(\"fn{}{} -> {}\",\n             typ.binder_id,"}]}