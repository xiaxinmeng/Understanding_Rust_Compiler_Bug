{"sha": "36527360a66024d0e3f971c0732efc52368afc8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTI3MzYwYTY2MDI0ZDBlM2Y5NzFjMDczMmVmYzUyMzY4YWZjOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T15:28:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-27T15:28:37Z"}, "message": "auto merge of #7429 : Blei/rust/delete-shared, r=huonw\n\nMostly just low-haning fruit, i.e. function arguments that were @ even\r\nthough & would work just as well.\r\n\r\nReduces librustc.so size by 200k when compiling without -O, by 100k when\r\ncompiling with -O.", "tree": {"sha": "483fc064907f6b9000696270117ac0fa44141f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/483fc064907f6b9000696270117ac0fa44141f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36527360a66024d0e3f971c0732efc52368afc8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36527360a66024d0e3f971c0732efc52368afc8b", "html_url": "https://github.com/rust-lang/rust/commit/36527360a66024d0e3f971c0732efc52368afc8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36527360a66024d0e3f971c0732efc52368afc8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c440743dcc17635eb65cc509a473d66dc6654e87", "url": "https://api.github.com/repos/rust-lang/rust/commits/c440743dcc17635eb65cc509a473d66dc6654e87", "html_url": "https://github.com/rust-lang/rust/commit/c440743dcc17635eb65cc509a473d66dc6654e87"}, {"sha": "7295a6da92ac4bfcbc714848bd611dae54df0b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/7295a6da92ac4bfcbc714848bd611dae54df0b67", "html_url": "https://github.com/rust-lang/rust/commit/7295a6da92ac4bfcbc714848bd611dae54df0b67"}], "stats": {"total": 815, "additions": 388, "deletions": 427}, "files": [{"sha": "2229a85836aa278200ad4c2eb236a663d22e3ffa", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -181,12 +181,12 @@ pub fn compile_rest(sess: Session,\n \n     let time_passes = sess.time_passes();\n \n-    let mut crate_opt = curr;\n+    let mut crate = curr.unwrap();\n \n     if phases.from == cu_parse || phases.from == cu_everything {\n \n         *sess.building_library = session::building_library(\n-            sess.opts.crate_type, crate_opt.unwrap(), sess.opts.test);\n+            sess.opts.crate_type, crate, sess.opts.test);\n \n         // strip before expansion to allow macros to depend on\n         // configuration variables e.g/ in\n@@ -195,27 +195,25 @@ pub fn compile_rest(sess: Session,\n         //   mod bar { macro_rules! baz!(() => {{}}) }\n         //\n         // baz! should not use this definition unless foo is enabled.\n-        crate_opt = Some(time(time_passes, ~\"configuration 1\", ||\n-                     front::config::strip_unconfigured_items(crate_opt.unwrap())));\n+        crate = time(time_passes, ~\"configuration 1\", ||\n+                     front::config::strip_unconfigured_items(crate));\n \n-        crate_opt = Some(time(time_passes, ~\"expansion\", ||\n+        crate = time(time_passes, ~\"expansion\", ||\n                      syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n-                                                       crate_opt.unwrap())));\n+                                                       crate));\n \n         // strip again, in case expansion added anything with a #[cfg].\n-        crate_opt = Some(time(time_passes, ~\"configuration 2\", ||\n-                     front::config::strip_unconfigured_items(crate_opt.unwrap())));\n+        crate = time(time_passes, ~\"configuration 2\", ||\n+                     front::config::strip_unconfigured_items(crate));\n \n-        crate_opt = Some(time(time_passes, ~\"maybe building test harness\", ||\n-                     front::test::modify_for_testing(sess, crate_opt.unwrap())));\n+        crate = time(time_passes, ~\"maybe building test harness\", ||\n+                     front::test::modify_for_testing(sess, crate));\n     }\n \n-    if phases.to == cu_expand { return (crate_opt, None); }\n+    if phases.to == cu_expand { return (Some(crate), None); }\n \n     assert!(phases.from != cu_no_trans);\n \n-    let mut crate = crate_opt.unwrap();\n-\n     let (llcx, llmod, link_meta) = {\n         crate = time(time_passes, ~\"extra injection\", ||\n                      front::std_inject::maybe_inject_libstd_ref(sess, crate));"}, {"sha": "b5eb351a8a5896f25725982cc8769ca279300ffc", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -349,7 +349,7 @@ pub fn expect<T:Copy>(sess: Session,\n }\n \n pub fn building_library(req_crate_type: crate_type,\n-                        crate: @ast::crate,\n+                        crate: &ast::crate,\n                         testing: bool) -> bool {\n     match req_crate_type {\n       bin_crate => false,"}, {"sha": "43098b98ea3b57ef73ed2c3a3654c9cd1ec5991a", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -24,11 +24,11 @@ struct Context {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     do strip_items(crate) |attrs| {\n-        in_cfg(/*bad*/copy crate.node.config, attrs)\n+        in_cfg(crate.node.config, attrs)\n     }\n }\n \n-pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n+pub fn strip_items(crate: &ast::crate, in_cfg: in_cfg_pred)\n     -> @ast::crate {\n \n     let ctxt = @Context { in_cfg: in_cfg };\n@@ -44,8 +44,7 @@ pub fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n           .. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n-    let res = @fold.fold_crate(&*crate);\n-    return res;\n+    @fold.fold_crate(crate)\n }\n \n fn filter_item(cx: @Context, item: @ast::item) ->\n@@ -183,12 +182,12 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n+fn in_cfg(cfg: &[@ast::meta_item], attrs: &[ast::attribute]) -> bool {\n     metas_in_cfg(cfg, attr::attr_metas(attrs))\n }\n \n-pub fn metas_in_cfg(cfg: ast::crate_cfg,\n-                    metas: ~[@ast::meta_item]) -> bool {\n+pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n+                    metas: &[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n     let cfg_metas = attr::find_meta_items_by_name(metas, \"cfg\");\n "}, {"sha": "a86e7c5e39b3aa60459c825b031429e2fc3af002", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -30,11 +30,11 @@ pub fn maybe_inject_libstd_ref(sess: Session, crate: @ast::crate)\n     }\n }\n \n-fn use_std(crate: @ast::crate) -> bool {\n+fn use_std(crate: &ast::crate) -> bool {\n     !attr::attrs_contains_name(crate.node.attrs, \"no_std\")\n }\n \n-fn inject_libstd_ref(sess: Session, crate: @ast::crate) -> @ast::crate {\n+fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n     fn spanned<T:Copy>(x: T) -> codemap::spanned<T> {\n         codemap::spanned { node: x, span: dummy_sp() }\n     }"}, {"sha": "97f1b3997ddc4d11cf89507e61a8b65ea63221b6", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -92,7 +92,7 @@ fn generate_test_harness(sess: session::Session,\n     return res;\n }\n \n-fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n+fn strip_test_functions(crate: &ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {"}, {"sha": "5e36b8fddcc71a81ee390c990426c08fa502e8f4", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -18,7 +18,6 @@ use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n use core::hashmap::HashMap;\n-use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n@@ -30,7 +29,7 @@ use syntax::ast;\n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(diag: @span_handler,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    cstore: @mut cstore::CStore,\n                    filesearch: @FileSearch,\n                    os: loader::os,\n@@ -53,8 +52,8 @@ pub fn read_crates(diag: @span_handler,\n             .. *visit::default_simple_visitor()});\n     visit_crate(e, crate);\n     visit::visit_crate(crate, ((), v));\n-    dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(e, diag, e.crate_cache);\n+    dump_crates(*e.crate_cache);\n+    warn_if_multiple_versions(e, diag, *e.crate_cache);\n }\n \n struct cache_entry {\n@@ -64,7 +63,7 @@ struct cache_entry {\n     metas: @~[@ast::meta_item]\n }\n \n-fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n+fn dump_crates(crate_cache: &[cache_entry]) {\n     debug!(\"resolved crates:\");\n     for crate_cache.iter().advance |entry| {\n         debug!(\"cnum: %?\", entry.cnum);\n@@ -75,11 +74,9 @@ fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n \n fn warn_if_multiple_versions(e: @mut Env,\n                              diag: @span_handler,\n-                             crate_cache: @mut ~[cache_entry]) {\n+                             crate_cache: &[cache_entry]) {\n     use core::either::*;\n \n-    let crate_cache = &mut *crate_cache;\n-\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(\n             *crate_cache[crate_cache.len() - 1].metas\n@@ -111,7 +108,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n             }\n         }\n \n-        warn_if_multiple_versions(e, diag, @mut non_matches);\n+        warn_if_multiple_versions(e, diag, non_matches);\n     }\n }\n \n@@ -126,7 +123,7 @@ struct Env {\n     intr: @ident_interner\n }\n \n-fn visit_crate(e: @mut Env, c: &ast::crate) {\n+fn visit_crate(e: &Env, c: &ast::crate) {\n     let cstore = e.cstore;\n     let link_args = attr::find_attrs_by_name(c.node.attrs, \"link_args\");\n \n@@ -152,7 +149,7 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     }\n }\n \n-fn visit_item(e: @mut Env, i: @ast::item) {\n+fn visit_item(e: &Env, i: @ast::item) {\n     match i.node {\n       ast::item_foreign_mod(ref fm) => {\n         if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n@@ -204,26 +201,25 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @str, key: @str, metas: ~[@ast::meta_item])\n+fn metas_with(ident: @str, key: @str, mut metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n-        vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n-    } else {\n-        metas\n+        metas.push(attr::mk_name_value_item_str(key, ident));\n     }\n+    metas\n }\n \n fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n     metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @str)\n+fn existing_match(e: &Env, metas: &[@ast::meta_item], hash: &str)\n                -> Option<int> {\n     for e.crate_cache.iter().advance |c| {\n         if loader::metadata_matches(*c.metas, metas)\n-            && (hash.is_empty() || c.hash == hash) {\n+            && (hash.is_empty() || c.hash.as_slice() == hash) {\n             return Some(c.cnum);\n         }\n     }"}, {"sha": "f22edd2e1d64ccc621cac3461a8e2270ac810771", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -58,7 +58,7 @@ pub fn check_crate(\n     moves_map: moves::MovesMap,\n     moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n-    crate: @ast::crate) -> (root_map, write_guard_map)\n+    crate: &ast::crate) -> (root_map, write_guard_map)\n {\n     let bccx = @BorrowckCtxt {\n         tcx: tcx,\n@@ -507,7 +507,7 @@ impl BorrowckCtxt {\n     pub fn report_use_of_moved_value(&self,\n                                      use_span: span,\n                                      use_kind: MovedValueUseKind,\n-                                     lp: @LoanPath,\n+                                     lp: &LoanPath,\n                                      move: &move_data::Move,\n                                      moved_lp: @LoanPath) {\n         let verb = match use_kind {\n@@ -570,7 +570,7 @@ impl BorrowckCtxt {\n \n     pub fn report_reassigned_immutable_variable(&self,\n                                                 span: span,\n-                                                lp: @LoanPath,\n+                                                lp: &LoanPath,\n                                                 assign:\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err("}, {"sha": "2c6ba79e96e4537f3f6242370933a7b363a17049", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -21,7 +21,7 @@ use syntax::codemap;\n use syntax::{visit, ast_util, ast_map};\n \n pub fn check_crate(sess: Session,\n-                   crate: @crate,\n+                   crate: &crate,\n                    ast_map: ast_map::map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,"}, {"sha": "190602e815d3da22e3dcdf60cb96aa4f1086f569", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -19,7 +19,7 @@ pub struct Context {\n     can_ret: bool\n }\n \n-pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n+pub fn check_crate(tcx: ty::ctxt, crate: &crate) {\n     visit::visit_crate(crate,\n                        (Context { in_loop: false, can_ret: true },\n                        visit::mk_vt(@visit::Visitor {"}, {"sha": "e2ab3247c19c1e075aee7717c3d3385df3986bf6", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -36,7 +36,7 @@ pub struct MatchCheckCtxt {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n                    moves_map: moves::MovesMap,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n@@ -50,7 +50,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n+pub fn expr_is_non_moving_lvalue(cx: &MatchCheckCtxt, expr: &expr) -> bool {\n     if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n         return false;\n     }\n@@ -108,7 +108,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n }\n \n // Check for unreachable patterns\n-pub fn check_arms(cx: @MatchCheckCtxt, arms: &[arm]) {\n+pub fn check_arms(cx: &MatchCheckCtxt, arms: &[arm]) {\n     let mut seen = ~[];\n     for arms.iter().advance |arm| {\n         for arm.pats.iter().advance |pat| {\n@@ -131,7 +131,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n     }\n }\n \n-pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n+pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n         not_useful => {\n@@ -205,7 +205,7 @@ pub enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n+pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match m.iter().find_(|r| r[0].id != 0) {\n@@ -281,7 +281,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     }\n }\n \n-pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n+pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              m: &matrix,\n                              v: &[@pat],\n                              ctor: ctor,\n@@ -297,7 +297,7 @@ pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n+pub fn pat_ctor_id(cx: &MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { None }\n@@ -333,7 +333,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     }\n }\n \n-pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n+pub fn is_wild(cx: &MatchCheckCtxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     match pat.node {\n       pat_wild => { true }\n@@ -347,7 +347,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     }\n }\n \n-pub fn missing_ctor(cx: @MatchCheckCtxt,\n+pub fn missing_ctor(cx: &MatchCheckCtxt,\n                     m: &matrix,\n                     left_ty: ty::t)\n                  -> Option<ctor> {\n@@ -449,7 +449,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn ctor_arity(cx: @MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n+pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(ref fs) => fs.len(),\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n@@ -476,7 +476,7 @@ pub fn wild() -> @pat {\n     @pat {id: 0, node: pat_wild, span: dummy_sp()}\n }\n \n-pub fn specialize(cx: @MatchCheckCtxt,\n+pub fn specialize(cx: &MatchCheckCtxt,\n                   r: &[@pat],\n                   ctor_id: &ctor,\n                   arity: uint,\n@@ -743,12 +743,12 @@ pub fn specialize(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn default(cx: @MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n+pub fn default(cx: &MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n     if is_wild(cx, r[0]) { Some(vec::to_owned(r.tail())) }\n     else { None }\n }\n \n-pub fn check_local(cx: @MatchCheckCtxt,\n+pub fn check_local(cx: &MatchCheckCtxt,\n                    loc: @local,\n                    (s, v): ((),\n                             visit::vt<()>)) {\n@@ -766,7 +766,7 @@ pub fn check_local(cx: @MatchCheckCtxt,\n     check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n }\n \n-pub fn check_fn(cx: @MatchCheckCtxt,\n+pub fn check_fn(cx: &MatchCheckCtxt,\n                 kind: &visit::fn_kind,\n                 decl: &fn_decl,\n                 body: &blk,\n@@ -783,7 +783,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n     }\n }\n \n-pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n+pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n     match cx.tcx.def_map.find(&pat.id) {\n       Some(&def_variant(enum_id, _)) => {\n         if ty::enum_variants(cx.tcx, enum_id).len() != 1u {\n@@ -821,7 +821,7 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n \n // Legality of move bindings checking\n \n-pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n+pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                        is_lvalue: bool,\n                                        has_guard: bool,\n                                        pats: &[@pat]) {"}, {"sha": "df7de540ea9adb48dc6b063569ab7062607302cf", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -75,7 +75,7 @@ pub fn join_all(cs: &[constness]) -> constness {\n     cs.iter().fold(integral_const, |a, b| join(a, *b))\n }\n \n-pub fn classify(e: @expr,\n+pub fn classify(e: &expr,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n@@ -164,7 +164,7 @@ pub fn classify(e: @expr,\n     }\n }\n \n-pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n+pub fn lookup_const(tcx: ty::ctxt, e: &expr) -> Option<@expr> {\n     match tcx.def_map.find(&e.id) {\n         Some(&ast::def_static(def_id, false)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n@@ -203,7 +203,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n+pub fn lookup_constness(tcx: ty::ctxt, e: &expr) -> constness {\n     match lookup_const(tcx, e) {\n         Some(rhs) => {\n             let ty = ty::expr_ty(tcx, rhs);\n@@ -217,7 +217,7 @@ pub fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n     }\n }\n \n-pub fn process_crate(crate: @ast::crate,\n+pub fn process_crate(crate: &ast::crate,\n                      tcx: ty::ctxt) {\n     let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr_post: |e| { classify(e, tcx); },\n@@ -239,14 +239,14 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n+pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n-pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n+pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: &expr)\n                             -> Result<const_val, ~str> {\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n@@ -406,7 +406,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n     }\n }\n \n-pub fn lit_to_const(lit: @lit) -> const_val {\n+pub fn lit_to_const(lit: &lit) -> const_val {\n     match lit.node {\n       lit_str(s) => const_str(s),\n       lit_int(n, _) => const_int(n),\n@@ -434,14 +434,14 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n     }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<int> {\n+pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: @expr, b: @expr) -> Option<bool> {\n+pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &expr, b: &expr) -> Option<bool> {\n     compare_lit_exprs(tcx, a, b).map(|&val| val == 0)\n }\n \n-pub fn lit_eq(a: @lit, b: @lit) -> Option<bool> {\n+pub fn lit_eq(a: &lit, b: &lit) -> Option<bool> {\n     compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|&val| val == 0)\n }"}, {"sha": "654cc25c15e8cb25bdf408b791dd910bb11fcdce", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -47,7 +47,7 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n-                   crate: @ast::crate) {\n+                   crate: &ast::crate) {\n     let context = @mut Context {\n         method_map: method_map,\n         unsafe_context: SafeContext,"}, {"sha": "904a7ec8c871d1f18acd4e04bd2118bc0ce45c07", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -41,7 +41,7 @@ struct EntryContext {\n \n type EntryVisitor = vt<@mut EntryContext>;\n \n-pub fn find_entry_point(session: Session, crate: @crate, ast_map: ast_map::map) {\n+pub fn find_entry_point(session: Session, crate: &crate, ast_map: ast_map::map) {\n \n     // FIXME #4404 android JNI hacks\n     if *session.building_library &&"}, {"sha": "c2f663ae23cd845deec6451ac6246eee208ac6bb", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -88,7 +88,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::blk)\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n+pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::crate) ->\n    freevar_map {\n     let freevars = @mut HashMap::new();\n "}, {"sha": "ef96fa979727a812589d88ae1b5b846c7c0c3a7f", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -17,7 +17,6 @@ use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n-use core::vec;\n use syntax::ast::*;\n use syntax::attr::attrs_contains_name;\n use syntax::codemap::span;\n@@ -63,7 +62,7 @@ pub struct Context {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let ctx = Context {\n         tcx: tcx,\n         method_map: method_map,\n@@ -163,7 +162,7 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n // closure.\n fn with_appropriate_checker(cx: Context, id: node_id,\n                             b: &fn(checker: &fn(Context, @freevar_entry))) {\n-    fn check_for_uniq(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_uniq(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n@@ -175,7 +174,7 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_box(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_box(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n@@ -186,7 +185,7 @@ fn with_appropriate_checker(cx: Context, id: node_id,\n         check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_block(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n+    fn check_for_block(cx: Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n         check_freevar_bounds(cx, fv.span, var_t, bounds);\n@@ -496,8 +495,8 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n /// FIXME(#5723)---This code should probably move into regionck.\n pub fn check_cast_for_escaping_regions(\n     cx: Context,\n-    source: @expr,\n-    target: @expr)\n+    source: &expr,\n+    target: &expr)\n {\n     // Determine what type we are casting to; if it is not an trait, then no\n     // worries."}, {"sha": "cd6070cc638f07624d3dd5acb6f4813df5866304", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -281,80 +281,79 @@ impl LanguageItems {\n     }\n }\n \n-fn LanguageItemCollector(crate: @crate,\n-                         session: Session)\n-                      -> LanguageItemCollector {\n-    let mut item_refs = HashMap::new();\n-\n-    item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n-    item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n-    item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n-    item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n-\n-    item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n-\n-    item_refs.insert(@\"add\", AddTraitLangItem as uint);\n-    item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n-    item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n-    item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n-    item_refs.insert(@\"not\", NotTraitLangItem as uint);\n-    item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n-    item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n-    item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n-    item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n-    item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n-    item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n-\n-    item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n-    item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n-\n-    item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n-    item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n-    item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n-    item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n-    item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n-    item_refs.insert(@\"fail_bounds_check\",\n-                     FailBoundsCheckFnLangItem as uint);\n-    item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-    item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n-    item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n-    item_refs.insert(@\"free\", FreeFnLangItem as uint);\n-    item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n-    item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n-    item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n-    item_refs.insert(@\"check_not_borrowed\",\n-                     CheckNotBorrowedFnLangItem as uint);\n-    item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n-    item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n-    item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n-    item_refs.insert(@\"start\", StartFnLangItem as uint);\n-    item_refs.insert(@\"ty_desc\", TyDescStructLangItem as uint);\n-    item_refs.insert(@\"ty_visitor\", TyVisitorTraitLangItem as uint);\n-    item_refs.insert(@\"opaque\", OpaqueStructLangItem as uint);\n-\n-    LanguageItemCollector {\n-        crate: crate,\n-        session: session,\n-        items: LanguageItems::new(),\n-        item_refs: item_refs\n-    }\n-}\n-\n-struct LanguageItemCollector {\n+struct LanguageItemCollector<'self> {\n     items: LanguageItems,\n \n-    crate: @crate,\n+    crate: &'self crate,\n     session: Session,\n \n     item_refs: HashMap<@str, uint>,\n }\n \n-impl LanguageItemCollector {\n+impl<'self> LanguageItemCollector<'self> {\n+\n+    pub fn new<'a>(crate: &'a crate, session: Session) -> LanguageItemCollector<'a> {\n+        let mut item_refs = HashMap::new();\n+\n+        item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n+        item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n+        item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n+        item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n+\n+        item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n+\n+        item_refs.insert(@\"add\", AddTraitLangItem as uint);\n+        item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n+        item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n+        item_refs.insert(@\"div\", DivTraitLangItem as uint);\n+        item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n+        item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n+        item_refs.insert(@\"not\", NotTraitLangItem as uint);\n+        item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n+        item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n+        item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n+        item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n+        item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n+        item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n+\n+        item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n+        item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n+\n+        item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n+        item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n+        item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n+        item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n+        item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n+        item_refs.insert(@\"fail_bounds_check\",\n+                         FailBoundsCheckFnLangItem as uint);\n+        item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+        item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n+        item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n+        item_refs.insert(@\"free\", FreeFnLangItem as uint);\n+        item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+        item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n+        item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+        item_refs.insert(@\"check_not_borrowed\",\n+                         CheckNotBorrowedFnLangItem as uint);\n+        item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+        item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n+        item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n+        item_refs.insert(@\"start\", StartFnLangItem as uint);\n+        item_refs.insert(@\"ty_desc\", TyDescStructLangItem as uint);\n+        item_refs.insert(@\"ty_visitor\", TyVisitorTraitLangItem as uint);\n+        item_refs.insert(@\"opaque\", OpaqueStructLangItem as uint);\n+\n+        LanguageItemCollector {\n+            crate: crate,\n+            session: session,\n+            items: LanguageItems::new(),\n+            item_refs: item_refs\n+        }\n+    }\n+\n     pub fn match_and_collect_meta_item(&mut self,\n                                        item_def_id: def_id,\n-                                       meta_item: @meta_item) {\n+                                       meta_item: &meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n@@ -386,7 +385,7 @@ impl LanguageItemCollector {\n \n     pub fn match_and_collect_item(&mut self,\n                                   item_def_id: def_id,\n-                                  key: @str,\n+                                  key: &str,\n                                   value: @str) {\n         if \"lang\" != key {\n             return;    // Didn't match.\n@@ -455,10 +454,10 @@ impl LanguageItemCollector {\n     }\n }\n \n-pub fn collect_language_items(crate: @crate,\n+pub fn collect_language_items(crate: &crate,\n                               session: Session)\n                            -> LanguageItems {\n-    let mut collector = LanguageItemCollector(crate, session);\n+    let mut collector = LanguageItemCollector::new(crate, session);\n     collector.collect();\n     let LanguageItemCollector { items, _ } = collector;\n     session.abort_if_errors();"}, {"sha": "ccbd006edec343d9dffe6dfe6d9586c3787b2991", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -701,7 +701,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     })\n }\n \n-fn check_item_default_methods(cx: &Context, item: @ast::item) {\n+fn check_item_default_methods(cx: &Context, item: &ast::item) {\n     match item.node {\n         ast::item_trait(_, _, ref methods) => {\n             for methods.iter().advance |method| {\n@@ -718,8 +718,8 @@ fn check_item_default_methods(cx: &Context, item: @ast::item) {\n     }\n }\n \n-fn check_item_ctypes(cx: &Context, it: @ast::item) {\n-    fn check_ty(cx: &Context, ty: @ast::Ty) {\n+fn check_item_ctypes(cx: &Context, it: &ast::item) {\n+    fn check_ty(cx: &Context, ty: &ast::Ty) {\n         match ty.node {\n             ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n@@ -797,7 +797,7 @@ fn check_type(cx: &Context, span: span, ty: ty::t) {\n     }\n }\n \n-fn check_item_heap(cx: &Context, it: @ast::item) {\n+fn check_item_heap(cx: &Context, it: &ast::item) {\n     match it.node {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n@@ -851,7 +851,7 @@ fn lint_path_statement() -> visit::vt<@mut Context> {\n     })\n }\n \n-fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n+fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n@@ -973,7 +973,7 @@ fn lint_session() -> visit::vt<@mut Context> {\n fn lint_unnecessary_allocations() -> visit::vt<@mut Context> {\n     // Warn if string and vector literals with sigils are immediately borrowed.\n     // Those can have the sigil removed.\n-    fn check(cx: &Context, e: @ast::expr) {\n+    fn check(cx: &Context, e: &ast::expr) {\n         match e.node {\n             ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n             ast::expr_vstore(e2, ast::expr_vstore_box) => {"}, {"sha": "86b8b2943198e1ef6d36bbb7ff55f59aef88dad2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -150,7 +150,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    capture_map: moves::CaptureMap,\n-                   crate: @crate) {\n+                   crate: &crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -322,7 +322,7 @@ impl IrMaps {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n-    pub fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n+    pub fn captures(&mut self, expr: &expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n           Some(&caps) => caps,\n           None => {\n@@ -596,7 +596,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n+    pub fn variable_from_path(&self, expr: &expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n@@ -923,7 +923,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_stmt(&self, stmt: @stmt, succ: LiveNode)\n+    pub fn propagate_through_stmt(&self, stmt: &stmt, succ: LiveNode)\n                                   -> LiveNode {\n         match stmt.node {\n           stmt_decl(decl, _) => {\n@@ -940,7 +940,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n+    pub fn propagate_through_decl(&self, decl: &decl, succ: LiveNode)\n                                   -> LiveNode {\n         match decl.node {\n             decl_local(ref local) => {\n@@ -950,7 +950,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_local(&self, local: @local, succ: LiveNode)\n+    pub fn propagate_through_local(&self, local: &local, succ: LiveNode)\n                                    -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n@@ -1293,7 +1293,7 @@ impl Liveness {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    pub fn write_lvalue(&self, expr: @expr, succ: LiveNode, acc: uint)\n+    pub fn write_lvalue(&self, expr: &expr, succ: LiveNode, acc: uint)\n                         -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n@@ -1306,7 +1306,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n+    pub fn access_path(&self, expr: &expr, succ: LiveNode, acc: uint)\n                        -> LiveNode {\n         let def = self.tcx.def_map.get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n@@ -1324,7 +1324,7 @@ impl Liveness {\n     }\n \n     pub fn propagate_through_loop(&self,\n-                                  expr: @expr,\n+                                  expr: &expr,\n                                   cond: Option<@expr>,\n                                   body: &blk,\n                                   succ: LiveNode)"}, {"sha": "68307a49d3b67355ad395757d128036a00c982fe", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -190,7 +190,7 @@ enum UseMode {\n \n pub fn compute_moves(tcx: ty::ctxt,\n                      method_map: method_map,\n-                     crate: @crate) -> MoveMaps\n+                     crate: &crate) -> MoveMaps\n {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_expr: compute_modes_for_expr,\n@@ -521,7 +521,7 @@ impl VisitContext {\n     }\n \n     pub fn use_overloaded_operator(&self,\n-                                   expr: @expr,\n+                                   expr: &expr,\n                                    receiver_expr: @expr,\n                                    arg_exprs: &[@expr],\n                                    visitor: vt<VisitContext>)"}, {"sha": "654d77b2a794b306bd2e859d019a9a3779c4eef5", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -29,7 +29,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n     map\n }\n \n-pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n+pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n             match dm.find(&pat.id) {"}, {"sha": "c3241dca1b87a493b09ff87f418410da5eae73bd", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -40,7 +40,7 @@ use syntax::visit;\n \n pub fn check_crate<'mm>(tcx: ty::ctxt,\n                    method_map: &'mm method_map,\n-                   crate: @ast::crate) {\n+                   crate: &ast::crate) {\n     let privileged_items = @mut ~[];\n \n     // Adds an item to its scope."}, {"sha": "00a44904fed1e69975c91761e354d962eb6c99dd", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 41, "deletions": 63, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -34,8 +34,6 @@ use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n \n-pub type parent = Option<ast::node_id>;\n-\n /**\n The region maps encode information about region relationships.\n \n@@ -68,10 +66,10 @@ pub struct Context {\n     region_maps: @mut RegionMaps,\n \n     // Scope where variables should be parented to\n-    var_parent: parent,\n+    var_parent: Option<ast::node_id>,\n \n     // Innermost enclosing expression\n-    parent: parent,\n+    parent: Option<ast::node_id>,\n }\n \n impl RegionMaps {\n@@ -313,28 +311,16 @@ impl RegionMaps {\n     }\n }\n \n-/// Extracts that current parent from cx, failing if there is none.\n-pub fn parent_id(cx: Context, span: span) -> ast::node_id {\n-    match cx.parent {\n-      None => {\n-        cx.sess.span_bug(span, \"crate should not be parent here\");\n-      }\n-      Some(parent_id) => {\n-        parent_id\n-      }\n-    }\n-}\n-\n /// Records the current parent (if any) as the parent of `child_id`.\n-pub fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n+fn parent_to_expr(cx: Context, child_id: ast::node_id, sp: span) {\n     debug!(\"region::parent_to_expr(span=%?)\",\n            cx.sess.codemap.span_to_str(sp));\n     for cx.parent.iter().advance |parent_id| {\n         cx.region_maps.record_parent(child_id, *parent_id);\n     }\n }\n \n-pub fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Record the parent of this block.\n     parent_to_expr(cx, blk.node.id, blk.span);\n \n@@ -345,17 +331,17 @@ pub fn resolve_block(blk: &ast::blk, (cx, visitor): (Context, visit::vt<Context>\n     visit::visit_block(blk, (new_cx, visitor));\n }\n \n-pub fn resolve_arm(arm: &ast::arm, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_arm(arm: &ast::arm, (cx, visitor): (Context, visit::vt<Context>)) {\n     visit::visit_arm(arm, (cx, visitor));\n }\n \n-pub fn resolve_pat(pat: @ast::pat, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_pat(pat: @ast::pat, (cx, visitor): (Context, visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n     visit::visit_pat(pat, (cx, visitor));\n }\n \n-pub fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context>)) {\n     match stmt.node {\n         ast::stmt_decl(*) => {\n             visit::visit_stmt(stmt, (cx, visitor));\n@@ -370,7 +356,7 @@ pub fn resolve_stmt(stmt: @ast::stmt, (cx, visitor): (Context, visit::vt<Context\n     }\n }\n \n-pub fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context>)) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n@@ -409,27 +395,27 @@ pub fn resolve_expr(expr: @ast::expr, (cx, visitor): (Context, visit::vt<Context\n     visit::visit_expr(expr, (new_cx, visitor));\n }\n \n-pub fn resolve_local(local: @ast::local,\n-                     (cx, visitor) : (Context,\n-                                      visit::vt<Context>)) {\n+fn resolve_local(local: @ast::local,\n+                 (cx, visitor) : (Context,\n+                                  visit::vt<Context>)) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.node.id, local.span);\n     visit::visit_local(local, (cx, visitor));\n }\n \n-pub fn resolve_item(item: @ast::item, (cx, visitor): (Context, visit::vt<Context>)) {\n+fn resolve_item(item: @ast::item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n     visit::visit_item(item, (new_cx, visitor));\n }\n \n-pub fn resolve_fn(fk: &visit::fn_kind,\n-                  decl: &ast::fn_decl,\n-                  body: &ast::blk,\n-                  sp: span,\n-                  id: ast::node_id,\n-                  (cx, visitor): (Context,\n-                                  visit::vt<Context>)) {\n+fn resolve_fn(fk: &visit::fn_kind,\n+              decl: &ast::fn_decl,\n+              body: &ast::blk,\n+              sp: span,\n+              id: ast::node_id,\n+              (cx, visitor): (Context,\n+                              visit::vt<Context>)) {\n     debug!(\"region::resolve_fn(id=%?, \\\n                                span=%?, \\\n                                body.node.id=%?, \\\n@@ -468,7 +454,7 @@ pub fn resolve_fn(fk: &visit::fn_kind,\n \n pub fn resolve_crate(sess: Session,\n                      def_map: resolve::DefMap,\n-                     crate: @ast::crate) -> @mut RegionMaps\n+                     crate: &ast::crate) -> @mut RegionMaps\n {\n     let region_maps = @mut RegionMaps {\n         scope_map: HashMap::new(),\n@@ -522,14 +508,12 @@ pub struct region_dep {\n     id: ast::node_id\n }\n \n-pub type dep_map = @mut HashMap<ast::node_id, @mut ~[region_dep]>;\n-\n pub struct DetermineRpCtxt {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n     region_paramd_items: region_paramd_items,\n-    dep_map: dep_map,\n+    dep_map: @mut HashMap<ast::node_id, @mut ~[region_dep]>,\n     worklist: ~[ast::node_id],\n \n     // the innermost enclosing item id\n@@ -619,14 +603,8 @@ impl DetermineRpCtxt {\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        token::get_ident_interner()),\n                copy self.ambient_variance);\n-        let vec = match self.dep_map.find(&from) {\n-            Some(&vec) => vec,\n-            None => {\n-                let vec = @mut ~[];\n-                let dep_map = self.dep_map;\n-                dep_map.insert(from, vec);\n-                vec\n-            }\n+        let vec = do self.dep_map.find_or_insert_with(from) |_| {\n+            @mut ~[]\n         };\n         let dep = region_dep {\n             ambient_variance: self.ambient_variance,\n@@ -715,21 +693,21 @@ impl DetermineRpCtxt {\n     }\n }\n \n-pub fn determine_rp_in_item(item: @ast::item,\n-                            (cx, visitor): (@mut DetermineRpCtxt,\n-                                            visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_item(item: @ast::item,\n+                        (cx, visitor): (@mut DetermineRpCtxt,\n+                                        visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, (cx, visitor));\n     }\n }\n \n-pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n-                          decl: &ast::fn_decl,\n-                          body: &ast::blk,\n-                          _: span,\n-                          _: ast::node_id,\n-                          (cx, visitor): (@mut DetermineRpCtxt,\n-                                          visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_fn(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::blk,\n+                      _: span,\n+                      _: ast::node_id,\n+                      (cx, visitor): (@mut DetermineRpCtxt,\n+                                      visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.iter().advance |a| {\n@@ -743,17 +721,17 @@ pub fn determine_rp_in_fn(fk: &visit::fn_kind,\n     }\n }\n \n-pub fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n-                                 (cx, visitor): (@mut DetermineRpCtxt,\n-                                                 visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n+                             (cx, visitor): (@mut DetermineRpCtxt,\n+                                             visit::vt<@mut DetermineRpCtxt>)) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, (cx, visitor));\n     }\n }\n \n-pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          (cx, visitor): (@mut DetermineRpCtxt,\n-                                          visit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty(ty: @ast::Ty,\n+                      (cx, visitor): (@mut DetermineRpCtxt,\n+                                      visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -883,7 +861,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n }\n \n-pub fn determine_rp_in_struct_field(\n+fn determine_rp_in_struct_field(\n         cm: @ast::struct_field,\n         (cx, visitor): (@mut DetermineRpCtxt,\n                         visit::vt<@mut DetermineRpCtxt>)) {\n@@ -893,7 +871,7 @@ pub fn determine_rp_in_struct_field(\n pub fn determine_rp_in_crate(sess: Session,\n                              ast_map: ast_map::map,\n                              def_map: resolve::DefMap,\n-                             crate: @ast::crate)\n+                             crate: &ast::crate)\n                           -> region_paramd_items {\n     let cx = @mut DetermineRpCtxt {\n         sess: sess,"}, {"sha": "a2cbc4d6fe05e390c434dd94365803406b07537e", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -406,8 +406,6 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n     }\n }\n \n-pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n-\n pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n@@ -417,6 +415,8 @@ pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     }\n }\n \n+pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n+\n pub fn enter_match<'r>(bcx: block,\n                        dm: DefMap,\n                        m: &[@Match<'r>],\n@@ -1048,7 +1048,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n pub type mk_fail = @fn() -> BasicBlockRef;\n \n pub fn pick_col(m: &[@Match]) -> uint {\n-    fn score(p: @ast::pat) -> uint {\n+    fn score(p: &ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n           ast::pat_ident(_, _, Some(p)) => score(p),\n@@ -1609,7 +1609,7 @@ pub fn compile_submatch(bcx: block,\n }\n \n pub fn trans_match(bcx: block,\n-                   match_expr: @ast::expr,\n+                   match_expr: &ast::expr,\n                    discr_expr: @ast::expr,\n                    arms: ~[ast::arm],\n                    dest: Dest) -> block {"}, {"sha": "a0628bc8e87c43f927f8a3ca26d6dbf201ed76dc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -160,7 +160,7 @@ pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, ty: Type) -> ValueRef {\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, ty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     return llfn;\n@@ -592,8 +592,7 @@ pub fn compare_scalar_values(cx: block,\n     }\n }\n \n-pub type val_pair_fn = @fn(block, ValueRef, ValueRef) -> block;\n-pub type val_and_ty_fn = @fn(block, ValueRef, ty::t) -> block;\n+pub type val_and_ty_fn<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn load_inbounds(cx: block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n@@ -1032,13 +1031,13 @@ pub fn build_return(bcx: block) {\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n-pub fn ignore_lhs(_bcx: block, local: @ast::local) -> bool {\n+pub fn ignore_lhs(_bcx: block, local: &ast::local) -> bool {\n     match local.node.pat.node {\n         ast::pat_wild => true, _ => false\n     }\n }\n \n-pub fn init_local(bcx: block, local: @ast::local) -> block {\n+pub fn init_local(bcx: block, local: &ast::local) -> block {\n \n     debug!(\"init_local(bcx=%s, local.id=%?)\",\n            bcx.to_str(), local.node.id);\n@@ -1378,7 +1377,7 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     }\n }\n \n-pub fn alloc_local(cx: block, local: @ast::local) -> block {\n+pub fn alloc_local(cx: block, local: &ast::local) -> block {\n     let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n@@ -2379,7 +2378,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: &CrateContext, i: @ast::item) -> path {\n+pub fn item_path(ccx: &CrateContext, i: &ast::item) -> path {\n     let base = match ccx.tcx.items.get_copy(&i.id) {\n         ast_map::node_item(_, p) => p,\n             // separate map for paths?\n@@ -2544,7 +2543,7 @@ pub fn register_method(ccx: @mut CrateContext,\n }\n \n // The constant translation pass.\n-pub fn trans_constant(ccx: @mut CrateContext, it: @ast::item) {\n+pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n     let _icx = push_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n@@ -2894,7 +2893,7 @@ pub fn write_abi_version(ccx: &mut CrateContext) {\n }\n \n pub fn trans_crate(sess: session::Session,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc/middle/trans/block.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c440743dcc17635eb65cc509a473d66dc6654e87/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fblock.rs?ref=c440743dcc17635eb65cc509a473d66dc6654e87"}, {"sha": "3ce52a63171eb8ef27002250d85c1f53d976980b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -468,7 +468,7 @@ pub fn make_closure_glue(\n         cx: block,\n         v: ValueRef,\n         t: ty::t,\n-        glue_fn: @fn(block, v: ValueRef, t: ty::t) -> block) -> block {\n+        glue_fn: &fn(block, v: ValueRef, t: ty::t) -> block) -> block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();"}, {"sha": "79d83fbc85703db5fabfbb09f2a9e61bdee005b1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -411,7 +411,6 @@ pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |scope_info| {\n-        let scope_info = &mut *scope_info; // FIXME(#5074) workaround borrowck\n         let cleanup_pos = scope_info.cleanups.iter().position_(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n@@ -473,7 +472,7 @@ pub trait get_node_info {\n     fn info(&self) -> Option<NodeInfo>;\n }\n \n-impl get_node_info for @ast::expr {\n+impl get_node_info for ast::expr {\n     fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo {id: self.id,\n                        callee_id: self.get_callee_id(),\n@@ -573,7 +572,7 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(si: @mut scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(si: &mut scope_info)) {\n     let mut cur = cx;\n     loop {\n         match cur.kind {\n@@ -612,11 +611,11 @@ impl block_ {\n         e.repr(self.tcx())\n     }\n \n-    pub fn expr_is_lval(&self, e: @ast::expr) -> bool {\n+    pub fn expr_is_lval(&self, e: &ast::expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    pub fn expr_kind(&self, e: @ast::expr) -> ty::ExprKind {\n+    pub fn expr_kind(&self, e: &ast::expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n@@ -995,11 +994,11 @@ pub fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n+pub fn expr_ty(bcx: block, ex: &ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: block, ex: @ast::expr) -> ty::t {\n+pub fn expr_ty_adjusted(bcx: block, ex: &ast::expr) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::expr_ty_adjusted(tcx, ex);\n     monomorphize_type(bcx, t)"}, {"sha": "d7b6e9cf5a372c6538cd22debca36ff7576cf52f", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -35,7 +35,7 @@ use core::libc::c_uint;\n use core::str;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: @mut CrateContext, e: @ast::expr, lit: ast::lit)\n+pub fn const_lit(cx: &mut CrateContext, e: &ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -82,7 +82,7 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n+pub fn const_vec(cx: @mut CrateContext, e: &ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, Type) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n@@ -101,7 +101,7 @@ pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n     }\n }\n \n-fn const_addr_of(cx: @mut CrateContext, cv: ValueRef) -> ValueRef {\n+fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n         let gv = do \"const\".as_c_str |name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n@@ -113,7 +113,7 @@ fn const_addr_of(cx: @mut CrateContext, cv: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_ptr(cx: @mut CrateContext, v: ValueRef) -> ValueRef {\n+fn const_deref_ptr(cx: &mut CrateContext, v: ValueRef) -> ValueRef {\n     let v = match cx.const_globals.find(&(v as int)) {\n         Some(&v) => v,\n         None => v\n@@ -124,13 +124,13 @@ fn const_deref_ptr(cx: @mut CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: @mut CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype(cx: &mut CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, repr, v, 0, 0)\n }\n \n-fn const_deref(cx: @mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n+fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n@@ -247,7 +247,7 @@ pub fn const_expr(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     llconst\n }\n \n-fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n+fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n@@ -393,7 +393,8 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                           let llunitty = type_of::type_of(cx, unit_ty);\n                           let unit_sz = machine::llsize_of(cx, llunitty);\n \n-                          (const_deref_ptr(cx, const_get_elt(cx, bv, [0])),\n+                          let e1 = const_get_elt(cx, bv, [0]);\n+                          (const_deref_ptr(cx, e1),\n                            llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n                                                unit_sz))\n                       },"}, {"sha": "862f455aeb6bda4c8e01916c89a44cf93e485058", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -178,7 +178,7 @@ pub fn trans_loop(bcx:block,\n     return next_bcx;\n }\n \n-pub fn trans_log(log_ex: @ast::expr,\n+pub fn trans_log(log_ex: &ast::expr,\n                  lvl: @ast::expr,\n                  bcx: block,\n                  e: @ast::expr) -> block {"}, {"sha": "de56d9a05f15f50f9822b5bd10ea331a23ff2f4d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -723,7 +723,7 @@ impl Datum {\n     }\n \n     /// expr: The deref expression.\n-    pub fn deref(&self, bcx: block, expr: @ast::expr, derefs: uint)\n+    pub fn deref(&self, bcx: block, expr: &ast::expr, derefs: uint)\n                  -> DatumBlock {\n         match self.try_deref(bcx, expr.span, expr.id, derefs, false) {\n             (Some(lvres), bcx) => DatumBlock { bcx: bcx, datum: lvres },"}, {"sha": "02f276cd0503c823f6e6760f9d641431636c8d46", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -254,7 +254,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n     fn auto_slice(bcx: block,\n                   autoderefs: uint,\n-                  expr: @ast::expr,\n+                  expr: &ast::expr,\n                   datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n@@ -280,7 +280,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n-    fn add_env(bcx: block, expr: @ast::expr, datum: Datum) -> DatumBlock {\n+    fn add_env(bcx: block, expr: &ast::expr, datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -301,7 +301,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n     fn auto_slice_and_ref(bcx: block,\n                           autoderefs: uint,\n-                          expr: @ast::expr,\n+                          expr: &ast::expr,\n                           datum: Datum) -> DatumBlock {\n         let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n@@ -705,7 +705,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n     }\n }\n \n-fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n+fn trans_def_dps_unadjusted(bcx: block, ref_expr: &ast::expr,\n                             def: ast::def, dest: Dest) -> block {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n     let ccx = bcx.ccx();\n@@ -752,7 +752,7 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n }\n \n fn trans_def_datum_unadjusted(bcx: block,\n-                              ref_expr: @ast::expr,\n+                              ref_expr: &ast::expr,\n                               def: ast::def) -> DatumBlock\n {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n@@ -776,7 +776,7 @@ fn trans_def_datum_unadjusted(bcx: block,\n     }\n \n     fn fn_data_to_datum(bcx: block,\n-                        ref_expr: @ast::expr,\n+                        ref_expr: &ast::expr,\n                         def_id: ast::def_id,\n                         fn_data: callee::FnData) -> DatumBlock {\n         /*!\n@@ -873,7 +873,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n \n     fn trans_index(bcx: block,\n-                   index_expr: @ast::expr,\n+                   index_expr: &ast::expr,\n                    base: @ast::expr,\n                    idx: @ast::expr) -> DatumBlock {\n         //! Translates `base[idx]`.\n@@ -936,7 +936,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n \n     fn trans_def_lvalue(bcx: block,\n-                        ref_expr: @ast::expr,\n+                        ref_expr: &ast::expr,\n                         def: ast::def)\n         -> DatumBlock\n     {\n@@ -1263,7 +1263,7 @@ fn trans_immediate_lit(bcx: block, expr: @ast::expr,\n }\n \n fn trans_unary_datum(bcx: block,\n-                     un_expr: @ast::expr,\n+                     un_expr: &ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_unary_datum\");\n@@ -1337,7 +1337,7 @@ fn trans_unary_datum(bcx: block,\n     }\n }\n \n-fn trans_addr_of(bcx: block, expr: @ast::expr,\n+fn trans_addr_of(bcx: block, expr: &ast::expr,\n                  subexpr: @ast::expr) -> DatumBlock {\n     let _icx = push_ctxt(\"trans_addr_of\");\n     let mut bcx = bcx;\n@@ -1349,7 +1349,7 @@ fn trans_addr_of(bcx: block, expr: @ast::expr,\n // Important to get types for both lhs and rhs, because one might be _|_\n // and the other not.\n fn trans_eager_binop(bcx: block,\n-                     binop_expr: @ast::expr,\n+                     binop_expr: &ast::expr,\n                      binop_ty: ty::t,\n                      op: ast::binop,\n                      lhs_datum: &Datum,\n@@ -1447,7 +1447,7 @@ fn trans_eager_binop(bcx: block,\n enum lazy_binop_ty { lazy_and, lazy_or }\n \n fn trans_lazy_binop(bcx: block,\n-                    binop_expr: @ast::expr,\n+                    binop_expr: &ast::expr,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n                     b: @ast::expr) -> DatumBlock {\n@@ -1492,7 +1492,7 @@ fn trans_lazy_binop(bcx: block,\n }\n \n fn trans_binary(bcx: block,\n-                binop_expr: @ast::expr,\n+                binop_expr: &ast::expr,\n                 op: ast::binop,\n                 lhs: @ast::expr,\n                 rhs: @ast::expr) -> DatumBlock\n@@ -1518,7 +1518,7 @@ fn trans_binary(bcx: block,\n }\n \n fn trans_overloaded_op(bcx: block,\n-                       expr: @ast::expr,\n+                       expr: &ast::expr,\n                        callee_id: ast::node_id,\n                        rcvr: @ast::expr,\n                        args: ~[@ast::expr],"}, {"sha": "6263ffb318eb28ed1043ecd18e8e57d888db9745", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -55,7 +55,7 @@ fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n+pub fn link_name(ccx: &CrateContext, i: &ast::foreign_item) -> @str {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n@@ -89,7 +89,7 @@ struct LlvmSignature {\n     sret: bool,\n }\n \n-fn foreign_signature(ccx: @mut CrateContext, fn_sig: &ty::FnSig)\n+fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -138,7 +138,7 @@ type shim_ret_builder<'self> =\n               llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @mut CrateContext,\n-                  shim_name: ~str,\n+                  shim_name: &str,\n                   llbasefn: ValueRef,\n                   tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n@@ -357,7 +357,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n     }\n \n     fn build_shim_fn(ccx: @mut CrateContext,\n-                     foreign_item: @ast::foreign_item,\n+                     foreign_item: &ast::foreign_item,\n                      tys: &ShimTypes,\n                      cc: lib::llvm::CallConv)\n                   -> ValueRef {\n@@ -419,7 +419,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n     // over the place\n     fn build_direct_fn(ccx: @mut CrateContext,\n                        decl: ValueRef,\n-                       item: @ast::foreign_item,\n+                       item: &ast::foreign_item,\n                        tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n         debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n@@ -446,7 +446,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n     // over the place\n     fn build_fast_ffi_fn(ccx: @mut CrateContext,\n                          decl: ValueRef,\n-                         item: @ast::foreign_item,\n+                         item: &ast::foreign_item,\n                          tys: &ShimTypes,\n                          cc: lib::llvm::CallConv) {\n         debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n@@ -541,7 +541,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n \n pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        decl: ValueRef,\n-                       item: @ast::foreign_item,\n+                       item: &ast::foreign_item,\n                        path: ast_map::path,\n                        substs: @param_substs,\n                        attributes: &[ast::attribute],"}, {"sha": "0172b70546593942b9307d37e7a67d9ea863ec0d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -205,7 +205,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n                                           field: uint,\n-                                          ti: @mut tydesc_info) -> bool {\n+                                          ti: &mut tydesc_info) -> bool {\n     let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n@@ -244,7 +244,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"take\");\n             ti.take_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n             debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n@@ -257,7 +257,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"drop\");\n             ti.drop_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n             debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n@@ -270,7 +270,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n             ti.free_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n             debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n@@ -283,7 +283,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n           None => {\n             debug!(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue = Some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n             debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n@@ -627,12 +627,12 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n-      ty::ty_struct(did, ref substs) => {\n+      ty::ty_struct(did, _) => {\n         let tcx = bcx.tcx();\n         let bcx = iter_structural_ty(bcx, v, t, take_ty);\n \n         match ty::ty_dtor(tcx, did) {\n-          ty::TraitDtor(dtor, false) => {\n+          ty::TraitDtor(_, false) => {\n             // Zero out the struct\n             unsafe {\n                 let ty = Type::from_ref(llvm::LLVMTypeOf(v));\n@@ -700,12 +700,11 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper = @fn(block, ValueRef, ty::t);\n+pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t);\n \n-pub fn declare_generic_glue(ccx: @mut CrateContext, t: ty::t, llfnty: Type,\n-                            name: ~str) -> ValueRef {\n+pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n+                            name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n-    let name = name;\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n     debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);"}, {"sha": "ebcc3d811eba7e2ddaaa981bc9c58f3f83bf92a5", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -357,7 +357,7 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     ms.iter().find_(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n \n-pub fn method_with_name_or_default(ccx: @mut CrateContext,\n+pub fn method_with_name_or_default(ccx: &mut CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n@@ -742,8 +742,8 @@ pub fn get_vtable(bcx: block,\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: @mut CrateContext,\n-                   tydesc: @mut tydesc_info,\n+pub fn make_vtable(ccx: &mut CrateContext,\n+                   tydesc: &tydesc_info,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {\n     unsafe {\n@@ -770,7 +770,7 @@ pub fn make_vtable(ccx: @mut CrateContext,\n pub fn make_impl_vtable(bcx: block,\n                         impl_id: ast::def_id,\n                         self_ty: ty::t,\n-                        substs: ~[ty::t],\n+                        substs: &[ty::t],\n                         vtables: typeck::vtable_res)\n                         -> ValueRef {\n     let ccx = bcx.ccx();"}, {"sha": "16695ad59a077ab80d273b14644bbcd7bf889a9e", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -86,7 +86,7 @@ impl Reflector {\n           self.c_tydesc(mt.ty)]\n     }\n \n-    pub fn visit(&mut self, ty_name: ~str, args: &[ValueRef]) {\n+    pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n@@ -122,7 +122,7 @@ impl Reflector {\n     }\n \n     pub fn bracketed(&mut self,\n-                     bracket_name: ~str,\n+                     bracket_name: &str,\n                      extra: &[ValueRef],\n                      inner: &fn(&mut Reflector)) {\n         self.visit(~\"enter_\" + bracket_name, extra);\n@@ -146,7 +146,7 @@ impl Reflector {\n         }\n     }\n \n-    pub fn leaf(&mut self, name: ~str) {\n+    pub fn leaf(&mut self, name: &str) {\n         self.visit(name, []);\n     }\n \n@@ -156,27 +156,27 @@ impl Reflector {\n         debug!(\"reflect::visit_ty %s\", ty_to_str(bcx.ccx().tcx, t));\n \n         match ty::get(t).sty {\n-          ty::ty_bot => self.leaf(~\"bot\"),\n-          ty::ty_nil => self.leaf(~\"nil\"),\n-          ty::ty_bool => self.leaf(~\"bool\"),\n-          ty::ty_int(ast::ty_i) => self.leaf(~\"int\"),\n-          ty::ty_int(ast::ty_char) => self.leaf(~\"char\"),\n-          ty::ty_int(ast::ty_i8) => self.leaf(~\"i8\"),\n-          ty::ty_int(ast::ty_i16) => self.leaf(~\"i16\"),\n-          ty::ty_int(ast::ty_i32) => self.leaf(~\"i32\"),\n-          ty::ty_int(ast::ty_i64) => self.leaf(~\"i64\"),\n-          ty::ty_uint(ast::ty_u) => self.leaf(~\"uint\"),\n-          ty::ty_uint(ast::ty_u8) => self.leaf(~\"u8\"),\n-          ty::ty_uint(ast::ty_u16) => self.leaf(~\"u16\"),\n-          ty::ty_uint(ast::ty_u32) => self.leaf(~\"u32\"),\n-          ty::ty_uint(ast::ty_u64) => self.leaf(~\"u64\"),\n-          ty::ty_float(ast::ty_f) => self.leaf(~\"float\"),\n-          ty::ty_float(ast::ty_f32) => self.leaf(~\"f32\"),\n-          ty::ty_float(ast::ty_f64) => self.leaf(~\"f64\"),\n+          ty::ty_bot => self.leaf(\"bot\"),\n+          ty::ty_nil => self.leaf(\"nil\"),\n+          ty::ty_bool => self.leaf(\"bool\"),\n+          ty::ty_int(ast::ty_i) => self.leaf(\"int\"),\n+          ty::ty_int(ast::ty_char) => self.leaf(\"char\"),\n+          ty::ty_int(ast::ty_i8) => self.leaf(\"i8\"),\n+          ty::ty_int(ast::ty_i16) => self.leaf(\"i16\"),\n+          ty::ty_int(ast::ty_i32) => self.leaf(\"i32\"),\n+          ty::ty_int(ast::ty_i64) => self.leaf(\"i64\"),\n+          ty::ty_uint(ast::ty_u) => self.leaf(\"uint\"),\n+          ty::ty_uint(ast::ty_u8) => self.leaf(\"u8\"),\n+          ty::ty_uint(ast::ty_u16) => self.leaf(\"u16\"),\n+          ty::ty_uint(ast::ty_u32) => self.leaf(\"u32\"),\n+          ty::ty_uint(ast::ty_u64) => self.leaf(\"u64\"),\n+          ty::ty_float(ast::ty_f) => self.leaf(\"float\"),\n+          ty::ty_float(ast::ty_f32) => self.leaf(\"f32\"),\n+          ty::ty_float(ast::ty_f64) => self.leaf(\"f64\"),\n \n           ty::ty_unboxed_vec(ref mt) => {\n               let values = self.c_mt(mt);\n-              self.visit(~\"vec\", values)\n+              self.visit(\"vec\", values)\n           }\n \n           ty::ty_estr(vst) => {\n@@ -190,28 +190,28 @@ impl Reflector {\n           }\n           ty::ty_box(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(~\"box\", extra)\n+              self.visit(\"box\", extra)\n           }\n           ty::ty_uniq(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(~\"uniq\", extra)\n+              self.visit(\"uniq\", extra)\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(~\"ptr\", extra)\n+              self.visit(\"ptr\", extra)\n           }\n           ty::ty_rptr(_, ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(~\"rptr\", extra)\n+              self.visit(\"rptr\", extra)\n           }\n \n           ty::ty_tup(ref tys) => {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n-              do self.bracketed(~\"tup\", extra) |this| {\n+              do self.bracketed(\"tup\", extra) |this| {\n                   for tys.iter().enumerate().advance |(i, t)| {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n-                      this.visit(~\"tup_field\", extra);\n+                      this.visit(\"tup_field\", extra);\n                   }\n               }\n           }\n@@ -226,9 +226,9 @@ impl Reflector {\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval)];\n-            self.visit(~\"enter_fn\", extra);\n+            self.visit(\"enter_fn\", extra);\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(~\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra);\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n@@ -241,9 +241,9 @@ impl Reflector {\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval)];\n-            self.visit(~\"enter_fn\", extra);\n+            self.visit(\"enter_fn\", extra);\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(~\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra);\n           }\n \n           ty::ty_struct(did, ref substs) => {\n@@ -253,13 +253,13 @@ impl Reflector {\n \n               let extra = ~[self.c_uint(fields.len())]\n                   + self.c_size_and_align(t);\n-              do self.bracketed(~\"class\", extra) |this| {\n+              do self.bracketed(\"class\", extra) |this| {\n                   for fields.iter().enumerate().advance |(i, field)| {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(\n                                         bcx.ccx().sess.str_of(field.ident))]\n                           + this.c_mt(&field.mt);\n-                      this.visit(~\"class_field\", extra);\n+                      this.visit(\"class_field\", extra);\n                   }\n               }\n           }\n@@ -309,14 +309,14 @@ impl Reflector {\n \n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n-            do self.bracketed(~\"enum\", enum_args) |this| {\n+            do self.bracketed(\"enum\", enum_args) |this| {\n                 for variants.iter().enumerate().advance |(i, v)| {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_int(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n-                    do this.bracketed(~\"enum_variant\", variant_args) |this| {\n+                    do this.bracketed(\"enum_variant\", variant_args) |this| {\n                         for v.args.iter().enumerate().advance |(j, a)| {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n@@ -325,28 +325,28 @@ impl Reflector {\n                             let field_args = ~[this.c_uint(j),\n                                                offset,\n                                                this.c_tydesc(*a)];\n-                            this.visit(~\"enum_variant_field\", field_args);\n+                            this.visit(\"enum_variant_field\", field_args);\n                         }\n                     }\n                 }\n             }\n           }\n \n           // Miscallaneous extra types\n-          ty::ty_trait(_, _, _, _, _) => self.leaf(~\"trait\"),\n-          ty::ty_infer(_) => self.leaf(~\"infer\"),\n-          ty::ty_err => self.leaf(~\"err\"),\n+          ty::ty_trait(_, _, _, _, _) => self.leaf(\"trait\"),\n+          ty::ty_infer(_) => self.leaf(\"infer\"),\n+          ty::ty_err => self.leaf(\"err\"),\n           ty::ty_param(ref p) => {\n               let extra = ~[self.c_uint(p.idx)];\n-              self.visit(~\"param\", extra)\n+              self.visit(\"param\", extra)\n           }\n-          ty::ty_self(*) => self.leaf(~\"self\"),\n-          ty::ty_type => self.leaf(~\"type\"),\n-          ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n+          ty::ty_self(*) => self.leaf(\"self\"),\n+          ty::ty_type => self.leaf(\"type\"),\n+          ty::ty_opaque_box => self.leaf(\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n               let ckval = ast_sigil_constant(ck);\n               let extra = ~[self.c_uint(ckval)];\n-              self.visit(~\"closure_ptr\", extra)\n+              self.visit(\"closure_ptr\", extra)\n           }\n         }\n     }\n@@ -357,11 +357,11 @@ impl Reflector {\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),\n                          self.c_tydesc(*arg)];\n-            self.visit(~\"fn_input\", extra);\n+            self.visit(\"fn_input\", extra);\n         }\n         let extra = ~[self.c_uint(retval),\n                       self.c_tydesc(sig.output)];\n-        self.visit(~\"fn_output\", extra);\n+        self.visit(\"fn_output\", extra);\n     }\n }\n "}, {"sha": "1344bed96eec66323975484a51665d5d5cdb357a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -164,7 +164,7 @@ impl VecTypes {\n \n pub fn trans_fixed_vstore(bcx: block,\n                           vstore_expr: @ast::expr,\n-                          content_expr: @ast::expr,\n+                          content_expr: &ast::expr,\n                           dest: expr::Dest)\n                        -> block {\n     //!\n@@ -286,7 +286,7 @@ pub fn trans_lit_str(bcx: block,\n \n \n pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::expr,\n-                                    content_expr: @ast::expr) -> DatumBlock {\n+                                    content_expr: &ast::expr) -> DatumBlock {\n     //!\n     //\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n@@ -346,7 +346,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n pub fn write_content(bcx: block,\n                      vt: &VecTypes,\n                      vstore_expr: @ast::expr,\n-                     content_expr: @ast::expr,\n+                     content_expr: &ast::expr,\n                      dest: Dest)\n                   -> block {\n     let _icx = push_ctxt(\"tvec::write_content\");\n@@ -471,7 +471,7 @@ pub fn write_content(bcx: block,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: block, vec_expr: @ast::expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: block, vec_expr: &ast::expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n@@ -488,7 +488,7 @@ pub fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n               llunit_size: llunit_size}\n }\n \n-pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n+pub fn elements_required(bcx: block, content_expr: &ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -542,8 +542,6 @@ pub fn get_base_and_len(bcx: block,\n     }\n }\n \n-pub type val_and_ty_fn = @fn(block, ValueRef, ty::t) -> Result;\n-\n pub type iter_vec_block<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,"}, {"sha": "c636b7f48761f9df5dd3ee6d8209679966ebb4d7", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -79,7 +79,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n             for sig.inputs.iter().advance |arg| {\n-                type_needs(cx, use_repr, *arg);\n+                type_needs(&cx, use_repr, *arg);\n             }\n         }\n         _ => ()\n@@ -100,7 +100,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, _, ref body),\n                                       _ }, _) |\n       ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n-        handle_body(cx, body);\n+        handle_body(&cx, body);\n       }\n       ast_map::node_trait_method(*) => {\n         // This will be a static trait method. For now, we just assume\n@@ -177,7 +177,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n     uses\n }\n \n-pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n+pub fn type_needs(cx: &Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n     let len = {\n         let uses = &*cx.uses;\n@@ -191,7 +191,7 @@ pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n     }\n }\n \n-pub fn type_needs_inner(cx: Context,\n+pub fn type_needs_inner(cx: &Context,\n                         use_: uint,\n                         ty: ty::t,\n                         enums_seen: @List<def_id>) {\n@@ -233,11 +233,11 @@ pub fn type_needs_inner(cx: Context,\n     }\n }\n \n-pub fn node_type_needs(cx: Context, use_: uint, id: node_id) {\n+pub fn node_type_needs(cx: &Context, use_: uint, id: node_id) {\n     type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n }\n \n-pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n+pub fn mark_for_method_call(cx: &Context, e_id: node_id, callee_id: node_id) {\n     let mut opt_static_did = None;\n     {\n         let r = cx.ccx.maps.method_map.find(&e_id);\n@@ -275,7 +275,7 @@ pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n     }\n }\n \n-pub fn mark_for_expr(cx: Context, e: @expr) {\n+pub fn mark_for_expr(cx: &Context, e: &expr) {\n     match e.node {\n       expr_vstore(_, _) | expr_vec(_, _) | expr_struct(*) | expr_tup(_) |\n       expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) |\n@@ -379,7 +379,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n     }\n }\n \n-pub fn handle_body(cx: Context, body: &blk) {\n+pub fn handle_body(cx: &Context, body: &blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, (cx, v)| {\n             visit::visit_expr(e, (cx, v));"}, {"sha": "d34befddad5f72ecf2d5200ff2bc2f1b39ae88c5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -3017,7 +3017,7 @@ pub fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n+pub fn pat_ty(cx: ctxt, pat: &ast::pat) -> t {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -3033,11 +3033,11 @@ pub fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-pub fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n+pub fn expr_ty(cx: ctxt, expr: &ast::expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n+pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::expr) -> t {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -3191,15 +3191,15 @@ pub struct ParamsTy {\n }\n \n pub fn expr_ty_params_and_ty(cx: ctxt,\n-                             expr: @ast::expr)\n+                             expr: &ast::expr)\n                           -> ParamsTy {\n     ParamsTy {\n         params: node_id_to_type_params(cx, expr.id),\n         ty: node_id_to_type(cx, expr.id)\n     }\n }\n \n-pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n+pub fn expr_has_ty_params(cx: ctxt, expr: &ast::expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n@@ -3235,7 +3235,7 @@ pub fn method_call_type_param_defs(\n     }\n }\n \n-pub fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n+pub fn resolve_expr(tcx: ctxt, expr: &ast::expr) -> ast::def {\n     match tcx.def_map.find(&expr.id) {\n         Some(&def) => def,\n         None => {\n@@ -3247,7 +3247,7 @@ pub fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n \n pub fn expr_is_lval(tcx: ctxt,\n                     method_map: typeck::method_map,\n-                    e: @ast::expr) -> bool {\n+                    e: &ast::expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n         LvalueExpr => true,\n         RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n@@ -3268,7 +3268,7 @@ pub enum ExprKind {\n \n pub fn expr_kind(tcx: ctxt,\n                  method_map: typeck::method_map,\n-                 expr: @ast::expr) -> ExprKind {\n+                 expr: &ast::expr) -> ExprKind {\n     if method_map.contains_key(&expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n@@ -3388,7 +3388,7 @@ pub fn expr_kind(tcx: ctxt,\n     }\n }\n \n-pub fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n+pub fn stmt_node_id(s: &ast::stmt) -> ast::node_id {\n     match s.node {\n       ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n         return id;\n@@ -4374,7 +4374,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n }\n \n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n+pub fn eval_repeat_count(tcx: ctxt, count_expr: &ast::expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n       Ok(ref const_val) => match *const_val {\n         const_eval::const_int(count) => if count < 0 {"}, {"sha": "b7242e64f230bdcece0b0f2a225aeaa5319ae6e8", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -248,7 +248,7 @@ pub static NO_TPS: uint = 2;\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n-    this: &AC, rscope: &RS, ast_ty: @ast::Ty) -> ty::t {\n+    this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n     fn ast_mt_to_mt<AC:AstConv, RS:region_scope + Copy + 'static>(\n         this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {"}, {"sha": "777b11186c6ff63cf278559c158cda726e082502", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -329,11 +329,9 @@ impl<'self> LookupContext<'self> {\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for opt_applicable_traits.iter().advance |applicable_traits| {\n             for applicable_traits.iter().advance |trait_did| {\n-                let coherence_info = self.fcx.ccx.coherence_info;\n-\n                 // Look for explicit implementations.\n                 let opt_impl_infos =\n-                    coherence_info.extension_methods.find(trait_did);\n+                    self.fcx.ccx.coherence_info.extension_methods.find(trait_did);\n                 for opt_impl_infos.iter().advance |impl_infos| {\n                     for impl_infos.iter().advance |impl_info| {\n                         self.push_candidates_from_impl("}, {"sha": "97e0cd4baf84449bd33e4be7e876795eca1a614d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -284,7 +284,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n+pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::crate) {\n     let visit = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()"}, {"sha": "6da9895534b037e6f43f753b120cf682e3242b4c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -197,7 +197,7 @@ pub struct CoherenceChecker {\n }\n \n impl CoherenceChecker {\n-    pub fn check_coherence(self, crate: @crate) {\n+    pub fn check_coherence(self, crate: &crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n@@ -455,7 +455,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        let coherence_info = self.crate_context.coherence_info;\n+        let coherence_info = &self.crate_context.coherence_info;\n         for coherence_info.extension_methods.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n@@ -514,7 +514,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n-        let coherence_info = self.crate_context.coherence_info;\n+        let coherence_info = &self.crate_context.coherence_info;\n         let extension_methods = &*coherence_info.extension_methods;\n \n         match extension_methods.find(&trait_def_id) {\n@@ -631,7 +631,7 @@ impl CoherenceChecker {\n     }\n \n     // Privileged scope checking\n-    pub fn check_privileged_scopes(self, crate: @crate) {\n+    pub fn check_privileged_scopes(self, crate: &crate) {\n         visit_crate(crate, ((), mk_vt(@Visitor {\n             visit_item: |item, (_context, visitor)| {\n                 match item.node {\n@@ -978,7 +978,7 @@ impl CoherenceChecker {\n     //\n \n     pub fn populate_destructor_table(&self) {\n-        let coherence_info = self.crate_context.coherence_info;\n+        let coherence_info = &self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n         let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n@@ -1102,7 +1102,7 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: @mut CrateCtxt, crate: @crate) {\n-    let coherence_checker = @CoherenceChecker(crate_context);\n+pub fn check_coherence(crate_context: @mut CrateCtxt, crate: &crate) {\n+    let coherence_checker = CoherenceChecker(crate_context);\n     coherence_checker.check_coherence(crate);\n }"}, {"sha": "0e118adb8f42e63587a9a462b033d68674b06bba", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -61,8 +61,8 @@ use syntax::visit;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n \n-pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n-    fn collect_intrinsic_type(ccx: @mut CrateCtxt,\n+pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::crate) {\n+    fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::def_id) {\n         let ty::ty_param_bounds_and_ty { ty: ty, _ } =\n             ccx.get_item_ty(lang_item);\n@@ -83,7 +83,7 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n impl CrateCtxt {\n     fn to_ty<RS:region_scope + Copy + 'static>(\n-        &self, rs: &RS, ast_ty: @ast::Ty) -> ty::t\n+        &self, rs: &RS, ast_ty: &ast::Ty) -> ty::t\n     {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n@@ -632,7 +632,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                                    generics: &ast::Generics,\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n-                                   a_trait_ty: @ast::trait_ref,\n+                                   a_trait_ty: &ast::trait_ref,\n                                    impl_ms: &[ConvertedMethod])\n {\n     let tcx = ccx.tcx;\n@@ -670,7 +670,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n pub fn convert_field(ccx: &CrateCtxt,\n                      rp: Option<ty::region_variance>,\n                      type_param_defs: @~[ty::TypeParameterDef],\n-                     v: @ast::struct_field,\n+                     v: &ast::struct_field,\n                      generics: &ast::Generics) {\n     let region_parameterization =\n         RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -736,7 +736,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n     });\n \n     fn ty_of_method(ccx: &CrateCtxt,\n-                    m: @ast::method,\n+                    m: &ast::method,\n                     rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_generics: &ast::Generics,\n@@ -785,7 +785,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n+pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     debug!(\"convert: item %s with id %d rp %?\",\n@@ -875,7 +875,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n \n pub fn convert_struct(ccx: &CrateCtxt,\n                       rp: Option<ty::region_variance>,\n-                      struct_def: @ast::struct_def,\n+                      struct_def: &ast::struct_def,\n                       generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::node_id) {\n@@ -914,7 +914,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n+pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -937,7 +937,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: @ast::foreign_item) {\n }\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n-                             ast_trait_ref: @ast::trait_ref,\n+                             ast_trait_ref: &ast::trait_ref,\n                              rp: Option<ty::region_variance>,\n                              generics: &ast::Generics,\n                              self_ty: ty::t) -> @ty::TraitRef\n@@ -983,7 +983,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::def_id) -> @ty::TraitDef {\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: @ast::item) -> @ty::TraitDef {\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.trait_defs.find(&def_id) {\n@@ -1011,7 +1011,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: @ast::item) -> @ty::TraitDef {\n     }\n }\n \n-pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n+pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n                -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -1103,7 +1103,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n }\n \n pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n-                          it: @ast::foreign_item,\n+                          it: &ast::foreign_item,\n                           abis: AbiSet) -> ty::ty_param_bounds_and_ty\n {\n     match it.node {"}, {"sha": "d834998d4ee238a172635aa288fd396349713185", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -182,7 +182,7 @@ pub struct CrateCtxt {\n     trait_map: resolve::TraitMap,\n     method_map: method_map,\n     vtable_map: vtable_map,\n-    coherence_info: @coherence::CoherenceInfo,\n+    coherence_info: coherence::CoherenceInfo,\n     tcx: ty::ctxt\n }\n \n@@ -220,7 +220,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     }\n }\n \n-pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n+pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: span, id: ast::node_id)\n                    -> ast::def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n@@ -276,11 +276,11 @@ trait get_and_find_region {\n }\n \n impl get_and_find_region for isr_alist {\n-    fn get(&self, br: ty::bound_region) -> ty::Region {\n+    pub fn get(&self, br: ty::bound_region) -> ty::Region {\n         self.find(br).get()\n     }\n \n-    fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n+    pub fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n         for list::each(*self) |isr| {\n             let (isr_br, isr_r) = *isr;\n             if isr_br == br { return Some(isr_r); }\n@@ -289,7 +289,7 @@ impl get_and_find_region for isr_alist {\n     }\n }\n \n-fn check_main_fn_ty(ccx: @mut CrateCtxt,\n+fn check_main_fn_ty(ccx: &CrateCtxt,\n                     main_id: ast::node_id,\n                     main_span: span) {\n     let tcx = ccx.tcx;\n@@ -330,7 +330,7 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n     }\n }\n \n-fn check_start_fn_ty(ccx: @mut CrateCtxt,\n+fn check_start_fn_ty(ccx: &CrateCtxt,\n                      start_id: ast::node_id,\n                      start_span: span) {\n     let tcx = ccx.tcx;\n@@ -379,7 +379,7 @@ fn check_start_fn_ty(ccx: @mut CrateCtxt,\n     }\n }\n \n-fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n+fn check_for_entry_fn(ccx: &CrateCtxt) {\n     let tcx = ccx.tcx;\n     if !*tcx.sess.building_library {\n         match *tcx.sess.entry_fn {\n@@ -395,14 +395,14 @@ fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    trait_map: resolve::TraitMap,\n-                   crate: @ast::crate)\n+                   crate: &ast::crate)\n                 -> (method_map, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @mut CrateCtxt {\n         trait_map: trait_map,\n         method_map: @mut HashMap::new(),\n         vtable_map: @mut HashMap::new(),\n-        coherence_info: @coherence::CoherenceInfo(),\n+        coherence_info: coherence::CoherenceInfo(),\n         tcx: tcx\n     };\n "}, {"sha": "38e6a4824afccccd3848aeb266e6375129108820", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -332,7 +332,7 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n     debug!(\"In find_and_install_dependencies...\");\n     let my_workspace = copy *workspace;\n     let my_ctxt      = copy *ctxt;\n-    for c.each_view_item() |vi: @ast::view_item| {\n+    for c.each_view_item() |vi: &ast::view_item| {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess"}, {"sha": "3abbe3970540ee7bf5ad4222f319de038aae56a3", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -124,7 +124,7 @@ pub fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-pub fn map_crate(diag: @span_handler, c: @crate) -> map {\n+pub fn map_crate(diag: @span_handler, c: &crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],"}, {"sha": "9ba7cb3c818eae84bf366bbc20ac73ffcc6ce7ec", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -565,11 +565,11 @@ pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    pub fn each_view_item(&self, f: @fn(@ast::view_item) -> bool) -> bool;\n+    pub fn each_view_item(&self, f: @fn(&ast::view_item) -> bool) -> bool;\n }\n \n impl EachViewItem for ast::crate {\n-    fn each_view_item(&self, f: @fn(@ast::view_item) -> bool) -> bool {\n+    fn each_view_item(&self, f: @fn(&ast::view_item) -> bool) -> bool {\n         let broke = @mut false;\n         let vtor: visit::vt<()> = visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_view_item: |vi| { *broke = f(vi); }, ..*visit::default_simple_visitor()\n@@ -579,7 +579,7 @@ impl EachViewItem for ast::crate {\n     }\n }\n \n-pub fn view_path_id(p: @view_path) -> node_id {\n+pub fn view_path_id(p: &view_path) -> node_id {\n     match p.node {\n       view_path_simple(_, _, id) |\n       view_path_glob(_, id) |"}, {"sha": "70ac4d3d4c18d1da113c51f4b9c8512aaa23fd44", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::prelude::*;\n-\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;"}, {"sha": "15f915ba4d8da08b1ef2bad7359fc2bcacb53540", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -644,7 +644,7 @@ pub fn core_macros() -> @str {\n }\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n-                    cfg: ast::crate_cfg, c: @crate) -> @crate {\n+                    cfg: ast::crate_cfg, c: &crate) -> @crate {\n     // adding *another* layer of indirection here so that the block\n     // visitor can swap out one exts table for another for the duration\n     // of the block.  The cleaner alternative would be to thread the\n@@ -695,7 +695,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // as it registers all the core macros as expanders.\n     f.fold_item(cm);\n \n-    @f.fold_crate(&*c)\n+    @f.fold_crate(c)\n }\n \n // given a function from idents to idents, produce"}, {"sha": "9fcffc110130e83f0192938b73466f29e913498d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36527360a66024d0e3f971c0732efc52368afc8b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=36527360a66024d0e3f971c0732efc52368afc8b", "patch": "@@ -39,7 +39,7 @@ pub enum fn_kind<'self> {\n     // fn foo(&self)\n     fk_method(ident, &'self Generics, &'self method),\n \n-    // fn@(x, y) { ... }\n+    // @fn(x, y) { ... }\n     fk_anon(ast::Sigil),\n \n     // |x, y| ...\n@@ -129,9 +129,9 @@ pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>))\n     for m.items.iter().advance |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n-pub fn visit_view_item<E>(_vi: @view_item, (_e, _v): (E, vt<E>)) { }\n+pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n \n-pub fn visit_local<E: Copy>(loc: @local, (e, v): (E, vt<E>)) {\n+pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n     (v.visit_pat)(loc.node.pat, (copy e, v));\n     (v.visit_ty)(loc.node.ty, (copy e, v));\n     match loc.node.init {\n@@ -140,11 +140,11 @@ pub fn visit_local<E: Copy>(loc: @local, (e, v): (E, vt<E>)) {\n     }\n }\n \n-fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, (e, v): (E, vt<E>)) {\n+fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n     visit_path(tref.path, (e, v));\n }\n \n-pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n+pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n     match i.node {\n         item_static(t, _, ex) => {\n             (v.visit_ty)(t, (copy e, v));\n@@ -230,9 +230,9 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n     }\n }\n \n-pub fn skip_ty<E>(_t: @Ty, (_e,_v): (E, vt<E>)) {}\n+pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n \n-pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n+pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n         ty_box(mt) | ty_uniq(mt) |\n         ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n@@ -268,11 +268,11 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_path<E: Copy>(p: @Path, (e, v): (E, vt<E>)) {\n+pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n     for p.types.iter().advance |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n }\n \n-pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n+pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(path, ref children) => {\n             visit_path(path, (copy e, v));\n@@ -322,7 +322,7 @@ pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n+pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n             visit_fn_decl(fd, (copy e, v));\n@@ -410,11 +410,11 @@ pub fn visit_struct_def<E: Copy>(\n     }\n }\n \n-pub fn visit_struct_field<E: Copy>(sf: @struct_field, (e, v): (E, vt<E>)) {\n+pub fn visit_struct_field<E: Copy>(sf: &struct_field, (e, v): (E, vt<E>)) {\n     (v.visit_ty)(sf.node.ty, (e, v));\n }\n \n-pub fn visit_struct_method<E: Copy>(m: @method, (e, v): (E, vt<E>)) {\n+pub fn visit_struct_method<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n     visit_method_helper(m, (e, v));\n }\n \n@@ -428,7 +428,7 @@ pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     visit_expr_opt(b.node.expr, (e, v));\n }\n \n-pub fn visit_stmt<E>(s: @stmt, (e, v): (E, vt<E>)) {\n+pub fn visit_stmt<E>(s: &stmt, (e, v): (E, vt<E>)) {\n     match s.node {\n       stmt_decl(d, _) => (v.visit_decl)(d, (e, v)),\n       stmt_expr(ex, _) => (v.visit_expr)(ex, (e, v)),\n@@ -437,7 +437,7 @@ pub fn visit_stmt<E>(s: @stmt, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_decl<E: Copy>(d: @decl, (e, v): (E, vt<E>)) {\n+pub fn visit_decl<E: Copy>(d: &decl, (e, v): (E, vt<E>)) {\n     match d.node {\n         decl_local(ref loc) => (v.visit_local)(*loc, (e, v)),\n         decl_item(it) => (v.visit_item)(it, (e, v))"}]}