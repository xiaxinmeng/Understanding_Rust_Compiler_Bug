{"sha": "d1947628b568c1d59048288486e68d917709f4d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOTQ3NjI4YjU2OGMxZDU5MDQ4Mjg4NDg2ZTY4ZDkxNzcwOWY0ZDQ=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T17:01:56Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:18:59Z"}, "message": "Take sys/vxworks/time from sys/unix instead.", "tree": {"sha": "012c2cd8b2262303ca6912ef3a4530836d4a21ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/012c2cd8b2262303ca6912ef3a4530836d4a21ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1947628b568c1d59048288486e68d917709f4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1947628b568c1d59048288486e68d917709f4d4", "html_url": "https://github.com/rust-lang/rust/commit/d1947628b568c1d59048288486e68d917709f4d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1947628b568c1d59048288486e68d917709f4d4/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "html_url": "https://github.com/rust-lang/rust/commit/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1"}], "stats": {"total": 198, "additions": 1, "deletions": 197}, "files": [{"sha": "fee0a83e353c6a0c8bd28f6c967155a3888f54cb", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1947628b568c1d59048288486e68d917709f4d4/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1947628b568c1d59048288486e68d917709f4d4/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=d1947628b568c1d59048288486e68d917709f4d4", "patch": "@@ -33,6 +33,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+#[path = \"../unix/time.rs\"]\n pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;"}, {"sha": "8f46f4d284f0bf71ad499c3457da75c9faac5a55", "filename": "library/std/src/sys/vxworks/time.rs", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f875c8be5ddfc734558a1f5d4cb9800477c3f1a1/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs?ref=f875c8be5ddfc734558a1f5d4cb9800477c3f1a1", "patch": "@@ -1,197 +0,0 @@\n-use crate::cmp::Ordering;\n-use crate::time::Duration;\n-use core::hash::{Hash, Hasher};\n-\n-pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n-use crate::convert::TryInto;\n-\n-const NSEC_PER_SEC: u64 = 1_000_000_000;\n-\n-#[derive(Copy, Clone)]\n-struct Timespec {\n-    t: libc::timespec,\n-}\n-\n-impl Timespec {\n-    const fn zero() -> Timespec {\n-        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n-    }\n-    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n-        if self >= other {\n-            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new(\n-                    (self.t.tv_sec - other.t.tv_sec) as u64,\n-                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n-                )\n-            } else {\n-                Duration::new(\n-                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n-                )\n-            })\n-        } else {\n-            match other.sub_timespec(self) {\n-                Ok(d) => Err(d),\n-                Err(d) => Ok(d),\n-            }\n-        }\n-    }\n-\n-    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n-\n-        // Nano calculations can't overflow because nanos are <1B which fit\n-        // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n-        if nsec >= NSEC_PER_SEC as u32 {\n-            nsec -= NSEC_PER_SEC as u32;\n-            secs = secs.checked_add(1)?;\n-        }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-\n-    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n-\n-        // Similar to above, nanos can't overflow.\n-        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n-        if nsec < 0 {\n-            nsec += NSEC_PER_SEC as i32;\n-            secs = secs.checked_sub(1)?;\n-        }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-}\n-\n-impl PartialEq for Timespec {\n-    fn eq(&self, other: &Timespec) -> bool {\n-        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-    }\n-}\n-\n-impl Eq for Timespec {}\n-\n-impl PartialOrd for Timespec {\n-    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Timespec {\n-    fn cmp(&self, other: &Timespec) -> Ordering {\n-        let me = (self.t.tv_sec, self.t.tv_nsec);\n-        let other = (other.t.tv_sec, other.t.tv_nsec);\n-        me.cmp(&other)\n-    }\n-}\n-\n-impl Hash for Timespec {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.t.tv_sec.hash(state);\n-        self.t.tv_nsec.hash(state);\n-    }\n-}\n-mod inner {\n-    use crate::fmt;\n-    use crate::sys::cvt;\n-    use crate::time::Duration;\n-\n-    use super::Timespec;\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct Instant {\n-        t: Timespec,\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct SystemTime {\n-        t: Timespec,\n-    }\n-\n-    pub const UNIX_EPOCH: SystemTime =\n-        SystemTime { t: Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } } };\n-\n-    impl Instant {\n-        pub fn now() -> Instant {\n-            Instant { t: now(libc::CLOCK_MONOTONIC) }\n-        }\n-\n-        pub const fn zero() -> Instant {\n-            Instant { t: Timespec::zero() }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            true\n-        }\n-\n-        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n-            self.t.sub_timespec(&other.t).ok()\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-            Some(Instant { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-            Some(Instant { t: self.t.checked_sub_duration(other)? })\n-        }\n-    }\n-\n-    impl fmt::Debug for Instant {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Instant\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n-        }\n-    }\n-\n-    impl SystemTime {\n-        pub fn now() -> SystemTime {\n-            SystemTime { t: now(libc::CLOCK_REALTIME) }\n-        }\n-\n-        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n-        }\n-    }\n-\n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t: t } }\n-        }\n-    }\n-\n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n-        }\n-    }\n-\n-    pub type clock_t = libc::c_int;\n-\n-    fn now(clock: clock_t) -> Timespec {\n-        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n-        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n-        t\n-    }\n-}"}]}