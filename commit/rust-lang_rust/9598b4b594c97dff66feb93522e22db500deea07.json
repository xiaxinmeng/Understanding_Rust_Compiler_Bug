{"sha": "9598b4b594c97dff66feb93522e22db500deea07", "node_id": "C_kwDOAAsO6NoAKDk1OThiNGI1OTRjOTdkZmY2NmZlYjkzNTIyZTIyZGI1MDBkZWVhMDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T10:39:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-02T10:39:24Z"}, "message": "Auto merge of #97644 - Dylan-DPC:rollup-xaeio91, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #96894 (Apply track_caller to closure on `expect_non_local()`)\n - #97023 (Diagnose anonymous lifetimes errors more uniformly between async and regular fns)\n - #97397 (Stabilize `box_into_pin`)\n - #97587 (Migrate more diagnostics to use the `#[derive(SessionDiagnostic)]`)\n - #97603 (Arc make_mut doc comment spelling correction.)\n - #97635 (Fix file metadata documentation for Windows)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "36ef4aa6db5e6cbecaa6b2f10eb8f9df7436babf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ef4aa6db5e6cbecaa6b2f10eb8f9df7436babf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9598b4b594c97dff66feb93522e22db500deea07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9598b4b594c97dff66feb93522e22db500deea07", "html_url": "https://github.com/rust-lang/rust/commit/9598b4b594c97dff66feb93522e22db500deea07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9598b4b594c97dff66feb93522e22db500deea07/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6bb83268518dcd74c96b5504f485b71e604e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6bb83268518dcd74c96b5504f485b71e604e4c", "html_url": "https://github.com/rust-lang/rust/commit/5e6bb83268518dcd74c96b5504f485b71e604e4c"}, {"sha": "fa79247826033eff7c422f95d6cda73dd0b211e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa79247826033eff7c422f95d6cda73dd0b211e1", "html_url": "https://github.com/rust-lang/rust/commit/fa79247826033eff7c422f95d6cda73dd0b211e1"}], "stats": {"total": 992, "additions": 746, "deletions": 246}, "files": [{"sha": "cb4b154d271a54a0a9c0e7b2a5f436f64eb4747d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -567,15 +567,17 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n-            hir::LifetimeName::Param(_)\n+            hir::LifetimeName::Param(hir::ParamName::Plain(_) | hir::ParamName::Error)\n             | hir::LifetimeName::Error\n-            | hir::LifetimeName::Static\n-            | hir::LifetimeName::Underscore => {\n+            | hir::LifetimeName::Static => {\n                 let lifetime_span = lifetime.span;\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::Param(hir::ParamName::Fresh(_))\n+            | hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit\n+            | hir::LifetimeName::Underscore => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "076b1b1caed7278645fbe808cf3510cac370c2a5", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -14,3 +14,21 @@ parser-add-paren = try adding parentheses\n parser-forgot-paren = perhaps you forgot parentheses?\n \n parser-expect-path = expected a path\n+\n+parser-maybe-recover-from-bad-qpath-stage-2 =\n+    missing angle brackets in associated item path\n+    .suggestion = try: `{$ty}`\n+\n+parser-incorrect-semicolon =\n+    expected item, found `;`\n+    .suggestion = remove this semicolon\n+    .help = {$name} declarations are not followed by a semicolon\n+\n+parser-incorrect-use-of-await =\n+    incorrect use of `await`\n+    .parentheses-suggestion = `await` is not a method call, remove the parentheses\n+    .postfix-suggestion = `await` is a postfix operation\n+\n+parser-in-in-typo =\n+    expected iterable, found keyword `in`\n+    .suggestion = remove the duplicated `in`"}, {"sha": "414f6272591966b60d9fdb49e21e6473ca1f92b6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -671,7 +671,10 @@ impl<Id> Res<Id> {\n \n     #[track_caller]\n     pub fn expect_non_local<OtherId>(self) -> Res<OtherId> {\n-        self.map_id(|_| panic!(\"unexpected `Res::Local`\"))\n+        self.map_id(\n+            #[track_caller]\n+            |_| panic!(\"unexpected `Res::Local`\"),\n+        )\n     }\n \n     pub fn macro_kind(self) -> Option<MacroKind> {"}, {"sha": "dbe6fe6ea84022e7da78650cdbed48e941d5a419", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -131,6 +131,17 @@ impl LifetimeName {\n         }\n     }\n \n+    pub fn is_anonymous(&self) -> bool {\n+        match *self {\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore\n+            | LifetimeName::Param(ParamName::Fresh(_))\n+            | LifetimeName::Error => true,\n+            LifetimeName::Static | LifetimeName::Param(_) => false,\n+        }\n+    }\n+\n     pub fn is_elided(&self) -> bool {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault"}, {"sha": "d845c433d8c5f6874f7ff8e739a3582afca9579d", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -3,6 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n \n #![feature(associated_type_defaults)]\n+#![feature(closure_track_caller)]\n #![feature(const_btree_new)]\n #![feature(let_else)]\n #![feature(once_cell)]"}, {"sha": "579d7efb56803ec26da25fa6aa5e82cbf1f74f91", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -72,7 +72,7 @@ use rustc_middle::ty::{\n     subst::{GenericArgKind, Subst, SubstsRef},\n     Binder, EarlyBinder, List, Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n+use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n use std::{cmp, fmt, iter};\n@@ -161,35 +161,45 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n             {\n                 sp = param.span;\n             }\n-            (format!(\"the lifetime `{}` as defined here\", br.name), sp)\n+            let text = if br.has_name() {\n+                format!(\"the lifetime `{}` as defined here\", br.name)\n+            } else {\n+                format!(\"the anonymous lifetime as defined here\")\n+            };\n+            (text, sp)\n         }\n-        ty::ReFree(ty::FreeRegion {\n-            bound_region: ty::BoundRegionKind::BrNamed(_, name), ..\n-        }) => {\n-            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n-            if let Some(param) =\n-                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+        ty::ReFree(ref fr) => {\n+            if !fr.bound_region.is_named()\n+                && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n             {\n-                sp = param.span;\n-            }\n-            (format!(\"the lifetime `{}` as defined here\", name), sp)\n-        }\n-        ty::ReFree(ref fr) => match fr.bound_region {\n-            ty::BrAnon(idx) => {\n-                if let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region) {\n-                    (\"the anonymous lifetime defined here\".to_string(), ty.span)\n-                } else {\n-                    (\n+                (\"the anonymous lifetime defined here\".to_string(), ty.span)\n+            } else {\n+                match fr.bound_region {\n+                    ty::BoundRegionKind::BrNamed(_, name) => {\n+                        let mut sp = sm.guess_head_span(tcx.def_span(scope));\n+                        if let Some(param) =\n+                            tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                        {\n+                            sp = param.span;\n+                        }\n+                        let text = if name == kw::UnderscoreLifetime {\n+                            format!(\"the anonymous lifetime as defined here\")\n+                        } else {\n+                            format!(\"the lifetime `{}` as defined here\", name)\n+                        };\n+                        (text, sp)\n+                    }\n+                    ty::BrAnon(idx) => (\n                         format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n-                        tcx.def_span(scope),\n-                    )\n+                        tcx.def_span(scope)\n+                    ),\n+                    _ => (\n+                        format!(\"the lifetime `{}` as defined here\", region),\n+                        sm.guess_head_span(tcx.def_span(scope)),\n+                    ),\n                 }\n             }\n-            _ => (\n-                format!(\"the lifetime `{}` as defined here\", region),\n-                sm.guess_head_span(tcx.def_span(scope)),\n-            ),\n-        },\n+        }\n         _ => bug!(),\n     }\n }\n@@ -2552,7 +2562,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n                 | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }),\n                 _,\n-            ) => {\n+            ) if name != kw::UnderscoreLifetime => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "b744594ddb7e6b0e6bd2548c5b87c77a22394254", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -12,6 +12,7 @@ use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::{GenericParamKind, Ty};\n use rustc_middle::ty::Region;\n+use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -169,7 +170,7 @@ pub fn suggest_adding_lifetime_params<'tcx>(\n         return false;\n     };\n \n-    if !lifetime_sub.name.is_elided() || !lifetime_sup.name.is_elided() {\n+    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n         return false;\n     };\n \n@@ -188,32 +189,37 @@ pub fn suggest_adding_lifetime_params<'tcx>(\n         _ => return false,\n     };\n \n-    let (suggestion_param_name, introduce_new) = generics\n+    let suggestion_param_name = generics\n         .params\n         .iter()\n-        .find(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .and_then(|p| tcx.sess.source_map().span_to_snippet(p.span).ok())\n-        .map(|name| (name, false))\n-        .unwrap_or_else(|| (\"'a\".to_string(), true));\n-\n-    let mut suggestions = vec![\n-        if let hir::LifetimeName::Underscore = lifetime_sub.name {\n-            (lifetime_sub.span, suggestion_param_name.clone())\n+        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+        .map(|p| p.name.ident().name)\n+        .find(|i| *i != kw::UnderscoreLifetime);\n+    let introduce_new = suggestion_param_name.is_none();\n+    let suggestion_param_name =\n+        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+    debug!(?lifetime_sup.span);\n+    debug!(?lifetime_sub.span);\n+    let make_suggestion = |span: rustc_span::Span| {\n+        if span.is_empty() {\n+            (span, format!(\"{}, \", suggestion_param_name))\n+        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n+            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n         } else {\n-            (lifetime_sub.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n-        },\n-        if let hir::LifetimeName::Underscore = lifetime_sup.name {\n-            (lifetime_sup.span, suggestion_param_name.clone())\n-        } else {\n-            (lifetime_sup.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n-        },\n-    ];\n+            (span, suggestion_param_name.clone())\n+        }\n+    };\n+    let mut suggestions =\n+        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n \n     if introduce_new {\n-        let new_param_suggestion = match &generics.params {\n-            [] => (generics.span, format!(\"<{}>\", suggestion_param_name)),\n-            [first, ..] => (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name)),\n-        };\n+        let new_param_suggestion =\n+            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n+                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+            } else {\n+                (generics.span, format!(\"<{}>\", suggestion_param_name))\n+            };\n \n         suggestions.push(new_param_suggestion);\n     }"}, {"sha": "375ad8d3736dc2fb2f266956346d42d6d1cfabec", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -4,6 +4,7 @@ use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty;\n+use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n@@ -67,7 +68,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let is_impl_item = region_info.is_impl_item;\n \n         match br {\n-            ty::BrAnon(_) => {}\n+            ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) => {}\n             _ => {\n                 /* not an anonymous region */\n                 debug!(\"try_report_named_anon_conflict: not an anonymous region\");"}, {"sha": "64c63e3d567d039d91b133a01662b1f46e6a4b29", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -2177,61 +2177,47 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n+        let mut next_name = |this: &Self| loop {\n+            let name = name_by_region_index(region_index);\n+            region_index += 1;\n+            if !this.used_region_names.contains(&name) {\n+                break name;\n+            }\n+        };\n+\n         // If we want to print verbosely, then print *all* binders, even if they\n         // aren't named. Eventually, we might just want this as the default, but\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n         let (new_value, map) = if self.tcx().sess.verbose() {\n             // anon index + 1 (BrEnv takes 0) -> name\n-            let mut region_map: BTreeMap<u32, Symbol> = BTreeMap::default();\n+            let mut region_map: FxHashMap<_, _> = Default::default();\n             let bound_vars = value.bound_vars();\n             for var in bound_vars {\n+                let ty::BoundVariableKind::Region(var) = var else { continue };\n                 match var {\n-                    ty::BoundVariableKind::Region(ty::BrNamed(_, name)) => {\n+                    ty::BrAnon(_) | ty::BrEnv => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n+                        region_map.insert(var, ty::BrNamed(CRATE_DEF_ID.to_def_id(), name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrAnon(i)) => {\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n-                        region_map.insert(i + 1, name);\n+                        region_map.insert(var, ty::BrNamed(def_id, name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrEnv) => {\n+                    ty::BrNamed(_, name) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n                         do_continue(&mut self, name);\n-                        region_map.insert(0, name);\n                     }\n-                    _ => continue,\n                 }\n             }\n             start_or_continue(&mut self, \"\", \"> \");\n \n             self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-                let kind = match br.kind {\n-                    ty::BrNamed(_, _) => br.kind,\n-                    ty::BrAnon(i) => {\n-                        let name = region_map[&(i + 1)];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                    ty::BrEnv => {\n-                        let name = region_map[&0];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                };\n+                let kind = region_map[&br.kind];\n                 self.tcx.mk_region(ty::ReLateBound(\n                     ty::INNERMOST,\n                     ty::BoundRegion { var: br.var, kind },\n@@ -2242,21 +2228,20 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             let mut name = |br: ty::BoundRegion| {\n                 start_or_continue(&mut self, \"for<\", \", \");\n                 let kind = match br.kind {\n-                    ty::BrNamed(_, name) => {\n-                        do_continue(&mut self, name);\n-                        br.kind\n-                    }\n                     ty::BrAnon(_) | ty::BrEnv => {\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n                         ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n                     }\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n+                        let name = next_name(&self);\n+                        do_continue(&mut self, name);\n+                        ty::BrNamed(def_id, name)\n+                    }\n+                    ty::BrNamed(_, name) => {\n+                        do_continue(&mut self, name);\n+                        br.kind\n+                    }\n                 };\n                 tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n             };"}, {"sha": "a4cdfdf55f9df393c64df2b6ac3dca9449ec6c0b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 77, "deletions": 44, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -285,6 +285,54 @@ pub enum BadTypePlusSub {\n     },\n }\n \n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"parser-maybe-recover-from-bad-qpath-stage-2\")]\n+struct BadQPathStage2 {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\")]\n+    span: Span,\n+    ty: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"parser-incorrect-semicolon\")]\n+struct IncorrectSemicolon<'a> {\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\")]\n+    span: Span,\n+    #[help]\n+    opt_help: Option<()>,\n+    name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"parser-incorrect-use-of-await\")]\n+struct IncorrectUseOfAwait {\n+    #[primary_span]\n+    #[suggestion(message = \"parentheses-suggestion\", applicability = \"machine-applicable\")]\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"parser-incorrect-use-of-await\")]\n+struct IncorrectAwait {\n+    #[primary_span]\n+    span: Span,\n+    #[suggestion(message = \"postfix-suggestion\", code = \"{expr}.await{question_mark}\")]\n+    sugg_span: (Span, Applicability),\n+    expr: String,\n+    question_mark: &'static str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"parser-in-in-typo\")]\n+struct InInTypo {\n+    #[primary_span]\n+    span: Span,\n+    #[suggestion(applicability = \"machine-applicable\")]\n+    sugg_span: Span,\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped.\n@@ -1451,15 +1499,10 @@ impl<'a> Parser<'a> {\n         path.span = ty_span.to(self.prev_token.span);\n \n         let ty_str = self.span_to_snippet(ty_span).unwrap_or_else(|_| pprust::ty_to_string(&ty));\n-        self.struct_span_err(path.span, \"missing angle brackets in associated item path\")\n-            .span_suggestion(\n-                // This is a best-effort recovery.\n-                path.span,\n-                \"try\",\n-                format!(\"<{}>::{}\", ty_str, pprust::path_to_string(&path)),\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+        self.sess.emit_err(BadQPathStage2 {\n+            span: path.span,\n+            ty: format!(\"<{}>::{}\", ty_str, pprust::path_to_string(&path)),\n+        });\n \n         let path_span = ty_span.shrink_to_hi(); // Use an empty path since `position == 0`.\n         Ok(P(T::recovered(Some(QSelf { ty, path_span, position: 0 }), path)))\n@@ -1468,13 +1511,10 @@ impl<'a> Parser<'a> {\n     pub fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n         if self.token.kind == TokenKind::Semi {\n             self.bump();\n-            let mut err = self.struct_span_err(self.prev_token.span, \"expected item, found `;`\");\n-            err.span_suggestion_short(\n-                self.prev_token.span,\n-                \"remove this semicolon\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n+\n+            let mut err =\n+                IncorrectSemicolon { span: self.prev_token.span, opt_help: None, name: \"\" };\n+\n             if !items.is_empty() {\n                 let previous_item = &items[items.len() - 1];\n                 let previous_item_kind_name = match previous_item.kind {\n@@ -1487,10 +1527,11 @@ impl<'a> Parser<'a> {\n                     _ => None,\n                 };\n                 if let Some(name) = previous_item_kind_name {\n-                    err.help(&format!(\"{name} declarations are not followed by a semicolon\"));\n+                    err.opt_help = Some(());\n+                    err.name = name;\n                 }\n             }\n-            err.emit();\n+            self.sess.emit_err(err);\n             true\n         } else {\n             false\n@@ -1604,18 +1645,20 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_on_incorrect_await(&self, lo: Span, hi: Span, expr: &Expr, is_question: bool) -> Span {\n-        let expr_str =\n-            self.span_to_snippet(expr.span).unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-        let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n-        let sp = lo.to(hi);\n-        let app = match expr.kind {\n+        let span = lo.to(hi);\n+        let applicability = match expr.kind {\n             ExprKind::Try(_) => Applicability::MaybeIncorrect, // `await <expr>?`\n             _ => Applicability::MachineApplicable,\n         };\n-        self.struct_span_err(sp, \"incorrect use of `await`\")\n-            .span_suggestion(sp, \"`await` is a postfix operation\", suggestion, app)\n-            .emit();\n-        sp\n+\n+        self.sess.emit_err(IncorrectAwait {\n+            span,\n+            sugg_span: (span, applicability),\n+            expr: self.span_to_snippet(expr.span).unwrap_or_else(|_| pprust::expr_to_string(&expr)),\n+            question_mark: if is_question { \"?\" } else { \"\" },\n+        });\n+\n+        span\n     }\n \n     /// If encountering `future.await()`, consumes and emits an error.\n@@ -1626,16 +1669,10 @@ impl<'a> Parser<'a> {\n             // future.await()\n             let lo = self.token.span;\n             self.bump(); // (\n-            let sp = lo.to(self.token.span);\n+            let span = lo.to(self.token.span);\n             self.bump(); // )\n-            self.struct_span_err(sp, \"incorrect use of `await`\")\n-                .span_suggestion(\n-                    sp,\n-                    \"`await` is not a method call, remove the parentheses\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+\n+            self.sess.emit_err(IncorrectUseOfAwait { span });\n         }\n     }\n \n@@ -1907,14 +1944,10 @@ impl<'a> Parser<'a> {\n     pub(super) fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            self.struct_span_err(self.prev_token.span, \"expected iterable, found keyword `in`\")\n-                .span_suggestion_short(\n-                    in_span.until(self.prev_token.span),\n-                    \"remove the duplicated `in`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(InInTypo {\n+                span: self.prev_token.span,\n+                sugg_span: in_span.until(self.prev_token.span),\n+            });\n         }\n     }\n "}, {"sha": "de5367ca27c3a65af21bab6cdc8b198881c27712", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 107, "deletions": 70, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -8,10 +8,11 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{def::Res, ItemKind, Node, PathSegment};\n+use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -29,7 +30,6 @@ use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};\n \n-use rustc_hir::def::DefKind;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -93,7 +93,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.return_type_pre_known = return_type_pre_known;\n \n     let tcx = fcx.tcx;\n-    let sess = tcx.sess;\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n@@ -259,85 +258,123 @@ pub(super) fn check_fn<'a, 'tcx>(\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n         && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n-\n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_panic_info = match *inputs[0].kind() {\n-                    ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                        ty::Adt(ref adt, _) => {\n-                            adt.did() == panic_info_did\n-                                && mutbl == hir::Mutability::Not\n-                                && !region.is_static()\n-                        }\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n-\n-                if !arg_is_panic_info {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                }\n-\n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(span, \"should have no type parameters\");\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n-            }\n-        } else {\n-            sess.err(\"language item required, but not found: `panic_info`\");\n-        }\n+        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n         && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n+        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n \n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_alloc_layout = match inputs[0].kind() {\n-                    ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-                    _ => false,\n-                };\n+    (fcx, gen_ty)\n+}\n \n-                if !arg_is_alloc_layout {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                }\n+fn check_panic_info_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n+        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+        return;\n+    };\n \n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(\n-                                span,\n-                        \"`#[alloc_error_handler]` function should have no type parameters\",\n-                            );\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let span = tcx.def_span(fn_id);\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_panic_info = match *inputs[0].kind() {\n+        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+            ty::Adt(ref adt, _) => {\n+                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n             }\n-        } else {\n-            sess.err(\"language item required, but not found: `alloc_layout`\");\n-        }\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+\n+    if !arg_is_panic_info {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n     }\n \n-    (fcx, gen_ty)\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no const parameters\");\n+    }\n+}\n+\n+fn check_alloc_error_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n+        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.def_span(fn_id);\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_alloc_layout = match inputs[0].kind() {\n+        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+        _ => false,\n+    };\n+\n+    if !arg_is_alloc_layout {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess\n+            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n+    }\n }\n \n fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {"}, {"sha": "4d17307ddb968bd72993d422bdea2dbfba07be3f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -660,8 +660,24 @@ fn compare_number_of_generics<'tcx>(\n                     _ => None,\n                 })\n                 .collect();\n-            let spans = impl_item.generics.spans();\n-            let span = spans.primary_span();\n+            let spans = if impl_item.generics.params.is_empty() {\n+                vec![impl_item.generics.span]\n+            } else {\n+                impl_item\n+                    .generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| {\n+                        matches!(\n+                            p.kind,\n+                            hir::GenericParamKind::Type { .. }\n+                                | hir::GenericParamKind::Const { .. }\n+                        )\n+                    })\n+                    .map(|p| p.span)\n+                    .collect::<Vec<Span>>()\n+            };\n+            let span = spans.first().copied();\n \n             let mut err = tcx.sess.struct_span_err_with_code(\n                 spans,"}, {"sha": "e2c692b5299f45faef3c0976a1b4cf4301729d12", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -1175,14 +1175,33 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n     /// This conversion does not allocate on the heap and happens in place.\n     ///\n     /// This is also available via [`From`].\n-    #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n+    ///\n+    /// # Notes\n+    ///\n+    /// It's not recommended that crates add an impl like `From<Box<T>> for Pin<T>`,\n+    /// as it'll introduce an ambiguity when calling `Pin::from`.\n+    /// A demonstration of such a poor impl is shown below.\n+    ///\n+    /// ```compile_fail\n+    /// # use std::pin::Pin;\n+    /// struct Foo; // A type defined in this crate.\n+    /// impl From<Box<()>> for Pin<Foo> {\n+    ///     fn from(_: Box<()>) -> Pin<Foo> {\n+    ///         Pin::new(Foo)\n+    ///     }\n+    /// }\n+    ///\n+    /// let foo = Box::new(());\n+    /// let bar = Pin::from(foo);\n+    /// ```\n+    #[stable(feature = \"box_into_pin\", since = \"1.63.0\")]\n     #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n     pub const fn into_pin(boxed: Self) -> Pin<Self>\n     where\n         A: 'static,\n     {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n-        // when `T: !Unpin`,  so it's safe to pin it directly without any\n+        // when `T: !Unpin`, so it's safe to pin it directly without any\n         // additional requirements.\n         unsafe { Pin::new_unchecked(boxed) }\n     }"}, {"sha": "55d51e0a3c4cf282e9916ef1a7417f0391997e93", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -1393,11 +1393,11 @@ impl<T: Clone> Arc<T> {\n     /// referred to as clone-on-write.\n     ///\n     /// However, if there are no other `Arc` pointers to this allocation, but some [`Weak`]\n-    /// pointers, then the [`Weak`] pointers will be disassociated and the inner value will not\n+    /// pointers, then the [`Weak`] pointers will be dissociated and the inner value will not\n     /// be cloned.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning the inner value\n-    /// or diassociating [`Weak`] pointers.\n+    /// or dissociating [`Weak`] pointers.\n     ///\n     /// [`clone`]: Clone::clone\n     /// [`get_mut`]: Arc::get_mut\n@@ -1420,7 +1420,7 @@ impl<T: Clone> Arc<T> {\n     /// assert_eq!(*other_data, 12);\n     /// ```\n     ///\n-    /// [`Weak`] pointers will be disassociated:\n+    /// [`Weak`] pointers will be dissociated:\n     ///\n     /// ```\n     /// use std::sync::Arc;"}, {"sha": "55bd2c59406df9a3ac8db1fd5bedfe029f933162", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -1620,7 +1620,7 @@ pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// # Platform-specific behavior\n ///\n /// This function currently corresponds to the `stat` function on Unix\n-/// and the `GetFileAttributesEx` function on Windows.\n+/// and the `GetFileInformationByHandle` function on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior\n@@ -1654,7 +1654,7 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n /// # Platform-specific behavior\n ///\n /// This function currently corresponds to the `lstat` function on Unix\n-/// and the `GetFileAttributesEx` function on Windows.\n+/// and the `GetFileInformationByHandle` function on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior"}, {"sha": "109883fbeb7cb2ca77c1417818c67eee68f780b8", "filename": "src/test/ui/async-await/issue-76547.base.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -5,6 +5,12 @@ LL | async fn fut(bufs: &mut [&mut [u8]]) {\n    |                    ---------------- these two types are declared with different lifetimes...\n LL |     ListFut(bufs).await\n    |             ^^^^ ...but data from `bufs` flows into `bufs` here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut<'a>(bufs: &'a mut [&'a mut [u8]]) {\n+   |             ++++        ++       ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:39:14\n@@ -13,6 +19,12 @@ LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n    |                     ---------------- these two types are declared with different lifetimes...\n LL |     ListFut2(bufs).await\n    |              ^^^^ ...but data from `bufs` flows into `bufs` here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut2<'a>(bufs: &'a mut [&'a mut [u8]]) -> i32 {\n+   |              ++++        ++       ++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0a5a52cb79e4ce06dfb9fde3014505e651207e9a", "filename": "src/test/ui/async-await/issue-76547.nll.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL | async fn fut(bufs: &mut [&mut [u8]]) {\n    |                    let's call the lifetime of this reference `'1`\n LL |     ListFut(bufs).await\n    |             ^^^^ this usage requires that `'1` must outlive `'2`\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut<'a>(bufs: &'a mut [&'a mut [u8]]) {\n+   |             ++++        ++       ++\n \n error: lifetime may not live long enough\n   --> $DIR/issue-76547.rs:39:14\n@@ -17,6 +22,11 @@ LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n    |                     let's call the lifetime of this reference `'1`\n LL |     ListFut2(bufs).await\n    |              ^^^^ this usage requires that `'1` must outlive `'2`\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut2<'a>(bufs: &'a mut [&'a mut [u8]]) -> i32 {\n+   |              ++++        ++       ++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f5409a7ca5d29ecd7c9a88a4bbd248d9f8712135", "filename": "src/test/ui/async-await/issues/issue-63388-1.base.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -1,14 +1,12 @@\n-error[E0623]: lifetime mismatch\n+error[E0621]: explicit lifetime required in the type of `foo`\n   --> $DIR/issue-63388-1.rs:19:9\n    |\n LL |         &'a self, foo: &dyn Foo\n-   |                        -------- this parameter and the return type are declared with different lifetimes...\n-LL |     ) -> &dyn Foo\n-   |          --------\n+   |                        -------- help: add explicit lifetime `'a` to the type of `foo`: `&'a (dyn Foo + 'a)`\n ...\n LL |         foo\n-   |         ^^^ ...but data from `foo` is returned here\n+   |         ^^^ lifetime `'a` required\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0623`.\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "9263a81bb6af42c3a4f2e20d3f7f6986548ff7d0", "filename": "src/test/ui/async-await/issues/issue-63388-1.nll.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -1,17 +1,16 @@\n-error: lifetime may not live long enough\n+error[E0621]: explicit lifetime required in the type of `foo`\n   --> $DIR/issue-63388-1.rs:17:5\n    |\n-LL |       async fn do_sth<'a>(\n-   |                       -- lifetime `'a` defined here\n LL |           &'a self, foo: &dyn Foo\n-   |                          - let's call the lifetime of this reference `'1`\n+   |                          -------- help: add explicit lifetime `'a` to the type of `foo`: `&'a (dyn Foo + 'a)`\n LL |       ) -> &dyn Foo\n LL | /     {\n LL | |\n LL | |         foo\n LL | |\n LL | |     }\n-   | |_____^ associated function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`\n+   | |_____^ lifetime `'a` required\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "f00f92954064095e13e9e4e0a7194b63fafea198", "filename": "src/test/ui/async-await/issues/issue-63388-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -15,9 +15,9 @@ impl Xyz {\n         &'a self, foo: &dyn Foo\n     ) -> &dyn Foo\n     {\n-        //[nll]~^ ERROR lifetime may not live long enough\n+        //[nll]~^ ERROR explicit lifetime required in the type of `foo` [E0621]\n         foo\n-        //[base]~^ ERROR lifetime mismatch\n+        //[base]~^ ERROR explicit lifetime required in the type of `foo` [E0621]\n     }\n }\n "}, {"sha": "de54a417253d406a36d29920a2f6346b1895b6ea", "filename": "src/test/ui/error-codes/E0308-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -6,7 +6,7 @@ LL | impl Eq for &dyn DynEq {}\n    |\n    = note: expected trait `<&dyn DynEq as PartialEq>`\n               found trait `<&(dyn DynEq + 'static) as PartialEq>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/E0308-2.rs:9:13\n    |\n LL | impl Eq for &dyn DynEq {}"}, {"sha": "76d39c88b61c3e38863642186da8178524577030", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind_impl.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -8,17 +8,15 @@ LL |     type A = u32;\n    |           ^ lifetimes do not match type in trait\n \n error[E0049]: type `B` has 1 type parameter but its trait declaration has 0 type parameters\n-  --> $DIR/parameter_number_and_kind_impl.rs:17:12\n+  --> $DIR/parameter_number_and_kind_impl.rs:17:16\n    |\n LL |     type B<'a, 'b>;\n    |            --  --\n    |            |\n    |            expected 0 type parameters\n ...\n LL |     type B<'a, T> = Vec<T>;\n-   |            ^^  ^\n-   |            |\n-   |            found 1 type parameter\n+   |                ^ found 1 type parameter\n \n error[E0195]: lifetime parameters or bounds on type `C` do not match the trait declaration\n   --> $DIR/parameter_number_and_kind_impl.rs:19:11"}, {"sha": "88b5fbec6cf03a860e548461e3c0309ae753db21", "filename": "src/test/ui/issues/issue-17905-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -11,7 +11,7 @@ note: the anonymous lifetime defined here...\n    |\n LL |     fn say(self: &Pair<&str, isize>) {\n    |                        ^^^^\n-note: ...does not necessarily outlive the lifetime `'_` as defined here\n+note: ...does not necessarily outlive the anonymous lifetime as defined here\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,\n@@ -25,7 +25,7 @@ LL |     fn say(self: &Pair<&str, isize>) {\n    |\n    = note: expected struct `Pair<&str, _>`\n               found struct `Pair<&str, _>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,"}, {"sha": "fcabcdea74fc299305032f124e33ee9ce56aeff3", "filename": "src/test/ui/issues/issue-65230.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -6,7 +6,7 @@ LL | impl T1 for &dyn T2 {}\n    |\n    = note: expected trait `<&dyn T2 as T0>`\n               found trait `<&(dyn T2 + 'static) as T0>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/issue-65230.rs:8:13\n    |\n LL | impl T1 for &dyn T2 {}"}, {"sha": "7b1fac082e42f18a4774857bcdf50a6642a74305", "filename": "src/test/ui/nll/issue-52742.base.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -4,7 +4,7 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         self.y = b.z\n    |                  ^^^\n    |\n-note: ...the reference is valid for the lifetime `'_` as defined here...\n+note: ...the reference is valid for the anonymous lifetime as defined here...\n   --> $DIR/issue-52742.rs:15:10\n    |\n LL | impl Foo<'_, '_> {"}, {"sha": "1a2165e0a9dac1578af9ee00974cd4e37901d4a4", "filename": "src/test/ui/nll/issue-52742.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -2,7 +2,7 @@ error: lifetime may not live long enough\n   --> $DIR/issue-52742.rs:17:9\n    |\n LL |     fn take_bar(&mut self, b: Bar<'_>) {\n-   |                 ---------         -- let's call this `'1`\n+   |                 ---------  - has type `Bar<'1>`\n    |                 |\n    |                 has type `&mut Foo<'_, '2>`\n LL |         self.y = b.z"}, {"sha": "2ec6a7af3f25747af97e73c1ec28ab741c9b9cac", "filename": "src/test/ui/nll/issue-55394.base.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |         Foo { bar }\n    |               ^^^\n-note: but, the lifetime must be valid for the lifetime `'_` as defined here...\n+note: but, the lifetime must be valid for the anonymous lifetime as defined here...\n   --> $DIR/issue-55394.rs:11:10\n    |\n LL | impl Foo<'_> {"}, {"sha": "5b8b9bb68ad1e916c397e2413614d6ad3b6baebd", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -2,9 +2,9 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -                     ^^^^^^^^\n+   |                          -----                 ^^^^^^^^\n    |                          |\n-   |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n+   |                          hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |"}, {"sha": "d2106630dfed799deade85311de88b7308030239", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -5,6 +5,12 @@ LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n    |                                    ----     ----   ^ ...but data from `f` is returned here\n    |                                    |\n    |                                    this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn a<'a>(self: Pin<&'a Foo>, f: &'a Foo) -> &Foo { f }\n+   |               ++++            ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:15:82\n@@ -13,6 +19,12 @@ LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (\n    |                                     ----              -----------------          ^ ...but data from `f` is returned here\n    |                                     |\n    |                                     this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn c<'a>(self: Pin<&'a Self>, f: &'a Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |               ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:22:64"}, {"sha": "3fd58725d02b7fcf3ba0218e83d8156e794d4c14", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -6,6 +6,11 @@ LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n    |                          |         |\n    |                          |         let's call the lifetime of this reference `'1`\n    |                          let's call the lifetime of this reference `'2`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn a<'a>(self: Pin<&'a Foo>, f: &'a Foo) -> &Foo { f }\n+   |               ++++            ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:15:75\n@@ -15,6 +20,11 @@ LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (\n    |                          |          |\n    |                          |          let's call the lifetime of this reference `'1`\n    |                          let's call the lifetime of this reference `'2`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn c<'a>(self: Pin<&'a Self>, f: &'a Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |               ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:22:64"}, {"sha": "0e2bbcc3c04db4f5eca744dc41570bba4503ebcb", "filename": "src/test/ui/self/elision/lt-ref-self-async.base.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:24:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:30:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:36:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:42:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:48:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++             ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1c889838e7082cabbd3c4f95d18bec503f726fb9", "filename": "src/test/ui/self/elision/lt-ref-self-async.nll.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:24:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:30:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:36:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:42:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:48:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                         let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++             ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "8ffc0d62242129748939bfb5796ce1ad626bca07", "filename": "src/test/ui/self/elision/ref-mut-self-async.base.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n    |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a mut self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:24:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n    |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a mut Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:30:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:36:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:42:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:48:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "9beafcd4ff994c3e000e13dfea4c475eaa474831", "filename": "src/test/ui/self/elision/ref-mut-self-async.nll.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a mut self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:24:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a mut Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:30:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:36:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:42:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:48:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "fefb3fc1944393f057946d08ce43e43f72994e80", "filename": "src/test/ui/self/elision/ref-mut-struct-async.base.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n    |                                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a mut Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:22:9\n@@ -17,6 +23,12 @@ LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n    |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:28:9\n@@ -27,6 +39,12 @@ LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n    |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:34:9\n@@ -37,6 +55,12 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u\n    |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:40:9\n@@ -47,6 +71,12 @@ LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u\n    |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Struct<'a>(self: Box<Pin<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "7fbecbe76a5485f1801321187082d8dbed49a8a5", "filename": "src/test/ui/self/elision/ref-mut-struct-async.nll.stderr", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n    |                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a mut Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++                 ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:22:9\n@@ -17,6 +22,11 @@ LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:28:9\n@@ -27,6 +37,11 @@ LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:34:9\n@@ -37,6 +52,11 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:40:9\n@@ -47,6 +67,11 @@ LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Struct<'a>(self: Box<Pin<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2b142b089d51b423e19457468791371a08fc5e86", "filename": "src/test/ui/self/elision/ref-self-async.base.stderr", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:34:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:40:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:46:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:52:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:58:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:64:9\n@@ -67,6 +103,12 @@ LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn wrap_ref_Self_Self<'a>(self: Wrap<&'a Self, Self>, f: &'a u8) -> &u8 {\n+   |                                ++++             ++                  ++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "f4e531a817c3d067a8acd0a00240164b3f0414e7", "filename": "src/test/ui/self/elision/ref-self-async.nll.stderr", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:34:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:40:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:46:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:52:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:58:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:64:9\n@@ -67,6 +97,11 @@ LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                            let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn wrap_ref_Self_Self<'a>(self: Wrap<&'a Self, Self>, f: &'a u8) -> &u8 {\n+   |                                ++++             ++                  ++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "88ddca89804f6833085f233684117a2cde1d009d", "filename": "src/test/ui/self/elision/ref-struct-async.base.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n    |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:22:9\n@@ -17,6 +23,12 @@ LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:28:9\n@@ -27,6 +39,12 @@ LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:34:9\n@@ -37,6 +55,12 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:40:9\n@@ -47,6 +71,12 @@ LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Struct<'a>(self: Box<Pin<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                            ++++                ++               ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "83c20329c3dad9601a736bf9069a5ac1fe4aa0fd", "filename": "src/test/ui/self/elision/ref-struct-async.nll.stderr", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9598b4b594c97dff66feb93522e22db500deea07/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr?ref=9598b4b594c97dff66feb93522e22db500deea07", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n    |                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:22:9\n@@ -17,6 +22,11 @@ LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:28:9\n@@ -27,6 +37,11 @@ LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:34:9\n@@ -37,6 +52,11 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:40:9\n@@ -47,6 +67,11 @@ LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n    |                                           let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Struct<'a>(self: Box<Pin<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                            ++++                ++               ++\n \n error: aborting due to 5 previous errors\n "}]}