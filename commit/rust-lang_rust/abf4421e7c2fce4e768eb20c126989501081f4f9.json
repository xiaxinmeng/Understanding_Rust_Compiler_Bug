{"sha": "abf4421e7c2fce4e768eb20c126989501081f4f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZjQ0MjFlN2MyZmNlNGU3NjhlYjIwYzEyNjk4OTUwMTA4MWY0Zjk=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-07T18:46:52Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-07T18:47:12Z"}, "message": "Generate try_send versions for all the messages. Fixes #3128", "tree": {"sha": "2f278276d0b59c31c5a8cbf077a6dd5efb9777d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f278276d0b59c31c5a8cbf077a6dd5efb9777d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf4421e7c2fce4e768eb20c126989501081f4f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf4421e7c2fce4e768eb20c126989501081f4f9", "html_url": "https://github.com/rust-lang/rust/commit/abf4421e7c2fce4e768eb20c126989501081f4f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf4421e7c2fce4e768eb20c126989501081f4f9/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672bfa5773913ce99524703e943729e3e50953b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/672bfa5773913ce99524703e943729e3e50953b8", "html_url": "https://github.com/rust-lang/rust/commit/672bfa5773913ce99524703e943729e3e50953b8"}], "stats": {"total": 200, "additions": 122, "deletions": 78}, "files": [{"sha": "4fa3d18c2a7a5eaedba1aec2b6086db195de8d0a", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=abf4421e7c2fce4e768eb20c126989501081f4f9", "patch": "@@ -337,7 +337,7 @@ struct buffer_resource<T: send> {\n \n #[doc(hidden)]\n fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n-                                -payload: T) {\n+                                -payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n@@ -346,29 +346,32 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n     p.payload <- some(payload);\n     let old_state = swap_state_rel(p.header.state, full);\n     match old_state {\n-      empty => {\n-        // Yay, fastpath.\n+        empty => {\n+            // Yay, fastpath.\n \n-        // The receiver will eventually clean this up.\n-        //unsafe { forget(p); }\n-      }\n-      full => fail ~\"duplicate send\",\n-      blocked => {\n-        debug!{\"waking up task for %?\", p_};\n-        let old_task = swap_task(p.header.blocked_task, ptr::null());\n-        if !old_task.is_null() {\n-            rustrt::task_signal_event(\n-                old_task, ptr::addr_of(p.header) as *libc::c_void);\n-            rustrt::rust_task_deref(old_task);\n+            // The receiver will eventually clean this up.\n+            //unsafe { forget(p); }\n+            return true;\n         }\n+        full => fail ~\"duplicate send\",\n+        blocked => {\n+            debug!{\"waking up task for %?\", p_};\n+            let old_task = swap_task(p.header.blocked_task, ptr::null());\n+            if !old_task.is_null() {\n+                rustrt::task_signal_event(\n+                    old_task, ptr::addr_of(p.header) as *libc::c_void);\n+                rustrt::rust_task_deref(old_task);\n+            }\n \n-        // The receiver will eventually clean this up.\n-        //unsafe { forget(p); }\n-      }\n-      terminated => {\n-        // The receiver will never receive this. Rely on drop_glue\n-        // to clean everything up.\n-      }\n+            // The receiver will eventually clean this up.\n+            //unsafe { forget(p); }\n+            return true;\n+        }\n+        terminated => {\n+            // The receiver will never receive this. Rely on drop_glue\n+            // to clean everything up.\n+            return false;\n+        }\n     }\n }\n "}, {"sha": "b8c37f84452568f8fce389e7abc84e652814fb15", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=abf4421e7c2fce4e768eb20c126989501081f4f9", "patch": "@@ -15,8 +15,8 @@ mod syntax {\n     export parse;\n }\n \n-fn ident(s: ~str) -> ast::ident {\n-    @(copy s)\n+fn ident(s: &str) -> ast::ident {\n+    @(s.to_unique())\n }\n \n fn path(id: ident, span: span) -> @ast::path {\n@@ -86,9 +86,15 @@ trait ext_ctxt_ast_builder {\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n     fn block_expr(b: ast::blk) -> @ast::expr;\n     fn empty_span() -> span;\n+    fn ty_option(ty: @ast::ty) -> @ast::ty;\n }\n \n impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n+    fn ty_option(ty: @ast::ty) -> @ast::ty {\n+        self.ty_path_ast_builder(path(@~\"option\", self.empty_span())\n+                                 .add_ty(ty))\n+    }\n+\n     fn empty_span() -> span {\n         {lo: 0, hi: 0, expn_info: self.backtrace()}\n     }"}, {"sha": "2e00c1b5e14d82e0ac05efc85609de6418cf19db", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 90, "deletions": 55, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf4421e7c2fce4e768eb20c126989501081f4f9/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=abf4421e7c2fce4e768eb20c126989501081f4f9", "patch": "@@ -31,7 +31,7 @@ mod syntax {\n }\n \n trait gen_send {\n-    fn gen_send(cx: ext_ctxt) -> @ast::item;\n+    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item;\n }\n \n trait to_type_decls {\n@@ -45,12 +45,12 @@ trait gen_init {\n }\n \n impl compile of gen_send for message {\n-    fn gen_send(cx: ext_ctxt) -> @ast::item {\n+    fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!{\"pipec: gen_send\"};\n         match self {\n           message(id, span, tys, this,\n                   some({state: next, tys: next_tys})) => {\n-            debug!{\"pipec: next state exists\"};\n+            debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n@@ -79,85 +79,119 @@ impl compile of gen_send for message {\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n-                body += fmt!{\"let %s = pipes::send_packet_buffered(\\\n+                body += fmt!(\"let %s = pipes::send_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             sp, *next.name};\n-                body += fmt!{\"let %s = pipes::recv_packet_buffered(\\\n+                             sp, *next.name);\n+                body += fmt!(\"let %s = pipes::recv_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             rp, *next.name};\n+                             rp, *next.name);\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n-                  (send, send) => ~\"(c, s)\",\n-                  (send, recv) => ~\"(s, c)\",\n-                  (recv, send) => ~\"(s, c)\",\n-                  (recv, recv) => ~\"(c, s)\"\n+                  (send, send) => \"(c, s)\",\n+                  (send, recv) => \"(s, c)\",\n+                  (recv, send) => \"(s, c)\",\n+                  (recv, recv) => \"(c, s)\"\n                 };\n \n-                body += fmt!{\"let %s = pipes::entangle();\\n\", pat};\n+                body += fmt!(\"let %s = pipes::entangle();\\n\", pat);\n             }\n-            body += fmt!{\"let message = %s::%s(%s);\\n\",\n+            body += fmt!(\"let message = %s::%s(%s);\\n\",\n                          *this.proto.name,\n                          *self.name(),\n                          str::connect(vec::append_one(arg_names, @~\"s\")\n                                       .map(|x| *x),\n-                                      ~\", \")};\n-            body += fmt!{\"pipes::send(pipe, message);\\n\"};\n-            // return the new channel\n-            body += ~\"c }\";\n+                                      ~\", \"));\n+\n+            if !try {\n+                body += fmt!{\"pipes::send(pipe, message);\\n\"};\n+                // return the new channel\n+                body += ~\"c }\";\n+            }\n+            else {\n+                body += fmt!(\"if pipes::send(pipe, message) {\\n \\\n+                                  some(c) \\\n+                              } else { none } }\");\n+            }\n \n             let body = cx.parse_expr(body);\n \n-            cx.item_fn_poly(self.name(),\n+            let mut rty = cx.ty_path_ast_builder(path(next.data_name(),\n+                                                      span)\n+                                                 .add_tys(next_tys));\n+            if try {\n+                rty = cx.ty_option(rty);\n+            }\n+\n+            let name = if try {\n+                @(~\"try_\" + *self.name())\n+            }\n+            else { self.name() };\n+\n+            cx.item_fn_poly(name,\n                             args_ast,\n-                            cx.ty_path_ast_builder(path(next.data_name(),\n-                                                        span)\n-                                      .add_tys(next_tys)),\n+                            rty,\n                             self.get_params(),\n                             cx.expr_block(body))\n           }\n \n-          message(id, span, tys, this, none) => {\n-            debug!{\"pipec: no next state\"};\n-            let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n+            message(id, span, tys, this, none) => {\n+                debug!{\"pipec: no next state\"};\n+                let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n \n-            let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg_mode(n, t, ast::by_copy)\n-            );\n+                let args_ast = (arg_names, tys).map(\n+                    |n, t| cx.arg_mode(n, t, ast::by_copy)\n+                );\n \n-            let args_ast = vec::append(\n-                ~[cx.arg_mode(@~\"pipe\",\n-                              cx.ty_path_ast_builder(path(this.data_name(),\n-                                                          span)\n-                                        .add_tys(cx.ty_vars(this.ty_params))),\n-                              ast::by_copy)],\n-                args_ast);\n+                let args_ast = vec::append(\n+                    ~[cx.arg_mode(@~\"pipe\",\n+                                  cx.ty_path_ast_builder(\n+                                      path(this.data_name(), span)\n+                                      .add_tys(cx.ty_vars(this.ty_params))),\n+                                  ast::by_copy)],\n+                    args_ast);\n \n-            let message_args = if arg_names.len() == 0 {\n-                ~\"\"\n-            }\n-            else {\n-                ~\"(\" + str::connect(arg_names.map(|x| *x), ~\", \") + ~\")\"\n-            };\n+                let message_args = if arg_names.len() == 0 {\n+                    ~\"\"\n+                }\n+                else {\n+                    ~\"(\" + str::connect(arg_names.map(|x| *x), ~\", \") + ~\")\"\n+                };\n \n-            let mut body = ~\"{ \";\n-            body += fmt!{\"let message = %s::%s%s;\\n\",\n-                         *this.proto.name,\n-                         *self.name(),\n-                         message_args};\n-            body += fmt!{\"pipes::send(pipe, message);\\n\"};\n-            body += ~\" }\";\n+                let mut body = ~\"{ \";\n+                body += fmt!{\"let message = %s::%s%s;\\n\",\n+                             *this.proto.name,\n+                             *self.name(),\n+                             message_args};\n+\n+                if !try {\n+                    body += fmt!{\"pipes::send(pipe, message);\\n\"};\n+                    body += ~\" }\";\n+                } else {\n+                    body += fmt!(\"if pipes::send(pipe, message) { \\\n+                                      some(()) \\\n+                                  } else { none } }\");\n+                }\n \n-            let body = cx.parse_expr(body);\n+                let body = cx.parse_expr(body);\n \n-            cx.item_fn_poly(self.name(),\n-                            args_ast,\n-                            cx.ty_nil_ast_builder(),\n-                            self.get_params(),\n-                            cx.expr_block(body))\n+                let name = if try {\n+                    @(~\"try_\" + *self.name())\n+                }\n+                else { self.name() };\n+\n+                cx.item_fn_poly(name,\n+                                args_ast,\n+                                if try {\n+                                    cx.ty_option(cx.ty_nil_ast_builder())\n+                                } else {\n+                                    cx.ty_nil_ast_builder()\n+                                },\n+                                self.get_params(),\n+                                cx.expr_block(body))\n+            }\n           }\n         }\n-    }\n \n     fn to_ty(cx: ext_ctxt) -> @ast::ty {\n         cx.ty_path_ast_builder(path(self.name(), self.span())\n@@ -215,7 +249,8 @@ impl compile of to_type_decls for state {\n         let mut items = ~[];\n         for self.messages.each |m| {\n             if dir == send {\n-                vec::push(items, m.gen_send(cx))\n+                vec::push(items, m.gen_send(cx, true));\n+                vec::push(items, m.gen_send(cx, false));\n             }\n         }\n "}]}