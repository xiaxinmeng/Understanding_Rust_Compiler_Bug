{"sha": "b3d71d900186c3fab2a91d84efcccc739df191d5", "node_id": "C_kwDOAAsO6NoAKGIzZDcxZDkwMDE4NmMzZmFiMmE5MWQ4NGVmY2NjYzczOWRmMTkxZDU", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2022-01-14T00:18:11Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2022-01-14T00:27:12Z"}, "message": "reduce indentaton", "tree": {"sha": "c23f3d39bdb4760373340a769bf37e6d1a4a5dfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c23f3d39bdb4760373340a769bf37e6d1a4a5dfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3d71d900186c3fab2a91d84efcccc739df191d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d71d900186c3fab2a91d84efcccc739df191d5", "html_url": "https://github.com/rust-lang/rust/commit/b3d71d900186c3fab2a91d84efcccc739df191d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3d71d900186c3fab2a91d84efcccc739df191d5/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73945fd6200521c5e2d18b2e0ec4cbd5f9d3762b", "url": "https://api.github.com/repos/rust-lang/rust/commits/73945fd6200521c5e2d18b2e0ec4cbd5f9d3762b", "html_url": "https://github.com/rust-lang/rust/commit/73945fd6200521c5e2d18b2e0ec4cbd5f9d3762b"}], "stats": {"total": 408, "additions": 201, "deletions": 207}, "files": [{"sha": "effe31e4ee70c1a386eb631ff15a5dc51b3a3de1", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 201, "deletions": 207, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/b3d71d900186c3fab2a91d84efcccc739df191d5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3d71d900186c3fab2a91d84efcccc739df191d5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=b3d71d900186c3fab2a91d84efcccc739df191d5", "patch": "@@ -26,85 +26,56 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    if let Node::AnonConst(_) = tcx.hir().get(hir_id) {\n-        let parent_node_id = tcx.hir().get_parent_node(hir_id);\n-        let parent_node = tcx.hir().get(parent_node_id);\n+    match tcx.hir().get(hir_id) {\n+        Node::AnonConst(_) => (),\n+        _ => return None,\n+    };\n \n-        let (generics, arg_idx) = match parent_node {\n-            // This match arm is for when the def_id appears in a GAT whose\n-            // path can't be resolved without typechecking e.g.\n-            //\n-            // trait Foo {\n-            //   type Assoc<const N: usize>;\n-            //   fn foo() -> Self::Assoc<3>;\n-            // }\n-            //\n-            // In the above code we would call this query with the def_id of 3 and\n-            // the parent_node we match on would be the hir node for Self::Assoc<3>\n-            //\n-            // `Self::Assoc<3>` cant be resolved without typchecking here as we\n-            // didnt write <Self as Foo>::Assoc<3>. If we did then another match\n-            // arm would handle this.\n-            //\n-            // I believe this match arm is only needed for GAT but I am not 100% sure - BoxyUwU\n-            Node::Ty(hir_ty @ Ty { kind: TyKind::Path(QPath::TypeRelative(_, segment)), .. }) => {\n-                // Find the Item containing the associated type so we can create an ItemCtxt.\n-                // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n-                // ty which is a fully resolved projection.\n-                // For the code example above, this would mean converting Self::Assoc<3>\n-                // into a ty::Projection(<Self as Foo>::Assoc<3>)\n-                let item_hir_id = tcx\n-                    .hir()\n-                    .parent_iter(hir_id)\n-                    .filter(|(_, node)| matches!(node, Node::Item(_)))\n-                    .map(|(id, _)| id)\n-                    .next()\n-                    .unwrap();\n-                let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n-                let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n-                let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n-\n-                // Iterate through the generics of the projection to find the one that corresponds to\n-                // the def_id that this query was called with. We filter to only const args here as a\n-                // precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n-                // but it can't hurt to be safe ^^\n-                if let ty::Projection(projection) = ty.kind() {\n-                    let generics = tcx.generics_of(projection.item_def_id);\n-\n-                    let arg_index = segment\n-                        .args\n-                        .and_then(|args| {\n-                            args.args\n-                                .iter()\n-                                .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n-                                .position(|arg| arg.id() == hir_id)\n-                        })\n-                        .unwrap_or_else(|| {\n-                            bug!(\"no arg matching AnonConst in segment\");\n-                        });\n+    let parent_node_id = tcx.hir().get_parent_node(hir_id);\n+    let parent_node = tcx.hir().get(parent_node_id);\n \n-                    (generics, arg_index)\n-                } else {\n-                    // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n-                    tcx.sess.delay_span_bug(\n-                        tcx.def_span(def_id),\n-                        \"unexpected non-GAT usage of an anon const\",\n-                    );\n-                    return None;\n-                }\n-            }\n-            Node::Expr(&Expr {\n-                kind:\n-                    ExprKind::MethodCall(segment, ..) | ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                ..\n-            }) => {\n-                let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                let tables = tcx.typeck(body_owner);\n-                // This may fail in case the method/path does not actually exist.\n-                // As there is no relevant param for `def_id`, we simply return\n-                // `None` here.\n-                let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n-                let idx = segment\n+    let (generics, arg_idx) = match parent_node {\n+        // This match arm is for when the def_id appears in a GAT whose\n+        // path can't be resolved without typechecking e.g.\n+        //\n+        // trait Foo {\n+        //   type Assoc<const N: usize>;\n+        //   fn foo() -> Self::Assoc<3>;\n+        // }\n+        //\n+        // In the above code we would call this query with the def_id of 3 and\n+        // the parent_node we match on would be the hir node for Self::Assoc<3>\n+        //\n+        // `Self::Assoc<3>` cant be resolved without typchecking here as we\n+        // didnt write <Self as Foo>::Assoc<3>. If we did then another match\n+        // arm would handle this.\n+        //\n+        // I believe this match arm is only needed for GAT but I am not 100% sure - BoxyUwU\n+        Node::Ty(hir_ty @ Ty { kind: TyKind::Path(QPath::TypeRelative(_, segment)), .. }) => {\n+            // Find the Item containing the associated type so we can create an ItemCtxt.\n+            // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n+            // ty which is a fully resolved projection.\n+            // For the code example above, this would mean converting Self::Assoc<3>\n+            // into a ty::Projection(<Self as Foo>::Assoc<3>)\n+            let item_hir_id = tcx\n+                .hir()\n+                .parent_iter(hir_id)\n+                .filter(|(_, node)| matches!(node, Node::Item(_)))\n+                .map(|(id, _)| id)\n+                .next()\n+                .unwrap();\n+            let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n+            let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n+            let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n+\n+            // Iterate through the generics of the projection to find the one that corresponds to\n+            // the def_id that this query was called with. We filter to only const args here as a\n+            // precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n+            // but it can't hurt to be safe ^^\n+            if let ty::Projection(projection) = ty.kind() {\n+                let generics = tcx.generics_of(projection.item_def_id);\n+\n+                let arg_index = segment\n                     .args\n                     .and_then(|args| {\n                         args.args\n@@ -116,145 +87,168 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                         bug!(\"no arg matching AnonConst in segment\");\n                     });\n \n-                (tcx.generics_of(type_dependent_def), idx)\n+                (generics, arg_index)\n+            } else {\n+                // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(def_id),\n+                    \"unexpected non-GAT usage of an anon const\",\n+                );\n+                return None;\n             }\n+        }\n+        Node::Expr(&Expr {\n+            kind:\n+                ExprKind::MethodCall(segment, ..) | ExprKind::Path(QPath::TypeRelative(_, segment)),\n+            ..\n+        }) => {\n+            let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+            let tables = tcx.typeck(body_owner);\n+            // This may fail in case the method/path does not actually exist.\n+            // As there is no relevant param for `def_id`, we simply return\n+            // `None` here.\n+            let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n+            let idx = segment\n+                .args\n+                .and_then(|args| {\n+                    args.args\n+                        .iter()\n+                        .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n+                        .position(|arg| arg.id() == hir_id)\n+                })\n+                .unwrap_or_else(|| {\n+                    bug!(\"no arg matching AnonConst in segment\");\n+                });\n \n-            Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n-            | Node::Expr(&Expr { kind: ExprKind::Path(_) | ExprKind::Struct(..), .. })\n-            | Node::TraitRef(..)\n-            | Node::Pat(_) => {\n-                let path = match parent_node {\n-                    Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n-                    | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n-                    Node::Expr(&Expr {\n-                        kind:\n-                            ExprKind::Path(QPath::Resolved(_, path))\n-                            | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n-                        ..\n-                    }) => {\n-                        let body_owner =\n-                            tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                        let _tables = tcx.typeck(body_owner);\n-                        &*path\n-                    }\n-                    Node::Pat(pat) => {\n-                        if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n-                            path\n-                        } else {\n-                            tcx.sess.delay_span_bug(\n-                                tcx.def_span(def_id),\n-                                &format!(\n-                                    \"unable to find const parent for {} in pat {:?}\",\n-                                    hir_id, pat\n-                                ),\n-                            );\n-                            return None;\n-                        }\n-                    }\n-                    _ => {\n-                        tcx.sess.delay_span_bug(\n-                            tcx.def_span(def_id),\n-                            &format!(\"unexpected const parent path {:?}\", parent_node),\n-                        );\n-                        return None;\n-                    }\n-                };\n-\n-                // We've encountered an `AnonConst` in some path, so we need to\n-                // figure out which generic parameter it corresponds to and return\n-                // the relevant type.\n-                let filtered = path\n-                    .segments\n-                    .iter()\n-                    .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n-                    .find_map(|(args, seg)| {\n-                        args.iter()\n-                            .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n-                            .position(|arg| arg.id() == hir_id)\n-                            .map(|index| (index, seg))\n-                    });\n-                let (arg_index, segment) = match filtered {\n-                    None => {\n-                        tcx.sess.delay_span_bug(\n-                            tcx.def_span(def_id),\n-                            \"no arg matching AnonConst in path\",\n-                        );\n-                        return None;\n-                    }\n-                    Some(inner) => inner,\n-                };\n-\n-                // Try to use the segment resolution if it is valid, otherwise we\n-                // default to the path resolution.\n-                let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                use def::CtorOf;\n-                let generics = match res {\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx.generics_of(\n-                        tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap(),\n-                    ),\n-                    Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n-                        tcx.generics_of(tcx.parent(def_id).unwrap())\n-                    }\n-                    // Other `DefKind`s don't have generics and would ICE when calling\n-                    // `generics_of`.\n-                    Res::Def(\n-                        DefKind::Struct\n-                        | DefKind::Union\n-                        | DefKind::Enum\n-                        | DefKind::Trait\n-                        | DefKind::OpaqueTy\n-                        | DefKind::TyAlias\n-                        | DefKind::ForeignTy\n-                        | DefKind::TraitAlias\n-                        | DefKind::AssocTy\n-                        | DefKind::Fn\n-                        | DefKind::AssocFn\n-                        | DefKind::AssocConst\n-                        | DefKind::Impl,\n-                        def_id,\n-                    ) => tcx.generics_of(def_id),\n-                    Res::Err => {\n-                        tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n-                        return None;\n-                    }\n-                    _ => {\n-                        // If the user tries to specify generics on a type that does not take them,\n-                        // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n-                        // no arguments have been passed. An error should already have been emitted.\n+            (tcx.generics_of(type_dependent_def), idx)\n+        }\n+\n+        Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n+        | Node::Expr(&Expr { kind: ExprKind::Path(_) | ExprKind::Struct(..), .. })\n+        | Node::TraitRef(..)\n+        | Node::Pat(_) => {\n+            let path = match parent_node {\n+                Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n+                | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                Node::Expr(&Expr {\n+                    kind:\n+                        ExprKind::Path(QPath::Resolved(_, path))\n+                        | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n+                    ..\n+                }) => {\n+                    let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+                    let _tables = tcx.typeck(body_owner);\n+                    &*path\n+                }\n+                Node::Pat(pat) => {\n+                    if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n+                        path\n+                    } else {\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(def_id),\n-                            &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),\n+                            &format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n                         );\n                         return None;\n                     }\n-                };\n+                }\n+                _ => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(def_id),\n+                        &format!(\"unexpected const parent path {:?}\", parent_node),\n+                    );\n+                    return None;\n+                }\n+            };\n+\n+            // We've encountered an `AnonConst` in some path, so we need to\n+            // figure out which generic parameter it corresponds to and return\n+            // the relevant type.\n+            let filtered = path\n+                .segments\n+                .iter()\n+                .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n+                .find_map(|(args, seg)| {\n+                    args.iter()\n+                        .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n+                        .position(|arg| arg.id() == hir_id)\n+                        .map(|index| (index, seg))\n+                });\n+            let (arg_index, segment) = match filtered {\n+                None => {\n+                    tcx.sess\n+                        .delay_span_bug(tcx.def_span(def_id), \"no arg matching AnonConst in path\");\n+                    return None;\n+                }\n+                Some(inner) => inner,\n+            };\n+\n+            // Try to use the segment resolution if it is valid, otherwise we\n+            // default to the path resolution.\n+            let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+            use def::CtorOf;\n+            let generics = match res {\n+                Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx\n+                    .generics_of(tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap()),\n+                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n+                    tcx.generics_of(tcx.parent(def_id).unwrap())\n+                }\n+                // Other `DefKind`s don't have generics and would ICE when calling\n+                // `generics_of`.\n+                Res::Def(\n+                    DefKind::Struct\n+                    | DefKind::Union\n+                    | DefKind::Enum\n+                    | DefKind::Trait\n+                    | DefKind::OpaqueTy\n+                    | DefKind::TyAlias\n+                    | DefKind::ForeignTy\n+                    | DefKind::TraitAlias\n+                    | DefKind::AssocTy\n+                    | DefKind::Fn\n+                    | DefKind::AssocFn\n+                    | DefKind::AssocConst\n+                    | DefKind::Impl,\n+                    def_id,\n+                ) => tcx.generics_of(def_id),\n+                Res::Err => {\n+                    tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n+                    return None;\n+                }\n+                _ => {\n+                    // If the user tries to specify generics on a type that does not take them,\n+                    // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n+                    // no arguments have been passed. An error should already have been emitted.\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(def_id),\n+                        &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),\n+                    );\n+                    return None;\n+                }\n+            };\n \n-                (generics, arg_index)\n+            (generics, arg_index)\n+        }\n+        _ => return None,\n+    };\n+\n+    debug!(?parent_node);\n+    debug!(?generics);\n+    debug!(?arg_idx);\n+    generics\n+        .params\n+        .iter()\n+        .filter(|param| !matches!(param.kind, ty::GenericParamDefKind::Lifetime { .. }))\n+        .nth(match generics.has_self && generics.parent.is_none() {\n+            true => arg_idx + 1,\n+            false => arg_idx,\n+        })\n+        .and_then(|param| match param.kind {\n+            ty::GenericParamDefKind::Const { .. } => {\n+                debug!(?param);\n+                Some(param.def_id)\n             }\n-            _ => return None,\n-        };\n-\n-        debug!(?parent_node);\n-        debug!(?generics);\n-        debug!(?arg_idx);\n-        generics\n-            .params\n-            .iter()\n-            .filter(|param| !matches!(param.kind, ty::GenericParamDefKind::Lifetime { .. }))\n-            .nth(match generics.has_self && generics.parent.is_none() {\n-                true => arg_idx + 1,\n-                false => arg_idx,\n-            })\n-            .and_then(|param| match param.kind {\n-                ty::GenericParamDefKind::Const { .. } => {\n-                    debug!(?param);\n-                    Some(param.def_id)\n-                }\n-                _ => None,\n-            })\n-    } else {\n-        None\n-    }\n+            _ => None,\n+        })\n }\n \n fn get_path_containing_arg_in_pat<'hir>("}]}