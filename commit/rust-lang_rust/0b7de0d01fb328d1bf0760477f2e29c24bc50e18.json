{"sha": "0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiN2RlMGQwMWZiMzI4ZDFiZjA3NjA0NzdmMmUyOWMyNGJjNTBlMTg=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-11-23T20:39:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-23T20:39:12Z"}, "message": "Merge pull request #1357 from Manishearth/rustup\n\nRustup to *rustc 1.15.0-nightly (7b3eeea22 2016-11-21)* and bump to 0.0.101", "tree": {"sha": "6626275278c388fa4fda5f627b98973b2a9b9af9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6626275278c388fa4fda5f627b98973b2a9b9af9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "html_url": "https://github.com/rust-lang/rust/commit/0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "530083c3b925829e4d2211057444510a7177f3b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/530083c3b925829e4d2211057444510a7177f3b4", "html_url": "https://github.com/rust-lang/rust/commit/530083c3b925829e4d2211057444510a7177f3b4"}, {"sha": "338690b4e9b7e2dfd5f7fbda8359631597f3af56", "url": "https://api.github.com/repos/rust-lang/rust/commits/338690b4e9b7e2dfd5f7fbda8359631597f3af56", "html_url": "https://github.com/rust-lang/rust/commit/338690b4e9b7e2dfd5f7fbda8359631597f3af56"}], "stats": {"total": 228, "additions": 120, "deletions": 108}, "files": [{"sha": "21dc43c4197a68bf82668c7d176efae0aaf73f51", "filename": "CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -1,11 +1,16 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.101 \u2014 2016-11-23\n+* Update to *rustc 1.15.0-nightly (7b3eeea22 2016-11-21)*\n+* New lint: [`string_extend_chars`]\n+\n ## 0.0.100 \u2014 2016-11-20\n * Update to *rustc 1.15.0-nightly (ac635aa95 2016-11-18)*\n \n ## 0.0.99 \u2014 2016-11-18\n * Update to rustc 1.15.0-nightly (0ed951993 2016-11-14)\n+* New lint: [`get_unwrap`]\n \n ## 0.0.98 \u2014 2016-11-08\n * Fixes a an issue due to a change in how cargo handles `--sysroot`, which broke `cargo clippy`\n@@ -16,6 +21,7 @@ All notable changes to this project will be documented in this file.\n   compatibility.\n * `cargo clippy --help` is more helping (and less helpful :smile:)\n * Rustup to *rustc 1.14.0-nightly (5665bdf3e 2016-11-02)*\n+* New lints: [`if_let_redundant_pattern_matching`], [`partialeq_ne_impl`]\n \n ## 0.0.96 \u2014 2016-10-22\n * Rustup to *rustc 1.14.0-nightly (f09420685 2016-10-20)*"}, {"sha": "49957dd40f917dbbbdcf865a65281ec0ab868dbf", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.100\"\n+version = \"0.0.101\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.100\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.101\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "07eebae08f9248d14a08fc7cba14b35f90117a23", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.100\"\n+version = \"0.0.101\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "c57122eeef9187ddb7b9e8ebdebb133690c96e76", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -2,6 +2,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use std::f64::consts as f64;\n use syntax::ast::{Lit, LitKind, FloatTy};\n+use syntax::symbol;\n use utils::span_lint;\n \n /// **What it does:** Checks for floating point literals that approximate\n@@ -75,7 +76,8 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: &str, module: &str) {\n+fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &str) {\n+    let s = &*s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {\n             if is_approx_const(constant, s, min_digits) {"}, {"sha": "21a662344762dbe390d3421515e2c0ab4ebda823", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -83,15 +83,15 @@ impl LintPass for AttrPass {\n \n impl LateLintPass for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext, attr: &Attribute) {\n-        if let MetaItemKind::List(ref name, ref items) = attr.node.value.node {\n-            if items.is_empty() || name != &\"deprecated\" {\n+        if let MetaItemKind::List(ref items) = attr.value.node {\n+            if items.is_empty() || attr.name() != \"deprecated\" {\n                 return;\n             }\n             for item in items {\n                 if_let_chain! {[\n                     let NestedMetaItemKind::MetaItem(ref mi) = item.node,\n-                    let MetaItemKind::NameValue(ref name, ref lit) = mi.node,\n-                    name == &\"since\",\n+                    let MetaItemKind::NameValue(ref lit) = mi.node,\n+                    mi.name() == \"since\",\n                 ], {\n                     check_semver(cx, item.span, lit);\n                 }}\n@@ -107,8 +107,8 @@ impl LateLintPass for AttrPass {\n             ItemExternCrate(_) |\n             ItemUse(_) => {\n                 for attr in &item.attrs {\n-                    if let MetaItemKind::List(ref name, ref lint_list) = attr.node.value.node {\n-                        match &**name {\n+                    if let MetaItemKind::List(ref lint_list) = attr.value.node {\n+                        match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports`\n                                 for lint in lint_list {\n@@ -210,8 +210,8 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n     }\n \n     for attr in attrs {\n-        if let MetaItemKind::List(ref inline, ref values) = attr.node.value.node {\n-            if values.len() != 1 || inline != &\"inline\" {\n+        if let MetaItemKind::List(ref values) = attr.value.node {\n+            if values.len() != 1 || attr.name() != \"inline\" {\n                 continue;\n             }\n             if is_word(&values[0], \"always\") {\n@@ -227,7 +227,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n \n fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n-        if Version::parse(&*is).is_ok() {\n+        if Version::parse(&*is.as_str()).is_ok() {\n             return;\n         }\n     }\n@@ -239,10 +239,8 @@ fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n \n fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n     if let NestedMetaItemKind::MetaItem(ref mi) = nmi.node {\n-        if let MetaItemKind::Word(ref word) = mi.node {\n-            return word == expected;\n-        }\n+        mi.is_word() && mi.name() == expected\n+    } else {\n+        false\n     }\n-\n-    false\n }"}, {"sha": "b46fda3d2f20ee27435ddb42911f1f1803c55ab5", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -3,7 +3,7 @@ use rustc::ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::util::small_vector::SmallVector;\n use utils::{SpanlessEq, SpanlessHash};\n use utils::{get_parent_expr, in_macro, span_lint_and_then, span_note_and_lint, snippet};"}, {"sha": "4183632543b7a91fb2dc377b94c1d4a491bbf324", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -59,13 +59,13 @@ impl EarlyLintPass for Doc {\n /// `syntax::parse::lexer::comments::strip_doc_comment_decoration` because we need to keep track of\n /// the span but this function is inspired from the later.\n #[allow(cast_possible_truncation)]\n-pub fn strip_doc_comment_decoration((comment, span): (&str, Span)) -> Vec<(&str, Span)> {\n+pub fn strip_doc_comment_decoration((comment, span): (String, Span)) -> Vec<(String, Span)> {\n     // one-line comments lose their prefix\n     const ONELINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONELINERS {\n         if comment.starts_with(*prefix) {\n             return vec![(\n-                &comment[prefix.len()..],\n+                comment[prefix.len()..].to_owned(),\n                 Span { lo: span.lo + BytePos(prefix.len() as u32), ..span }\n             )];\n         }\n@@ -77,7 +77,7 @@ pub fn strip_doc_comment_decoration((comment, span): (&str, Span)) -> Vec<(&str,\n             debug_assert_eq!(offset as u32 as usize, offset);\n \n             (\n-                line,\n+                line.to_owned(),\n                 Span {\n                     lo: span.lo + BytePos(offset as u32),\n                     ..span\n@@ -93,9 +93,10 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n     let mut docs = vec![];\n \n     for attr in attrs {\n-        if attr.node.is_sugared_doc {\n-            if let ast::MetaItemKind::NameValue(_, ref doc) = attr.node.value.node {\n+        if attr.is_sugared_doc {\n+            if let ast::MetaItemKind::NameValue(ref doc) = attr.value.node {\n                 if let ast::LitKind::Str(ref doc, _) = doc.node {\n+                    let doc = (*doc.as_str()).to_owned();\n                     docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n                 }\n             }\n@@ -108,7 +109,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n }\n \n #[allow(while_let_loop)] // #362\n-fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)]) -> Result<(), ()> {\n+fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(String, Span)]) -> Result<(), ()> {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -136,7 +137,7 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n         /// First byte of the current potential match\n         current_word_begin: usize,\n         /// List of lines and their associated span\n-        docs: &'a [(&'a str, Span)],\n+        docs: &'a [(String, Span)],\n         /// Index of the current line we are parsing\n         line: usize,\n         /// Whether we are in a link\n@@ -155,7 +156,8 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n         }\n \n         fn line(&self) -> (&'a str, Span) {\n-            self.docs[self.line]\n+            let (ref doc, span) = self.docs[self.line];\n+            (doc, span)\n         }\n \n         fn peek(&self) -> Option<char> {"}, {"sha": "7a0e17335531c9a880d19e70943d51df7df45945", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -82,7 +82,7 @@ fn check_cond<'a, 'tcx, 'b>(cx: &'a LateContext<'a, 'tcx>, check: &'b Expr) -> O\n     if_let_chain! {[\n         let ExprMethodCall(ref name, _, ref params) = check.node,\n         params.len() >= 2,\n-        name.node.as_str() == \"contains_key\",\n+        &*name.node.as_str() == \"contains_key\",\n         let ExprAddrOf(_, ref key) = params[1].node\n     ], {\n         let map = &params[0];\n@@ -116,7 +116,7 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n-            name.node.as_str() == \"insert\",\n+            &*name.node.as_str() == \"insert\",\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &*params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {"}, {"sha": "74611d491c7fa1e80d987e8805bfa3f801821c48", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -3,7 +3,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use utils::{span_help_and_lint, span_lint};\n use utils::{camel_case_from, camel_case_until, in_macro};\n "}, {"sha": "33db64e0ceffbc961be3375b5f615d781b367c61", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -3,6 +3,7 @@ use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n use rustc::ty::TypeVariants;\n use syntax::ast::LitKind;\n+use syntax::symbol::InternedString;\n use utils::paths;\n use utils::{is_expn_of, match_def_path, match_type, resolve_node, span_lint, walk_ptrs_ty};\n \n@@ -73,14 +74,14 @@ impl LateLintPass for Pass {\n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n /// Public because it's shared with a lint in print.rs.\n pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Expr)\n-                                         -> Option<Vec<&'a str>> {\n+                                         -> Option<Vec<InternedString>> {\n     if_let_chain! {[\n         let ExprBlock(ref block) = expr.node,\n         block.stmts.len() == 1,\n         let StmtDecl(ref decl, _) = block.stmts[0].node,\n         let DeclItem(ref decl) = decl.node,\n         let Some(NodeItem(decl)) = cx.tcx.map.find(decl.id),\n-        decl.name.as_str() == \"__STATIC_FMTSTR\",\n+        &*decl.name.as_str() == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n         let ExprAddrOf(_, ref expr) = expr.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,\n@@ -89,7 +90,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         for expr in exprs {\n             if let ExprLit(ref lit) = expr.node {\n                 if let LitKind::Str(ref lit, _) = lit.node {\n-                    result.push(&**lit);\n+                    result.push(lit.as_str());\n                 }\n             }\n         }"}, {"sha": "c81fcdc8624257b90110f63b74d8526eb44339ca", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -90,7 +90,7 @@ impl LateLintPass for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n-        item.name.as_str() == name &&\n+        &*item.name.as_str() == name &&\n         if let MethodTraitItem(ref sig, _) = item.node {\n             if sig.decl.has_self() {\n                 sig.decl.inputs.len() == 1\n@@ -117,7 +117,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        item.name.as_str() == name &&\n+        &*item.name.as_str() == name &&\n         if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.map.local_def_id(item.id.node_id);\n@@ -157,7 +157,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {\n     // check if we are in an is_empty() method\n     if let Some(name) = get_item_name(cx, left) {\n-        if name.as_str() == \"is_empty\" {\n+        if &*name.as_str() == \"is_empty\" {\n             return;\n         }\n     }\n@@ -172,7 +172,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned { node: LitKind::Int(0, _), .. } = *lit {\n-        if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n+        if &*name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint_and_then(cx, LEN_ZERO, span, \"length comparison to zero\", |db| {\n                 db.span_suggestion(span,\n                                    \"consider using `is_empty`\",\n@@ -187,7 +187,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if item.name.as_str() == \"is_empty\" {\n+            if &*item.name.as_str() == \"is_empty\" {\n                 let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n                 ty.inputs.len() == 1\n             } else {"}, {"sha": "710604b3a2829c3a8c2cfbb11609677f5e7ab9e4", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -196,7 +196,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if lt.name.as_str() != \"'static\" {\n+        if &*lt.name.as_str() != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n         }\n     }\n@@ -225,7 +225,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if lt.name.as_str() == \"'static\" {\n+            if &*lt.name.as_str() == \"'static\" {\n                 self.lts.push(RefLt::Static);\n             } else {\n                 self.lts.push(RefLt::Named(lt.name));"}, {"sha": "bcfa89c6bf1a3e61e7cdbcb8bbc401e2280549c3", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -370,9 +370,9 @@ impl LateLintPass for Pass {\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n                 if let Some(lhs_constructor) = path.segments.last() {\n-                    if method_name.node.as_str() == \"next\" &&\n+                    if &*method_name.node.as_str() == \"next\" &&\n                        match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       lhs_constructor.name.as_str() == \"Some\" &&\n+                       &*lhs_constructor.name.as_str() == \"Some\" &&\n                        !is_refutable(cx, &pat_args[0]) &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n@@ -395,7 +395,7 @@ impl LateLintPass for Pass {\n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node.as_str() == \"collect\" &&\n+                if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n                    match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n@@ -509,7 +509,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n     if_let_chain! {[\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n-        method.node.as_str() == \"len\",\n+        &*method.node.as_str() == \"len\",\n         let ExprPath(_, ref path) = len_args[0].node,\n         path.segments.len() == 1,\n         &path.segments[0].name == var\n@@ -580,14 +580,14 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n         if args.len() == 1 {\n             let method_name = method.node;\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-            if method_name.as_str() == \"iter\" || method_name.as_str() == \"iter_mut\" {\n+            if &*method_name.as_str() == \"iter\" || &*method_name.as_str() == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n                     let object = snippet(cx, args[0].span, \"_\");\n                     span_lint(cx,\n                               EXPLICIT_ITER_LOOP,\n                               expr.span,\n                               &format!(\"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n-                                       if method_name.as_str() == \"iter_mut\" {\n+                                       if &*method_name.as_str() == \"iter_mut\" {\n                                            \"mut \"\n                                        } else {\n                                            \"\"\n@@ -596,7 +596,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        object,\n                                        method_name));\n                 }\n-            } else if method_name.as_str() == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n+            } else if &*method_name.as_str() == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                     let object = snippet(cx, args[0].span, \"_\");\n                     span_lint(cx,\n                               EXPLICIT_INTO_ITER_LOOP,\n@@ -606,7 +606,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                                        object,\n                                        method_name));\n \n-            } else if method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n+            } else if &*method_name.as_str() == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n                 span_lint(cx,\n                           ITER_NEXT_LOOP,\n                           expr.span,"}, {"sha": "07bbc70382646e85050a54a404da3b54789acbda", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -28,7 +28,7 @@ impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n-            if name.node.as_str() == \"map\" && args.len() == 2 {\n+            if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, ref closure_expr, _) => {\n                         let closure_expr = remove_blocks(closure_expr);\n@@ -51,7 +51,7 @@ impl LateLintPass for Pass {\n                             }\n                             // explicit clone() calls ( .map(|x| x.clone()) )\n                             else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                if clone_call.node.as_str() == \"clone\" &&\n+                                if &*clone_call.node.as_str() == \"clone\" &&\n                                     clone_args.len() == 1 &&\n                                     match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                     expr_eq_name(&clone_args[0], arg_ident)"}, {"sha": "7c48b7a11772a21d0d833d40b3402ca7fb66fbc8", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -605,14 +605,14 @@ impl LateLintPass for Pass {\n                 lint_or_fun_call(cx, expr, &name.node.as_str(), args);\n \n                 let self_ty = cx.tcx.tables().expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && name.node.as_str() == \"clone\" {\n+                if args.len() == 1 && &*name.node.as_str() == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty) if ty.ty.sty == ty::TyStr => {\n                         for &(method, pos) in &PATTERN_METHODS {\n-                            if name.node.as_str() == method && args.len() > pos {\n+                            if &*name.node.as_str() == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n                             }\n                         }\n@@ -643,7 +643,7 @@ impl LateLintPass for Pass {\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if name.as_str() == method_name &&\n+                if &*name.as_str() == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n                    self_kind.matches(&explicit_self, false) {\n@@ -681,7 +681,7 @@ impl LateLintPass for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            if &name.as_str() == &\"new\" &&\n+            if &*name.as_str() == \"new\" &&\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n@@ -979,7 +979,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sug\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n+        if &*name.node.as_str() == \"iter\" && may_slice(cx, cx.tcx.tables().expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &*args[0]).map(|sugg| {\n                 sugg.addr()\n             })\n@@ -1209,7 +1209,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n         let hir::ExprPath(None, ref path) = fun.node,\n-        path.segments.len() == 1 && path.segments[0].name.as_str() == \"Some\"\n+        path.segments.len() == 1 && &*path.segments[0].name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "190cef82db22e2f11be0d89306a2e0599e7eb219", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -235,7 +235,7 @@ impl LateLintPass for Pass {\n                     return;\n                 }\n                 if let Some(name) = get_item_name(cx, expr) {\n-                    let name = name.as_str();\n+                    let name = &*name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n                         name.ends_with(\"_eq\") {\n                         return;\n@@ -271,7 +271,7 @@ impl LateLintPass for Pass {\n                     .as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n-                    binding != \"_result\" && // FIXME: #944\n+                    &*binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n                     non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n@@ -315,7 +315,7 @@ impl LateLintPass for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     path.segments.last().map(|seg| {\n-        if seg.name.as_str() == \"NAN\" {\n+        if &*seg.name.as_str() == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       span,\n@@ -359,7 +359,8 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n     let (arg_ty, snip) = match expr.node {\n         ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n-            if name.as_str() == \"to_string\" || name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n+            let name = &*name.as_str();\n+            if name == \"to_string\" || name == \"to_owned\" && is_str_arg(cx, args) {\n                 (cx.tcx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;"}, {"sha": "92d78e875dc1e0fd95ce4abba92c8dbe9ca54a93", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -100,7 +100,7 @@ impl LateLintPass for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if decl.inputs.is_empty() && name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n+            if decl.inputs.is_empty() && &*name.as_str() == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id)));\n                 if_let_chain!{["}, {"sha": "b5b901ccf8474cea4748a708ce0cfd4052b8ecd2", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::visit::{Visitor, walk_block, walk_pat, walk_expr};"}, {"sha": "ca30c14e191ad409948dac9c4792fd819ff4143b", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -36,7 +36,7 @@ impl LateLintPass for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n-            if name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);"}, {"sha": "97ad9173ef15fbe2724c96caa5959971495222fa", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -45,8 +45,8 @@ impl LateLintPass for Pass {\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,\n-            let Some(par) = string.find('{'),\n-            string[par..].contains('}')\n+            let Some(par) = string.as_str().find('{'),\n+            string.as_str()[par..].contains('}')\n         ], {\n             span_lint(cx, PANIC_PARAMS, params[0].span,\n                       \"you probably are missing some parameter in your format string\");"}, {"sha": "ab02a62ad29285ac7cc0c170b9aae9b1df1a5907", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -49,27 +49,29 @@ impl LintPass for StepByZero {\n impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n+            let name = &*name.as_str();\n+\n             // Range with step_by(0).\n-            if name.as_str() == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n+            if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) &&\n                is_integer_literal(&args[1], 0) {\n                 span_lint(cx,\n                           RANGE_STEP_BY_ZERO,\n                           expr.span,\n                           \"Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` \\\n                            instead\");\n-            } else if name.as_str() == \"zip\" && args.len() == 2 {\n+            } else if name == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n                 if_let_chain! {[\n                     // .iter() call\n                     let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                    iter_name.as_str() == \"iter\",\n+                    &*iter_name.as_str() == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n                     let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                    len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    &*len_name.as_str() == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n                     let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n                     let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,"}, {"sha": "ec3013d36a1b151fed23a223d93f551547d218df", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -8,7 +8,7 @@ use std::collections::HashSet;\n use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{Span, BytePos};\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_and_lint};\n \n /// **What it does:** Checks [regex] creation (with `Regex::new`,\n@@ -203,6 +203,7 @@ fn check_regex(cx: &LateContext, expr: &Expr, utf8: bool) {\n \n     if let ExprLit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, _) = lit.node {\n+            let r = &*r.as_str();\n             match builder.parse(r) {\n                 Ok(r) => {\n                     if let Some(repl) = is_trivial_regex(&r) {"}, {"sha": "d79913b2c15b7e9af14b7da074ec16f5e1eda51d", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -146,8 +146,8 @@ impl EarlyLintPass for ReturnPass {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    if let ast::MetaItemKind::List(ref key, _) = attr.node.value.node {\n-        *key == \"cfg\"\n+    if let ast::MetaItemKind::List(_) = attr.value.node {\n+        attr.name() == \"cfg\"\n     } else {\n         false\n     }"}, {"sha": "e971d6ee13fc748d99dc2c54dbd409374339e217", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -143,10 +143,10 @@ impl LateLintPass for StringLitAsBytes {\n         use utils::{snippet, in_macro};\n \n         if let ExprMethodCall(ref name, _, ref args) = e.node {\n-            if name.node.as_str() == \"as_bytes\" {\n+            if &*name.node.as_str() == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n-                        if lit_content.chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {\n+                        if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(cx, args[0].span) {\n                             span_lint_and_then(cx,\n                                                STRING_LIT_AS_BYTES,\n                                                e.span,"}, {"sha": "7cd108dd02d9a22c17e1771b81431f194657d663", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use utils::span_lint;\n \n /// **What it does:** Checks for imports that remove \"unsafe\" from an item's"}, {"sha": "4aefc822a6497031c4780c08038983f1e5867fb4", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn};\n use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use utils::{in_macro, span_lint};\n \n /// **What it does:** Checks for unused labels."}, {"sha": "9a1753d511ce5d84cfbfe8ba360db1a76804baa3", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -10,22 +10,20 @@ use toml;\n /// Get the configuration file from arguments.\n pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>]) -> Result<Option<path::PathBuf>, (&'static str, codemap::Span)> {\n     for arg in args.iter().filter_map(|a| a.meta_item()) {\n-        match arg.node {\n-            ast::MetaItemKind::Word(ref name) |\n-            ast::MetaItemKind::List(ref name, _) => {\n-                if name == &\"conf_file\" {\n-                    return Err((\"`conf_file` must be a named value\", arg.span));\n+        if arg.name() == \"conf_file\" {\n+            return match arg.node {\n+                ast::MetaItemKind::Word |\n+                ast::MetaItemKind::List(_) => {\n+                    Err((\"`conf_file` must be a named value\", arg.span))\n                 }\n-            }\n-            ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                if name == &\"conf_file\" {\n-                    return if let ast::LitKind::Str(ref file, _) = value.node {\n+                ast::MetaItemKind::NameValue(ref value) => {\n+                    if let ast::LitKind::Str(ref file, _) = value.node {\n                         Ok(Some(file.to_string().into()))\n                     } else {\n                         Err((\"`conf_file` value must be a string\", value.span))\n-                    };\n+                    }\n                 }\n-            }\n+            };\n         }\n     }\n "}, {"sha": "74857232485eaf6b2185182b6ac6883d4f2123dc", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -61,7 +61,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n     /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n-                          .find(|field| field.name.node.as_str() == name)\n+                          .find(|field| field.name.node == name)\n                           .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n                           .expr;\n "}, {"sha": "93d1ce8629b0e2302b1c5d925c44d872f74cf2e5", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, walk_expr};\n use utils::{paths, match_path, span_lint};\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n use syntax::codemap::Span;\n use std::collections::{HashSet, HashMap};\n@@ -63,9 +63,9 @@ impl LintPass for Clippy {\n \n impl EarlyLintPass for Clippy {\n     fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n-        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n+        if let Some(utils) = krate.module.items.iter().find(|item| item.ident.name == \"utils\") {\n             if let ItemKind::Mod(ref utils_mod) = utils.node {\n-                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n+                if let Some(paths) = utils_mod.items.iter().find(|item| item.ident.name == \"paths\") {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<InternedString> = None;\n                         for item in &paths_mod.items {\n@@ -109,7 +109,7 @@ impl LateLintPass for LintWithoutLintPass {\n         if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n-            } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name.as_str() == \"ARRAY\" {\n+            } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n                 let mut collector = LintCollector { output: &mut self.registered_lints };\n                 collector.visit_expr(expr);\n             }"}, {"sha": "d8458c3bbcfc426eff53b8ffe6ccb07c17c45cf0", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -129,10 +129,10 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n ///\n /// See also the `paths` module.\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n-    use syntax::parse::token;\n+    use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n-        names: Vec<token::InternedString>,\n+        names: Vec<symbol::InternedString>,\n     }\n \n     impl ty::item_path::ItemPathBuffer for AbsolutePathBuffer {\n@@ -142,15 +142,16 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n         }\n \n         fn push(&mut self, text: &str) {\n-            self.names.push(token::intern(text).as_str());\n+            self.names.push(symbol::Symbol::intern(text).as_str());\n         }\n     }\n \n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n     cx.tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names == path\n+    apb.names.len() == path.len() &&\n+    apb.names.iter().zip(path.iter()).all(|(a, &b)| &**a == b)\n }\n \n /// Check if type is struct, enum or union type with given def path.\n@@ -202,7 +203,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g.\n@@ -212,7 +213,7 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name == *b)\n }\n \n /// Get the definition associated to a path.\n@@ -234,7 +235,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n             };\n \n             for item in &mem::replace(&mut items, vec![]) {\n-                if item.name.as_str() == *segment {\n+                if item.name == *segment {\n                     if path_it.peek().is_none() {\n                         return Some(item.def);\n                     }\n@@ -297,7 +298,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n         if let ExprMethodCall(ref name, _, ref args) = current.node {\n-            if name.node.as_str() == *method_name {\n+            if name.node == *method_name {\n                 matched.push(args); // build up `matched` backwards\n                 current = &args[0] // go to parent expression\n             } else {\n@@ -580,13 +581,13 @@ impl LimitStack {\n \n fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n     for attr in attrs {\n-        if attr.node.is_sugared_doc {\n+        if attr.is_sugared_doc {\n             continue;\n         }\n-        if let ast::MetaItemKind::NameValue(ref key, ref value) = attr.node.value.node {\n-            if *key == name {\n+        if let ast::MetaItemKind::NameValue(ref value) = attr.value.node {\n+            if attr.name() == name {\n                 if let LitKind::Str(ref s, _) = value.node {\n-                    if let Ok(value) = FromStr::from_str(s) {\n+                    if let Ok(value) = FromStr::from_str(&*s.as_str()) {\n                         attr::mark_used(attr);\n                         f(value)\n                     } else {\n@@ -610,7 +611,7 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n                                .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n         match span_name_span {\n-            Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),\n+            Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n             None => return None,\n             Some((_, new_span)) => span = new_span,\n         }\n@@ -631,7 +632,7 @@ pub fn is_direct_expn_of(cx: &LateContext, span: Span, name: &str) -> Option<Spa\n                            .with_expn_info(span.expn_id, |expn| expn.map(|ei| (ei.callee.name(), ei.call_site)));\n \n     match span_name_span {\n-        Some((mac_name, new_span)) if mac_name.as_str() == name => Some(new_span),\n+        Some((mac_name, new_span)) if mac_name == name => Some(new_span),\n         _ => None,\n     }\n }"}, {"sha": "899eb45a73da6e12982346a9da7ee5ce909a7358", "filename": "tests/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7de0d01fb328d1bf0760477f2e29c24bc50e18/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=0b7de0d01fb328d1bf0760477f2e29c24bc50e18", "patch": "@@ -11,7 +11,7 @@ use rustc_const_math::ConstInt;\n use rustc::hir::*;\n use syntax::ast::{LitIntType, LitKind, NodeId, StrStyle};\n use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax::util::ThinVec;\n \n@@ -55,7 +55,7 @@ fn test_lit() {\n     check(FALSE, &lit(LitKind::Bool(false)));\n     check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n     check(Constant::Str(\"cool!\".into(), StrStyle::Cooked),\n-          &lit(LitKind::Str(InternedString::new(\"cool!\"), StrStyle::Cooked)));\n+          &lit(LitKind::Str(Symbol::intern(\"cool!\"), StrStyle::Cooked)));\n }\n \n #[test]"}]}