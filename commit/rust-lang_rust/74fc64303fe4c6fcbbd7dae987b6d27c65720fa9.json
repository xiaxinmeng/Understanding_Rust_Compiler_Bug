{"sha": "74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZmM2NDMwM2ZlNGM2ZmNiYmQ3ZGFlOTg3YjZkMjdjNjU3MjBmYTk=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-02-24T04:39:33Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-03-14T23:42:00Z"}, "message": "Only borrow place for matching under specific conditions", "tree": {"sha": "735d12404f2811d7d26032f3b9e73cf7f91bc4be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/735d12404f2811d7d26032f3b9e73cf7f91bc4be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "html_url": "https://github.com/rust-lang/rust/commit/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "url": "https://api.github.com/repos/rust-lang/rust/commits/685a4c6b6b6016fa0c4b1ae4af745103add0bb02", "html_url": "https://github.com/rust-lang/rust/commit/685a4c6b6b6016fa0c4b1ae4af745103add0bb02"}], "stats": {"total": 242, "additions": 193, "deletions": 49}, "files": [{"sha": "0e70cd36efba88ac7fc3e711d154c8170ffd09cf", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -100,7 +100,7 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 // single and multiple variants.\n                 // For single variants, enums are not captured completely.\n                 // We keep track of VariantIdx so we can use this information\n-                // if the next ProjectionElem is a Field\n+                // if the next ProjectionElem is a Field.\n                 variant = Some(*idx);\n                 continue;\n             }"}, {"sha": "47f75825fb6af61dcc202effc3f940ae2ddd7be4", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -420,6 +420,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n@@ -436,6 +437,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n \n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n                 let place = unpack!(block = this.as_place(block, expr));\n                 let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);"}, {"sha": "3ad143a57ff561525ae39ef06d457a5bf97b8990", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n             if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n-                &*match_pairs.clone()\n+                &*match_pairs\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n                 mem::swap(&mut candidate.bindings, &mut existing_bindings);\n@@ -155,12 +155,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                // value being matched, taking the variance field into account.\n-                let place = match_pair.place.clone().into_place(self.tcx, self.typeck_results);\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n                     user_ty,\n-                    source: place,\n+                    source: match_pair.place.clone().into_place(self.tcx, self.typeck_results),\n                     variance,\n                 });\n \n@@ -175,12 +173,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Binding { name, mutability, mode, var, ty, ref subpattern, is_primary: _ } => {\n-                let place = match_pair.place.clone().into_place(self.tcx, self.typeck_results);\n                 candidate.bindings.push(Binding {\n                     name,\n                     mutability,\n                     span: match_pair.pattern.span,\n-                    source: place,\n+                    source: match_pair.place.clone().into_place(self.tcx, self.typeck_results),\n                     var_id: var,\n                     var_ty: ty,\n                     binding_mode: mode,"}, {"sha": "dee69793f2a80f33fb99a7b45b2959561cdba73e", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -455,32 +455,18 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                 );\n \n                 let fake_reads = match self.typeck_results().closure_fake_reads.get(&def_id) {\n-                    Some(vals) => {\n-                        Some(\n-                            vals.iter()\n-                                .map(|(place, cause)| {\n-                                    (\n-                                        self.arena.alloc(\n-                                            self.convert_captured_hir_place(expr, place.clone()),\n-                                        ),\n-                                        *cause,\n-                                    )\n-                                    // let var_hir_id = match val.base {\n-                                    //     HirPlaceBase::Upvar(upvar_id) => {\n-                                    //         debug!(\"upvar\");\n-                                    //         upvar_id.var_path.hir_id\n-                                    //     }\n-                                    //     _ => {\n-                                    //         bug!(\n-                                    //             \"Do not know how to get HirId out of Rvalue and StaticItem\"\n-                                    //         );\n-                                    //     }\n-                                    // };\n-                                    // self.fake_read_capture_upvar(expr, val.clone(), var_hir_id)\n-                                })\n-                                .collect(),\n-                        )\n-                    }\n+                    Some(vals) => Some(\n+                        vals.iter()\n+                            .map(|(place, cause)| {\n+                                (\n+                                    self.arena.alloc(\n+                                        self.convert_captured_hir_place(expr, place.clone()),\n+                                    ),\n+                                    *cause,\n+                                )\n+                            })\n+                            .collect(),\n+                    ),\n                     None => None,\n                 };\n \n@@ -1058,6 +1044,11 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n         let temp_lifetime = self.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n         let var_ty = place.base_ty;\n \n+        // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+        // as it's seen for use within the closure and not at the time of closure creation.\n+        //\n+        // That is we see expect to see it start from a captured upvar and not something that is local\n+        // to the closure's parent.\n         let var_hir_id = match place.base {\n             HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n             base => bug!(\"Expected an upvar, found {:?}\", base),"}, {"sha": "0172f993c266c47efc77e0df360e98c3a264de5f", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -8,10 +8,10 @@ pub use self::ConsumeMode::*;\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n-use rustc_hir::QPath;\n+//use rustc_hir::QPath;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n@@ -54,7 +54,6 @@ pub trait Delegate<'tcx> {\n     // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    // [FIXME] RFC2229 This should also affect clippy ref: https://github.com/sexxi-goose/rust/pull/27\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause);\n }\n \n@@ -235,24 +234,30 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n \n+                // Matching should not always be considered a use of the place, hence\n+                // discr does not necessarily need to be borrowed.\n                 // We only want to borrow discr if the pattern contain something other\n-                // than wildcards\n+                // than wildcards.\n                 let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n                 let mut needs_to_be_read = false;\n                 for arm in arms.iter() {\n                     return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |_place, pat| {\n-                        if let PatKind::Binding(_, _, _, opt_sub_pat) = pat.kind {\n-                            if let None = opt_sub_pat {\n-                                needs_to_be_read = true;\n-                            }\n-                        } else if let PatKind::TupleStruct(qpath, _, _) = &pat.kind {\n-                            // If a TupleStruct has a Some PathSegment, we should read the discr_place\n-                            // regardless if it contains a Wild pattern later\n-                            if let QPath::Resolved(_, path) = qpath {\n-                                if let Res::Def(DefKind::Ctor(_, _), _) = path.res {\n+                        match &pat.kind {\n+                            PatKind::Binding(_, _, _, opt_sub_pat) => {\n+                                // If the opt_sub_pat is None, than the binding does not count as\n+                                // a wildcard for the purpose of borrowing discr\n+                                if let None = opt_sub_pat {\n                                     needs_to_be_read = true;\n                                 }\n                             }\n+                            PatKind::TupleStruct(_, _, _)\n+                            | PatKind::Struct(_, _, _)\n+                            | PatKind::Lit(_) => {\n+                                // If the PatKind is a TupleStruct, Struct, or Lit then we want\n+                                // to borrow discr\n+                                needs_to_be_read = true;\n+                            }\n+                            _ => {}\n                         }\n                     }));\n                 }\n@@ -629,6 +634,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+        debug!(\"walk_captures({:?})\", closure_expr);\n+\n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n         let upvars = self.tcx().upvars_mentioned(self.body_owner);\n \n@@ -645,10 +652,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         if upvars.map_or(body_owner_is_closure, |upvars| {\n                             !upvars.contains_key(&upvar_id.var_path.hir_id)\n                         }) {\n-                            // [FIXME] RFC2229 Update this comment\n-                            // The nested closure might be capturing the current (enclosing) closure's local variables.\n+                            // The nested closure might be fake reading the current (enclosing) closure's local variables.\n                             // We check if the root variable is ever mentioned within the enclosing closure, if not\n-                            // then for the current body (if it's a closure) these aren't captures, we will ignore them.\n+                            // then for the current body (if it's a closure) these do not require fake_read, we will ignore them.\n                             continue;\n                         }\n                     }"}, {"sha": "97b56e7c4be2234694280d82d8c26fd7adf80b5f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,24 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+#![feature(rustc_attrs)]\n+#![feature(btree_drain_filter)]\n+\n+use std::collections::BTreeMap;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+\n+fn main() {\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", ());\n+    map.insert(\"b\", ());\n+    map.insert(\"c\", ());\n+\n+    {\n+        let mut it = map.drain_filter(|_, _| true);\n+        catch_unwind(AssertUnwindSafe(|| while it.next().is_some() {})).unwrap_err();\n+        let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+        assert!(matches!(result, Ok(None)));\n+    }\n+\n+}"}, {"sha": "bc046ecad6867d20142d8d0cd6b660d47a24a18b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.stderr?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/lit-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2f13590a2bdab6e8ef017fcd0f2f556b98e647c7", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct-pattern-matching-with-methods.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,48 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![warn(unused)]\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug, Clone, Copy)]\n+enum PointType {\n+    TwoD { x: u32, y: u32 },\n+\n+    ThreeD{ x: u32, y: u32, z: u32 }\n+}\n+\n+struct Points {\n+    points: Vec<PointType>,\n+}\n+\n+impl Points {\n+    pub fn test1(&mut self) -> Vec<usize> {\n+        (0..self.points.len())\n+            .filter_map(|i| {\n+                let idx = i as usize;\n+                match self.test2(idx) {\n+                    PointType::TwoD { .. } => Some(i),\n+                    PointType::ThreeD { .. } => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    pub fn test2(&mut self, i: usize) -> PointType {\n+        self.points[i]\n+    }\n+}\n+\n+fn main() {\n+    let mut points = Points {\n+        points: Vec::<PointType>::new()\n+    };\n+\n+    points.points.push(PointType::ThreeD { x:0, y:0, z:0 });\n+    points.points.push(PointType::TwoD{ x:0, y:0 });\n+    points.points.push(PointType::ThreeD{ x:0, y:0, z:0 });\n+    points.points.push(PointType::TwoD{ x:0, y:0 });\n+\n+    println!(\"{:?}\", points.test1());\n+    println!(\"{:?}\", points.points);\n+}"}, {"sha": "3e4303a3710df961c03aaa85fbc494f7d77c8a66", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.stderr?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/struct-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "0948039287b2cc71bf8be6637b2524afc88089c2", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/tuple-struct-pattern-matching-with-methods.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,43 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Copy, Clone)]\n+enum PointType {\n+    TwoD(u32, u32),\n+    ThreeD(u32, u32, u32)\n+}\n+\n+struct Points {\n+    points: Vec<PointType>,\n+}\n+\n+impl Points {\n+    pub fn test1(&mut self) -> Vec<usize> {\n+        (0..self.points.len())\n+            .filter_map(|i| {\n+                match self.test2(i) {\n+                    PointType::TwoD (..) => Some(i),\n+                    PointType::ThreeD (..) => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    pub fn test2(&mut self, i: usize) -> PointType {\n+        self.points[i]\n+    }\n+}\n+\n+fn main() {\n+    let mut points = Points {\n+        points: Vec::<PointType>::new()\n+    };\n+\n+    points.points.push(PointType::ThreeD(0,0,0));\n+    points.points.push(PointType::TwoD(0,0));\n+    points.points.push(PointType::ThreeD(0,0,1));\n+    points.points.push(PointType::TwoD(0,1));\n+\n+    println!(\"{:?}\", points.test1());\n+}"}, {"sha": "ded0e37b0f366eea3303cdd6440cab14bb53f73f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/tuple-struct-pattern-matching-with-methods.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74fc64303fe4c6fcbbd7dae987b6d27c65720fa9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.stderr?ref=74fc64303fe4c6fcbbd7dae987b6d27c65720fa9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/tuple-struct-pattern-matching-with-methods.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}]}