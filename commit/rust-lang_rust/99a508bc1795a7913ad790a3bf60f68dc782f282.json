{"sha": "99a508bc1795a7913ad790a3bf60f68dc782f282", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YTUwOGJjMTc5NWE3OTEzYWQ3OTBhM2JmNjBmNjhkYzc4MmYyODI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-17T10:24:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-17T10:24:11Z"}, "message": "Check that predicates hold before emitting an entry for the vtable.\nFixes #23435.", "tree": {"sha": "bb87a27f860fafb94e59c160b7ade43ac701eec9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb87a27f860fafb94e59c160b7ade43ac701eec9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99a508bc1795a7913ad790a3bf60f68dc782f282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99a508bc1795a7913ad790a3bf60f68dc782f282", "html_url": "https://github.com/rust-lang/rust/commit/99a508bc1795a7913ad790a3bf60f68dc782f282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99a508bc1795a7913ad790a3bf60f68dc782f282/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b65c9e2b42d663bca64c935350d6e96f0b9c4e", "html_url": "https://github.com/rust-lang/rust/commit/88b65c9e2b42d663bca64c935350d6e96f0b9c4e"}], "stats": {"total": 116, "additions": 100, "deletions": 16}, "files": [{"sha": "f4d40e265421523fc42cf0de8f9ce89f898a1940", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=99a508bc1795a7913ad790a3bf60f68dc782f282", "patch": "@@ -1053,10 +1053,11 @@ impl<'tcx> Repr<'tcx> for ty::Variance {\n \n impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"method(name: {}, generics: {}, fty: {}, \\\n+        format!(\"method(name: {}, generics: {}, predicates: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n                 self.generics.repr(tcx),\n+                self.predicates.repr(tcx),\n                 self.fty.repr(tcx),\n                 self.explicit_self.repr(tcx),\n                 self.vis.repr(tcx),"}, {"sha": "9be1d3eb901ca6516e2f699bd0c0cd4c8578cfce", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=99a508bc1795a7913ad790a3bf60f68dc782f282", "patch": "@@ -46,6 +46,7 @@ use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n+use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n@@ -1006,9 +1007,9 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) ->\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n+                                    span: Span,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n \n@@ -1067,7 +1068,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let vtable = selection.map_move_nested(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n-    let vtable = drain_fulfillment_cx(span, &infcx, &mut fulfill_cx, &vtable);\n+    let vtable = drain_fulfillment_cx_or_panic(span, &infcx, &mut fulfill_cx, &vtable);\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,\n@@ -1076,6 +1077,22 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n+pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 predicates: Vec<ty::Predicate<'tcx>>)\n+                                 -> bool\n+{\n+    debug!(\"predicates_hold(predicates={})\",\n+           predicates.repr(ccx.tcx()));\n+\n+    let infcx = infer::new_infer_ctxt(ccx.tcx());\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    for predicate in predicates {\n+        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n+        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+    drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &()).is_ok()\n+}\n+\n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n     param_env: ty::ParameterEnvironment<'a, 'tcx>\n }\n@@ -1123,11 +1140,36 @@ impl<'a,'tcx> ty::ClosureTyper<'tcx> for NormalizingClosureTyper<'a,'tcx> {\n     }\n }\n \n+pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n+                                                infcx: &infer::InferCtxt<'a,'tcx>,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    match drain_fulfillment_cx(span, infcx, fulfill_cx, result) {\n+        Ok(v) => v,\n+        Err(errors) => {\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                         errors.repr(infcx.tcx)));\n+        }\n+    }\n+}\n+\n+/// Finishes processes any obligations that remain in the fulfillment\n+/// context, and then \"freshens\" and returns `result`. This is\n+/// primarily used during normalization and other cases where\n+/// processing the obligations in `fulfill_cx` may cause type\n+/// inference variables that appear in `result` to be unified, and\n+/// hence we need to process those obligations to get the complete\n+/// picture of the type.\n pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n-                                   infcx: &infer::InferCtxt<'a,'tcx>,\n-                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                   result: &T)\n-                                   -> T\n+                                       infcx: &infer::InferCtxt<'a,'tcx>,\n+                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                       result: &T)\n+                                       -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     debug!(\"drain_fulfillment_cx(result={})\",\n@@ -1140,16 +1182,13 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n+            // We always want to surface any overflow errors, no matter what.\n             if errors.iter().all(|e| e.is_overflow()) {\n-                // See Ok(None) case above.\n                 infcx.tcx.sess.span_fatal(\n                     span,\n                     \"reached the recursion limit during monomorphization\");\n             } else {\n-                infcx.tcx.sess.span_bug(\n-                    span,\n-                    &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx)));\n+                return Err(errors);\n             }\n         }\n     }\n@@ -1159,7 +1198,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     // sort of overkill because we do not expect there to be any\n     // unbound type variables, hence no `TyFresh` types should ever be\n     // inserted.\n-    result.fold_with(&mut infcx.freshener())\n+    Ok(result.fold_with(&mut infcx.freshener()))\n }\n \n // Key used to lookup values supplied for type parameters in an expr."}, {"sha": "735a7162f041a51ab56134a17e13a07ea7947bf0", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=99a508bc1795a7913ad790a3bf60f68dc782f282", "patch": "@@ -842,6 +842,15 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 return nullptr;\n             }\n \n+            let predicates =\n+                monomorphize::apply_param_substs(tcx,\n+                                                 &substs,\n+                                                 &impl_method_type.predicates.predicates);\n+            if !predicates_hold(ccx, predicates.into_vec()) {\n+                debug!(\"emit_vtable_methods: predicates do not hold\");\n+                return nullptr;\n+            }\n+\n             trans_fn_ref_with_substs(ccx,\n                                      impl_method_def_id,\n                                      ExprId(0),"}, {"sha": "dcb21c5cd93b1459ba2a06d45b55088a8462e15d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=99a508bc1795a7913ad790a3bf60f68dc782f282", "patch": "@@ -339,7 +339,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    let result = drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n+    let result = drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result);\n \n     result\n }"}, {"sha": "dad7d0675d62759589c85814fecd879de32ad380", "filename": "src/test/run-pass/issue-23435.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Ftest%2Frun-pass%2Fissue-23435.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a508bc1795a7913ad790a3bf60f68dc782f282/src%2Ftest%2Frun-pass%2Fissue-23435.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23435.rs?ref=99a508bc1795a7913ad790a3bf60f68dc782f282", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not ICE when a default method implementation has\n+// requirements (in this case, `Self : Baz`) that do not hold for some\n+// specific impl (in this case, `Foo : Bar`). This causes problems\n+// only when building a vtable, because that goes along and\n+// instantiates all the methods, even those that could not otherwise\n+// be called.\n+\n+struct Foo {\n+    x: i32\n+}\n+\n+trait Bar {\n+    fn bar(&self) where Self : Baz { self.baz(); }\n+}\n+\n+trait Baz {\n+    fn baz(&self);\n+}\n+\n+impl Bar for Foo {\n+}\n+\n+fn main() {\n+    let x: &Bar = &Foo { x: 22 };\n+}"}]}