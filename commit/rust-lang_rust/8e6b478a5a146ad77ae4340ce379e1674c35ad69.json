{"sha": "8e6b478a5a146ad77ae4340ce379e1674c35ad69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNmI0NzhhNWExNDZhZDc3YWU0MzQwY2UzNzllMTY3NGMzNWFkNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-05T23:40:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-05T23:40:18Z"}, "message": "Auto merge of #83905 - JohnTitor:rollup-pa1la80, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #83370 (Add `x.py setup tools` which enables `download-rustc` by default)\n - #83489 (Properly suggest deref in else block)\n - #83734 (Catch a bad placeholder type error for statics in `extern`s)\n - #83814 (expand: Do not ICE when a legacy AST-based macro attribute produces and empty expression)\n - #83835 (rustdoc: sort search index items for compression)\n - #83849 (rustdoc: Cleanup handling of associated items for intra-doc links)\n - #83881 (:arrow_up: rust-analyzer)\n - #83885 (Document compiler/ with -Aprivate-intra-doc-links)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b564f944ecaedceaf64f15a7804ecefb3c221aa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b564f944ecaedceaf64f15a7804ecefb3c221aa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e6b478a5a146ad77ae4340ce379e1674c35ad69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6b478a5a146ad77ae4340ce379e1674c35ad69", "html_url": "https://github.com/rust-lang/rust/commit/8e6b478a5a146ad77ae4340ce379e1674c35ad69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e6b478a5a146ad77ae4340ce379e1674c35ad69/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32238532138485c80db4f2cd596372bce214e00", "url": "https://api.github.com/repos/rust-lang/rust/commits/d32238532138485c80db4f2cd596372bce214e00", "html_url": "https://github.com/rust-lang/rust/commit/d32238532138485c80db4f2cd596372bce214e00"}, {"sha": "d8c04b13a2a6eaba375bb79c1bda7ec78f820e7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c04b13a2a6eaba375bb79c1bda7ec78f820e7e", "html_url": "https://github.com/rust-lang/rust/commit/d8c04b13a2a6eaba375bb79c1bda7ec78f820e7e"}], "stats": {"total": 559, "additions": 367, "deletions": 192}, "files": [{"sha": "282877d5dd10962f9c7be3e66e0e96189d9529fc", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -45,9 +45,6 @@ macro_rules! forward {\n         pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)?) -> &Self\n     ) => {\n         $(#[$attrs])*\n-        // we always document with --document-private-items\n-        #[cfg_attr(not(bootstrap), allow(rustdoc::private_intra_doc_links))]\n-        #[cfg_attr(bootstrap, allow(private_intra_doc_links))]\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n             self.diagnostic.$n($($name),*);\n@@ -62,9 +59,6 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n-        // we always document with --document-private-items\n-        #[cfg_attr(not(bootstrap), allow(rustdoc::private_intra_doc_links))]\n-        #[cfg_attr(bootstrap, allow(private_intra_doc_links))]\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n@@ -82,9 +76,6 @@ macro_rules! forward {\n     ) => {\n         $(#[$attrs])*\n         #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n-        // we always document with --document-private-items\n-        #[cfg_attr(not(bootstrap), allow(rustdoc::private_intra_doc_links))]\n-        #[cfg_attr(bootstrap, allow(private_intra_doc_links))]\n         pub fn $n<$($generic: $bound),*>(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self"}, {"sha": "b732e4493742b4f0dbbc6b8f4c3044570d43f2c4", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -735,7 +735,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                     });\n                                 }\n                             };\n-                            fragment_kind.expect_from_annotatables(items)\n+                            if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n+                                let msg =\n+                                    \"removing an expression is not supported in this position\";\n+                                self.cx.span_err(span, msg);\n+                                fragment_kind.dummy(span)\n+                            } else {\n+                                fragment_kind.expect_from_annotatables(items)\n+                            }\n                         }\n                         Err(mut err) => {\n                             err.emit();"}, {"sha": "1c5f8996e1b454ecf419ab27f9f315c67a26470e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -18,6 +18,7 @@\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n+#![allow(rustdoc::private_intra_doc_links)]\n \n pub use rustc_hir::def::{Namespace, PerNS};\n "}, {"sha": "d879b6e97dcfb884098a9915144e3167bd50c90b", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -366,6 +366,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// If the given `HirId` corresponds to a block with a trailing expression, return that expression\n+    crate fn maybe_get_block_expr(&self, hir_id: hir::HirId) -> Option<&'tcx hir::Expr<'tcx>> {\n+        match self.tcx.hir().find(hir_id)? {\n+            Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, ..), .. }) => block.expr,\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns whether the given expression is an `else if`.\n+    crate fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n+        if let hir::ExprKind::If(..) = expr.kind {\n+            let parent_id = self.tcx.hir().get_parent_node(expr.hir_id);\n+            if let Some(Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::If(_, _, Some(else_expr)),\n+                ..\n+            })) = self.tcx.hir().find(parent_id)\n+            {\n+                return else_expr.hir_id == expr.hir_id;\n+            }\n+        }\n+        false\n+    }\n+\n     /// This function is used to determine potential \"simple\" improvements or users' errors and\n     /// provide them useful help. For example:\n     ///\n@@ -652,6 +675,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 };\n                                 let suggestion = if is_struct_pat_shorthand_field {\n                                     format!(\"{}: *{}\", code, code)\n+                                } else if self.is_else_if_block(expr) {\n+                                    // Don't suggest nonsense like `else *if`\n+                                    return None;\n+                                } else if let Some(expr) = self.maybe_get_block_expr(expr.hir_id) {\n+                                    format!(\"*{}\", sm.span_to_snippet(expr.span).unwrap_or(code))\n                                 } else {\n                                     format!(\"*{}\", code)\n                                 };"}, {"sha": "53dc79106de2ec9816e0c99ee850f21b78d994a5", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -734,8 +734,14 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 tcx.ensure().generics_of(item.def_id);\n                 tcx.ensure().type_of(item.def_id);\n                 tcx.ensure().predicates_of(item.def_id);\n-                if let hir::ForeignItemKind::Fn(..) = item.kind {\n-                    tcx.ensure().fn_sig(item.def_id);\n+                match item.kind {\n+                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.def_id),\n+                    hir::ForeignItemKind::Static(..) => {\n+                        let mut visitor = PlaceholderHirTyCollector::default();\n+                        visitor.visit_foreign_item(item);\n+                        placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n+                    }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "883bfead64e4afc7d087ea2aa74c20cf6a1bfaf8", "filename": "src/bootstrap/defaults/config.compiler.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -8,6 +8,5 @@ debug-logging = true\n incremental = true\n \n [llvm]\n-# Will download LLVM from CI if available on your platform (Linux only for now)\n-# https://github.com/rust-lang/rust/issues/77084 tracks support for more platforms\n+# Will download LLVM from CI if available on your platform.\n download-ci-llvm = \"if-available\""}, {"sha": "182fb0fb0675c1887b22746ed5038450396f9cbf", "filename": "src/bootstrap/defaults/config.tools.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.tools.toml?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -0,0 +1,16 @@\n+# These defaults are meant for contributors to tools which build on the\n+# compiler, but do not modify it directly.\n+[rust]\n+# This enables `RUSTC_LOG=debug`, avoiding confusing situations\n+# where adding `debug!()` appears to do nothing.\n+# However, it makes running the compiler slightly slower.\n+debug-logging = true\n+# This greatly increases the speed of rebuilds, especially when there are only minor changes. However, it makes the initial build slightly slower.\n+incremental = true\n+# Download rustc from CI instead of building it from source.\n+# This cuts compile times by almost 60x, but means you can't modify the compiler.\n+download-rustc = \"if-unchanged\"\n+\n+[llvm]\n+# Will download LLVM from CI if available on your platform.\n+download-ci-llvm = \"if-available\""}, {"sha": "f499f1a684d1d56a7d5cd370265dbd7b1db6273d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -549,6 +549,8 @@ impl Step for Rustc {\n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, SourceType::InTree, target, \"doc\");\n         cargo.rustdocflag(\"--document-private-items\");\n+        // Since we always pass --document-private-items, there's no need to warn about linking to private items.\n+        cargo.rustdocflag(\"-Arustdoc::private-intra-doc-links\");\n         cargo.rustdocflag(\"--enable-index-page\");\n         cargo.rustdocflag(\"-Zunstable-options\");\n         cargo.rustdocflag(\"-Znormalize-docs\");"}, {"sha": "a5829dfa9d87905192b6331a780e2f397d519431", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -13,6 +13,7 @@ pub enum Profile {\n     Compiler,\n     Codegen,\n     Library,\n+    Tools,\n     User,\n }\n \n@@ -24,15 +25,16 @@ impl Profile {\n     pub fn all() -> impl Iterator<Item = Self> {\n         use Profile::*;\n         // N.B. these are ordered by how they are displayed, not alphabetically\n-        [Library, Compiler, Codegen, User].iter().copied()\n+        [Library, Compiler, Codegen, Tools, User].iter().copied()\n     }\n \n     pub fn purpose(&self) -> String {\n         use Profile::*;\n         match self {\n             Library => \"Contribute to the standard library\",\n-            Compiler => \"Contribute to the compiler or rustdoc\",\n+            Compiler => \"Contribute to the compiler itself\",\n             Codegen => \"Contribute to the compiler, and also modify LLVM or codegen\",\n+            Tools => \"Contribute to tools which depend on the compiler, but do not modify it directly (e.g. rustdoc, clippy, miri)\",\n             User => \"Install Rust from source\",\n         }\n         .to_string()\n@@ -53,9 +55,12 @@ impl FromStr for Profile {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         match s {\n             \"lib\" | \"library\" => Ok(Profile::Library),\n-            \"compiler\" | \"rustdoc\" => Ok(Profile::Compiler),\n+            \"compiler\" => Ok(Profile::Compiler),\n             \"llvm\" | \"codegen\" => Ok(Profile::Codegen),\n             \"maintainer\" | \"user\" => Ok(Profile::User),\n+            \"tools\" | \"tool\" | \"rustdoc\" | \"clippy\" | \"miri\" | \"rustfmt\" | \"rls\" => {\n+                Ok(Profile::Tools)\n+            }\n             _ => Err(format!(\"unknown profile: '{}'\", s)),\n         }\n     }\n@@ -68,6 +73,7 @@ impl fmt::Display for Profile {\n             Profile::Codegen => write!(f, \"codegen\"),\n             Profile::Library => write!(f, \"library\"),\n             Profile::User => write!(f, \"user\"),\n+            Profile::Tools => write!(f, \"tools\"),\n         }\n     }\n }\n@@ -103,6 +109,14 @@ pub fn setup(src_path: &Path, profile: Profile) {\n \n     let suggestions = match profile {\n         Profile::Codegen | Profile::Compiler => &[\"check\", \"build\", \"test\"][..],\n+        Profile::Tools => &[\n+            \"check\",\n+            \"build\",\n+            \"test src/test/rustdoc*\",\n+            \"test src/tools/clippy\",\n+            \"test src/tools/miri\",\n+            \"test src/tools/rustfmt\",\n+        ],\n         Profile::Library => &[\"check\", \"build\", \"test library/std\", \"doc\"],\n         Profile::User => &[\"dist\", \"build\"],\n     };"}, {"sha": "77559ce0204268cd97c5eea18a5b575b1113b712", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -914,7 +914,7 @@ impl Attributes {\n             .collect()\n     }\n \n-    crate fn get_doc_aliases(&self) -> FxHashSet<String> {\n+    crate fn get_doc_aliases(&self) -> Box<[String]> {\n         let mut aliases = FxHashSet::default();\n \n         for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n@@ -931,7 +931,7 @@ impl Attributes {\n                 aliases.insert(attr.value_str().map(|s| s.to_string()).unwrap());\n             }\n         }\n-        aliases\n+        aliases.into_iter().collect::<Vec<String>>().into()\n     }\n }\n "}, {"sha": "0a59bae941edf0a51d590923d24a594713001a4d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -120,10 +120,6 @@ crate struct Cache {\n     // when gathering trait documentation on a type, hold impls here while\n     // folding and add them to the cache later on if we find the trait.\n     orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    crate aliases: BTreeMap<String, Vec<usize>>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n@@ -309,15 +305,8 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item, &self.empty_cache, self.tcx),\n+                            aliases: item.attrs.get_doc_aliases(),\n                         });\n-\n-                        for alias in item.attrs.get_doc_aliases() {\n-                            self.cache\n-                                .aliases\n-                                .entry(alias.to_lowercase())\n-                                .or_insert(Vec::new())\n-                                .push(self.cache.search_index.len() - 1);\n-                        }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {"}, {"sha": "2265905dcbaf41d5a0e7d212380af1948a8b2728", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -82,18 +82,31 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item, cache, tcx),\n+                aliases: item.attrs.get_doc_aliases(),\n             });\n-            for alias in item.attrs.get_doc_aliases() {\n-                cache\n-                    .aliases\n-                    .entry(alias.to_lowercase())\n-                    .or_insert(Vec::new())\n-                    .push(cache.search_index.len() - 1);\n-            }\n         }\n     }\n \n-    let Cache { ref mut search_index, ref paths, ref mut aliases, .. } = *cache;\n+    let Cache { ref mut search_index, ref paths, .. } = *cache;\n+\n+    // Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    // we need the alias element to have an array of items.\n+    let mut aliases: BTreeMap<String, Vec<usize>> = BTreeMap::new();\n+\n+    // Sort search index items. This improves the compressibility of the search index.\n+    search_index.sort_unstable_by(|k1, k2| {\n+        // `sort_unstable_by_key` produces lifetime errors\n+        let k1 = (&k1.path, &k1.name, &k1.ty, &k1.parent);\n+        let k2 = (&k2.path, &k2.name, &k2.ty, &k2.parent);\n+        std::cmp::Ord::cmp(&k1, &k2)\n+    });\n+\n+    // Set up alias indexes.\n+    for (i, item) in search_index.iter().enumerate() {\n+        for alias in &item.aliases[..] {\n+            aliases.entry(alias.to_lowercase()).or_insert(Vec::new()).push(i);\n+        }\n+    }\n \n     // Reduce `DefId` in paths into smaller sequential numbers,\n     // and prune the paths that do not appear in the index.\n@@ -201,7 +214,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n             doc: crate_doc,\n             items: crate_items,\n             paths: crate_paths,\n-            aliases,\n+            aliases: &aliases,\n         })\n         .expect(\"failed serde conversion\")\n         // All these `replace` calls are because we have to go through JS string for JSON content."}, {"sha": "fb433bf8a8dc4c9eeb23a12f17dbf73cd7ca38aa", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -164,6 +164,7 @@ crate struct IndexItem {\n     crate parent: Option<DefId>,\n     crate parent_idx: Option<usize>,\n     crate search_type: Option<IndexItemFunctionType>,\n+    crate aliases: Box<[String]>,\n }\n \n /// A type used for the search index."}, {"sha": "39912a136ab2213e470394b22f8e3ef9a6c39009", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 102, "deletions": 135, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -368,55 +368,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Given a primitive type, try to resolve an associated item.\n-    ///\n-    /// HACK(jynelson): `item_str` is passed in instead of derived from `item_name` so the\n-    /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n-        module_id: DefId,\n         item_name: Symbol,\n-        item_str: &'path str,\n-    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty\n-            .impls(tcx)\n-            .into_iter()\n-            .find_map(|&impl_| {\n-                tcx.associated_items(impl_)\n-                    .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n-                    .map(|item| {\n-                        let kind = item.kind;\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), item.def_id)));\n-                        match kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        }\n-                    })\n-                    .map(|out| {\n-                        (\n-                            Res::Primitive(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_str)),\n-                        )\n-                    })\n-            })\n-            .ok_or_else(|| {\n-                debug!(\n-                    \"returning primitive error for {}::{} in {} namespace\",\n-                    prim_ty.as_str(),\n-                    item_name,\n-                    ns.descr()\n-                );\n-                ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(Res::Primitive(prim_ty)),\n-                    unresolved: item_str.into(),\n-                }\n-                .into()\n-            })\n+        prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n+            tcx.associated_items(impl_)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+                .map(|item| {\n+                    let kind = item.kind;\n+                    let out = match kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    };\n+                    let fragment = format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_name);\n+                    (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n+                })\n+        })\n     }\n \n     /// Resolves a string as a macro.\n@@ -490,8 +463,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let tcx = self.cx.tcx;\n-\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -534,29 +505,58 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n-        // FIXME: are these both necessary?\n-        let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n+        // FIXME(#83862): this arbitrarily gives precedence to primitives over modules to support\n+        // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n+        // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n+        // primitives.\n+        resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n-        {\n-            ty_res\n-        } else {\n-            // FIXME: this is duplicated on the end of this function.\n-            return if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: None,\n-                    unresolved: path_root.into(),\n+            .and_then(|ty_res| {\n+                let (res, fragment, side_channel) =\n+                    self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n+                let result = if extra_fragment.is_some() {\n+                    let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n+                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n+                } else {\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    if let Some((kind, id)) = side_channel {\n+                        self.kind_side_channel.set(Some((kind, id)));\n+                    }\n+                    Ok((res, Some(fragment)))\n+                };\n+                Some(result)\n+            })\n+            .unwrap_or_else(|| {\n+                if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, module_id)\n+                } else {\n+                    Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: None,\n+                        unresolved: path_root.into(),\n+                    }\n+                    .into())\n                 }\n-                .into())\n-            };\n-        };\n+            })\n+    }\n+\n+    /// Returns:\n+    /// - None if no associated item was found\n+    /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n+    /// - Some((_, _, None)) otherwise\n+    fn resolve_associated_item(\n+        &mut self,\n+        root_res: Res,\n+        item_name: Symbol,\n+        ns: Namespace,\n+        module_id: DefId,\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n+        let tcx = self.cx.tcx;\n \n-        let res = match ty_res {\n-            Res::Primitive(prim) => Some(\n-                self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n-            ),\n+        match root_res {\n+            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -599,59 +599,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n-                    Some(if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n-                    } else {\n-                        // HACK(jynelson): `clean` expects the type, not the associated item\n-                        // but the disambiguator logic expects the associated item.\n-                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_str))))\n-                    })\n-                } else if ns == Namespace::ValueNS {\n-                    debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n-                    // FIXME(jynelson): why is this different from\n-                    // `variant_field`?\n-                    match tcx.type_of(did).kind() {\n-                        ty::Adt(def, _) => {\n-                            let field = if def.is_enum() {\n-                                def.all_fields().find(|item| item.ident.name == item_name)\n-                            } else {\n-                                def.non_enum_variant()\n-                                    .fields\n-                                    .iter()\n-                                    .find(|item| item.ident.name == item_name)\n-                            };\n-                            field.map(|item| {\n-                                if extra_fragment.is_some() {\n-                                    let res = Res::Def(\n-                                        if def.is_enum() {\n-                                            DefKind::Variant\n-                                        } else {\n-                                            DefKind::Field\n-                                        },\n-                                        item.did,\n-                                    );\n-                                    Err(ErrorKind::AnchorFailure(\n-                                        AnchorFailure::RustdocAnchorConflict(res),\n-                                    ))\n-                                } else {\n-                                    Ok((\n-                                        ty_res,\n-                                        Some(format!(\n-                                            \"{}.{}\",\n-                                            if def.is_enum() { \"variant\" } else { \"structfield\" },\n-                                            item.ident\n-                                        )),\n-                                    ))\n-                                }\n-                            })\n-                        }\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    return Some((\n+                        root_res,\n+                        format!(\"{}.{}\", out, item_name),\n+                        Some((kind.as_def_kind(), id)),\n+                    ));\n+                }\n+\n+                if ns != Namespace::ValueNS {\n+                    return None;\n                 }\n+                debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n+                // NOTE: it's different from variant_field because it resolves fields and variants,\n+                // not variant fields (2 path segments, not 3).\n+                let def = match tcx.type_of(did).kind() {\n+                    ty::Adt(def, _) => def,\n+                    _ => return None,\n+                };\n+                let field = if def.is_enum() {\n+                    def.all_fields().find(|item| item.ident.name == item_name)\n+                } else {\n+                    def.non_enum_variant().fields.iter().find(|item| item.ident.name == item_name)\n+                }?;\n+                let kind = if def.is_enum() { DefKind::Variant } else { DefKind::Field };\n+                Some((\n+                    root_res,\n+                    format!(\n+                        \"{}.{}\",\n+                        if def.is_enum() { \"variant\" } else { \"structfield\" },\n+                        field.ident\n+                    ),\n+                    Some((kind, field.did)),\n+                ))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n@@ -669,27 +652,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     };\n \n-                    if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n-                    } else {\n-                        let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_str))))\n-                    }\n+                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                    (res, format!(\"{}.{}\", kind, item_name), None)\n                 }),\n             _ => None,\n-        };\n-        res.unwrap_or_else(|| {\n-            if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(ty_res),\n-                    unresolved: item_str.into(),\n-                }\n-                .into())\n-            }\n-        })\n+        }\n     }\n \n     /// Used for reporting better errors."}, {"sha": "392321f9c60db4a72557f146adf8a2ae3381014c", "filename": "src/test/rustdoc-ui/intra-doc/private.private.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link resolves only because you passed `--document-private-items`, but will break without\n+\n+warning: 3 warnings emitted\n "}, {"sha": "5d1c34b9168d9368bf0d643f407716c0abf59947", "filename": "src/test/rustdoc-ui/intra-doc/private.public.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link will resolve properly if you pass `--document-private-items`\n+\n+warning: 3 warnings emitted\n "}, {"sha": "525332ddaac3badc8b9209d5361ee88ba7d6eff8", "filename": "src/test/rustdoc-ui/intra-doc/private.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -2,12 +2,16 @@\n // revisions: public private\n // [private]compile-flags: --document-private-items\n \n-/// docs [DontDocMe] [DontDocMe::f]\n+// make sure to update `rustdoc/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n //~^ WARNING public documentation for `DocMe` links to private item `DontDocMe`\n+//~| WARNING public documentation for `DocMe` links to private item `DontDocMe::x`\n //~| WARNING public documentation for `DocMe` links to private item `DontDocMe::f`\n-// FIXME: for [private] we should also make sure the link was actually generated\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n \n impl DontDocMe {\n     fn f() {}"}, {"sha": "337102d6ab3fa966d7a32fd362fda42d156234e1", "filename": "src/test/rustdoc/intra-doc/private.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -1,6 +1,17 @@\n #![crate_name = \"private\"]\n // compile-flags: --document-private-items\n-/// docs [DontDocMe]\n+\n+// make sure to update `rustdoc-ui/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n // @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html\"]' 'DontDocMe'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n+\n+impl DontDocMe {\n+    fn f() {}\n+}"}, {"sha": "4fd695585ba06d8190a0b28c008842412d12b123", "filename": "src/test/ui/deref-suggestion.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fderef-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fderef-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -45,4 +45,30 @@ fn main() {\n     //~^ ERROR mismatched types\n     let r = R { i: i };\n     //~^ ERROR mismatched types\n+\n+\n+    let a = &1;\n+    let b = &2;\n+    let val: i32 = if true {\n+        a + 1\n+    } else {\n+        b\n+        //~^ ERROR mismatched types\n+    };\n+    let val: i32 = if true {\n+        let _ = 2;\n+        a + 1\n+    } else {\n+        let _ = 2;\n+        b\n+        //~^ ERROR mismatched types\n+    };\n+    let val = if true {\n+        *a\n+    } else if true {\n+    //~^ ERROR incompatible types\n+        b\n+    } else {\n+        &0\n+    };\n }"}, {"sha": "632a279d79623b92d8bd87c3cc50c707e08991ea", "filename": "src/test/ui/deref-suggestion.stderr", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.stderr?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -89,6 +89,43 @@ LL |     let r = R { i: i };\n    |                    expected `u32`, found `&{integer}`\n    |                    help: consider dereferencing the borrow: `*i`\n \n-error: aborting due to 10 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:55:9\n+   |\n+LL |         b\n+   |         ^\n+   |         |\n+   |         expected `i32`, found `&{integer}`\n+   |         help: consider dereferencing the borrow: `*b`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:63:9\n+   |\n+LL |         b\n+   |         ^\n+   |         |\n+   |         expected `i32`, found `&{integer}`\n+   |         help: consider dereferencing the borrow: `*b`\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/deref-suggestion.rs:68:12\n+   |\n+LL |        let val = if true {\n+   |   _______________-\n+LL |  |         *a\n+   |  |         -- expected because of this\n+LL |  |     } else if true {\n+   |  |____________^\n+LL | ||\n+LL | ||         b\n+LL | ||     } else {\n+LL | ||         &0\n+LL | ||     };\n+   | ||     ^\n+   | ||_____|\n+   | |______`if` and `else` have incompatible types\n+   |        expected `i32`, found `&{integer}`\n+\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "d4d1a3ee71e67c00c44aef199212ed27b8c059d6", "filename": "src/test/ui/macros/attr-empty-expr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -0,0 +1,11 @@\n+// AST-based macro attributes expanding to an empty expression produce an error and not ICE.\n+\n+#![feature(custom_test_frameworks)]\n+#![feature(stmt_expr_attributes)]\n+#![feature(test)]\n+\n+fn main() {\n+    let _ = #[test] 0; //~ ERROR removing an expression is not supported in this position\n+    let _ = #[bench] 1; //~ ERROR removing an expression is not supported in this position\n+    let _ = #[test_case] 2; //~ ERROR removing an expression is not supported in this position\n+}"}, {"sha": "53721053bcc08314a0e27e5c09aadda2fdf93b2f", "filename": "src/test/ui/macros/attr-empty-expr.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fattr-empty-expr.stderr?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -0,0 +1,20 @@\n+error: removing an expression is not supported in this position\n+  --> $DIR/attr-empty-expr.rs:8:13\n+   |\n+LL |     let _ = #[test] 0;\n+   |             ^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/attr-empty-expr.rs:9:13\n+   |\n+LL |     let _ = #[bench] 1;\n+   |             ^^^^^^^^\n+\n+error: removing an expression is not supported in this position\n+  --> $DIR/attr-empty-expr.rs:10:13\n+   |\n+LL |     let _ = #[test_case] 2;\n+   |             ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "16ec2a546434c20fbe79ebfb10d1445eb65841ea", "filename": "src/test/ui/typeck/issue-83621-placeholder-static-in-extern.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.rs?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -0,0 +1,7 @@\n+// Regression test for #83621.\n+\n+extern \"C\" {\n+    static x: _; //~ ERROR: [E0121]\n+}\n+\n+fn main() {}"}, {"sha": "b1bec4c0827f9255077a5e8112a504c7847782d9", "filename": "src/test/ui/typeck/issue-83621-placeholder-static-in-extern.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e6b478a5a146ad77ae4340ce379e1674c35ad69/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -0,0 +1,9 @@\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-83621-placeholder-static-in-extern.rs:4:15\n+   |\n+LL |     static x: _;\n+   |               ^ not allowed in type signatures\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "19e09a4a54c75312aeaac04577f2d0e067463ab6", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=8e6b478a5a146ad77ae4340ce379e1674c35ad69", "patch": "@@ -1 +1 @@\n-Subproject commit bb1d925dab36372c6bd1fb5671bb68ce938ff009\n+Subproject commit 19e09a4a54c75312aeaac04577f2d0e067463ab6"}]}