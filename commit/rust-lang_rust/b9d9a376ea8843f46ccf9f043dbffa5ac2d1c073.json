{"sha": "b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDlhMzc2ZWE4ODQzZjQ2Y2NmOWYwNDNkYmZmYTVhYzJkMWMwNzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:59:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:59:55Z"}, "message": "rollup merge of #24385: aturon/unstable-scoped\n\nConflicts:\n\tsrc/libstd/thread/mod.rs\n\tsrc/test/bench/shootout-mandelbrot.rs\n\tsrc/test/bench/shootout-reverse-complement.rs\n\tsrc/test/run-pass/capturing-logging.rs\n\tsrc/test/run-pass/issue-9396.rs\n\tsrc/test/run-pass/tcp-accept-stress.rs\n\tsrc/test/run-pass/tcp-connect-timeouts.rs\n\tsrc/test/run-pass/tempfile.rs", "tree": {"sha": "94aa404c31d33f17e0fac67b1ea8e7e6a0b30946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94aa404c31d33f17e0fac67b1ea8e7e6a0b30946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "html_url": "https://github.com/rust-lang/rust/commit/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae7959d298c95d5ffdeae8e7c3f3659d7fc28cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7959d298c95d5ffdeae8e7c3f3659d7fc28cdb", "html_url": "https://github.com/rust-lang/rust/commit/ae7959d298c95d5ffdeae8e7c3f3659d7fc28cdb"}, {"sha": "a9fd41e1f984fdfecb78ba9570bb159854c58b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9fd41e1f984fdfecb78ba9570bb159854c58b16", "html_url": "https://github.com/rust-lang/rust/commit/a9fd41e1f984fdfecb78ba9570bb159854c58b16"}], "stats": {"total": 668, "additions": 537, "deletions": 131}, "files": [{"sha": "e6d560d8122e6c9bb29899be075a83d6ed05df18", "filename": "src/doc/intro.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -389,6 +389,7 @@ safe concurrent programs.\n Here's an example of a concurrent Rust program:\n \n ```{rust}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {\n@@ -421,6 +422,7 @@ problem.\n Let's see an example. This Rust code will not compile:\n \n ```{rust,ignore}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {\n@@ -467,6 +469,7 @@ that our mutation doesn't cause a data race.\n Here's what using a Mutex looks like:\n \n ```{rust}\n+# #![feature(scoped)]\n use std::thread;\n use std::sync::Mutex;\n \n@@ -527,6 +530,7 @@ As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:\n \n ```{rust,ignore}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {"}, {"sha": "159e04e9429a079a048c204757bf0ed4513c639c", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -56,68 +56,35 @@ place!\n \n ## Threads\n \n-Rust's standard library provides a library for 'threads', which allow you to\n+Rust's standard library provides a library for threads, which allow you to\n run Rust code in parallel. Here's a basic example of using `std::thread`:\n \n ```\n use std::thread;\n \n fn main() {\n-    thread::scoped(|| {\n+    thread::spawn(|| {\n         println!(\"Hello from a thread!\");\n     });\n }\n ```\n \n-The `thread::scoped()` method accepts a closure, which is executed in a new\n-thread. It's called `scoped` because this thread returns a join guard:\n+The `thread::spawn()` method accepts a closure, which is executed in a\n+new thread. It returns a handle to the thread, that can be used to\n+wait for the child thread to finish and extract its result:\n \n ```\n use std::thread;\n \n fn main() {\n-    let guard = thread::scoped(|| {\n-        println!(\"Hello from a thread!\");\n+    let handle = thread::spawn(|| {\n+        \"Hello from a thread!\"\n     });\n \n-    // guard goes out of scope here\n+    println!(\"{}\", handle.join().unwrap());\n }\n ```\n \n-When `guard` goes out of scope, it will block execution until the thread is\n-finished. If we didn't want this behaviour, we could use `thread::spawn()`:\n-\n-```\n-use std::thread;\n-\n-fn main() {\n-    thread::spawn(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-We need to `sleep` here because when `main()` ends, it kills all of the\n-running threads.\n-\n-[`scoped`](std/thread/struct.Builder.html#method.scoped) has an interesting\n-type signature:\n-\n-```text\n-fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T>\n-    where T: Send + 'a,\n-          F: FnOnce() -> T,\n-          F: Send + 'a\n-```\n-\n-Specifically, `F`, the closure that we pass to execute in the new thread. It\n-has two restrictions: It must be a `FnOnce` from `()` to `T`. Using `FnOnce`\n-allows the closure to take ownership of any data it mentions from the parent\n-thread. The other restriction is that `F` must be `Send`. We aren't allowed to\n-transfer this ownership unless the type thinks that's okay.\n-\n Many languages have the ability to execute threads, but it's wildly unsafe.\n There are entire books about how to prevent errors that occur from shared\n mutable state. Rust helps out with its type system here as well, by preventing"}, {"sha": "1393c39f66c954362250a4df667e11a47356138c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -130,10 +130,10 @@ struct Output {\n \n pub fn main() {\n     const STACK_SIZE: usize = 32000000; // 32MB\n-    let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n+    let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n-    }).unwrap().join();\n+    }).unwrap().join().unwrap();\n     env::set_exit_status(res as i32);\n }\n "}, {"sha": "4fd0340f09ac0ef533feff7194203883603a11ab", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -67,13 +67,33 @@\n //! thread. This means that it can outlive its parent (the thread that spawned\n //! it), unless this parent is the main thread.\n //!\n+//! The parent thread can also wait on the completion of the child\n+//! thread; a call to `spawn` produces a `JoinHandle`, which provides\n+//! a `join` method for waiting:\n+//!\n+//! ```rust\n+//! use std::thread;\n+//!\n+//! let child = thread::spawn(move || {\n+//!     // some work here\n+//! });\n+//! // some work here\n+//! let res = child.join();\n+//! ```\n+//!\n+//! The `join` method returns a `Result` containing `Ok` of the final\n+//! value produced by the child thread, or `Err` of the value given to\n+//! a call to `panic!` if the child panicked.\n+//!\n //! ## Scoped threads\n //!\n-//! Often a parent thread uses a child thread to perform some particular task,\n-//! and at some point must wait for the child to complete before continuing.\n-//! For this scenario, use the `thread::scoped` function:\n+//! The `spawn` method does not allow the child and parent threads to\n+//! share any stack data, since that is not safe in general. However,\n+//! `scoped` makes it possible to share the parent's stack by forcing\n+//! a join before any relevant stack frames are popped:\n //!\n //! ```rust\n+//! # #![feature(scoped)]\n //! use std::thread;\n //!\n //! let guard = thread::scoped(move || {\n@@ -253,8 +273,8 @@ impl Builder {\n     /// `io::Result` to capture any failure to create the thread at\n     /// the OS level.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n-        F: FnOnce(), F: Send + 'static\n+    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n+        F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n     {\n         self.spawn_inner(Box::new(f)).map(|i| JoinHandle(i))\n     }\n@@ -274,7 +294,8 @@ impl Builder {\n     /// Unlike the `scoped` free function, this method yields an\n     /// `io::Result` to capture any failure to create the thread at\n     /// the OS level.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[unstable(feature = \"scoped\",\n+               reason = \"memory unsafe if destructor is avoided, see #24292\")]\n     pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n@@ -370,7 +391,9 @@ impl Builder {\n /// Panics if the OS fails to create a thread; use `Builder::spawn`\n /// to recover from such errors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n+pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n+    F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n+{\n     Builder::new().spawn(f).unwrap()\n }\n \n@@ -387,7 +410,8 @@ pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n ///\n /// Panics if the OS fails to create a thread; use `Builder::scoped`\n /// to recover from such errors.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"scoped\",\n+           reason = \"memory unsafe if destructor is avoided, see #24292\")]\n pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n     T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n {\n@@ -635,9 +659,9 @@ impl<T> JoinInner<T> {\n /// handle: the ability to join a child thread is a uniquely-owned\n /// permission.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinHandle(JoinInner<()>);\n+pub struct JoinHandle<T>(JoinInner<T>);\n \n-impl JoinHandle {\n+impl<T> JoinHandle<T> {\n     /// Extracts a handle to the underlying thread\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n@@ -649,13 +673,14 @@ impl JoinHandle {\n     /// If the child thread panics, `Err` is returned with the parameter given\n     /// to `panic`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join(mut self) -> Result<()> {\n+    pub fn join(mut self) -> Result<T> {\n         self.0.join()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Drop for JoinHandle {\n+#[unsafe_destructor]\n+impl<T> Drop for JoinHandle<T> {\n     fn drop(&mut self) {\n         if !self.0.joined {\n             unsafe { imp::detach(self.0.native) }\n@@ -674,7 +699,8 @@ impl Drop for JoinHandle {\n /// handle: the ability to join a child thread is a uniquely-owned\n /// permission.\n #[must_use = \"thread will be immediately joined if `JoinGuard` is not used\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"scoped\",\n+           reason = \"memory unsafe if destructor is avoided, see #24292\")]\n pub struct JoinGuard<'a, T: Send + 'a> {\n     inner: JoinInner<T>,\n     _marker: PhantomData<&'a T>,\n@@ -706,7 +732,8 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n }\n \n #[unsafe_destructor]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"scoped\",\n+           reason = \"memory unsafe if destructor is avoided, see #24292\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n         if !self.inner.joined {"}, {"sha": "61fe6593dc398dd72381c5691bf9b5aa51d4e5f6", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -111,11 +111,11 @@ fn main() {\n     let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n         use std::num::Int;\n         let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n-        thread::scoped(move || inner(depth, iterations))\n+        thread::spawn(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n \n     for message in messages {\n-        println!(\"{}\", message.join());\n+        println!(\"{}\", message.join().unwrap());\n     }\n \n     println!(\"long lived tree of depth {}\\t check: {}\","}, {"sha": "32504350e42682d33fcea64af426e6a1fe65c032", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -166,15 +166,15 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (_, j) in (0..N).zip((0..).step_by(k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(thread::scoped(move|| {\n+        futures.push(thread::spawn(move|| {\n             work(perm, j as usize, max as usize)\n         }))\n     }\n \n     let mut checksum = 0;\n     let mut maxflips = 0;\n     for fut in futures {\n-        let (cs, mf) = fut.join();\n+        let (cs, mf) = fut.join().unwrap();\n         checksum += cs;\n         maxflips = cmp::max(maxflips, mf);\n     }"}, {"sha": "07cb120ef0e29c18cf0d7ca1bef57d9802170d8d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -307,17 +307,17 @@ fn main() {\n \n     let nb_freqs: Vec<_> = (1..3).map(|i| {\n         let input = input.clone();\n-        (i, thread::scoped(move|| generate_frequencies(&input, i)))\n+        (i, thread::spawn(move|| generate_frequencies(&input, i)))\n     }).collect();\n     let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        thread::scoped(move|| generate_frequencies(&input, occ.len()))\n+        thread::spawn(move|| generate_frequencies(&input, occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs {\n-        print_frequencies(&freq.join(), i);\n+        print_frequencies(&freq.join().unwrap(), i);\n     }\n     for (&occ, freq) in OCCURRENCES.iter().zip(occ_freqs.into_iter()) {\n-        print_occurrences(&mut freq.join(), occ);\n+        print_occurrences(&mut freq.join().unwrap(), occ);\n     }\n }"}, {"sha": "f2714d55e5ea772753b032451524ee927873b0b1", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -81,7 +81,7 @@ fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n     let mut precalc_i = Vec::with_capacity(h);\n \n     let precalc_futures = (0..WORKERS).map(|i| {\n-        thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n \n@@ -107,7 +107,7 @@ fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n     }).collect::<Vec<_>>();\n \n     for res in precalc_futures {\n-        let (rs, is) = res.join();\n+        let (rs, is) = res.join().unwrap();\n         precalc_r.extend(rs.into_iter());\n         precalc_i.extend(is.into_iter());\n     }\n@@ -122,7 +122,7 @@ fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n-        thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n             let init_r_slice = vec_init_r;\n \n@@ -143,7 +143,7 @@ fn mandelbrot<W: Write>(w: usize, mut out: W) -> io::Result<()> {\n \n     try!(writeln!(&mut out, \"P4\\n{} {}\", w, h));\n     for res in data {\n-        try!(out.write_all(&res.join()));\n+        try!(out.write_all(&res.join().unwrap()));\n     }\n     out.flush()\n }"}, {"sha": "7c9f33678a39c924fdabdd7849fe75a1bf865f49", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(libc)]\n+#![feature(libc, scoped)]\n \n extern crate libc;\n "}, {"sha": "b0e8c39567323b4b32ec5d5d8503c57095051995", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -41,7 +41,7 @@\n // no-pretty-expanded FIXME #15189\n \n #![allow(non_snake_case)]\n-#![feature(unboxed_closures, core, os)]\n+#![feature(unboxed_closures, core, os, scoped)]\n \n use std::iter::repeat;\n use std::thread;"}, {"sha": "561f141100ca7c3a7c962f4a50c7b893598b162c", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -13,9 +13,9 @@\n use std::thread::Builder;\n \n fn main() {\n-    let r: () = Builder::new().name(\"owned name\".to_string()).scoped(move|| {\n+    let r: () = Builder::new().name(\"owned name\".to_string()).spawn(move|| {\n         panic!(\"test\");\n         ()\n-    }).unwrap().join();\n+    }).unwrap().join().unwrap();\n     panic!();\n }"}, {"sha": "b4f0d7ceb99eb911ef8990dcd7ee8d3c52129191", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -37,7 +37,7 @@ fn r(x:isize) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    let _t = thread::scoped(move|| {\n+    let _t = thread::spawn(move|| {\n       let _i = r(5);\n     });\n     panic!();"}, {"sha": "ae0a358ac4e3f952d6a1681c310e20e4ac41f43e", "filename": "src/test/run-pass/atomic-print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-print.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -27,7 +27,7 @@ fn main(){\n     if env::args().count() == 2 {\n         let barrier = sync::Arc::new(sync::Barrier::new(2));\n         let tbarrier = barrier.clone();\n-        let t = thread::scoped(||{\n+        let t = thread::spawn(move || {\n             tbarrier.wait();\n             do_print(1);\n         });"}, {"sha": "5a7b1c83dfda3acca3a9e410b34cac239b9efe09", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -22,8 +22,8 @@ struct Pair {\n pub fn main() {\n     let z: Box<_> = box Pair { a : 10, b : 12};\n \n-    let _t = thread::scoped(move|| {\n+    thread::spawn(move|| {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n-    });\n+    }).join();\n }"}, {"sha": "72f623ccfde7aaa30a0e207a8c5834acaec7ff7e", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -15,11 +15,12 @@ use std::sync::mpsc::{channel, Sender};\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move|| { child(&tx) });\n+    let t = thread::spawn(move|| { child(&tx) });\n     let y = rx.recv().unwrap();\n     println!(\"received\");\n     println!(\"{}\", y);\n     assert_eq!(y, 10);\n+    t.join();\n }\n \n fn child(c: &Sender<isize>) {"}, {"sha": "b35095171ece00d800c2b918a5a407c996c6cc77", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -42,7 +42,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    thread::scoped(move|| {\n+    thread::spawn(move|| {\n         let result = count(1000);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 1000);"}, {"sha": "3993868068197ebb44a026865b761c85f6b78867", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -46,9 +46,9 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    let _t = thread::scoped(move|| {\n+    thread::spawn(move|| {\n         let result = count(12);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 2048);\n-    });\n+    }).join();\n }"}, {"sha": "3be47e8430d598f675336ea0bda6a11300d7e097", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -34,22 +34,19 @@ fn main() {\n \n fn parent() {\n     let file = File::open(\"Makefile\").unwrap();\n-    let _dir = fs::read_dir(\"/\").unwrap();\n     let tcp1 = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n-    assert_eq!(tcp1.as_raw_fd(), file.as_raw_fd() + 2);\n     let tcp2 = tcp1.try_clone().unwrap();\n     let addr = tcp1.local_addr().unwrap();\n-    let t = thread::scoped(|| TcpStream::connect(addr).unwrap());\n+    let t = thread::spawn(move || TcpStream::connect(addr).unwrap());\n     let tcp3 = tcp1.accept().unwrap().0;\n-    let tcp4 = t.join();\n+    let tcp4 = t.join().unwrap();\n     let tcp5 = tcp3.try_clone().unwrap();\n     let tcp6 = tcp4.try_clone().unwrap();\n     let udp1 = UdpSocket::bind(\"127.0.0.1:0\").unwrap();\n     let udp2 = udp1.try_clone().unwrap();\n \n     let status = Command::new(env::args().next().unwrap())\n                         .arg(file.as_raw_fd().to_string())\n-                        .arg((file.as_raw_fd() + 1).to_string())\n                         .arg(tcp1.as_raw_fd().to_string())\n                         .arg(tcp2.as_raw_fd().to_string())\n                         .arg(tcp3.as_raw_fd().to_string())"}, {"sha": "dafa8ee10339ee706c810153987fe7787bbc35a3", "filename": "src/test/run-pass/init-large-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-large-type.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -26,7 +26,7 @@ const SIZE: usize = 1024 * 1024;\n \n fn main() {\n     // do the test in a new thread to avoid (spurious?) stack overflows\n-    let _ = thread::scoped(|| {\n+    thread::spawn(|| {\n         let _memory: [u8; SIZE] = unsafe { init() };\n     }).join();\n }"}, {"sha": "71897ea68c209b39358e5ca678a632e1978584ca", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -26,7 +26,7 @@ fn helper(rx: Receiver<Sender<()>>) {\n \n fn main() {\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move|| { helper(rx) });\n+    let t = thread::spawn(move|| { helper(rx) });\n     let (snd, rcv) = channel::<isize>();\n     for _ in 1..100000 {\n         snd.send(1).unwrap();\n@@ -38,4 +38,5 @@ fn main() {\n         }\n     }\n     drop(tx);\n+    t.join();\n }"}, {"sha": "522f544a21c1037c87e89c7142c8ecb8d2a31efd", "filename": "src/test/run-pass/issue-20454.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20454.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -13,11 +13,11 @@\n use std::thread;\n \n fn _foo() {\n-    let _t = thread::scoped(move || { // no need for -> ()\n+    thread::spawn(move || { // no need for -> ()\n         loop {\n             println!(\"hello\");\n         }\n-    });\n+    }).join();\n }\n \n fn main() {}"}, {"sha": "61de3c6385e7bb49581f01e73703a241e7ded94b", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -23,7 +23,7 @@ enum Msg\n }\n \n fn foo(name: String, samples_chan: Sender<Msg>) {\n-    let _t = thread::scoped(move|| {\n+    thread::spawn(move|| {\n         let mut samples_chan = samples_chan;\n \n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n@@ -34,7 +34,7 @@ fn foo(name: String, samples_chan: Sender<Msg>) {\n         });\n \n         samples_chan.send(Msg::GetSamples(name.clone(), callback));\n-    });\n+    }).join();\n }\n \n pub fn main() {}"}, {"sha": "ed67630bcac44540024f6834e9065d65799855a2", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -13,7 +13,7 @@ use std::thread;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move||{\n+    let t = thread::spawn(move||{\n         thread::sleep_ms(10);\n         tx.send(()).unwrap();\n     });\n@@ -24,4 +24,5 @@ pub fn main() {\n             Err(TryRecvError::Disconnected) => unreachable!()\n         }\n     }\n+    t.join();\n }"}, {"sha": "3f0daf2610ce970704f31a2fa685b3a23b8fda7d", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -23,9 +23,10 @@ fn producer(tx: &Sender<Vec<u8>>) {\n \n pub fn main() {\n     let (tx, rx) = channel::<Vec<u8>>();\n-    let _prod = thread::scoped(move|| {\n+    let prod = thread::spawn(move|| {\n         producer(&tx)\n     });\n \n     let _data: Vec<u8> = rx.recv().unwrap();\n+    prod.join();\n }"}, {"sha": "a81c0846a279489534080fc789c3cb7ef5509040", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -18,36 +18,39 @@ fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    let _t = thread::scoped(move|| {\n+    let t = thread::spawn(move|| {\n         user(i);\n         println!(\"spawned {}\", i)\n     });\n     i += 1;\n-    println!(\"original {}\", i)\n+    println!(\"original {}\", i);\n+    t.join();\n }\n \n fn bar() {\n     // Here, the original i has not been moved, only copied, so is still\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             user(i);\n         });\n         i += 1;\n+        t.join();\n     }\n }\n \n fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             let mut i = i;\n             i += 1;\n             user(i);\n         });\n         i += 1;\n+        t.join();\n     }\n }\n "}, {"sha": "c7ef9776367bd10d410d56e80f68dd398b428557", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -14,7 +14,7 @@ use std::thread;\n \n pub fn main() {\n     let x = \"Hello world!\".to_string();\n-    let _t = thread::scoped(move|| {\n+    thread::spawn(move|| {\n         println!(\"{}\", x);\n-    });\n+    }).join();\n }"}, {"sha": "0d0a5bee8a443f879ddc00df20d2bf80d1a153de", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -37,7 +37,7 @@ fn recurse() {\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 && args[1] == \"recurse\" {\n-        let _t = thread::scoped(recurse);\n+        thread::spawn(recurse).join();\n     } else {\n         let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n         assert!(!recurse.status.success());"}, {"sha": "59179206104f8421cf8229d053dcccac638dcd29", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -40,7 +40,7 @@ impl log::Logger for ChannelLogger {\n pub fn main() {\n     let (logger, rx) = ChannelLogger::new();\n \n-    let _t = thread::scoped(move|| {\n+    let t = thread::spawn(move|| {\n         log::set_logger(logger);\n \n         info!(\"foo\");\n@@ -53,4 +53,6 @@ pub fn main() {\n     assert_eq!(rx.recv().unwrap(), \"foo bar\");\n     assert_eq!(rx.recv().unwrap(), \"bar foo\");\n     assert!(rx.recv().is_err());\n+\n+    t.join();\n }"}, {"sha": "5f0902d34d3e87a28a73fa8809742fca4bab9587", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core, std_misc)]\n+#![feature(core, std_misc, scoped)]\n use std::thread;\n use std::sync::Mutex;\n \n@@ -25,7 +25,6 @@ fn par_for<I, F>(iter: I, f: F)\n             f(elem)\n         })\n     }).collect();\n-\n }\n \n fn sum(x: &[i32]) {"}, {"sha": "66878d98c840cf5088112c79cb33c96aabb0f041", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -32,12 +32,14 @@ fn test(f: isize) -> test {\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    let _t = thread::scoped(move|| {\n+    let t = thread::spawn(move|| {\n         let (tx2, rx2) = channel();\n         tx.send(tx2).unwrap();\n \n         let _r = rx2.recv().unwrap();\n     });\n \n     rx.recv().unwrap().send(test(42)).unwrap();\n+\n+    t.join();\n }"}, {"sha": "4a35ed609e0801c793997c53785cc46d39e63549", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -16,13 +16,16 @@ fn x(s: String, n: isize) {\n }\n \n pub fn main() {\n-    let _t = thread::scoped(|| x(\"hello from first spawned fn\".to_string(), 65) );\n-    let _t = thread::scoped(|| x(\"hello from second spawned fn\".to_string(), 66) );\n-    let _t = thread::scoped(|| x(\"hello from third spawned fn\".to_string(), 67) );\n+    let t1 = thread::spawn(|| x(\"hello from first spawned fn\".to_string(), 65) );\n+    let t2 = thread::spawn(|| x(\"hello from second spawned fn\".to_string(), 66) );\n+    let t3 = thread::spawn(|| x(\"hello from third spawned fn\".to_string(), 67) );\n     let mut i = 30;\n     while i > 0 {\n         i = i - 1;\n         println!(\"parent sleeping\");\n         thread::yield_now();\n     }\n+    t1.join();\n+    t2.join();\n+    t3.join();\n }"}, {"sha": "1409caf9c702db352b046f27e46c8419571c9941", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -26,12 +26,13 @@ fn test05_start(tx : &Sender<isize>) {\n \n fn test05() {\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move|| { test05_start(&tx) });\n+    let t = thread::spawn(move|| { test05_start(&tx) });\n     let mut value: isize = rx.recv().unwrap();\n     println!(\"{}\", value);\n     value = rx.recv().unwrap();\n     println!(\"{}\", value);\n     value = rx.recv().unwrap();\n     println!(\"{}\", value);\n     assert_eq!(value, 30);\n+    t.join();\n }"}, {"sha": "b3327d82c3ebe8b05707b35cef118278f52479b4", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -17,6 +17,6 @@ pub fn main() { test00(); }\n fn start() { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n-    let _ = thread::scoped(move|| start() ).join();\n+    thread::spawn(move|| start() ).join();\n     println!(\"Completing.\");\n }"}, {"sha": "a796750ef88b7d999e4a289f893203ff6288930c", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -29,10 +29,12 @@ fn start(tx: &Sender<Sender<String>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = thread::scoped(move|| { start(&tx) });\n+    let child = thread::spawn(move|| { start(&tx) });\n \n     let mut c = rx.recv().unwrap();\n     c.send(\"A\".to_string()).unwrap();\n     c.send(\"B\".to_string()).unwrap();\n     thread::yield_now();\n+\n+    child.join();\n }"}, {"sha": "7af8f5d3b35759b109760146dadec7000bf09828", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -22,8 +22,9 @@ fn start(tx: &Sender<Sender<isize>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = thread::scoped(move|| {\n+    let child = thread::spawn(move|| {\n         start(&tx)\n     });\n     let _tx = rx.recv().unwrap();\n+    child.join();\n }"}, {"sha": "f8d608d31689c0536a09d8955e4022e218e1a3c1", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -18,7 +18,7 @@ fn start(_task_number: isize) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: isize = 0;\n-    let mut result = thread::scoped(move|| {\n+    let mut result = thread::spawn(move|| {\n         start(i)\n     });\n "}, {"sha": "156ddd9c77fc339d817b749a9e13b5bef09d9c31", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -21,6 +21,6 @@ fn start(tx: &Sender<isize>, start: isize, number_of_messages: isize) {\n pub fn main() {\n     println!(\"Check that we don't deadlock.\");\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move|| { start(&tx, 0, 10) }).join();\n+    let _ = thread::spawn(move|| { start(&tx, 0, 10) }).join();\n     println!(\"Joined task\");\n }"}, {"sha": "0048d7d2d73217de7971695569e9c28df12f9473", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     while (i > 0) {\n         println!(\"{}\", i);\n         let tx = tx.clone();\n-        thread::scoped({let i = i; move|| { child(i, &tx) }});\n+        thread::spawn({let i = i; move|| { child(i, &tx) }});\n         i = i - 1;\n     }\n "}, {"sha": "1d853b3e67ffc4c86c55b9c9de9d9ce22d796ad0", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -29,8 +29,9 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (tx, rx) = channel();\n-    let _t = thread::scoped(move|| {\n+    let t = thread::spawn(move|| {\n         start(&tx, 10)\n     });\n     rx.recv();\n+    t.join();\n }"}, {"sha": "8f6f971ce35c817dd4a06a2a3a2ca4a9592da68a", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -22,5 +22,5 @@ fn f() {\n }\n \n pub fn main() {\n-    let _t = thread::scoped(move|| f() ).join();\n+    thread::spawn(move|| f() ).join();\n }"}, {"sha": "25f40757b7b8ae652cdab0cd08a953bf3d49be09", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -42,7 +42,7 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        results.push(thread::scoped({\n+        results.push(thread::spawn({\n             let i = i;\n             move|| {\n                 test00_start(&tx, i, number_of_messages)"}, {"sha": "e37160f979c268849d3756587f6703012fd00c60", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -30,19 +30,19 @@ fn test00() {\n     let number_of_messages: isize = 10;\n \n     let tx2 = tx.clone();\n-    let _t = thread::scoped(move|| {\n+    let t1 = thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = thread::scoped(move|| {\n+    let t2 = thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = thread::scoped(move|| {\n+    let t3 = thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = thread::scoped(move|| {\n+    let t4 = thread::spawn(move|| {\n         test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n \n@@ -60,4 +60,9 @@ fn test00() {\n     }\n \n     assert_eq!(sum, number_of_messages * 4 * (number_of_messages * 4 - 1) / 2);\n+\n+    t1.join();\n+    t2.join();\n+    t3.join();\n+    t4.join();\n }"}, {"sha": "d8eec4169e3531c0f749a827b39ffc64256ec97a", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -26,7 +26,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: isize = 10;\n \n-    let result = thread::scoped(move|| {\n+    let result = thread::spawn(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n "}, {"sha": "ba8819fd0b0fee8e236977c8ac70b97672a3c15d", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -15,7 +15,7 @@\n use std::thread;\n \n pub fn main() {\n-    let _t = thread::scoped(move|| child(\"Hello\".to_string()) );\n+    thread::spawn(move|| child(\"Hello\".to_string()) ).join();\n }\n \n fn child(_s: String) {"}, {"sha": "6a84ec47c93a1a0a22f0db4b299428c3d5a040e2", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -21,11 +21,13 @@ pub fn main() {\n     let x: Box<isize> = box 1;\n     let x_in_parent = &(*x) as *const isize as usize;\n \n-    let _t = thread::scoped(move || {\n+    let t = thread::spawn(move || {\n         let x_in_child = &(*x) as *const isize as usize;\n         tx.send(x_in_child).unwrap();\n     });\n \n     let x_in_child = rx.recv().unwrap();\n     assert_eq!(x_in_parent, x_in_child);\n+\n+    t.join();\n }"}, {"sha": "3347287748e1db56b2e946d8b6770f1cf1a79226", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-macos osx really doesn't like cycling through large numbers of\n+//              sockets as calls to connect() will start returning EADDRNOTAVAIL\n+//              quite quickly and it takes a few seconds for the sockets to get\n+//              recycled.\n+\n+#![feature(old_io, io, std_misc)]\n+\n+use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n+use std::sync::Arc;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::mpsc::channel;\n+use std::thread;\n+\n+static N: usize = 8;\n+static M: usize = 20;\n+\n+fn main() {\n+    test();\n+}\n+\n+fn test() {\n+    let mut l = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+    let addr = l.socket_name().unwrap();\n+    let mut a = l.listen().unwrap();\n+    let cnt = Arc::new(AtomicUsize::new(0));\n+\n+    let (srv_tx, srv_rx) = channel();\n+    let (cli_tx, cli_rx) = channel();\n+    let ts1 = (0..N).map(|_| {\n+        let a = a.clone();\n+        let cnt = cnt.clone();\n+        let srv_tx = srv_tx.clone();\n+        thread::spawn(move|| {\n+            let mut a = a;\n+            loop {\n+                match a.accept() {\n+                    Ok(..) => {\n+                        if cnt.fetch_add(1, Ordering::SeqCst) == N * M - 1 {\n+                            break\n+                        }\n+                    }\n+                    Err(ref e) if e.kind == EndOfFile => break,\n+                    Err(e) => panic!(\"{}\", e),\n+                }\n+            }\n+            srv_tx.send(());\n+        })\n+    }).collect::<Vec<_>>();\n+\n+    let ts2 = (0..N).map(|_| {\n+        let cli_tx = cli_tx.clone();\n+        thread::scoped(move|| {\n+            for _ in 0..M {\n+                let _s = TcpStream::connect(addr).unwrap();\n+            }\n+            cli_tx.send(());\n+        })\n+    }).collect::<Vec<_>>();\n+    drop((cli_tx, srv_tx));\n+\n+    // wait for senders\n+    if cli_rx.iter().take(N).count() != N {\n+        a.close_accept().unwrap();\n+        panic!(\"clients panicked\");\n+    }\n+\n+    // wait for one acceptor to die\n+    let _ = srv_rx.recv();\n+\n+    // Notify other receivers should die\n+    a.close_accept().unwrap();\n+\n+    // wait for receivers\n+    assert_eq!(srv_rx.iter().take(N - 1).count(), N - 1);\n+\n+    // Everything should have been accepted.\n+    assert_eq!(cnt.load(Ordering::SeqCst), N * M);\n+\n+    for t in ts1 { t.join() }\n+    for t in ts2 { t.join() }\n+}"}, {"sha": "c31400a832c749fdfbfdf41d6df06ce23bde699b", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+// compile-flags:--test\n+// exec-env:RUST_TEST_THREADS=1\n+\n+// Tests for the connect_timeout() function on a TcpStream. This runs with only\n+// one test task to ensure that errors are timeouts, not file descriptor\n+// exhaustion.\n+\n+#![reexport_test_harness_main = \"test_main\"]\n+\n+#![allow(unused_imports)]\n+#![feature(old_io, std_misc, io)]\n+\n+use std::old_io::*;\n+use std::old_io::test::*;\n+use std::old_io;\n+use std::time::Duration;\n+use std::sync::mpsc::channel;\n+use std::thread;\n+\n+#[cfg_attr(target_os = \"freebsd\", ignore)]\n+fn eventual_timeout() {\n+    let addr = next_test_ip4();\n+\n+    let (tx1, rx1) = channel();\n+    let (_tx2, rx2) = channel::<()>();\n+    let t = thread::spawn(move|| {\n+        let _l = TcpListener::bind(addr).unwrap().listen();\n+        tx1.send(()).unwrap();\n+        let _ = rx2.recv();\n+    });\n+    rx1.recv().unwrap();\n+\n+    let mut v = Vec::new();\n+    for _ in 0_usize..10000 {\n+        match TcpStream::connect_timeout(addr, Duration::milliseconds(100)) {\n+            Ok(e) => v.push(e),\n+            Err(ref e) if e.kind == old_io::TimedOut => return,\n+            Err(e) => panic!(\"other error: {}\", e),\n+        }\n+    }\n+    panic!(\"never timed out!\");\n+    t.join();\n+}\n+\n+fn timeout_success() {\n+    let addr = next_test_ip4();\n+    let _l = TcpListener::bind(addr).unwrap().listen();\n+\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_ok());\n+}\n+\n+fn timeout_error() {\n+    let addr = next_test_ip4();\n+\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_err());\n+}\n+\n+fn connect_timeout_zero() {\n+    let addr = next_test_ip4();\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(0)).is_err());\n+}\n+\n+fn connect_timeout_negative() {\n+    let addr = next_test_ip4();\n+    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(-1)).is_err());\n+}"}, {"sha": "3f99c338c0e33537d08fb7e16aa5727b424ec1a2", "filename": "src/test/run-pass/tempfile.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -0,0 +1,213 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows TempDir may cause IoError on windows: #10463\n+\n+// These tests are here to exercise the functionality of the `tempfile` module.\n+// One might expect these tests to be located in that module, but sadly they\n+// cannot. The tests need to invoke `os::change_dir` which cannot be done in the\n+// normal test infrastructure. If the tests change the current working\n+// directory, then *all* tests which require relative paths suddenly break b/c\n+// they're in a different location than before. Hence, these tests are all run\n+// serially here.\n+\n+#![feature(old_io, old_path, os, old_fs)]\n+\n+use std::old_path::{Path, GenericPath};\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::{fs, TempDir};\n+use std::old_io;\n+use std::env;\n+use std::sync::mpsc::channel;\n+use std::thread;\n+\n+fn test_tempdir() {\n+    let path = {\n+        let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n+        let p = p.path();\n+        assert!(p.as_str().unwrap().contains(\"foobar\"));\n+        p.clone()\n+    };\n+    assert!(!path.exists());\n+}\n+\n+fn test_rm_tempdir() {\n+    let (tx, rx) = channel();\n+    let f = move|| -> () {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        tx.send(tmp.path().clone()).unwrap();\n+        panic!(\"panic to unwind past `tmp`\");\n+    };\n+    thread::spawn(f).join();\n+    let path = rx.recv().unwrap();\n+    assert!(!path.exists());\n+\n+    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+    let path = tmp.path().clone();\n+    let f = move|| -> () {\n+        let _tmp = tmp;\n+        panic!(\"panic to unwind past `tmp`\");\n+    };\n+    thread::spawn(f).join();\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let f = move || {\n+            TempDir::new(\"test_rm_tempdir\").unwrap()\n+        };\n+        // FIXME(#16640) `: TempDir` annotation shouldn't be necessary\n+        let tmp: TempDir = thread::spawn(f).join().unwrap();\n+        path = tmp.path().clone();\n+        assert!(path.exists());\n+    }\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        path = tmp.into_inner();\n+    }\n+    assert!(path.exists());\n+    fs::rmdir_recursive(&path);\n+    assert!(!path.exists());\n+}\n+\n+fn test_rm_tempdir_close() {\n+    let (tx, rx) = channel();\n+    let f = move|| -> () {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        tx.send(tmp.path().clone()).unwrap();\n+        tmp.close();\n+        panic!(\"panic when unwinding past `tmp`\");\n+    };\n+    thread::spawn(f).join();\n+    let path = rx.recv().unwrap();\n+    assert!(!path.exists());\n+\n+    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+    let path = tmp.path().clone();\n+    let f = move|| -> () {\n+        let tmp = tmp;\n+        tmp.close();\n+        panic!(\"panic when unwinding past `tmp`\");\n+    };\n+    thread::spawn(f).join();\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let f = move || {\n+            TempDir::new(\"test_rm_tempdir\").unwrap()\n+        };\n+        // FIXME(#16640) `: TempDir` annotation shouldn't be necessary\n+        let tmp: TempDir = thread::spawn(f).join().unwrap();\n+        path = tmp.path().clone();\n+        assert!(path.exists());\n+        tmp.close();\n+    }\n+    assert!(!path.exists());\n+\n+    let path;\n+    {\n+        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n+        path = tmp.into_inner();\n+    }\n+    assert!(path.exists());\n+    fs::rmdir_recursive(&path);\n+    assert!(!path.exists());\n+}\n+\n+// Ideally these would be in std::os but then core would need\n+// to depend on std\n+fn recursive_mkdir_rel() {\n+    let path = Path::new(\"frob\");\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n+    println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n+           cwd.display(), path.exists());\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n+    assert!(path.is_dir());\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n+    assert!(path.is_dir());\n+}\n+\n+fn recursive_mkdir_dot() {\n+    let dot = Path::new(\".\");\n+    fs::mkdir_recursive(&dot, old_io::USER_RWX);\n+    let dotdot = Path::new(\"..\");\n+    fs::mkdir_recursive(&dotdot, old_io::USER_RWX);\n+}\n+\n+fn recursive_mkdir_rel_2() {\n+    let path = Path::new(\"./frob/baz\");\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n+    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n+           cwd.display(), path.exists());\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n+    assert!(path.is_dir());\n+    assert!(path.dir_path().is_dir());\n+    let path2 = Path::new(\"quux/blat\");\n+    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n+           cwd.display());\n+    fs::mkdir_recursive(&path2, old_io::USER_RWX);\n+    assert!(path2.is_dir());\n+    assert!(path2.dir_path().is_dir());\n+}\n+\n+// Ideally this would be in core, but needs TempFile\n+pub fn test_rmdir_recursive_ok() {\n+    let rwx = old_io::USER_RWX;\n+\n+    let tmpdir = TempDir::new(\"test\").ok().expect(\"test_rmdir_recursive_ok: \\\n+                                                   couldn't create temp dir\");\n+    let tmpdir = tmpdir.path();\n+    let root = tmpdir.join(\"foo\");\n+\n+    println!(\"making {}\", root.display());\n+    fs::mkdir(&root, rwx);\n+    fs::mkdir(&root.join(\"foo\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n+    fs::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n+    fs::rmdir_recursive(&root);\n+    assert!(!root.exists());\n+    assert!(!root.join(\"bar\").exists());\n+    assert!(!root.join(\"bar\").join(\"blat\").exists());\n+}\n+\n+pub fn dont_double_panic() {\n+    let r: Result<(), _> = thread::spawn(move|| {\n+        let tmpdir = TempDir::new(\"test\").unwrap();\n+        // Remove the temporary directory so that TempDir sees\n+        // an error on drop\n+        fs::rmdir(tmpdir.path());\n+        // Panic. If TempDir panics *again* due to the rmdir\n+        // error then the process will abort.\n+        panic!();\n+    }).join();\n+    assert!(r.is_err());\n+}\n+\n+fn in_tmpdir<F>(f: F) where F: FnOnce() {\n+    let tmpdir = TempDir::new(\"test\").ok().expect(\"can't make tmpdir\");\n+    assert!(env::set_current_dir(tmpdir.path().as_str().unwrap()).is_ok());\n+\n+    f();\n+}\n+\n+pub fn main() {\n+    in_tmpdir(test_tempdir);\n+    in_tmpdir(test_rm_tempdir);\n+    in_tmpdir(test_rm_tempdir_close);\n+    in_tmpdir(recursive_mkdir_rel);\n+    in_tmpdir(recursive_mkdir_dot);\n+    in_tmpdir(recursive_mkdir_rel_2);\n+    in_tmpdir(test_rmdir_recursive_ok);\n+    in_tmpdir(dont_double_panic);\n+}"}, {"sha": "184338c3294ff9290502609af17cd762263705d3", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -15,7 +15,7 @@ use std::thread;\n pub fn main() {\n     let mut i = 10;\n     while i > 0 {\n-        thread::scoped({let i = i; move|| child(i)});\n+        thread::spawn({let i = i; move|| child(i)}).join();\n         i = i - 1;\n     }\n     println!(\"main thread exiting\");"}, {"sha": "21205a2d7fa590427a4ee581e2f74d6535430610", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -83,16 +83,19 @@ pub fn main() {\n                             box dogge2 as Box<Pet+Sync+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    let _t1 = thread::scoped(move|| { check_legs(arc1); tx1.send(()); });\n+    let t1 = thread::spawn(move|| { check_legs(arc1); tx1.send(()); });\n     let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    let _t2 = thread::scoped(move|| { check_names(arc2); tx2.send(()); });\n+    let t2 = thread::spawn(move|| { check_names(arc2); tx2.send(()); });\n     let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    let _t3 = thread::scoped(move|| { check_pedigree(arc3); tx3.send(()); });\n+    let t3 = thread::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n     rx1.recv();\n     rx2.recv();\n     rx3.recv();\n+    t1.join();\n+    t2.join();\n+    t3.join();\n }\n \n fn check_legs(arc: Arc<Vec<Box<Pet+Sync+Send>>>) {"}, {"sha": "c32483f629e03dd4d6130e8602a38834a550ad99", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -23,10 +23,10 @@ pub fn main() {\n     let (tx, rx) = channel();\n     let n = 100;\n     let mut expected = 0;\n-    let _t = (0..n).map(|i| {\n+    let ts = (0..n).map(|i| {\n         expected += i;\n         let tx = tx.clone();\n-        thread::scoped(move|| {\n+        thread::spawn(move|| {\n             child(&tx, i)\n         })\n     }).collect::<Vec<_>>();\n@@ -38,4 +38,6 @@ pub fn main() {\n     }\n \n     assert_eq!(expected, actual);\n+\n+    for t in ts { t.join(); }\n }"}]}