{"sha": "81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZTZiNTA5NGViMWMyZmJmNTE4NGI2OTUyYTFhM2RkZjY0N2JmN2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T11:14:30Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T11:14:30Z"}, "message": "parser: split into expr.rs", "tree": {"sha": "61581689cea22f6672c846729e34dacca024b6cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61581689cea22f6672c846729e34dacca024b6cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "html_url": "https://github.com/rust-lang/rust/commit/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee36cfaff97116bcc6230408015dbeb3fb5e2bb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee36cfaff97116bcc6230408015dbeb3fb5e2bb9", "html_url": "https://github.com/rust-lang/rust/commit/ee36cfaff97116bcc6230408015dbeb3fb5e2bb9"}], "stats": {"total": 3539, "additions": 1792, "deletions": 1747}, "files": [{"sha": "260381b575c05a5098b46ae37755caa1e03a1fe4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 89, "deletions": 1747, "changes": 1836, "blob_url": "https://github.com/rust-lang/rust/blob/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "patch": "@@ -1,21 +1,23 @@\n // ignore-tidy-filelength\n \n+mod expr;\n+use expr::LhsExpr;\n+\n use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n-use crate::ast::Block;\n-use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n+use crate::ast::{Mod, AnonConst, Arg, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::{Block, BlockCheckMode};\n use crate::ast::{Constness, Crate};\n use crate::ast::Defaultness;\n use crate::ast::EnumDef;\n-use crate::ast::{Expr, ExprKind, RangeLimits};\n-use crate::ast::{Field, FnDecl, FnHeader};\n+use crate::ast::{Expr, ExprKind};\n+use crate::ast::{FnDecl, FnHeader};\n use crate::ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n-use crate::ast::{Label, Lifetime};\n+use crate::ast::{Lifetime};\n use crate::ast::Local;\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n@@ -30,7 +32,6 @@ use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use crate::ast::{UseTree, UseTreeKind};\n-use crate::ast::{BinOpKind, UnOp};\n use crate::ast::{RangeEnd, RangeSyntax};\n use crate::{ast, attr};\n use crate::ext::base::DummyResult;\n@@ -41,7 +42,6 @@ use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n-use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::parse::PResult;\n@@ -115,41 +115,6 @@ crate enum BlockMode {\n     Ignore,\n }\n \n-/// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n-/// dropped into the token stream, which happens while parsing the result of\n-/// macro expansion). Placement of these is not as complex as I feared it would\n-/// be. The important thing is to make sure that lookahead doesn't balk at\n-/// `token::Interpolated` tokens.\n-macro_rules! maybe_whole_expr {\n-    ($p:expr) => {\n-        if let token::Interpolated(nt) = &$p.token.kind {\n-            match &**nt {\n-                token::NtExpr(e) | token::NtLiteral(e) => {\n-                    let e = e.clone();\n-                    $p.bump();\n-                    return Ok(e);\n-                }\n-                token::NtPath(path) => {\n-                    let path = path.clone();\n-                    $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n-                    ));\n-                }\n-                token::NtBlock(block) => {\n-                    let block = block.clone();\n-                    $p.bump();\n-                    return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n-                    ));\n-                }\n-                // N.B: `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n-                _ => {},\n-            };\n-        }\n-    }\n-}\n-\n /// As maybe_whole_expr, but for things other than expressions\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n@@ -164,6 +129,7 @@ macro_rules! maybe_whole {\n }\n \n /// If the next tokens are ill-formed `$ty::` recover them as `<$ty>::`.\n+#[macro_export]\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n@@ -438,29 +404,6 @@ pub struct ModulePathSuccess {\n     warn: bool,\n }\n \n-#[derive(Debug)]\n-enum LhsExpr {\n-    NotYetParsed,\n-    AttributesParsed(ThinVec<Attribute>),\n-    AlreadyParsed(P<Expr>),\n-}\n-\n-impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n-    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n-        if let Some(attrs) = o {\n-            LhsExpr::AttributesParsed(attrs)\n-        } else {\n-            LhsExpr::NotYetParsed\n-        }\n-    }\n-}\n-\n-impl From<P<Expr>> for LhsExpr {\n-    fn from(expr: P<Expr>) -> Self {\n-        LhsExpr::AlreadyParsed(expr)\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n crate enum TokenExpectType {\n     Expect,\n@@ -602,20 +545,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n-    fn interpolated_or_expr_span(\n-        &self,\n-        expr: PResult<'a, P<Expr>>,\n-    ) -> PResult<'a, (Span, P<Expr>)> {\n-        expr.map(|e| {\n-            if self.prev_token_kind == PrevTokenKind::Interpolated {\n-                (self.prev_span, e)\n-            } else {\n-                (e.span, e)\n-            }\n-        })\n-    }\n-\n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.parse_ident_common(true)\n     }\n@@ -755,7 +684,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-\n     /// Checks to see if the next token is either `+` or `+=`.\n     /// Otherwise returns `false`.\n     fn check_plus(&mut self) -> bool {\n@@ -1622,26 +1550,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n-    crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n-        maybe_whole_expr!(self);\n-\n-        let minus_lo = self.token.span;\n-        let minus_present = self.eat(&token::BinOp(token::Minus));\n-        let lo = self.token.span;\n-        let literal = self.parse_lit()?;\n-        let hi = self.prev_span;\n-        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n-\n-        if minus_present {\n-            let minus_hi = self.prev_span;\n-            let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n-        } else {\n-            Ok(expr)\n-        }\n-    }\n-\n     fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n             token::Ident(name, _) if name.is_path_segment_keyword() => {\n@@ -1862,16 +1770,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn eat_label(&mut self) -> Option<Label> {\n-        if let Some(ident) = self.token.lifetime() {\n-            let span = self.token.span;\n-            self.bump();\n-            Some(Label { ident: Ident::new(ident.name, span) })\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) {\n@@ -1892,86 +1790,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse ident (COLON expr)?\n-    fn parse_field(&mut self) -> PResult<'a, Field> {\n-        let attrs = self.parse_outer_attributes()?;\n-        let lo = self.token.span;\n-\n-        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-        let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| {\n-            t == &token::Colon || t == &token::Eq\n-        }) {\n-            let fieldname = self.parse_field_name()?;\n-\n-            // Check for an equals token. This means the source incorrectly attempts to\n-            // initialize a field with an eq rather than a colon.\n-            if self.token == token::Eq {\n-                self.diagnostic()\n-                    .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n-                    .span_suggestion(\n-                        fieldname.span.shrink_to_hi().to(self.token.span),\n-                        \"replace equals symbol with a colon\",\n-                        \":\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-            }\n-            self.bump(); // `:`\n-            (fieldname, self.parse_expr()?, false)\n-        } else {\n-            let fieldname = self.parse_ident_common(false)?;\n-\n-            // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(fieldname);\n-            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n-            (fieldname, expr, true)\n-        };\n-        Ok(ast::Field {\n-            ident: fieldname,\n-            span: lo.to(expr.span),\n-            expr,\n-            is_shorthand,\n-            attrs: attrs.into(),\n-        })\n-    }\n-\n-    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n-        P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n-    }\n-\n-    fn mk_unary(&self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind {\n-        ExprKind::Unary(unop, expr)\n-    }\n-\n-    fn mk_binary(&self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n-        ExprKind::Binary(binop, lhs, rhs)\n-    }\n-\n-    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind {\n-        ExprKind::Call(f, args)\n-    }\n-\n-    fn mk_index(&self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind {\n-        ExprKind::Index(expr, idx)\n-    }\n-\n-    fn mk_range(&self,\n-                    start: Option<P<Expr>>,\n-                    end: Option<P<Expr>>,\n-                    limits: RangeLimits)\n-                    -> PResult<'a, ast::ExprKind> {\n-        if end.is_none() && limits == RangeLimits::Closed {\n-            Err(self.span_fatal_err(self.token.span, Error::InclusiveRangeWithNoEnd))\n-        } else {\n-            Ok(ExprKind::Range(start, end, limits))\n-        }\n-    }\n-\n-    fn mk_assign_op(&self, binop: ast::BinOp,\n-                        lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n-        ExprKind::AssignOp(binop, lhs, rhs)\n-    }\n-\n     fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n         let delim = match self.token.kind {\n             token::OpenDelim(delim) => delim,\n@@ -1995,1535 +1813,104 @@ impl<'a> Parser<'a> {\n         Ok((delim, tts.into()))\n     }\n \n-    /// At the bottom (top?) of the precedence hierarchy,\n-    /// Parses things like parenthesized exprs, macros, `return`, etc.\n-    ///\n-    /// N.B., this does not parse outer attributes, and is private because it only works\n-    /// correctly if called from `parse_dot_or_call_expr()`.\n-    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        maybe_recover_from_interpolated_ty_qpath!(self, true);\n-        maybe_whole_expr!(self);\n-\n-        // Outer attributes are already parsed and will be\n-        // added to the return value after the fact.\n-        //\n-        // Therefore, prevent sub-parser from parsing\n-        // attributes by giving them a empty \"already parsed\" list.\n-        let mut attrs = ThinVec::new();\n-\n-        let lo = self.token.span;\n-        let mut hi = self.token.span;\n-\n-        let ex: ExprKind;\n-\n-        macro_rules! parse_lit {\n-            () => {\n-                match self.parse_lit() {\n-                    Ok(literal) => {\n-                        hi = self.prev_span;\n-                        ex = ExprKind::Lit(literal);\n-                    }\n-                    Err(mut err) => {\n-                        self.cancel(&mut err);\n-                        return Err(self.expected_expression_found());\n-                    }\n-                }\n-            }\n+    fn parse_or_use_outer_attributes(&mut self,\n+                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n+                                     -> PResult<'a, ThinVec<Attribute>> {\n+        if let Some(attrs) = already_parsed_attrs {\n+            Ok(attrs)\n+        } else {\n+            self.parse_outer_attributes().map(|a| a.into())\n         }\n+    }\n \n-        // Note: when adding new syntax here, don't forget to adjust TokenKind::can_begin_expr().\n-        match self.token.kind {\n-            // This match arm is a special-case of the `_` match arm below and\n-            // could be removed without changing functionality, but it's faster\n-            // to have it here, especially for programs with large constants.\n-            token::Literal(_) => {\n-                parse_lit!()\n-            }\n-            token::OpenDelim(token::Paren) => {\n+    crate fn process_potential_macro_variable(&mut self) {\n+        self.token = match self.token.kind {\n+            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n+                             self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n-\n-                attrs.extend(self.parse_inner_attributes()?);\n-\n-                // (e) is parenthesized e\n-                // (e,) is a tuple with only one field, e\n-                let mut es = vec![];\n-                let mut trailing_comma = false;\n-                let mut recovered = false;\n-                while self.token != token::CloseDelim(token::Paren) {\n-                    es.push(match self.parse_expr() {\n-                        Ok(es) => es,\n-                        Err(mut err) => {\n-                            // recover from parse error in tuple list\n-                            match self.token.kind {\n-                                token::Ident(name, false)\n-                                if name == kw::Underscore && self.look_ahead(1, |t| {\n-                                    t == &token::Comma\n-                                }) => {\n-                                    // Special-case handling of `Foo<(_, _, _)>`\n-                                    err.emit();\n-                                    let sp = self.token.span;\n-                                    self.bump();\n-                                    self.mk_expr(sp, ExprKind::Err, ThinVec::new())\n-                                }\n-                                _ => return Ok(\n-                                    self.recover_seq_parse_error(token::Paren, lo, Err(err)),\n-                                ),\n-                            }\n-                        }\n-                    });\n-                    recovered = self.expect_one_of(\n-                        &[],\n-                        &[token::Comma, token::CloseDelim(token::Paren)],\n-                    )?;\n-                    if self.eat(&token::Comma) {\n-                        trailing_comma = true;\n-                    } else {\n-                        trailing_comma = false;\n-                        break;\n-                    }\n-                }\n-                if !recovered {\n-                    self.bump();\n-                }\n-\n-                hi = self.prev_span;\n-                ex = if es.len() == 1 && !trailing_comma {\n-                    ExprKind::Paren(es.into_iter().nth(0).unwrap())\n-                } else {\n-                    ExprKind::Tup(es)\n+                let name = match self.token.kind {\n+                    token::Ident(name, _) => name,\n+                    _ => unreachable!()\n                 };\n-            }\n-            token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n-            }\n-            token::BinOp(token::Or) | token::OrOr => {\n-                return self.parse_lambda_expr(attrs);\n-            }\n-            token::OpenDelim(token::Bracket) => {\n+                let span = self.prev_span.to(self.token.span);\n+                self.diagnostic()\n+                    .struct_span_fatal(span, &format!(\"unknown macro variable `{}`\", name))\n+                    .span_label(span, \"unknown macro variable\")\n+                    .emit();\n                 self.bump();\n-\n-                attrs.extend(self.parse_inner_attributes()?);\n-\n-                if self.eat(&token::CloseDelim(token::Bracket)) {\n-                    // Empty vector.\n-                    ex = ExprKind::Array(Vec::new());\n-                } else {\n-                    // Nonempty vector.\n-                    let first_expr = self.parse_expr()?;\n-                    if self.eat(&token::Semi) {\n-                        // Repeating array syntax: [ 0; 512 ]\n-                        let count = AnonConst {\n-                            id: ast::DUMMY_NODE_ID,\n-                            value: self.parse_expr()?,\n-                        };\n-                        self.expect(&token::CloseDelim(token::Bracket))?;\n-                        ex = ExprKind::Repeat(first_expr, count);\n-                    } else if self.eat(&token::Comma) {\n-                        // Vector with two or more elements.\n-                        let remaining_exprs = self.parse_seq_to_end(\n-                            &token::CloseDelim(token::Bracket),\n-                            SeqSep::trailing_allowed(token::Comma),\n-                            |p| Ok(p.parse_expr()?)\n-                        )?;\n-                        let mut exprs = vec![first_expr];\n-                        exprs.extend(remaining_exprs);\n-                        ex = ExprKind::Array(exprs);\n-                    } else {\n-                        // Vector with one element.\n-                        self.expect(&token::CloseDelim(token::Bracket))?;\n-                        ex = ExprKind::Array(vec![first_expr]);\n-                    }\n-                }\n-                hi = self.prev_span;\n+                return\n             }\n-            _ => {\n-                if self.eat_lt() {\n-                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n-                    hi = path.span;\n-                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n-                }\n-                if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n-                    return self.parse_lambda_expr(attrs);\n-                }\n-                if self.eat_keyword(kw::If) {\n-                    return self.parse_if_expr(attrs);\n-                }\n-                if self.eat_keyword(kw::For) {\n-                    let lo = self.prev_span;\n-                    return self.parse_for_expr(None, lo, attrs);\n-                }\n-                if self.eat_keyword(kw::While) {\n-                    let lo = self.prev_span;\n-                    return self.parse_while_expr(None, lo, attrs);\n-                }\n-                if let Some(label) = self.eat_label() {\n-                    let lo = label.ident.span;\n-                    self.expect(&token::Colon)?;\n-                    if self.eat_keyword(kw::While) {\n-                        return self.parse_while_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.eat_keyword(kw::For) {\n-                        return self.parse_for_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.eat_keyword(kw::Loop) {\n-                        return self.parse_loop_expr(Some(label), lo, attrs)\n-                    }\n-                    if self.token == token::OpenDelim(token::Brace) {\n-                        return self.parse_block_expr(Some(label),\n-                                                     lo,\n-                                                     BlockCheckMode::Default,\n-                                                     attrs);\n-                    }\n-                    let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-                    let mut err = self.fatal(msg);\n-                    err.span_label(self.token.span, msg);\n-                    return Err(err);\n-                }\n-                if self.eat_keyword(kw::Loop) {\n-                    let lo = self.prev_span;\n-                    return self.parse_loop_expr(None, lo, attrs);\n-                }\n-                if self.eat_keyword(kw::Continue) {\n-                    let label = self.eat_label();\n-                    let ex = ExprKind::Continue(label);\n-                    let hi = self.prev_span;\n-                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n-                }\n-                if self.eat_keyword(kw::Match) {\n-                    let match_sp = self.prev_span;\n-                    return self.parse_match_expr(attrs).map_err(|mut err| {\n-                        err.span_label(match_sp, \"while parsing this match expression\");\n-                        err\n-                    });\n-                }\n-                if self.eat_keyword(kw::Unsafe) {\n-                    return self.parse_block_expr(\n-                        None,\n-                        lo,\n-                        BlockCheckMode::Unsafe(ast::UserProvided),\n-                        attrs);\n-                }\n-                if self.is_do_catch_block() {\n-                    let mut db = self.fatal(\"found removed `do catch` syntax\");\n-                    db.help(\"Following RFC #2388, the new non-placeholder syntax is `try`\");\n-                    return Err(db);\n-                }\n-                if self.is_try_block() {\n-                    let lo = self.token.span;\n-                    assert!(self.eat_keyword(kw::Try));\n-                    return self.parse_try_block(lo, attrs);\n+            token::Interpolated(ref nt) => {\n+                self.meta_var_span = Some(self.token.span);\n+                // Interpolated identifier and lifetime tokens are replaced with usual identifier\n+                // and lifetime tokens, so the former are never encountered during normal parsing.\n+                match **nt {\n+                    token::NtIdent(ident, is_raw) =>\n+                        Token::new(token::Ident(ident.name, is_raw), ident.span),\n+                    token::NtLifetime(ident) =>\n+                        Token::new(token::Lifetime(ident.name), ident.span),\n+                    _ => return,\n                 }\n+            }\n+            _ => return,\n+        };\n+    }\n \n-                // Span::rust_2018() is somewhat expensive; don't get it repeatedly.\n-                let is_span_rust_2018 = self.token.span.rust_2018();\n-                if is_span_rust_2018 && self.check_keyword(kw::Async) {\n-                    return if self.is_async_block() { // check for `async {` and `async move {`\n-                        self.parse_async_block(attrs)\n-                    } else {\n-                        self.parse_lambda_expr(attrs)\n-                    };\n-                }\n-                if self.eat_keyword(kw::Return) {\n-                    if self.token.can_begin_expr() {\n-                        let e = self.parse_expr()?;\n-                        hi = e.span;\n-                        ex = ExprKind::Ret(Some(e));\n-                    } else {\n-                        ex = ExprKind::Ret(None);\n-                    }\n-                } else if self.eat_keyword(kw::Break) {\n-                    let label = self.eat_label();\n-                    let e = if self.token.can_begin_expr()\n-                               && !(self.token == token::OpenDelim(token::Brace)\n-                                    && self.restrictions.contains(\n-                                           Restrictions::NO_STRUCT_LITERAL)) {\n-                        Some(self.parse_expr()?)\n-                    } else {\n-                        None\n-                    };\n-                    ex = ExprKind::Break(label, e);\n-                    hi = self.prev_span;\n-                } else if self.eat_keyword(kw::Yield) {\n-                    if self.token.can_begin_expr() {\n-                        let e = self.parse_expr()?;\n-                        hi = e.span;\n-                        ex = ExprKind::Yield(Some(e));\n-                    } else {\n-                        ex = ExprKind::Yield(None);\n-                    }\n-                } else if self.eat_keyword(kw::Let) {\n-                    return self.parse_let_expr(attrs);\n-                } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n-                    let (await_hi, e_kind) = self.parse_incorrect_await_syntax(lo, self.prev_span)?;\n-                    hi = await_hi;\n-                    ex = e_kind;\n-                } else if self.token.is_path_start() {\n-                    let path = self.parse_path(PathStyle::Expr)?;\n-\n-                    // `!`, as an operator, is prefix, so we know this isn't that\n-                    if self.eat(&token::Not) {\n-                        // MACRO INVOCATION expression\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        hi = self.prev_span;\n-                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ {\n-                            path,\n-                            tts,\n-                            delim,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        }));\n-                    } else if self.check(&token::OpenDelim(token::Brace)) {\n-                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n-                            return expr;\n-                        } else {\n-                            hi = path.span;\n-                            ex = ExprKind::Path(None, path);\n-                        }\n-                    } else {\n-                        hi = path.span;\n-                        ex = ExprKind::Path(None, path);\n-                    }\n-                } else {\n-                    if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n-                        // Don't complain about bare semicolons after unclosed braces\n-                        // recovery in order to keep the error count down. Fixing the\n-                        // delimiters will possibly also fix the bare semicolon found in\n-                        // expression context. For example, silence the following error:\n-                        // ```\n-                        // error: expected expression, found `;`\n-                        //  --> file.rs:2:13\n-                        //   |\n-                        // 2 |     foo(bar(;\n-                        //   |             ^ expected expression\n-                        // ```\n-                        self.bump();\n-                        return Ok(self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()));\n-                    }\n-                    parse_lit!()\n-                }\n+    /// Parses a single token tree from the input.\n+    crate fn parse_token_tree(&mut self) -> TokenTree {\n+        match self.token.kind {\n+            token::OpenDelim(..) => {\n+                let frame = mem::replace(&mut self.token_cursor.frame,\n+                                         self.token_cursor.stack.pop().unwrap());\n+                self.token.span = frame.span.entire();\n+                self.bump();\n+                TokenTree::Delimited(\n+                    frame.span,\n+                    frame.delim,\n+                    frame.tree_cursor.stream.into(),\n+                )\n+            },\n+            token::CloseDelim(_) | token::Eof => unreachable!(),\n+            _ => {\n+                let token = self.token.take();\n+                self.bump();\n+                TokenTree::Token(token)\n             }\n         }\n-\n-        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    fn maybe_parse_struct_expr(\n-        &mut self,\n-        lo: Span,\n-        path: &ast::Path,\n-        attrs: &ThinVec<Attribute>,\n-    ) -> Option<PResult<'a, P<Expr>>> {\n-        let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n-        let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n-            // `{ ident, ` cannot start a block\n-            self.look_ahead(2, |t| t == &token::Comma) ||\n-            self.look_ahead(2, |t| t == &token::Colon) && (\n-                // `{ ident: token, ` cannot start a block\n-                self.look_ahead(4, |t| t == &token::Comma) ||\n-                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`\n-                self.look_ahead(3, |t| !t.can_begin_type())\n-            )\n-        );\n+    /// Parses a stream of tokens into a list of `TokenTree`s, up to EOF.\n+    pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n+        let mut tts = Vec::new();\n+        while self.token != token::Eof {\n+            tts.push(self.parse_token_tree());\n+        }\n+        Ok(tts)\n+    }\n \n-        if struct_allowed || certainly_not_a_block() {\n-            // This is a struct literal, but we don't can't accept them here\n-            let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n-            if let (Ok(expr), false) = (&expr, struct_allowed) {\n-                self.struct_span_err(\n-                    expr.span,\n-                    \"struct literals are not allowed here\",\n-                )\n-                .multipart_suggestion(\n-                    \"surround the struct literal with parentheses\",\n-                    vec![\n-                        (lo.shrink_to_lo(), \"(\".to_string()),\n-                        (expr.span.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+    pub fn parse_tokens(&mut self) -> TokenStream {\n+        let mut result = Vec::new();\n+        loop {\n+            match self.token.kind {\n+                token::Eof | token::CloseDelim(..) => break,\n+                _ => result.push(self.parse_token_tree().into()),\n             }\n-            return Some(expr);\n         }\n-        None\n+        TokenStream::new(result)\n     }\n \n-    fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n-                         -> PResult<'a, P<Expr>> {\n-        let struct_sp = lo.to(self.prev_span);\n-        self.bump();\n-        let mut fields = Vec::new();\n-        let mut base = None;\n+    /// Evaluates the closure with restrictions in place.\n+    ///\n+    /// Afters the closure is evaluated, restrictions are reset.\n+    fn with_res<F, T>(&mut self, r: Restrictions, f: F) -> T\n+        where F: FnOnce(&mut Self) -> T\n+    {\n+        let old = self.restrictions;\n+        self.restrictions = r;\n+        let r = f(self);\n+        self.restrictions = old;\n+        return r;\n \n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        while self.token != token::CloseDelim(token::Brace) {\n-            if self.eat(&token::DotDot) {\n-                let exp_span = self.prev_span;\n-                match self.parse_expr() {\n-                    Ok(e) => {\n-                        base = Some(e);\n-                    }\n-                    Err(mut e) => {\n-                        e.emit();\n-                        self.recover_stmt();\n-                    }\n-                }\n-                if self.token == token::Comma {\n-                    self.struct_span_err(\n-                        exp_span.to(self.prev_span),\n-                        \"cannot use a comma after the base struct\",\n-                    )\n-                    .span_suggestion_short(\n-                        self.token.span,\n-                        \"remove this comma\",\n-                        String::new(),\n-                        Applicability::MachineApplicable\n-                    )\n-                    .note(\"the base struct must always be the last field\")\n-                    .emit();\n-                    self.recover_stmt();\n-                }\n-                break;\n-            }\n-\n-            let mut recovery_field = None;\n-            if let token::Ident(name, _) = self.token.kind {\n-                if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                    // Use in case of error after field-looking code: `S { foo: () with a }`\n-                    recovery_field = Some(ast::Field {\n-                        ident: Ident::new(name, self.token.span),\n-                        span: self.token.span,\n-                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n-                        is_shorthand: false,\n-                        attrs: ThinVec::new(),\n-                    });\n-                }\n-            }\n-            let mut parsed_field = None;\n-            match self.parse_field() {\n-                Ok(f) => parsed_field = Some(f),\n-                Err(mut e) => {\n-                    e.span_label(struct_sp, \"while parsing this struct\");\n-                    e.emit();\n-\n-                    // If the next token is a comma, then try to parse\n-                    // what comes next as additional fields, rather than\n-                    // bailing out until next `}`.\n-                    if self.token != token::Comma {\n-                        self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n-                        if self.token != token::Comma {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            match self.expect_one_of(&[token::Comma],\n-                                     &[token::CloseDelim(token::Brace)]) {\n-                Ok(_) => if let Some(f) = parsed_field.or(recovery_field) {\n-                    // only include the field if there's no parse error for the field name\n-                    fields.push(f);\n-                }\n-                Err(mut e) => {\n-                    if let Some(f) = recovery_field {\n-                        fields.push(f);\n-                    }\n-                    e.span_label(struct_sp, \"while parsing this struct\");\n-                    e.emit();\n-                    self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n-                    self.eat(&token::Comma);\n-                }\n-            }\n-        }\n-\n-        let span = lo.to(self.token.span);\n-        self.expect(&token::CloseDelim(token::Brace))?;\n-        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n-    }\n-\n-    fn parse_or_use_outer_attributes(&mut self,\n-                                     already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                                     -> PResult<'a, ThinVec<Attribute>> {\n-        if let Some(attrs) = already_parsed_attrs {\n-            Ok(attrs)\n-        } else {\n-            self.parse_outer_attributes().map(|a| a.into())\n-        }\n-    }\n-\n-    /// Parses a block or unsafe block.\n-    crate fn parse_block_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        lo: Span,\n-        blk_mode: BlockCheckMode,\n-        outer_attrs: ThinVec<Attribute>,\n-    ) -> PResult<'a, P<Expr>> {\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        let mut attrs = outer_attrs;\n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        let blk = self.parse_block_tail(lo, blk_mode)?;\n-        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs));\n-    }\n-\n-    /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n-    fn parse_dot_or_call_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n-    ) -> PResult<'a, P<Expr>> {\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-\n-        let b = self.parse_bottom_expr();\n-        let (span, b) = self.interpolated_or_expr_span(b)?;\n-        self.parse_dot_or_call_expr_with(b, span, attrs)\n-    }\n-\n-    fn parse_dot_or_call_expr_with(\n-        &mut self,\n-        e0: P<Expr>,\n-        lo: Span,\n-        mut attrs: ThinVec<Attribute>,\n-    ) -> PResult<'a, P<Expr>> {\n-        // Stitch the list of outer attributes onto the return value.\n-        // A little bit ugly, but the best way given the current code\n-        // structure\n-        self.parse_dot_or_call_expr_with_(e0, lo).map(|expr|\n-            expr.map(|mut expr| {\n-                attrs.extend::<Vec<_>>(expr.attrs.into());\n-                expr.attrs = attrs;\n-                match expr.node {\n-                    ExprKind::If(..) if !expr.attrs.is_empty() => {\n-                        // Just point to the first attribute in there...\n-                        let span = expr.attrs[0].span;\n-                        self.span_err(span, \"attributes are not yet allowed on `if` expressions\");\n-                    }\n-                    _ => {}\n-                }\n-                expr\n-            })\n-        )\n-    }\n-\n-    fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let span = lo.to(self.prev_span);\n-        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), ThinVec::new());\n-        self.recover_from_await_method_call();\n-        Ok(await_expr)\n-    }\n-\n-    /// Assuming we have just parsed `.`, continue parsing into an expression.\n-    fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n-            return self.mk_await_expr(self_arg, lo);\n-        }\n-\n-        let segment = self.parse_path_segment(PathStyle::Expr)?;\n-        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n-\n-        Ok(match self.token.kind {\n-            token::OpenDelim(token::Paren) => {\n-                // Method call `expr.f()`\n-                let mut args = self.parse_paren_expr_seq()?;\n-                args.insert(0, self_arg);\n-\n-                let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n-            }\n-            _ => {\n-                // Field access `expr.f`\n-                if let Some(args) = segment.args {\n-                    self.span_err(args.span(),\n-                                  \"field expressions may not have generic arguments\");\n-                }\n-\n-                let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n-            }\n-        })\n-    }\n-\n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let mut e = e0;\n-        let mut hi;\n-        loop {\n-            // expr?\n-            while self.eat(&token::Question) {\n-                let hi = self.prev_span;\n-                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n-            }\n-\n-            // expr.f\n-            if self.eat(&token::Dot) {\n-                match self.token.kind {\n-                    token::Ident(..) => {\n-                        e = self.parse_dot_suffix(e, lo)?;\n-                    }\n-                    token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n-                        let span = self.token.span;\n-                        self.bump();\n-                        let field = ExprKind::Field(e, Ident::new(symbol, span));\n-                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n-\n-                        self.expect_no_suffix(span, \"a tuple index\", suffix);\n-                    }\n-                    token::Literal(token::Lit { kind: token::Float, symbol, .. }) => {\n-                      self.bump();\n-                      let fstr = symbol.as_str();\n-                      let msg = format!(\"unexpected token: `{}`\", symbol);\n-                      let mut err = self.diagnostic().struct_span_err(self.prev_span, &msg);\n-                      err.span_label(self.prev_span, \"unexpected token\");\n-                      if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n-                          let float = match fstr.parse::<f64>().ok() {\n-                              Some(f) => f,\n-                              None => continue,\n-                          };\n-                          let sugg = pprust::to_string(|s| {\n-                              s.popen();\n-                              s.print_expr(&e);\n-                              s.s.word( \".\");\n-                              s.print_usize(float.trunc() as usize);\n-                              s.pclose();\n-                              s.s.word(\".\");\n-                              s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n-                          });\n-                          err.span_suggestion(\n-                              lo.to(self.prev_span),\n-                              \"try parenthesizing the first index\",\n-                              sugg,\n-                              Applicability::MachineApplicable\n-                          );\n-                      }\n-                      return Err(err);\n-\n-                    }\n-                    _ => {\n-                        // FIXME Could factor this out into non_fatal_unexpected or something.\n-                        let actual = self.this_token_to_string();\n-                        self.span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual));\n-                    }\n-                }\n-                continue;\n-            }\n-            if self.expr_is_complete(&e) { break; }\n-            match self.token.kind {\n-                // expr(...)\n-                token::OpenDelim(token::Paren) => {\n-                    let seq = self.parse_paren_expr_seq().map(|es| {\n-                        let nd = self.mk_call(e, es);\n-                        let hi = self.prev_span;\n-                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n-                    });\n-                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n-                }\n-\n-                // expr[...]\n-                // Could be either an index expression or a slicing expression.\n-                token::OpenDelim(token::Bracket) => {\n-                    self.bump();\n-                    let ix = self.parse_expr()?;\n-                    hi = self.token.span;\n-                    self.expect(&token::CloseDelim(token::Bracket))?;\n-                    let index = self.mk_index(e, ix);\n-                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n-                }\n-                _ => return Ok(e)\n-            }\n-        }\n-        return Ok(e);\n-    }\n-\n-    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n-        self.parse_paren_comma_seq(|p| {\n-            match p.parse_expr() {\n-                Ok(expr) => Ok(expr),\n-                Err(mut err) => match p.token.kind {\n-                    token::Ident(name, false)\n-                    if name == kw::Underscore && p.look_ahead(1, |t| {\n-                        t == &token::Comma\n-                    }) => {\n-                        // Special-case handling of `foo(_, _, _)`\n-                        err.emit();\n-                        let sp = p.token.span;\n-                        p.bump();\n-                        Ok(p.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n-                    }\n-                    _ => Err(err),\n-                },\n-            }\n-        }).map(|(r, _)| r)\n-    }\n-\n-    crate fn process_potential_macro_variable(&mut self) {\n-        self.token = match self.token.kind {\n-            token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n-                             self.look_ahead(1, |t| t.is_ident()) => {\n-                self.bump();\n-                let name = match self.token.kind {\n-                    token::Ident(name, _) => name,\n-                    _ => unreachable!()\n-                };\n-                let span = self.prev_span.to(self.token.span);\n-                self.diagnostic()\n-                    .struct_span_fatal(span, &format!(\"unknown macro variable `{}`\", name))\n-                    .span_label(span, \"unknown macro variable\")\n-                    .emit();\n-                self.bump();\n-                return\n-            }\n-            token::Interpolated(ref nt) => {\n-                self.meta_var_span = Some(self.token.span);\n-                // Interpolated identifier and lifetime tokens are replaced with usual identifier\n-                // and lifetime tokens, so the former are never encountered during normal parsing.\n-                match **nt {\n-                    token::NtIdent(ident, is_raw) =>\n-                        Token::new(token::Ident(ident.name, is_raw), ident.span),\n-                    token::NtLifetime(ident) =>\n-                        Token::new(token::Lifetime(ident.name), ident.span),\n-                    _ => return,\n-                }\n-            }\n-            _ => return,\n-        };\n-    }\n-\n-    /// Parses a single token tree from the input.\n-    crate fn parse_token_tree(&mut self) -> TokenTree {\n-        match self.token.kind {\n-            token::OpenDelim(..) => {\n-                let frame = mem::replace(&mut self.token_cursor.frame,\n-                                         self.token_cursor.stack.pop().unwrap());\n-                self.token.span = frame.span.entire();\n-                self.bump();\n-                TokenTree::Delimited(\n-                    frame.span,\n-                    frame.delim,\n-                    frame.tree_cursor.stream.into(),\n-                )\n-            },\n-            token::CloseDelim(_) | token::Eof => unreachable!(),\n-            _ => {\n-                let token = self.token.take();\n-                self.bump();\n-                TokenTree::Token(token)\n-            }\n-        }\n-    }\n-\n-    /// Parses a stream of tokens into a list of `TokenTree`s, up to EOF.\n-    pub fn parse_all_token_trees(&mut self) -> PResult<'a, Vec<TokenTree>> {\n-        let mut tts = Vec::new();\n-        while self.token != token::Eof {\n-            tts.push(self.parse_token_tree());\n-        }\n-        Ok(tts)\n-    }\n-\n-    pub fn parse_tokens(&mut self) -> TokenStream {\n-        let mut result = Vec::new();\n-        loop {\n-            match self.token.kind {\n-                token::Eof | token::CloseDelim(..) => break,\n-                _ => result.push(self.parse_token_tree().into()),\n-            }\n-        }\n-        TokenStream::new(result)\n-    }\n-\n-    /// Parse a prefix-unary-operator expr\n-    fn parse_prefix_expr(&mut self,\n-                             already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                             -> PResult<'a, P<Expr>> {\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.token.span;\n-        // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n-        let (hi, ex) = match self.token.kind {\n-            token::Not => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Not, e))\n-            }\n-            // Suggest `!` for bitwise negation when encountering a `~`\n-            token::Tilde => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                let span_of_tilde = lo;\n-                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n-                    .span_suggestion_short(\n-                        span_of_tilde,\n-                        \"use `!` to perform bitwise negation\",\n-                        \"!\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    )\n-                    .emit();\n-                (lo.to(span), self.mk_unary(UnOp::Not, e))\n-            }\n-            token::BinOp(token::Minus) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n-            }\n-            token::BinOp(token::Star) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n-            }\n-            token::BinOp(token::And) | token::AndAnd => {\n-                self.expect_and()?;\n-                let m = self.parse_mutability();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), ExprKind::AddrOf(m, e))\n-            }\n-            token::Ident(..) if self.token.is_keyword(kw::Box) => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), ExprKind::Box(e))\n-            }\n-            token::Ident(..) if self.token.is_ident_named(sym::not) => {\n-                // `not` is just an ordinary identifier in Rust-the-language,\n-                // but as `rustc`-the-compiler, we can issue clever diagnostics\n-                // for confused users who really want to say `!`\n-                let token_cannot_continue_expr = |t: &Token| match t.kind {\n-                    // These tokens can start an expression after `!`, but\n-                    // can't continue an expression after an ident\n-                    token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n-                    token::Literal(..) | token::Pound => true,\n-                    _ => t.is_whole_expr(),\n-                };\n-                let cannot_continue_expr = self.look_ahead(1, token_cannot_continue_expr);\n-                if cannot_continue_expr {\n-                    self.bump();\n-                    // Emit the error ...\n-                    self.struct_span_err(\n-                        self.token.span,\n-                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n-                    )\n-                    .span_suggestion_short(\n-                        // Span the `not` plus trailing whitespace to avoid\n-                        // trailing whitespace after the `!` in our suggestion\n-                        self.sess.source_map()\n-                            .span_until_non_whitespace(lo.to(self.token.span)),\n-                        \"use `!` to perform logical negation\",\n-                        \"!\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    )\n-                    .emit();\n-                    // \u2014and recover! (just as if we were in the block\n-                    // for the `token::Not` arm)\n-                    let e = self.parse_prefix_expr(None);\n-                    let (span, e) = self.interpolated_or_expr_span(e)?;\n-                    (lo.to(span), self.mk_unary(UnOp::Not, e))\n-                } else {\n-                    return self.parse_dot_or_call_expr(Some(attrs));\n-                }\n-            }\n-            _ => { return self.parse_dot_or_call_expr(Some(attrs)); }\n-        };\n-        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n-    }\n-\n-    /// Parses an associative expression.\n-    ///\n-    /// This parses an expression accounting for associativity and precedence of the operators in\n-    /// the expression.\n-    #[inline]\n-    fn parse_assoc_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n-    ) -> PResult<'a, P<Expr>> {\n-        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n-    }\n-\n-    /// Parses an associative expression with operators of at least `min_prec` precedence.\n-    fn parse_assoc_expr_with(\n-        &mut self,\n-        min_prec: usize,\n-        lhs: LhsExpr,\n-    ) -> PResult<'a, P<Expr>> {\n-        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n-            expr\n-        } else {\n-            let attrs = match lhs {\n-                LhsExpr::AttributesParsed(attrs) => Some(attrs),\n-                _ => None,\n-            };\n-            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind) {\n-                return self.parse_prefix_range_expr(attrs);\n-            } else {\n-                self.parse_prefix_expr(attrs)?\n-            }\n-        };\n-        let last_type_ascription_set = self.last_type_ascription.is_some();\n-\n-        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n-            (true, None) => {\n-                self.last_type_ascription = None;\n-                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n-                return Ok(lhs);\n-            }\n-            (false, _) => {} // continue parsing the expression\n-            // An exhaustive check is done in the following block, but these are checked first\n-            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n-            // want to keep their span info to improve diagnostics in these cases in a later stage.\n-            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n-            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n-            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n-            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n-            // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n-                self.last_type_ascription = None;\n-                // These cases are ambiguous and can't be identified in the parser alone\n-                let sp = self.sess.source_map().start_point(self.token.span);\n-                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n-                return Ok(lhs);\n-            }\n-            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n-                self.last_type_ascription = None;\n-                return Ok(lhs);\n-            }\n-            (true, Some(_)) => {\n-                // We've found an expression that would be parsed as a statement, but the next\n-                // token implies this should be parsed as an expression.\n-                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.struct_span_err(self.token.span, &format!(\n-                    \"expected expression, found `{}`\",\n-                    pprust::token_to_string(&self.token),\n-                ));\n-                err.span_label(self.token.span, \"expected expression\");\n-                self.sess.expr_parentheses_needed(\n-                    &mut err,\n-                    lhs.span,\n-                    Some(pprust::expr_to_string(&lhs),\n-                ));\n-                err.emit();\n-            }\n-        }\n-        self.expected_tokens.push(TokenType::Operator);\n-        while let Some(op) = AssocOp::from_token(&self.token) {\n-\n-            // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n-            // it refers to. Interpolated identifiers are unwrapped early and never show up here\n-            // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n-            // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n-            let lhs_span = match (self.prev_token_kind, &lhs.node) {\n-                (PrevTokenKind::Interpolated, _) => self.prev_span,\n-                (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n-                    if path.segments.len() == 1 => self.prev_span,\n-                _ => lhs.span,\n-            };\n-\n-            let cur_op_span = self.token.span;\n-            let restrictions = if op.is_assign_like() {\n-                self.restrictions & Restrictions::NO_STRUCT_LITERAL\n-            } else {\n-                self.restrictions\n-            };\n-            let prec = op.precedence();\n-            if prec < min_prec {\n-                break;\n-            }\n-            // Check for deprecated `...` syntax\n-            if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n-                self.err_dotdotdot_syntax(self.token.span);\n-            }\n-\n-            self.bump();\n-            if op.is_comparison() {\n-                self.check_no_chained_comparison(&lhs, &op);\n-            }\n-            // Special cases:\n-            if op == AssocOp::As {\n-                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n-                continue\n-            } else if op == AssocOp::Colon {\n-                let maybe_path = self.could_ascription_be_path(&lhs.node);\n-                self.last_type_ascription = Some((self.prev_span, maybe_path));\n-\n-                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                continue\n-            } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n-                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n-                // generalise it to the Fixity::None code.\n-                //\n-                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n-                // two variants are handled with `parse_prefix_range_expr` call above.\n-                let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n-                } else {\n-                    None\n-                };\n-                let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n-                    x.span\n-                } else {\n-                    cur_op_span\n-                });\n-                let limits = if op == AssocOp::DotDot {\n-                    RangeLimits::HalfOpen\n-                } else {\n-                    RangeLimits::Closed\n-                };\n-\n-                let r = self.mk_range(Some(lhs), rhs, limits)?;\n-                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n-                break\n-            }\n-\n-            let fixity = op.fixity();\n-            let prec_adjustment = match fixity {\n-                Fixity::Right => 0,\n-                Fixity::Left => 1,\n-                // We currently have no non-associative operators that are not handled above by\n-                // the special cases. The code is here only for future convenience.\n-                Fixity::None => 1,\n-            };\n-            let rhs = self.with_res(\n-                restrictions - Restrictions::STMT_EXPR,\n-                |this| this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n-            )?;\n-\n-            // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n-            // including the attributes.\n-            let lhs_span = lhs\n-                .attrs\n-                .iter()\n-                .filter(|a| a.style == AttrStyle::Outer)\n-                .next()\n-                .map_or(lhs_span, |a| a.span);\n-            let span = lhs_span.to(rhs.span);\n-            lhs = match op {\n-                AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n-                AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n-                AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n-                AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n-                AssocOp::Greater | AssocOp::GreaterEqual => {\n-                    let ast_op = op.to_ast_binop().unwrap();\n-                    let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(span, binary, ThinVec::new())\n-                }\n-                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n-                AssocOp::AssignOp(k) => {\n-                    let aop = match k {\n-                        token::Plus =>    BinOpKind::Add,\n-                        token::Minus =>   BinOpKind::Sub,\n-                        token::Star =>    BinOpKind::Mul,\n-                        token::Slash =>   BinOpKind::Div,\n-                        token::Percent => BinOpKind::Rem,\n-                        token::Caret =>   BinOpKind::BitXor,\n-                        token::And =>     BinOpKind::BitAnd,\n-                        token::Or =>      BinOpKind::BitOr,\n-                        token::Shl =>     BinOpKind::Shl,\n-                        token::Shr =>     BinOpKind::Shr,\n-                    };\n-                    let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(span, aopexpr, ThinVec::new())\n-                }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n-                    self.bug(\"AssocOp should have been handled by special case\")\n-                }\n-            };\n-\n-            if let Fixity::None = fixity { break }\n-        }\n-        if last_type_ascription_set {\n-            self.last_type_ascription = None;\n-        }\n-        Ok(lhs)\n-    }\n-\n-    fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n-                           expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n-                           -> PResult<'a, P<Expr>> {\n-        let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n-            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), ThinVec::new())\n-        };\n-\n-        // Save the state of the parser before parsing type normally, in case there is a\n-        // LessThan comparison after this cast.\n-        let parser_snapshot_before_type = self.clone();\n-        match self.parse_ty_no_plus() {\n-            Ok(rhs) => {\n-                Ok(mk_expr(self, rhs))\n-            }\n-            Err(mut type_err) => {\n-                // Rewind to before attempting to parse the type with generics, to recover\n-                // from situations like `x as usize < y` in which we first tried to parse\n-                // `usize < y` as a type with generic arguments.\n-                let parser_snapshot_after_type = self.clone();\n-                mem::replace(self, parser_snapshot_before_type);\n-\n-                match self.parse_path(PathStyle::Expr) {\n-                    Ok(path) => {\n-                        let (op_noun, op_verb) = match self.token.kind {\n-                            token::Lt => (\"comparison\", \"comparing\"),\n-                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n-                            _ => {\n-                                // We can end up here even without `<` being the next token, for\n-                                // example because `parse_ty_no_plus` returns `Err` on keywords,\n-                                // but `parse_path` returns `Ok` on them due to error recovery.\n-                                // Return original error and parser state.\n-                                mem::replace(self, parser_snapshot_after_type);\n-                                return Err(type_err);\n-                            }\n-                        };\n-\n-                        // Successfully parsed the type path leaving a `<` yet to parse.\n-                        type_err.cancel();\n-\n-                        // Report non-fatal diagnostics, keep `x as usize` as an expression\n-                        // in AST and continue parsing.\n-                        let msg = format!(\"`<` is interpreted as a start of generic \\\n-                                           arguments for `{}`, not a {}\", path, op_noun);\n-                        let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr = mk_expr(self, P(Ty {\n-                            span: path.span,\n-                            node: TyKind::Path(None, path),\n-                            id: ast::DUMMY_NODE_ID\n-                        }));\n-\n-                        let expr_str = self.span_to_snippet(expr.span)\n-                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-\n-                        self.struct_span_err(self.token.span, &msg)\n-                            .span_label(\n-                                self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                \"interpreted as generic arguments\"\n-                            )\n-                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n-                            .span_suggestion(\n-                                expr.span,\n-                                &format!(\"try {} the cast value\", op_verb),\n-                                format!(\"({})\", expr_str),\n-                                Applicability::MachineApplicable\n-                            )\n-                            .emit();\n-\n-                        Ok(expr)\n-                    }\n-                    Err(mut path_err) => {\n-                        // Couldn't parse as a path, return original error and parser state.\n-                        path_err.cancel();\n-                        mem::replace(self, parser_snapshot_after_type);\n-                        Err(type_err)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr`\n-    fn parse_prefix_range_expr(&mut self,\n-                               already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                               -> PResult<'a, P<Expr>> {\n-        // Check for deprecated `...` syntax\n-        if self.token == token::DotDotDot {\n-            self.err_dotdotdot_syntax(self.token.span);\n-        }\n-\n-        debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind),\n-                      \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n-                      self.token);\n-        let tok = self.token.clone();\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.token.span;\n-        let mut hi = self.token.span;\n-        self.bump();\n-        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-            // RHS must be parsed with more associativity than the dots.\n-            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n-            Some(self.parse_assoc_expr_with(next_prec,\n-                                            LhsExpr::NotYetParsed)\n-                .map(|x|{\n-                    hi = x.span;\n-                    x\n-                })?)\n-        } else {\n-            None\n-        };\n-        let limits = if tok == token::DotDot {\n-            RangeLimits::HalfOpen\n-        } else {\n-            RangeLimits::Closed\n-        };\n-\n-        let r = self.mk_range(None, opt_end, limits)?;\n-        Ok(self.mk_expr(lo.to(hi), r, attrs))\n-    }\n-\n-    fn is_at_start_of_range_notation_rhs(&self) -> bool {\n-        if self.token.can_begin_expr() {\n-            // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n-            if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n-            }\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n-        let cond = self.parse_cond_expr()?;\n-\n-        // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n-        // verify that the last statement is either an implicit return (no `;`) or an explicit\n-        // return. This won't catch blocks with an explicit `return`, but that would be caught by\n-        // the dead code lint.\n-        if self.eat_keyword(kw::Else) || !cond.returns() {\n-            let sp = self.sess.source_map().next_point(lo);\n-            let mut err = self.diagnostic()\n-                .struct_span_err(sp, \"missing condition for `if` statemement\");\n-            err.span_label(sp, \"expected if condition here\");\n-            return Err(err)\n-        }\n-        let not_block = self.token != token::OpenDelim(token::Brace);\n-        let thn = self.parse_block().map_err(|mut err| {\n-            if not_block {\n-                err.span_label(lo, \"this `if` statement has a condition, but no block\");\n-            }\n-            err\n-        })?;\n-        let mut els: Option<P<Expr>> = None;\n-        let mut hi = thn.span;\n-        if self.eat_keyword(kw::Else) {\n-            let elexpr = self.parse_else_expr()?;\n-            hi = elexpr.span;\n-            els = Some(elexpr);\n-        }\n-        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n-    }\n-\n-    /// Parse the condition of a `if`- or `while`-expression\n-    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n-\n-        if let ExprKind::Let(..) = cond.node {\n-            // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.let_chains_spans.borrow_mut().pop();\n-            debug_assert_eq!(cond.span, last.unwrap());\n-        }\n-\n-        Ok(cond)\n-    }\n-\n-    /// Parses a `let $pats = $expr` pseudo-expression.\n-    /// The `let` token has already been eaten.\n-    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span;\n-        let pats = self.parse_pats()?;\n-        self.expect(&token::Eq)?;\n-        let expr = self.with_res(\n-            Restrictions::NO_STRUCT_LITERAL,\n-            |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n-        )?;\n-        let span = lo.to(expr.span);\n-        self.sess.let_chains_spans.borrow_mut().push(span);\n-        Ok(self.mk_expr(span, ExprKind::Let(pats, expr), attrs))\n-    }\n-\n-    /// Parses `move |args| expr`.\n-    fn parse_lambda_expr(&mut self,\n-                             attrs: ThinVec<Attribute>)\n-                             -> PResult<'a, P<Expr>>\n-    {\n-        let lo = self.token.span;\n-\n-        let movability = if self.eat_keyword(kw::Static) {\n-            Movability::Static\n-        } else {\n-            Movability::Movable\n-        };\n-\n-        let asyncness = if self.token.span.rust_2018() {\n-            self.parse_asyncness()\n-        } else {\n-            IsAsync::NotAsync\n-        };\n-        if asyncness.is_async() {\n-            // Feature gate `async ||` closures.\n-            self.sess.async_closure_spans.borrow_mut().push(self.prev_span);\n-        }\n-\n-        let capture_clause = self.parse_capture_clause();\n-        let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.prev_span;\n-        let body = match decl.output {\n-            FunctionRetTy::Default(_) => {\n-                let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n-                self.parse_expr_res(restrictions, None)?\n-            },\n-            _ => {\n-                // If an explicit return type is given, require a\n-                // block to appear (RFC 968).\n-                let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n-            }\n-        };\n-\n-        Ok(self.mk_expr(\n-            lo.to(body.span),\n-            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n-            attrs))\n-    }\n-\n-    /// `else` token already eaten\n-    fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.eat_keyword(kw::If) {\n-            return self.parse_if_expr(ThinVec::new());\n-        } else {\n-            let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n-        }\n-    }\n-\n-    /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    fn parse_for_expr(\n-        &mut self,\n-        opt_label: Option<Label>,\n-        span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n-    ) -> PResult<'a, P<Expr>> {\n-        // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n-\n-        // Record whether we are about to parse `for (`.\n-        // This is used below for recovery in case of `for ( $stuff ) $block`\n-        // in which case we will suggest `for $stuff $block`.\n-        let begin_paren = match self.token.kind {\n-            token::OpenDelim(token::Paren) => Some(self.token.span),\n-            _ => None,\n-        };\n-\n-        let pat = self.parse_top_level_pat()?;\n-        if !self.eat_keyword(kw::In) {\n-            let in_span = self.prev_span.between(self.token.span);\n-            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n-                .span_suggestion_short(\n-                    in_span,\n-                    \"try adding `in` here\", \" in \".into(),\n-                    // has been misleading, at least in the past (closed Issue #48492)\n-                    Applicability::MaybeIncorrect\n-                )\n-                .emit();\n-        }\n-        let in_span = self.prev_span;\n-        self.check_for_for_in_in_typo(in_span);\n-        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n-\n-        let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n-\n-        let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-\n-        let hi = self.prev_span;\n-        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n-    }\n-\n-    /// Parses a `while` or `while let` expression (`while` token already eaten).\n-    fn parse_while_expr(&mut self, opt_label: Option<Label>,\n-                            span_lo: Span,\n-                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let cond = self.parse_cond_expr()?;\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs))\n-    }\n-\n-    /// Parse `loop {...}`, `loop` token already eaten.\n-    fn parse_loop_expr(&mut self, opt_label: Option<Label>,\n-                           span_lo: Span,\n-                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        let span = span_lo.to(body.span);\n-        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n-    }\n-\n-    /// Parse an optional `move` prefix to a closure lke construct.\n-    fn parse_capture_clause(&mut self) -> CaptureBy {\n-        if self.eat_keyword(kw::Move) {\n-            CaptureBy::Value\n-        } else {\n-            CaptureBy::Ref\n-        }\n-    }\n-\n-    /// Parses an `async move? {...}` expression.\n-    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let span_lo = self.token.span;\n-        self.expect_keyword(kw::Async)?;\n-        let capture_clause = self.parse_capture_clause();\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        Ok(self.mk_expr(\n-            span_lo.to(body.span),\n-            ExprKind::Async(capture_clause, ast::DUMMY_NODE_ID, body), attrs))\n-    }\n-\n-    /// Parses a `try {...}` expression (`try` token already eaten).\n-    fn parse_try_block(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)\n-        -> PResult<'a, P<Expr>>\n-    {\n-        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n-        attrs.extend(iattrs);\n-        if self.eat_keyword(kw::Catch) {\n-            let mut error = self.struct_span_err(self.prev_span,\n-                                                 \"keyword `catch` cannot follow a `try` block\");\n-            error.help(\"try using `match` on the result of the `try` block instead\");\n-            error.emit();\n-            Err(error)\n-        } else {\n-            Ok(self.mk_expr(span_lo.to(body.span), ExprKind::TryBlock(body), attrs))\n-        }\n-    }\n-\n-    // `match` token already eaten\n-    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n-        let match_span = self.prev_span;\n-        let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL,\n-                                               None)?;\n-        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n-            if self.token == token::Semi {\n-                e.span_suggestion_short(\n-                    match_span,\n-                    \"try removing this `match`\",\n-                    String::new(),\n-                    Applicability::MaybeIncorrect // speculative\n-                );\n-            }\n-            return Err(e)\n-        }\n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        let mut arms: Vec<Arm> = Vec::new();\n-        while self.token != token::CloseDelim(token::Brace) {\n-            match self.parse_arm() {\n-                Ok(arm) => arms.push(arm),\n-                Err(mut e) => {\n-                    // Recover by skipping to the end of the block.\n-                    e.emit();\n-                    self.recover_stmt();\n-                    let span = lo.to(self.token.span);\n-                    if self.token == token::CloseDelim(token::Brace) {\n-                        self.bump();\n-                    }\n-                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n-                }\n-            }\n-        }\n-        let hi = self.token.span;\n-        self.bump();\n-        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n-    }\n-\n-    crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n-        let attrs = self.parse_outer_attributes()?;\n-        let lo = self.token.span;\n-        let pats = self.parse_pats()?;\n-        let guard = if self.eat_keyword(kw::If) {\n-            Some(self.parse_expr()?)\n-        } else {\n-            None\n-        };\n-        let arrow_span = self.token.span;\n-        self.expect(&token::FatArrow)?;\n-        let arm_start_span = self.token.span;\n-\n-        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)\n-            .map_err(|mut err| {\n-                err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n-                err\n-            })?;\n-\n-        let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n-            && self.token != token::CloseDelim(token::Brace);\n-\n-        let hi = self.token.span;\n-\n-        if require_comma {\n-            let cm = self.sess.source_map();\n-            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n-                .map_err(|mut err| {\n-                    match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n-                        (Ok(ref expr_lines), Ok(ref arm_start_lines))\n-                        if arm_start_lines.lines[0].end_col == expr_lines.lines[0].end_col\n-                            && expr_lines.lines.len() == 2\n-                            && self.token == token::FatArrow => {\n-                            // We check whether there's any trailing code in the parse span,\n-                            // if there isn't, we very likely have the following:\n-                            //\n-                            // X |     &Y => \"y\"\n-                            //   |        --    - missing comma\n-                            //   |        |\n-                            //   |        arrow_span\n-                            // X |     &X => \"x\"\n-                            //   |      - ^^ self.token.span\n-                            //   |      |\n-                            //   |      parsed until here as `\"y\" & X`\n-                            err.span_suggestion_short(\n-                                cm.next_point(arm_start_span),\n-                                \"missing a comma here to end this `match` arm\",\n-                                \",\".to_owned(),\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n-                        _ => {\n-                            err.span_label(arrow_span,\n-                                           \"while parsing the `match` arm starting here\");\n-                        }\n-                    }\n-                    err\n-                })?;\n-        } else {\n-            self.eat(&token::Comma);\n-        }\n-\n-        Ok(ast::Arm {\n-            attrs,\n-            pats,\n-            guard,\n-            body: expr,\n-            span: lo.to(hi),\n-        })\n-    }\n-\n-    /// Parses an expression.\n-    #[inline]\n-    pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n-        self.parse_expr_res(Restrictions::empty(), None)\n-    }\n-\n-    /// Evaluates the closure with restrictions in place.\n-    ///\n-    /// Afters the closure is evaluated, restrictions are reset.\n-    fn with_res<F, T>(&mut self, r: Restrictions, f: F) -> T\n-        where F: FnOnce(&mut Self) -> T\n-    {\n-        let old = self.restrictions;\n-        self.restrictions = r;\n-        let r = f(self);\n-        self.restrictions = old;\n-        return r;\n-\n-    }\n-\n-    /// Parses an expression, subject to the given restrictions.\n-    #[inline]\n-    fn parse_expr_res(&mut self, r: Restrictions,\n-                          already_parsed_attrs: Option<ThinVec<Attribute>>)\n-                          -> PResult<'a, P<Expr>> {\n-        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n \n     /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n@@ -4277,38 +2664,11 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn is_async_block(&self) -> bool {\n-        self.token.is_keyword(kw::Async) &&\n-        (\n-            ( // `async move {`\n-                self.is_keyword_ahead(1, &[kw::Move]) &&\n-                self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n-            ) || ( // `async {`\n-                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n-            )\n-        )\n-    }\n-\n     fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) &&\n             self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    fn is_do_catch_block(&self) -> bool {\n-        self.token.is_keyword(kw::Do) &&\n-        self.is_keyword_ahead(1, &[kw::Catch]) &&\n-        self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n-        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n-    }\n-\n-    fn is_try_block(&self) -> bool {\n-        self.token.is_keyword(kw::Try) &&\n-        self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.token.span.rust_2018() &&\n-        // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n-        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n-    }\n-\n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(kw::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n@@ -4537,12 +2897,6 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Checks if this expression is a successfully parsed statement.\n-    fn expr_is_complete(&self, e: &Expr) -> bool {\n-        self.restrictions.contains(Restrictions::STMT_EXPR) &&\n-            !classify::expr_requires_semi_to_be_stmt(e)\n-    }\n-\n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);\n@@ -4713,18 +3067,6 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n-    fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.diagnostic().struct_span_err(span, {\n-            \"unexpected token: `...`\"\n-        }).span_suggestion(\n-            span, \"use `..` for an exclusive range\", \"..\".to_owned(),\n-            Applicability::MaybeIncorrect\n-        ).span_suggestion(\n-            span, \"or `..=` for an inclusive range\", \"..=\".to_owned(),\n-            Applicability::MaybeIncorrect\n-        ).emit();\n-    }\n-\n     /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n     ///\n     /// ```"}, {"sha": "88e534394fe1653c70ee6608a57f2b31026a57e1", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "added", "additions": 1703, "deletions": 0, "changes": 1703, "blob_url": "https://github.com/rust-lang/rust/blob/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=81e6b5094eb1c2fbf5184b6952a1a3ddf647bf7a", "patch": "@@ -0,0 +1,1703 @@\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle};\n+use super::{BlockCheckMode, BlockMode, SemiColonMode};\n+use super::SeqSep;\n+\n+use crate::{maybe_recover_from_interpolated_ty_qpath};\n+\n+use crate::ptr::P;\n+use crate::ast;\n+use crate::ast::{Attribute, AttrStyle};\n+use crate::ast::{Ident, CaptureBy};\n+use crate::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n+use crate::ast::{Ty, TyKind, FunctionRetTy};\n+use crate::ast::{BinOpKind, BinOp, UnOp};\n+use crate::ast::{Mac_, AnonConst, Field};\n+\n+use crate::parse::classify;\n+use crate::parse::token::{self, Token};\n+use crate::parse::diagnostics::{Error};\n+use crate::print::pprust;\n+use crate::source_map::{self, respan, Span};\n+use crate::symbol::{kw, sym};\n+use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n+\n+use std::mem;\n+\n+use errors::{Applicability};\n+\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+/// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n+/// dropped into the token stream, which happens while parsing the result of\n+/// macro expansion). Placement of these is not as complex as I feared it would\n+/// be. The important thing is to make sure that lookahead doesn't balk at\n+/// `token::Interpolated` tokens.\n+macro_rules! maybe_whole_expr {\n+    ($p:expr) => {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n+            match &**nt {\n+                token::NtExpr(e) | token::NtLiteral(e) => {\n+                    let e = e.clone();\n+                    $p.bump();\n+                    return Ok(e);\n+                }\n+                token::NtPath(path) => {\n+                    let path = path.clone();\n+                    $p.bump();\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n+                    ));\n+                }\n+                token::NtBlock(block) => {\n+                    let block = block.clone();\n+                    $p.bump();\n+                    return Ok($p.mk_expr(\n+                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n+                    ));\n+                }\n+                // N.B: `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n+                _ => {},\n+            };\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum LhsExpr {\n+    NotYetParsed,\n+    AttributesParsed(ThinVec<Attribute>),\n+    AlreadyParsed(P<Expr>),\n+}\n+\n+impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n+        if let Some(attrs) = o {\n+            LhsExpr::AttributesParsed(attrs)\n+        } else {\n+            LhsExpr::NotYetParsed\n+        }\n+    }\n+}\n+\n+impl From<P<Expr>> for LhsExpr {\n+    fn from(expr: P<Expr>) -> Self {\n+        LhsExpr::AlreadyParsed(expr)\n+    }\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses an expression.\n+    #[inline]\n+    pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        self.parse_expr_res(Restrictions::empty(), None)\n+    }\n+\n+    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n+        self.parse_paren_comma_seq(|p| {\n+            match p.parse_expr() {\n+                Ok(expr) => Ok(expr),\n+                Err(mut err) => match p.token.kind {\n+                    token::Ident(name, false)\n+                    if name == kw::Underscore && p.look_ahead(1, |t| {\n+                        t == &token::Comma\n+                    }) => {\n+                        // Special-case handling of `foo(_, _, _)`\n+                        err.emit();\n+                        let sp = p.token.span;\n+                        p.bump();\n+                        Ok(p.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n+                    }\n+                    _ => Err(err),\n+                },\n+            }\n+        }).map(|(r, _)| r)\n+    }\n+\n+    /// Parses an expression, subject to the given restrictions.\n+    #[inline]\n+    pub(super) fn parse_expr_res(\n+        &mut self,\n+        r: Restrictions,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n+    }\n+\n+    /// Parses an associative expression.\n+    ///\n+    /// This parses an expression accounting for associativity and precedence of the operators in\n+    /// the expression.\n+    #[inline]\n+    fn parse_assoc_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n+        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n+    }\n+\n+    /// Parses an associative expression with operators of at least `min_prec` precedence.\n+    pub(super) fn parse_assoc_expr_with(\n+        &mut self,\n+        min_prec: usize,\n+        lhs: LhsExpr,\n+    ) -> PResult<'a, P<Expr>> {\n+        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n+            expr\n+        } else {\n+            let attrs = match lhs {\n+                LhsExpr::AttributesParsed(attrs) => Some(attrs),\n+                _ => None,\n+            };\n+            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind) {\n+                return self.parse_prefix_range_expr(attrs);\n+            } else {\n+                self.parse_prefix_expr(attrs)?\n+            }\n+        };\n+        let last_type_ascription_set = self.last_type_ascription.is_some();\n+\n+        match (self.expr_is_complete(&lhs), AssocOp::from_token(&self.token)) {\n+            (true, None) => {\n+                self.last_type_ascription = None;\n+                // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n+                return Ok(lhs);\n+            }\n+            (false, _) => {} // continue parsing the expression\n+            // An exhaustive check is done in the following block, but these are checked first\n+            // because they *are* ambiguous but also reasonable looking incorrect syntax, so we\n+            // want to keep their span info to improve diagnostics in these cases in a later stage.\n+            (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n+            (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n+            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n+            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n+            // `if x { a } else { b } && if y { c } else { d }`\n+            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n+                self.last_type_ascription = None;\n+                // These cases are ambiguous and can't be identified in the parser alone\n+                let sp = self.sess.source_map().start_point(self.token.span);\n+                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n+                return Ok(lhs);\n+            }\n+            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => {\n+                self.last_type_ascription = None;\n+                return Ok(lhs);\n+            }\n+            (true, Some(_)) => {\n+                // We've found an expression that would be parsed as a statement, but the next\n+                // token implies this should be parsed as an expression.\n+                // For example: `if let Some(x) = x { x } else { 0 } / 2`\n+                let mut err = self.struct_span_err(self.token.span, &format!(\n+                    \"expected expression, found `{}`\",\n+                    pprust::token_to_string(&self.token),\n+                ));\n+                err.span_label(self.token.span, \"expected expression\");\n+                self.sess.expr_parentheses_needed(\n+                    &mut err,\n+                    lhs.span,\n+                    Some(pprust::expr_to_string(&lhs),\n+                ));\n+                err.emit();\n+            }\n+        }\n+        self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = AssocOp::from_token(&self.token) {\n+\n+            // Adjust the span for interpolated LHS to point to the `$lhs` token and not to what\n+            // it refers to. Interpolated identifiers are unwrapped early and never show up here\n+            // as `PrevTokenKind::Interpolated` so if LHS is a single identifier we always process\n+            // it as \"interpolated\", it doesn't change the answer for non-interpolated idents.\n+            let lhs_span = match (self.prev_token_kind, &lhs.node) {\n+                (PrevTokenKind::Interpolated, _) => self.prev_span,\n+                (PrevTokenKind::Ident, &ExprKind::Path(None, ref path))\n+                    if path.segments.len() == 1 => self.prev_span,\n+                _ => lhs.span,\n+            };\n+\n+            let cur_op_span = self.token.span;\n+            let restrictions = if op.is_assign_like() {\n+                self.restrictions & Restrictions::NO_STRUCT_LITERAL\n+            } else {\n+                self.restrictions\n+            };\n+            let prec = op.precedence();\n+            if prec < min_prec {\n+                break;\n+            }\n+            // Check for deprecated `...` syntax\n+            if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n+                self.err_dotdotdot_syntax(self.token.span);\n+            }\n+\n+            self.bump();\n+            if op.is_comparison() {\n+                self.check_no_chained_comparison(&lhs, &op);\n+            }\n+            // Special cases:\n+            if op == AssocOp::As {\n+                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n+                continue\n+            } else if op == AssocOp::Colon {\n+                let maybe_path = self.could_ascription_be_path(&lhs.node);\n+                self.last_type_ascription = Some((self.prev_span, maybe_path));\n+\n+                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n+                continue\n+            } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n+                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n+                // generalise it to the Fixity::None code.\n+                //\n+                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n+                // two variants are handled with `parse_prefix_range_expr` call above.\n+                let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+                } else {\n+                    None\n+                };\n+                let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    x.span\n+                } else {\n+                    cur_op_span\n+                });\n+                let limits = if op == AssocOp::DotDot {\n+                    RangeLimits::HalfOpen\n+                } else {\n+                    RangeLimits::Closed\n+                };\n+\n+                let r = self.mk_range(Some(lhs), rhs, limits)?;\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n+                break\n+            }\n+\n+            let fixity = op.fixity();\n+            let prec_adjustment = match fixity {\n+                Fixity::Right => 0,\n+                Fixity::Left => 1,\n+                // We currently have no non-associative operators that are not handled above by\n+                // the special cases. The code is here only for future convenience.\n+                Fixity::None => 1,\n+            };\n+            let rhs = self.with_res(\n+                restrictions - Restrictions::STMT_EXPR,\n+                |this| this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n+            )?;\n+\n+            // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n+            // including the attributes.\n+            let lhs_span = lhs\n+                .attrs\n+                .iter()\n+                .filter(|a| a.style == AttrStyle::Outer)\n+                .next()\n+                .map_or(lhs_span, |a| a.span);\n+            let span = lhs_span.to(rhs.span);\n+            lhs = match op {\n+                AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n+                AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n+                AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n+                AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n+                AssocOp::Greater | AssocOp::GreaterEqual => {\n+                    let ast_op = op.to_ast_binop().unwrap();\n+                    let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n+                    self.mk_expr(span, binary, ThinVec::new())\n+                }\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                AssocOp::AssignOp(k) => {\n+                    let aop = match k {\n+                        token::Plus =>    BinOpKind::Add,\n+                        token::Minus =>   BinOpKind::Sub,\n+                        token::Star =>    BinOpKind::Mul,\n+                        token::Slash =>   BinOpKind::Div,\n+                        token::Percent => BinOpKind::Rem,\n+                        token::Caret =>   BinOpKind::BitXor,\n+                        token::And =>     BinOpKind::BitAnd,\n+                        token::Or =>      BinOpKind::BitOr,\n+                        token::Shl =>     BinOpKind::Shl,\n+                        token::Shr =>     BinOpKind::Shr,\n+                    };\n+                    let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n+                    self.mk_expr(span, aopexpr, ThinVec::new())\n+                }\n+                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                    self.bug(\"AssocOp should have been handled by special case\")\n+                }\n+            };\n+\n+            if let Fixity::None = fixity { break }\n+        }\n+        if last_type_ascription_set {\n+            self.last_type_ascription = None;\n+        }\n+        Ok(lhs)\n+    }\n+\n+    /// Checks if this expression is a successfully parsed statement.\n+    fn expr_is_complete(&self, e: &Expr) -> bool {\n+        self.restrictions.contains(Restrictions::STMT_EXPR) &&\n+            !classify::expr_requires_semi_to_be_stmt(e)\n+    }\n+\n+    fn is_at_start_of_range_notation_rhs(&self) -> bool {\n+        if self.token.can_begin_expr() {\n+            // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n+            if self.token == token::OpenDelim(token::Brace) {\n+                return !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr`\n+    fn parse_prefix_range_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        // Check for deprecated `...` syntax\n+        if self.token == token::DotDotDot {\n+            self.err_dotdotdot_syntax(self.token.span);\n+        }\n+\n+        debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token.kind),\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotEq\",\n+                      self.token);\n+        let tok = self.token.clone();\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n+        self.bump();\n+        let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+            // RHS must be parsed with more associativity than the dots.\n+            let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n+            Some(self.parse_assoc_expr_with(next_prec, LhsExpr::NotYetParsed)\n+                .map(|x| {\n+                    hi = x.span;\n+                    x\n+                })?)\n+        } else {\n+            None\n+        };\n+        let limits = if tok == token::DotDot {\n+            RangeLimits::HalfOpen\n+        } else {\n+            RangeLimits::Closed\n+        };\n+\n+        let r = self.mk_range(None, opt_end, limits)?;\n+        Ok(self.mk_expr(lo.to(hi), r, attrs))\n+    }\n+\n+    /// Parse a prefix-unary-operator expr\n+    fn parse_prefix_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>\n+    ) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+        let lo = self.token.span;\n+        // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n+        let (hi, ex) = match self.token.kind {\n+            token::Not => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n+            }\n+            // Suggest `!` for bitwise negation when encountering a `~`\n+            token::Tilde => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                let span_of_tilde = lo;\n+                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n+                    .span_suggestion_short(\n+                        span_of_tilde,\n+                        \"use `!` to perform bitwise negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n+            }\n+            token::BinOp(token::Minus) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n+            }\n+            token::BinOp(token::Star) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n+            }\n+            token::BinOp(token::And) | token::AndAnd => {\n+                self.expect_and()?;\n+                let m = self.parse_mutability();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), ExprKind::AddrOf(m, e))\n+            }\n+            token::Ident(..) if self.token.is_keyword(kw::Box) => {\n+                self.bump();\n+                let e = self.parse_prefix_expr(None);\n+                let (span, e) = self.interpolated_or_expr_span(e)?;\n+                (lo.to(span), ExprKind::Box(e))\n+            }\n+            token::Ident(..) if self.token.is_ident_named(sym::not) => {\n+                // `not` is just an ordinary identifier in Rust-the-language,\n+                // but as `rustc`-the-compiler, we can issue clever diagnostics\n+                // for confused users who really want to say `!`\n+                let token_cannot_continue_expr = |t: &Token| match t.kind {\n+                    // These tokens can start an expression after `!`, but\n+                    // can't continue an expression after an ident\n+                    token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n+                    token::Literal(..) | token::Pound => true,\n+                    _ => t.is_whole_expr(),\n+                };\n+                let cannot_continue_expr = self.look_ahead(1, token_cannot_continue_expr);\n+                if cannot_continue_expr {\n+                    self.bump();\n+                    // Emit the error ...\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n+                    )\n+                    .span_suggestion_short(\n+                        // Span the `not` plus trailing whitespace to avoid\n+                        // trailing whitespace after the `!` in our suggestion\n+                        self.sess.source_map()\n+                            .span_until_non_whitespace(lo.to(self.token.span)),\n+                        \"use `!` to perform logical negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n+                    // \u2014and recover! (just as if we were in the block\n+                    // for the `token::Not` arm)\n+                    let e = self.parse_prefix_expr(None);\n+                    let (span, e) = self.interpolated_or_expr_span(e)?;\n+                    (lo.to(span), self.mk_unary(UnOp::Not, e))\n+                } else {\n+                    return self.parse_dot_or_call_expr(Some(attrs));\n+                }\n+            }\n+            _ => { return self.parse_dot_or_call_expr(Some(attrs)); }\n+        };\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+    }\n+\n+    /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n+    fn interpolated_or_expr_span(\n+        &self,\n+        expr: PResult<'a, P<Expr>>,\n+    ) -> PResult<'a, (Span, P<Expr>)> {\n+        expr.map(|e| {\n+            if self.prev_token_kind == PrevTokenKind::Interpolated {\n+                (self.prev_span, e)\n+            } else {\n+                (e.span, e)\n+            }\n+        })\n+    }\n+\n+    fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n+                           expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n+                           -> PResult<'a, P<Expr>> {\n+        let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n+            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), ThinVec::new())\n+        };\n+\n+        // Save the state of the parser before parsing type normally, in case there is a\n+        // LessThan comparison after this cast.\n+        let parser_snapshot_before_type = self.clone();\n+        match self.parse_ty_no_plus() {\n+            Ok(rhs) => {\n+                Ok(mk_expr(self, rhs))\n+            }\n+            Err(mut type_err) => {\n+                // Rewind to before attempting to parse the type with generics, to recover\n+                // from situations like `x as usize < y` in which we first tried to parse\n+                // `usize < y` as a type with generic arguments.\n+                let parser_snapshot_after_type = self.clone();\n+                mem::replace(self, parser_snapshot_before_type);\n+\n+                match self.parse_path(PathStyle::Expr) {\n+                    Ok(path) => {\n+                        let (op_noun, op_verb) = match self.token.kind {\n+                            token::Lt => (\"comparison\", \"comparing\"),\n+                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n+                            _ => {\n+                                // We can end up here even without `<` being the next token, for\n+                                // example because `parse_ty_no_plus` returns `Err` on keywords,\n+                                // but `parse_path` returns `Ok` on them due to error recovery.\n+                                // Return original error and parser state.\n+                                mem::replace(self, parser_snapshot_after_type);\n+                                return Err(type_err);\n+                            }\n+                        };\n+\n+                        // Successfully parsed the type path leaving a `<` yet to parse.\n+                        type_err.cancel();\n+\n+                        // Report non-fatal diagnostics, keep `x as usize` as an expression\n+                        // in AST and continue parsing.\n+                        let msg = format!(\"`<` is interpreted as a start of generic \\\n+                                           arguments for `{}`, not a {}\", path, op_noun);\n+                        let span_after_type = parser_snapshot_after_type.token.span;\n+                        let expr = mk_expr(self, P(Ty {\n+                            span: path.span,\n+                            node: TyKind::Path(None, path),\n+                            id: ast::DUMMY_NODE_ID\n+                        }));\n+\n+                        let expr_str = self.span_to_snippet(expr.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+\n+                        self.struct_span_err(self.token.span, &msg)\n+                            .span_label(\n+                                self.look_ahead(1, |t| t.span).to(span_after_type),\n+                                \"interpreted as generic arguments\"\n+                            )\n+                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_suggestion(\n+                                expr.span,\n+                                &format!(\"try {} the cast value\", op_verb),\n+                                format!(\"({})\", expr_str),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n+\n+                        Ok(expr)\n+                    }\n+                    Err(mut path_err) => {\n+                        // Couldn't parse as a path, return original error and parser state.\n+                        path_err.cancel();\n+                        mem::replace(self, parser_snapshot_after_type);\n+                        Err(type_err)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n+    fn parse_dot_or_call_expr(\n+        &mut self,\n+        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+    ) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+\n+        let b = self.parse_bottom_expr();\n+        let (span, b) = self.interpolated_or_expr_span(b)?;\n+        self.parse_dot_or_call_expr_with(b, span, attrs)\n+    }\n+\n+    pub(super) fn parse_dot_or_call_expr_with(\n+        &mut self,\n+        e0: P<Expr>,\n+        lo: Span,\n+        mut attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n+        // Stitch the list of outer attributes onto the return value.\n+        // A little bit ugly, but the best way given the current code\n+        // structure\n+        self.parse_dot_or_call_expr_with_(e0, lo).map(|expr|\n+            expr.map(|mut expr| {\n+                attrs.extend::<Vec<_>>(expr.attrs.into());\n+                expr.attrs = attrs;\n+                match expr.node {\n+                    ExprKind::If(..) if !expr.attrs.is_empty() => {\n+                        // Just point to the first attribute in there...\n+                        let span = expr.attrs[0].span;\n+                        self.span_err(span, \"attributes are not yet allowed on `if` expressions\");\n+                    }\n+                    _ => {}\n+                }\n+                expr\n+            })\n+        )\n+    }\n+\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let mut e = e0;\n+        let mut hi;\n+        loop {\n+            // expr?\n+            while self.eat(&token::Question) {\n+                let hi = self.prev_span;\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n+            }\n+\n+            // expr.f\n+            if self.eat(&token::Dot) {\n+                match self.token.kind {\n+                    token::Ident(..) => {\n+                        e = self.parse_dot_suffix(e, lo)?;\n+                    }\n+                    token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n+                        let span = self.token.span;\n+                        self.bump();\n+                        let field = ExprKind::Field(e, Ident::new(symbol, span));\n+                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n+\n+                        self.expect_no_suffix(span, \"a tuple index\", suffix);\n+                    }\n+                    token::Literal(token::Lit { kind: token::Float, symbol, .. }) => {\n+                      self.bump();\n+                      let fstr = symbol.as_str();\n+                      let msg = format!(\"unexpected token: `{}`\", symbol);\n+                      let mut err = self.diagnostic().struct_span_err(self.prev_span, &msg);\n+                      err.span_label(self.prev_span, \"unexpected token\");\n+                      if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n+                          let float = match fstr.parse::<f64>().ok() {\n+                              Some(f) => f,\n+                              None => continue,\n+                          };\n+                          let sugg = pprust::to_string(|s| {\n+                              s.popen();\n+                              s.print_expr(&e);\n+                              s.s.word( \".\");\n+                              s.print_usize(float.trunc() as usize);\n+                              s.pclose();\n+                              s.s.word(\".\");\n+                              s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n+                          });\n+                          err.span_suggestion(\n+                              lo.to(self.prev_span),\n+                              \"try parenthesizing the first index\",\n+                              sugg,\n+                              Applicability::MachineApplicable\n+                          );\n+                      }\n+                      return Err(err);\n+\n+                    }\n+                    _ => {\n+                        // FIXME Could factor this out into non_fatal_unexpected or something.\n+                        let actual = self.this_token_to_string();\n+                        self.span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual));\n+                    }\n+                }\n+                continue;\n+            }\n+            if self.expr_is_complete(&e) { break; }\n+            match self.token.kind {\n+                // expr(...)\n+                token::OpenDelim(token::Paren) => {\n+                    let seq = self.parse_paren_expr_seq().map(|es| {\n+                        let nd = self.mk_call(e, es);\n+                        let hi = self.prev_span;\n+                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                    });\n+                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n+                }\n+\n+                // expr[...]\n+                // Could be either an index expression or a slicing expression.\n+                token::OpenDelim(token::Bracket) => {\n+                    self.bump();\n+                    let ix = self.parse_expr()?;\n+                    hi = self.token.span;\n+                    self.expect(&token::CloseDelim(token::Bracket))?;\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                }\n+                _ => return Ok(e)\n+            }\n+        }\n+        return Ok(e);\n+    }\n+\n+    /// Assuming we have just parsed `.`, continue parsing into an expression.\n+    fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+            return self.mk_await_expr(self_arg, lo);\n+        }\n+\n+        let segment = self.parse_path_segment(PathStyle::Expr)?;\n+        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n+\n+        Ok(match self.token.kind {\n+            token::OpenDelim(token::Paren) => {\n+                // Method call `expr.f()`\n+                let mut args = self.parse_paren_expr_seq()?;\n+                args.insert(0, self_arg);\n+\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n+            }\n+            _ => {\n+                // Field access `expr.f`\n+                if let Some(args) = segment.args {\n+                    self.span_err(args.span(),\n+                                  \"field expressions may not have generic arguments\");\n+                }\n+\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n+            }\n+        })\n+    }\n+\n+\n+    /// At the bottom (top?) of the precedence hierarchy,\n+    /// Parses things like parenthesized exprs, macros, `return`, etc.\n+    ///\n+    /// N.B., this does not parse outer attributes, and is private because it only works\n+    /// correctly if called from `parse_dot_or_call_expr()`.\n+    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, true);\n+        maybe_whole_expr!(self);\n+\n+        // Outer attributes are already parsed and will be\n+        // added to the return value after the fact.\n+        //\n+        // Therefore, prevent sub-parser from parsing\n+        // attributes by giving them a empty \"already parsed\" list.\n+        let mut attrs = ThinVec::new();\n+\n+        let lo = self.token.span;\n+        let mut hi = self.token.span;\n+\n+        let ex: ExprKind;\n+\n+        macro_rules! parse_lit {\n+            () => {\n+                match self.parse_lit() {\n+                    Ok(literal) => {\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Lit(literal);\n+                    }\n+                    Err(mut err) => {\n+                        self.cancel(&mut err);\n+                        return Err(self.expected_expression_found());\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Note: when adding new syntax here, don't forget to adjust TokenKind::can_begin_expr().\n+        match self.token.kind {\n+            // This match arm is a special-case of the `_` match arm below and\n+            // could be removed without changing functionality, but it's faster\n+            // to have it here, especially for programs with large constants.\n+            token::Literal(_) => {\n+                parse_lit!()\n+            }\n+            token::OpenDelim(token::Paren) => {\n+                self.bump();\n+\n+                attrs.extend(self.parse_inner_attributes()?);\n+\n+                // (e) is parenthesized e\n+                // (e,) is a tuple with only one field, e\n+                let mut es = vec![];\n+                let mut trailing_comma = false;\n+                let mut recovered = false;\n+                while self.token != token::CloseDelim(token::Paren) {\n+                    es.push(match self.parse_expr() {\n+                        Ok(es) => es,\n+                        Err(mut err) => {\n+                            // recover from parse error in tuple list\n+                            match self.token.kind {\n+                                token::Ident(name, false)\n+                                if name == kw::Underscore && self.look_ahead(1, |t| {\n+                                    t == &token::Comma\n+                                }) => {\n+                                    // Special-case handling of `Foo<(_, _, _)>`\n+                                    err.emit();\n+                                    let sp = self.token.span;\n+                                    self.bump();\n+                                    self.mk_expr(sp, ExprKind::Err, ThinVec::new())\n+                                }\n+                                _ => return Ok(\n+                                    self.recover_seq_parse_error(token::Paren, lo, Err(err)),\n+                                ),\n+                            }\n+                        }\n+                    });\n+                    recovered = self.expect_one_of(\n+                        &[],\n+                        &[token::Comma, token::CloseDelim(token::Paren)],\n+                    )?;\n+                    if self.eat(&token::Comma) {\n+                        trailing_comma = true;\n+                    } else {\n+                        trailing_comma = false;\n+                        break;\n+                    }\n+                }\n+                if !recovered {\n+                    self.bump();\n+                }\n+\n+                hi = self.prev_span;\n+                ex = if es.len() == 1 && !trailing_comma {\n+                    ExprKind::Paren(es.into_iter().nth(0).unwrap())\n+                } else {\n+                    ExprKind::Tup(es)\n+                };\n+            }\n+            token::OpenDelim(token::Brace) => {\n+                return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n+            }\n+            token::BinOp(token::Or) | token::OrOr => {\n+                return self.parse_lambda_expr(attrs);\n+            }\n+            token::OpenDelim(token::Bracket) => {\n+                self.bump();\n+\n+                attrs.extend(self.parse_inner_attributes()?);\n+\n+                if self.eat(&token::CloseDelim(token::Bracket)) {\n+                    // Empty vector.\n+                    ex = ExprKind::Array(Vec::new());\n+                } else {\n+                    // Nonempty vector.\n+                    let first_expr = self.parse_expr()?;\n+                    if self.eat(&token::Semi) {\n+                        // Repeating array syntax: [ 0; 512 ]\n+                        let count = AnonConst {\n+                            id: ast::DUMMY_NODE_ID,\n+                            value: self.parse_expr()?,\n+                        };\n+                        self.expect(&token::CloseDelim(token::Bracket))?;\n+                        ex = ExprKind::Repeat(first_expr, count);\n+                    } else if self.eat(&token::Comma) {\n+                        // Vector with two or more elements.\n+                        let remaining_exprs = self.parse_seq_to_end(\n+                            &token::CloseDelim(token::Bracket),\n+                            SeqSep::trailing_allowed(token::Comma),\n+                            |p| Ok(p.parse_expr()?)\n+                        )?;\n+                        let mut exprs = vec![first_expr];\n+                        exprs.extend(remaining_exprs);\n+                        ex = ExprKind::Array(exprs);\n+                    } else {\n+                        // Vector with one element.\n+                        self.expect(&token::CloseDelim(token::Bracket))?;\n+                        ex = ExprKind::Array(vec![first_expr]);\n+                    }\n+                }\n+                hi = self.prev_span;\n+            }\n+            _ => {\n+                if self.eat_lt() {\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                    hi = path.span;\n+                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n+                }\n+                if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n+                    return self.parse_lambda_expr(attrs);\n+                }\n+                if self.eat_keyword(kw::If) {\n+                    return self.parse_if_expr(attrs);\n+                }\n+                if self.eat_keyword(kw::For) {\n+                    let lo = self.prev_span;\n+                    return self.parse_for_expr(None, lo, attrs);\n+                }\n+                if self.eat_keyword(kw::While) {\n+                    let lo = self.prev_span;\n+                    return self.parse_while_expr(None, lo, attrs);\n+                }\n+                if let Some(label) = self.eat_label() {\n+                    let lo = label.ident.span;\n+                    self.expect(&token::Colon)?;\n+                    if self.eat_keyword(kw::While) {\n+                        return self.parse_while_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.eat_keyword(kw::For) {\n+                        return self.parse_for_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.eat_keyword(kw::Loop) {\n+                        return self.parse_loop_expr(Some(label), lo, attrs)\n+                    }\n+                    if self.token == token::OpenDelim(token::Brace) {\n+                        return self.parse_block_expr(Some(label),\n+                                                     lo,\n+                                                     BlockCheckMode::Default,\n+                                                     attrs);\n+                    }\n+                    let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n+                    let mut err = self.fatal(msg);\n+                    err.span_label(self.token.span, msg);\n+                    return Err(err);\n+                }\n+                if self.eat_keyword(kw::Loop) {\n+                    let lo = self.prev_span;\n+                    return self.parse_loop_expr(None, lo, attrs);\n+                }\n+                if self.eat_keyword(kw::Continue) {\n+                    let label = self.eat_label();\n+                    let ex = ExprKind::Continue(label);\n+                    let hi = self.prev_span;\n+                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+                }\n+                if self.eat_keyword(kw::Match) {\n+                    let match_sp = self.prev_span;\n+                    return self.parse_match_expr(attrs).map_err(|mut err| {\n+                        err.span_label(match_sp, \"while parsing this match expression\");\n+                        err\n+                    });\n+                }\n+                if self.eat_keyword(kw::Unsafe) {\n+                    return self.parse_block_expr(\n+                        None,\n+                        lo,\n+                        BlockCheckMode::Unsafe(ast::UserProvided),\n+                        attrs);\n+                }\n+                if self.is_do_catch_block() {\n+                    let mut db = self.fatal(\"found removed `do catch` syntax\");\n+                    db.help(\"Following RFC #2388, the new non-placeholder syntax is `try`\");\n+                    return Err(db);\n+                }\n+                if self.is_try_block() {\n+                    let lo = self.token.span;\n+                    assert!(self.eat_keyword(kw::Try));\n+                    return self.parse_try_block(lo, attrs);\n+                }\n+\n+                // Span::rust_2018() is somewhat expensive; don't get it repeatedly.\n+                let is_span_rust_2018 = self.token.span.rust_2018();\n+                if is_span_rust_2018 && self.check_keyword(kw::Async) {\n+                    return if self.is_async_block() { // check for `async {` and `async move {`\n+                        self.parse_async_block(attrs)\n+                    } else {\n+                        self.parse_lambda_expr(attrs)\n+                    };\n+                }\n+                if self.eat_keyword(kw::Return) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Ret(Some(e));\n+                    } else {\n+                        ex = ExprKind::Ret(None);\n+                    }\n+                } else if self.eat_keyword(kw::Break) {\n+                    let label = self.eat_label();\n+                    let e = if self.token.can_begin_expr()\n+                               && !(self.token == token::OpenDelim(token::Brace)\n+                                    && self.restrictions.contains(\n+                                           Restrictions::NO_STRUCT_LITERAL)) {\n+                        Some(self.parse_expr()?)\n+                    } else {\n+                        None\n+                    };\n+                    ex = ExprKind::Break(label, e);\n+                    hi = self.prev_span;\n+                } else if self.eat_keyword(kw::Yield) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Yield(Some(e));\n+                    } else {\n+                        ex = ExprKind::Yield(None);\n+                    }\n+                } else if self.eat_keyword(kw::Let) {\n+                    return self.parse_let_expr(attrs);\n+                } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n+                    let (await_hi, e_kind) = self.parse_incorrect_await_syntax(lo, self.prev_span)?;\n+                    hi = await_hi;\n+                    ex = e_kind;\n+                } else if self.token.is_path_start() {\n+                    let path = self.parse_path(PathStyle::Expr)?;\n+\n+                    // `!`, as an operator, is prefix, so we know this isn't that\n+                    if self.eat(&token::Not) {\n+                        // MACRO INVOCATION expression\n+                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        hi = self.prev_span;\n+                        ex = ExprKind::Mac(respan(lo.to(hi), Mac_ {\n+                            path,\n+                            tts,\n+                            delim,\n+                            prior_type_ascription: self.last_type_ascription,\n+                        }));\n+                    } else if self.check(&token::OpenDelim(token::Brace)) {\n+                        if let Some(expr) = self.maybe_parse_struct_expr(lo, &path, &attrs) {\n+                            return expr;\n+                        } else {\n+                            hi = path.span;\n+                            ex = ExprKind::Path(None, path);\n+                        }\n+                    } else {\n+                        hi = path.span;\n+                        ex = ExprKind::Path(None, path);\n+                    }\n+                } else {\n+                    if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n+                        // Don't complain about bare semicolons after unclosed braces\n+                        // recovery in order to keep the error count down. Fixing the\n+                        // delimiters will possibly also fix the bare semicolon found in\n+                        // expression context. For example, silence the following error:\n+                        // ```\n+                        // error: expected expression, found `;`\n+                        //  --> file.rs:2:13\n+                        //   |\n+                        // 2 |     foo(bar(;\n+                        //   |             ^ expected expression\n+                        // ```\n+                        self.bump();\n+                        return Ok(self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()));\n+                    }\n+                    parse_lit!()\n+                }\n+            }\n+        }\n+\n+        let expr = self.mk_expr(lo.to(hi), ex, attrs);\n+        self.maybe_recover_from_bad_qpath(expr, true)\n+    }\n+\n+    /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n+    crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+        maybe_whole_expr!(self);\n+\n+        let minus_lo = self.token.span;\n+        let minus_present = self.eat(&token::BinOp(token::Minus));\n+        let lo = self.token.span;\n+        let literal = self.parse_lit()?;\n+        let hi = self.prev_span;\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n+\n+        if minus_present {\n+            let minus_hi = self.prev_span;\n+            let unary = self.mk_unary(UnOp::Neg, expr);\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n+        } else {\n+            Ok(expr)\n+        }\n+    }\n+\n+    /// Parses a block or unsafe block.\n+    crate fn parse_block_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n+        outer_attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+\n+        let mut attrs = outer_attrs;\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let blk = self.parse_block_tail(lo, blk_mode)?;\n+        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs));\n+    }\n+\n+    /// Parses `move |args| expr`.\n+    fn parse_lambda_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.token.span;\n+\n+        let movability = if self.eat_keyword(kw::Static) {\n+            Movability::Static\n+        } else {\n+            Movability::Movable\n+        };\n+\n+        let asyncness = if self.token.span.rust_2018() {\n+            self.parse_asyncness()\n+        } else {\n+            IsAsync::NotAsync\n+        };\n+        if asyncness.is_async() {\n+            // Feature gate `async ||` closures.\n+            self.sess.async_closure_spans.borrow_mut().push(self.prev_span);\n+        }\n+\n+        let capture_clause = self.parse_capture_clause();\n+        let decl = self.parse_fn_block_decl()?;\n+        let decl_hi = self.prev_span;\n+        let body = match decl.output {\n+            FunctionRetTy::Default(_) => {\n+                let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n+                self.parse_expr_res(restrictions, None)?\n+            },\n+            _ => {\n+                // If an explicit return type is given, require a\n+                // block to appear (RFC 968).\n+                let body_lo = self.token.span;\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n+            }\n+        };\n+\n+        Ok(self.mk_expr(\n+            lo.to(body.span),\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n+            attrs))\n+    }\n+\n+    /// Parse an optional `move` prefix to a closure lke construct.\n+    fn parse_capture_clause(&mut self) -> CaptureBy {\n+        if self.eat_keyword(kw::Move) {\n+            CaptureBy::Value\n+        } else {\n+            CaptureBy::Ref\n+        }\n+    }\n+\n+    /// Parses an `if` expression (`if` token already eaten).\n+    fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let cond = self.parse_cond_expr()?;\n+\n+        // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n+        // verify that the last statement is either an implicit return (no `;`) or an explicit\n+        // return. This won't catch blocks with an explicit `return`, but that would be caught by\n+        // the dead code lint.\n+        if self.eat_keyword(kw::Else) || !cond.returns() {\n+            let sp = self.sess.source_map().next_point(lo);\n+            let mut err = self.diagnostic()\n+                .struct_span_err(sp, \"missing condition for `if` statemement\");\n+            err.span_label(sp, \"expected if condition here\");\n+            return Err(err)\n+        }\n+        let not_block = self.token != token::OpenDelim(token::Brace);\n+        let thn = self.parse_block().map_err(|mut err| {\n+            if not_block {\n+                err.span_label(lo, \"this `if` statement has a condition, but no block\");\n+            }\n+            err\n+        })?;\n+        let mut els: Option<P<Expr>> = None;\n+        let mut hi = thn.span;\n+        if self.eat_keyword(kw::Else) {\n+            let elexpr = self.parse_else_expr()?;\n+            hi = elexpr.span;\n+            els = Some(elexpr);\n+        }\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n+    }\n+\n+    /// Parse the condition of a `if`- or `while`-expression\n+    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        if let ExprKind::Let(..) = cond.node {\n+            // Remove the last feature gating of a `let` expression since it's stable.\n+            let last = self.sess.let_chains_spans.borrow_mut().pop();\n+            debug_assert_eq!(cond.span, last.unwrap());\n+        }\n+\n+        Ok(cond)\n+    }\n+\n+    /// Parses a `let $pats = $expr` pseudo-expression.\n+    /// The `let` token has already been eaten.\n+    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let lo = self.prev_span;\n+        let pats = self.parse_pats()?;\n+        self.expect(&token::Eq)?;\n+        let expr = self.with_res(\n+            Restrictions::NO_STRUCT_LITERAL,\n+            |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n+        )?;\n+        let span = lo.to(expr.span);\n+        self.sess.let_chains_spans.borrow_mut().push(span);\n+        Ok(self.mk_expr(span, ExprKind::Let(pats, expr), attrs))\n+    }\n+\n+    /// `else` token already eaten\n+    fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n+        if self.eat_keyword(kw::If) {\n+            return self.parse_if_expr(ThinVec::new());\n+        } else {\n+            let blk = self.parse_block()?;\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n+        }\n+    }\n+\n+    /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n+    fn parse_for_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n+\n+        // Record whether we are about to parse `for (`.\n+        // This is used below for recovery in case of `for ( $stuff ) $block`\n+        // in which case we will suggest `for $stuff $block`.\n+        let begin_paren = match self.token.kind {\n+            token::OpenDelim(token::Paren) => Some(self.token.span),\n+            _ => None,\n+        };\n+\n+        let pat = self.parse_top_level_pat()?;\n+        if !self.eat_keyword(kw::In) {\n+            let in_span = self.prev_span.between(self.token.span);\n+            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+                .span_suggestion_short(\n+                    in_span,\n+                    \"try adding `in` here\", \" in \".into(),\n+                    // has been misleading, at least in the past (closed Issue #48492)\n+                    Applicability::MaybeIncorrect\n+                )\n+                .emit();\n+        }\n+        let in_span = self.prev_span;\n+        self.check_for_for_in_in_typo(in_span);\n+        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n+\n+        let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+\n+        let hi = self.prev_span;\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_label), attrs))\n+    }\n+\n+    /// Parses a `while` or `while let` expression (`while` token already eaten).\n+    fn parse_while_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_cond_expr()?;\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_label), attrs))\n+    }\n+\n+    /// Parse `loop {...}`, `loop` token already eaten.\n+    fn parse_loop_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n+    }\n+\n+    fn eat_label(&mut self) -> Option<Label> {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.token.span;\n+            self.bump();\n+            Some(Label { ident: Ident::new(ident.name, span) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // `match` token already eaten\n+    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let match_span = self.prev_span;\n+        let lo = self.prev_span;\n+        let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+        if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n+            if self.token == token::Semi {\n+                e.span_suggestion_short(\n+                    match_span,\n+                    \"try removing this `match`\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect // speculative\n+                );\n+            }\n+            return Err(e)\n+        }\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        let mut arms: Vec<Arm> = Vec::new();\n+        while self.token != token::CloseDelim(token::Brace) {\n+            match self.parse_arm() {\n+                Ok(arm) => arms.push(arm),\n+                Err(mut e) => {\n+                    // Recover by skipping to the end of the block.\n+                    e.emit();\n+                    self.recover_stmt();\n+                    let span = lo.to(self.token.span);\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        self.bump();\n+                    }\n+                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n+                }\n+            }\n+        }\n+        let hi = self.token.span;\n+        self.bump();\n+        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n+    }\n+\n+    crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+        let pats = self.parse_pats()?;\n+        let guard = if self.eat_keyword(kw::If) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n+        let arrow_span = self.token.span;\n+        self.expect(&token::FatArrow)?;\n+        let arm_start_span = self.token.span;\n+\n+        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)\n+            .map_err(|mut err| {\n+                err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n+                err\n+            })?;\n+\n+        let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n+            && self.token != token::CloseDelim(token::Brace);\n+\n+        let hi = self.token.span;\n+\n+        if require_comma {\n+            let cm = self.sess.source_map();\n+            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Brace)])\n+                .map_err(|mut err| {\n+                    match (cm.span_to_lines(expr.span), cm.span_to_lines(arm_start_span)) {\n+                        (Ok(ref expr_lines), Ok(ref arm_start_lines))\n+                        if arm_start_lines.lines[0].end_col == expr_lines.lines[0].end_col\n+                            && expr_lines.lines.len() == 2\n+                            && self.token == token::FatArrow => {\n+                            // We check whether there's any trailing code in the parse span,\n+                            // if there isn't, we very likely have the following:\n+                            //\n+                            // X |     &Y => \"y\"\n+                            //   |        --    - missing comma\n+                            //   |        |\n+                            //   |        arrow_span\n+                            // X |     &X => \"x\"\n+                            //   |      - ^^ self.token.span\n+                            //   |      |\n+                            //   |      parsed until here as `\"y\" & X`\n+                            err.span_suggestion_short(\n+                                cm.next_point(arm_start_span),\n+                                \"missing a comma here to end this `match` arm\",\n+                                \",\".to_owned(),\n+                                Applicability::MachineApplicable\n+                            );\n+                        }\n+                        _ => {\n+                            err.span_label(arrow_span,\n+                                           \"while parsing the `match` arm starting here\");\n+                        }\n+                    }\n+                    err\n+                })?;\n+        } else {\n+            self.eat(&token::Comma);\n+        }\n+\n+        Ok(ast::Arm {\n+            attrs,\n+            pats,\n+            guard,\n+            body: expr,\n+            span: lo.to(hi),\n+        })\n+    }\n+\n+    /// Parses a `try {...}` expression (`try` token already eaten).\n+    fn parse_try_block(\n+        &mut self,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        if self.eat_keyword(kw::Catch) {\n+            let mut error = self.struct_span_err(self.prev_span,\n+                                                 \"keyword `catch` cannot follow a `try` block\");\n+            error.help(\"try using `match` on the result of the `try` block instead\");\n+            error.emit();\n+            Err(error)\n+        } else {\n+            Ok(self.mk_expr(span_lo.to(body.span), ExprKind::TryBlock(body), attrs))\n+        }\n+    }\n+\n+    fn is_do_catch_block(&self) -> bool {\n+        self.token.is_keyword(kw::Do) &&\n+        self.is_keyword_ahead(1, &[kw::Catch]) &&\n+        self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n+        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+    }\n+\n+    fn is_try_block(&self) -> bool {\n+        self.token.is_keyword(kw::Try) &&\n+        self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n+        self.token.span.rust_2018() &&\n+        // prevent `while try {} {}`, `if try {} {} else {}`, etc.\n+        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+    }\n+\n+    /// Parses an `async move? {...}` expression.\n+    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+        let span_lo = self.token.span;\n+        self.expect_keyword(kw::Async)?;\n+        let capture_clause = self.parse_capture_clause();\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        Ok(self.mk_expr(\n+            span_lo.to(body.span),\n+            ExprKind::Async(capture_clause, ast::DUMMY_NODE_ID, body), attrs))\n+    }\n+\n+    fn is_async_block(&self) -> bool {\n+        self.token.is_keyword(kw::Async) &&\n+        (\n+            ( // `async move {`\n+                self.is_keyword_ahead(1, &[kw::Move]) &&\n+                self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+            ) || ( // `async {`\n+                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            )\n+        )\n+    }\n+\n+    fn maybe_parse_struct_expr(\n+        &mut self,\n+        lo: Span,\n+        path: &ast::Path,\n+        attrs: &ThinVec<Attribute>,\n+    ) -> Option<PResult<'a, P<Expr>>> {\n+        let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n+        let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n+            // `{ ident, ` cannot start a block\n+            self.look_ahead(2, |t| t == &token::Comma) ||\n+            self.look_ahead(2, |t| t == &token::Colon) && (\n+                // `{ ident: token, ` cannot start a block\n+                self.look_ahead(4, |t| t == &token::Comma) ||\n+                // `{ ident: ` cannot start a block unless it's a type ascription `ident: Type`\n+                self.look_ahead(3, |t| !t.can_begin_type())\n+            )\n+        );\n+\n+        if struct_allowed || certainly_not_a_block() {\n+            // This is a struct literal, but we don't can't accept them here\n+            let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n+            if let (Ok(expr), false) = (&expr, struct_allowed) {\n+                self.struct_span_err(\n+                    expr.span,\n+                    \"struct literals are not allowed here\",\n+                )\n+                .multipart_suggestion(\n+                    \"surround the struct literal with parentheses\",\n+                    vec![\n+                        (lo.shrink_to_lo(), \"(\".to_string()),\n+                        (expr.span.shrink_to_hi(), \")\".to_string()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+            }\n+            return Some(expr);\n+        }\n+        None\n+    }\n+\n+    pub(super) fn parse_struct_expr(\n+        &mut self,\n+        lo: Span,\n+        pth: ast::Path,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n+        let struct_sp = lo.to(self.prev_span);\n+        self.bump();\n+        let mut fields = Vec::new();\n+        let mut base = None;\n+\n+        attrs.extend(self.parse_inner_attributes()?);\n+\n+        while self.token != token::CloseDelim(token::Brace) {\n+            if self.eat(&token::DotDot) {\n+                let exp_span = self.prev_span;\n+                match self.parse_expr() {\n+                    Ok(e) => {\n+                        base = Some(e);\n+                    }\n+                    Err(mut e) => {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+                if self.token == token::Comma {\n+                    self.struct_span_err(\n+                        exp_span.to(self.prev_span),\n+                        \"cannot use a comma after the base struct\",\n+                    )\n+                    .span_suggestion_short(\n+                        self.token.span,\n+                        \"remove this comma\",\n+                        String::new(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .note(\"the base struct must always be the last field\")\n+                    .emit();\n+                    self.recover_stmt();\n+                }\n+                break;\n+            }\n+\n+            let mut recovery_field = None;\n+            if let token::Ident(name, _) = self.token.kind {\n+                if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n+                    // Use in case of error after field-looking code: `S { foo: () with a }`\n+                    recovery_field = Some(ast::Field {\n+                        ident: Ident::new(name, self.token.span),\n+                        span: self.token.span,\n+                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n+                        is_shorthand: false,\n+                        attrs: ThinVec::new(),\n+                    });\n+                }\n+            }\n+            let mut parsed_field = None;\n+            match self.parse_field() {\n+                Ok(f) => parsed_field = Some(f),\n+                Err(mut e) => {\n+                    e.span_label(struct_sp, \"while parsing this struct\");\n+                    e.emit();\n+\n+                    // If the next token is a comma, then try to parse\n+                    // what comes next as additional fields, rather than\n+                    // bailing out until next `}`.\n+                    if self.token != token::Comma {\n+                        self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                        if self.token != token::Comma {\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            match self.expect_one_of(&[token::Comma],\n+                                     &[token::CloseDelim(token::Brace)]) {\n+                Ok(_) => if let Some(f) = parsed_field.or(recovery_field) {\n+                    // only include the field if there's no parse error for the field name\n+                    fields.push(f);\n+                }\n+                Err(mut e) => {\n+                    if let Some(f) = recovery_field {\n+                        fields.push(f);\n+                    }\n+                    e.span_label(struct_sp, \"while parsing this struct\");\n+                    e.emit();\n+                    self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                    self.eat(&token::Comma);\n+                }\n+            }\n+        }\n+\n+        let span = lo.to(self.token.span);\n+        self.expect(&token::CloseDelim(token::Brace))?;\n+        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n+    }\n+\n+    /// Parse ident (COLON expr)?\n+    fn parse_field(&mut self) -> PResult<'a, Field> {\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| {\n+            t == &token::Colon || t == &token::Eq\n+        }) {\n+            let fieldname = self.parse_field_name()?;\n+\n+            // Check for an equals token. This means the source incorrectly attempts to\n+            // initialize a field with an eq rather than a colon.\n+            if self.token == token::Eq {\n+                self.diagnostic()\n+                    .struct_span_err(self.token.span, \"expected `:`, found `=`\")\n+                    .span_suggestion(\n+                        fieldname.span.shrink_to_hi().to(self.token.span),\n+                        \"replace equals symbol with a colon\",\n+                        \":\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            }\n+            self.bump(); // `:`\n+            (fieldname, self.parse_expr()?, false)\n+        } else {\n+            let fieldname = self.parse_ident_common(false)?;\n+\n+            // Mimic `x: x` for the `x` field shorthand.\n+            let path = ast::Path::from_ident(fieldname);\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            (fieldname, expr, true)\n+        };\n+        Ok(ast::Field {\n+            ident: fieldname,\n+            span: lo.to(expr.span),\n+            expr,\n+            is_shorthand,\n+            attrs: attrs.into(),\n+        })\n+    }\n+\n+    fn err_dotdotdot_syntax(&self, span: Span) {\n+        self.struct_span_err(span, \"unexpected token: `...`\")\n+            .span_suggestion(\n+                span,\n+                \"use `..` for an exclusive range\", \"..\".to_owned(),\n+                Applicability::MaybeIncorrect\n+            )\n+            .span_suggestion(\n+                span,\n+                \"or `..=` for an inclusive range\", \"..=\".to_owned(),\n+                Applicability::MaybeIncorrect\n+            )\n+            .emit();\n+    }\n+\n+    fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {\n+        ExprKind::AssignOp(binop, lhs, rhs)\n+    }\n+\n+    fn mk_range(\n+        &self,\n+        start: Option<P<Expr>>,\n+        end: Option<P<Expr>>,\n+        limits: RangeLimits\n+    ) -> PResult<'a, ExprKind> {\n+        if end.is_none() && limits == RangeLimits::Closed {\n+            Err(self.span_fatal_err(self.token.span, Error::InclusiveRangeWithNoEnd))\n+        } else {\n+            Ok(ExprKind::Range(start, end, limits))\n+        }\n+    }\n+\n+    fn mk_unary(&self, unop: UnOp, expr: P<Expr>) -> ExprKind {\n+        ExprKind::Unary(unop, expr)\n+    }\n+\n+    fn mk_binary(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {\n+        ExprKind::Binary(binop, lhs, rhs)\n+    }\n+\n+    fn mk_index(&self, expr: P<Expr>, idx: P<Expr>) -> ExprKind {\n+        ExprKind::Index(expr, idx)\n+    }\n+\n+    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ExprKind {\n+        ExprKind::Call(f, args)\n+    }\n+\n+    fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let span = lo.to(self.prev_span);\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), ThinVec::new());\n+        self.recover_from_await_method_call();\n+        Ok(await_expr)\n+    }\n+\n+    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+        P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n+    }\n+}"}]}