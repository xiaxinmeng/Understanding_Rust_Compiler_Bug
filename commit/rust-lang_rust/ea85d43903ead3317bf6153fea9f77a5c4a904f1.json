{"sha": "ea85d43903ead3317bf6153fea9f77a5c4a904f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhODVkNDM5MDNlYWQzMzE3YmY2MTUzZmVhOWY3N2E1YzRhOTA0ZjE=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-02-06T05:08:02Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-02-07T18:49:58Z"}, "message": "Make std::fmt a simple re-export from collections", "tree": {"sha": "898c7bc84c377281a07163e63c6934b7209676e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/898c7bc84c377281a07163e63c6934b7209676e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea85d43903ead3317bf6153fea9f77a5c4a904f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea85d43903ead3317bf6153fea9f77a5c4a904f1", "html_url": "https://github.com/rust-lang/rust/commit/ea85d43903ead3317bf6153fea9f77a5c4a904f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea85d43903ead3317bf6153fea9f77a5c4a904f1/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a246b6542a6660f725441dd016bddd470c761e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a246b6542a6660f725441dd016bddd470c761e4c", "html_url": "https://github.com/rust-lang/rust/commit/a246b6542a6660f725441dd016bddd470c761e4c"}], "stats": {"total": 826, "additions": 402, "deletions": 424}, "files": [{"sha": "5f337528d780736ecf3b0708239be492d16f6484", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 401, "deletions": 9, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/ea85d43903ead3317bf6153fea9f77a5c4a904f1/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea85d43903ead3317bf6153fea9f77a5c4a904f1/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=ea85d43903ead3317bf6153fea9f77a5c4a904f1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,15 +7,409 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15679\n \n-//! Formatting support for `String`.\n+//! Utilities for formatting and printing strings\n+//!\n+//! This module contains the runtime support for the `format!` syntax extension.\n+//! This macro is implemented in the compiler to emit calls to this module in\n+//! order to format arguments at runtime into strings and streams.\n+//!\n+//! ## Usage\n+//!\n+//! The `format!` macro is intended to be familiar to those coming from C's\n+//! printf/fprintf functions or Python's `str.format` function. In its current\n+//! revision, the `format!` macro returns a `String` type which is the result of\n+//! the formatting. In the future it will also be able to pass in a stream to\n+//! format arguments directly while performing minimal allocations.\n+//!\n+//! Some examples of the `format!` extension are:\n+//!\n+//! ```\n+//! format!(\"Hello\");                  // => \"Hello\"\n+//! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n+//! format!(\"The number is {}\", 1);   // => \"The number is 1\"\n+//! format!(\"{:?}\", (3, 4));         // => \"(3, 4)\"\n+//! format!(\"{value}\", value=4);      // => \"4\"\n+//! format!(\"{} {}\", 1, 2u);          // => \"1 2\"\n+//! ```\n+//!\n+//! From these, you can see that the first argument is a format string. It is\n+//! required by the compiler for this to be a string literal; it cannot be a\n+//! variable passed in (in order to perform validity checking). The compiler\n+//! will then parse the format string and determine if the list of arguments\n+//! provided is suitable to pass to this format string.\n+//!\n+//! ### Positional parameters\n+//!\n+//! Each formatting argument is allowed to specify which value argument it's\n+//! referencing, and if omitted it is assumed to be \"the next argument\". For\n+//! example, the format string `{} {} {}` would take three parameters, and they\n+//! would be formatted in the same order as they're given. The format string\n+//! `{2} {1} {0}`, however, would format arguments in reverse order.\n+//!\n+//! Things can get a little tricky once you start intermingling the two types of\n+//! positional specifiers. The \"next argument\" specifier can be thought of as an\n+//! iterator over the argument. Each time a \"next argument\" specifier is seen,\n+//! the iterator advances. This leads to behavior like this:\n+//!\n+//! ```rust\n+//! format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n+//! ```\n+//!\n+//! The internal iterator over the argument has not been advanced by the time\n+//! the first `{}` is seen, so it prints the first argument. Then upon reaching\n+//! the second `{}`, the iterator has advanced forward to the second argument.\n+//! Essentially, parameters which explicitly name their argument do not affect\n+//! parameters which do not name an argument in terms of positional specifiers.\n+//!\n+//! A format string is required to use all of its arguments, otherwise it is a\n+//! compile-time error. You may refer to the same argument more than once in the\n+//! format string, although it must always be referred to with the same type.\n+//!\n+//! ### Named parameters\n+//!\n+//! Rust itself does not have a Python-like equivalent of named parameters to a\n+//! function, but the `format!` macro is a syntax extension which allows it to\n+//! leverage named parameters. Named parameters are listed at the end of the\n+//! argument list and have the syntax:\n+//!\n+//! ```text\n+//! identifier '=' expression\n+//! ```\n+//!\n+//! For example, the following `format!` expressions all use named argument:\n+//!\n+//! ```\n+//! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n+//! format!(\"{name} {}\", 1, name = 2);        // => \"2 1\"\n+//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n+//! ```\n+//!\n+//! It is illegal to put positional parameters (those without names) after\n+//! arguments which have names. Like with positional parameters, it is illegal\n+//! to provide named parameters that are unused by the format string.\n+//!\n+//! ### Argument types\n+//!\n+//! Each argument's type is dictated by the format string. It is a requirement\n+//! that every argument is only ever referred to by one type. For example, this\n+//! is an invalid format string:\n+//!\n+//! ```text\n+//! {0:x} {0:o}\n+//! ```\n+//!\n+//! This is invalid because the first argument is both referred to as a\n+//! hexadecimal as well as an\n+//! octal.\n+//!\n+//! There are various parameters which do require a particular type, however.\n+//! Namely if the syntax `{:.*}` is used, then the number of characters to print\n+//! precedes the actual object being formatted, and the number of characters\n+//! must have the type `uint`. Although a `uint` can be printed with `{}`, it is\n+//! illegal to reference an argument as such. For example this is another\n+//! invalid format string:\n+//!\n+//! ```text\n+//! {:.*} {0}\n+//! ```\n+//!\n+//! ### Formatting traits\n+//!\n+//! When requesting that an argument be formatted with a particular type, you\n+//! are actually requesting that an argument ascribes to a particular trait.\n+//! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n+//! well as `int`).  The current mapping of types to traits is:\n+//!\n+//! * *nothing* \u21d2 `Display`\n+//! * `?` \u21d2 `Debug`\n+//! * `o` \u21d2 `Octal`\n+//! * `x` \u21d2 `LowerHex`\n+//! * `X` \u21d2 `UpperHex`\n+//! * `p` \u21d2 `Pointer`\n+//! * `b` \u21d2 `Binary`\n+//! * `e` \u21d2 `LowerExp`\n+//! * `E` \u21d2 `UpperExp`\n+//!\n+//! What this means is that any type of argument which implements the\n+//! `fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n+//! are provided for these traits for a number of primitive types by the\n+//! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n+//! then the format trait used is the `Display` trait.\n+//!\n+//! When implementing a format trait for your own type, you will have to\n+//! implement a method of the signature:\n+//!\n+//! ```rust\n+//! # use std::fmt;\n+//! # struct Foo; // our custom type\n+//! # impl fmt::Display for Foo {\n+//! fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//! # write!(f, \"testing, testing\")\n+//! # } }\n+//! ```\n+//!\n+//! Your type will be passed as `self` by-reference, and then the function\n+//! should emit output into the `f.buf` stream. It is up to each format trait\n+//! implementation to correctly adhere to the requested formatting parameters.\n+//! The values of these parameters will be listed in the fields of the\n+//! `Formatter` struct. In order to help with this, the `Formatter` struct also\n+//! provides some helper methods.\n+//!\n+//! Additionally, the return value of this function is `fmt::Result` which is a\n+//! typedef to `Result<(), IoError>` (also known as `IoResult<()>`). Formatting\n+//! implementations should ensure that they return errors from `write!`\n+//! correctly (propagating errors upward).\n+//!\n+//! An example of implementing the formatting traits would look\n+//! like:\n+//!\n+//! ```rust\n+//! use std::fmt;\n+//! use std::f64;\n+//! use std::num::Float;\n+//!\n+//! #[derive(Debug)]\n+//! struct Vector2D {\n+//!     x: int,\n+//!     y: int,\n+//! }\n+//!\n+//! impl fmt::Display for Vector2D {\n+//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//!         // The `f` value implements the `Writer` trait, which is what the\n+//!         // write! macro is expecting. Note that this formatting ignores the\n+//!         // various flags provided to format strings.\n+//!         write!(f, \"({}, {})\", self.x, self.y)\n+//!     }\n+//! }\n+//!\n+//! // Different traits allow different forms of output of a type. The meaning\n+//! // of this format is to print the magnitude of a vector.\n+//! impl fmt::Binary for Vector2D {\n+//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+//!         let magnitude = (self.x * self.x + self.y * self.y) as f64;\n+//!         let magnitude = magnitude.sqrt();\n+//!\n+//!         // Respect the formatting flags by using the helper method\n+//!         // `pad_integral` on the Formatter object. See the method documentation\n+//!         // for details, and the function `pad` can be used to pad strings.\n+//!         let decimals = f.precision().unwrap_or(3);\n+//!         let string = f64::to_str_exact(magnitude, decimals);\n+//!         f.pad_integral(true, \"\", string.as_slice())\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     let myvector = Vector2D { x: 3, y: 4 };\n+//!\n+//!     println!(\"{}\", myvector);       // => \"(3, 4)\"\n+//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3, y:4}\"\n+//!     println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n+//! }\n+//! ```\n+//!\n+//! #### fmt::Display vs fmt::Debug\n+//!\n+//! These two formatting traits have distinct purposes:\n+//!\n+//! - `fmt::Display` implementations assert that the type can be faithfully\n+//!   represented as a UTF-8 string at all times. It is **not** expected that\n+//!   all types implement the `Display` trait.\n+//! - `fmt::Debug` implementations should be implemented for **all** public types.\n+//!   Output will typically represent the internal state as faithfully as possible.\n+//!   The purpose of the `Debug` trait is to facilitate debugging Rust code. In\n+//!   most cases, using `#[derive(Debug)]` is sufficient and recommended.\n+//!\n+//! Some examples of the output from both traits:\n+//!\n+//! ```\n+//! assert_eq!(format!(\"{} {:?}\", 3i32, 4i32), \"3 4\");\n+//! assert_eq!(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\n+//! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n+//! ```\n+//!\n+//! ### Related macros\n+//!\n+//! There are a number of related macros in the `format!` family. The ones that\n+//! are currently implemented are:\n+//!\n+//! ```ignore\n+//! format!      // described above\n+//! write!       // first argument is a &mut old_io::Writer, the destination\n+//! writeln!     // same as write but appends a newline\n+//! print!       // the format string is printed to the standard output\n+//! println!     // same as print but appends a newline\n+//! format_args! // described below.\n+//! ```\n+//!\n+//! #### `write!`\n+//!\n+//! This and `writeln` are two macros which are used to emit the format string\n+//! to a specified stream. This is used to prevent intermediate allocations of\n+//! format strings and instead directly write the output. Under the hood, this\n+//! function is actually invoking the `write` function defined in this module.\n+//! Example usage is:\n+//!\n+//! ```rust\n+//! # #![allow(unused_must_use)]\n+//! let mut w = Vec::new();\n+//! write!(&mut w, \"Hello {}!\", \"world\");\n+//! ```\n+//!\n+//! #### `print!`\n+//!\n+//! This and `println` emit their output to stdout. Similarly to the `write!`\n+//! macro, the goal of these macros is to avoid intermediate allocations when\n+//! printing output. Example usage is:\n+//!\n+//! ```rust\n+//! print!(\"Hello {}!\", \"world\");\n+//! println!(\"I have a newline {}\", \"character at the end\");\n+//! ```\n+//!\n+//! #### `format_args!`\n+//! This is a curious macro which is used to safely pass around\n+//! an opaque object describing the format string. This object\n+//! does not require any heap allocations to create, and it only\n+//! references information on the stack. Under the hood, all of\n+//! the related macros are implemented in terms of this. First\n+//! off, some example usage is:\n+//!\n+//! ```\n+//! use std::fmt;\n+//! use std::old_io;\n+//!\n+//! fmt::format(format_args!(\"this returns {}\", \"String\"));\n+//!\n+//! let mut some_writer = old_io::stdout();\n+//! write!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n+//!\n+//! fn my_fmt_fn(args: fmt::Arguments) {\n+//!     write!(&mut old_io::stdout(), \"{}\", args);\n+//! }\n+//! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n+//! ```\n+//!\n+//! The result of the `format_args!` macro is a value of type `fmt::Arguments`.\n+//! This structure can then be passed to the `write` and `format` functions\n+//! inside this module in order to process the format string.\n+//! The goal of this macro is to even further prevent intermediate allocations\n+//! when dealing formatting strings.\n+//!\n+//! For example, a logging library could use the standard formatting syntax, but\n+//! it would internally pass around this structure until it has been determined\n+//! where output should go to.\n+//!\n+//! ## Syntax\n+//!\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ format <text> ] *\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | ''\n+//! count := parameter | integer\n+//! parameter := integer '$'\n+//! ```\n+//!\n+//! ## Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted. This\n+//! syntax draws heavily from Python's, so it may seem a bit familiar.\n+//!\n+//! ### Fill/Alignment\n+//!\n+//! The fill character is provided normally in conjunction with the `width`\n+//! parameter. This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it. The extra\n+//! characters are specified by `fill`, and the alignment can be one of two\n+//! options:\n+//!\n+//! * `<` - the argument is left-aligned in `width` columns\n+//! * `^` - the argument is center-aligned in `width` columns\n+//! * `>` - the argument is right-aligned in `width` columns\n+//!\n+//! ### Sign/#/0\n+//!\n+//! These can all be interpreted as flags for a particular formatter.\n+//!\n+//! * '+' - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (+ or -)\n+//!         should always be printed.\n+//! * '-' - Currently not used\n+//! * '#' - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. By default, this only applies to the integer formatting\n+//!         traits and performs like:\n+//!     * `x` - precedes the argument with a \"0x\"\n+//!     * `X` - precedes the argument with a \"0x\"\n+//!     * `t` - precedes the argument with a \"0b\"\n+//!     * `o` - precedes the argument with a \"0o\"\n+//! * '0' - This is used to indicate for integer formats that the padding should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08d}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!\n+//! ### Width\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space.\n+//!\n+//! The default fill/alignment for non-numerics is a space and left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the '0' flag is specified for numerics, then the implicit fill character is\n+//! '0'.\n+//!\n+//! The value for the width can also be provided as a `uint` in the list of\n+//! parameters by using the `2$` syntax indicating that the second argument is a\n+//! `uint` specifying the width.\n+//!\n+//! ### Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the\n+//! resulting string is longer than this width, then it is truncated down to\n+//! this many characters and only those are emitted.\n+//!\n+//! For integral types, this has no meaning currently.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal\n+//! point should be printed.\n+//!\n+//! ## Escaping\n //!\n-//! See `core::fmt` and `std::fmt` for full documentation on string\n-//! formatting.\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n \n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![unstable(feature = \"std_misc\")]\n \n-use core::fmt;\n+pub use core::fmt::{Formatter, Result, Writer, rt};\n+pub use core::fmt::{Show, String, Octal, Binary};\n+pub use core::fmt::{Display, Debug};\n+pub use core::fmt::{LowerHex, UpperHex, Pointer};\n+pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::Error;\n+pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n \n use string;\n \n@@ -35,9 +429,7 @@ use string;\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn format(args: fmt::Arguments) -> string::String {\n-    // FIXME #21826\n-    use core::fmt::Writer;\n+pub fn format(args: Arguments) -> string::String {\n     let mut output = string::String::new();\n     let _ = write!(&mut output, \"{}\", args);\n     output"}, {"sha": "82823f0cb28dc11ea5924bfea4be68e6529c624a", "filename": "src/libstd/fmt.rs", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/a246b6542a6660f725441dd016bddd470c761e4c/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a246b6542a6660f725441dd016bddd470c761e4c/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=a246b6542a6660f725441dd016bddd470c761e4c", "patch": "@@ -1,414 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Utilities for formatting and printing strings\n-//!\n-//! This module contains the runtime support for the `format!` syntax extension.\n-//! This macro is implemented in the compiler to emit calls to this module in\n-//! order to format arguments at runtime into strings and streams.\n-//!\n-//! ## Usage\n-//!\n-//! The `format!` macro is intended to be familiar to those coming from C's\n-//! printf/fprintf functions or Python's `str.format` function. In its current\n-//! revision, the `format!` macro returns a `String` type which is the result of\n-//! the formatting. In the future it will also be able to pass in a stream to\n-//! format arguments directly while performing minimal allocations.\n-//!\n-//! Some examples of the `format!` extension are:\n-//!\n-//! ```\n-//! format!(\"Hello\");                  // => \"Hello\"\n-//! format!(\"Hello, {}!\", \"world\");    // => \"Hello, world!\"\n-//! format!(\"The number is {}\", 1);   // => \"The number is 1\"\n-//! format!(\"{:?}\", (3, 4));         // => \"(3, 4)\"\n-//! format!(\"{value}\", value=4);      // => \"4\"\n-//! format!(\"{} {}\", 1, 2u);          // => \"1 2\"\n-//! ```\n-//!\n-//! From these, you can see that the first argument is a format string. It is\n-//! required by the compiler for this to be a string literal; it cannot be a\n-//! variable passed in (in order to perform validity checking). The compiler\n-//! will then parse the format string and determine if the list of arguments\n-//! provided is suitable to pass to this format string.\n-//!\n-//! ### Positional parameters\n-//!\n-//! Each formatting argument is allowed to specify which value argument it's\n-//! referencing, and if omitted it is assumed to be \"the next argument\". For\n-//! example, the format string `{} {} {}` would take three parameters, and they\n-//! would be formatted in the same order as they're given. The format string\n-//! `{2} {1} {0}`, however, would format arguments in reverse order.\n-//!\n-//! Things can get a little tricky once you start intermingling the two types of\n-//! positional specifiers. The \"next argument\" specifier can be thought of as an\n-//! iterator over the argument. Each time a \"next argument\" specifier is seen,\n-//! the iterator advances. This leads to behavior like this:\n-//!\n-//! ```rust\n-//! format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n-//! ```\n-//!\n-//! The internal iterator over the argument has not been advanced by the time\n-//! the first `{}` is seen, so it prints the first argument. Then upon reaching\n-//! the second `{}`, the iterator has advanced forward to the second argument.\n-//! Essentially, parameters which explicitly name their argument do not affect\n-//! parameters which do not name an argument in terms of positional specifiers.\n-//!\n-//! A format string is required to use all of its arguments, otherwise it is a\n-//! compile-time error. You may refer to the same argument more than once in the\n-//! format string, although it must always be referred to with the same type.\n-//!\n-//! ### Named parameters\n-//!\n-//! Rust itself does not have a Python-like equivalent of named parameters to a\n-//! function, but the `format!` macro is a syntax extension which allows it to\n-//! leverage named parameters. Named parameters are listed at the end of the\n-//! argument list and have the syntax:\n-//!\n-//! ```text\n-//! identifier '=' expression\n-//! ```\n-//!\n-//! For example, the following `format!` expressions all use named argument:\n-//!\n-//! ```\n-//! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n-//! format!(\"{name} {}\", 1, name = 2);        // => \"2 1\"\n-//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n-//! ```\n-//!\n-//! It is illegal to put positional parameters (those without names) after\n-//! arguments which have names. Like with positional parameters, it is illegal\n-//! to provide named parameters that are unused by the format string.\n-//!\n-//! ### Argument types\n-//!\n-//! Each argument's type is dictated by the format string. It is a requirement\n-//! that every argument is only ever referred to by one type. For example, this\n-//! is an invalid format string:\n-//!\n-//! ```text\n-//! {0:x} {0:o}\n-//! ```\n-//!\n-//! This is invalid because the first argument is both referred to as a\n-//! hexadecimal as well as an\n-//! octal.\n-//!\n-//! There are various parameters which do require a particular type, however.\n-//! Namely if the syntax `{:.*}` is used, then the number of characters to print\n-//! precedes the actual object being formatted, and the number of characters\n-//! must have the type `uint`. Although a `uint` can be printed with `{}`, it is\n-//! illegal to reference an argument as such. For example this is another\n-//! invalid format string:\n-//!\n-//! ```text\n-//! {:.*} {0}\n-//! ```\n-//!\n-//! ### Formatting traits\n-//!\n-//! When requesting that an argument be formatted with a particular type, you\n-//! are actually requesting that an argument ascribes to a particular trait.\n-//! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n-//! well as `int`).  The current mapping of types to traits is:\n-//!\n-//! * *nothing* \u21d2 `Display`\n-//! * `?` \u21d2 `Debug`\n-//! * `o` \u21d2 `Octal`\n-//! * `x` \u21d2 `LowerHex`\n-//! * `X` \u21d2 `UpperHex`\n-//! * `p` \u21d2 `Pointer`\n-//! * `b` \u21d2 `Binary`\n-//! * `e` \u21d2 `LowerExp`\n-//! * `E` \u21d2 `UpperExp`\n-//!\n-//! What this means is that any type of argument which implements the\n-//! `std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n-//! are provided for these traits for a number of primitive types by the\n-//! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n-//! then the format trait used is the `Display` trait.\n-//!\n-//! When implementing a format trait for your own type, you will have to\n-//! implement a method of the signature:\n-//!\n-//! ```rust\n-//! # use std::fmt;\n-//! # struct Foo; // our custom type\n-//! # impl fmt::Display for Foo {\n-//! fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result {\n-//! # write!(f, \"testing, testing\")\n-//! # } }\n-//! ```\n-//!\n-//! Your type will be passed as `self` by-reference, and then the function\n-//! should emit output into the `f.buf` stream. It is up to each format trait\n-//! implementation to correctly adhere to the requested formatting parameters.\n-//! The values of these parameters will be listed in the fields of the\n-//! `Formatter` struct. In order to help with this, the `Formatter` struct also\n-//! provides some helper methods.\n-//!\n-//! Additionally, the return value of this function is `fmt::Result` which is a\n-//! typedef to `Result<(), IoError>` (also known as `IoResult<()>`). Formatting\n-//! implementations should ensure that they return errors from `write!`\n-//! correctly (propagating errors upward).\n-//!\n-//! An example of implementing the formatting traits would look\n-//! like:\n-//!\n-//! ```rust\n-//! use std::fmt;\n-//! use std::f64;\n-//! use std::num::Float;\n-//!\n-//! #[derive(Debug)]\n-//! struct Vector2D {\n-//!     x: int,\n-//!     y: int,\n-//! }\n-//!\n-//! impl fmt::Display for Vector2D {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         // The `f` value implements the `Writer` trait, which is what the\n-//!         // write! macro is expecting. Note that this formatting ignores the\n-//!         // various flags provided to format strings.\n-//!         write!(f, \"({}, {})\", self.x, self.y)\n-//!     }\n-//! }\n-//!\n-//! // Different traits allow different forms of output of a type. The meaning\n-//! // of this format is to print the magnitude of a vector.\n-//! impl fmt::Binary for Vector2D {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         let magnitude = (self.x * self.x + self.y * self.y) as f64;\n-//!         let magnitude = magnitude.sqrt();\n-//!\n-//!         // Respect the formatting flags by using the helper method\n-//!         // `pad_integral` on the Formatter object. See the method documentation\n-//!         // for details, and the function `pad` can be used to pad strings.\n-//!         let decimals = f.precision().unwrap_or(3);\n-//!         let string = f64::to_str_exact(magnitude, decimals);\n-//!         f.pad_integral(true, \"\", string.as_slice())\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     let myvector = Vector2D { x: 3, y: 4 };\n-//!\n-//!     println!(\"{}\", myvector);       // => \"(3, 4)\"\n-//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3, y:4}\"\n-//!     println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n-//! }\n-//! ```\n-//!\n-//! #### fmt::Display vs fmt::Debug\n-//!\n-//! These two formatting traits have distinct purposes:\n-//!\n-//! - `fmt::Display` implementations assert that the type can be faithfully\n-//!   represented as a UTF-8 string at all times. It is **not** expected that\n-//!   all types implement the `Display` trait.\n-//! - `fmt::Debug` implementations should be implemented for **all** public types.\n-//!   Output will typically represent the internal state as faithfully as possible.\n-//!   The purpose of the `Debug` trait is to facilitate debugging Rust code. In\n-//!   most cases, using `#[derive(Debug)]` is sufficient and recommended.\n-//!\n-//! Some examples of the output from both traits:\n-//!\n-//! ```\n-//! assert_eq!(format!(\"{} {:?}\", 3i32, 4i32), \"3 4\");\n-//! assert_eq!(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\n-//! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n-//! ```\n-//!\n-//! ### Related macros\n-//!\n-//! There are a number of related macros in the `format!` family. The ones that\n-//! are currently implemented are:\n-//!\n-//! ```ignore\n-//! format!      // described above\n-//! write!       // first argument is a &mut old_io::Writer, the destination\n-//! writeln!     // same as write but appends a newline\n-//! print!       // the format string is printed to the standard output\n-//! println!     // same as print but appends a newline\n-//! format_args! // described below.\n-//! ```\n-//!\n-//! #### `write!`\n-//!\n-//! This and `writeln` are two macros which are used to emit the format string\n-//! to a specified stream. This is used to prevent intermediate allocations of\n-//! format strings and instead directly write the output. Under the hood, this\n-//! function is actually invoking the `write` function defined in this module.\n-//! Example usage is:\n-//!\n-//! ```rust\n-//! # #![allow(unused_must_use)]\n-//! let mut w = Vec::new();\n-//! write!(&mut w, \"Hello {}!\", \"world\");\n-//! ```\n-//!\n-//! #### `print!`\n-//!\n-//! This and `println` emit their output to stdout. Similarly to the `write!`\n-//! macro, the goal of these macros is to avoid intermediate allocations when\n-//! printing output. Example usage is:\n-//!\n-//! ```rust\n-//! print!(\"Hello {}!\", \"world\");\n-//! println!(\"I have a newline {}\", \"character at the end\");\n-//! ```\n-//!\n-//! #### `format_args!`\n-//! This is a curious macro which is used to safely pass around\n-//! an opaque object describing the format string. This object\n-//! does not require any heap allocations to create, and it only\n-//! references information on the stack. Under the hood, all of\n-//! the related macros are implemented in terms of this. First\n-//! off, some example usage is:\n-//!\n-//! ```\n-//! use std::fmt;\n-//! use std::old_io;\n-//!\n-//! fmt::format(format_args!(\"this returns {}\", \"String\"));\n-//!\n-//! let mut some_writer = old_io::stdout();\n-//! write!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n-//!\n-//! fn my_fmt_fn(args: fmt::Arguments) {\n-//!     write!(&mut old_io::stdout(), \"{}\", args);\n-//! }\n-//! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n-//! ```\n-//!\n-//! The result of the `format_args!` macro is a value of type `fmt::Arguments`.\n-//! This structure can then be passed to the `write` and `format` functions\n-//! inside this module in order to process the format string.\n-//! The goal of this macro is to even further prevent intermediate allocations\n-//! when dealing formatting strings.\n-//!\n-//! For example, a logging library could use the standard formatting syntax, but\n-//! it would internally pass around this structure until it has been determined\n-//! where output should go to.\n-//!\n-//! ## Syntax\n-//!\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ format <text> ] *\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | ''\n-//! count := parameter | integer\n-//! parameter := integer '$'\n-//! ```\n-//!\n-//! ## Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted. This\n-//! syntax draws heavily from Python's, so it may seem a bit familiar.\n-//!\n-//! ### Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the `width`\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of two\n-//! options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! ### Sign/#/0\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * '+' - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (+ or -)\n-//!         should always be printed.\n-//! * '-' - Currently not used\n-//! * '#' - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. By default, this only applies to the integer formatting\n-//!         traits and performs like:\n-//!     * `x` - precedes the argument with a \"0x\"\n-//!     * `X` - precedes the argument with a \"0x\"\n-//!     * `t` - precedes the argument with a \"0b\"\n-//!     * `o` - precedes the argument with a \"0o\"\n-//! * '0' - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08d}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!\n-//! ### Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default fill/alignment for non-numerics is a space and left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the '0' flag is specified for numerics, then the implicit fill character is\n-//! '0'.\n-//!\n-//! The value for the width can also be provided as a `uint` in the list of\n-//! parameters by using the `2$` syntax indicating that the second argument is a\n-//! `uint` specifying the width.\n-//!\n-//! ### Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the\n-//! resulting string is longer than this width, then it is truncated down to\n-//! this many characters and only those are emitted.\n-//!\n-//! For integral types, this has no meaning currently.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal\n-//! point should be printed.\n-//!\n-//! ## Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-\n-#![unstable(feature = \"std_misc\")]\n-\n-pub use core::fmt::{Formatter, Result, Writer, rt};\n-pub use core::fmt::{Show, String, Octal, Binary};\n-pub use core::fmt::{Display, Debug};\n-pub use core::fmt::{LowerHex, UpperHex, Pointer};\n-pub use core::fmt::{LowerExp, UpperExp};\n-pub use core::fmt::Error;\n-pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n-\n-pub use core_collections::fmt::format;"}, {"sha": "9a9a554ec98420e1ba84e893a4642f0f2b359500", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea85d43903ead3317bf6153fea9f77a5c4a904f1/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea85d43903ead3317bf6153fea9f77a5c4a904f1/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ea85d43903ead3317bf6153fea9f77a5c4a904f1", "patch": "@@ -181,6 +181,7 @@ pub use core::error;\n #[cfg(not(test))] pub use alloc::boxed;\n pub use alloc::rc;\n \n+pub use core_collections::fmt;\n pub use core_collections::slice;\n pub use core_collections::str;\n pub use core_collections::string;\n@@ -246,7 +247,6 @@ pub mod thread_local;\n \n pub mod dynamic_lib;\n pub mod ffi;\n-pub mod fmt;\n pub mod old_io;\n pub mod io;\n pub mod os;"}]}