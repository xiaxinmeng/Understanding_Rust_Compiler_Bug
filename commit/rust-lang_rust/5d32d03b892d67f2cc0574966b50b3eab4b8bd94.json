{"sha": "5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMzJkMDNiODkyZDY3ZjJjYzA1NzQ5NjZiNTBiM2VhYjRiOGJkOTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-26T15:51:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-30T21:49:28Z"}, "message": "Fix #2979: inference for lifetimes of & expressions\n\nWhat we now do is to create a region variable for each &\nexpression (and also each borrow).  The lifetime of this\nvariable will be checked by borrowck to ensure it is not greater\nthan the lifetime of the underlying data.  This both leads to\nshorter lifetimes in some cases but also longer in others,\nsuch as taking the address to the interior of unique boxes\ntht are rooted in region pointers (e.g., returning a pointer\nto the interior of a sendable map).\n\nThis may lead to issue #2977 if the rvalue is not POD, because\nwe may drop the data in trans sooner than borrowck expects us\nto.  Need to work out precisely where that fix ought to occur.", "tree": {"sha": "60317b676fef08e531fb6e6af243222e6192f571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60317b676fef08e531fb6e6af243222e6192f571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "html_url": "https://github.com/rust-lang/rust/commit/5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef13e76e95ea67103a2bc4f4becc91dc290aafc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef13e76e95ea67103a2bc4f4becc91dc290aafc", "html_url": "https://github.com/rust-lang/rust/commit/6ef13e76e95ea67103a2bc4f4becc91dc290aafc"}], "stats": {"total": 1041, "additions": 719, "deletions": 322}, "files": [{"sha": "1428d9e898230b8a1bd03d5fc490778dbde19d3a", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -436,21 +436,6 @@ impl of tr for method_origin {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding of borrow\n-\n-trait read_borrow_helper {\n-    fn read_borrow(xcx: extended_decode_ctxt) -> ty::borrow;\n-}\n-\n-impl helper of read_borrow_helper for ebml::ebml_deserializer {\n-    fn read_borrow(xcx: extended_decode_ctxt) -> ty::borrow {\n-        let borrow = ty::deserialize_borrow(self);\n-        {scope_id: xcx.tr_id(borrow.scope_id),\n-         mutbl: borrow.mutbl}\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n@@ -766,11 +751,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.borrowings.find(id)) |borrow| {\n+    do option::iter(tcx.borrowings.find(id)) |_borrow| {\n         do ebml_w.tag(c::tag_table_borrowings) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                ty::serialize_borrow(ebml_w, borrow)\n+                // N.B. We don't actually serialize borrows as, in\n+                // trans, we only care whether a value is borrowed or\n+                // not.\n             }\n         }\n     }\n@@ -890,7 +877,10 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));\n             } else if tag == (c::tag_table_borrowings as uint) {\n-                let borrow = val_dsr.read_borrow(xcx);\n+                // N.B.: we don't actually *serialize* borrows because, in\n+                // trans, the only thing we care about is whether a value was\n+                // borrowed or not.\n+                let borrow = {region: ty::re_static, mutbl: ast::m_imm};\n                 dcx.tcx.borrowings.insert(id, borrow);\n             } else {\n                 xcx.dcx.tcx.sess.bug("}, {"sha": "df09a585f472dac1876f2af96ab562d9501be6a1", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -321,9 +321,10 @@ type binding_map = std::map::hashmap<ast::node_id, ast::mutability>;\n enum bckerr_code {\n     err_mut_uniq,\n     err_mut_variant,\n-    err_preserve_gc,\n-    err_mutbl(ast::mutability,\n-              ast::mutability)\n+    err_root_not_permitted,\n+    err_mutbl(ast::mutability, ast::mutability),\n+    err_out_of_root_scope(ty::region, ty::region), // superscope, subscope\n+    err_out_of_scope(ty::region, ty::region) // superscope, subscope\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -346,7 +347,7 @@ enum categorization {\n }\n \n // different kinds of pointers:\n-enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n+enum ptr_kind {uniq_ptr, gc_ptr, region_ptr(ty::region), unsafe_ptr}\n \n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n@@ -391,10 +392,15 @@ enum loan_path {\n     lp_comp(@loan_path, comp_kind)\n }\n \n-// a complete record of a loan that was granted\n+/// a complete record of a loan that was granted\n type loan = {lp: @loan_path, cmt: cmt, mutbl: ast::mutability};\n \n-// maps computed by `gather_loans` that are then used by `check_loans`\n+/// maps computed by `gather_loans` that are then used by `check_loans`\n+///\n+/// - `req_loan_map`: map from each block/expr to the required loans needed\n+///   for the duration of that block/expr\n+/// - `pure_map`: map from block/expr that must be pure to the error message\n+///   that should be reported if they are not pure\n type req_maps = {\n     req_loan_map: hashmap<ast::node_id, @dvec<@dvec<loan>>>,\n     pure_map: hashmap<ast::node_id, bckerr>\n@@ -519,7 +525,7 @@ impl to_str_methods for borrowck_ctxt {\n         alt ptr {\n           uniq_ptr { ~\"~\" }\n           gc_ptr { ~\"@\" }\n-          region_ptr { ~\"&\" }\n+          region_ptr(_) { ~\"&\" }\n           unsafe_ptr { ~\"*\" }\n         }\n     }\n@@ -561,15 +567,6 @@ impl to_str_methods for borrowck_ctxt {\n              ty_to_str(self.tcx, cmt.ty)]\n     }\n \n-    fn pk_to_sigil(pk: ptr_kind) -> ~str {\n-        alt pk {\n-          uniq_ptr {~\"~\"}\n-          gc_ptr {~\"@\"}\n-          region_ptr {~\"&\"}\n-          unsafe_ptr {~\"*\"}\n-        }\n-    }\n-\n     fn cmt_to_str(cmt: cmt) -> ~str {\n         let mut_str = self.mut_to_str(cmt.mutbl);\n         alt cmt.cat {\n@@ -584,7 +581,7 @@ impl to_str_methods for borrowck_ctxt {\n           cat_binding(_) { ~\"pattern binding\" }\n           cat_arg(_) { ~\"argument\" }\n           cat_deref(_, _, pk) { #fmt[\"dereference of %s %s pointer\",\n-                                     mut_str, self.pk_to_sigil(pk)] }\n+                                     mut_str, self.ptr_sigil(pk)] }\n           cat_stack_upvar(_) {\n             ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n           }\n@@ -622,12 +619,30 @@ impl to_str_methods for borrowck_ctxt {\n           err_mut_variant {\n             ~\"enum variant in aliasable, mutable location\"\n           }\n-          err_preserve_gc {\n-            ~\"GC'd value would have to be preserved for longer \\\n-                 than the scope of the function\"\n+          err_root_not_permitted {\n+            // note: I don't expect users to ever see this error\n+            // message, reasons are discussed in attempt_root() in\n+            // preserve.rs.\n+            ~\"rooting is not permitted\"\n+          }\n+          err_out_of_root_scope(super_scope, sub_scope) {\n+            #fmt[\"managed value would have to be rooted for lifetime %s, \\\n+                  but can only be rooted for lifetime %s\",\n+                 self.region_to_str(sub_scope),\n+                 self.region_to_str(super_scope)]\n+          }\n+          err_out_of_scope(super_scope, sub_scope) {\n+            #fmt[\"borrowed pointer has lifetime %s, \\\n+                  but the borrowed value only has lifetime %s\",\n+                 self.region_to_str(sub_scope),\n+                 self.region_to_str(super_scope)]\n           }\n         }\n     }\n+\n+    fn region_to_str(r: ty::region) -> ~str {\n+        region_to_str(self.tcx, r)\n+    }\n }\n \n // The inherent mutability of a component is its default mutability"}, {"sha": "d8c88d415acd680de3aa233637e4a9ec1241e72f", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -50,10 +50,10 @@ fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n         some(deref_ptr(uniq_ptr))\n       }\n \n-      ty::ty_rptr(*) |\n-      ty::ty_evec(_, ty::vstore_slice(_)) |\n-      ty::ty_estr(ty::vstore_slice(_)) {\n-        some(deref_ptr(region_ptr))\n+      ty::ty_rptr(r, _) |\n+      ty::ty_evec(_, ty::vstore_slice(r)) |\n+      ty::ty_estr(ty::vstore_slice(r)) {\n+        some(deref_ptr(region_ptr(r)))\n       }\n \n       ty::ty_box(*) |\n@@ -343,7 +343,7 @@ impl public_methods for borrowck_ctxt {\n                     // not loanable.\n                     alt ptr {\n                       uniq_ptr => {some(@lp_deref(l, ptr))}\n-                      gc_ptr | region_ptr | unsafe_ptr => {none}\n+                      gc_ptr | region_ptr(_) | unsafe_ptr => {none}\n                     }\n                 };\n \n@@ -353,7 +353,7 @@ impl public_methods for borrowck_ctxt {\n                   uniq_ptr => {\n                     self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                   }\n-                  gc_ptr | region_ptr | unsafe_ptr => {\n+                  gc_ptr | region_ptr(_) | unsafe_ptr => {\n                     mt.mutbl\n                   }\n                 };\n@@ -402,7 +402,7 @@ impl public_methods for borrowck_ctxt {\n               uniq_ptr => {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n-              gc_ptr | region_ptr | unsafe_ptr => {\n+              gc_ptr | region_ptr(_) | unsafe_ptr => {\n                 mt.mutbl\n               }\n             };"}, {"sha": "87e8ad7a9f2e577e8245a140fefddccbc4cbf475", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 159, "deletions": 60, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -8,35 +8,94 @@\n \n import categorization::{public_methods, opt_deref_kind};\n import loan::public_methods;\n-import preserve::public_methods;\n+import preserve::{public_methods, preserve_condition, pc_ok, pc_if_pure};\n \n export gather_loans;\n \n-enum gather_loan_ctxt = @{bccx: borrowck_ctxt, req_maps: req_maps};\n+/// Context used while gathering loans:\n+///\n+/// - `bccx`: the the borrow check context\n+/// - `req_maps`: the maps computed by `gather_loans()`, see def'n of the\n+///   type `req_maps` for more info\n+/// - `item_ub`: the id of the block for the enclosing fn/method item\n+/// - `root_ub`: the id of the outermost block for which we can root\n+///   an `@T`.  This is the id of the innermost enclosing\n+///   loop or function body.\n+///\n+/// The role of `root_ub` is to prevent us from having to accumulate\n+/// vectors of rooted items at runtime.  Consider this case:\n+///\n+///     fn foo(...) -> int {\n+///         let mut ptr: &int;\n+///         while some_cond {\n+///             let x: @int = ...;\n+///             ptr = &*x;\n+///         }\n+///         *ptr\n+///     }\n+///\n+/// If we are not careful here, we would infer the scope of the borrow `&*x`\n+/// to be the body of the function `foo()` as a whole.  We would then\n+/// have root each `@int` that is produced, which is an unbounded number.\n+/// No good.  Instead what will happen is that `root_ub` will be set to the\n+/// body of the while loop and we will refuse to root the pointer `&*x`\n+/// because it would have to be rooted for a region greater than `root_ub`.\n+enum gather_loan_ctxt = @{bccx: borrowck_ctxt,\n+                          req_maps: req_maps,\n+                          mut item_ub: ast::node_id,\n+                          mut root_ub: ast::node_id};\n \n fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n     let glcx = gather_loan_ctxt(@{bccx: bccx,\n                                   req_maps: {req_loan_map: int_hash(),\n-                                             pure_map: int_hash()}});\n-    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr\n+                                             pure_map: int_hash()},\n+                                  mut item_ub: 0,\n+                                  mut root_ub: 0});\n+    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr,\n+                           visit_fn: req_loans_in_fn,\n                            with *visit::default_visitor()});\n     visit::visit_crate(*crate, glcx, v);\n     ret glcx.req_maps;\n }\n \n+fn req_loans_in_fn(fk: visit::fn_kind,\n+                   decl: ast::fn_decl,\n+                   body: ast::blk,\n+                   sp: span,\n+                   id: ast::node_id,\n+                   &&self: gather_loan_ctxt,\n+                   v: visit::vt<gather_loan_ctxt>) {\n+    // see explanation attached to the `root_ub` field:\n+    let old_item_id = self.item_ub;\n+    let old_root_ub = self.root_ub;\n+    self.root_ub = body.node.id;\n+\n+    alt fk {\n+      visit::fk_anon(*) | visit::fk_fn_block(*) {}\n+      visit::fk_item_fn(*) | visit::fk_method(*) |\n+      visit::fk_ctor(*) | visit::fk_dtor(*) {\n+        self.item_ub = body.node.id;\n+      }\n+    }\n+\n+    visit::visit_fn(fk, decl, body, sp, id, self, v);\n+    self.root_ub = old_root_ub;\n+    self.item_ub = old_item_id;\n+}\n+\n fn req_loans_in_expr(ex: @ast::expr,\n                      &&self: gather_loan_ctxt,\n                      vt: visit::vt<gather_loan_ctxt>) {\n     let bccx = self.bccx;\n     let tcx = bccx.tcx;\n+    let old_root_ub = self.root_ub;\n \n     #debug[\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)];\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each |borrow| {\n         let cmt = self.bccx.cat_borrow_of_expr(ex);\n-        let scope_r = ty::re_scope(borrow.scope_id);\n-        self.guarantee_valid(cmt, borrow.mutbl, scope_r);\n+        self.guarantee_valid(cmt, borrow.mutbl, borrow.region);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -51,6 +110,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n               ty::ty_rptr(r, _) { r }\n             };\n         self.guarantee_valid(base_cmt, mutbl, scope_r);\n+        visit::visit_expr(ex, self, vt);\n       }\n \n       ast::expr_call(f, args, _) {\n@@ -92,7 +152,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 // fine).\n                 //\n                 alt opt_deref_kind(arg_ty.ty) {\n-                  some(deref_ptr(region_ptr)) |\n+                  some(deref_ptr(region_ptr(_))) |\n                   some(deref_ptr(unsafe_ptr)) {\n                     /* region pointers are (by induction) guaranteed */\n                     /* unsafe pointers are the user's problem */\n@@ -110,6 +170,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n               ast::by_move | ast::by_copy {}\n             }\n         }\n+        visit::visit_expr(ex, self, vt);\n       }\n \n       ast::expr_alt(ex_v, arms, _) {\n@@ -119,6 +180,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n                 self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n             }\n         }\n+        visit::visit_expr(ex, self, vt);\n       }\n \n       ast::expr_index(rcvr, _) |\n@@ -136,6 +198,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let scope_r = ty::re_scope(ex.id);\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n+        visit::visit_expr(ex, self, vt);\n       }\n \n       ast::expr_field(rcvr, _, _)\n@@ -151,13 +214,34 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let scope_r = ty::re_scope(self.tcx().region_map.get(ex.id));\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n+        visit::visit_expr(ex, self, vt);\n       }\n \n-      _ { /*ok*/ }\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_while(cond, body) {\n+        // during the condition, can only root for the condition\n+        self.root_ub = cond.id;\n+        vt.visit_expr(cond, self, vt);\n+\n+        // during body, can only root for the body\n+        self.root_ub = body.node.id;\n+        vt.visit_block(body, self, vt);\n+      }\n+\n+      // see explanation attached to the `root_ub` field:\n+      ast::expr_loop(body) {\n+        self.root_ub = body.node.id;\n+        visit::visit_expr(ex, self, vt);\n+      }\n+\n+      _ => {\n+        visit::visit_expr(ex, self, vt);\n+      }\n     }\n \n     // Check any contained expressions:\n-    visit::visit_expr(ex, self, vt);\n+\n+    self.root_ub = old_root_ub;\n }\n \n impl methods for gather_loan_ctxt {\n@@ -192,65 +276,69 @@ impl methods for gather_loan_ctxt {\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n           some(_) {\n-            alt scope_r {\n-              ty::re_scope(scope_id) {\n-                let loans = self.bccx.loan(cmt, req_mutbl);\n-                self.add_loans(scope_id, loans);\n-\n-                if req_mutbl == m_imm && cmt.mutbl != m_imm {\n-                    self.bccx.loaned_paths_imm += 1;\n-\n-                    if self.tcx().sess.borrowck_note_loan() {\n-                        self.bccx.span_note(\n-                            cmt.span,\n-                            #fmt[\"immutable loan required\"]);\n+            alt self.bccx.loan(cmt, scope_r, req_mutbl) {\n+              err(e) => { self.bccx.report(e); }\n+              ok(loans) if loans.len() == 0 => {}\n+              ok(loans) => {\n+                alt scope_r {\n+                  ty::re_scope(scope_id) => {\n+                    self.add_loans(scope_id, loans);\n+\n+                    if req_mutbl == m_imm && cmt.mutbl != m_imm {\n+                        self.bccx.loaned_paths_imm += 1;\n+\n+                        if self.tcx().sess.borrowck_note_loan() {\n+                            self.bccx.span_note(\n+                                cmt.span,\n+                                #fmt[\"immutable loan required\"]);\n+                        }\n+                    } else {\n+                        self.bccx.loaned_paths_same += 1;\n                     }\n-                } else {\n-                    self.bccx.loaned_paths_same += 1;\n+                  }\n+                  _ => {\n+                    self.bccx.tcx.sess.span_bug(\n+                        cmt.span,\n+                        #fmt[\"loans required but scope is scope_region is %s\",\n+                             region_to_str(self.tcx(), scope_r)]);\n+                  }\n                 }\n               }\n-              _ {\n-                self.bccx.span_err(\n-                    cmt.span,\n-                    #fmt[\"cannot guarantee the stability \\\n-                          of this expression for the entirety of \\\n-                          its lifetime, %s\",\n-                         region_to_str(self.tcx(), scope_r)]);\n-              }\n             }\n           }\n \n-          // The path is not loanable: in that case, we must try and preserve\n-          // it dynamically (or see that it is preserved by virtue of being\n-          // rooted in some immutable path)\n+          // The path is not loanable: in that case, we must try and\n+          // preserve it dynamically (or see that it is preserved by\n+          // virtue of being rooted in some immutable path).  We must\n+          // also check that the mutability of the desired pointer\n+          // matches with the actual mutability (but if an immutable\n+          // pointer is desired, that is ok as long as we are pure)\n           none {\n-            let opt_scope_id = alt scope_r {\n-              ty::re_scope(scope_id) { some(scope_id) }\n-              _ { none }\n-            };\n-\n-            let result = {\n-                do self.check_mutbl(req_mutbl, cmt).chain |_ok| {\n-                    self.bccx.preserve(cmt, opt_scope_id)\n+            let result: bckres<preserve_condition> = {\n+                do self.check_mutbl(req_mutbl, cmt).chain |pc1| {\n+                    do self.bccx.preserve(cmt, scope_r,\n+                                          self.item_ub,\n+                                          self.root_ub).chain |pc2| {\n+                        ok(pc1.combine(pc2))\n+                    }\n                 }\n             };\n \n             alt result {\n-              ok(()) {\n+              ok(pc_ok) {\n                 // we were able guarantee the validity of the ptr,\n                 // perhaps by rooting or because it is immutably\n                 // rooted.  good.\n                 self.bccx.stable_paths += 1;\n               }\n-              err(e) {\n-                // not able to guarantee the validity of the ptr.\n-                // rather than report an error, presuming that the\n-                // borrow is for a limited scope, we'll make one last\n-                // ditch effort and require that the scope where the\n-                // borrow occurs be pure.\n-                alt opt_scope_id {\n-                  some(scope_id) {\n-                    self.req_maps.pure_map.insert(scope_id, e);\n+              ok(pc_if_pure(e)) {\n+                // we are only able to guarantee the validity if\n+                // the scope is pure\n+                alt scope_r {\n+                  ty::re_scope(pure_id) => {\n+                    // if the scope is some block/expr in the fn,\n+                    // then just require that this scope be pure\n+                    self.req_maps.pure_map.insert(pure_id, e);\n                     self.bccx.req_pure_paths += 1;\n \n                     if self.tcx().sess.borrowck_note_pure() {\n@@ -259,12 +347,17 @@ impl methods for gather_loan_ctxt {\n                             #fmt[\"purity required\"]);\n                     }\n                   }\n-                  none {\n-                    // otherwise, fine, I give up.\n+                  _ => {\n+                    // otherwise, we can't enforce purity for that\n+                    // scope, so give up and report an error\n                     self.bccx.report(e);\n                   }\n                 }\n               }\n+              err(e) => {\n+                // we cannot guarantee the validity of this pointer\n+                self.bccx.report(e);\n+              }\n             }\n           }\n         }\n@@ -279,19 +372,25 @@ impl methods for gather_loan_ctxt {\n     // reqires an immutable pointer, but `f` lives in (aliased)\n     // mutable memory.\n     fn check_mutbl(req_mutbl: ast::mutability,\n-                   cmt: cmt) -> bckres<()> {\n+                   cmt: cmt) -> bckres<preserve_condition> {\n         alt (req_mutbl, cmt.mutbl) {\n           (m_const, _) |\n           (m_imm, m_imm) |\n-          (m_mutbl, m_mutbl) {\n-            ok(())\n+          (m_mutbl, m_mutbl) => {\n+            ok(pc_ok)\n           }\n \n           (_, m_const) |\n           (m_imm, m_mutbl) |\n-          (m_mutbl, m_imm) {\n-            err({cmt: cmt,\n-                 code: err_mutbl(req_mutbl, cmt.mutbl)})\n+          (m_mutbl, m_imm) => {\n+            let e = {cmt: cmt,\n+                     code: err_mutbl(req_mutbl, cmt.mutbl)};\n+            if req_mutbl == m_imm {\n+                // you can treat mutable things as imm if you are pure\n+                ok(pc_if_pure(e))\n+            } else {\n+                err(e)\n+            }\n           }\n         }\n     }"}, {"sha": "4b1726b69fac7c041e1881765d35f6a2f22313b3", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -3,17 +3,29 @@\n // of the scope S, presuming that the returned set of loans `Ls` are honored.\n \n export public_methods;\n+import result::{result, ok, err};\n \n impl public_methods for borrowck_ctxt {\n-    fn loan(cmt: cmt, mutbl: ast::mutability) -> @dvec<loan> {\n-        let lc = loan_ctxt_(@{bccx: self, loans: @dvec()});\n-        lc.loan(cmt, mutbl);\n-        ret lc.loans;\n+    fn loan(cmt: cmt,\n+            scope_region: ty::region,\n+            mutbl: ast::mutability) -> bckres<@dvec<loan>> {\n+        let lc = loan_ctxt_(@{bccx: self,\n+                              scope_region: scope_region,\n+                              loans: @dvec()});\n+        alt lc.loan(cmt, mutbl) {\n+          ok(()) => {ok(lc.loans)}\n+          err(e) => {err(e)}\n+        }\n     }\n }\n \n type loan_ctxt_ = {\n     bccx: borrowck_ctxt,\n+\n+    // the region scope for which we must preserve the memory\n+    scope_region: ty::region,\n+\n+    // accumulated list of loans that will be required\n     loans: @dvec<loan>\n };\n \n@@ -22,18 +34,30 @@ enum loan_ctxt {\n }\n \n impl loan_methods for loan_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n     fn ok_with_loan_of(cmt: cmt,\n-                       mutbl: ast::mutability) {\n-        // Note: all cmt's that we deal with will have a non-none lp, because\n-        // the entry point into this routine, `borrowck_ctxt::loan()`, rejects\n-        // any cmt with a none-lp.\n-        (*self.loans).push({lp:option::get(cmt.lp),\n-                            cmt:cmt,\n-                            mutbl:mutbl});\n+                       scope_ub: ty::region,\n+                       mutbl: ast::mutability) -> bckres<()> {\n+        let region_map = self.tcx().region_map;\n+        if region::subregion(region_map, scope_ub, self.scope_region) {\n+            // Note: all cmt's that we deal with will have a non-none\n+            // lp, because the entry point into this routine,\n+            // `borrowck_ctxt::loan()`, rejects any cmt with a\n+            // none-lp.\n+            (*self.loans).push({lp: option::get(cmt.lp),\n+                                cmt: cmt,\n+                                mutbl: mutbl});\n+            ok(())\n+        } else {\n+            // The loan being requested lives longer than the data\n+            // being loaned out!\n+            err({cmt:cmt, code:err_out_of_scope(scope_ub,\n+                                                self.scope_region)})\n+        }\n     }\n \n-    fn loan(cmt: cmt, req_mutbl: ast::mutability) {\n-\n+    fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n         #debug[\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n                self.bccx.mut_to_str(req_mutbl)];\n@@ -53,8 +77,12 @@ impl loan_methods for loan_ctxt {\n                 cmt.span,\n                 ~\"rvalue with a non-none lp\");\n           }\n-          cat_local(_) | cat_arg(_) | cat_stack_upvar(_) {\n-            self.ok_with_loan_of(cmt, req_mutbl)\n+          cat_local(local_id) | cat_arg(local_id) {\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n+            self.ok_with_loan_of(cmt, ty::re_scope(local_scope_id), req_mutbl)\n+          }\n+          cat_stack_upvar(cmt) {\n+            self.loan(cmt, req_mutbl) // NDM correct?\n           }\n           cat_discr(base, _) {\n             self.loan(base, req_mutbl)\n@@ -88,7 +116,7 @@ impl loan_methods for loan_ctxt {\n           }\n           cat_deref(cmt1, _, unsafe_ptr) |\n           cat_deref(cmt1, _, gc_ptr) |\n-          cat_deref(cmt1, _, region_ptr) {\n+          cat_deref(cmt1, _, region_ptr(_)) {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n@@ -102,26 +130,31 @@ impl loan_methods for loan_ctxt {\n     // Example: record fields.\n     fn loan_stable_comp(cmt: cmt,\n                         cmt_base: cmt,\n-                        req_mutbl: ast::mutability) {\n+                        req_mutbl: ast::mutability) -> bckres<()> {\n         let base_mutbl = alt req_mutbl {\n           m_imm { m_imm }\n           m_const | m_mutbl { m_const }\n         };\n \n-        self.loan(cmt_base, base_mutbl);\n-        self.ok_with_loan_of(cmt, req_mutbl)\n+        do self.loan(cmt_base, base_mutbl).chain |_ok| {\n+            // can use static for the scope because the base\n+            // determines the lifetime, ultimately\n+            self.ok_with_loan_of(cmt, ty::re_static, req_mutbl)\n+        }\n     }\n \n     // An \"unstable deref\" means a deref of a ptr/comp where, if the\n     // base of the deref is assigned to, pointers into the result of the\n     // deref would be invalidated. Examples: interior of variants, uniques.\n     fn loan_unstable_deref(cmt: cmt,\n                            cmt_base: cmt,\n-                           req_mutbl: ast::mutability) {\n+                           req_mutbl: ast::mutability) -> bckres<()> {\n         // Variant components: the base must be immutable, because\n         // if it is overwritten, the types of the embedded data\n         // could change.\n-        self.loan(cmt_base, m_imm);\n-        self.ok_with_loan_of(cmt, req_mutbl)\n+        do self.loan(cmt_base, m_imm).chain |_ok| {\n+            // can use static, as in loan_stable_comp()\n+            self.ok_with_loan_of(cmt, ty::re_static, req_mutbl)\n+        }\n     }\n }"}, {"sha": "860e4962295a098eb4c70d5e79a6c5e116d7bf8c", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 218, "deletions": 56, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -1,92 +1,173 @@\n // ----------------------------------------------------------------------\n // Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n // the scope S.\n-export public_methods;\n+//\n+\n+export public_methods, preserve_condition, pc_ok, pc_if_pure;\n+\n+enum preserve_condition {\n+    pc_ok,\n+    pc_if_pure(bckerr)\n+}\n+\n+impl public_methods for preserve_condition {\n+    // combines two preservation conditions such that if either of\n+    // them requires purity, the result requires purity\n+    fn combine(pc: preserve_condition) -> preserve_condition {\n+        alt self {\n+          pc_ok => {pc}\n+          pc_if_pure(e) => {self}\n+        }\n+    }\n+}\n \n impl public_methods for borrowck_ctxt {\n-    fn preserve(cmt: cmt, opt_scope_id: option<ast::node_id>) -> bckres<()> {\n-        #debug[\"preserve(%s)\", self.cmt_to_repr(cmt)];\n+    fn preserve(cmt: cmt,\n+                scope_region: ty::region,\n+                item_ub: ast::node_id,\n+                root_ub: ast::node_id)\n+        -> bckres<preserve_condition> {\n+\n+        let ctxt = preserve_ctxt({bccx: self,\n+                                  scope_region: scope_region,\n+                                  item_ub: item_ub,\n+                                  root_ub: root_ub,\n+                                  root_managed_data: true});\n+        (&ctxt).preserve(cmt)\n+    }\n+}\n+\n+enum preserve_ctxt = {\n+    bccx: borrowck_ctxt,\n+\n+    // the region scope for which we must preserve the memory\n+    scope_region: ty::region,\n+\n+    // the scope for the body of the enclosing fn/method item\n+    item_ub: ast::node_id,\n+\n+    // the upper bound on how long we can root an @T pointer\n+    root_ub: ast::node_id,\n+\n+    // if false, do not attempt to root managed data\n+    root_managed_data: bool\n+};\n+\n+\n+impl private_methods for &preserve_ctxt {\n+    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+\n+    fn preserve(cmt: cmt) -> bckres<preserve_condition> {\n+        #debug[\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n+               self.bccx.cmt_to_repr(cmt), self.root_ub,\n+               self.root_managed_data];\n         let _i = indenter();\n \n         alt cmt.cat {\n-          cat_rvalue | cat_special(_) {\n-            ok(())\n+          cat_special(sk_self) | cat_special(sk_heap_upvar) {\n+            self.compare_scope(cmt, ty::re_scope(self.item_ub))\n+          }\n+          cat_special(sk_static_item) | cat_special(sk_method) {\n+            ok(pc_ok)\n+          }\n+          cat_rvalue {\n+            // when we borrow an rvalue, we can keep it rooted but only\n+            // up to the root_ub point\n+\n+            // FIXME(#2977)--need to update trans!\n+            self.compare_scope(cmt, ty::re_scope(self.root_ub))\n           }\n           cat_stack_upvar(cmt) {\n-            self.preserve(cmt, opt_scope_id)\n+            self.preserve(cmt)\n           }\n-          cat_local(_) {\n+          cat_local(local_id) {\n             // Normally, local variables are lendable, and so this\n             // case should never trigger.  However, if we are\n             // preserving an expression like a.b where the field `b`\n             // has @ type, then it will recurse to ensure that the `a`\n             // is stable to try and avoid rooting the value `a.b`.  In\n-            // this case, opt_scope_id will be none.\n-            if opt_scope_id.is_some() {\n-                self.tcx.sess.span_bug(\n+            // this case, root_managed_data will be false.\n+            if self.root_managed_data {\n+                self.tcx().sess.span_bug(\n                     cmt.span,\n-                    ~\"preserve() called with local and \\\n-                      non-none opt_scope_id\");\n+                    ~\"preserve() called with local and !root_managed_data\");\n             }\n-            ok(())\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n+            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n-          cat_binding(_) {\n+          cat_binding(local_id) {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            ok(())\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n+            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n-          cat_arg(_) {\n+          cat_arg(local_id) {\n             // This can happen as not all args are lendable (e.g., &&\n-            // modes).  In that case, the caller guarantees stability.\n-            // This is basically a deref of a region ptr.\n-            ok(())\n+            // modes).  In that case, the caller guarantees stability\n+            // for at least the scope of the fn.  This is basically a\n+            // deref of a region ptr.\n+            let local_scope_id = self.tcx().region_map.get(local_id);\n+            self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n           cat_comp(cmt_base, comp_tuple) {\n             // Most embedded components: if the base is stable, the\n             // type never changes.\n-            self.preserve(cmt_base, opt_scope_id)\n+            self.preserve(cmt_base)\n           }\n           cat_comp(cmt_base, comp_variant(enum_did)) {\n-            if ty::enum_is_univariant(self.tcx, enum_did) {\n-                self.preserve(cmt_base, opt_scope_id)\n+            if ty::enum_is_univariant(self.tcx(), enum_did) {\n+                self.preserve(cmt_base)\n             } else {\n                 // If there are multiple variants: overwriting the\n                 // base could cause the type of this memory to change,\n                 // so require imm.\n-                self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_variant)\n+                self.require_imm(cmt, cmt_base, err_mut_variant)\n             }\n           }\n           cat_deref(cmt_base, _, uniq_ptr) {\n             // Overwriting the base could cause this memory to be\n             // freed, so require imm.\n-            self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_uniq)\n+            self.require_imm(cmt, cmt_base, err_mut_uniq)\n           }\n-          cat_deref(_, _, region_ptr) {\n-            // References are always \"stable\" by induction (when the\n-            // reference of type &MT was created, the memory must have\n-            // been stable)\n-            ok(())\n+          cat_deref(_, _, region_ptr(region)) {\n+            // References are always \"stable\" for lifetime `region` by\n+            // induction (when the reference of type &MT was created,\n+            // the memory must have been stable).\n+            self.compare_scope(cmt, region)\n           }\n           cat_deref(_, _, unsafe_ptr) {\n             // Unsafe pointers are the user's problem\n-            ok(())\n+            ok(pc_ok)\n           }\n           cat_deref(base, derefs, gc_ptr) {\n             // GC'd pointers of type @MT: if this pointer lives in\n             // immutable, stable memory, then everything is fine.  But\n             // otherwise we have no guarantee the pointer will stay\n             // live, so we must root the pointer (i.e., inc the ref\n             // count) for the duration of the loan.\n+            #debug[\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl)];\n             if base.mutbl == m_imm {\n-                alt self.preserve(base, none) {\n-                  ok(()) {ok(())}\n-                  err(_) {self.attempt_root(cmt, opt_scope_id, base, derefs)}\n+                let non_rooting_ctxt =\n+                    preserve_ctxt({root_managed_data: false with **self});\n+                alt (&non_rooting_ctxt).preserve(base) {\n+                  ok(pc_ok) => {\n+                    ok(pc_ok)\n+                  }\n+                  ok(pc_if_pure(_)) {\n+                    #debug[\"must root @T, otherwise purity req'd\"];\n+                    self.attempt_root(cmt, base, derefs)\n+                  }\n+                  err(e) => {\n+                    #debug[\"must root @T, err: %s\",\n+                           self.bccx.bckerr_code_to_str(e.code)];\n+                    self.attempt_root(cmt, base, derefs)\n+                  }\n                 }\n             } else {\n-                self.attempt_root(cmt, opt_scope_id, base, derefs)\n+                self.attempt_root(cmt, base, derefs)\n             }\n           }\n           cat_discr(base, alt_id) {\n@@ -144,43 +225,124 @@ impl public_methods for borrowck_ctxt {\n             // in the *arm* vs the *alt*.\n \n             // current scope must be the arm, which is always a child of alt:\n-            assert self.tcx.region_map.get(opt_scope_id.get()) == alt_id;\n+            assert {\n+                alt check self.scope_region {\n+                  ty::re_scope(arm_id) => {\n+                    self.tcx().region_map.get(arm_id) == alt_id\n+                  }\n+                  _ => {false}\n+                }\n+            };\n \n-            self.preserve(base, some(alt_id))\n+            let alt_rooting_ctxt =\n+                preserve_ctxt({scope_region: ty::re_scope(alt_id)\n+                               with **self});\n+            (&alt_rooting_ctxt).preserve(base)\n           }\n         }\n     }\n-}\n \n-impl private_methods for borrowck_ctxt {\n+    /// Reqiures that `cmt` (which is a deref or subcomponent of\n+    /// `base`) be found in an immutable location (that is, `base`\n+    /// must be immutable).  Also requires that `base` itself is\n+    /// preserved.\n     fn require_imm(cmt: cmt,\n                    cmt_base: cmt,\n-                   opt_scope_id: option<ast::node_id>,\n-                   code: bckerr_code) -> bckres<()> {\n+                   code: bckerr_code) -> bckres<preserve_condition> {\n         // Variant contents and unique pointers: must be immutably\n         // rooted to a preserved address.\n-        alt cmt_base.mutbl {\n-          m_mutbl | m_const { err({cmt:cmt, code:code}) }\n-          m_imm { self.preserve(cmt_base, opt_scope_id) }\n+        alt self.preserve(cmt_base) {\n+          // the base is preserved, but if we are not mutable then\n+          // purity is required\n+          ok(pc_ok) => {\n+            alt cmt_base.mutbl {\n+              m_mutbl | m_const => {\n+                ok(pc_if_pure({cmt:cmt, code:code}))\n+              }\n+              m_imm => {\n+                ok(pc_ok)\n+              }\n+            }\n+          }\n+\n+          // the base requires purity too, that's fine\n+          ok(pc_if_pure(e)) => {\n+            ok(pc_if_pure(e))\n+          }\n+\n+          // base is not stable, doesn't matter\n+          err(e) => {\n+            err(e)\n+          }\n         }\n     }\n \n-    fn attempt_root(cmt: cmt, opt_scope_id: option<ast::node_id>,\n-                    base: cmt, derefs: uint) -> bckres<()> {\n-        alt opt_scope_id {\n-          some(scope_id) {\n-            #debug[\"Inserting root map entry for %s: \\\n-                    node %d:%u -> scope %d\",\n-                   self.cmt_to_repr(cmt), base.id,\n-                   derefs, scope_id];\n+    /// Checks that the scope for which the value must be preserved\n+    /// is a subscope of `scope_ub`; if so, success.\n+    fn compare_scope(cmt: cmt,\n+                     scope_ub: ty::region) -> bckres<preserve_condition> {\n+        let region_map = self.tcx().region_map;\n+        if region::subregion(region_map, scope_ub, self.scope_region) {\n+            ok(pc_ok)\n+        } else {\n+            err({cmt:cmt, code:err_out_of_scope(scope_ub,\n+                                                self.scope_region)})\n+        }\n+    }\n+\n+    /// Here, `cmt=*base` is always a deref of managed data (if\n+    /// `derefs` != 0, then an auto-deref).  This routine determines\n+    /// whether it is safe to MAKE cmt stable by rooting the pointer\n+    /// `base`.  We can only do the dynamic root if the desired\n+    /// lifetime `self.scope_region` is a subset of `self.root_ub`\n+    /// scope; otherwise, it would either require that we hold the\n+    /// value live for longer than the current fn or else potentially\n+    /// require that an statically unbounded number of values be\n+    /// rooted (if a loop exists).\n+    fn attempt_root(cmt: cmt, base: cmt,\n+                    derefs: uint) -> bckres<preserve_condition> {\n+        if !self.root_managed_data {\n+            // normally, there is a root_ub; the only time that this\n+            // is none is when a boxed value is stored in an immutable\n+            // location.  In that case, we will test to see if that\n+            // immutable location itself can be preserved long enough\n+            // in which case no rooting is necessary.  But there it\n+            // would be sort of pointless to avoid rooting the inner\n+            // box by rooting an outer box, as it would just keep more\n+            // memory live than necessary, so we set root_ub to none.\n+            ret err({cmt:cmt, code:err_root_not_permitted});\n+        }\n \n-            let rk = {id: base.id, derefs: derefs};\n-            self.root_map.insert(rk, scope_id);\n-            ok(())\n+        let root_region = ty::re_scope(self.root_ub);\n+        alt self.scope_region {\n+          // we can only root values if the desired region is some concrete\n+          // scope within the fn body\n+          ty::re_scope(scope_id) => {\n+            let region_map = self.tcx().region_map;\n+            #debug[\"Considering root map entry for %s: \\\n+                    node %d:%u -> scope_id %?, root_ub %?\",\n+                   self.bccx.cmt_to_repr(cmt), base.id,\n+                   derefs, scope_id, self.root_ub];\n+            if region::subregion(region_map, root_region, self.scope_region) {\n+                #debug[\"Elected to root\"];\n+                let rk = {id: base.id, derefs: derefs};\n+                self.bccx.root_map.insert(rk, scope_id);\n+                ret ok(pc_ok);\n+            } else {\n+                #debug[\"Unable to root\"];\n+                ret err({cmt:cmt,\n+                         code:err_out_of_root_scope(root_region,\n+                                                    self.scope_region)});\n+            }\n           }\n-          none {\n-            err({cmt:cmt, code:err_preserve_gc})\n+\n+          // we won't be able to root long enough\n+          _ => {\n+              ret err({cmt:cmt,\n+                       code:err_out_of_root_scope(root_region,\n+                                                  self.scope_region)});\n           }\n+\n         }\n     }\n }"}, {"sha": "07704de129774e7d9e5e0c5c6ab5df70c77d02d4", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -63,24 +63,19 @@ class LanguageItems {\n }\n \n class LanguageItemCollector {\n-    let items: LanguageItems;\n+    let items: &LanguageItems;\n \n     let crate: @crate;\n     let session: session;\n \n     let item_refs: hashmap<~str,&mut option<def_id>>;\n \n-    new(crate: @crate, session: session) {\n+    new(crate: @crate, session: session, items: &self/LanguageItems) {\n         self.crate = crate;\n         self.session = session;\n-\n-        self.items = LanguageItems();\n-\n+        self.items = items;\n         self.item_refs = str_hash();\n-    }\n \n-    // XXX: Needed to work around an issue with constructors.\n-    fn init() {\n         self.item_refs.insert(~\"const\", &mut self.items.const_trait);\n         self.item_refs.insert(~\"copy\", &mut self.items.copy_trait);\n         self.item_refs.insert(~\"send\", &mut self.items.send_trait);\n@@ -206,16 +201,16 @@ class LanguageItemCollector {\n     }\n \n     fn collect() {\n-        self.init();\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();\n     }\n }\n \n fn collect_language_items(crate: @crate, session: session) -> LanguageItems {\n-    let collector = LanguageItemCollector(crate, session);\n+    let items = LanguageItems();\n+    let collector = LanguageItemCollector(crate, session, &items);\n     collector.collect();\n-    copy collector.items\n+    copy items\n }\n "}, {"sha": "d0dc1ea28f7fba0be4c5a49e4adf8778d18410a8", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -39,6 +39,15 @@ type ctxt = {\n     def_map: resolve3::DefMap,\n     region_map: region_map,\n \n+    // Generally speaking, expressions are parented to their innermost\n+    // enclosing block. But some kinds of expressions serve as\n+    // parents: calls, methods, etc.  In addition, some expressions\n+    // serve as parents by virtue of where they appear.  For example,\n+    // the condition in a while loop is always a parent.  In those\n+    // cases, we add the node id of such an expression to this set so\n+    // that when we visit it we can view it as a parent.\n+    root_exprs: hashmap<ast::node_id, ()>,\n+\n     // The parent scope is the innermost block, call, or alt\n     // expression during the execution of which the current expression\n     // will be evaluated.  Generally speaking, the innermost parent\n@@ -87,6 +96,27 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n     ret true;\n }\n \n+/// Determines whether one region is a subregion of another.  This is\n+/// intended to run *after inference* and sadly the logic is somewhat\n+/// duplicated with the code in infer.rs.\n+fn subregion(region_map: region_map,\n+             super_region: ty::region,\n+             sub_region: ty::region) -> bool {\n+    super_region == sub_region ||\n+        alt (super_region, sub_region) {\n+          (ty::re_static, _) => {true}\n+\n+          (ty::re_scope(super_scope), ty::re_scope(sub_scope)) |\n+          (ty::re_free(super_scope, _), ty::re_scope(sub_scope)) => {\n+            scope_contains(region_map, super_scope, sub_scope)\n+          }\n+\n+          _ => {\n+            false\n+          }\n+        }\n+}\n+\n /// Finds the nearest common ancestor (if any) of two scopes.  That\n /// is, finds the smallest scope which is greater than or equal to\n /// both `scope_a` and `scope_b`.\n@@ -198,31 +228,37 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n+\n+    let mut new_cx = cx;\n     alt expr.node {\n-      ast::expr_call(*) {\n+      ast::expr_call(*) => {\n         #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n-        let new_cx = {parent: some(expr.id) with cx};\n-        visit::visit_expr(expr, new_cx, visitor);\n+        new_cx.parent = some(expr.id);\n       }\n-      ast::expr_alt(subexpr, _, _) {\n+      ast::expr_alt(subexpr, _, _) => {\n         #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n-        let new_cx = {parent: some(expr.id) with cx};\n-        visit::visit_expr(expr, new_cx, visitor);\n+        new_cx.parent = some(expr.id);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n-      ast::expr_fn_block(_, _, cap_clause) {\n+      ast::expr_fn_block(_, _, cap_clause) => {\n         // although the capture items are not expressions per se, they\n         // do get \"evaluated\" in some sense as copies or moves of the\n         // relevant variables so we parent them like an expression\n         for (*cap_clause).each |cap_item| {\n-            record_parent(cx, cap_item.id);\n+            record_parent(new_cx, cap_item.id);\n         }\n-        visit::visit_expr(expr, cx, visitor);\n       }\n-      _ {\n-        visit::visit_expr(expr, cx, visitor);\n+      ast::expr_while(cond, _) => {\n+        new_cx.root_exprs.insert(cond.id, ());\n       }\n+      _ => {}\n+    };\n+\n+    if new_cx.root_exprs.contains_key(expr.id) {\n+        new_cx.parent = some(expr.id);\n     }\n+\n+    visit::visit_expr(expr, new_cx, visitor);\n }\n \n fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n@@ -269,6 +305,7 @@ fn resolve_crate(sess: session, def_map: resolve3::DefMap,\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n                     region_map: int_hash(),\n+                    root_exprs: int_hash(),\n                     parent: none};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,"}, {"sha": "e58de56703af807288bf24a79904a24e6b26a37a", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -213,9 +213,11 @@ enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-#[auto_serialize]\n+// N.B.: Borrows from inlined content are not accurately deserialized.  This\n+// is because we don't need the details in trans, we only care if there is an\n+// entry in the table or not.\n type borrow = {\n-    scope_id: ast::node_id,\n+    region: ty::region,\n     mutbl: ast::mutability\n };\n "}, {"sha": "e7575ff0f1f46bbae49fe3d927016a65163870f5", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -105,7 +105,6 @@ type fn_ctxt_ =\n      // use.  In practice, this is the innermost loop or function\n      // body.\n      mut region_lb: ast::node_id,\n-     mut region_ub: ast::node_id,\n \n      in_scope_regions: isr_alist,\n \n@@ -130,7 +129,6 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                infcx: infer::new_infer_ctxt(ccx.tcx),\n                locals: int_hash(),\n                mut region_lb: region_bnd,\n-               mut region_ub: region_bnd,\n                in_scope_regions: @nil,\n                node_types: map::int_hash(),\n                node_type_substs: map::int_hash(),\n@@ -246,7 +244,6 @@ fn check_fn(ccx: @crate_ctxt,\n                    infcx: infcx,\n                    locals: locals,\n                    mut region_lb: body.node.id,\n-                   mut region_ub: body.node.id,\n                    in_scope_regions: isr,\n                    node_types: node_types,\n                    node_type_substs: node_type_substs,\n@@ -600,15 +597,13 @@ impl methods for @fn_ctxt {\n \n     fn mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n                    sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, borrow_lb: borrow_lb,\n-                     borrow_ub: self.region_ub};\n+        let anmnt = {expr_id: expr.id, span: expr.span, borrow_lb: borrow_lb};\n         infer::mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n     fn can_mk_assignty(expr: @ast::expr, borrow_lb: ast::node_id,\n-                      sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n-        let anmnt = {expr_id: expr.id, borrow_lb: borrow_lb,\n-                     borrow_ub: self.region_ub};\n+                       sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n+        let anmnt = {expr_id: expr.id, span: expr.span, borrow_lb: borrow_lb};\n         infer::can_mk_assignty(self.infcx, anmnt, sub, sup)\n     }\n \n@@ -637,13 +632,6 @@ impl methods for @fn_ctxt {\n         self.region_lb = old_region_lb;\n         ret v;\n     }\n-    fn with_region_ub<R>(ub: ast::node_id, f: fn() -> R) -> R {\n-        let old_region_ub = self.region_ub;\n-        self.region_ub = ub;\n-        let v <- f();\n-        self.region_ub = old_region_ub;\n-        ret v;\n-    }\n }\n \n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n@@ -1376,7 +1364,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, |ty|\n             alt ty { ty::ty_rptr(_, mt) { some(mt.ty) } _ { none } }\n         ));\n-        let region = region_of(fcx, oprnd);\n+        //let region = region_of(fcx, oprnd);\n+        let region = fcx.infcx.next_region_var_with_scope_lb(expr.id);\n         let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n         fcx.write_ty(id, oprnd_t);\n@@ -1446,15 +1435,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n-        do fcx.with_region_ub(body.node.id) {\n-            check_block_no_value(fcx, body);\n-        }\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n       ast::expr_loop(body) {\n-        do fcx.with_region_ub(body.node.id) {\n-            check_block_no_value(fcx, body);\n-        }\n+        check_block_no_value(fcx, body);\n         fcx.write_ty(id, ty::mk_nil(tcx));\n         bot = !may_break(body);\n       }"}, {"sha": "77b7f5cec3bd5195bd137f1ac23212a72f762085", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -276,13 +276,13 @@ fn convert_integral_ty_to_int_ty_set(tcx: ty::ctxt, t: ty::t)\n }\n \n // Extra information needed to perform an assignment that may borrow.\n-// The `expr_id` is the is of the expression whose type is being\n-// assigned, and `borrow_scope` is the region scope to use if the\n-// value should be borrowed.\n+// The `expr_id` and `span` are the id/span of the expression\n+// whose type is being assigned, and `borrow_scope` is the region\n+// scope to use if the value should be borrowed.\n type assignment = {\n     expr_id: ast::node_id,\n+    span: span,\n     borrow_lb: ast::node_id,\n-    borrow_ub: ast::node_id,\n };\n \n type bound<T:copy> = option<T>;\n@@ -325,6 +325,7 @@ enum infer_ctxt = @{\n     region_var_counter: @mut uint,\n \n     borrowings: dvec<{expr_id: ast::node_id,\n+                      span: span,\n                       scope: ty::region,\n                       mutbl: ast::mutability}>\n };\n@@ -422,16 +423,18 @@ fn resolve_region(cx: infer_ctxt, r: ty::region, modes: uint)\n fn resolve_borrowings(cx: infer_ctxt) {\n     for cx.borrowings.each |item| {\n         alt resolve_region(cx, item.scope, resolve_all|force_all) {\n-          ok(ty::re_scope(scope_id)) => {\n-            #debug[\"borrowing for expr %d resolved to scope %d, mutbl %?\",\n-                   item.expr_id, scope_id, item.mutbl];\n+          ok(region) => {\n+            #debug[\"borrowing for expr %d resolved to region %?, mutbl %?\",\n+                   item.expr_id, region, item.mutbl];\n             cx.tcx.borrowings.insert(\n-                item.expr_id, {scope_id: scope_id, mutbl: item.mutbl});\n+                item.expr_id, {region: region, mutbl: item.mutbl});\n           }\n \n-          r => {\n-            cx.tcx.sess.bug(\n-                #fmt[\"borrowing resolved to %?, not a valid scope\", r]);\n+          err(e) => {\n+            let str = fixup_err_to_str(e);\n+            cx.tcx.sess.span_err(\n+                item.span,\n+                #fmt[\"could not resolve lifetime for borrow: %s\", str]);\n           }\n         }\n     }\n@@ -663,6 +666,11 @@ impl methods for infer_ctxt {\n         ret region_vid(id);\n     }\n \n+    fn next_region_var_with_scope_lb(scope_id: ast::node_id) -> ty::region {\n+        self.next_region_var({lb: some(ty::re_scope(scope_id)),\n+                              ub: none})\n+    }\n+\n     fn next_region_var(bnds: bounds<ty::region>) -> ty::region {\n         ty::re_var(self.next_region_var_id(bnds))\n     }\n@@ -1475,10 +1483,7 @@ impl assignment for infer_ctxt {\n             do self.sub_tys(a, nr_b).then {\n                 // Create a fresh region variable `r_a` with the given\n                 // borrow bounds:\n-                let r_lb = ty::re_scope(anmnt.borrow_lb);\n-                let r_ub = ty::re_scope(anmnt.borrow_ub);\n-                let r_a = self.next_region_var({lb: some(r_lb),\n-                                                ub: some(r_ub)});\n+                let r_a = self.next_region_var_with_scope_lb(anmnt.borrow_lb);\n \n                 #debug[\"anmnt=%?\", anmnt];\n                 do sub(self).contraregions(r_a, r_b).chain |_r| {\n@@ -1487,6 +1492,7 @@ impl assignment for infer_ctxt {\n                     #debug[\"borrowing expression #%?, scope=%?, m=%?\",\n                            anmnt, r_a, m];\n                     self.borrowings.push({expr_id: anmnt.expr_id,\n+                                          span: anmnt.span,\n                                           scope: r_a,\n                                           mutbl: m});\n                     uok()"}, {"sha": "d3c05ea6becdd242841615805bee475ef12dcff1", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -62,9 +62,10 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n             #fmt(\"<method at %s>\",\n                  codemap::span_to_str(expr.span, cx.sess.codemap))\n           }\n-          _ { cx.sess.bug(\n-              #fmt[\"re_scope refers to %s\",\n-                   ast_map::node_id_to_str(cx.items, node_id)]) }\n+          _ {\n+            #fmt(\"<expression at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+          }\n         }\n       }\n       none {"}, {"sha": "ba64e8887751143d072c33f0740ecff8f0288cd1", "filename": "src/test/compile-fail/borrowck-addr-of-upvar.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,14 @@\n+fn foo(x: @int) -> fn@() -> &static/int {\n+    fn@() -> &static/int {&*x} //~ ERROR illegal borrow\n+}\n+\n+fn bar(x: @int) -> fn@() -> &int {\n+    fn@() -> &int {&*x} //~ ERROR illegal borrow\n+}\n+\n+fn zed(x: @int) -> fn@() -> int {\n+    fn@() -> int {*&*x}\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "0a489630c3811a68c32b0ace97f84bb80216af0f", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -24,10 +24,25 @@ fn post_aliased_mut() {\n }\n \n fn post_aliased_scope(cond: bool) {\n-    // NDM--scope of &\n     let mut v = ~3;\n-    borrow(v);  //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n-    if cond { inc(&mut v); } //~ NOTE prior loan as mutable granted here\n+    borrow(v);\n+    if cond { inc(&mut v); }\n+}\n+\n+fn loop_overarching_alias_mut() {\n+    let mut v = ~3;\n+    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n+    loop {\n+        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    }\n+}\n+\n+fn block_overarching_alias_mut() {\n+    let mut v = ~3;\n+    let mut _x = &mut v; //~ NOTE prior loan as mutable granted here\n+    for 3.times {\n+        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n+    }\n }\n \n fn loop_aliased_mut() {\n@@ -63,7 +78,7 @@ fn loop_in_block() {\n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n     for uint::range(0u, 10u) |_i| {\n-        borrow(v); //~ ERROR loan of captured outer mutable variable in a stack closure as immutable conflicts with prior loan\n+        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n         _x = &mut v; //~ NOTE prior loan as mutable granted here\n     }\n }\n@@ -77,7 +92,7 @@ fn at_most_once_block() {\n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n     do at_most_once {\n-        borrow(v); //~ ERROR loan of captured outer mutable variable in a stack closure as immutable conflicts with prior loan\n+        borrow(v); //~ ERROR loan of mutable local variable as immutable conflicts with prior loan\n         _x = &mut v; //~ NOTE prior loan as mutable granted here\n     }\n }"}, {"sha": "70434074dbf84cc62b081120c5ca38b666347cf3", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -8,6 +8,5 @@ fn f<T>(&o: option<T>) {\n fn main() {\n     f::<int>(option::none);\n     //~^ ERROR taking mut reference to static item\n-    //~^^ ERROR illegal borrow unless pure: creating mutable alias to aliasable, immutable memory\n-    //~^^^ NOTE impure due to access to impure function\n+    //~^^ ERROR illegal borrow: creating mutable alias to aliasable, immutable memory\n }\n\\ No newline at end of file"}, {"sha": "8383a500e80070d9dce119daac255ba0b0021f60", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     // Here, an error results as the type of y is inferred to\n     // repeater<&lt/3> where lt is the block.\n     let y = { //~ ERROR reference is not valid outside of its lifetime\n-        let x = &3;\n+        let x: &blk/int = &3;\n         repeater(@x)\n     };\n     assert 3 == *(y.get()); //~ ERROR reference is not valid outside of its lifetime"}, {"sha": "46ba84c2c183f88f4b8e811f4c8785e5ef5e1a4b", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -1,5 +1,5 @@\n fn foo(a: int) {\n-    let _p: &static/int = &a; //~ ERROR mismatched types\n+    let _p: &static/int = &a; //~ ERROR illegal borrow\n }\n \n fn bar(a: int) {"}, {"sha": "fbef015ea7f5627b3d884a99fbc3122e558afcdb", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -6,7 +6,7 @@ class dog {\n     }\n \n     fn chase_cat() {\n-        let p: &static/mut uint = &mut self.cats_chased; //~ ERROR mismatched types\n+        let p: &static/mut uint = &mut self.cats_chased; //~ ERROR illegal borrow\n         *p += 1u;\n     }\n \n@@ -20,4 +20,4 @@ fn main() {\n     let d = dog();\n     d.chase_cat();\n     #debug[\"cats_chased: %u\", d.cats_chased];\n-}\n\\ No newline at end of file\n+}"}, {"sha": "e44674919bed7c4a19862642b92125a386d611bf", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -6,12 +6,12 @@ class dog {\n     }\n \n     fn chase_cat() {\n-        for uint::range(0u, 10u) |i| {\n-            let p: &static/mut uint = &mut self.food; //~ ERROR mismatched types\n+        for uint::range(0u, 10u) |_i| {\n+            let p: &static/mut uint = &mut self.food; //~ ERROR illegal borrow\n             *p = 3u;\n         }\n     }\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "300aece8c3c37c0e10201a94f8c6f8eaccdc2b3d", "filename": "src/test/compile-fail/regions-appearance-constraint.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ef13e76e95ea67103a2bc4f4becc91dc290aafc/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef13e76e95ea67103a2bc4f4becc91dc290aafc/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-appearance-constraint.rs?ref=6ef13e76e95ea67103a2bc4f4becc91dc290aafc", "patch": "@@ -1,35 +0,0 @@\n-/*\n-\n-Tests that borrowing always produces a pointer confined to the\n-innermost scope.  In this case, the variable `a` gets inferred\n-to the lifetime of the `if` statement because it is assigned\n-a borrow of `y` which takes place within the `if`.\n-\n-Note: If this constraint were lifted (as I contemplated at one point),\n-it complicates the preservation mechanics in trans, though not\n-irreperably.  I'm partially including this test so that if these\n-semantics do change we'll remember to test this scenario.\n-\n-*/\n-\n-fn testfn(cond: bool) {\n-    let mut x = @3;\n-    let mut y = @4;\n-\n-    let mut a = &*x;\n-    //~^ ERROR reference is not valid outside of its lifetime\n-\n-    let mut exp = 3;\n-    if cond {\n-        a = &*y;\n-\n-        exp = 4;\n-    }\n-\n-    x = @5;\n-    y = @6;\n-    assert *a == exp;\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "5924164ef265440fe5eb19f1f46ffd5d44e9e691", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -20,12 +20,12 @@ fn compute(x: &ast) -> uint {\n fn map_nums(x: &ast, f: fn(uint) -> uint) -> &ast {\n     alt *x {\n       num(x) {\n-        ret &num(f(x)); //~ ERROR mismatched types: expected `&ast/&` but found\n+        ret &num(f(x)); //~ ERROR illegal borrow\n       }\n       add(x, y) {\n         let m_x = map_nums(x, f);\n         let m_y = map_nums(y, f);\n-        ret &add(m_x, m_y);  //~ ERROR mismatched types: expected `&ast/&` but found\n+        ret &add(m_x, m_y);  //~ ERROR illegal borrow\n       }\n     }\n }"}, {"sha": "e63a0717503291236acb510b1aac2ff82ce7988f", "filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -4,11 +4,10 @@ fn main() {\n     // Here, the variable `p` gets inferred to a type with a lifetime\n     // of the loop body.  The regionck then determines that this type\n     // is invalid.\n-    let mut p = //~ ERROR reference is not valid\n-        &x;\n+    let mut p = &x;\n \n     loop {\n         let x = 1 + *p;\n-        p = &x;\n+        p = &x; //~ ERROR illegal borrow\n     }\n }"}, {"sha": "638f14f87949dc735b49ae05e46551e24b497e1c", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -1,17 +1,13 @@\n // The type of `y` ends up getting inferred to the type of the block.\n-// This generates a ton of error msgs at the moment.\n fn broken() -> int {\n     let mut x = 3;\n-    let mut y = ~[&mut x]; //~ ERROR reference is not valid\n+    let mut y = ~[&mut x];\n     while x < 10 {\n         let mut z = x;\n-        y += ~[&mut z];\n+        y += ~[&mut z]; //~ ERROR illegal borrow\n         x += 1;\n     }\n     vec::foldl(0, y, |v, p| v + *p )\n-    //~^ ERROR reference is not valid\n-    //~^^ ERROR reference is not valid\n-    //~^^^ ERROR reference is not valid\n }\n \n fn main() { }\n\\ No newline at end of file"}, {"sha": "2f4003f0f3a9bc8aa7cfbbee5d11d0a6842c4395", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -5,9 +5,9 @@ fn x_coord(p: &point) -> &int {\n }\n \n fn foo(p: @point) -> &int {\n-    let xc = x_coord(p);\n+    let xc = x_coord(p); //~ ERROR illegal borrow\n     assert *xc == 3;\n-    ret xc; //~ ERROR mismatched types: expected `&int` but found\n+    ret xc;\n }\n \n fn main() {}"}, {"sha": "0c62532f86a5beeefbc24ec8ac667b2bd72804f0", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -1,11 +1,18 @@\n fn borrow<T>(x: &T) -> &T {x}\n \n-fn main() {\n-    let x = @3;\n-    let y: &int; //~ ERROR reference is not valid outside of its lifetime\n-    while true {\n-        y = borrow(x);\n+fn foo(cond: fn() -> bool, box: fn() -> @int) {\n+    let mut y: &int;\n+    loop {\n+        let x = box();\n+\n+\t// Here we complain because the resulting region\n+\t// of this borrow is the fn body as a whole.\n+        y = borrow(x); //~ ERROR managed value would have to be rooted for lifetime \n+\n         assert *x == *y;\n+        if cond() { break; }\n     }\n-    assert *x == *y;\n+    assert *y != 0;\n }\n+\n+fn main() {}"}, {"sha": "ad22140b3b5593aa1edd87e8c513c1b061eb90fb", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,11 @@\n+fn ignore<T>(_t: T) {}\n+\n+fn nested() {\n+    let y = 3;\n+    ignore(fn&(z: &z/int) -> &z/int {\n+        if false { ret &y; } //~ ERROR illegal borrow\n+        ret z;\n+    });\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "ae3102b8ec2613fd20c0c577a488b589b4b9856e", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -12,7 +12,6 @@ fn nested(x: &x/int) {\n \n     ignore(fn&(z: &z/int) -> &z/int {\n         if false { ret x; }  //~ ERROR references with lifetime\n-        if false { ret &y; } //~ ERROR references with lifetime\n         if false { ret ay; } //~ ERROR references with lifetime\n         ret z;\n     });"}, {"sha": "9c1bf26b400f255a34253cc48999db281b0b20cf", "filename": "src/test/compile-fail/regions-ret.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -1,7 +1,5 @@\n-// error-pattern: mismatched types\n-\n-fn f(x : &a/int) -> &a/int {\n-    ret &3;\n+fn f(_x : &a/int) -> &a/int {\n+    ret &3; //~ ERROR illegal borrow\n }\n \n fn main() {"}, {"sha": "8526c6722f4b61b8ffebc9f24ed4a662e3875eb2", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -33,10 +33,15 @@ fn nested(x: &x/int) {  // (1)\n         let z = 3i;\n         let d: &x/int = foo(x, x, |_x, _y, z| z );\n         let e: &x/int = foo(x, &z, |_x, _y, z| z );\n-        let f: &x/int = foo(&z, &z, |_x, _y, z| z ); //~ ERROR mismatched types: expected `&x/int` but found\n+\n+        // This would result in an error, but it is not reported by typeck\n+        // anymore but rather borrowck. Therefore, it doesn't end up\n+        // getting printed out since compilation fails after typeck.\n+        //\n+        // let f: &x/int = foo(&z, &z, |_x, _y, z| z ); // ERROR mismatched types: expected `&x/int` but found\n \n         foo(x, &z, |x, _y, _z| x ); //~ ERROR mismatched types: expected `&z/int` but found `&x/int`\n-        foo(x, &z, |_x, y, _z| y ); //~ ERROR mismatched types: expected `&z/int` but found `&<block at\n+        foo(x, &z, |_x, y, _z| y ); //~ ERROR mismatched types: expected `&z/int` but found `&<expression at\n     }\n }\n "}, {"sha": "a26ee45d0298a1c6f13def17bbde4c9523192525", "filename": "src/test/run-pass/borrowck-root-while-cond-2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond-2.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let rec = @{mut f: @{g: ~[1, 2, 3]}};\n+    while rec.f.g.len() == 23 {}\n+}"}, {"sha": "07016d1bf0d43ac4a50c6ffbd0957de969d5beb3", "filename": "src/test/run-pass/borrowck-root-while-cond.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-root-while-cond.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,6 @@\n+fn borrow<T>(x: &T) -> &T {x}\n+\n+fn main() {\n+    let rec = @{mut f: @22};\n+    while *borrow(rec.f) == 23 {}\n+}"}, {"sha": "e9a3d0b3ec333a067478fd2931d6e399464cb84d", "filename": "src/test/run-pass/regions-addr-of-interior-of-unique-box.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-addr-of-interior-of-unique-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-addr-of-interior-of-unique-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-addr-of-interior-of-unique-box.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,13 @@\n+type point = { x: int, y: int };\n+type character = { pos: ~point };\n+\n+fn get_x(x: &character) -> &int {\n+    // interesting case because the scope of this\n+    // borrow of the unique pointer is in fact\n+    // larger than the fn itself\n+    ret &x.pos.x;\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "2a8258b39361e364d0d35d88f0643faedaee9a36", "filename": "src/test/run-pass/regions-appearance-constraint.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-appearance-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-appearance-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-appearance-constraint.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,22 @@\n+/* Tests conditional rooting of the box y */\n+\n+fn testfn(cond: bool) {\n+    let mut x = @3;\n+    let mut y = @4;\n+\n+    let mut a = &*x;\n+\n+    let mut exp = 3;\n+    if cond {\n+        a = &*y;\n+\n+        exp = 4;\n+    }\n+\n+    x = @5;\n+    y = @6;\n+    assert *a == exp;\n+}\n+\n+fn main() {\n+}"}, {"sha": "124c271032f58da9b0f57266e17cc21fd82b4810", "filename": "src/test/run-pass/regions-infer-borrow-scope-addr-of.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d32d03b892d67f2cc0574966b50b3eab4b8bd94/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-borrow-scope-addr-of.rs?ref=5d32d03b892d67f2cc0574966b50b3eab4b8bd94", "patch": "@@ -0,0 +1,19 @@\n+fn main() {\n+    let mut x = 4;\n+\n+    for uint::range(0, 3) |i| {\n+        // ensure that the borrow in this alt\n+\t// does not inferfere with the swap\n+\t// below.  note that it would it you\n+\t// naively borrowed &x for the lifetime\n+\t// of the variable x, as we once did\n+        alt i {\n+          i {\n+            let y = &x;\n+            assert i < *y;\n+          }\n+        }\n+        let mut y = 4;\n+        y <-> x;\n+    }\n+}"}]}