{"sha": "540934980a9d7c62dd30675946ba1dbb96aee163", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MDkzNDk4MGE5ZDdjNjJkZDMwNjc1OTQ2YmExZGJiOTZhZWUxNjM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-26T17:13:43Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-26T17:42:23Z"}, "message": "Demode some of core::io", "tree": {"sha": "2e91c0a8aad645ff02deab10b1966ec58d5aa36f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e91c0a8aad645ff02deab10b1966ec58d5aa36f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/540934980a9d7c62dd30675946ba1dbb96aee163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/540934980a9d7c62dd30675946ba1dbb96aee163", "html_url": "https://github.com/rust-lang/rust/commit/540934980a9d7c62dd30675946ba1dbb96aee163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/540934980a9d7c62dd30675946ba1dbb96aee163/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d38b97a170eaea47933c30937cee5f525573116d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d38b97a170eaea47933c30937cee5f525573116d", "html_url": "https://github.com/rust-lang/rust/commit/d38b97a170eaea47933c30937cee5f525573116d"}], "stats": {"total": 86, "additions": 44, "deletions": 42}, "files": [{"sha": "021aa624e061ac0514ccca4cb68987d2a1aaabb4", "filename": "src/libcore/io.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/540934980a9d7c62dd30675946ba1dbb96aee163/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540934980a9d7c62dd30675946ba1dbb96aee163/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=540934980a9d7c62dd30675946ba1dbb96aee163", "patch": "@@ -74,69 +74,71 @@ impl<T: Reader> T : ReaderUtil {\n impl Reader {\n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes(buf: ~[u8], &chars: ~[char]) -> (uint, uint) {\n-            let mut i = 0u;\n-            while i < vec::len(buf) {\n+        fn chars_from_bytes(buf: &~[u8], chars: &mut ~[char])\n+            -> (uint, uint) {\n+            let mut i = 0;\n+            let buf_len = buf.len();\n+            while i < buf_len {\n                 let b0 = buf[i];\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n-                i += 1u;\n-                assert (w > 0u);\n-                if w == 1u {\n-                    vec::push(chars,  b0 as char );\n+                i += 1;\n+                assert (w > 0);\n+                if w == 1 {\n+                    vec::push(*chars, b0 as char);\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n-                if end > vec::len(buf) {\n-                    return (i - 1u, end - vec::len(buf));\n+                if end > buf_len {\n+                    return (i - 1, end - buf_len);\n                 }\n-                let mut val = 0u;\n+                let mut val = 0;\n                 while i < end {\n                     let next = buf[i] as int;\n-                    i += 1u;\n+                    i += 1;\n                     assert (next > -1);\n                     assert (next & 192 == 128);\n-                    val <<= 6u;\n+                    val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n                 // See str::char_at\n-                val += ((b0 << ((w + 1u) as u8)) as uint)\n-                    << (w - 1u) * 6u - w - 1u;\n-                vec::push(chars,  val as char );\n+                val += ((b0 << ((w + 1) as u8)) as uint)\n+                    << (w - 1) * 6 - w - 1u;\n+                vec::push(*chars, val as char);\n             }\n-            return (i, 0u);\n+            return (i, 0);\n         }\n         let mut buf: ~[u8] = ~[];\n         let mut chars: ~[char] = ~[];\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n-        while nbread > 0u {\n+        while nbread > 0 {\n             let data = self.read_bytes(nbread);\n-            if vec::len(data) == 0u {\n+            if data.is_empty() {\n                 // eof - FIXME (#2004): should we do something if\n                 // we're split in a unicode char?\n                 break;\n             }\n             vec::push_all(buf, data);\n-            let (offset, nbreq) = chars_from_bytes(buf, chars);\n-            let ncreq = n - vec::len(chars);\n+            let (offset, nbreq) = chars_from_bytes(&buf, &mut chars);\n+            let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n             // to complete a character, or we make sure we don't\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n-            if nbread > 0u {\n-                buf = vec::slice(buf, offset, vec::len(buf));\n+            if nbread > 0 {\n+                buf = vec::slice(buf, offset, buf.len());\n             }\n         }\n         move chars\n     }\n \n     fn read_char() -> char {\n-        let c = self.read_chars(1u);\n-        if vec::len(c) == 0u {\n+        let c = self.read_chars(1);\n+        if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert(vec::len(c) == 1u);\n+        assert(vec::len(c) == 1);\n         return c[0];\n     }\n \n@@ -195,7 +197,7 @@ impl Reader {\n         }\n     }\n \n-    fn each_line(it: fn(~str) -> bool) {\n+    fn each_line(it: fn(s: &str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n@@ -440,7 +442,7 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n }\n \n \n-fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n+fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     -> Result<Writer, ~str> {\n \n     #[cfg(windows)]\n@@ -644,7 +646,7 @@ impl<T: Writer> T : WriterUtil {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn file_writer(path: &Path, flags: ~[FileFlag]) -> Result<Writer, ~str> {\n+fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n     mk_file_writer(path, flags).chain(|w| result::Ok(w))\n }\n \n@@ -786,7 +788,7 @@ mod fsync {\n \n \n     // Artifacts that need to fsync on destruction\n-    struct Res<t> {\n+    struct Res<t: Copy> {\n         arg: Arg<t>,\n         drop {\n           match self.arg.opt_level {\n@@ -799,7 +801,7 @@ mod fsync {\n         }\n     }\n \n-    fn Res<t>(-arg: Arg<t>) -> Res<t>{\n+    fn Res<t: Copy>(+arg: Arg<t>) -> Res<t>{\n         Res {\n             arg: move arg\n         }\n@@ -808,28 +810,28 @@ mod fsync {\n     type Arg<t> = {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: fn@(t, Level) -> int\n+        fsync_fn: fn@(+f: t, Level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    fn FILE_res_sync(&&file: FILERes, opt_level: Option<Level>,\n-                  blk: fn(&&v: Res<*libc::FILE>)) {\n-        blk(Res({\n+    fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n+                  blk: fn(+v: Res<*libc::FILE>)) {\n+        blk(move Res({\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: fn@(&&file: *libc::FILE, l: Level) -> int {\n+            fsync_fn: fn@(+file: *libc::FILE, l: Level) -> int {\n                 return os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(&&fd: FdRes, opt_level: Option<Level>,\n-                   blk: fn(&&v: Res<fd_t>)) {\n-        blk(Res({\n+    fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n+                   blk: fn(+v: Res<fd_t>)) {\n+        blk(move Res({\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: fn@(&&fd: fd_t, l: Level) -> int {\n+            fsync_fn: fn@(+fd: fd_t, l: Level) -> int {\n                 return os::fsync_fd(fd, l) as int;\n             }\n         }));\n@@ -839,11 +841,11 @@ mod fsync {\n     trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(&&o: FSyncable, opt_level: Option<Level>,\n-                blk: fn(&&v: Res<FSyncable>)) {\n+    fn obj_sync(+o: FSyncable, opt_level: Option<Level>,\n+                blk: fn(+v: Res<FSyncable>)) {\n         blk(Res({\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(&&o: FSyncable, l: Level) -> int {\n+            fsync_fn: fn@(+o: FSyncable, l: Level) -> int {\n                 return o.fsync(l);\n             }\n         }));"}]}