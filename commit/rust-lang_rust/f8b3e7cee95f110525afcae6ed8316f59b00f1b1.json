{"sha": "f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YjNlN2NlZTk1ZjExMDUyNWFmY2FlNmVkODMxNmY1OWIwMGYxYjE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-21T17:12:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-21T17:12:57Z"}, "message": "Rollup merge of #46031 - Keruspe:cargofmt, r=Mark-Simulacrum\n\nrustbuild: distribute cargo-fmt alongside rustfmt\n\nNot sure whether we want that nor if it's the right way to do so, but it feels quite weird to have rustfmt without cargo-fmt. Or are there other plans wrt that?\n\nWhat do you think @nrc ?", "tree": {"sha": "0291001c9422533221102c1778fd22814567cfe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0291001c9422533221102c1778fd22814567cfe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "html_url": "https://github.com/rust-lang/rust/commit/f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8b3e7cee95f110525afcae6ed8316f59b00f1b1/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c3cc4d3dc88bca1ae41424afc499efe40a894b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c3cc4d3dc88bca1ae41424afc499efe40a894b", "html_url": "https://github.com/rust-lang/rust/commit/c0c3cc4d3dc88bca1ae41424afc499efe40a894b"}, {"sha": "b29a61e51b14276edf0d2110901129ab4e92fc5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b29a61e51b14276edf0d2110901129ab4e92fc5e", "html_url": "https://github.com/rust-lang/rust/commit/b29a61e51b14276edf0d2110901129ab4e92fc5e"}], "stats": {"total": 192, "additions": 57, "deletions": 135}, "files": [{"sha": "95be9a396c17c3bd3aeef6fb98518f9aa236784d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f8b3e7cee95f110525afcae6ed8316f59b00f1b1/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b3e7cee95f110525afcae6ed8316f59b00f1b1/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "patch": "@@ -1168,7 +1168,12 @@ impl Step for Rustfmt {\n             compiler: builder.compiler(stage, build.build),\n             target\n         }).expect(\"Rustfmt to build: toolstate is testing\");\n+        let cargofmt = builder.ensure(tool::Cargofmt {\n+            compiler: builder.compiler(stage, build.build),\n+            target\n+        }).expect(\"Cargofmt to build: toolstate is testing\");\n         install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n         install(&src.join(\"README.md\"), &doc, 0o644);\n         install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);"}, {"sha": "9b16ca0980acb22612b0fa480e12ff2cd44cdcf8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 52, "deletions": 135, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f8b3e7cee95f110525afcae6ed8316f59b00f1b1/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b3e7cee95f110525afcae6ed8316f59b00f1b1/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=f8b3e7cee95f110525afcae6ed8316f59b00f1b1", "patch": "@@ -403,71 +403,66 @@ impl Step for Cargo {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Clippy {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n+macro_rules! tool_extended {\n+    (($sel:ident, $builder:ident),\n+       $($name:ident,\n+       $toolstate:ident,\n+       $path:expr,\n+       $tool_name:expr,\n+       $extra_deps:block;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n+        }\n \n-impl Step for Clippy {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n+        impl Step for $name {\n+            type Output = Option<PathBuf>;\n+            const DEFAULT: bool = true;\n+            const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/clippy\").default_condition(builder.build.config.extended)\n-    }\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                let builder = run.builder;\n+                run.path($path).default_condition(builder.build.config.extended)\n+            }\n \n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n+            fn make_run(run: RunConfig) {\n+                run.builder.ensure($name {\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    target: run.target,\n+                });\n+            }\n+\n+            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+                $extra_deps\n+                let toolstate = $builder.build.config.toolstate.$toolstate;\n+                $builder.ensure(ToolBuild {\n+                    compiler: $sel.compiler,\n+                    target: $sel.target,\n+                    tool: $tool_name,\n+                    mode: Mode::Librustc,\n+                    path: $path,\n+                    expectation: toolstate.passes(ToolState::Compiling),\n+                })\n+            }\n+        }\n+        )+\n     }\n+}\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+tool_extended!((self, builder),\n+    Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"clippy-driver\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/clippy\",\n-            expectation: builder.build.config.toolstate.clippy.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rls {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rls\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    };\n+    Miri, miri, \"src/tools/miri\", \"miri\", {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -477,87 +472,9 @@ impl Step for Rls {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rls\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rls\",\n-            expectation: builder.build.config.toolstate.rls.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustfmt {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rustfmt\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rustfmt\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rustfmt\",\n-            expectation: builder.build.config.toolstate.rustfmt.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Miri {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"miri\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/miri\",\n-            expectation: builder.build.config.toolstate.miri.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n+    };\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+);\n \n impl<'a> Builder<'a> {\n     /// Get a `Command` which is ready to run `tool` in `stage` built for"}]}