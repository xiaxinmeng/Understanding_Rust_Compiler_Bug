{"sha": "8f0e73ef55f6cf837555a0c144c00844eefa97b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMGU3M2VmNTVmNmNmODM3NTU1YTBjMTQ0YzAwODQ0ZWVmYTk3Yjk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-08T23:23:52Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:05:13Z"}, "message": "Address review comments", "tree": {"sha": "1817854c796812cfd3e34d00f711c31e885d760f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1817854c796812cfd3e34d00f711c31e885d760f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f0e73ef55f6cf837555a0c144c00844eefa97b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f0e73ef55f6cf837555a0c144c00844eefa97b9", "html_url": "https://github.com/rust-lang/rust/commit/8f0e73ef55f6cf837555a0c144c00844eefa97b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f0e73ef55f6cf837555a0c144c00844eefa97b9/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74", "html_url": "https://github.com/rust-lang/rust/commit/9bcfdb7b9c5c37a38b1b5c71a5efa14f037d0c74"}], "stats": {"total": 206, "additions": 99, "deletions": 107}, "files": [{"sha": "e1d811d450d5a559b15cffcb9c0935f5898cb160", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -100,21 +100,21 @@ pub enum ProjectionMode {\n }\n \n impl ProjectionMode {\n-    pub fn topmost(&self) -> bool {\n+    pub fn is_topmost(&self) -> bool {\n         match *self {\n             ProjectionMode::Topmost => true,\n             _ => false,\n         }\n     }\n \n-    pub fn any_final(&self) -> bool {\n+    pub fn is_any_final(&self) -> bool {\n         match *self {\n             ProjectionMode::AnyFinal => true,\n             _ => false,\n         }\n     }\n \n-    pub fn any(&self) -> bool {\n+    pub fn is_any(&self) -> bool {\n         match *self {\n             ProjectionMode::Any => true,\n             _ => false,\n@@ -665,7 +665,7 @@ fn project_type<'cx,'tcx>(\n         // In Any (i.e. trans) mode, all projections succeed;\n         // otherwise, we need to be sensitive to `default` and\n         // specialization.\n-        if !selcx.projection_mode().any() {\n+        if !selcx.projection_mode().is_any() {\n             if let ProjectionTyCandidate::Impl(ref impl_data) = candidate {\n                 if let Some(node_item) = assoc_ty_def(selcx,\n                                                       impl_data.impl_def_id,\n@@ -1116,7 +1116,7 @@ fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>, impl_def_id: Def\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n \n-    if selcx.projection_mode().topmost() {\n+    if selcx.projection_mode().is_topmost() {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n             if let ty::TypeTraitItem(assoc_ty) = item {"}, {"sha": "b557db9a8b2ac48cdebb2ea5b2c1074edecb995d", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "modified", "additions": 56, "deletions": 84, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -25,7 +25,7 @@ use middle::def_id::DefId;\n use middle::infer::{self, InferCtxt, TypeOrigin};\n use middle::region;\n use middle::subst::{Subst, Substs};\n-use middle::traits::{self, ProjectionMode};\n+use middle::traits::ProjectionMode;\n use middle::ty;\n use syntax::codemap::DUMMY_SP;\n \n@@ -41,45 +41,43 @@ pub struct Overlap<'a, 'tcx: 'a> {\n /// Given a subst for the requested impl, translate it to a subst\n /// appropriate for the actual item definition (whether it be in that impl,\n /// a parent impl, or the trait).\n-//\n-// When we have selected one impl, but are actually using item definitions from\n-// a parent impl providing a default, we need a way to translate between the\n-// type parameters of the two impls. Here the `source_impl` is the one we've\n-// selected, and `source_substs` is a substitution of its generics (and\n-// possibly some relevant `FnSpace` variables as well). And `target_node` is\n-// the impl/trait we're actually going to get the definition from. The resulting\n-// substitution will map from `target_node`'s generics to `source_impl`'s\n-// generics as instantiated by `source_subst`.\n-//\n-// For example, consider the following scenario:\n-//\n-// ```rust\n-// trait Foo { ... }\n-// impl<T, U> Foo for (T, U) { ... }  // target impl\n-// impl<V> Foo for (V, V) { ... }     // source impl\n-// ```\n-//\n-// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n-// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n-//\n-// Where clauses add some trickiness here, because they can be used to \"define\"\n-// an argument indirectly:\n-//\n-// ```rust\n-// impl<'a, I, T: 'a> Iterator for Cloned<I>\n-//    where I: Iterator<Item=&'a T>, T: Clone\n-// ```\n-//\n-// In a case like this, the substitution for `T` is determined indirectly,\n-// through associated type projection. We deal with such cases by using\n-// *fulfillment* to relate the two impls, requiring that all projections are\n-// resolved.\n+/// When we have selected one impl, but are actually using item definitions from\n+/// a parent impl providing a default, we need a way to translate between the\n+/// type parameters of the two impls. Here the `source_impl` is the one we've\n+/// selected, and `source_substs` is a substitution of its generics (and\n+/// possibly some relevant `FnSpace` variables as well). And `target_node` is\n+/// the impl/trait we're actually going to get the definition from. The resulting\n+/// substitution will map from `target_node`'s generics to `source_impl`'s\n+/// generics as instantiated by `source_subst`.\n+///\n+/// For example, consider the following scenario:\n+///\n+/// ```rust\n+/// trait Foo { ... }\n+/// impl<T, U> Foo for (T, U) { ... }  // target impl\n+/// impl<V> Foo for (V, V) { ... }     // source impl\n+/// ```\n+///\n+/// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n+/// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n+///\n+/// Where clauses add some trickiness here, because they can be used to \"define\"\n+/// an argument indirectly:\n+///\n+/// ```rust\n+/// impl<'a, I, T: 'a> Iterator for Cloned<I>\n+///    where I: Iterator<Item=&'a T>, T: Clone\n+/// ```\n+///\n+/// In a case like this, the substitution for `T` is determined indirectly,\n+/// through associated type projection. We deal with such cases by using\n+/// *fulfillment* to relate the two impls, requiring that all projections are\n+/// resolved.\n pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                   source_impl: DefId,\n                                   source_substs: Substs<'tcx>,\n                                   target_node: specialization_graph::Node)\n-                                  -> Substs<'tcx>\n-{\n+                                  -> Substs<'tcx> {\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -116,29 +114,16 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     target_substs.with_method_from_subst(&source_substs)\n }\n \n-\n-fn skolemizing_subst_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        impl_def_id: DefId)\n-                                        -> Substs<'tcx>\n-{\n-    let impl_generics = infcx.tcx.lookup_item_type(impl_def_id).generics;\n-\n-    let types = impl_generics.types.map(|def| infcx.tcx.mk_param_from_def(def));\n-\n-    // TODO: figure out what we actually want here\n-    let regions = impl_generics.regions.map(|_| ty::Region::ReStatic);\n-    // |d| infcx.next_region_var(infer::RegionVariableOrigin::EarlyBoundRegion(span, d.name)));\n-\n-    Substs::new(types, regions)\n-}\n-\n /// Is impl1 a specialization of impl2?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n-    if !tcx.sess.features.borrow().specialization {\n+    // The feature gate should prevent introducing new specializations, but not\n+    // taking advantage of upstream ones.\n+    if !tcx.sess.features.borrow().specialization &&\n+        (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n         return false;\n     }\n \n@@ -156,33 +141,24 @@ pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) ->\n \n     // Currently we do not allow e.g. a negative impl to specialize a positive one\n     if tcx.trait_impl_polarity(impl1_def_id) != tcx.trait_impl_polarity(impl2_def_id) {\n-        return false\n+        return false;\n     }\n \n     let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Topmost);\n \n-    // Skiolemize impl1: we want to prove that \"for all types matched by impl1,\n-    // those types are also matched by impl2\".\n-    let impl1_substs = skolemizing_subst_for_impl(&infcx, impl1_def_id);\n-    let (impl1_trait_ref, impl1_obligations) = {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n-    };\n+    // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n+    let scheme = tcx.lookup_item_type(impl1_def_id);\n+    let predicates = tcx.lookup_predicates(impl1_def_id);\n+    let penv = tcx.construct_parameter_environment(DUMMY_SP,\n+                                                   &scheme.generics,\n+                                                   &predicates,\n+                                                   region::DUMMY_CODE_EXTENT);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n+                             .unwrap()\n+                             .subst(tcx, &penv.free_substs);\n \n-    // Add impl1's obligations as assumptions to the environment.\n-    let impl1_predicates: Vec<_> = impl1_obligations.iter()\n-                                                    .cloned()\n-                                                    .map(|oblig| oblig.predicate)\n-                                                    .collect();\n-    infcx.parameter_environment = ty::ParameterEnvironment {\n-        tcx: tcx,\n-        free_substs: impl1_substs,\n-        implicit_region_bound: ty::ReEmpty, // TODO: is this OK?\n-        caller_bounds: impl1_predicates,\n-        selection_cache: traits::SelectionCache::new(),\n-        evaluation_cache: traits::EvaluationCache::new(),\n-        free_id_outlive: region::DUMMY_CODE_EXTENT, // TODO: is this OK?\n-    };\n+    // Install the parameter environment, which means we take the predicates of impl1 as assumptions:\n+    infcx.parameter_environment = penv;\n \n     // Attempt to prove that impl2 applies, given all of the above.\n     fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n@@ -196,9 +172,8 @@ pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) ->\n fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                  source_trait_ref: ty::TraitRef<'tcx>,\n                                  target_impl: DefId)\n-                                 -> Result<Substs<'tcx>, ()>\n-{\n-    infcx.probe(|_| {\n+                                 -> Result<Substs<'tcx>, ()> {\n+    infcx.commit_if_ok(|_| {\n         let selcx = &mut SelectionContext::new(&infcx);\n         let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n         let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n@@ -227,23 +202,20 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n             // no dice!\n-            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} \\\n-                    given {:?}\",\n+            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                    {:?}\",\n                    source_trait_ref,\n                    target_trait_ref,\n                    errors,\n                    infcx.parameter_environment.caller_bounds);\n             Err(())\n         } else {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses \\\n-                    elided)\",\n+            debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n                    source_trait_ref,\n                    target_trait_ref);\n \n             // Now resolve the *substitution* we built for the target earlier, replacing\n             // the inference variables inside with whatever we got from fulfillment.\n-\n-            // TODO: should this use `fully_resolve` instead?\n             Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n         }\n     })"}, {"sha": "77588a3e0708b129a5d46cfd671b8e7a6828819f", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -65,14 +65,15 @@ impl Graph {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let trait_def_id = trait_ref.def_id;\n \n-        debug!(\"inserting TraitRef {:?} into specialization graph\", trait_ref);\n+        debug!(\"insert({:?}): inserting TraitRef {:?} into specialization graph\",\n+               impl_def_id, trait_ref);\n \n         // if the reference itself contains an earlier error (e.g., due to a\n         // resolution failure), then we just insert the impl at the top level of\n         // the graph and claim that there's no overlap (in order to supress\n         // bogus errors).\n         if trait_ref.references_error() {\n-            debug!(\"Inserting dummy node for erroneous TraitRef {:?}, \\\n+            debug!(\"insert: inserting dummy node for erroneous TraitRef {:?}, \\\n                     impl_def_id={:?}, trait_def_id={:?}\",\n                    trait_ref, impl_def_id, trait_def_id);\n \n@@ -101,15 +102,15 @@ impl Graph {\n                     let ge = specializes(tcx, possible_sibling, impl_def_id);\n \n                     if le && !ge {\n-                        let parent_trait_ref = tcx.impl_trait_ref(possible_sibling).unwrap();\n-                        debug!(\"descending as child of TraitRef {:?}\", parent_trait_ref);\n+                        debug!(\"descending as child of TraitRef {:?}\",\n+                               tcx.impl_trait_ref(possible_sibling).unwrap());\n \n                         // the impl specializes possible_sibling\n                         parent = possible_sibling;\n                         continue 'descend;\n                     } else if ge && !le {\n-                        let child_trait_ref = tcx.impl_trait_ref(possible_sibling).unwrap();\n-                        debug!(\"placing as parent of TraitRef {:?}\", child_trait_ref);\n+                        debug!(\"placing as parent of TraitRef {:?}\",\n+                               tcx.impl_trait_ref(possible_sibling).unwrap());\n \n                         // possible_sibling specializes the impl\n                         *slot = impl_def_id;\n@@ -158,10 +159,10 @@ impl Graph {\n     }\n }\n \n-#[derive(Debug, Copy, Clone)]\n /// A node in the specialization graph is either an impl or a trait\n /// definition; either can serve as a source of item definitions.\n /// There is always exactly one trait definition node: the root.\n+#[derive(Debug, Copy, Clone)]\n pub enum Node {\n     Impl(DefId),\n     Trait(DefId),\n@@ -316,7 +317,7 @@ impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n-    /// Seach the items from the given ancestors, returning each type definition\n+    /// Search the items from the given ancestors, returning each type definition\n     /// with the given name.\n     pub fn type_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n@@ -337,7 +338,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n         TypeDefs { iter: Box::new(iter) }\n     }\n \n-    /// Seach the items from the given ancestors, returning each fn definition\n+    /// Search the items from the given ancestors, returning each fn definition\n     /// with the given name.\n     pub fn fn_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n@@ -358,7 +359,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n         FnDefs { iter: Box::new(iter) }\n     }\n \n-    /// Seach the items from the given ancestors, returning each const\n+    /// Search the items from the given ancestors, returning each const\n     /// definition with the given name.\n     pub fn const_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {"}, {"sha": "534f10103b5357ecc6684b752f9103846999cc72", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -870,8 +870,8 @@ fn report_forbidden_specialization(tcx: &ty::ctxt,\n {\n     let mut err = struct_span_err!(\n         tcx.sess, impl_item.span, E0520,\n-        \"item `{}` is provided by an implementation that specializes \\\n-         another, but the item in the parent implementations is not \\\n+        \"item `{}` is provided by an `impl` that specializes \\\n+         another, but the item in the parent `impl` is not \\\n          marked `default` and so it cannot be specialized.\",\n         impl_item.name);\n "}, {"sha": "377838f2a080cbee57953cd7ae47dc5e3745d59a", "filename": "src/test/compile-fail/specialization-default-projection.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-default-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-default-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-default-projection.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -25,10 +25,22 @@ impl Foo for u8 {\n }\n \n fn generic<T>() -> <T as Foo>::Assoc {\n-    () //~ ERROR\n+    // `T` could be some downstream crate type that specializes (or,\n+    // for that matter, `u8`).\n+\n+    () //~ ERROR E0308\n+}\n+\n+fn monomorphic() -> () {\n+    // Even though we know that `()` is not specialized in a\n+    // downstream crate, typeck refuses to project here.\n+\n+    generic::<()>() //~ ERROR E0308\n }\n \n fn main() {\n+    // No error here, we CAN project from `u8`, as there is no `default`\n+    // in that impl.\n     let s: String = generic::<u8>();\n-    println!(\"{}\", s); // bad news\n+    println!(\"{}\", s); // bad news if this all compiles\n }"}, {"sha": "3c2e3d5a36c377f80f8d1dd0c8e72d1e0490d6d1", "filename": "src/test/compile-fail/specialization-default-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-default-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-default-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-default-types.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -22,7 +22,7 @@ trait Example {\n impl<T> Example for T {\n     default type Output = Box<T>;\n     default fn generate(self) -> Self::Output {\n-        Box::new(self) //~ ERROR\n+        Box::new(self) //~ ERROR E0308\n     }\n }\n \n@@ -32,7 +32,7 @@ impl Example for bool {\n }\n \n fn trouble<T>(t: T) -> Box<T> {\n-    Example::generate(t) //~ ERROR\n+    Example::generate(t) //~ ERROR E0308\n }\n \n fn weaponize() -> bool {"}, {"sha": "e7c194ce84df95620c2cbe4750eb3489695390bf", "filename": "src/test/compile-fail/specialization-feature-gate-default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-default.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that specialization must be ungated to use the `default` keyword\n+\n trait Foo {\n     fn foo(&self);\n }\n \n impl<T> Foo for T {\n-    default fn foo(&self) {} //~ ERROR\n+    default fn foo(&self) {} //~ ERROR specialization is unstable\n }\n \n fn main() {}"}, {"sha": "d11ab56ff7e871d5f22839aed780f7e92117f472", "filename": "src/test/compile-fail/specialization-feature-gate-overlap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-feature-gate-overlap.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Check that writing an overlapping impl is not allow unless specialization is ungated.\n+\n trait Foo {\n     fn foo(&self);\n }\n@@ -16,7 +18,7 @@ impl<T> Foo for T {\n     fn foo(&self) {}\n }\n \n-impl Foo for u8 { //~ ERROR\n+impl Foo for u8 { //~ ERROR E0119\n     fn foo(&self) {}\n }\n "}, {"sha": "961561685437a97eddd96739974f14ae71b327c1", "filename": "src/test/compile-fail/specialization-no-default.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f0e73ef55f6cf837555a0c144c00844eefa97b9/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs?ref=8f0e73ef55f6cf837555a0c144c00844eefa97b9", "patch": "@@ -10,6 +10,9 @@\n \n #![feature(specialization)]\n \n+// Check a number of scenarios in which one impl tries to override another,\n+// without correctly using `default`.\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Test 1: one layer of specialization, multiple methods, missing `default`\n ////////////////////////////////////////////////////////////////////////////////"}]}