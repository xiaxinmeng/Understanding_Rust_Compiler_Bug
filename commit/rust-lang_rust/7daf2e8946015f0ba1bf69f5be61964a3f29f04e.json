{"sha": "7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYWYyZTg5NDYwMTVmMGJhMWJmNjlmNWJlNjE5NjRhM2YyOWYwNGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-02T16:24:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-02T16:24:41Z"}, "message": "Rollup merge of #64980 - ecstatic-morse:better-rustc-peek, r=oli-obk\n\nEnable support for `IndirectlyMutableLocals` in `rustc_peek`\n\nThis PR allows `rustc_peek` tests to be written for the `IndirectlyMutableLocals` analysis implemented in #64470. See any of the tests in [`test/ui/mir-dataflow`](https://github.com/rust-lang/rust/blob/master/src/test/ui/mir-dataflow/inits-1.rs) for an example.\n\nIncluded in this PR is a major rewrite of the `rustc_peek` module. This was motivated by the differences between the `IndirectlyMutableLocals` analysis and the initialized places ones.\n\nTo properly test `IndirectlyMutableLocals`, we must pass locals by-value to `rustc_peek`, since any local that is not `Freeze` will be marked as indirectly mutable as soon as a reference to it is taken. Unfortunately, `UnsafeCell` is not `Copy`, so we can only do one `rustc_peek` on each value with interior mutability inside a test. I'm not sure how to deal with this restriction; perhaps I need to special case borrows preceding a call to `rustc_peek` in the analysis itself?\n\n`rustc_peek` also assumed that the analysis was done on move paths and that its transfer function only needed to be applied at assignment statements. This PR removes both of those restrictions by adding a trait, `RustcPeekAt`, that controls how the peeked at `Place` maps to the current dataflow state and using a dataflow cursor to retrieve the state itself.\n\nFinally, this PR adds a test which demonstrates some unsoundness in the `IndirectlyMutableLocals` analysis by converting a reference to a `Freeze` field to a reference to a `!Freeze` field by offsetting a pointer (or in this case transmuting a pointer to a ZST field with the same address as a `!Freeze` field). This does not represent a hole in the language proper, since this analysis is only used to validate `const` bodies, in which the unsound code will only compile with `-Zunleash-the-miri-inside-of-you`. Nevertheless, this should get fixed.\n\nr? @oli-obk", "tree": {"sha": "b29eef3d79d578d337065fa4f65eb84276cf7628", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29eef3d79d578d337065fa4f65eb84276cf7628"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdlM9JCRBK7hj4Ov3rIwAAdHIIAEHFK/9EWqFR2MWZAuXPD1a1\na2sdWXxKn+wbb5surr0TDB/48b/cRs/SHItTTDPs/jZS05hNuIdcjW4VyhmMyJaO\nTEPRtIMlJsVZncVQnu0ylCRf8CPNpm7g/jUD980EWqLIKj/OOaMo145DJNnLD7Ca\naTOiUw0Nadv6BdzfNBfyO/poXpm9ysfThJvvkv98dHLDvG4cR0S02s2o3alq5JsR\nKMqNE9+qwR4Heiub26rzGSBrP5QKO5Bl4Kjdg1KA/Bd4SUm2Q0FBZ/cDpZUn94QZ\nILl1OicUPS3dyS55hcid+xPFMucvnJasuJio2vU1IiIqp8FsZ8P0fNeyv61sXvA=\n=C1P3\n-----END PGP SIGNATURE-----\n", "payload": "tree b29eef3d79d578d337065fa4f65eb84276cf7628\nparent 10b0fe9c5c9bc2d58b2ac2451114bf2a670bd0dc\nparent 33aa5e855ed1deec5d086c7919b2a9572128b7ee\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570033481 +0200\ncommitter GitHub <noreply@github.com> 1570033481 +0200\n\nRollup merge of #64980 - ecstatic-morse:better-rustc-peek, r=oli-obk\n\nEnable support for `IndirectlyMutableLocals` in `rustc_peek`\n\nThis PR allows `rustc_peek` tests to be written for the `IndirectlyMutableLocals` analysis implemented in #64470. See any of the tests in [`test/ui/mir-dataflow`](https://github.com/rust-lang/rust/blob/master/src/test/ui/mir-dataflow/inits-1.rs) for an example.\n\nIncluded in this PR is a major rewrite of the `rustc_peek` module. This was motivated by the differences between the `IndirectlyMutableLocals` analysis and the initialized places ones.\n\nTo properly test `IndirectlyMutableLocals`, we must pass locals by-value to `rustc_peek`, since any local that is not `Freeze` will be marked as indirectly mutable as soon as a reference to it is taken. Unfortunately, `UnsafeCell` is not `Copy`, so we can only do one `rustc_peek` on each value with interior mutability inside a test. I'm not sure how to deal with this restriction; perhaps I need to special case borrows preceding a call to `rustc_peek` in the analysis itself?\n\n`rustc_peek` also assumed that the analysis was done on move paths and that its transfer function only needed to be applied at assignment statements. This PR removes both of those restrictions by adding a trait, `RustcPeekAt`, that controls how the peeked at `Place` maps to the current dataflow state and using a dataflow cursor to retrieve the state itself.\n\nFinally, this PR adds a test which demonstrates some unsoundness in the `IndirectlyMutableLocals` analysis by converting a reference to a `Freeze` field to a reference to a `!Freeze` field by offsetting a pointer (or in this case transmuting a pointer to a ZST field with the same address as a `!Freeze` field). This does not represent a hole in the language proper, since this analysis is only used to validate `const` bodies, in which the unsound code will only compile with `-Zunleash-the-miri-inside-of-you`. Nevertheless, this should get fixed.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "html_url": "https://github.com/rust-lang/rust/commit/7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b0fe9c5c9bc2d58b2ac2451114bf2a670bd0dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b0fe9c5c9bc2d58b2ac2451114bf2a670bd0dc", "html_url": "https://github.com/rust-lang/rust/commit/10b0fe9c5c9bc2d58b2ac2451114bf2a670bd0dc"}, {"sha": "33aa5e855ed1deec5d086c7919b2a9572128b7ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/33aa5e855ed1deec5d086c7919b2a9572128b7ee", "html_url": "https://github.com/rust-lang/rust/commit/33aa5e855ed1deec5d086c7919b2a9572128b7ee"}], "stats": {"total": 367, "additions": 237, "deletions": 130}, "files": [{"sha": "6edd28a4259a5ed59c62957c39fd06d641b6540e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 184, "deletions": 130, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "patch": "@@ -3,19 +3,21 @@ use syntax::ast;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Body, Location};\n+use rustc::mir::{self, Body, Location, Local};\n use rustc_index::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::BitDenotation;\n use crate::dataflow::DataflowResults;\n+use crate::dataflow::DataflowResultsCursor;\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces\n };\n+use crate::dataflow::IndirectlyMutableLocals;\n use crate::dataflow::move_paths::{MovePathIndex, LookupResult};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n \n@@ -50,6 +52,10 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n                         DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n+        let flow_indirectly_mut =\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        IndirectlyMutableLocals::new(tcx, body, param_env),\n+                        |_, i| DebugFormatted::new(&i));\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n@@ -60,6 +66,9 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_indirectly_mut);\n+        }\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n@@ -88,151 +97,196 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(\n     def_id: DefId,\n     _attributes: &[ast::Attribute],\n     results: &DataflowResults<'tcx, O>,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n+) where O: RustcPeekAt<'tcx> {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n-    // FIXME: this is not DRY. Figure out way to abstract this and\n-    // `dataflow::build_sets`. (But note it is doing non-standard\n-    // stuff, so such generalization may not be realistic.)\n \n-    for bb in body.basic_blocks().indices() {\n-        each_block(tcx, body, results, bb);\n-    }\n-}\n+    let mut cursor = DataflowResultsCursor::new(results, body);\n \n-fn each_block<'tcx, O>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    results: &DataflowResults<'tcx, O>,\n-    bb: mir::BasicBlock,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n-    let move_data = results.0.operator.move_data();\n-    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n-\n-    let (args, span) = match is_rustc_peek(tcx, terminator) {\n-        Some(args_and_span) => args_and_span,\n-        None => return,\n-    };\n-    assert!(args.len() == 1);\n-    let peek_arg_place = match args[0] {\n-        mir::Operand::Copy(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) |\n-        mir::Operand::Move(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) => Some(place),\n-        _ => None,\n-    };\n-\n-    let peek_arg_place = match peek_arg_place {\n-        Some(arg) => arg,\n-        None => {\n-            tcx.sess.diagnostic().span_err(\n-                span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n-            return;\n-        }\n-    };\n-\n-    let mut on_entry = results.0.sets.entry_set_for(bb.index()).to_owned();\n-    let mut trans = results.0.sets.trans_for(bb.index()).clone();\n-\n-    // Emulate effect of all statements in the block up to (but not\n-    // including) the borrow within `peek_arg_place`. Do *not* include\n-    // call to `peek_arg_place` itself (since we are peeking the state\n-    // of the argument at time immediate preceding Call to\n-    // `rustc_peek`).\n-\n-    for (j, stmt) in statements.iter().enumerate() {\n-        debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n-        let (place, rvalue) = match stmt.kind {\n-            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                (place, rvalue)\n+    let peek_calls = body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .filter_map(|(bb, block_data)| {\n+                PeekCall::from_terminator(tcx, block_data.terminator())\n+                    .map(|call| (bb, block_data, call))\n+            });\n+\n+    for (bb, block_data, call) in peek_calls {\n+        // Look for a sequence like the following to indicate that we should be peeking at `_1`:\n+        //    _2 = &_1;\n+        //    rustc_peek(_2);\n+        //\n+        //    /* or */\n+        //\n+        //    _2 = _1;\n+        //    rustc_peek(_2);\n+        let (statement_index, peek_rval) = block_data\n+            .statements\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, stmt)| value_assigned_to_local(stmt, call.arg).map(|rval| (i, rval)))\n+            .next()\n+            .expect(\"call to rustc_peek should be preceded by \\\n+                    assignment to temporary holding its argument\");\n+\n+        match (call.kind, peek_rval) {\n+            | (PeekCallKind::ByRef, mir::Rvalue::Ref(_, _, place))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Move(place)))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Copy(place)))\n+            => {\n+                let loc = Location { block: bb, statement_index };\n+                cursor.seek(loc);\n+                let state = cursor.get();\n+                results.operator().peek_at(tcx, place, state, call);\n             }\n-            mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::Retag { .. } |\n-            mir::StatementKind::AscribeUserType(..) |\n-            mir::StatementKind::Nop => continue,\n-            mir::StatementKind::SetDiscriminant{ .. } =>\n-                span_bug!(stmt.source_info.span,\n-                          \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n-        };\n \n-        if place == peek_arg_place {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n-                // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_place.as_ref()) {\n-                    LookupResult::Exact(peek_mpi) => {\n-                        let bit_state = on_entry.contains(peek_mpi);\n-                        debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                               place, peeking_at_place, bit_state);\n-                        if !bit_state {\n-                            tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n-                        }\n-                    }\n-                    LookupResult::Parent(..) => {\n-                        tcx.sess.span_err(span, \"rustc_peek: argument untracked\");\n-                    }\n-                }\n-                return;\n-            } else {\n-                // Our search should have been over, but the input\n-                // does not match expectations of `rustc_peek` for\n-                // this sanity_check.\n+            _ => {\n                 let msg = \"rustc_peek: argument expression \\\n-                           must be immediate borrow of form `&expr`\";\n-                tcx.sess.span_err(span, msg);\n+                           must be either `place` or `&place`\";\n+                tcx.sess.span_err(call.span, msg);\n             }\n         }\n+    }\n+}\n \n-        let lhs_mpi = move_data.rev_lookup.find(place.as_ref());\n-\n-        debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n-               place, lhs_mpi, stmt);\n-        // reset GEN and KILL sets before emulating their effect.\n-        trans.clear();\n-        results.0.operator.before_statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        results.0.operator.statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        trans.apply(&mut on_entry);\n+/// If `stmt` is an assignment where the LHS is the given local (with no projections), returns the\n+/// RHS of the assignment.\n+fn value_assigned_to_local<'a, 'tcx>(\n+    stmt: &'a mir::Statement<'tcx>,\n+    local: Local,\n+) -> Option<&'a mir::Rvalue<'tcx>> {\n+    if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n+        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n+            if local == *l {\n+                return Some(&*rvalue);\n+            }\n+        }\n     }\n \n-    results.0.operator.before_terminator_effect(\n-        &mut trans,\n-        Location { block: bb, statement_index: statements.len() });\n+    None\n+}\n \n-    tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n-                                      anticipated pattern; note that \\\n-                                      rustc_peek expects input of \\\n-                                      form `&expr`\"));\n+#[derive(Clone, Copy, Debug)]\n+enum PeekCallKind {\n+    ByVal,\n+    ByRef,\n }\n \n-fn is_rustc_peek<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    terminator: &'a Option<mir::Terminator<'tcx>>,\n-) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n-    if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n-            if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.literal.ty.kind {\n-                    let abi = tcx.fn_sig(def_id).abi();\n-                    let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic && name == sym::rustc_peek {\n-                        return Some((args, source_info.span));\n+impl PeekCallKind {\n+    fn from_arg_ty(arg: Ty<'_>) -> Self {\n+        match arg.kind {\n+            ty::Ref(_, _, _) => PeekCallKind::ByRef,\n+            _ => PeekCallKind::ByVal,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct PeekCall {\n+    arg: Local,\n+    kind: PeekCallKind,\n+    span: Span,\n+}\n+\n+impl PeekCall {\n+    fn from_terminator<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> Option<Self> {\n+        use mir::{Operand, Place, PlaceBase};\n+\n+        let span = terminator.source_info.span;\n+        if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+            &terminator.kind\n+        {\n+            if let ty::FnDef(def_id, substs) = func.literal.ty.kind {\n+                let sig = tcx.fn_sig(def_id);\n+                let name = tcx.item_name(def_id);\n+                if sig.abi() != Abi::RustIntrinsic || name != sym::rustc_peek {\n+                    return None;\n+                }\n+\n+                assert_eq!(args.len(), 1);\n+                let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n+                let arg = match args[0] {\n+                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    => local,\n+\n+                    _ => {\n+                        tcx.sess.diagnostic().span_err(\n+                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                        return None;\n                     }\n+                };\n+\n+                return Some(PeekCall {\n+                    arg,\n+                    kind,\n+                    span,\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub trait RustcPeekAt<'tcx>: BitDenotation<'tcx> {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    );\n+}\n+\n+impl<'tcx, O> RustcPeekAt<'tcx> for O\n+    where O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n+{\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    ) {\n+        match self.move_data().rev_lookup.find(place.as_ref()) {\n+            LookupResult::Exact(peek_mpi) => {\n+                let bit_state = flow_state.contains(peek_mpi);\n+                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                       call.arg, place, bit_state);\n+                if !bit_state {\n+                    tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n                 }\n             }\n+\n+            LookupResult::Parent(..) => {\n+                tcx.sess.span_err(call.span, \"rustc_peek: argument untracked\");\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Local>,\n+        call: PeekCall,\n+    ) {\n+        warn!(\"peek_at: place={:?}\", place);\n+        let local = match place {\n+            mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } => *l,\n+            _ => {\n+                tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+                return;\n+            }\n+        };\n+\n+        if !flow_state.contains(local) {\n+            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n         }\n     }\n-    return None;\n }"}, {"sha": "82c47e6dbb75879ec01f1537ccc26dcefcc994c8", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "patch": "@@ -597,6 +597,7 @@ symbols! {\n         rustc_peek_definite_init,\n         rustc_peek_maybe_init,\n         rustc_peek_maybe_uninit,\n+        rustc_peek_indirectly_mutable,\n         rustc_private,\n         rustc_proc_macro_decls,\n         rustc_promotable,"}, {"sha": "804b70d26527a05ea8970a49834c2f8f740ecde1", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "patch": "@@ -0,0 +1,42 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n+\n+use std::cell::UnsafeCell;\n+use std::intrinsics::rustc_peek;\n+\n+#[repr(C)]\n+struct PartialInteriorMut {\n+    zst: [i32; 0],\n+    cell: UnsafeCell<i32>,\n+}\n+\n+#[rustc_mir(rustc_peek_indirectly_mutable,stop_after_dataflow)]\n+#[rustc_mir(borrowck_graphviz_postflow=\"indirect.dot\")]\n+const BOO: i32 = {\n+    let x = PartialInteriorMut {\n+        zst: [],\n+        cell: UnsafeCell::new(0),\n+    };\n+\n+    let p_zst: *const _ = &x.zst ; // Doesn't cause `x` to get marked as indirectly mutable.\n+\n+    let rmut_cell = unsafe {\n+        // Take advantage of the fact that `zst` and `cell` are at the same location in memory.\n+        // This trick would work with any size type if miri implemented `ptr::offset`.\n+        let p_cell = p_zst as *const UnsafeCell<i32>;\n+\n+        let pmut_cell = (*p_cell).get();\n+        &mut *pmut_cell\n+    };\n+\n+    *rmut_cell = 42;  // Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!\n+    let val = *rmut_cell;\n+    unsafe { rustc_peek(x) }; //~ ERROR rustc_peek: bit not set\n+\n+    val\n+};\n+\n+fn main() {\n+    println!(\"{}\", BOO);\n+}"}, {"sha": "16bd17813134a8e9d5f2a6ccd3d4f49ae15b8885", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7daf2e8946015f0ba1bf69f5be61964a3f29f04e/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=7daf2e8946015f0ba1bf69f5be61964a3f29f04e", "patch": "@@ -0,0 +1,10 @@\n+error: rustc_peek: bit not set\n+  --> $DIR/indirect-mutation-offset.rs:35:14\n+   |\n+LL |     unsafe { rustc_peek(x) };\n+   |              ^^^^^^^^^^^^^\n+\n+error: stop_after_dataflow ended compilation\n+\n+error: aborting due to 2 previous errors\n+"}]}