{"sha": "b2df88bae1318689c86c69655268ca2d2afc0f81", "node_id": "C_kwDOAAsO6NoAKGIyZGY4OGJhZTEzMTg2ODljODZjNjk2NTUyNjhjYTJkMmFmYzBmODE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T01:55:54Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-13T22:43:17Z"}, "message": "Consolidate two almost duplicated fn info extraction routines", "tree": {"sha": "42594c7fc57f1abfa8e792dcd6b415543c030ee4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42594c7fc57f1abfa8e792dcd6b415543c030ee4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2df88bae1318689c86c69655268ca2d2afc0f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2df88bae1318689c86c69655268ca2d2afc0f81", "html_url": "https://github.com/rust-lang/rust/commit/b2df88bae1318689c86c69655268ca2d2afc0f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2df88bae1318689c86c69655268ca2d2afc0f81/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b90256ada21c6a81b4c18f2c7a23151ab5fc232", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b90256ada21c6a81b4c18f2c7a23151ab5fc232", "html_url": "https://github.com/rust-lang/rust/commit/0b90256ada21c6a81b4c18f2c7a23151ab5fc232"}], "stats": {"total": 368, "additions": 183, "deletions": 185}, "files": [{"sha": "f1a4f94cd0151e9f4c2b30526c2d3e0413bd123e", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -659,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-            if let Some((maybe_def, output_ty, _)) =\n-                self.extract_callable_info(callee_expr, callee_ty)\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_ty)\n                 && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n             {\n                 let descr = match maybe_def {"}, {"sha": "76f33be7a389c5bb111778f7964e626aa29b1acf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_hir_analysis::astconv::AstConv;\n-use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n@@ -23,9 +22,9 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::NormalizeExt;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n@@ -94,7 +93,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(expr, found)\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(found)\n             else { return false; };\n         if can_satisfy(output) {\n             let (sugg_call, mut applicability) = match inputs.len() {\n@@ -163,99 +162,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// because the callable type must also be well-formed to be called.\n     pub(in super::super) fn extract_callable_info(\n         &self,\n-        expr: &Expr<'_>,\n-        found: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        // Autoderef is useful here because sometimes we box callables, etc.\n-        let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n-            match *found.kind() {\n-                ty::FnPtr(fn_sig) =>\n-                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n-                ty::FnDef(def_id, _) => {\n-                    let fn_sig = found.fn_sig(self.tcx);\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-                }\n-                ty::Closure(def_id, substs) => {\n-                    let fn_sig = substs.as_closure().sig();\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n-                }\n-                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Dynamic(data, _, ty::Dyn) => {\n-                    data.iter().find_map(|pred| {\n-                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // for existential projection, substs are shifted over by 1\n-                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::Name(\"trait object\"),\n-                                pred.rebind(proj.term.ty().unwrap()),\n-                                pred.rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Param(param) => {\n-                    let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n-                    self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        && proj.projection_ty.self_ty() == found\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                _ => None,\n-            }\n-        }) else { return None; };\n-\n-        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let inputs = inputs\n-            .skip_binder()\n-            .iter()\n-            .map(|ty| {\n-                self.replace_bound_vars_with_fresh_vars(\n-                    expr.span,\n-                    infer::FnCall,\n-                    inputs.rebind(*ty),\n-                )\n-            })\n-            .collect();\n-\n-        // We don't want to register any extra obligations, which should be\n-        // implied by wf, but also because that would possibly result in\n-        // erroneous errors later on.\n-        let infer::InferOk { value: output, obligations: _ } =\n-            self.at(&self.misc(expr.span), self.param_env).normalize(output);\n-\n-        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call(\n@@ -267,9 +176,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rhs_ty: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_ty)\n             else { return false; };\n-        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_ty)\n             else { return false; };\n \n         if can_satisfy(lhs_output_ty, rhs_output_ty) {"}, {"sha": "7e25810337240dcfca33ada3b37bcc7b98418f80", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -2662,8 +2662,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> bool {\n-        let Some((_def_id_or_name, output, _inputs)) = self.extract_callable_info(expr, found)\n-        else { return false; };\n+        let Some((_def_id_or_name, output, _inputs)) =\n+            self.extract_callable_info(found) else {\n+                return false;\n+        };\n \n         if !self.can_coerce(output, expected) {\n             return false;"}, {"sha": "940fc29841b0818e429592566984e10a0cee6f0b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -2912,6 +2912,7 @@ impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n     }\n }\n \n+#[derive(Copy, Clone)]\n pub enum DefIdOrName {\n     DefId(DefId),\n     Name(&'static str),"}, {"sha": "48c32a446c521ba342360a3822dfda0e308e9e56", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 137, "deletions": 84, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -212,6 +212,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)>;\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -885,92 +892,17 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             return false;\n         }\n \n-        // This is duplicated from `extract_callable_info` in typeck, which\n-        // relies on autoderef, so we can't use it here.\n-        let found = trait_pred.self_ty().skip_binder().peel_refs();\n-        let Some((def_id_or_name, output, inputs)) = (match *found.kind()\n-        {\n-            ty::FnPtr(fn_sig) => {\n-                Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                Some((\n-                    DefIdOrName::DefId(def_id),\n-                    fn_sig.output(),\n-                    fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n-                ))\n-            }\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::DefId(def_id),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Dynamic(data, _, ty::Dyn) => {\n-                data.iter().find_map(|pred| {\n-                    if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                    && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // for existential projection, substs are shifted over by 1\n-                    && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"trait object\"),\n-                            pred.rebind(proj.term.ty().unwrap()),\n-                            pred.rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Param(_) => {\n-                obligation.param_env.caller_bounds().iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    && proj.projection_ty.self_ty() == found\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"type parameter\"),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            _ => None,\n-        }) else { return false; };\n-        let output = self.replace_bound_vars_with_fresh_vars(\n-            obligation.cause.span,\n+        let self_ty = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n-            output,\n+            trait_pred.self_ty(),\n         );\n-        let inputs = inputs.skip_binder().iter().map(|ty| {\n-            self.replace_bound_vars_with_fresh_vars(\n-                obligation.cause.span,\n-                LateBoundRegionConversionTime::FnCall,\n-                inputs.rebind(*ty),\n-            )\n-        });\n+\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(\n+            obligation.cause.body_id,\n+            obligation.param_env,\n+            self_ty,\n+        ) else { return false; };\n \n         // Remapping bound vars here\n         let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output));\n@@ -998,6 +930,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         };\n \n         let args = inputs\n+            .into_iter()\n             .map(|ty| {\n                 if ty.is_suggestable(self.tcx, false) {\n                     format!(\"/* {ty} */\")\n@@ -1161,6 +1094,126 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         false\n     }\n \n+    /// Extracts information about a callable type for diagnostics. This is a\n+    /// heuristic -- it doesn't necessarily mean that a type is always callable,\n+    /// because the callable type must also be well-formed to be called.\n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id_or_name, output, inputs)) = Autoderef::new(\n+            self,\n+            param_env,\n+            hir_id,\n+            DUMMY_SP,\n+            found,\n+        ).silence_errors().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) =>\n+                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n+                }\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Dynamic(data, _, ty::Dyn) => {\n+                    data.iter().find_map(|pred| {\n+                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // for existential projection, substs are shifted over by 1\n+                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::Name(\"trait object\"),\n+                                pred.rebind(proj.term.ty().unwrap()),\n+                                pred.rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Param(param) => {\n+                    let generics = self.tcx.generics_of(hir_id.owner.to_def_id());\n+                    let name = if generics.count() > param.index as usize\n+                        && let def = generics.param_at(param.index as usize, self.tcx)\n+                        && matches!(def.kind, ty::GenericParamDefKind::Type { .. })\n+                        && def.name == param.name\n+                    {\n+                        DefIdOrName::DefId(def.def_id)\n+                    } else {\n+                        DefIdOrName::Name(\"type parameter\")\n+                    };\n+                    param_env.caller_bounds().iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        && proj.projection_ty.self_ty() == found\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                name,\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                _ => None,\n+            }\n+        }) else { return None; };\n+\n+        let output = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::FnCall,\n+            output,\n+        );\n+        let inputs = inputs\n+            .skip_binder()\n+            .iter()\n+            .map(|ty| {\n+                self.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    inputs.rebind(*ty),\n+                )\n+            })\n+            .collect();\n+\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let InferOk { value: output, obligations: _ } =\n+            self.at(&ObligationCause::dummy(), param_env).normalize(output);\n+\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "9021dd752e7e9525c3e6bc8489827d601895acf0", "filename": "tests/ui/suggestions/call-on-unimplemented-with-autoderef.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -0,0 +1,13 @@\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+\n+fn needs_foo(_: impl Foo) {}\n+\n+fn test(x: &Box<dyn Fn() -> i32>) {\n+    needs_foo(x);\n+    //~^ ERROR the trait bound\n+    //~| HELP use parentheses to call this trait object\n+}\n+\n+fn main() {}"}, {"sha": "90f44cce06e440a1744d2e508201e2459f391af3", "filename": "tests/ui/suggestions/call-on-unimplemented-with-autoderef.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2df88bae1318689c86c69655268ca2d2afc0f81/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2df88bae1318689c86c69655268ca2d2afc0f81/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr?ref=b2df88bae1318689c86c69655268ca2d2afc0f81", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `&Box<dyn Fn() -> i32>: Foo` is not satisfied\n+  --> $DIR/call-on-unimplemented-with-autoderef.rs:8:15\n+   |\n+LL |     needs_foo(x);\n+   |     --------- ^ the trait `Foo` is not implemented for `&Box<dyn Fn() -> i32>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `needs_foo`\n+  --> $DIR/call-on-unimplemented-with-autoderef.rs:5:22\n+   |\n+LL | fn needs_foo(_: impl Foo) {}\n+   |                      ^^^ required by this bound in `needs_foo`\n+help: use parentheses to call this trait object\n+   |\n+LL |     needs_foo(x());\n+   |                ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}