{"sha": "3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNjE3OTNiNWFlZWYzYWIzZThmZTg3NmZiOTRkZDljOGM0NDEwYzY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-07T23:12:23Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-07T23:12:23Z"}, "message": "Synthesize closure thunks, and pass closure pointer into fn calls.", "tree": {"sha": "ea1eee2d59a86894460c966e1f7ff457eab53a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea1eee2d59a86894460c966e1f7ff457eab53a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "html_url": "https://github.com/rust-lang/rust/commit/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9994a29634cc8d1ce330bdbb41fb1941c41f778", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9994a29634cc8d1ce330bdbb41fb1941c41f778", "html_url": "https://github.com/rust-lang/rust/commit/a9994a29634cc8d1ce330bdbb41fb1941c41f778"}], "stats": {"total": 200, "additions": 170, "deletions": 30}, "files": [{"sha": "f81c2bb4c6067fb39a5ab33bf79bf92f5d4fe072", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 170, "deletions": 30, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3c61793b5aeef3ab3e8fe876fb94dd9c8c4410c6", "patch": "@@ -77,6 +77,7 @@ state type crate_ctxt = rec(session.session sess,\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n+                         ValueRef llclosure,\n                          mutable option.t[ValueRef] llself,\n                          mutable option.t[ValueRef] llretptr,\n                          hashmap[ast.def_id, ValueRef] llargs,\n@@ -197,7 +198,7 @@ fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n \n fn T_fn_pair(TypeRef tfn) -> TypeRef {\n     ret T_struct(vec(T_ptr(tfn),\n-                     T_ptr(T_box(T_nil()))));\n+                     T_opaque_closure_ptr()));\n }\n \n fn T_ptr(TypeRef t) -> TypeRef {\n@@ -287,6 +288,20 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n+fn T_closure_ptr(TypeRef lltarget_ty,\n+                 TypeRef llbindings_ty) -> TypeRef {\n+    ret T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n+                                 lltarget_ty,\n+                                 llbindings_ty)\n+                             // FIXME: add captured typarams.\n+                             )));\n+}\n+\n+fn T_opaque_closure_ptr() -> TypeRef {\n+    ret T_ptr(T_box(T_nil()));\n+}\n+\n+\n fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     let TypeRef llty = type_of_inner(cx, t);\n     check (llty as int != 0);\n@@ -313,7 +328,9 @@ fn type_of_fn_full(@crate_ctxt cx,\n             check (t as int != 0);\n             atys += t;\n         }\n-        case (_) { }\n+        case (_) {\n+            atys += T_opaque_closure_ptr();\n+        }\n     }\n \n     if (ty.type_has_dynamic_size(output)) {\n@@ -1880,7 +1897,8 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n \n-impure fn trans_args(@block_ctxt cx, option.t[ValueRef] llobj,\n+impure fn trans_args(@block_ctxt cx, ValueRef llclosure,\n+                     option.t[ValueRef] llobj,\n                      &vec[@ast.expr] es, @ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n@@ -1899,7 +1917,9 @@ impure fn trans_args(@block_ctxt cx, option.t[ValueRef] llobj,\n             // doted method-call).\n             vs += cx.build.Load(ob);\n         }\n-        case (_) { }\n+        case (_) {\n+            vs += llclosure;\n+        }\n     }\n \n     auto i = 0u;\n@@ -1948,6 +1968,95 @@ impure fn trans_args(@block_ctxt cx, option.t[ValueRef] llobj,\n     ret tup(bcx, vs);\n }\n \n+impure fn trans_bind_thunk(@crate_ctxt cx,\n+                           @ty.t incoming_fty,\n+                           @ty.t outgoing_fty,\n+                           vec[option.t[@ast.expr]] args,\n+                           TypeRef llclosure_ty,\n+                           vec[@ty.t] bound_tys) -> ValueRef {\n+    // Construct a thunk-call with signature incoming_fty, and that copies\n+    // args forward into a call to outgoing_fty.\n+\n+    let str s = cx.names.next(\"_rust_thunk\") + \".\" + cx.path;\n+    let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n+    let ValueRef llthunk = decl_fastcall_fn(cx.llmod, s, llthunk_ty);\n+\n+    let @ty.t rty = ret_ty_of_fn_ty(incoming_fty);\n+\n+    // FIXME: handle ty params properly.\n+    let vec[ast.ty_param] ty_params = vec();\n+\n+    auto fcx = new_fn_ctxt(cx, s, llthunk);\n+    auto bcx = new_top_block_ctxt(fcx);\n+\n+    auto llclosure = bcx.build.PointerCast(fcx.llclosure, llclosure_ty);\n+\n+    auto llbody = bcx.build.GEP(llclosure,\n+                                vec(C_int(0),\n+                                    C_int(abi.box_rc_field_body)));\n+\n+    auto lltarget = bcx.build.GEP(llbody,\n+                                  vec(C_int(0),\n+                                      C_int(abi.closure_elt_target)));\n+\n+    auto llbound = bcx.build.GEP(llbody,\n+                                 vec(C_int(0),\n+                                     C_int(abi.closure_elt_bindings)));\n+\n+    auto lltargetclosure = bcx.build.GEP(lltarget,\n+                                         vec(C_int(0),\n+                                             C_int(abi.fn_field_box)));\n+    lltargetclosure = bcx.build.Load(lltargetclosure);\n+    let vec[ValueRef] llargs = vec(fcx.lltaskptr,\n+                                   lltargetclosure);\n+    let uint a = 0u;\n+    let int b = 0;\n+    for (option.t[@ast.expr] arg in args) {\n+        alt (arg) {\n+\n+            // Arg provided at binding time; thunk copies it from closure.\n+            case (some[@ast.expr](_)) {\n+                let ValueRef bound_arg = bcx.build.GEP(llbound,\n+                                                       vec(C_int(0),\n+                                                           C_int(b)));\n+                // FIXME: possibly support passing aliases someday.\n+                llargs += bcx.build.Load(bound_arg);\n+                b += 1;\n+            }\n+\n+            // Arg will be provided when the thunk is invoked.\n+            case (none[@ast.expr]) {\n+                let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n+                llargs += passed_arg;\n+                a += 1u;\n+            }\n+        }\n+    }\n+\n+    // FIXME: turn this call + ret into a tail call.\n+    auto lltargetfn = bcx.build.GEP(lltarget,\n+                                    vec(C_int(0),\n+                                        C_int(abi.fn_field_code)));\n+    lltargetfn = bcx.build.Load(lltargetfn);\n+    auto r = bcx.build.FastCall(lltargetfn, llargs);\n+\n+    alt (fcx.llretptr) {\n+        case (some[ValueRef](?llptr)) {\n+            bcx.build.Store(bcx.build.Load(r), llptr);\n+            bcx.build.RetVoid();\n+        }\n+        case (none[ValueRef]) {\n+            if (ty.type_is_nil(rty)) {\n+                bcx.build.RetVoid();\n+            } else {\n+                bcx.build.Ret(r);\n+            }\n+        }\n+    }\n+\n+    ret llthunk;\n+}\n+\n impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n                      vec[option.t[@ast.expr]] args,\n                      &ast.ann ann) -> result {\n@@ -1974,10 +2083,6 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n             auto pair_t = node_type(cx.fcx.ccx, ann);\n             auto pair_v = bcx.build.Alloca(pair_t);\n \n-            auto pair_box = bcx.build.GEP(pair_v,\n-                                          vec(C_int(0),\n-                                              C_int(abi.fn_field_box)));\n-\n             // Translate the bound expressions.\n             let vec[@ty.t] bound_tys = vec();\n             let vec[ValueRef] bound_vals = vec();\n@@ -1990,14 +2095,10 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n \n             // Synthesize a closure type.\n             let @ty.t bindings_ty = ty.plain_ty(ty.ty_tup(bound_tys));\n+            let TypeRef lltarget_ty = type_of(bcx.fcx.ccx, ty.expr_ty(f));\n             let TypeRef llbindings_ty = type_of(bcx.fcx.ccx, bindings_ty);\n-            let TypeRef llclosure_ty =\n-                T_ptr(T_box(T_struct(vec(T_ptr(T_tydesc()),\n-                                         type_of(bcx.fcx.ccx,\n-                                                 ty.expr_ty(f)),\n-                                         llbindings_ty)\n-                                     // FIXME: add captured typarams.\n-                                     )));\n+            let TypeRef llclosure_ty = T_closure_ptr(lltarget_ty,\n+                                                     llbindings_ty);\n \n             // Malloc a box for the body.\n             auto r = trans_malloc_inner(bcx, llclosure_ty);\n@@ -2040,10 +2141,27 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 i += 1;\n             }\n \n-            // Store box ptr in outer pair.\n-            let TypeRef llbox_ty = T_ptr(T_box(T_nil()));\n-            auto p = r.bcx.build.PointerCast(box, llbox_ty);\n-            bcx.build.Store(p, pair_box);\n+            // Make thunk and store thunk-ptr in outer pair's code slot.\n+            auto pair_code = bcx.build.GEP(pair_v,\n+                                           vec(C_int(0),\n+                                               C_int(abi.fn_field_code)));\n+            let ValueRef llthunk =\n+                trans_bind_thunk(cx.fcx.ccx,\n+                                 node_ann_type(cx.fcx.ccx, ann),\n+                                 ty.expr_ty(f),\n+                                 args,\n+                                 llclosure_ty,\n+                                 bound_tys);\n+\n+            bcx.build.Store(llthunk, pair_code);\n+\n+            // Store box ptr in outer pair's box slot.\n+            auto pair_box = bcx.build.GEP(pair_v,\n+                                          vec(C_int(0),\n+                                              C_int(abi.fn_field_box)));\n+            bcx.build.Store(bcx.build.PointerCast(box,\n+                                                  T_opaque_closure_ptr()),\n+                            pair_box);\n \n             ret res(bcx, pair_v);\n         }\n@@ -2054,6 +2172,7 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                      vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n+    auto llclosure = C_null(T_opaque_closure_ptr());\n \n     alt (f_res.llobj) {\n         case (some[ValueRef](_)) {\n@@ -2063,14 +2182,20 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n         case (none[ValueRef]) {\n             // It's a closure.\n             auto bcx = f_res.res.bcx;\n-            faddr = bcx.build.GEP(faddr, vec(C_int(0),\n+            auto pair = faddr;\n+            faddr = bcx.build.GEP(pair, vec(C_int(0),\n                                              C_int(abi.fn_field_code)));\n             faddr = bcx.build.Load(faddr);\n+\n+            llclosure = bcx.build.GEP(pair, vec(C_int(0),\n+                                                 C_int(abi.fn_field_box)));\n+            llclosure = bcx.build.Load(llclosure);\n         }\n     }\n     auto fn_ty = ty.expr_ty(f);\n     auto ret_ty = ty.ann_to_type(ann);\n-    auto args_res = trans_args(f_res.res.bcx, f_res.llobj, args, fn_ty);\n+    auto args_res = trans_args(f_res.res.bcx, llclosure, f_res.llobj,\n+                               args, fn_ty);\n \n     auto real_retval = args_res._0.build.FastCall(faddr, args_res._1);\n     auto retval;\n@@ -2569,6 +2694,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n                ValueRef llfndecl) -> @fn_ctxt {\n \n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfndecl, 0u);\n+    let ValueRef llclosure = llvm.LLVMGetParam(llfndecl, 1u);\n \n     let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n@@ -2577,6 +2703,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n \n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n+             llclosure=llclosure,\n              mutable llself=none[ValueRef],\n              mutable llretptr=none[ValueRef],\n              llargs=llargs,\n@@ -2608,7 +2735,10 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n             cx.llself = some[ValueRef](llself);\n             arg_n += 1u;\n         }\n-        case (_) { }\n+        case (_) {\n+            // llclosure, we don't know what it is.\n+            arg_n += 1u;\n+        }\n     }\n \n     if (ty.type_has_dynamic_size(ret_ty)) {\n@@ -2677,15 +2807,20 @@ fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n     fail;\n }\n \n-fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n-    alt (ty.ann_to_type(ann).struct) {\n+fn ret_ty_of_fn_ty(@ty.t t) -> @ty.t {\n+    alt (t.struct) {\n         case (ty.ty_fn(_, ?ret_ty)) {\n             ret ret_ty;\n         }\n     }\n     fail;\n }\n \n+\n+fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n+    ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n+}\n+\n fn create_llobjfields_for_fields(@block_ctxt cx, ValueRef llself) {\n \n     let vec[TypeRef] llfield_tys = vec();\n@@ -2996,18 +3131,22 @@ impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n     }\n }\n \n+fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n+    // Bit of a kludge: pick the fn typeref out of the pair.\n+    let vec[TypeRef] pair_tys = vec(T_nil(), T_nil());\n+    llvm.LLVMGetStructElementTypes(llpairty,\n+                                   _vec.buf[TypeRef](pair_tys));\n+    ret llvm.LLVMGetElementType(pair_tys.(0));\n+}\n+\n fn decl_fn_and_pair(@crate_ctxt cx,\n                     str kind,\n                     str name,\n                     &ast.ann ann,\n                     ast.def_id id) {\n \n-    // Bit of a kludge: pick the fn typeref out of the pair.\n     auto llpairty = node_type(cx, ann);\n-    let vec[TypeRef] pair_tys = vec(T_nil(), T_nil());\n-    llvm.LLVMGetStructElementTypes(llpairty,\n-                                   _vec.buf[TypeRef](pair_tys));\n-    auto llfty = llvm.LLVMGetElementType(pair_tys.(0));\n+    auto llfty = get_pair_fn_ty(llpairty);\n \n     // Declare the function itself.\n     let str s = cx.names.next(\"_rust_\" + kind) + \".\" + name;\n@@ -3018,7 +3157,7 @@ fn decl_fn_and_pair(@crate_ctxt cx,\n     let ValueRef gvar = llvm.LLVMAddGlobal(cx.llmod, llpairty,\n                                            _str.buf(ps));\n     auto pair = C_struct(vec(llfn,\n-                             C_null(T_ptr(T_box(T_nil())))));\n+                             C_null(T_opaque_closure_ptr())));\n \n     llvm.LLVMSetInitializer(gvar, pair);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n@@ -3252,6 +3391,7 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n+                    llclosure=C_null(T_opaque_closure_ptr()),\n                     mutable llself=none[ValueRef],\n                     mutable llretptr=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),"}]}