{"sha": "fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODVjYTAyZjZkYTQ1MzFiY2VjNjViODMwOWVjZjM4ZTBlYjg5Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-02T15:31:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-02T15:31:53Z"}, "message": "Auto merge of #80550 - bugadani:markdown-refactor, r=jyn514\n\nCleanup markdown span handling, take 2\n\nThis PR includes the cleanups made in #80244 except for the removal of `locate()`.\n\nWhile the biggest conceptual part in #80244 was the removal of `locate()`, it introduced a diagnostic regression.\n\nAdditional cleanup:\n - Use `RefCell` to avoid building two separate vectors for the links\n\nWork to do:\n- [ ] Decide if `locate()` can be simplified by assuming `s` is always in `md`\n- [ ] Should probably add some tests that still provide the undesired diagnostics causing #80381\n\ncc `@jyn514` This is the best I can do without patching Pulldown to provide multiple ranges for reference-style links. Also, since `locate` is probably more efficient than `rfind` (at least it's constant time), I decided to not check the link type and just cover every &str as it was before.", "tree": {"sha": "1be9b90cb754d2a6dc5623050918ec92d7c67c44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be9b90cb754d2a6dc5623050918ec92d7c67c44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "html_url": "https://github.com/rust-lang/rust/commit/fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd85ca02f6da4531bcec65b8309ecf38e0eb8938/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ccf4f5adfb2562fc95c996b97faac7775a34bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ccf4f5adfb2562fc95c996b97faac7775a34bb", "html_url": "https://github.com/rust-lang/rust/commit/90ccf4f5adfb2562fc95c996b97faac7775a34bb"}, {"sha": "f07354333f254fc7d3f20c939b29ba93143b8671", "url": "https://api.github.com/repos/rust-lang/rust/commits/f07354333f254fc7d3f20c939b29ba93143b8671", "html_url": "https://github.com/rust-lang/rust/commit/f07354333f254fc7d3f20c939b29ba93143b8671"}], "stats": {"total": 214, "additions": 111, "deletions": 103}, "files": [{"sha": "0774413960501f0f023d53c42d0d3d8fc432c604", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 84, "deletions": 71, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/fd85ca02f6da4531bcec65b8309ecf38e0eb8938/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd85ca02f6da4531bcec65b8309ecf38e0eb8938/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "patch": "@@ -25,6 +25,7 @@ use rustc_session::lint;\n use rustc_span::edition::Edition;\n use rustc_span::Span;\n use std::borrow::Cow;\n+use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt::Write;\n@@ -414,11 +415,13 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n     }\n }\n \n+type SpannedEvent<'a> = (Event<'a>, Range<usize>);\n+\n /// Make headings links with anchor IDs and build up TOC.\n struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<Event<'a>>,\n+    buf: VecDeque<SpannedEvent<'a>>,\n     id_map: &'ids mut IdMap,\n }\n \n@@ -428,48 +431,48 @@ impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n-    type Item = Event<'a>;\n+impl<'a, 'b, 'ids, I: Iterator<Item = SpannedEvent<'a>>> Iterator\n+    for HeadingLinks<'a, 'b, 'ids, I>\n+{\n+    type Item = SpannedEvent<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Heading(level))) = event {\n+        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event {\n+                match &event.0 {\n                     Event::End(Tag::Heading(..)) => break,\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n+                        self.buf.push_back(event);\n                     }\n-                    _ => {}\n-                }\n-                match event {\n-                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n-                    event => self.buf.push_back(event),\n+                    _ => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n+                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n             }\n \n-            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::Html(start_tags.into()));\n+            return Some((Event::Html(start_tags.into()), 0..0));\n         }\n         event\n     }\n@@ -555,23 +558,23 @@ impl<'a, I> Footnotes<'a, I> {\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n-    type Item = Event<'a>;\n+impl<'a, I: Iterator<Item = SpannedEvent<'a>>> Iterator for Footnotes<'a, I> {\n+    type Item = SpannedEvent<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some(Event::FootnoteReference(ref reference)) => {\n+                Some((Event::FootnoteReference(ref reference), range)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some(Event::Html(reference.into()));\n+                    return Some((Event::Html(reference.into()), range));\n                 }\n-                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n                     let mut content = Vec::new();\n-                    for event in &mut self.inner {\n+                    for (event, _) in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -602,7 +605,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some(Event::Html(ret.into()));\n+                        return Some((Event::Html(ret.into()), 0..0));\n                     } else {\n                         return None;\n                     }\n@@ -912,13 +915,14 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n+        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -929,16 +933,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n+            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -954,19 +958,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) => Event::Text(text),\n+        let p = p.map(|event| match event.0 {\n+            Event::Html(text) => (Event::Text(text), event.1),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1119,56 +1123,65 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n-    let mut links = vec![];\n-    let mut shortcut_links = vec![];\n-\n-    {\n-        let locate = |s: &str| unsafe {\n-            let s_start = s.as_ptr();\n-            let s_end = s_start.add(s.len());\n-            let md_start = md.as_ptr();\n-            let md_end = md_start.add(md.len());\n-            if md_start <= s_start && s_end <= md_end {\n-                let start = s_start.offset_from(md_start) as usize;\n-                let end = s_end.offset_from(md_start) as usize;\n-                Some(start..end)\n-            } else {\n-                None\n-            }\n-        };\n+    let links = RefCell::new(vec![]);\n+\n+    // FIXME: remove this function once pulldown_cmark can provide spans for link definitions.\n+    let locate = |s: &str, fallback: Range<usize>| unsafe {\n+        let s_start = s.as_ptr();\n+        let s_end = s_start.add(s.len());\n+        let md_start = md.as_ptr();\n+        let md_end = md_start.add(md.len());\n+        if md_start <= s_start && s_end <= md_end {\n+            let start = s_start.offset_from(md_start) as usize;\n+            let end = s_end.offset_from(md_start) as usize;\n+            start..end\n+        } else {\n+            fallback\n+        }\n+    };\n+\n+    let span_for_link = |link: &CowStr<'_>, span: Range<usize>| {\n+        // For diagnostics, we want to underline the link's definition but `span` will point at\n+        // where the link is used. This is a problem for reference-style links, where the definition\n+        // is separate from the usage.\n+        match link {\n+            // `Borrowed` variant means the string (the link's destination) may come directly from\n+            // the markdown text and we can locate the original link destination.\n+            // NOTE: LinkReplacer also provides `Borrowed` but possibly from other sources,\n+            // so `locate()` can fall back to use `span`.\n+            CowStr::Borrowed(s) => locate(s, span),\n+\n+            // For anything else, we can only use the provided range.\n+            CowStr::Boxed(_) | CowStr::Inlined(_) => span,\n+        }\n+    };\n \n-        let mut push = |link: BrokenLink<'_>| {\n-            // FIXME: use `link.span` instead of `locate`\n-            // (doing it now includes the `[]` as well as the text)\n-            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n-            None\n-        };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n-\n-        // There's no need to thread an IdMap through to here because\n-        // the IDs generated aren't going to be emitted anywhere.\n-        let mut ids = IdMap::new();\n-        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n-\n-        for ev in iter {\n-            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n-                debug!(\"found link: {}\", dest);\n-                links.push(match dest {\n-                    CowStr::Borrowed(s) => (s.to_owned(), locate(s)),\n-                    s @ (CowStr::Boxed(..) | CowStr::Inlined(..)) => (s.into_string(), None),\n-                });\n-            }\n+    let mut push = |link: BrokenLink<'_>| {\n+        let span = span_for_link(&CowStr::Borrowed(link.reference), link.span);\n+        links.borrow_mut().push((link.reference.to_owned(), span));\n+        None\n+    };\n+    let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push)).into_offset_iter();\n+\n+    // There's no need to thread an IdMap through to here because\n+    // the IDs generated aren't going to be emitted anywhere.\n+    let mut ids = IdMap::new();\n+    let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n+\n+    for ev in iter {\n+        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n+            debug!(\"found link: {}\", dest);\n+            let span = span_for_link(&dest, ev.1);\n+            links.borrow_mut().push((dest.into_string(), span));\n         }\n     }\n \n-    links.append(&mut shortcut_links);\n-\n-    links\n+    links.into_inner()\n }\n \n #[derive(Debug)]"}, {"sha": "bd8bfd8e1c9afcd02f86c96a3705a872c44083b9", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fd85ca02f6da4531bcec65b8309ecf38e0eb8938/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd85ca02f6da4531bcec65b8309ecf38e0eb8938/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fd85ca02f6da4531bcec65b8309ecf38e0eb8938", "patch": "@@ -245,7 +245,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -960,7 +960,7 @@ impl LinkCollector<'_, '_> {\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: String,\n-        link_range: Option<Range<usize>>,\n+        link_range: Range<usize>,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n@@ -1606,7 +1606,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1624,31 +1624,27 @@ fn report_diagnostic(\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = link_range\n-            .as_ref()\n-            .and_then(|range| super::source_span_for_markdown_range(cx, dox, range, attrs));\n+        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n \n-        if let Some(link_range) = link_range {\n-            if let Some(sp) = span {\n-                diag.set_span(sp);\n-            } else {\n-                // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-                //                       ^     ~~~~\n-                //                       |     link_range\n-                //                       last_new_line_offset\n-                let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-                let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-                // Print the line containing the `link_range` and manually mark it with '^'s.\n-                diag.note(&format!(\n-                    \"the link appears in this line:\\n\\n{line}\\n\\\n+        if let Some(sp) = span {\n+            diag.set_span(sp);\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n                      {indicator: <before$}{indicator:^<found$}\",\n-                    line = line,\n-                    indicator = \"\",\n-                    before = link_range.start - last_new_line_offset,\n-                    found = link_range.len(),\n-                ));\n-            }\n+                line = line,\n+                indicator = \"\",\n+                before = link_range.start - last_new_line_offset,\n+                found = link_range.len(),\n+            ));\n         }\n \n         decorate(&mut diag, span);\n@@ -1668,7 +1664,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     let tcx = collector.cx.tcx;\n@@ -1892,7 +1888,7 @@ fn anchor_failure(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     failure: AnchorFailure,\n ) {\n     let msg = match failure {\n@@ -1917,7 +1913,7 @@ fn ambiguity_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     candidates: Vec<Res>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -1966,13 +1962,12 @@ fn suggest_disambiguator(\n     path_str: &str,\n     dox: &str,\n     sp: Option<rustc_span::Span>,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n ) {\n     let suggestion = disambiguator.suggestion();\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n-        let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n         let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n             format!(\"`{}`\", suggestion.as_help(path_str))\n         } else {\n@@ -1991,7 +1986,7 @@ fn privacy_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n ) {\n     let sym;\n     let item_name = match item.name {"}]}