{"sha": "d1985c9dd06379b8a173239e90007db926ec052e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOTg1YzlkZDA2Mzc5YjhhMTczMjM5ZTkwMDA3ZGI5MjZlYzA1MmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-12T05:09:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-21T01:02:38Z"}, "message": "Implement a lint mode to deal with unused 'mut' variables", "tree": {"sha": "59043863d15f5812667e77fc4e4da4b0585d7a44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59043863d15f5812667e77fc4e4da4b0585d7a44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1985c9dd06379b8a173239e90007db926ec052e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1985c9dd06379b8a173239e90007db926ec052e", "html_url": "https://github.com/rust-lang/rust/commit/d1985c9dd06379b8a173239e90007db926ec052e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1985c9dd06379b8a173239e90007db926ec052e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e017ab4e0d59c82109604fa1917abd66b72e0e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e017ab4e0d59c82109604fa1917abd66b72e0e0", "html_url": "https://github.com/rust-lang/rust/commit/0e017ab4e0d59c82109604fa1917abd66b72e0e0"}], "stats": {"total": 185, "additions": 164, "deletions": 21}, "files": [{"sha": "6f3075717ed86cfe321a05c3128ee02e17118fdb", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -367,7 +367,18 @@ pub impl CheckLoanCtxt {\n             // are only assigned once\n         } else {\n             match cmt.mutbl {\n-                McDeclared | McInherited => { /*ok*/ }\n+                McDeclared | McInherited => {\n+                    // Ok, but if this loan is a mutable loan, then mark the\n+                    // loan path (if it exists) as being used. This is similar\n+                    // to the check performed in loan.rs in issue_loan(). This\n+                    // type of use of mutable is different from issuing a loan,\n+                    // however.\n+                    for cmt.lp.each |lp| {\n+                        for lp.node_id().each |&id| {\n+                            self.tcx().used_mut_nodes.insert(id);\n+                        }\n+                    }\n+                }\n                 McReadOnly | McImmutable => {\n                     self.bccx.span_err(\n                         ex.span,"}, {"sha": "3c37b5dae64a299ef9bf442984d10b8a32927aff", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -51,7 +51,7 @@ use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n use middle::mem_categorization::{cat_special, cat_stack_upvar, cmt};\n use middle::mem_categorization::{comp_field, comp_index, comp_variant};\n-use middle::mem_categorization::{gc_ptr, region_ptr};\n+use middle::mem_categorization::{gc_ptr, region_ptr, lp_local, lp_arg};\n use middle::ty;\n use util::common::indenter;\n \n@@ -274,7 +274,17 @@ pub impl LoanContext {\n         if !owns_lent_data ||\n             self.bccx.is_subregion_of(self.scope_region, scope_ub)\n         {\n-            if loan_kind.is_take() && !cmt.mutbl.is_mutable() {\n+            if cmt.mutbl.is_mutable() {\n+                // If this loan is a mutable loan, then mark the loan path (if\n+                // it exists) as being used. This is similar to the check\n+                // performed in check_loans.rs in check_assignment(), but this\n+                // is for a different purpose of having the 'mut' qualifier.\n+                for cmt.lp.each |lp| {\n+                    for lp.node_id().each |&id| {\n+                        self.tcx().used_mut_nodes.insert(id);\n+                    }\n+                }\n+            } else if loan_kind.is_take() {\n                 // We do not allow non-mutable data to be \"taken\"\n                 // under any circumstances.\n                 return Err(bckerr {"}, {"sha": "bda97f4f530d1f65df6e5ddf9693a3c1f4ce955a", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use driver::session::Session;\n use driver::session;\n use middle::ty;\n+use middle::pat_util;\n use util::ppaux::{ty_to_str};\n \n use core::hashmap::HashMap;\n@@ -86,6 +87,7 @@ pub enum lint {\n \n     unused_variable,\n     dead_assignment,\n+    unused_mut,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -277,6 +279,13 @@ pub fn get_lint_dict() -> LintDict {\n             desc: \"detect assignments that will never be read\",\n             default: warn\n         }),\n+\n+        (~\"unused_mut\",\n+         LintSpec {\n+            lint: unused_mut,\n+            desc: \"detect mut variables which don't need to be mutable\",\n+            default: warn\n+        }),\n     ];\n     let mut map = HashMap::new();\n     do vec::consume(v) |_, (k, v)| {\n@@ -499,6 +508,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_deprecated_mutable_fields(cx, i);\n     check_item_deprecated_drop(cx, i);\n     check_item_unused_unsafe(cx, i);\n+    check_item_unused_mut(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -954,6 +964,53 @@ fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n+fn check_item_unused_mut(tcx: ty::ctxt, it: @ast::item) {\n+    let check_pat: @fn(@ast::pat) = |p| {\n+        let mut used = false;\n+        let mut bindings = 0;\n+        do pat_util::pat_bindings(tcx.def_map, p) |_, id, _, _| {\n+            used = used || tcx.used_mut_nodes.contains(&id);\n+            bindings += 1;\n+        }\n+        if !used {\n+            let msg = if bindings == 1 {\n+                ~\"variable does not need to be mutable\"\n+            } else {\n+                ~\"variables do not need to be mutable\"\n+            };\n+            tcx.sess.span_lint(unused_mut, p.id, it.id, p.span, msg);\n+        }\n+    };\n+\n+    let visit_fn_decl: @fn(&ast::fn_decl) = |fd| {\n+        for fd.inputs.each |arg| {\n+            if arg.is_mutbl {\n+                check_pat(arg.pat);\n+            }\n+        }\n+    };\n+\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_local: |l| {\n+                if l.node.is_mutbl {\n+                    check_pat(l.node.pat);\n+                }\n+            },\n+            visit_fn: |_, fd, _, _, _| visit_fn_decl(fd),\n+            visit_ty_method: |tm| visit_fn_decl(&tm.decl),\n+            visit_struct_method: |sm| visit_fn_decl(&sm.decl),\n+            visit_trait_method: |tm| {\n+                match *tm {\n+                    ast::required(ref tm) => visit_fn_decl(&tm.decl),\n+                    ast::provided(m) => visit_fn_decl(&m.decl),\n+                }\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n+    visit::visit_item(it, (), visit);\n+}\n+\n fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n             _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);"}, {"sha": "2b36ce4ce031a7841a08521f26ed229494ca2864", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -1516,9 +1516,8 @@ fn check_local(local: @local, self: @Liveness, vt: vt<@Liveness>) {\n \n         // Initializer:\n         self.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n-        if !local.node.is_mutbl {\n-            self.check_for_reassignments_in_pat(local.node.pat);\n-        }\n+        self.check_for_reassignments_in_pat(local.node.pat,\n+                                            local.node.is_mutbl);\n       }\n       None => {\n \n@@ -1702,12 +1701,15 @@ pub impl Liveness {\n         match expr.node {\n           expr_path(_) => {\n             match *self.tcx.def_map.get(&expr.id) {\n-              def_local(nid, false) => {\n-                // Assignment to an immutable variable or argument:\n-                // only legal if there is no later assignment.\n+              def_local(nid, mutbl) => {\n+                // Assignment to an immutable variable or argument: only legal\n+                // if there is no later assignment. If this local is actually\n+                // mutable, then check for a reassignment to flag the mutability\n+                // as being used.\n                 let ln = self.live_node(expr.id, expr.span);\n                 let var = self.variable(nid, expr.span);\n-                self.check_for_reassignment(ln, var, expr.span);\n+                self.check_for_reassignment(ln, var, expr.span,\n+                                            if mutbl {Some(nid)} else {None});\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n@@ -1731,23 +1733,28 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(@self, pat: @pat) {\n-        do self.pat_bindings(pat) |ln, var, sp, _id| {\n-            self.check_for_reassignment(ln, var, sp);\n+    fn check_for_reassignments_in_pat(@self, pat: @pat, mutbl: bool) {\n+        do self.pat_bindings(pat) |ln, var, sp, id| {\n+            self.check_for_reassignment(ln, var, sp,\n+                                        if mutbl {Some(id)} else {None});\n         }\n     }\n \n     fn check_for_reassignment(@self, ln: LiveNode, var: Variable,\n-                              orig_span: span) {\n+                              orig_span: span, mutbl: Option<node_id>) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n-            self.tcx.sess.span_err(\n-                span,\n-                ~\"re-assignment of immutable variable\");\n-\n-            self.tcx.sess.span_note(\n-                orig_span,\n-                ~\"prior assignment occurs here\");\n+            match mutbl {\n+              Some(id) => { self.tcx.used_mut_nodes.insert(id); }\n+              None => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    ~\"re-assignment of immutable variable\");\n+                self.tcx.sess.span_note(\n+                    orig_span,\n+                    ~\"prior assignment occurs here\");\n+              }\n+            }\n           }\n           Some(lnk) => {\n             self.tcx.sess.span_bug("}, {"sha": "51e6860432a2e40a6568f5dc575c62bf95ee4a2b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -351,6 +351,16 @@ pub impl MutabilityCategory {\n     }\n }\n \n+pub impl loan_path {\n+    fn node_id(&self) -> Option<ast::node_id> {\n+        match *self {\n+            lp_local(id) | lp_arg(id) => Some(id),\n+            lp_deref(lp, _) | lp_comp(lp, _) => lp.node_id(),\n+            lp_self => None\n+        }\n+    }\n+}\n+\n pub impl mem_categorization_ctxt {\n     fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {"}, {"sha": "be362904dc42d3e30f38728b77008efc517e4df5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -304,6 +304,11 @@ struct ctxt_ {\n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n     used_unsafe: @mut HashSet<ast::node_id>,\n+\n+    // Set of nodes which mark locals as mutable which end up getting used at\n+    // some point. Local variable definitions not in this set can be warned\n+    // about.\n+    used_mut_nodes: @mut HashSet<ast::node_id>,\n }\n \n pub enum tbox_flag {\n@@ -933,6 +938,7 @@ pub fn mk_ctxt(s: session::Session,\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n+        used_mut_nodes: @mut HashSet::new(),\n      }\n }\n "}, {"sha": "d1223cd889307ca4aeb5d45badf7ac5facf968ba", "filename": "src/test/compile-fail/unused-mut-variables.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d1985c9dd06379b8a173239e90007db926ec052e/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1985c9dd06379b8a173239e90007db926ec052e/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-mut-variables.rs?ref=d1985c9dd06379b8a173239e90007db926ec052e", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Exercise the unused_mut attribute in some positive and negative cases\n+\n+#[allow(dead_assignment)];\n+#[allow(unused_variable)];\n+#[deny(unused_mut)];\n+\n+fn main() {\n+    // negative cases\n+    let mut a = 3; //~ ERROR: variable does not need to be mutable\n+    let mut a = 2, b = 3; //~ ERROR: variable does not need to be mutable\n+                          //~^ ERROR: variable does not need to be mutable\n+    let mut a = ~[3]; //~ ERROR: variable does not need to be mutable\n+\n+    // positive cases\n+    let mut a = 2;\n+    a = 3;\n+    let mut a = ~[];\n+    a.push(3);\n+    let mut a = ~[];\n+    do callback {\n+        a.push(3);\n+    }\n+}\n+\n+fn callback(f: &fn()) {}\n+\n+// make sure the lint attribute can be turned off\n+#[allow(unused_mut)]\n+fn foo(mut a: int) {\n+    let mut a = 3;\n+    let mut b = ~[2];\n+}"}]}