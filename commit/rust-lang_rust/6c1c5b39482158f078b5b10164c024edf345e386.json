{"sha": "6c1c5b39482158f078b5b10164c024edf345e386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMWM1YjM5NDgyMTU4ZjA3OGI1YjEwMTY0YzAyNGVkZjM0NWUzODY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-11T02:52:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-14T00:35:13Z"}, "message": "More progress on anonymous objects.\n\nStill segfaulting on the method-overriding.rs test, though.", "tree": {"sha": "7c179784c98b97df43ff2329c96940452934f7b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c179784c98b97df43ff2329c96940452934f7b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c1c5b39482158f078b5b10164c024edf345e386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1c5b39482158f078b5b10164c024edf345e386", "html_url": "https://github.com/rust-lang/rust/commit/6c1c5b39482158f078b5b10164c024edf345e386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c1c5b39482158f078b5b10164c024edf345e386/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a53e39e710d4a31785015d042cc491692954ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a53e39e710d4a31785015d042cc491692954ab7", "html_url": "https://github.com/rust-lang/rust/commit/6a53e39e710d4a31785015d042cc491692954ab7"}], "stats": {"total": 114, "additions": 100, "deletions": 14}, "files": [{"sha": "267c752ee1feed3e62e382738d7777d02de3f061", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6c1c5b39482158f078b5b10164c024edf345e386", "patch": "@@ -807,24 +807,24 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n \n         // Only make people type () if they're actually adding new fields\n         let option.t[vec[ast.obj_field]] fields = none[vec[ast.obj_field]];\n-        if (p.peek() == token.LPAREN) {\n+        if (p.peek() == token::LPAREN) {\n             auto pf = parse_obj_field;\n             hi = p.get_hi_pos();\n-            expect(p, token.LPAREN);\n+            expect(p, token::LPAREN);\n             fields = some[vec[ast.obj_field]]\n                 (parse_seq_to_end[ast.obj_field] \n-                 (token.RPAREN,\n-                  some(token.COMMA),\n+                 (token::RPAREN,\n+                  some(token::COMMA),\n                   pf, hi, p));\n         }\n \n         let vec[@ast.method] meths = vec();\n         let option.t[ast.ident] with_obj = none[ast.ident];\n \n-        expect(p, token.LBRACE);\n-        while (p.peek() != token.RBRACE) {\n+        expect(p, token::LBRACE);\n+        while (p.peek() != token::RBRACE) {\n             alt (p.peek()) {\n-                case (token.WITH) { \n+                case (token::WITH) { \n                     with_obj = some[ast.ident](parse_ident(p));\n                 }\n                 case (_) {\n@@ -833,7 +833,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n             }\n         }\n         hi = p.get_hi_pos();\n-        expect(p, token.RBRACE);\n+        expect(p, token::RBRACE);\n \n         // fields and methods may be *additional* or *overriding* fields and\n         // methods if there's a with_obj, or they may be the *only* fields and\n@@ -848,6 +848,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n \n         ex = ast.expr_anon_obj(ob, ty_params, odid, ast.ann_none);\n+\n     } else if (eat_word(p, \"bind\")) {\n         auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(parser p) -> option::t[@ast::expr] {"}, {"sha": "7d0fa9946a0e863b59f0ce25284c8d5f4e94b236", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=6c1c5b39482158f078b5b10164c024edf345e386", "patch": "@@ -209,6 +209,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp,\n          &@expr e, &ann a) -> @expr)              fold_expr_chan,\n \n+     (fn(&ENV e, &span sp,\n+         &ast.anon_obj ob, // TODO: Is the ob arg supposed to be & or not?\n+         vec[ast.ty_param] tps,\n+         ast.obj_def_ids odid, ann a) -> @expr)   fold_expr_anon_obj,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n@@ -322,6 +326,11 @@ type ast_fold[ENV] =\n          &option::t[@ast::method] dtor)\n       -> ast::_obj)                                fold_obj,\n \n+     (fn(&ENV e,\n+         Option.t[vec[ast.obj_field]] fields,\n+         vec[@ast.method] methods,\n+         Option.t[ident] with_obj) -> ast.anon_obj) fold_anon_obj,\n+\n      // Env updates.\n      (fn(&ENV e, &@ast::crate c) -> ENV) update_env_for_crate,\n      (fn(&ENV e, &@item i) -> ENV) update_env_for_item,\n@@ -828,6 +837,12 @@ fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n             auto t2 = fld.fold_ann(env_, t);\n             ret fld.fold_expr_chan(env_, e.span, ee, t2);\n         }\n+\n+        case (ast.expr_anon_obj(?ob, ?tps, ?odid, ?t)) {\n+            auto ee = fold_anon_obj(env_, fld, ob);\n+            auto t2 = fld.fold_ann(env_, t);\n+            ret fld.fold_expr_anon_obj(env_, e.span, ee, tps, odid, t2);\n+        }\n     }\n \n     fail;\n@@ -930,7 +945,6 @@ fn fold_method[ENV](&ENV env, &ast_fold[ENV] fld,\n     ret @rec(node=rec(meth=meth with m.node) with *m);\n }\n \n-\n fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n \n     let vec[ast::obj_field] fields = vec();\n@@ -962,6 +976,49 @@ fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n \n+fn fold_anon_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast.anon_obj ob) \n+    -> ast.anon_obj {\n+\n+    // Fields\n+    let Option.t[vec[ast.obj_field]] fields = none[vec[ast.obj_field]];\n+    alt (ob.fields) {\n+        case (none[vec[ast.obj_field]]) { }\n+        case (some[vec[ast.obj_field]](?v)) {\n+            let vec[ast.obj_field] fields = vec();\n+            for (ast.obj_field f in v) {\n+                fields += vec(fold_obj_field(env, fld, f));\n+            }\n+        }\n+    }\n+\n+    // with_obj\n+    let Option.t[ast.ident] with_obj = none[ast.ident];\n+    alt (ob.with_obj) {\n+        case (none[ast.ident]) { }\n+        case (some[ast.ident](?i)) {\n+            with_obj = some[ast.ident](i);\n+        }\n+    }\n+\n+    // Methods\n+    let vec[@ast.method] meths = vec();\n+    let vec[ast.ty_param] tp = vec();\n+    for (@ast.method m in ob.methods) {\n+        // Fake-up an ast.item for this method.\n+        // FIXME: this is kinda awful. Maybe we should reformulate\n+        // the way we store methods in the AST?\n+        let @ast.item i = @rec(node=ast.item_fn(m.node.ident,\n+                                                m.node.meth,\n+                                                tp,\n+                                                m.node.id,\n+                                                m.node.ann),\n+                               span=m.span);\n+        let ENV _env = fld.update_env_for_item(env, i);\n+        Vec.push[@ast.method](meths, fold_method(_env, fld, m));\n+    }\n+    ret fld.fold_anon_obj(env, fields, meths, with_obj);\n+}\n+\n fn fold_view_item[ENV](&ENV env, &ast_fold[ENV] fld, &@view_item vi)\n     -> @view_item {\n \n@@ -1410,6 +1467,12 @@ fn identity_fold_expr_chan[ENV](&ENV e, &span sp, &@expr x,\n     ret @respan(sp, ast::expr_chan(x, a));\n }\n \n+fn identity_fold_expr_anon_obj[ENV](&ENV e, &span sp,\n+                                    &ast.anon_obj ob, vec[ast.ty_param] tps,\n+                                    ast.obj_def_ids odid, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_anon_obj(ob, tps, odid, a));\n+}\n+\n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n@@ -1584,6 +1647,12 @@ fn identity_fold_obj[ENV](&ENV e,\n     ret rec(fields=fields, methods=methods, dtor=dtor);\n }\n \n+fn identity_fold_anon_obj[ENV](&ENV e,\n+                               Option.t[vec[ast.obj_field]] fields,\n+                               vec[@ast.method] methods,\n+                               Option.t[ident] with_obj) -> ast.anon_obj {\n+    ret rec(fields=fields, methods=methods, with_obj=with_obj);\n+}\n \n // Env update identities.\n \n@@ -1707,6 +1776,9 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n          fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n \n+         fold_expr_anon_obj   \n+                        = bind identity_fold_expr_anon_obj[ENV](_,_,_,_,_,_),\n+\n          fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n          fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),\n \n@@ -1746,6 +1818,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_,_),\n          fold_obj = bind identity_fold_obj[ENV](_,_,_,_),\n+         fold_anon_obj = bind identity_fold_anon_obj[ENV](_,_,_,_),\n \n          update_env_for_crate = bind identity_update_env_for_crate[ENV](_,_),\n          update_env_for_item = bind identity_update_env_for_item[ENV](_,_),"}, {"sha": "fa50d857ae9088353b5ab391b7af43915ff094c6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6c1c5b39482158f078b5b10164c024edf345e386", "patch": "@@ -2885,10 +2885,14 @@ fn iter_sequence(@block_ctxt cx,\n             auto et = ty::mk_mach(cx.fcx.lcx.ccx.tcx, common::ty_u8);\n             ret iter_sequence_body(cx, v, et, f, true);\n         }\n-        case (_) { fail; }\n+        case (_) {\n+\n+            cx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n+                                    \"trans::iter_sequence: \" +\n+                                    ty.ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+            fail; \n+        }\n     }\n-    cx.fcx.lcx.ccx.sess.bug(\"bad type in trans::iter_sequence\");\n-    fail;\n }\n \n fn lazily_emit_all_tydesc_glue(&@block_ctxt cx,"}, {"sha": "fcde5e2cb890747506e4592428845b3fd73b246b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1c5b39482158f078b5b10164c024edf345e386/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6c1c5b39482158f078b5b10164c024edf345e386", "patch": "@@ -1659,6 +1659,7 @@ fn pat_ty(&ctxt cx, &node_type_table ntt, &@ast::pat pat) -> t {\n     fail;   // not reached\n }\n \n+<<<<<<< HEAD\n fn expr_ann(&@ast::expr e) -> ast::ann {\n     alt (e.node) {\n         case (ast::expr_vec(_,_,?a)) { ret a; }\n@@ -1694,6 +1695,7 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n         case (ast::expr_check(_,?a)) { ret a; }\n         case (ast::expr_port(?a)) { ret a; }\n         case (ast::expr_chan(_,?a)) { ret a; }\n+        case (ast::expr_anon_obj(_,_,_,?a)) { ret a; }\n         case (ast::expr_break(?a)) { ret a; }\n         case (ast::expr_cont(?a)) { ret a; }\n         case (ast::expr_self_method(_, ?a)) { ret a; }"}, {"sha": "3fbb53ff6cfd7defc6f58ca0f727a51d6170aa1e", "filename": "src/test/run-pass/method-overriding.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c1c5b39482158f078b5b10164c024edf345e386/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1c5b39482158f078b5b10164c024edf345e386/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-overriding.rs?ref=6c1c5b39482158f078b5b10164c024edf345e386", "patch": "@@ -1,7 +1,7 @@\n // xfail-boot\n // xfail-stage0\n use std;\n-import std._vec.len;\n+\n fn main() {\n \n     obj a() {\n@@ -15,12 +15,18 @@ fn main() {\n \n     auto my_a = a();\n \n-    // Step 1 is to add support for this \"with\" syntax\n+    // Extending an object with a new method\n     auto my_b = obj { \n         fn baz() -> int { \n             ret self.foo(); \n         } \n         with my_a \n     };\n+\n+    // Extending an object with a new field\n+    auto my_c = obj(quux) { with my_a } ;\n+\n+    // Should this be legal?\n+    auto my_d = obj() { with my_a } ;\n     \n }"}]}