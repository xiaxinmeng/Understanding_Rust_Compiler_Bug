{"sha": "525ab4a4139f32732f222d39f5cc00ad08951910", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNWFiNGE0MTM5ZjMyNzMyZjIyMmQzOWY1Y2MwMGFkMDg5NTE5MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-23T21:35:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-23T21:35:59Z"}, "message": "Auto merge of #29065 - steveklabnik:doc_iter_traits, r=alexcrichton\n\nThis adds a bunch of documentation for most of the traits in std::iter", "tree": {"sha": "078bb555179c25601b17917485b5812c92917a03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/078bb555179c25601b17917485b5812c92917a03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/525ab4a4139f32732f222d39f5cc00ad08951910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/525ab4a4139f32732f222d39f5cc00ad08951910", "html_url": "https://github.com/rust-lang/rust/commit/525ab4a4139f32732f222d39f5cc00ad08951910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/525ab4a4139f32732f222d39f5cc00ad08951910/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "html_url": "https://github.com/rust-lang/rust/commit/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12"}, {"sha": "608cb84955e52c71c7ed8806f9783674a45c1cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/608cb84955e52c71c7ed8806f9783674a45c1cd7", "html_url": "https://github.com/rust-lang/rust/commit/608cb84955e52c71c7ed8806f9783674a45c1cd7"}], "stats": {"total": 340, "additions": 315, "deletions": 25}, "files": [{"sha": "7c113fde658b859316fe008c9f1d30d3aa07ee21", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 315, "deletions": 25, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/525ab4a4139f32732f222d39f5cc00ad08951910/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/525ab4a4139f32732f222d39f5cc00ad08951910/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=525ab4a4139f32732f222d39f5cc00ad08951910", "patch": "@@ -92,7 +92,7 @@\n //!\n //! /// An iterator which counts from one to five\n //! struct Counter {\n-//!     count: i32,\n+//!     count: usize,\n //! }\n //!\n //! // we want our count to start at one, so let's add a new() method to help.\n@@ -107,11 +107,11 @@\n //! // Then, we implement `Iterator` for our `Counter`:\n //!\n //! impl Iterator for Counter {\n-//!     // we will be counting with i32\n-//!     type Item = i32;\n+//!     // we will be counting with usize\n+//!     type Item = usize;\n //!\n //!     // next() is the only required method\n-//!     fn next(&mut self) -> Option<i32> {\n+//!     fn next(&mut self) -> Option<usize> {\n //!         // increment our count. This is why we started at zero.\n //!         self.count += 1;\n //!\n@@ -1486,7 +1486,7 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n     fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n }\n \n-/// Conversion from an `Iterator`\n+/// Conversion from an `Iterator`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n@@ -1518,21 +1518,90 @@ pub trait FromIterator<A> {\n     fn from_iter<T: IntoIterator<Item=A>>(iterator: T) -> Self;\n }\n \n-/// Conversion into an `Iterator`\n+/// Conversion into an `Iterator`.\n ///\n-/// Implementing this trait allows you to use your type with Rust's `for` loop. See\n-/// the [module level documentation](index.html) for more details.\n+/// By implementing `IntoIterator` for a type, you define how it will be\n+/// converted to an iterator. This is common for types which describe a\n+/// collection of some kind.\n+///\n+/// One benefit of implementing `IntoIterator` is that your type will [work\n+/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n+///\n+/// # Examples\n+///\n+/// Vectors implement `IntoIterator`:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// let mut iter = v.into_iter();\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(1), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(2), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(3), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(None, n);\n+/// ```\n+///\n+/// Implementing `IntoIterator` for your type:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // and we'll implement IntoIterator\n+/// impl IntoIterator for MyCollection {\n+///     type Item = i32;\n+///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///\n+///     fn into_iter(self) -> Self::IntoIter {\n+///         self.0.into_iter()\n+///     }\n+/// }\n+///\n+/// // Now we can make a new collection...\n+/// let mut c = MyCollection::new();\n+///\n+/// // ... add some stuff to it ...\n+/// c.add(0);\n+/// c.add(1);\n+/// c.add(2);\n+///\n+/// // ... and then turn it into an Iterator:\n+/// for (i, n) in c.into_iter().enumerate() {\n+///     assert_eq!(i as i32, n);\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n-    /// The type of the elements being iterated\n+    /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n-    /// A container for iterating over elements of type `Item`\n+    /// Which kind of iterator are we turning this into?\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type IntoIter: Iterator<Item=Self::Item>;\n \n-    /// Consumes `Self` and returns an iterator over it\n+    /// Consumes `Self` and returns an iterator over it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_iter(self) -> Self::IntoIter;\n }\n@@ -1547,23 +1616,164 @@ impl<I: Iterator> IntoIterator for I {\n     }\n }\n \n-/// A type growable from an `Iterator` implementation\n+/// Extend a collection with the contents of an iterator.\n+///\n+/// Iterators produce a series of values, and collections can also be thought\n+/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n+/// to extend a collection by including the contents of that iterator.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // You can extend a String with some chars:\n+/// let mut message = String::from(\"The first three letters are: \");\n+///\n+/// message.extend(&['a', 'b', 'c']);\n+///\n+/// assert_eq!(\"abc\", &message[29..32]);\n+/// ```\n+///\n+/// Implementing `Extend`:\n+///\n+/// ```\n+/// // A sample collection, that's just a wrapper over Vec<T>\n+/// #[derive(Debug)]\n+/// struct MyCollection(Vec<i32>);\n+///\n+/// // Let's give it some methods so we can create one and add things\n+/// // to it.\n+/// impl MyCollection {\n+///     fn new() -> MyCollection {\n+///         MyCollection(Vec::new())\n+///     }\n+///\n+///     fn add(&mut self, elem: i32) {\n+///         self.0.push(elem);\n+///     }\n+/// }\n+///\n+/// // since MyCollection has a list of i32s, we implement Extend for i32\n+/// impl Extend<i32> for MyCollection {\n+///\n+///     // This is a bit simpler with the concrete type signature: we can call\n+///     // extend on anything which can be turned into an Iterator which gives\n+///     // us i32s. Because we need i32s to put into MyCollection.\n+///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iterable: T) {\n+///\n+///         // The implementation is very straightforward: loop through the\n+///         // iterator, and add() each element to ourselves.\n+///         for elem in iterable {\n+///             self.add(elem);\n+///         }\n+///     }\n+/// }\n+///\n+/// let mut c = MyCollection::new();\n+///\n+/// c.add(5);\n+/// c.add(6);\n+/// c.add(7);\n+///\n+/// // let's extend our collection with three more numbers\n+/// c.extend(vec![1, 2, 3]);\n+///\n+/// // we've added these elements onto the end\n+/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n-    /// Extends a container with the elements yielded by an arbitrary iterator\n+    /// Extends a collection with the contents of an iterator.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.Extend.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // You can extend a String with some chars:\n+    /// let mut message = String::from(\"The first three letters are: \");\n+    ///\n+    /// message.extend(['a', 'b', 'c'].iter());\n+    ///\n+    /// assert_eq!(\"abc\", &message[29..32]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);\n }\n \n-/// A range iterator able to yield elements from both ends\n+/// An iterator able to yield elements from both ends.\n+///\n+/// Something that implements `DoubleEndedIterator` has one extra capability\n+/// over something that implements [`Iterator`]: the ability to also take\n+/// `Item`s from the back, as well as the front.\n ///\n-/// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and\n-/// `next_back()` exhaust elements from the *same* range, and do not work\n-/// independently of each other.\n+/// It is important to note that both back and forth work on the same range,\n+/// and do not cross: iteration is over when they meet in the middle.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let numbers = vec![1, 2, 3];\n+///\n+/// let mut iter = numbers.iter();\n+///\n+/// let n = iter.next();\n+/// assert_eq!(Some(&1), n);\n+///\n+/// let n = iter.next_back();\n+/// assert_eq!(Some(&3), n);\n+///\n+/// let n = iter.next_back();\n+/// assert_eq!(Some(&2), n);\n+///\n+/// let n = iter.next();\n+/// assert_eq!(None, n);\n+///\n+/// let n = iter.next_back();\n+/// assert_eq!(None, n);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// Yields an element from the end of the range, returning `None` if the\n-    /// range is empty.\n+    /// An iterator able to yield elements from both ends.\n+    ///\n+    /// As this is the only method for this trait, the [trait-level] docs\n+    /// contain more details.\n+    ///\n+    /// [trait-level]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let numbers = vec![1, 2, 3];\n+    ///\n+    /// let mut iter = numbers.iter();\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(Some(&1), n);\n+    ///\n+    /// let n = iter.next_back();\n+    /// assert_eq!(Some(&3), n);\n+    ///\n+    /// let n = iter.next_back();\n+    /// assert_eq!(Some(&2), n);\n+    ///\n+    /// let n = iter.next();\n+    /// assert_eq!(None, n);\n+    ///\n+    /// let n = iter.next_back();\n+    /// assert_eq!(None, n);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n@@ -1573,18 +1783,98 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n     fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n }\n \n-/// An iterator that knows its exact length\n+/// An iterator that knows its exact length.\n+///\n+/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n+/// If an iterator knows how many times it can iterate, providing access to\n+/// that information can be useful. For example, if you want to iterate\n+/// backwards, a good start is to know where the end is.\n ///\n-/// This trait is a helper for iterators like the vector iterator, so that\n-/// it can support double-ended enumeration.\n+/// When implementing an `ExactSizeIterator`, You must also implement\n+/// [`Iterator`]. When doing so, the implementation of [`size_hint()`] *must*\n+/// return the exact size of the iterator.\n ///\n-/// `Iterator::size_hint` *must* return the exact size of the iterator.\n-/// Note that the size must fit in `usize`.\n+/// [`Iterator`]: trait.Iterator.html\n+/// [`size_hint()`]: trait.Iterator.html#method.size_hint\n+///\n+/// The [`len()`] method has a default implementation, so you usually shouldn't\n+/// implement it. However, you may be able to provide a more performant\n+/// implementation than the default, so overriding it in this case makes sense.\n+///\n+/// [`len()`]: #method.len\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// // a finite range knows exactly how many times it will iterate\n+/// let five = (0..5);\n+///\n+/// assert_eq!(5, five.len());\n+/// ```\n+///\n+/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n+/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n+///\n+/// [moddocs]: index.html\n+///\n+/// ```\n+/// # struct Counter {\n+/// #     count: usize,\n+/// # }\n+/// # impl Counter {\n+/// #     fn new() -> Counter {\n+/// #         Counter { count: 0 }\n+/// #     }\n+/// # }\n+/// # impl Iterator for Counter {\n+/// #     type Item = usize;\n+/// #     fn next(&mut self) -> Option<usize> {\n+/// #         self.count += 1;\n+/// #         if self.count < 6 {\n+/// #             Some(self.count)\n+/// #         } else {\n+/// #             None\n+/// #         }\n+/// #     }\n+/// # }\n+/// impl ExactSizeIterator for Counter {\n+///     // We already have the number of iterations, so we can use it directly.\n+///     fn len(&self) -> usize {\n+///         self.count\n+///     }\n+/// }\n+///\n+/// // And now we can use it!\n+///\n+/// let counter = Counter::new();\n+///\n+/// assert_eq!(0, counter.len());\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    /// Returns the exact length of the iterator.\n+    /// Returns the exact number of times the iterator will iterate.\n+    ///\n+    /// This method has a default implementation, so you usually should not\n+    /// implement it directly. However, if you can provide a more efficient\n+    /// implementation, you can do so. See the [trait-level] docs for an\n+    /// example.\n+    ///\n+    /// [trait-level]: trait.ExactSizeIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // a finite range knows exactly how many times it will iterate\n+    /// let five = (0..5);\n+    ///\n+    /// assert_eq!(5, five.len());\n+    /// ```\n     fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();\n         // Note: This assertion is overly defensive, but it checks the invariant"}]}