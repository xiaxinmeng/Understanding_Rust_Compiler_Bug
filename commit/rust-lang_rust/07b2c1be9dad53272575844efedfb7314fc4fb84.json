{"sha": "07b2c1be9dad53272575844efedfb7314fc4fb84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YjJjMWJlOWRhZDUzMjcyNTc1ODQ0ZWZlZGZiNzMxNGZjNGZiODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T03:07:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-02T03:07:17Z"}, "message": "auto merge of #17620 : nick29581/rust/slice4, r=aturon\n\ncc @aturon \r\n\r\nr? anyone?", "tree": {"sha": "d26dab000c4444cf6e972bb30da0392e675ca52b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d26dab000c4444cf6e972bb30da0392e675ca52b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07b2c1be9dad53272575844efedfb7314fc4fb84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07b2c1be9dad53272575844efedfb7314fc4fb84", "html_url": "https://github.com/rust-lang/rust/commit/07b2c1be9dad53272575844efedfb7314fc4fb84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07b2c1be9dad53272575844efedfb7314fc4fb84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "url": "https://api.github.com/repos/rust-lang/rust/commits/d53874eccf0657d5d9c0a9ed9f84380d27d1c423", "html_url": "https://github.com/rust-lang/rust/commit/d53874eccf0657d5d9c0a9ed9f84380d27d1c423"}, {"sha": "6e0611a48707a1f5d90aee32a02b2b15957ef25b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e0611a48707a1f5d90aee32a02b2b15957ef25b", "html_url": "https://github.com/rust-lang/rust/commit/6e0611a48707a1f5d90aee32a02b2b15957ef25b"}], "stats": {"total": 1172, "additions": 677, "deletions": 495}, "files": [{"sha": "1e5e3ebdb3410e531a5e3fe951dfe2752c76447c", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(phase)]\n+#![feature(phase, slicing_syntax)]\n \n #![deny(warnings)]\n "}, {"sha": "2182bc895163005c9e8a4eec27ebb2e7352dea93", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -874,7 +874,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n+        props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "c3b61f6435c493b4f7de4dea15b5f64b8f78d8a0", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -3828,7 +3828,7 @@ type signature of `print`, and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of\n its type parameters are types:\n \n-```\n+```ignore\n fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     if xs.len() == 0 {\n        return vec![];"}, {"sha": "9f26c0980131f447ce66ef28cf467551c290e3d1", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -194,7 +194,7 @@ impl Bitv {\n         if start > self.storage.len() {\n             start = self.storage.len();\n         }\n-        let mut iter = self.storage.slice_from(start).iter();\n+        let mut iter = self.storage[start..].iter();\n         MaskWords {\n           next_word: iter.next(),\n           iter: iter,"}, {"sha": "4d0aaf8390707bfd847ed7d1431da1b6c4be961c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -19,8 +19,9 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n+#![allow(unknown_features)]\n #![feature(macro_rules, managed_boxes, default_type_params, phase, globs)]\n-#![feature(unsafe_destructor, import_shadowing)]\n+#![feature(unsafe_destructor, import_shadowing, slicing_syntax)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;"}, {"sha": "0e1c39535bed45e096665300c0c1409ceeb500d4", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -271,7 +271,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>().as_slice(), b);\n+    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -291,7 +291,7 @@ impl<T> RingBuf<T> {\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts.slice_mut(start_index, end_index);\n+            let remaining1 = elts[mut start_index..end_index];\n             MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }"}, {"sha": "253375aabe8a4c78f4b7ce90d33c165e9266f504", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -44,15 +44,20 @@\n //!\n //! A number of traits add methods that allow you to accomplish tasks with slices.\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! and `MutableSlice`, defined for `&mut [T]` types.\n+//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n+//! which are defined for `[T]`.\n //!\n-//! An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n-//! a `Vec` or another slice from the index interval `[a, b)`:\n+//! An example is the `slice` method which enables slicing syntax `[a..b]` that\n+//! returns an immutable \"view\" into a `Vec` or another slice from the index\n+//! interval `[a, b)`:\n //!\n //! ```rust\n-//! let numbers = [0i, 1i, 2i];\n-//! let last_numbers = numbers.slice(1, 3);\n-//! // last_numbers is now &[1i, 2i]\n+//! #![feature(slicing_syntax)]\n+//! fn main() {\n+//!     let numbers = [0i, 1i, 2i];\n+//!     let last_numbers = numbers[1..3];\n+//!     // last_numbers is now &[1i, 2i]\n+//! }\n //! ```\n //!\n //! ## Implementations of other traits\n@@ -610,7 +615,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -702,7 +707,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[mut i..].reverse();\n \n         true\n     }\n@@ -723,7 +728,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[mut i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -990,24 +995,24 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1i, 2, 3, 4];\n-        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_vec();\n+        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack = &[1i, 2, 3];\n-        let v_b = vec_stack.slice(1u, 3u).to_vec();\n+        let vec_stack: &[_] = &[1i, 2, 3];\n+        let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique.slice(1u, 6u).to_vec();\n+        let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1020,21 +1025,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.slice_from(0), vec);\n+        assert_eq!(vec[0..], vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec.slice_from(2), b);\n+        assert_eq!(vec[2..], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.slice_from(4), b);\n+        assert_eq!(vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.slice_to(4), vec);\n+        assert_eq!(vec[..4], vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec.slice_to(2), b);\n+        assert_eq!(vec[..2], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.slice_to(0), b);\n+        assert_eq!(vec[..0], b);\n     }\n \n \n@@ -1975,7 +1980,7 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a.slice_mut(2,4).move_from(b,1,6), 2);\n+        assert_eq!(a[mut 2..4].move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n@@ -1995,7 +2000,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values.slice_mut(1, 4).reverse();\n+        values[mut 1..4].reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -2042,9 +2047,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values.slice_mut(0,5).set_memory(0xAB);\n+        values[mut 0..5].set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values.slice_mut(2,4).set_memory(0xFF);\n+        values[mut 2..4].set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n@@ -2070,12 +2075,18 @@ mod tests {\n         let mut values = [1u8,2,3,4,5];\n         {\n             let (left, right) = values.split_at_mut(2);\n-            assert!(left.slice(0, left.len()) == [1, 2]);\n+            {\n+                let left: &[_] = left;\n+                assert!(left[0..left.len()] == [1, 2]);\n+            }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n+            {\n+                let right: &[_] = right;\n+                assert!(right[0..right.len()] == [3, 4, 5]);\n+            }\n             for p in right.iter_mut() {\n                 *p += 2;\n             }\n@@ -2099,7 +2110,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v.slice(1, 3).iter() {\n+        for f in v[1..3].iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "11bda25fee5859cd375f009fe909776cc54d9286", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -1680,7 +1680,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -1692,7 +1692,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n+            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "1032a504330c60b6d772de40ac256a79bab7ff88", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -160,7 +160,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v.slice_to(i))\n+                res.as_mut_vec().push_all(v[..i])\n             };\n         }\n \n@@ -177,7 +177,7 @@ impl String {\n             macro_rules! error(() => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v.slice(subseqidx, i_));\n+                        res.as_mut_vec().push_all(v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -246,7 +246,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v.slice(subseqidx, total))\n+                res.as_mut_vec().push_all(v[subseqidx..total])\n             };\n         }\n         Owned(res.into_string())\n@@ -927,6 +927,7 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n+#[cfg(stage0)]\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -949,6 +950,34 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[inline]\n+fn str_to_slice<'a, U: Str>(this: &'a U) -> &'a str {\n+    this.as_slice()\n+}\n+#[cfg(not(stage0))]\n+impl ops::Slice<uint, str> for String {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        str_to_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n+        self[][*from..]\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n+        self[][..*to]\n+    }\n+\n+    #[inline]\n+    fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n+        self[][*from..*to]\n+    }\n+}\n+\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {"}, {"sha": "9bfc8e08d8d3cc3fa8241bb2a47538ca090d52bc", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -24,6 +24,7 @@ use core::fmt;\n use core::fmt::Show;\n use core::mem::zeroed;\n use core::mem;\n+use core::ops::{Slice,SliceMut};\n use core::uint;\n use core::iter;\n use std::hash::{Writer, Hash};\n@@ -378,7 +379,7 @@ macro_rules! bound {\n                         }\n                     };\n                     // push to the stack.\n-                    it.stack[it.length] = children.$slice_from(slice_idx).$iter();\n+                    it.stack[it.length] = children.$slice_from(&slice_idx).$iter();\n                     it.length += 1;\n                     if ret { return it }\n                 })\n@@ -388,6 +389,15 @@ macro_rules! bound {\n \n impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[cfg(stage0)]\n+    #[inline]\n+    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n+        bound!(Entries, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from_, iter = iter,\n+               mutability = )\n+    }\n+    #[cfg(not(stage0))]\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n@@ -430,6 +440,15 @@ impl<T> TrieMap<T> {\n         self.bound(key, true)\n     }\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n+    #[cfg(stage0)]\n+    #[inline]\n+    fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n+        bound!(MutEntries, self = self,\n+               key = key, is_upper = upper,\n+               slice_from = slice_from_mut_, iter = iter_mut,\n+               mutability = mut)\n+    }\n+    #[cfg(not(stage0))]\n     #[inline]\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,"}, {"sha": "9dc122cfc7dc279877f893ac05fc1924c35c78ae", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -24,6 +24,7 @@ use core::num;\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n+use core::slice::Slice as SliceSlice;\n use core::uint;\n \n use {Mutable, MutableSeq};\n@@ -438,7 +439,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other.slice_from(self.len());\n+        let slice = other[self.len()..];\n         self.push_all(slice);\n     }\n }\n@@ -460,6 +461,37 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n+// Annoying helper function because there are two Slice::as_slice functions in\n+// scope.\n+#[cfg(not(stage0))]\n+#[inline]\n+fn slice_to_slice<'a, T, U: Slice<T>>(this: &'a U) -> &'a [T] {\n+    this.as_slice()\n+}\n+\n+\n+#[cfg(not(stage0))]\n+impl<T> ops::Slice<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        slice_to_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice_from(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice_to(end)\n+    }\n+    #[inline]\n+    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        slice_to_slice(self).slice(start, end)\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -481,6 +513,28 @@ impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        self.as_mut_slice()\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_from_mut(start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_to_mut(end)\n+    }\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        self.as_mut_slice().slice_mut(start, end)\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -928,11 +982,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice(0, 2) == [1, 2]);\n+    /// assert!(vec[0..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self.as_slice().slice(start, end)\n+        self[start..end]\n     }\n \n     /// Returns a slice containing all but the first element of the vector.\n@@ -949,7 +1003,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self.as_slice().tail()\n+        self[].tail()\n     }\n \n     /// Returns all but the first `n' elements of a vector.\n@@ -968,7 +1022,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self.as_slice().slice_from(n)\n+        self[n..]\n     }\n \n     /// Returns a reference to the last element of a vector, or `None` if it is\n@@ -982,7 +1036,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self.as_slice().last()\n+        self[].last()\n     }\n \n     /// Deprecated: use `last_mut`.\n@@ -1176,10 +1230,10 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n+    #[deprecated = \"use slice_from\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self.slice_mut(start, end)\n+        self[mut start..end]\n     }\n \n     /// Returns a mutable slice of `self` between `start` and `end`.\n@@ -1193,18 +1247,18 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_mut(0, 2) == [1, 2]);\n+    /// assert!(vec[mut 0..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self.as_mut_slice().slice_mut(start, end)\n+        self[mut start..end]\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n     #[deprecated = \"use slice_from_mut\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self.slice_from_mut(start)\n+        self[mut start..]\n     }\n \n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n@@ -1217,17 +1271,17 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_from_mut(2) == [3, 4]);\n+    /// assert!(vec[mut 2..] == [3, 4]);\n     /// ```\n     #[inline]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_mut(start)\n+        self[mut start..]\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n     #[deprecated = \"use slice_to_mut\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self.slice_to_mut(end)\n+        self[mut ..end]\n     }\n \n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n@@ -1240,11 +1294,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_to_mut(2) == [1, 2]);\n+    /// assert!(vec[mut ..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_mut(end)\n+        self[mut ..end]\n     }\n \n     /// Deprecated: use `split_at_mut`.\n@@ -1289,7 +1343,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.as_mut_slice().split_at_mut(mid)\n+        self[mut].split_at_mut(mid)\n     }\n \n     /// Reverses the order of elements in a vector, in place.\n@@ -1303,7 +1357,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n-        self.as_mut_slice().reverse()\n+        self[mut].reverse()\n     }\n \n     /// Returns a slice of `self` from `start` to the end of the vec.\n@@ -1316,11 +1370,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.slice_from(1) == [2, 3]);\n+    /// assert!(vec[1..] == [2, 3]);\n     /// ```\n     #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self.as_slice().slice_from(start)\n+        self[start..]\n     }\n \n     /// Returns a slice of self from the start of the vec to `end`.\n@@ -1333,11 +1387,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.slice_to(2) == [1, 2]);\n+    /// assert!(vec[..2] == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self.as_slice().slice_to(end)\n+        self[..end]\n     }\n \n     /// Returns a slice containing all but the last element of the vector.\n@@ -1354,7 +1408,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+        self[0..self.len() - 1]\n     }\n \n \n@@ -2212,12 +2266,18 @@ mod tests {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n             let (left, right) = values.split_at_mut(2);\n-            assert!(left.slice(0, left.len()) == [1, 2]);\n+            {\n+                let left: &[_] = left;\n+                assert!(left[0..left.len()] == [1, 2]);\n+            }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n+            {\n+                let right: &[_] = right;\n+                assert!(right[0..right.len()] == [3, 4, 5]);\n+            }\n             for p in right.iter_mut() {\n                 *p += 2;\n             }"}, {"sha": "343ab7cfd28b98e7ec9733dc11a10f7dd5aa3166", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,7 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::MutableSlice;\n use slice;\n use str::StrSlice;\n \n@@ -173,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    buf.slice_to_mut(end).reverse();\n+    buf[mut ..end].reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n+                    slice::bytes::copy_memory(self.buf[mut *self.end..],\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())\n@@ -328,5 +328,5 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         }\n     }\n \n-    f(buf.slice_to(end))\n+    f(buf[..end])\n }"}, {"sha": "28ee522346f2f41e6046e25ec1508f8b7b3956cb", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -423,7 +423,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(b).unwrap_or(0);\n-                try!(f.buf.write(b.slice_to(n)));\n+                try!(f.buf.write(b[..n]));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n             else { Ok(()) }\n@@ -530,13 +530,13 @@ impl<'a> Formatter<'a> {\n         let len = self.fill.encode_utf8(fill).unwrap_or(0);\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill.slice_to(len)));\n+            try!(self.buf.write(fill[..len]));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill.slice_to(len)));\n+            try!(self.buf.write(fill[..len]));\n         }\n \n         Ok(())\n@@ -611,7 +611,7 @@ impl Char for char {\n \n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n+        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n         secret_string(&s, f)\n     }\n }"}, {"sha": "e57c499948362576932b274fd6721d0f1c1374af", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -18,7 +18,7 @@ use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::{MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +60,7 @@ trait GenericRadix {\n                 if x == zero() { break; }                 // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n+        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n     }\n }\n "}, {"sha": "4890dc2bb739350585255f97f93568d05dde091c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -57,8 +57,9 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![no_std]\n+#![allow(unknown_features)]\n #![feature(globs, intrinsics, lang_items, macro_rules, managed_boxes, phase)]\n-#![feature(simd, unsafe_destructor)]\n+#![feature(simd, unsafe_destructor, slicing_syntax)]\n #![deny(missing_doc)]\n \n mod macros;"}, {"sha": "422c496995b5ec243859adb30229411c6adb0ba5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -684,23 +684,23 @@ pub trait IndexMut<Index, Result> {\n  * A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n  * calling `slice_to`, and therefore, `main` prints `Slicing!`.\n  *\n- * ```\n+ * ```ignore\n  * struct Foo;\n  *\n  * impl ::core::ops::Slice<Foo, Foo> for Foo {\n- *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n+ *     fn as_slice<'a>(&'a self) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from_<'a>(&'a self, from: &Foo) -> &'a Foo {\n+ *     fn slice_from<'a>(&'a self, from: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to_<'a>(&'a self, to: &Foo) -> &'a Foo {\n+ *     fn slice_to<'a>(&'a self, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n+ *     fn slice<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n@@ -711,7 +711,22 @@ pub trait IndexMut<Index, Result> {\n  * }\n  * ```\n  */\n-// FIXME(#17273) remove the postscript _s\n+#[cfg(not(stage0))]\n+#[lang=\"slice\"]\n+pub trait Slice<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_slice<'a>(&'a self) -> &'a Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from<'a>(&'a self, from: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to<'a>(&'a self, to: &Idx) -> &'a Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n+}\n+/**\n+ *\n+ */\n+#[cfg(stage0)]\n #[lang=\"slice\"]\n pub trait Slice<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -734,34 +749,49 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n  * A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n  * calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n  *\n- * ```\n+ * ```ignore\n  * struct Foo;\n  *\n  * impl ::core::ops::SliceMut<Foo, Foo> for Foo {\n- *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+ *     fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from_mut_<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n+ *     fn slice_from_mut<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to_mut_<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_to_mut<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_mut_<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_mut<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n  * }\n  *\n- * fn main() {\n+ * pub fn main() {\n  *     Foo[mut Foo..];\n  * }\n  * ```\n  */\n-// FIXME(#17273) remove the postscript _s\n+#[cfg(not(stage0))]\n+#[lang=\"slice_mut\"]\n+pub trait SliceMut<Idx, Sized? Result> for Sized? {\n+    /// The method for the slicing operation foo[]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..]\n+    fn slice_from_mut<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[..to]\n+    fn slice_to_mut<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n+    /// The method for the slicing operation foo[from..to]\n+    fn slice_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n+}\n+/**\n+ *\n+ */\n+#[cfg(stage0)]\n #[lang=\"slice_mut\"]\n pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut]\n@@ -773,6 +803,7 @@ pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut from..to]\n     fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n+\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "a8becb315b201fd8cd5cc00d82aec401d193d1bd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 81, "deletions": 136, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -61,31 +61,6 @@ use raw::Slice as RawSlice;\n /// Extension methods for immutable slices.\n #[unstable = \"may merge with other traits; region parameter may disappear\"]\n pub trait ImmutableSlice<'a, T> {\n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n-\n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from(&self, start: uint) -> &'a [T];\n-\n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to(&self, end: uint) -> &'a [T];\n-\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -240,7 +215,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None }\n      *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n+     *     *self = self[1..];\n      *     Some(head)\n      * ```\n      *\n@@ -259,7 +234,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n+     *     *self = self[..self.len() - 1];\n      *     Some(tail)\n      * ```\n      *\n@@ -271,31 +246,9 @@ pub trait ImmutableSlice<'a, T> {\n \n #[unstable]\n impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(start as int),\n-                    len: (end - start)\n-                })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n-        self.slice(0, end)\n-    }\n-\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]) {\n-        (self.slice(0, mid), self.slice(mid, self.len()))\n+        ((*self)[..mid], (*self)[mid..])\n     }\n \n     #[inline]\n@@ -364,21 +317,21 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n+    fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n     #[inline]\n     #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n+    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n \n     #[inline]\n     fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n+        (*self)[..self.len() - 1]\n     }\n \n     #[inline]\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n+        (*self)[..self.len() - n]\n     }\n \n     #[inline]\n@@ -464,6 +417,35 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T> ops::Slice<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        self\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n+        self.slice(start, &self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n+        self.slice(&0, end)\n+    }\n+    #[inline]\n+    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -491,7 +473,36 @@ impl<T> ops::Slice<uint, [T]> for [T] {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T> ops::SliceMut<uint, [T]> for [T] {\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        self\n+    }\n \n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n+        let len = &self.len();\n+        self.slice_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n+        self.slice_mut(&0, end)\n+    }\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n+        assert!(*start <= *end);\n+        assert!(*end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(*start as int),\n+                    len: (*end - *start)\n+                })\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for [T] {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -533,49 +544,6 @@ pub trait MutableSlice<'a, T> {\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice(self) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        self.slice_mut(start, end)\n-    }\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Fails when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /// Deprecated: use `slice_from_mut`.\n-    #[deprecated = \"use slice_from_mut\"]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        self.slice_from_mut(start)\n-    }\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Fails when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_from_mut(self, start: uint) -> &'a mut [T];\n-\n-    /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.slice_to_mut(end)\n-    }\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Fails when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n-    fn slice_to_mut(self, end: uint) -> &'a mut [T];\n-\n     /// Deprecated: use `iter_mut`.\n     #[deprecated = \"use iter_mut\"]\n     fn mut_iter(self) -> MutItems<'a, T> {\n@@ -659,7 +627,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n-     *     *self = self.slice_from_mut(1);\n+     *     *self = self[mut 1..];\n      *     Some(head)\n      * ```\n      *\n@@ -678,7 +646,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.slice_to_mut(self.len() - 1);\n+     *     *self = self[mut ..self.len() - 1];\n      *     Some(tail)\n      * ```\n      *\n@@ -803,34 +771,11 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn as_mut_slice(self) -> &'a mut [T] { self }\n \n-    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_mut_ptr().offset(start as int) as *const T,\n-                    len: (end - start)\n-                })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.slice_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n-        self.slice_mut(0, end)\n-    }\n-\n     #[inline]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n-            let len = self.len();\n             let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self.slice_mut(0, mid), self2.slice_mut(mid, len))\n+            (self[mut ..mid], self2[mut mid..])\n         }\n     }\n \n@@ -867,13 +812,13 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn tail_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self.slice_mut(1, len)\n+        self[mut 1..len]\n     }\n \n     #[inline]\n     fn init_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self.slice_mut(0, len - 1)\n+        self[mut 0..len - 1]\n     }\n \n     #[inline]\n@@ -1020,13 +965,13 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle == self.slice_to(n)\n+        self.len() >= n && needle == (*self)[..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.slice_from(m - n)\n+        m >= n && needle == (*self)[m-n..]\n     }\n }\n \n@@ -1299,8 +1244,8 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n+                let ret = Some(self.v[..idx]);\n+                self.v = self.v[idx + 1..];\n                 ret\n             }\n         }\n@@ -1325,8 +1270,8 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n+                let ret = Some(self.v[idx + 1..]);\n+                self.v = self.v[..idx];\n                 ret\n             }\n         }\n@@ -1376,7 +1321,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = tail[mut 1..];\n                 Some(head)\n             }\n         }\n@@ -1410,7 +1355,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(tail[mut 1..])\n             }\n         }\n     }\n@@ -1458,8 +1403,8 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n+            let ret = Some(self.v[..self.size]);\n+            self.v = self.v[1..];\n             ret\n         }\n     }\n@@ -1543,7 +1488,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v.slice(lo, hi))\n+            Some(self.v[lo..hi])\n         } else {\n             None\n         }"}, {"sha": "1c20d364bf86353b8c04d3d6a258f1f7ced7cbef", "filename": "src/libcore/str.rs", "status": "modified", "additions": 69, "deletions": 31, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::ImmutableSlice;\n use slice;\n use uint;\n \n@@ -393,7 +393,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack.slice(self.position, self.position + needle.len()) == needle {\n+            if haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -514,10 +514,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n+        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -741,7 +741,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n+            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })\n@@ -1007,7 +1007,7 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v.slice_to(i),\n+        Some(i) => v[..i],\n         None => v\n     }\n }\n@@ -1164,6 +1164,7 @@ pub mod traits {\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n+    #[cfg(stage0)]\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1172,17 +1173,39 @@ pub mod traits {\n \n         #[inline]\n         fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-            self.slice_from(*from)\n+            super::slice_from_impl(&self, *from)\n         }\n \n         #[inline]\n         fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-            self.slice_to(*to)\n+            super::slice_to_impl(&self, *to)\n         }\n \n         #[inline]\n         fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            self.slice(*from, *to)\n+            super::slice_impl(&self, *from, *to)\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl ops::Slice<uint, str> for str {\n+        #[inline]\n+        fn as_slice<'a>(&'a self) -> &'a str {\n+            self\n+        }\n+\n+        #[inline]\n+        fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n+            super::slice_from_impl(&self, *from)\n+        }\n+\n+        #[inline]\n+        fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n+            super::slice_to_impl(&self, *to)\n+        }\n+\n+        #[inline]\n+        fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n+            super::slice_impl(&self, *from, *to)\n         }\n     }\n }\n@@ -1835,6 +1858,38 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n+#[inline]\n+fn slice_impl<'a>(this: &&'a str, begin: uint, end: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if begin <= end &&\n+       this.is_char_boundary(begin) &&\n+       this.is_char_boundary(end) {\n+        unsafe { raw::slice_unchecked(*this, begin, end) }\n+    } else {\n+        slice_error_fail(*this, begin, end)\n+    }\n+}\n+\n+#[inline]\n+fn slice_from_impl<'a>(this: &&'a str, begin: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if this.is_char_boundary(begin) {\n+        unsafe { raw::slice_unchecked(*this, begin, this.len()) }\n+    } else {\n+        slice_error_fail(*this, begin, this.len())\n+    }\n+}\n+\n+#[inline]\n+fn slice_to_impl<'a>(this: &&'a str, end: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if this.is_char_boundary(end) {\n+        unsafe { raw::slice_unchecked(*this, 0, end) }\n+    } else {\n+        slice_error_fail(*this, 0, end)\n+    }\n+}\n+\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1938,34 +1993,17 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, begin, end) }\n-        } else {\n-            slice_error_fail(*self, begin, end)\n-        }\n+        slice_impl(self, begin, end)\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n-        } else {\n-            slice_error_fail(*self, begin, self.len())\n-        }\n+        slice_from_impl(self, begin)\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, 0, end) }\n-        } else {\n-            slice_error_fail(*self, 0, end)\n-        }\n+        slice_to_impl(self, end)\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n@@ -1994,13 +2032,13 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n     }\n \n     #[inline]"}, {"sha": "9628d7950b5cf0c35b83e3ec9400fa818ae1ccd6", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -174,7 +174,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.slice_to(n), expect);\n+        assert_eq!(buf[..n], expect);\n     }\n \n     check('x', [0x78]);\n@@ -188,7 +188,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.slice_to(n), expect);\n+        assert_eq!(buf[..n], expect);\n     }\n \n     check('x', [0x0078]);"}, {"sha": "e84c894796736d249e83ea9fb887b738b1e34988", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -13,6 +13,7 @@ use core::iter::order::*;\n use core::uint;\n use core::cmp;\n use core::num;\n+use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -228,7 +229,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs.as_slice(), ys.as_slice());\n+    assert_eq!(xs[], ys[]);\n }\n \n #[test]\n@@ -268,7 +269,7 @@ fn test_cycle() {\n \n #[test]\n fn test_iterator_nth() {\n-    let v = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0i, 1, 2, 3, 4];\n     for i in range(0u, v.len()) {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n@@ -277,55 +278,55 @@ fn test_iterator_nth() {\n \n #[test]\n fn test_iterator_last() {\n-    let v = &[0i, 1, 2, 3, 4];\n+    let v: &[_] = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n+    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().count(), 4);\n-    assert_eq!(v.slice(0, 10).iter().count(), 10);\n-    assert_eq!(v.slice(0, 0).iter().count(), 0);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().count(), 4);\n+    assert_eq!(v[0..10].iter().count(), 10);\n+    assert_eq!(v[0..0].iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n-    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n+    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n+    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n+    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n }\n \n #[test]\n fn test_iterator_size_hint() {\n     let c = count(0i, 1);\n-    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10i, 11, 12];\n     let vi = v.iter();\n \n@@ -372,7 +373,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+    assert!(v.slice(&0, &0).iter().all(|_| fail!()));\n }\n \n #[test]\n@@ -381,7 +382,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+    assert!(!v.slice(&0, &0).iter().any(|_| fail!()));\n }\n \n #[test]\n@@ -566,7 +567,7 @@ fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, le\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n+    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "5f31ed35f1b60f6d69767027d3174d7ec5466454", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, macro_rules)]\n+#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax)]\n \n extern crate core;\n extern crate test;"}, {"sha": "aa2b1a6f14e6bd39773bca8c4fa5119e714c16fa", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -1012,7 +1012,7 @@ pub fn write<T>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf.slice_from(written).as_ptr();\n+            let ptr = buf[written..].as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if util::wouldblock() => {}"}, {"sha": "5475de6d7e1cc4158a7d4d8ed45070c7a240349c", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -448,7 +448,7 @@ impl rtio::RtioPipe for UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n+                                buf[offset..].as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "5def99d8ef34eafaa14d3e5ef96a15a66acc2bc3", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -57,7 +57,8 @@\n \n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types, deprecated)]\n-#![feature(default_type_params, lang_items)]\n+#![allow(unknown_features)]\n+#![feature(default_type_params, lang_items, slicing_syntax)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "c5722419f3ec94aa055820c02b1ee6fd77e07f5a", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -735,7 +735,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf.slice(start, end), radix) {\n+            match uint::parse_bytes(buf[start..end], radix) {\n                 Some(d) => {\n                     let d: Option<BigUint> = FromPrimitive::from_uint(d);\n                     match d {\n@@ -1406,7 +1406,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n+        return BigUint::parse_bytes(buf[start..], radix)\n             .map(|bu| BigInt::from_biguint(sign, bu));\n     }\n "}, {"sha": "fa41cf371129c286b3f7088afaf4357f7efe92e1", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -43,7 +43,8 @@\n //!\n //! [newt]: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n \n-#![feature(macro_rules)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, slicing_syntax)]\n #![feature(default_type_params)]\n \n #![crate_name = \"num\"]"}, {"sha": "c65e55690c78b9adf17ef93323919d4a2e264009", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -228,7 +228,7 @@ pub trait Rng {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n     /// println!(\"{}\", rng.choose(choices));\n-    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n+    /// assert_eq!(rng.choose(choices[..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "8917151609f810e3e1fa0f235a05405715c0f324", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -94,15 +94,15 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf.slice_to(cap), buf.slice_from(cap))\n+                (buf[..cap], buf[cap..])\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result\n             };\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n+                slice::bytes::copy_memory(self.buf[mut self.pos..], left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "7480cf320cff2cda3978c952a6ed768f0d0bdf35", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -24,7 +24,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, phase)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, phase, slicing_syntax)]\n #![allow(missing_doc)]\n \n extern crate serialize;\n@@ -54,7 +55,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n+        str::from_utf8(self.data[self.start..self.end]).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -280,7 +281,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n-        f(d.data.slice(d.start, d.end))\n+        f(d.data[d.start..d.end])\n     }\n \n "}, {"sha": "a32dfcf5d2a2b89121332272a8ab45c81cb3a323", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -102,7 +102,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts.slice_from(1).iter() {\n+        for inst in c.insts[1..].iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "fdfd8c1eae25c7dc3426b212b6a41252cc344525", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -368,7 +368,8 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, phase)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, phase, slicing_syntax)]\n #![deny(missing_doc)]\n \n #[cfg(test)]"}, {"sha": "bf576432631391e7a91714146994d1187032188e", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -511,7 +511,7 @@ impl<'a> Parser<'a> {\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n         let inner = String::from_chars(\n-            self.chars.as_slice().slice(start + 1, closer));\n+            self.chars[start+1..closer]);\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -944,7 +944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars.as_slice().slice(start, end))\n+        String::from_chars(self.chars[start..end])\n     }\n }\n "}, {"sha": "088425c08885533916fb2b0abb8f735b93cf2cce", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -130,7 +130,7 @@ macro_rules! mat(\n             // actual capture groups to match test set.\n             let (sexpect, mut sgot) = (expected.as_slice(), got.as_slice());\n             if sgot.len() > sexpect.len() {\n-                sgot = sgot.slice(0, sexpect.len())\n+                sgot = sgot[0..sexpect.len()]\n             }\n             if sexpect != sgot {\n                 fail!(\"For RE '{}' against '{}', expected '{}' but got '{}'\","}, {"sha": "0a4dca9125aa60144048662f713e711a252eb8bc", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -145,7 +145,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_slice().as_bytes();\n-                    let haystack = self.input.as_bytes().slice_from(self.ic);\n+                    let haystack = self.input.as_bytes()[self.ic..];\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "3535038b6a5a0877c1a94f6d7f448983593e55d5", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -550,7 +550,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n-                    let haystack = self.input.as_bytes().slice_from(self.ic);\n+                    let haystack = self.input.as_bytes()[self.ic..];\n                     match find_prefix(prefix_bytes, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "58db79f41ca4ce272c620f856fd2c45b76a3d676", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -89,9 +89,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded.slice(\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n+                        let compressed_data = bc_encoded[\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n@@ -188,7 +188,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc.slice(0, magic_id_byte_count) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -200,8 +200,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes.slice(position_in_bytes,\n-                                position_in_bytes + mem::size_of::<T>());\n+    let byte_data = bytes[position_in_bytes..\n+                          position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "478aa6d9805be44f2825faa9b75ac74b1cd723f1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -29,8 +29,9 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n #![allow(deprecated)]\n+#![allow(unknown_features)]\n #![feature(macro_rules, globs, struct_variant, quote)]\n-#![feature(default_type_params, phase, unsafe_destructor)]\n+#![feature(default_type_params, phase, unsafe_destructor, slicing_syntax)]\n \n #![feature(rustc_diagnostic_macros)]\n #![feature(import_shadowing)]"}, {"sha": "58d0f132e06a2616276d61e309c512c31ece6cf1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -70,7 +70,7 @@ fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n+        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n+            bytes[0u..4u], 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "ce5494ef477cf4b59141b6cd6110c68a3e810a71", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -91,7 +91,7 @@ fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data.slice(start_pos, end_pos));\n+    return op(st.data[start_pos..end_pos]);\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -599,8 +599,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         fail!();\n     }\n \n-    let crate_part = buf.slice(0u, colon_idx);\n-    let def_part = buf.slice(colon_idx + 1u, len);\n+    let crate_part = buf[0u..colon_idx];\n+    let def_part = buf[colon_idx + 1u..len];\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "bef63ec31539f5a653b64df276418c7b759be93a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -870,7 +870,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n+    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "6ead2445b8d06f2a58515f0bb36b9c0ad40ee581", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -4014,7 +4014,7 @@ impl<'a> Resolver<'a> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n+                    return self.upvarify(ribs[i + 1..], def_like, span);\n                 }\n                 None => {\n                     // Continue."}, {"sha": "504273f209019f31b395e4ac4e2060eeb737f8c4", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -193,7 +193,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths.slice(0, len-2);\n+        let sub_paths = sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,"}, {"sha": "3ec8d079df4061bf5527fe1fc98a87a85b729a36", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -473,7 +473,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n+            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n         } else {\n             None\n         }\n@@ -949,7 +949,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = compile_guard(bcx,\n                                     &**guard_expr,\n                                     m[0].data,\n-                                    m.slice(1, m.len()),\n+                                    m[1..m.len()],\n                                     vals,\n                                     chk,\n                                     has_genuine_default);\n@@ -988,7 +988,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n+    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but"}, {"sha": "f58241d677743627089c7d3a82bc04b892c059c2", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n+            self.inbounds_gep(base, small_vec[..ixs.len()])\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");"}, {"sha": "dc328833d546b79d7d9e96ec0ba0626a60e32d87", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -931,7 +931,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations.slice_to(address_op_count)\n+        address_operations: address_operations[..address_op_count]\n     };\n \n     declare_local(bcx,"}, {"sha": "e618e08f8a4dd985133b2076e1c6c50b15b4b1b3", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -290,7 +290,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n+    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter."}, {"sha": "aa53773bddf0ceb81e919df3b3acfd2a5bb5ff16", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -2271,10 +2271,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_mut_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_mut_\",\n-                    (&Some(_), &None) => \"slice_from_mut_\",\n-                    (&None, &Some(_)) => \"slice_to_mut_\",\n-                    (&None, &None) => \"as_mut_slice_\",\n+                    (&Some(_), &Some(_)) => \"slice_mut\",\n+                    (&Some(_), &None) => \"slice_from_mut\",\n+                    (&None, &Some(_)) => \"slice_to_mut\",\n+                    (&None, &None) => \"as_mut_slice\",\n                 };\n \n                 method::lookup_in_trait(fcx,\n@@ -2296,10 +2296,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_\",\n-                    (&Some(_), &None) => \"slice_from_\",\n-                    (&None, &Some(_)) => \"slice_to_\",\n-                    (&None, &None) => \"as_slice_\",\n+                    (&Some(_), &Some(_)) => \"slice\",\n+                    (&Some(_), &None) => \"slice_from\",\n+                    (&None, &Some(_)) => \"slice_to\",\n+                    (&None, &None) => \"as_slice\",\n                 };\n \n                 method::lookup_in_trait(fcx,\n@@ -3032,7 +3032,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n+        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,"}, {"sha": "5ca6d08720fa689e4b71c37f5b054c81f86a8d9f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -490,7 +490,7 @@ pub fn parameterized(cx: &ctxt,\n         0\n     };\n \n-    for t in tps.slice_to(tps.len() - num_defaults).iter() {\n+    for t in tps[..tps.len() - num_defaults].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n "}, {"sha": "6486442deb8d8cb7b33760b7e61d5f7db70fe01f", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -31,7 +31,8 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/\")]\n \n-#![feature(globs, phase, macro_rules)]\n+#![allow(unknown_features)]\n+#![feature(globs, phase, macro_rules, slicing_syntax)]\n \n #[phase(plugin, link)]\n extern crate log;"}, {"sha": "bf8d993964ff9b3ccd08f3533973347e8edbf2fa", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -136,14 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer.slice_mut(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining));\n+                        self.buffer[mut self.buffer_idx..size],\n+                        input[..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n+                    self.buffer[mut self.buffer_idx..self.buffer_idx + input.len()],\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -153,7 +153,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input.slice(i, i + size));\n+            func(input[i..i + size]);\n             i += size;\n         }\n \n@@ -162,8 +162,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer.slice_mut(0, input_remaining),\n-            input.slice_from(i));\n+            self.buffer[mut ..input_remaining],\n+            input[i..]);\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -173,19 +173,19 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n+        self.buffer[mut self.buffer_idx..idx].set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n+        return self.buffer[mut self.buffer_idx - len..self.buffer_idx];\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer.slice_to(64);\n+        return self.buffer[..64];\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }\n@@ -359,7 +359,7 @@ impl Engine256State {\n              )\n         )\n \n-        read_u32v_be(w.slice_mut(0, 16), data);\n+        read_u32v_be(w[mut 0..16], data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -495,14 +495,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n-        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n-        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n-        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n-        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n-        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n-        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n-        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n+        write_u32_be(out[mut 0..4], self.engine.state.h0);\n+        write_u32_be(out[mut 4..8], self.engine.state.h1);\n+        write_u32_be(out[mut 8..12], self.engine.state.h2);\n+        write_u32_be(out[mut 12..16], self.engine.state.h3);\n+        write_u32_be(out[mut 16..20], self.engine.state.h4);\n+        write_u32_be(out[mut 20..24], self.engine.state.h5);\n+        write_u32_be(out[mut 24..28], self.engine.state.h6);\n+        write_u32_be(out[mut 28..32], self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "0b04536f05443f90a0de6d1e22fb049b0bc03e02", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -698,7 +698,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs.slice_from(1)\n+            _ => all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -737,7 +737,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.slice_from(1)\n+            _ => self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1009,7 +1009,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n+                    inputs: self.fty.sig.inputs[1..].to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "b52b34ff58124a991c9a3a014c0baa6a5343507f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -249,7 +249,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments.slice_to(amt).iter() {\n+                for seg in path.segments[..amt].iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -264,7 +264,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 }\n             }\n             None => {\n-                for seg in path.segments.slice_to(amt).iter() {\n+                for seg in path.segments[..amt].iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -275,7 +275,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = fqp.slice_to(fqp.len() - 1);\n+            let to_link = fqp[..fqp.len() - 1];\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");"}, {"sha": "f6ea0eea9db3607fc59dc02da3265fe5ef7f66ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -394,7 +394,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n+                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -549,7 +549,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n+        for part in remote_path[..remote_path.len() - 1].iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -829,7 +829,7 @@ impl DocFolder for Cache {\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n                         ((Some(*self.parent_stack.last().unwrap()),\n-                          Some(self.stack.slice_to(self.stack.len() - 1))),\n+                          Some(self.stack[..self.stack.len() - 1])),\n                           false)\n                     }\n                     clean::MethodItem(..) => {\n@@ -840,13 +840,13 @@ impl DocFolder for Cache {\n                             let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n-                                    Some(self.stack.slice_to(self.stack.len() - 1)),\n+                                    Some(self.stack[..self.stack.len() - 1]),\n                                 // The current stack not necessarily has correlation for\n                                 // where the type was defined. On the other hand,\n                                 // `paths` always has the right information if present.\n                                 Some(&(ref fqp, item_type::Struct)) |\n                                 Some(&(ref fqp, item_type::Enum)) =>\n-                                    Some(fqp.slice_to(fqp.len() - 1)),\n+                                    Some(fqp[..fqp.len() - 1]),\n                                 Some(..) => Some(self.stack.as_slice()),\n                                 None => None\n                             };\n@@ -1172,7 +1172,7 @@ impl Context {\n                 let mut url = \"../\".repeat(cx.current.len());\n                 match cache_key.get().unwrap().paths.find(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in names.slice_to(names.len() - 1).iter() {\n+                        for name in names[..names.len() - 1].iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }"}, {"sha": "b46d8727b69d01a5b57c80a0dd2c7c71acbe979e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -15,7 +15,8 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n \n-#![feature(globs, struct_variant, managed_boxes, macro_rules, phase)]\n+#![allow(unknown_features)]\n+#![feature(globs, struct_variant, managed_boxes, macro_rules, phase, slicing_syntax)]\n \n extern crate arena;\n extern crate debug;"}, {"sha": "1183b14fb4e16d16b1699e18fa7311655d47b9b8", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -16,9 +16,10 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n+#![allow(unknown_features)]\n #![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n #![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n-#![feature(import_shadowing)]\n+#![feature(import_shadowing, slicing_syntax)]\n #![no_std]\n #![experimental]\n "}, {"sha": "f07e8ecc335d7c0fda54b1807a6ff27c4e5fbe02", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -562,7 +562,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = unsafe {\n         let amt = CALLBACK_CNT.load(atomic::SeqCst);\n-        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n+        CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n     };\n     for cb in callbacks.iter() {\n         match cb.load(atomic::SeqCst) {"}, {"sha": "455df88963e0d37315f1cc53653c128b613e27a3", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -62,8 +62,8 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n+            let left = self.buf[mut self.pos..];\n+            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -74,7 +74,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     let mut msg = [0u8, ..512];\n     let mut w = BufWriter { buf: msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "7f329630e703ea988e740baf26f212f4c5d86916", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -334,7 +334,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes.slice(start, i)));\n+            try!(wr.write(bytes[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -343,7 +343,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n     }\n \n     if start != bytes.len() {\n-        try!(wr.write(bytes.slice_from(start)));\n+        try!(wr.write(bytes[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -369,7 +369,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n \n     if n > 0 {\n-        wr.write(buf.slice_to(n))\n+        wr.write(buf[..n])\n     } else {\n         Ok(())\n     }\n@@ -1149,7 +1149,7 @@ impl Stack {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n-                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n+                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n             }\n         }\n     }\n@@ -1191,7 +1191,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(Key(str::from_utf8(\n-                    self.str_buffer.slice(start as uint, (start+size) as uint)\n+                    self.str_buffer[start as uint .. (start+size) as uint]\n                 ).unwrap()))\n             }\n         }"}, {"sha": "8c2f323532235a224eab136bc1281dadc8ae9025", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -23,7 +23,8 @@ Core encoding and decoding interfaces.\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(macro_rules, managed_boxes, default_type_params, phase)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, managed_boxes, default_type_params, phase, slicing_syntax)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "754b440b0de8a873bd29d8b2408fdc907eae8a36", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -90,10 +90,10 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n+            self.cap = try!(self.inner.read(self.buf[mut]));\n             self.pos = 0;\n         }\n-        Ok(self.buf.slice(self.pos, self.cap))\n+        Ok(self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -107,7 +107,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available.slice_to(nread));\n+            slice::bytes::copy_memory(buf, available[..nread]);\n             nread\n         };\n         self.pos += nread;\n@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.as_mut().unwrap().write(self.buf[..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -195,7 +195,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf.slice_from_mut(self.pos);\n+            let dst = self.buf[mut self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -250,9 +250,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf.slice_to(i + 1)));\n+                try!(self.inner.write(buf[..i + 1]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf.slice_from(i + 1)));\n+                try!(self.inner.write(buf[i + 1..]));\n                 Ok(())\n             }\n             None => self.inner.write(buf),"}, {"sha": "5bec131f22251d3e24666fb150947dfa47f15ed1", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -15,8 +15,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n-use str::StrSlice;\n+use slice::{bytes, CloneableVector};\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n \n@@ -62,10 +61,10 @@ impl Reader for ChanReader {\n         loop {\n             match self.buf {\n                 Some(ref prev) => {\n-                    let dst = buf.slice_from_mut(num_read);\n-                    let src = prev.slice_from(self.pos);\n+                    let dst = buf[mut num_read..];\n+                    let src = prev[self.pos..];\n                     let count = cmp::min(dst.len(), src.len());\n-                    bytes::copy_memory(dst, src.slice_to(count));\n+                    bytes::copy_memory(dst, src[..count]);\n                     num_read += count;\n                     self.pos += count;\n                 },"}, {"sha": "66d20835fb28887a8107e8897dcffb4a29a60307", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -485,7 +485,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return update_err(Err(e), from, to)\n         };\n-        try!(writer.write(buf.slice_to(amt)));\n+        try!(writer.write(buf[..amt]));\n     }\n \n     chmod(to, try!(update_err(from.stat(), from, to)).perm)\n@@ -1014,7 +1014,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_string()\n+                n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }\n@@ -1061,11 +1061,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem.slice_mut(0, 4);\n+                let read_buf = read_mem[mut 0..4];\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem.slice_mut(4, 8);\n+                let read_buf = read_mem[mut 4..8];\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "ca9692ee1588da2411c7ba887d657c86e9f24248", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -19,7 +19,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::{Slice, ImmutableSlice, MutableSlice};\n+use slice::Slice;\n use vec::Vec;\n \n static BUF_CAPACITY: uint = 128;\n@@ -146,8 +146,8 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.slice_mut(0, write_len);\n+            let input = self.buf[self.pos.. self.pos + write_len];\n+            let output = buf[mut ..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -174,7 +174,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -232,7 +232,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), buf);\n+        slice::bytes::copy_memory(self.buf[mut self.pos..], buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -292,8 +292,8 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.slice(self.pos, self.pos + write_len);\n-            let output = buf.slice_mut(0, write_len);\n+            let input = self.buf[self.pos.. self.pos + write_len];\n+            let output = buf[mut ..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -320,7 +320,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -427,7 +427,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.slice(0, 3), b);\n+        assert_eq!(buf[0..3], b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -454,7 +454,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.slice(0, 3), b);\n+        assert_eq!(buf[0..3], b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -548,7 +548,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n+        assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "9768539b23e7f3da76e9a0e25d48e14e03f8bb79", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -235,7 +235,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{Slice, MutableSlice, ImmutableSlice};\n+use slice::{Slice, ImmutableSlice};\n use str::{Str, StrSlice};\n use str;\n use string::String;\n@@ -575,7 +575,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf.slice_from_mut(read)) {\n+                match self.read(buf[mut read..]) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1111,8 +1111,8 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(buf.slice_to(n))\n+        let n = c.encode_utf8(buf[mut]).unwrap_or(0);\n+        self.write(buf[..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1496,7 +1496,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n+                        res.push_all(available[..i + 1]);\n                         used = i + 1;\n                         break\n                     }\n@@ -1528,14 +1528,14 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf.slice_mut(start, width))) {\n+                match try!(self.read(buf[mut start..width])) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n-        match str::from_utf8(buf.slice_to(width)) {\n+        match str::from_utf8(buf[..width]) {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "5140159e4ea3790f1cdfc139e2744972bff9a158", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -21,7 +21,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableSlice, ImmutableSlice, MutableSlice};\n+use slice::{MutableCloneableSlice, MutableSlice};\n \n pub type Port = u16;\n \n@@ -241,7 +241,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.clone_from_slice(head);\n-            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n+            gs[mut 8 - tail.len() .. 8].clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16, ..8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n+        Some(ipv6_addr_from_head_tail(head[..head_size], tail[..tail_size]))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "b8fb187548c652ed8830e1acf1964d308b68c22d", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -35,26 +35,29 @@ use rt::rtio;\n ///\n /// ```rust,no_run\n /// # #![allow(unused_must_use)]\n+/// #![feature(slicing_syntax)]\n+///\n /// use std::io::net::udp::UdpSocket;\n /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// fn main() {\n+///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n+///     let mut socket = match UdpSocket::bind(addr) {\n+///         Ok(s) => s,\n+///         Err(e) => fail!(\"couldn't bind socket: {}\", e),\n+///     };\n ///\n-/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-/// let mut socket = match UdpSocket::bind(addr) {\n-///     Ok(s) => s,\n-///     Err(e) => fail!(\"couldn't bind socket: {}\", e),\n-/// };\n-///\n-/// let mut buf = [0, ..10];\n-/// match socket.recv_from(buf) {\n-///     Ok((amt, src)) => {\n-///         // Send a reply to the socket we received data from\n-///         let buf = buf.slice_to_mut(amt);\n-///         buf.reverse();\n-///         socket.send_to(buf, src);\n+///     let mut buf = [0, ..10];\n+///     match socket.recv_from(buf) {\n+///         Ok((amt, src)) => {\n+///             // Send a reply to the socket we received data from\n+///             let buf = buf[mut ..amt];\n+///             buf.reverse();\n+///             socket.send_to(buf, src);\n+///         }\n+///         Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n ///     }\n-///     Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n+///     drop(socket); // close the socket\n /// }\n-/// drop(socket); // close the socket\n /// ```\n pub struct UdpSocket {\n     obj: Box<RtioUdpSocket + Send>,"}, {"sha": "820ae931f320484a3ef7fa8caf5b60c4618d67fd", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -47,7 +47,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf.slice_to_mut(len));\n+        let res = self.inner.read(buf[mut ..len]);\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}\n@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt.slice_to(cmp::min(amt.len(), self.limit));\n+        let buf = amt[..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -216,7 +216,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf.slice_to(len)).map(|()| len)\n+            self.writer.write(buf[mut ..len]).map(|()| len)\n         })\n     }\n }\n@@ -230,7 +230,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf.slice_to(len)));\n+        try!(w.write(buf[..len]));\n     }\n }\n "}, {"sha": "82de55efad603ae53342a5de31bf58634208c6e2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -105,9 +105,10 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n+#![allow(unknown_features)]\n #![feature(macro_rules, globs, managed_boxes, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n-#![feature(import_shadowing)]\n+#![feature(import_shadowing, slicing_syntax)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "9e4cc06f0a2005c9a5bcec46a7eb2fc85448621a", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "54259fcad55cb700ebaaa3976374a2538445c4ab", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "b5fe6825ca4b4c12fba61d75bf89885e6e32bf45", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "7aa9a41e340386330ea4ee1f9d88d7a107fe4b25", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "74ee61634c6950ed5b95072dc7a32e0fca6fbf4b", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "62e609bb2e18b962878158dcfc1a2a86b30ef86e", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -78,7 +78,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf.slice(0, amt))\n+    f(buf[..amt])\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "f97bbe0dc8eab12955d5ffbbdb65e33ee5728e9f", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -730,7 +730,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf.slice(i+1, len), 10, true, false, false, ExpNone, false,\n+            buf[i+1..len], 10, true, false, false, ExpNone, false,\n             ignore_underscores);\n \n         match exp {"}, {"sha": "c141ecc9cba4ec3ae609e0d21fe4ade2a4cb61ce", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "8a8e2729a5325d4b0764614a882e8c7d8e3497fb", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "1b4f8bc433f15299d28790b89c2482250d1ea3d9", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "28f2242923560ee60869a093813bbfa24d504c95", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "da328074453925a64037b55735fc0d749b1e9355", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -17,7 +17,6 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n-use slice::ImmutableSlice;\n use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "a033308af1616cc182837e78d407036b2804fd1c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -79,7 +79,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf.slice(0, amt))\n+    f(buf[..amt])\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "c6948cccafec8b468808669b7c533653f849567a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{MutableSlice, ImmutableSlice};\n+    use slice::MutableSlice;\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "63c81695affd9c38c3313da4a68628ead7f049b8", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -357,7 +357,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name.slice_to(pos)\n+                    Some(pos) => name[..pos]\n                 }\n             })\n         }\n@@ -404,7 +404,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name.slice_from(pos+1))\n+                    Some(pos) => Some(name[pos+1..])\n                 }\n             }\n         }\n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n+                (Some(idx), 0) => Some(name[..idx].to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -489,7 +489,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name.slice_to(idx));\n+                    v.push_all(name[..idx]);\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)"}, {"sha": "3043c25f761dd6754cb6e08eecb6c20b57173d85", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -165,7 +165,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -175,7 +175,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr.slice_to(idx+1));\n+                v.push_all(self.repr[..idx+1]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -216,9 +216,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr.slice_to(idx)\n+            Some(0) => self.repr[..1],\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr[..idx]\n         }\n     }\n \n@@ -227,9 +227,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr.as_slice() ||\n                 b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n-            Some(0) if self.repr.slice_from(1).is_empty() => None,\n-            Some(idx) => Some(self.repr.slice_from(idx+1))\n+            Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n+            Some(0) if self.repr[1..].is_empty() => None,\n+            Some(idx) => Some(self.repr[idx+1..])\n         }\n     }\n \n@@ -371,7 +371,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n+            let v_ = if is_abs { v.as_slice()[1..] } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -410,7 +410,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr.slice_from(1)\n+            self.repr[1..]\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {"}, {"sha": "e1925fc79d0dc1e8ed0c10c31f3e2ca70d33e548", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -999,7 +999,7 @@ mod imp {\n                 let bytes = cstr.as_bytes();\n                 match cstr.as_str() {\n                     Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n+                    None => try!(w.write(bytes[..bytes.len()-1])),\n                 }\n             }\n             try!(w.write(['\\n' as u8]));"}, {"sha": "257bfc632d882f4b0a7fb760a29e7a1fd4e47136", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -496,7 +496,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts.slice_to(parts.len() - 1),\n+            in_which: parts[..parts.len() - 1],\n             idx: 0,\n         }\n     }"}, {"sha": "6d063aef5a99063e886aaeca006b592d98ce1058", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -414,7 +414,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines.slice(0u, MAX_LINES);\n+        display_lines = display_lines[0u..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "38de2a9c284f09fe3a9abfbb7a4b177febb6bb9e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -70,6 +70,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"tuple_indexing\", Active),\n     (\"associated_types\", Active),\n     (\"visible_private_types\", Active),\n+    (\"slicing_syntax\", Active),\n \n     (\"if_let\", Active),\n \n@@ -362,6 +363,11 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 self.gate_feature(\"if_let\", e.span,\n                                   \"`if let` syntax is experimental\");\n             }\n+            ast::ExprSlice(..) => {\n+                self.gate_feature(\"slicing_syntax\",\n+                                  e.span,\n+                                  \"slicing syntax is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "64dedd4592397f06b755a834f534ea89f1d62604", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -23,7 +23,8 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![feature(macro_rules, globs, default_type_params, phase)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n "}, {"sha": "b05e0a4bff398595bf045392da5a07775b3c7f0c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -49,7 +49,8 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, phase)]\n+#![allow(unknown_features)]\n+#![feature(macro_rules, phase, slicing_syntax)]\n \n #![deny(missing_doc)]\n "}, {"sha": "6b921144144e26f133eea9fea79674a736959366", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -285,13 +285,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n+            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table.slice(offset as uint,\n-                                          offset as uint + len).to_vec())\n+                                      string_table[offset as uint ..\n+                                          offset as uint + len].to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "b4292c2b050331ea5eaba7abce3fbc1f7082aa73", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(slicing_syntax)]\n+\n use std::{cmp, iter, mem};\n use std::sync::Future;\n \n@@ -50,7 +52,7 @@ fn rotate(x: &mut [i32]) {\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm.slice_to_mut(i + 1));\n+        rotate(perm[mut ..i + 1]);\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -99,7 +101,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p.slice_to(i + 1).iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n                 *place = (*val) as u8\n             }\n \n@@ -125,7 +127,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm.slice_to_mut(k).reverse()\n+    tperm[mut ..k].reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}, {"sha": "b8af76ce17cecf879ffb01980cbf8873656e76e3", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(slicing_syntax)]\n+\n use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n@@ -124,8 +126,8 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf.slice_mut(alu_len, buf_len),\n-                    alu.slice_to(LINE_LEN));\n+        copy_memory(buf[mut alu_len..buf_len],\n+                    alu[..LINE_LEN]);\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -201,7 +203,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(buf.slice_to(chars_left))\n+        self.out.write(buf[..chars_left])\n     }\n }\n "}, {"sha": "7565525bc8cc00f7c498955d60a12abad58f8171", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(slicing_syntax)]\n+\n use std::io;\n use std::io::{BufferedWriter, File};\n use std::cmp::min;\n@@ -93,7 +95,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n         }\n         n -= nb;\n         line[nb] = '\\n' as u8;\n-        wr.write(line.slice_to(nb + 1));\n+        wr.write(line[..nb+1]);\n     }\n }\n "}, {"sha": "86c1bd82e9f9c8fbfdfef7090373f2fae198864b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -13,6 +13,8 @@\n \n // multi tasking k-nucleotide\n \n+#![feature(slicing_syntax)]\n+\n extern crate collections;\n \n use std::collections::HashMap;\n@@ -97,11 +99,11 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(bb.slice(ii, ii+nn));\n+      it(bb[ii..ii+nn]);\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb.slice(len - (nn - 1u), len));\n+   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "8c08fc4caa1d88b24d60622e90bd4711f93aaf1a", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -40,6 +40,8 @@\n \n // ignore-android see #10393 #13206\n \n+#![feature(slicing_syntax)]\n+\n use std::string::String;\n use std::slice;\n use std::sync::{Arc, Future};\n@@ -240,14 +242,14 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     // Pull first frame.\n     for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n-        input = input.slice_from(1);\n+        input = input[1..];\n     }\n     frequencies.lookup(code, BumpCallback);\n \n     while input.len() != 0 && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n-        input = input.slice_from(1);\n+        input = input[1..];\n     }\n     frequencies\n }"}, {"sha": "dccdafe9cf832d07c240661ccc28fdb3db539168", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -41,7 +41,7 @@\n // ignore-stage1\n // ignore-cross-compile #12102\n \n-#![feature(macro_rules, phase)]\n+#![feature(macro_rules, phase, slicing_syntax)]\n \n extern crate regex;\n #[phase(plugin)]extern crate regex_macros;"}, {"sha": "e3fa6334f77cc55ad075898ffe79f847752617eb", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -41,6 +41,8 @@\n // ignore-pretty very bad with line comments\n // ignore-android doesn't terminate?\n \n+#![feature(slicing_syntax)]\n+\n use std::iter::range_step;\n use std::io::{stdin, stdout, File};\n \n@@ -81,7 +83,7 @@ fn main() {\n             Some(c) => c\n         };\n         let len = seq.len();\n-        let seq = seq.slice_mut(begin + 1, len - 1);\n+        let seq = seq[mut begin+1..len-1];\n \n         // arrange line breaks\n         let len = seq.len();"}, {"sha": "c29e74af03cd2f17bade2f1e5a4aae4070ce1ba2", "filename": "src/test/compile-fail/issue-15730.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(slicing_syntax)]\n+\n fn main() {\n     let mut array = [1, 2, 3];\n //~^ ERROR cannot determine a type for this local variable: cannot determine the type of this integ\n-    let pie_slice = array.slice(1, 2);\n+    let pie_slice = array[1..2];\n }"}, {"sha": "63f79c808ae22e575e8ea6db54ea7be1343e6852", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test that slicing syntax gives errors if we have not implemented the trait.\n \n+#![feature(slicing_syntax)]\n+\n struct Foo;\n \n fn main() {"}, {"sha": "00783b71ea11da2c12f7ca2548e7dccfe09b44fe", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test slicing expressions doesn't defeat the borrow checker.\n \n+#![feature(slicing_syntax)]\n+\n fn main() {\n     let y;\n     {"}, {"sha": "09019448a6786e8dd3f68485a287cbfe0047f894", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test mutability and slicing syntax.\n \n+#![feature(slicing_syntax)]\n+\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice"}, {"sha": "cbfa3ed85fd6c8f59b6f0b1134902a3ecc29d096", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test mutability and slicing syntax.\n \n+#![feature(slicing_syntax)]\n+\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable."}, {"sha": "67e621fe556202bd0f588bb417b8480532beba4f", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -80,6 +80,7 @@\n // lldb-check:[...]$5 = &[AStruct { x: 10, y: 11, z: 12 }, AStruct { x: 13, y: 14, z: 15 }]\n \n #![allow(unused_variable)]\n+#![feature(slicing_syntax)]\n \n struct AStruct {\n     x: i16,\n@@ -94,7 +95,7 @@ fn main() {\n     let empty: &[i64] = &[];\n     let singleton: &[i64] = &[1];\n     let multiple: &[i64] = &[2, 3, 4, 5];\n-    let slice_of_slice = multiple.slice(1,3);\n+    let slice_of_slice = multiple[1..3];\n \n     let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n "}, {"sha": "10add853ee7f3bc2fcf8513dab64415dd05da36f", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(slicing_syntax)]\n+\n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v.slice(1, 5)\n+    v[1..5]\n }\n \n pub fn main() {}"}, {"sha": "f2c1a715b514b959ed238dea4c5d4519165a064d", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.slice(i, j) }\n+#![feature(slicing_syntax)]\n+\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v[i..j] }\n \n pub fn main() {}"}, {"sha": "f2dcaa4a31eaa2bdd29be934c815089ec780a394", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(slicing_syntax)]\n \n extern crate debug;\n \n@@ -21,7 +22,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x.slice(0,1);\n+    let slice = x[0..1];\n     let z = box(GC) x;\n \n     assert_repr_eq(abc, \"[1, 2, 3]\".to_string());"}, {"sha": "768c28cb8ded72533b138f460a50f379c1af5866", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test slicing expressions on slices and Vecs.\n \n+#![feature(slicing_syntax)]\n+\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];"}, {"sha": "b07cf59596852250647308a68278d173afe3e5f4", "filename": "src/test/run-pass/slice-fail-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test that is a slicing expr[..] fails, the correct cleanups happen.\n \n+#![feature(slicing_syntax)]\n+\n use std::task;\n \n struct Foo;"}, {"sha": "a2aecc1d5cd56e3b62d415006d7e2634ceedbe18", "filename": "src/test/run-pass/slice-fail-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test that is a slicing expr[..] fails, the correct cleanups happen.\n \n+#![feature(slicing_syntax)]\n+\n use std::task;\n \n struct Foo;"}, {"sha": "2b4251b40891f7cdc1dadbabd0f2378d7471e510", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07b2c1be9dad53272575844efedfb7314fc4fb84/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=07b2c1be9dad53272575844efedfb7314fc4fb84", "patch": "@@ -10,6 +10,8 @@\n \n // Test slicing sugar.\n \n+#![feature(slicing_syntax)]\n+\n extern crate core;\n use core::ops::{Slice,SliceMut};\n \n@@ -18,38 +20,38 @@ static mut COUNT: uint = 0;\n struct Foo;\n \n impl Slice<Foo, Foo> for Foo {\n-    fn as_slice_<'a>(&'a self) -> &'a Foo {\n+    fn as_slice<'a>(&'a self) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+    fn slice_from<'a>(&'a self, _from: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+    fn slice_to<'a>(&'a self, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+    fn slice<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n impl SliceMut<Foo, Foo> for Foo {\n-    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_mut_<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+    fn slice_from_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_mut_<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+    fn slice_to_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_mut_<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+    fn slice_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }"}]}