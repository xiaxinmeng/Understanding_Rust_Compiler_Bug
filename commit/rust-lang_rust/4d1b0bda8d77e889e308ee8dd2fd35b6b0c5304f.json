{"sha": "4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMWIwYmRhOGQ3N2U4ODllMzA4ZWU4ZGQyZmQzNWI2YjBjNTMwNGY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-02T21:48:00Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-02T21:48:00Z"}, "message": "Merge pull request #602 from mcarton/#594\n\nAdd a lint about using `clone` on `Copy` types", "tree": {"sha": "888a859f4642bdda2111f33da3177ac707c7dc09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/888a859f4642bdda2111f33da3177ac707c7dc09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "html_url": "https://github.com/rust-lang/rust/commit/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "527af79993e4c179c05cad49d9887d64391aa27b", "url": "https://api.github.com/repos/rust-lang/rust/commits/527af79993e4c179c05cad49d9887d64391aa27b", "html_url": "https://github.com/rust-lang/rust/commit/527af79993e4c179c05cad49d9887d64391aa27b"}, {"sha": "db205c82a4125446d47296c3d3463c81efb0dd3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/db205c82a4125446d47296c3d3463c81efb0dd3d", "html_url": "https://github.com/rust-lang/rust/commit/db205c82a4125446d47296c3d3463c81efb0dd3d"}], "stats": {"total": 442, "additions": 186, "deletions": 256}, "files": [{"sha": "d7086a6dac83a701bdd773b76a7e0bd03091aff7", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 107 lints included in this crate:\n+There are 108 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -22,6 +22,7 @@ name\n [cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                               | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n [char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                               | warn    | Casting a character literal to u8\n [chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                               | warn    | using `.chars().next()` to check if a string starts with a char\n+[clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#clone_on_copy)                                 | warn    | using `clone` on a `Copy` type\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                             | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                         | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                               | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }` and an `else { if .. } expression can be collapsed to `else if`"}, {"sha": "012c4e502b4a7c82a8e70c31e9dd8de9504740aa", "filename": "src/attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -60,10 +60,10 @@ impl LateLintPass for AttrPass {\n                         check_semver(cx, item.span, lit);\n                     }\n                 }\n-            } \n+            }\n         }\n     }\n-    \n+\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if is_relevant_item(item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n@@ -164,7 +164,7 @@ fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n             return;\n         }\n     }\n-    span_lint(cx, \n+    span_lint(cx,\n               DEPRECATED_SEMVER,\n               span,\n               \"the since field must contain a semver-compliant version\");"}, {"sha": "0fce772010a9a1796978037425ff10c4a12e8304", "filename": "src/bit_mask.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -151,7 +151,6 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     } else if mask_value == 0 {\n                         span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n                     }\n-\n                 }\n                 BiBitOr => {\n                     if mask_value | cmp_value != cmp_value {"}, {"sha": "d8f331ef5ff4f8af9846a9c126df33e1f44263e6", "filename": "src/derive.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -158,24 +158,21 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref:\n             _ => (),\n         }\n \n-        span_lint_and_then(\n-            cx, DERIVE_HASH_NOT_EQ, span,\n-            \"you are implementing `Clone` explicitly on a `Copy` type\",\n-            |db| {\n-                db.span_note(\n-                    span,\n-                    \"consider deriving `Clone` or removing `Copy`\"\n-                );\n-        });\n+        span_lint_and_then(cx,\n+                           DERIVE_HASH_NOT_EQ,\n+                           span,\n+                           \"you are implementing `Clone` explicitly on a `Copy` type\",\n+                           |db| {\n+                               db.span_note(span, \"consider deriving `Clone` or removing `Copy`\");\n+                           });\n     }\n }\n \n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d implementations have.\n fn is_automatically_derived(attr: &Attribute) -> bool {\n     if let MetaItem_::MetaWord(ref word) = attr.node.value.node {\n         word == &\"automatically_derived\"\n-    }\n-    else {\n+    } else {\n         false\n     }\n }"}, {"sha": "bd6687e3f0dfb9fd2c810ef0ede958f37c4903bd", "filename": "src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -34,7 +34,7 @@ declare_lint!(pub BOXED_LOCAL, Warn, \"using Box<T> where unnecessary\");\n fn is_non_trait_box(ty: ty::Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(ref inner) => !inner.is_trait(),\n-        _ => false\n+        _ => false,\n     }\n }\n "}, {"sha": "ad666a3bf3f6baead8a0dea1c2d528cf1214f406", "filename": "src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems_after_statements.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -56,8 +56,10 @@ impl EarlyLintPass for ItemsAfterStatemets {\n                     if in_macro(cx, it.span) {\n                         return;\n                     }\n-                    cx.struct_span_lint(ITEMS_AFTER_STATEMENTS, it.span,\n-                                        \"adding items after statements is confusing, since items exist from the start of the scope\")\n+                    cx.struct_span_lint(ITEMS_AFTER_STATEMENTS,\n+                                        it.span,\n+                                        \"adding items after statements is confusing, since items exist from the \\\n+                                         start of the scope\")\n                       .emit();\n                 }\n             }"}, {"sha": "369542841846f6a8b91bab947119de2d4f46b209", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -87,9 +87,8 @@ mod reexport {\n     pub use syntax::ast::{Name, NodeId};\n }\n \n-#[allow(unused_attributes)]\n #[plugin_registrar]\n-#[rustfmt_skip]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box misc::TopLevelRefPass);\n@@ -215,6 +214,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::CHARS_NEXT_CMP,\n+        methods::CLONE_ON_COPY,\n         methods::EXTEND_FROM_SLICE,\n         methods::FILTER_NEXT,\n         methods::OK_EXPECT,"}, {"sha": "b6f8ebe5fd8992b4445605e852bc226a2c127cd5", "filename": "src/lifetimes.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -68,9 +68,13 @@ enum RefLt {\n \n fn bound_lifetimes(bound: &TyParamBound) -> Option<HirVec<&Lifetime>> {\n     if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-        let lt = trait_ref.trait_ref.path.segments\n-            .last().expect(\"a path must have at least one segment\")\n-            .parameters.lifetimes();\n+        let lt = trait_ref.trait_ref\n+                          .path\n+                          .segments\n+                          .last()\n+                          .expect(\"a path must have at least one segment\")\n+                          .parameters\n+                          .lifetimes();\n \n         Some(lt)\n     } else {\n@@ -83,10 +87,9 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n         return;\n     }\n \n-    let bounds_lts =\n-        generics.ty_params\n-            .iter()\n-            .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n+    let bounds_lts = generics.ty_params\n+                             .iter()\n+                             .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n \n     if could_use_elision(cx, decl, slf, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n@@ -97,10 +100,9 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n     report_extra_lifetimes(cx, decl, &generics, slf);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item=&'a Lifetime>>(\n-    cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n-    named_lts: &[LifetimeDef], bounds_lts: T\n-) -> bool {\n+fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n+                                                           named_lts: &[LifetimeDef], bounds_lts: T)\n+                                                           -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -185,7 +187,7 @@ fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n     allowed_lts\n }\n \n-fn lts_from_bounds<'a, T: Iterator<Item=&'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n+fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n         if lt.name.as_str() != \"'static\" {\n             vec.push(RefLt::Named(lt.name));\n@@ -332,8 +334,7 @@ impl<'v> Visitor<'v> for LifetimeChecker {\n     }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl,\n-                          generics: &Generics, slf: Option<&ExplicitSelf>) {\n+fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics, slf: Option<&ExplicitSelf>) {\n     let hs = generics.lifetimes\n                      .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))"}, {"sha": "49e073aacd0a057d9e071b8b6d127e289e901ed0", "filename": "src/loops.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -296,16 +296,14 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n \n                 let skip: Cow<_> = if starts_at_zero {\n                     \"\".into()\n-                }\n-                else {\n+                } else {\n                     format!(\".skip({})\", snippet(cx, l.span, \"..\")).into()\n                 };\n \n                 let take: Cow<_> = if let Some(ref r) = *r {\n                     if !is_len_call(&r, &indexed) {\n                         format!(\".take({})\", snippet(cx, r.span, \"..\")).into()\n-                    }\n-                    else {\n+                    } else {\n                         \"\".into()\n                     }\n                 } else {\n@@ -327,8 +325,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n                         format!(\"&{}\", indexed)\n-                    }\n-                    else {\n+                    } else {\n                         format!(\"{}.iter(){}{}\", indexed, take, skip)\n                     };\n \n@@ -478,7 +475,7 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n                 let mut visitor2 = InitializeVisitor {\n                     cx: cx,\n                     end_expr: expr,\n-                    var_id: id.clone(),\n+                    var_id: *id,\n                     state: VarState::IncrOnce,\n                     name: None,\n                     depth: 0,"}, {"sha": "e690f04bdb0c60518ebba7144e8deafd47205719", "filename": "src/matches.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -192,7 +192,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n         },\n         PatEnum(ref path, None) => path.to_string(),\n         PatIdent(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n-        _ => return\n+        _ => return,\n     };\n \n     for &(ty_path, pat_path) in candidates {\n@@ -206,15 +206,17 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n             span_lint_and_then(cx,\n                                lint,\n                                expr.span,\n-                               \"you seem to be trying to use match for destructuring a single pattern. \\\n-                               Consider using `if let`\", |db| {\n-                db.span_suggestion(expr.span, \"try this\",\n-                                   format!(\"if let {} = {} {}{}\",\n-                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                           snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\"),\n-                                           els_str));\n-            });\n+                               \"you seem to be trying to use match for destructuring a single pattern. Consider \\\n+                                using `if let`\",\n+                               |db| {\n+                                   db.span_suggestion(expr.span,\n+                                                      \"try this\",\n+                                                      format!(\"if let {} = {} {}{}\",\n+                                                              snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                                              snippet(cx, ex.span, \"..\"),\n+                                                              expr_block(cx, &arms[0].body, None, \"..\"),\n+                                                              els_str));\n+                               });\n         }\n     }\n }\n@@ -267,12 +269,12 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n         span_lint_and_then(cx,\n                            MATCH_BOOL,\n                            expr.span,\n-                           \"you seem to be trying to match on a boolean expression. Consider using \\\n-                           an if..else block:\", move |db| {\n-            if let Some(sugg) = sugg {\n-                db.span_suggestion(expr.span, \"try this\", sugg);\n-            }\n-        });\n+                           \"you seem to be trying to match on a boolean expression. Consider using an if..else block:\",\n+                           move |db| {\n+                               if let Some(sugg) = sugg {\n+                                   db.span_suggestion(expr.span, \"try this\", sugg);\n+                               }\n+                           });\n     }\n }\n "}, {"sha": "0584d39330dd533004299cf03a005f8d7efc92f1", "filename": "src/methods.rs", "status": "modified", "additions": 99, "deletions": 179, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -219,6 +219,17 @@ declare_lint!(pub OR_FUN_CALL, Warn,\n declare_lint!(pub EXTEND_FROM_SLICE, Warn,\n               \"`.extend_from_slice(_)` is a faster way to extend a Vec by a slice\");\n \n+/// **What it does:** This lint warns on using `.clone()` on a `Copy` type.\n+///\n+/// **Why is this bad?** The only reason `Copy` types implement `Clone` is for generics, not for\n+/// using the `clone` method on a concrete type.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `42u64.clone()`\n+declare_lint!(pub CLONE_ON_COPY, Warn,\n+              \"using `clone` on a `Copy` type\");\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n@@ -233,7 +244,8 @@ impl LintPass for MethodsPass {\n                     OPTION_MAP_UNWRAP_OR,\n                     OPTION_MAP_UNWRAP_OR_ELSE,\n                     OR_FUN_CALL,\n-                    CHARS_NEXT_CMP)\n+                    CHARS_NEXT_CMP,\n+                    CLONE_ON_COPY)\n     }\n }\n \n@@ -269,6 +281,7 @@ impl LateLintPass for MethodsPass {\n                 }\n \n                 lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n+                lint_clone_on_copy(cx, expr, &name.node.as_str(), &args);\n             }\n             ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n                 if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n@@ -349,16 +362,18 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n \n         if name == \"unwrap_or\" {\n             if let ExprPath(_, ref path) = fun.node {\n-                let path : &str = &path.segments.last()\n-                    .expect(\"A path must have at least one segment\")\n-                    .identifier.name.as_str();\n+                let path: &str = &path.segments\n+                                      .last()\n+                                      .expect(\"A path must have at least one segment\")\n+                                      .identifier\n+                                      .name\n+                                      .as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.expr_ty(arg);\n                     let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n                         default_trait_id\n-                    }\n-                    else {\n+                    } else {\n                         return false;\n                     };\n \n@@ -408,7 +423,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n             };\n \n         if !poss.contains(&name) {\n-            return\n+            return;\n         }\n \n         let sugg = match (fn_has_arguments, !or_has_args) {\n@@ -437,37 +452,52 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     }\n }\n \n+/// Checks for the `CLONE_ON_COPY` lint.\n+fn lint_clone_on_copy(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n+    if args.len() == 1 && name == \"clone\" {\n+        let ty = cx.tcx.expr_ty(expr);\n+        let parent = cx.tcx.map.get_parent(expr.id);\n+        let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n+\n+        if !ty.moves_by_default(&parameter_environment, expr.span) {\n+            span_lint(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\");\n+        }\n+    }\n+}\n+\n fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n     if !match_type(cx, obj_ty, &VEC_PATH) {\n         return;\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n     if let Some((span, r)) = derefs_to_slice(cx, &args[1], &arg_ty) {\n-        span_lint(cx, EXTEND_FROM_SLICE, expr.span,\n+        span_lint(cx,\n+                  EXTEND_FROM_SLICE,\n+                  expr.span,\n                   &format!(\"use of `extend` to extend a Vec by a slice\"))\n-            .span_suggestion(expr.span, \"try this\",\n+            .span_suggestion(expr.span,\n+                             \"try this\",\n                              format!(\"{}.extend_from_slice({}{})\",\n                                      snippet(cx, args[0].span, \"_\"),\n-                                     r, snippet(cx, span, \"_\")));\n+                                     r,\n+                                     snippet(cx, span, \"_\")));\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n-   -> Option<(Span, &'static str)> {\n+fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyStruct(..) => match_type(cx, ty, &VEC_PATH),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n             ty::TyBox(ref inner) => may_slice(cx, inner),\n-            _ => false\n+            _ => false,\n         }\n     }\n     if let ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" &&\n-               may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n+        if &name.node.as_str() == &\"iter\" && may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n             Some((args[0].span, \"&\"))\n         } else {\n             None\n@@ -476,10 +506,14 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n         match ty.sty {\n             ty::TySlice(_) => Some((expr.span, \"\")),\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n-            ty::TyBox(ref inner) => if may_slice(cx, inner) {\n-                Some((expr.span, \"\"))\n-            } else { None },\n-            _ => None\n+            ty::TyBox(ref inner) => {\n+                if may_slice(cx, inner) {\n+                    Some((expr.span, \"\"))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n         }\n     }\n }\n@@ -693,7 +727,7 @@ fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq\n     false\n }\n \n-// Given a `Result<T, E>` type, return its error type (`E`)\n+/// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {\n         return None;\n@@ -706,9 +740,9 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n-// This checks whether a given type is known to implement Debug. It's\n-// conservative, i.e. it should not return false positives, but will return\n-// false negatives.\n+/// This checks whether a given type is known to implement Debug. It's\n+/// conservative, i.e. it should not return false positives, but will return\n+/// false negatives.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     let no_ref_ty = walk_ptrs_ty(ty);\n     let debug = match cx.tcx.lang_items.debug_trait() {\n@@ -728,162 +762,48 @@ fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     debug_impl_exists\n }\n \n-const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [(\"into_\", &[SelfKind::Value]),\n-                                                               (\"to_\", &[SelfKind::Ref]),\n-                                                               (\"as_\", &[SelfKind::Ref, SelfKind::RefMut]),\n-                                                               (\"is_\", &[SelfKind::Ref, SelfKind::No]),\n-                                                               (\"from_\", &[SelfKind::No])];\n-\n-const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [(\"add\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Add\"),\n-                                                                                     (\"sub\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Sub\"),\n-                                                                                     (\"mul\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Mul\"),\n-                                                                                     (\"div\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Div\"),\n-                                                                                     (\"rem\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Rem\"),\n-                                                                                     (\"shl\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Shl\"),\n-                                                                                     (\"shr\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Shr\"),\n-                                                                                     (\"bitand\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::BitAnd\"),\n-                                                                                     (\"bitor\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::BitOr\"),\n-                                                                                     (\"bitxor\",\n-                                                                                      2,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::BitXor\"),\n-                                                                                     (\"neg\",\n-                                                                                      1,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Neg\"),\n-                                                                                     (\"not\",\n-                                                                                      1,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::ops::Not\"),\n-                                                                                     (\"drop\",\n-                                                                                      1,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Unit,\n-                                                                                      \"std::ops::Drop\"),\n-                                                                                     (\"index\",\n-                                                                                      2,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::ops::Index\"),\n-                                                                                     (\"index_mut\",\n-                                                                                      2,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::ops::IndexMut\"),\n-                                                                                     (\"deref\",\n-                                                                                      1,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::ops::Deref\"),\n-                                                                                     (\"deref_mut\",\n-                                                                                      1,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::ops::DerefMut\"),\n-                                                                                     (\"clone\",\n-                                                                                      1,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::clone::Clone\"),\n-                                                                                     (\"borrow\",\n-                                                                                      1,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::borrow::Borrow\"),\n-                                                                                     (\"borrow_mut\",\n-                                                                                      1,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::borrow::BorrowMut\"),\n-                                                                                     (\"as_ref\",\n-                                                                                      1,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::convert::AsRef\"),\n-                                                                                     (\"as_mut\",\n-                                                                                      1,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Ref,\n-                                                                                      \"std::convert::AsMut\"),\n-                                                                                     (\"eq\",\n-                                                                                      2,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Bool,\n-                                                                                      \"std::cmp::PartialEq\"),\n-                                                                                     (\"cmp\",\n-                                                                                      2,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::cmp::Ord\"),\n-                                                                                     (\"default\",\n-                                                                                      0,\n-                                                                                      SelfKind::No,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::default::Default\"),\n-                                                                                     (\"hash\",\n-                                                                                      2,\n-                                                                                      SelfKind::Ref,\n-                                                                                      OutType::Unit,\n-                                                                                      \"std::hash::Hash\"),\n-                                                                                     (\"next\",\n-                                                                                      1,\n-                                                                                      SelfKind::RefMut,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::iter::Iterator\"),\n-                                                                                     (\"into_iter\",\n-                                                                                      1,\n-                                                                                      SelfKind::Value,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::iter::IntoIterator\"),\n-                                                                                     (\"from_iter\",\n-                                                                                      1,\n-                                                                                      SelfKind::No,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::iter::FromIterator\"),\n-                                                                                     (\"from_str\",\n-                                                                                      1,\n-                                                                                      SelfKind::No,\n-                                                                                      OutType::Any,\n-                                                                                      \"std::str::FromStr\")];\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [\n+    (\"into_\", &[SelfKind::Value]),\n+    (\"to_\", &[SelfKind::Ref]),\n+    (\"as_\", &[SelfKind::Ref, SelfKind::RefMut]),\n+    (\"is_\", &[SelfKind::Ref, SelfKind::No]),\n+    (\"from_\", &[SelfKind::No]),\n+];\n+\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n+    (\"add\", 2, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n+    (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n+    (\"mul\", 2, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n+    (\"div\", 2, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n+    (\"rem\", 2, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n+    (\"shl\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n+    (\"shr\", 2, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n+    (\"bitand\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n+    (\"bitor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n+    (\"bitxor\", 2, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n+    (\"neg\", 1, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n+    (\"not\", 1, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n+    (\"drop\", 1, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n+    (\"index\", 2, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n+    (\"index_mut\", 2, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n+    (\"deref\", 1, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n+    (\"deref_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n+    (\"clone\", 1, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n+    (\"borrow\", 1, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n+    (\"borrow_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n+    (\"as_ref\", 1, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n+    (\"as_mut\", 1, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n+    (\"eq\", 2, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n+    (\"cmp\", 2, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n+    (\"default\", 0, SelfKind::No, OutType::Any, \"std::default::Default\"),\n+    (\"hash\", 2, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n+    (\"next\", 1, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n+    (\"into_iter\", 1, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n+    (\"from_iter\", 1, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n+    (\"from_str\", 1, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n+];\n \n #[derive(Clone, Copy)]\n enum SelfKind {"}, {"sha": "d436d98c981105ebbc2b3412a5c3a7c27b81588b", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -376,8 +376,7 @@ impl LintPass for UsedUnderscoreBinding {\n }\n \n impl LateLintPass for UsedUnderscoreBinding {\n-    #[allow(unused_attributes)]\n-    #[rustfmt_skip]\n+    #[cfg_attr(rustfmt, rustfmt_skip)]\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_attributes_expansion(cx, expr) {\n     // Don't lint things expanded by #[derive(...)], etc"}, {"sha": "1573aff2a4da88438da2de7a58b679b64c8419a2", "filename": "src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -110,7 +110,7 @@ impl EarlyLintPass for MiscEarly {\n                                            arg_name[1..].to_owned()));\n                     }\n                 } else {\n-                    registered_names.insert(arg_name, arg.pat.span.clone());\n+                    registered_names.insert(arg_name, arg.pat.span);\n                 }\n             }\n         }"}, {"sha": "930952bdbaf89363dece0c4dc87dddc114d472a1", "filename": "src/print.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -37,10 +37,7 @@ impl LateLintPass for PrintLint {\n                             None => (span, \"print\"),\n                         };\n \n-                        span_lint(cx,\n-                                  PRINT_STDOUT,\n-                                  span,\n-                                  &format!(\"use of `{}!`\", name));\n+                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n                     }\n                 }\n             }"}, {"sha": "1beb00e9056125fa47609500e2694ef5e55346e3", "filename": "src/shadow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -211,8 +211,8 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init: &\n                                         &format!(\"{} is shadowed by {} which reuses the original value\",\n                                                  snippet(cx, lspan, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n-                                                 expr.span,\n-                                                 \"initialization happens here\");\n+                                        expr.span,\n+                                        \"initialization happens here\");\n             note_orig(cx, db, SHADOW_REUSE, prev_span);\n         } else {\n             let db = span_note_and_lint(cx,\n@@ -221,8 +221,8 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init: &\n                                         &format!(\"{} is shadowed by {}\",\n                                                  snippet(cx, lspan, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n-                                                 expr.span,\n-                                                 \"initialization happens here\");\n+                                        expr.span,\n+                                        \"initialization happens here\");\n             note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n         }\n "}, {"sha": "78fb45cd6cfc04b60f05007d2f8d6161922f2b20", "filename": "src/utils.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -209,7 +209,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n         loop {\n             let segment = match path_it.next() {\n                 Some(segment) => segment,\n-                None => return None\n+                None => return None,\n             };\n \n             for item in &mem::replace(&mut items, vec![]) {\n@@ -229,8 +229,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n                 }\n             }\n         }\n-    }\n-    else {\n+    } else {\n         None\n     }\n }\n@@ -250,13 +249,17 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n \n /// Check whether a type implements a trait.\n /// See also `get_trait_def_id`.\n-pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId, ty_params: Option<Vec<ty::Ty<'tcx>>>) -> bool {\n+pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId,\n+                                  ty_params: Option<Vec<ty::Ty<'tcx>>>)\n+                                  -> bool {\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None);\n     let obligation = traits::predicate_for_trait_def(cx.tcx,\n                                                      traits::ObligationCause::dummy(),\n-                                                     trait_id, 0, ty,\n+                                                     trait_id,\n+                                                     0,\n+                                                     ty,\n                                                      ty_params.unwrap_or_default());\n \n     traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n@@ -658,6 +661,7 @@ pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span>\n                 (ei.callee.name(), ei.call_site)\n             })\n         });\n+\n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name.as_str() == name => return Some(new_span),\n             None => return None,"}, {"sha": "bd630211f19fb0fcda7eecd94ad8ea8e22b3c464", "filename": "tests/compile-fail/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/tests%2Fcompile-fail%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/tests%2Fcompile-fail%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmap_clone.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -3,7 +3,7 @@\n #![plugin(clippy)]\n #![deny(map_clone)]\n \n-#![allow(unused)]\n+#![allow(clone_on_copy, unused)]\n \n use std::ops::Deref;\n "}, {"sha": "f998a83e83158fe3bd55d92e10f859d975585e9a", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=4d1b0bda8d77e889e308ee8dd2fd35b6b0c5304f", "patch": "@@ -312,14 +312,25 @@ fn use_extend_from_slice() {\n     //~^ERROR use of `extend`\n     //~| HELP try this\n     //~| SUGGESTION v.extend_from_slice(&vec![\"Some\", \"more\"]);\n-    \n+\n     v.extend(vec![\"And\", \"even\", \"more\"].iter()); //~ERROR use of `extend`\n     let o : Option<&'static str> = None;\n     v.extend(o);\n     v.extend(Some(\"Bye\"));\n     v.extend(vec![\"Not\", \"like\", \"this\"]);\n-    v.extend([\"But\", \"this\"].iter()); \n+    v.extend([\"But\", \"this\"].iter());\n     //~^ERROR use of `extend\n     //~| HELP try this\n     //~| SUGGESTION v.extend_from_slice(&[\"But\", \"this\"]);\n }\n+\n+fn clone_on_copy() {\n+    42.clone(); //~ERROR using `clone` on a `Copy` type\n+    vec![1].clone(); // ok, not a Copy type\n+    Some(vec![1]).clone(); // ok, not a Copy type\n+}\n+\n+fn clone_on_copy_generic<T: Copy>(t: T) {\n+    t.clone(); //~ERROR using `clone` on a `Copy` type\n+    Some(t).clone(); //~ERROR using `clone` on a `Copy` type\n+}"}]}