{"sha": "79376abb43e3e1e607b5307e85dd43251ad6c5e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Mzc2YWJiNDNlM2UxZTYwN2I1MzA3ZTg1ZGQ0MzI1MWFkNmM1ZTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-26T08:19:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-26T08:19:18Z"}, "message": "Merge #1823\n\n1823: Support type coercion r=flodiebold a=uHOOCCOOHu\n\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>", "tree": {"sha": "03ab755672e9b973bbcbb9fd86f9d2fdf4f0e1ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03ab755672e9b973bbcbb9fd86f9d2fdf4f0e1ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79376abb43e3e1e607b5307e85dd43251ad6c5e3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdjHSGCRBK7hj4Ov3rIwAAdHIIAJuAaJW/aaA5AgLGNlskSovp\ni1WNNe/srjgF28ZLPjJIVmt+xf0O5GuNQZRECvfbDGmKA7PHS72NOK43gCzb1anM\nExQ2JlKEYz24msumg92mEJPH7xkXHYdkfGGfv5yR4qf/tl0riBtU62QS02TJI2YO\np5fWJuVbMew0pvJH2vvIpsnF6dKT3mDNaIIL1R5Ec6g+JIjU8PpUFn88o3JEzlvI\n6Ci3QnyfxMkQecm65nat8qL2Tq/sva9FxNvPDLBebHOwjx8XzlInM1dmoQmFqvCb\nU7GlkSIStIc/XvDCs1dKuBSz888nm78v5xI+sk70qdZ18jz6Q1/YdFXEEetJoyI=\n=yHIY\n-----END PGP SIGNATURE-----\n", "payload": "tree 03ab755672e9b973bbcbb9fd86f9d2fdf4f0e1ba\nparent 6c1878009db50b81fd70b7eb93a76d57a366c7ba\nparent 29e56b8ee480828b81011cfa16c055fa0c9c89fe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569485958 +0000\ncommitter GitHub <noreply@github.com> 1569485958 +0000\n\nMerge #1823\n\n1823: Support type coercion r=flodiebold a=uHOOCCOOHu\n\n\n\nCo-authored-by: uHOOCCOOHu <hooccooh1896@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79376abb43e3e1e607b5307e85dd43251ad6c5e3", "html_url": "https://github.com/rust-lang/rust/commit/79376abb43e3e1e607b5307e85dd43251ad6c5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79376abb43e3e1e607b5307e85dd43251ad6c5e3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c1878009db50b81fd70b7eb93a76d57a366c7ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1878009db50b81fd70b7eb93a76d57a366c7ba", "html_url": "https://github.com/rust-lang/rust/commit/6c1878009db50b81fd70b7eb93a76d57a366c7ba"}, {"sha": "29e56b8ee480828b81011cfa16c055fa0c9c89fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e56b8ee480828b81011cfa16c055fa0c9c89fe", "html_url": "https://github.com/rust-lang/rust/commit/29e56b8ee480828b81011cfa16c055fa0c9c89fe"}], "stats": {"total": 1475, "additions": 1218, "deletions": 257}, "files": [{"sha": "b2111be053ccc88027548191003d2d5d4d8a8a10", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -13,4 +13,5 @@ test_utils::marks!(\n     infer_while_let\n     macro_rules_from_other_crates_are_visible_with_macro_use\n     prelude_is_macro_use\n+    coerce_merge_fail_fallback\n );"}, {"sha": "db337735725d1efea691d44cd98b332b96ffff01", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 436, "deletions": 93, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -14,7 +14,7 @@\n //! the `ena` crate, which is extracted from rustc.\n \n use std::borrow::Cow;\n-use std::iter::repeat;\n+use std::iter::{repeat, repeat_with};\n use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n@@ -42,6 +42,7 @@ use crate::{\n         RecordFieldPat, Statement, UnaryOp,\n     },\n     generics::{GenericParams, HasGenericParams},\n+    lang_item::LangItemTarget,\n     name,\n     nameres::Namespace,\n     path::{known, GenericArg, GenericArgs},\n@@ -188,6 +189,21 @@ struct InferenceContext<'a, D: HirDatabase> {\n     result: InferenceResult,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n+\n+    /// Impls of `CoerceUnsized` used in coercion.\n+    /// (from_ty_ctor, to_ty_ctor) => coerce_generic_index\n+    // FIXME: Use trait solver for this.\n+    // Chalk seems unable to work well with builtin impl of `Unsize` now.\n+    coerce_unsized_map: FxHashMap<(TypeCtor, TypeCtor), usize>,\n+}\n+\n+macro_rules! ty_app {\n+    ($ctor:pat, $param:pat) => {\n+        Ty::Apply(ApplicationTy { ctor: $ctor, parameters: $param })\n+    };\n+    ($ctor:pat) => {\n+        ty_app!($ctor, _)\n+    };\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -198,12 +214,52 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: lower::trait_env(db, &resolver),\n+            coerce_unsized_map: Self::init_coerce_unsized_map(db, &resolver),\n             db,\n             body,\n             resolver,\n         }\n     }\n \n+    fn init_coerce_unsized_map(\n+        db: &'a D,\n+        resolver: &Resolver,\n+    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n+        let krate = resolver.krate().unwrap();\n+        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n+            _ => return FxHashMap::default(),\n+        };\n+\n+        impls\n+            .iter()\n+            .filter_map(|impl_block| {\n+                // `CoerseUnsized` has one generic parameter for the target type.\n+                let trait_ref = impl_block.target_trait_ref(db)?;\n+                let cur_from_ty = trait_ref.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+\n+                match (&cur_from_ty, cur_to_ty) {\n+                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n+                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n+                        // This works for smart-pointer-like coercion, which covers all impls from std.\n+                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n+                            match (ty1, ty2) {\n+                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n+                                    if p1 != p2 =>\n+                                {\n+                                    Some(((*ctor1, *ctor2), i))\n+                                }\n+                                _ => None,\n+                            }\n+                        })\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n@@ -278,27 +334,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         match (&*ty1, &*ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n             (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n                 self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n             }\n+            _ => self.unify_inner_trivial(&ty1, &ty2),\n+        }\n+    }\n+\n+    fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            | (\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n+            ) => {\n                 // both type vars are unknown since we tried to resolve them\n                 self.var_unification_table.union(*tv1, *tv2);\n                 true\n             }\n+\n+            // The order of MaybeNeverTypeVar matters here.\n+            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n+            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n             (Ty::Infer(InferTy::TypeVar(tv)), other)\n             | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n+            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n+            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n+            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true\n             }\n+\n             _ => false,\n         }\n     }\n@@ -315,6 +389,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n     }\n \n+    fn new_maybe_never_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::MaybeNeverTypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n@@ -795,17 +875,304 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ret_ty\n     }\n \n-    /// This is similar to unify, but it makes the first type coerce to the\n-    /// second one.\n-    fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        if is_never(from_ty) {\n-            // ! coerces to any type\n-            true\n+    /// Infer type of expression with possibly implicit coerce to the expected type.\n+    /// Return the type after possible coercion.\n+    fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(expr, &expected);\n+        let ty = if !self.coerce(&ty, &expected.ty) {\n+            self.result\n+                .type_mismatches\n+                .insert(expr, TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() });\n+            // Return actual type when type mismatch.\n+            // This is needed for diagnostic when return type mismatch.\n+            ty\n+        } else if expected.ty == Ty::Unknown {\n+            ty\n         } else {\n-            self.unify(from_ty, to_ty)\n+            expected.ty.clone()\n+        };\n+\n+        self.resolve_ty_as_possible(&mut vec![], ty)\n+    }\n+\n+    /// Merge two types from different branches, with possible implicit coerce.\n+    ///\n+    /// Note that it is only possible that one type are coerced to another.\n+    /// Coercing both types to another least upper bound type is not possible in rustc,\n+    /// which will simply result in \"incompatible types\" error.\n+    fn coerce_merge_branch<'t>(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n+        if self.coerce(ty1, ty2) {\n+            ty2.clone()\n+        } else if self.coerce(ty2, ty1) {\n+            ty1.clone()\n+        } else {\n+            tested_by!(coerce_merge_fail_fallback);\n+            // For incompatible types, we use the latter one as result\n+            // to be better recovery for `if` without `else`.\n+            ty2.clone()\n+        }\n+    }\n+\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    ///\n+    /// See: https://doc.rust-lang.org/nomicon/coercions.html\n+    fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        self.coerce_inner(from_ty, &to_ty)\n+    }\n+\n+    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n+        match (&from_ty, to_ty) {\n+            // Never type will make type variable to fallback to Never Type instead of Unknown.\n+            (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n+                let var = self.new_maybe_never_type_var();\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                return true;\n+            }\n+            (ty_app!(TypeCtor::Never), _) => return true,\n+\n+            // Trivial cases, this should go after `never` check to\n+            // avoid infer result type to be never\n+            _ => {\n+                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        // Pointer weakening and function to pointer\n+        match (&mut from_ty, to_ty) {\n+            // `*mut T`, `&mut T, `&T`` -> `*const T`\n+            // `&mut T` -> `&T`\n+            // `&mut T` -> `*mut T`\n+            (ty_app!(c1@TypeCtor::RawPtr(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::Ref(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(Mutability::Mut)), ty_app!(c2@TypeCtor::RawPtr(_))) => {\n+                *c1 = *c2;\n+            }\n+\n+            // Illegal mutablity conversion\n+            (\n+                ty_app!(TypeCtor::RawPtr(Mutability::Shared)),\n+                ty_app!(TypeCtor::RawPtr(Mutability::Mut)),\n+            )\n+            | (\n+                ty_app!(TypeCtor::Ref(Mutability::Shared)),\n+                ty_app!(TypeCtor::Ref(Mutability::Mut)),\n+            ) => return false,\n+\n+            // `{function_type}` -> `fn()`\n+            (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n+                match from_ty.callable_sig(self.db) {\n+                    None => return false,\n+                    Some(sig) => {\n+                        let num_args = sig.params_and_return.len() as u16 - 1;\n+                        from_ty =\n+                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n+            return ret;\n+        }\n+\n+        // Auto Deref if cannot coerce\n+        match (&from_ty, to_ty) {\n+            // FIXME: DerefMut\n+            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n+                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n+            }\n+\n+            // Otherwise, normal unify\n+            _ => self.unify(&from_ty, to_ty),\n+        }\n+    }\n+\n+    /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n+    ///\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n+        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n+            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n+            _ => return None,\n+        };\n+\n+        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n+\n+        // Check `Unsize` first\n+        match self.check_unsize_and_coerce(\n+            st1.0.get(coerce_generic_index)?,\n+            st2.0.get(coerce_generic_index)?,\n+            0,\n+        ) {\n+            Some(true) => {}\n+            ret => return ret,\n+        }\n+\n+        let ret = st1\n+            .iter()\n+            .zip(st2.iter())\n+            .enumerate()\n+            .filter(|&(idx, _)| idx != coerce_generic_index)\n+            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+        Some(ret)\n+    }\n+\n+    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n+    ///\n+    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n+    ///\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n+    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n+        if depth > 1000 {\n+            panic!(\"Infinite recursion in coercion\");\n+        }\n+\n+        match (&from_ty, &to_ty) {\n+            // `[T; N]` -> `[T]`\n+            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n+                Some(self.unify(&st1[0], &st2[0]))\n+            }\n+\n+            // `T` -> `dyn Trait` when `T: Trait`\n+            (_, Ty::Dyn(_)) => {\n+                // FIXME: Check predicates\n+                Some(true)\n+            }\n+\n+            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n+            (\n+                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n+                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n+            ) => {\n+                if len1 != len2 || *len1 == 0 {\n+                    return None;\n+                }\n+\n+                match self.check_unsize_and_coerce(\n+                    st1.last().unwrap(),\n+                    st2.last().unwrap(),\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                let ret = st1[..st1.len() - 1]\n+                    .iter()\n+                    .zip(&st2[..st2.len() - 1])\n+                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n+\n+                Some(ret)\n+            }\n+\n+            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n+            // - T: Unsize<U>\n+            // - Foo is a struct\n+            // - Only the last field of Foo has a type involving T\n+            // - T is not part of the type of any other fields\n+            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n+            (\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n+            ) if struct1 == struct2 => {\n+                let fields = struct1.fields(self.db);\n+                let (last_field, prev_fields) = fields.split_last()?;\n+\n+                // Get the generic parameter involved in the last field.\n+                let unsize_generic_index = {\n+                    let mut index = None;\n+                    let mut multiple_param = false;\n+                    last_field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } => {\n+                            if index.is_none() {\n+                                index = Some(idx);\n+                            } else if Some(idx) != index {\n+                                multiple_param = true;\n+                            }\n+                        }\n+                        _ => {}\n+                    });\n+\n+                    if multiple_param {\n+                        return None;\n+                    }\n+                    index?\n+                };\n+\n+                // Check other fields do not involve it.\n+                let mut multiple_used = false;\n+                prev_fields.iter().for_each(|field| {\n+                    field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n+                            multiple_used = true\n+                        }\n+                        _ => {}\n+                    })\n+                });\n+                if multiple_used {\n+                    return None;\n+                }\n+\n+                let unsize_generic_index = unsize_generic_index as usize;\n+\n+                // Check `Unsize` first\n+                match self.check_unsize_and_coerce(\n+                    st1.get(unsize_generic_index)?,\n+                    st2.get(unsize_generic_index)?,\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                // Then unify other parameters\n+                let ret = st1\n+                    .iter()\n+                    .zip(st2.iter())\n+                    .enumerate()\n+                    .filter(|&(idx, _)| idx != unsize_generic_index)\n+                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+                Some(ret)\n+            }\n+\n+            _ => None,\n         }\n     }\n \n+    /// Unify `from_ty` to `to_ty` with optional auto Deref\n+    ///\n+    /// Note that the parameters are already stripped the outer reference.\n+    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n+        let to_ty = self.resolve_ty_shallow(&to_ty);\n+        // FIXME: Auto DerefMut\n+        for derefed_ty in\n+            autoderef::autoderef(self.db, &self.resolver.clone(), canonicalized.value.clone())\n+        {\n+            let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n+            match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n+                // Stop when constructor matches.\n+                (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n+                    // It will not recurse to `coerce`.\n+                    return self.unify_substs(st1, st2, 0);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        false\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(tgt_expr, expected);\n         let could_unify = self.unify(&ty, &expected.ty);\n@@ -828,15 +1195,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n                 let then_ty = self.infer_expr_inner(*then_branch, &expected);\n-                self.coerce(&then_ty, &expected.ty);\n-\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n-                self.coerce(&else_ty, &expected.ty);\n \n-                expected.ty.clone()\n+                self.coerce_merge_branch(&then_ty, &else_ty)\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -932,13 +1296,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n-                let expected = if expected.ty == Ty::Unknown {\n-                    Expectation::has_type(self.new_type_var())\n-                } else {\n-                    expected.clone()\n-                };\n \n-                let mut arm_tys = Vec::with_capacity(arms.len());\n+                let mut result_ty = self.new_maybe_never_type_var();\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -950,16 +1309,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    arm_tys.push(self.infer_expr_inner(arm.expr, &expected));\n-                }\n-\n-                let lub_ty = calculate_least_upper_bound(expected.ty, &arm_tys);\n \n-                for arm_ty in &arm_tys {\n-                    self.coerce(arm_ty, &lub_ty);\n+                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n                 }\n \n-                lub_ty\n+                result_ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -986,6 +1341,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n                 }\n \n+                self.unify(&ty, &expected.ty);\n+\n                 let substs = ty.substs().unwrap_or_else(Substs::empty);\n                 for (field_idx, field) in fields.iter().enumerate() {\n                     let field_ty = def_id\n@@ -1001,7 +1358,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         })\n                         .map_or(Ty::Unknown, |field| field.ty(self.db))\n                         .subst(&substs);\n-                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n+                    self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n                     self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n@@ -1171,35 +1528,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::Unknown\n             }\n             Expr::Tuple { exprs } => {\n-                let mut ty_vec = Vec::with_capacity(exprs.len());\n-                for arg in exprs.iter() {\n-                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n+                let mut tys = match &expected.ty {\n+                    ty_app!(TypeCtor::Tuple { .. }, st) => st\n+                        .iter()\n+                        .cloned()\n+                        .chain(repeat_with(|| self.new_type_var()))\n+                        .take(exprs.len())\n+                        .collect::<Vec<_>>(),\n+                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                };\n+\n+                for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n+                    self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                Ty::apply(\n-                    TypeCtor::Tuple { cardinality: ty_vec.len() as u16 },\n-                    Substs(ty_vec.into()),\n-                )\n+                Ty::apply(TypeCtor::Tuple { cardinality: tys.len() as u16 }, Substs(tys.into()))\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match &expected.ty {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Slice | TypeCtor::Array => {\n-                            Ty::clone(&a_ty.parameters.as_single())\n-                        }\n-                        _ => self.new_type_var(),\n-                    },\n+                    ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n+                        st.as_single().clone()\n+                    }\n                     _ => self.new_type_var(),\n                 };\n \n                 match array {\n                     Array::ElementList(items) => {\n                         for expr in items.iter() {\n-                            self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n                         }\n                     }\n                     Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr(*initializer, &Expectation::has_type(elem_ty.clone()));\n+                        self.infer_expr_coerce(\n+                            *initializer,\n+                            &Expectation::has_type(elem_ty.clone()),\n+                        );\n                         self.infer_expr(\n                             *repeat,\n                             &Expectation::has_type(Ty::simple(TypeCtor::Int(\n@@ -1246,24 +1609,33 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Statement::Let { pat, type_ref, initializer } => {\n                     let decl_ty =\n                         type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n-                    let decl_ty = self.insert_type_vars(decl_ty);\n-                    let ty = if let Some(expr) = initializer {\n-                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n-                        expr_ty\n-                    } else {\n-                        decl_ty\n-                    };\n \n+                    // Always use the declared type when specified\n+                    let mut ty = decl_ty.clone();\n+\n+                    if let Some(expr) = initializer {\n+                        let actual_ty =\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n+                        if decl_ty == Ty::Unknown {\n+                            ty = actual_ty;\n+                        }\n+                    }\n+\n+                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n             }\n         }\n-        let ty =\n-            if let Some(expr) = tail { self.infer_expr_inner(expr, expected) } else { Ty::unit() };\n-        ty\n+\n+        if let Some(expr) = tail {\n+            self.infer_expr_coerce(expr, expected)\n+        } else {\n+            self.coerce(&Ty::unit(), &expected.ty);\n+            Ty::unit()\n+        }\n     }\n \n     fn check_call_arguments(&mut self, args: &[ExprId], param_tys: &[Ty]) {\n@@ -1285,7 +1657,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n \n                 let param_ty = self.normalize_associated_types_in(param_ty);\n-                self.infer_expr(arg, &Expectation::has_type(param_ty));\n+                self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n             }\n         }\n     }\n@@ -1400,12 +1772,16 @@ pub enum InferTy {\n     TypeVar(TypeVarId),\n     IntVar(TypeVarId),\n     FloatVar(TypeVarId),\n+    MaybeNeverTypeVar(TypeVarId),\n }\n \n impl InferTy {\n     fn to_inner(self) -> TypeVarId {\n         match self {\n-            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n+            InferTy::TypeVar(ty)\n+            | InferTy::IntVar(ty)\n+            | InferTy::FloatVar(ty)\n+            | InferTy::MaybeNeverTypeVar(ty) => ty,\n         }\n     }\n \n@@ -1418,6 +1794,7 @@ impl InferTy {\n             InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(\n                 primitive::UncertainFloatTy::Known(primitive::FloatTy::f64()),\n             )),\n+            InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }\n }\n@@ -1475,37 +1852,3 @@ mod diagnostics {\n         }\n     }\n }\n-\n-fn is_never(ty: &Ty) -> bool {\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) = ty {\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: &[Ty]) -> Ty {\n-    let mut all_never = true;\n-    let mut last_never_ty = None;\n-    let mut least_upper_bound = expected_ty;\n-\n-    for actual_ty in actual_tys {\n-        if is_never(actual_ty) {\n-            last_never_ty = Some(actual_ty.clone());\n-        } else {\n-            all_never = false;\n-            least_upper_bound = match (actual_ty, &least_upper_bound) {\n-                (_, Ty::Unknown)\n-                | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n-                | (Ty::Apply(_), _) => actual_ty.clone(),\n-                _ => least_upper_bound,\n-            }\n-        }\n-    }\n-\n-    if all_never && last_never_ty.is_some() {\n-        last_never_ty.unwrap()\n-    } else {\n-        least_upper_bound\n-    }\n-}"}, {"sha": "b6ebee3b1b2a1ce35ef626be99161119c44341f8", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -63,6 +63,7 @@ where\n                         InferTy::TypeVar(_) => InferTy::TypeVar(root),\n                         InferTy::IntVar(_) => InferTy::IntVar(root),\n                         InferTy::FloatVar(_) => InferTy::FloatVar(root),\n+                        InferTy::MaybeNeverTypeVar(_) => InferTy::MaybeNeverTypeVar(root),\n                     };\n                     let position = self.add(free_var);\n                     Ty::Bound(position as u32)"}, {"sha": "4362bb27a3c65ef6f4c58d37aae47a76737212b0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 165, "deletions": 164, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -20,6 +20,9 @@ use crate::{\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n+mod never_type;\n+mod coercion;\n+\n #[test]\n fn infer_await() {\n     let (mut db, pos) = MockDatabase::with_position(\n@@ -236,17 +239,23 @@ fn test() {\n     let a = 1isize;\n     let b: usize = 1;\n     let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n }\n \"#),\n         @r###\"\n-\n-    [11; 71) '{     ...= b; }': ()\n+    [11; 118) '{     ...= e; }': ()\n     [21; 22) 'a': isize\n     [25; 31) '1isize': isize\n     [41; 42) 'b': usize\n     [52; 53) '1': usize\n     [63; 64) 'c': usize\n     [67; 68) 'b': usize\n+    [78; 79) 'd': u32\n+    [94; 95) 'e': i32\n+    [105; 106) 'f': i32\n+    [114; 115) 'e': i32\n     \"###\n     );\n }\n@@ -328,14 +337,14 @@ fn test() {\n \"#),\n         @r###\"\n     [45; 49) 'self': &[T]\n-    [56; 79) '{     ...     }': !\n+    [56; 79) '{     ...     }': T\n     [66; 73) 'loop {}': !\n     [71; 73) '{}': ()\n     [133; 160) '{     ...o\"); }': ()\n     [139; 149) '<[_]>::foo': fn foo<u8>(&[T]) -> T\n     [139; 157) '<[_]>:...\"foo\")': u8\n     [150; 156) 'b\"foo\"': &[u8]\n-\"###\n+    \"###\n     );\n }\n \n@@ -800,6 +809,130 @@ fn test2(a1: *const A, a2: *mut A) {\n     );\n }\n \n+#[test]\n+fn infer_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(T);\n+\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test() {\n+    let t = A::foo(&&B(B(A(42))));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [139; 143) 'self': &A<T>\n+    [151; 174) '{     ...     }': &T\n+    [161; 168) '&self.0': &T\n+    [162; 166) 'self': &A<T>\n+    [162; 168) 'self.0': T\n+    [255; 259) 'self': &B<T>\n+    [278; 301) '{     ...     }': &T\n+    [288; 295) '&self.0': &T\n+    [289; 293) 'self': &B<T>\n+    [289; 295) 'self.0': T\n+    [315; 353) '{     ...))); }': ()\n+    [325; 326) 't': &i32\n+    [329; 335) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [329; 350) 'A::foo...42))))': &i32\n+    [336; 349) '&&B(B(A(42)))': &&B<B<A<i32>>>\n+    [337; 349) '&B(B(A(42)))': &B<B<A<i32>>>\n+    [338; 339) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [338; 349) 'B(B(A(42)))': B<B<A<i32>>>\n+    [340; 341) 'B': B<A<i32>>(T) -> B<T>\n+    [340; 348) 'B(A(42))': B<A<i32>>\n+    [342; 343) 'A': A<i32>(T) -> A<T>\n+    [342; 347) 'A(42)': A<i32>\n+    [344; 346) '42': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_method_argument_autoderef() {\n+    assert_snapshot!(\n+        infer(r#\"\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct A<T>(*mut T);\n+\n+impl<T> A<T> {\n+    fn foo(&self, x: &A<T>) -> &T {\n+        &*x.0\n+    }\n+}\n+\n+struct B<T>(T);\n+\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn test(a: A<i32>) {\n+    let t = A(0 as *mut _).foo(&&B(B(a)));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [144; 148) 'self': &A<T>\n+    [150; 151) 'x': &A<T>\n+    [166; 187) '{     ...     }': &T\n+    [176; 181) '&*x.0': &T\n+    [177; 181) '*x.0': T\n+    [178; 179) 'x': &A<T>\n+    [178; 181) 'x.0': *mut T\n+    [268; 272) 'self': &B<T>\n+    [291; 314) '{     ...     }': &T\n+    [301; 308) '&self.0': &T\n+    [302; 306) 'self': &B<T>\n+    [302; 308) 'self.0': T\n+    [326; 327) 'a': A<i32>\n+    [337; 383) '{     ...))); }': ()\n+    [347; 348) 't': &i32\n+    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 365) 'A(0 as *mut _)': A<i32>\n+    [351; 380) 'A(0 as...B(a)))': &i32\n+    [353; 354) '0': i32\n+    [353; 364) '0 as *mut _': *mut i32\n+    [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n+    [371; 379) '&B(B(a))': &B<B<A<i32>>>\n+    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 379) 'B(B(a))': B<B<A<i32>>>\n+    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 378) 'B(a)': B<A<i32>>\n+    [376; 377) 'a': A<i32>\n+\"###\n+    );\n+}\n+\n #[test]\n fn bug_484() {\n     assert_snapshot!(\n@@ -983,14 +1116,12 @@ fn test(x: &str, y: isize) {\n \n     let b = [a, [\"b\"]];\n     let x: [u8; 0] = [];\n-    let z: &[u8] = &[1, 2, 3];\n }\n \"#),\n         @r###\"\n-\n     [9; 10) 'x': &str\n     [18; 19) 'y': isize\n-    [28; 324) '{     ... 3]; }': ()\n+    [28; 293) '{     ... []; }': ()\n     [38; 39) 'a': [&str;_]\n     [42; 45) '[x]': [&str;_]\n     [43; 44) 'x': &str\n@@ -1040,12 +1171,6 @@ fn test(x: &str, y: isize) {\n     [260; 263) '\"b\"': &str\n     [275; 276) 'x': [u8;_]\n     [288; 290) '[]': [u8;_]\n-    [300; 301) 'z': &[u8;_]\n-    [311; 321) '&[1, 2, 3]': &[u8;_]\n-    [312; 321) '[1, 2, 3]': [u8;_]\n-    [313; 314) '1': u8\n-    [316; 317) '2': u8\n-    [319; 320) '3': u8\n     \"###\n     );\n }\n@@ -1767,8 +1892,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [80; 104) '{     ...     }': !\n+    [80; 104) '{     ...     }': Gen<T>\n     [90; 98) 'loop { }': !\n     [95; 98) '{ }': ()\n     [118; 146) '{     ...e(); }': ()\n@@ -1798,8 +1922,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [76; 100) '{     ...     }': !\n+    [76; 100) '{     ...     }': Gen<T>\n     [86; 94) 'loop { }': !\n     [91; 94) '{ }': ()\n     [114; 149) '{     ...e(); }': ()\n@@ -1830,8 +1953,7 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n-    [102; 126) '{     ...     }': !\n+    [102; 126) '{     ...     }': Gen<u32, T>\n     [112; 120) 'loop { }': !\n     [117; 120) '{ }': ()\n     [140; 180) '{     ...e(); }': ()\n@@ -1973,7 +2095,6 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [11; 48) '{     ...&y]; }': ()\n     [21; 22) 'y': &{unknown}\n     [25; 32) 'unknown': &{unknown}\n@@ -1998,14 +2119,13 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [11; 80) '{     ...x)]; }': ()\n     [21; 22) 'x': &&{unknown}\n     [25; 32) 'unknown': &&{unknown}\n     [42; 43) 'y': &&{unknown}\n     [46; 53) 'unknown': &&{unknown}\n-    [59; 77) '[(x, y..., &x)]': [(&&{unknown}, &&{unknown});_]\n-    [60; 66) '(x, y)': (&&{unknown}, &&{unknown})\n+    [59; 77) '[(x, y..., &x)]': [(&&&{unknown}, &&&{unknown});_]\n+    [60; 66) '(x, y)': (&&&{unknown}, &&&{unknown})\n     [61; 62) 'x': &&{unknown}\n     [64; 65) 'y': &&{unknown}\n     [68; 76) '(&y, &x)': (&&&{unknown}, &&&{unknown})\n@@ -2026,7 +2146,7 @@ fn id<T>(x: T) -> T {\n }\n \n fn clone<T>(x: &T) -> T {\n-    x\n+    *x\n }\n \n fn test() {\n@@ -2037,26 +2157,26 @@ fn test() {\n }\n \"#),\n         @r###\"\n-\n     [10; 11) 'x': T\n     [21; 30) '{     x }': T\n     [27; 28) 'x': T\n     [44; 45) 'x': &T\n-    [56; 65) '{     x }': &T\n-    [62; 63) 'x': &T\n-    [77; 157) '{     ...(1); }': ()\n-    [87; 88) 'y': u32\n-    [91; 96) '10u32': u32\n-    [102; 104) 'id': fn id<u32>(T) -> T\n-    [102; 107) 'id(y)': u32\n-    [105; 106) 'y': u32\n-    [117; 118) 'x': bool\n-    [127; 132) 'clone': fn clone<bool>(&T) -> T\n-    [127; 135) 'clone(z)': bool\n-    [133; 134) 'z': &bool\n-    [141; 151) 'id::<i128>': fn id<i128>(T) -> T\n-    [141; 154) 'id::<i128>(1)': i128\n-    [152; 153) '1': i128\n+    [56; 66) '{     *x }': T\n+    [62; 64) '*x': T\n+    [63; 64) 'x': &T\n+    [78; 158) '{     ...(1); }': ()\n+    [88; 89) 'y': u32\n+    [92; 97) '10u32': u32\n+    [103; 105) 'id': fn id<u32>(T) -> T\n+    [103; 108) 'id(y)': u32\n+    [106; 107) 'y': u32\n+    [118; 119) 'x': bool\n+    [128; 133) 'clone': fn clone<bool>(&T) -> T\n+    [128; 136) 'clone(z)': bool\n+    [134; 135) 'z': &bool\n+    [142; 152) 'id::<i128>': fn id<i128>(T) -> T\n+    [142; 155) 'id::<i128>(1)': i128\n+    [153; 154) '1': i128\n     \"###\n     );\n }\n@@ -2181,7 +2301,6 @@ fn extra_compiler_flags() {\n }\n \"#),\n         @r###\"\n-\n     [27; 323) '{     ...   } }': ()\n     [33; 321) 'for co...     }': ()\n     [37; 44) 'content': &{unknown}\n@@ -2195,8 +2314,8 @@ fn extra_compiler_flags() {\n     [135; 167) '{     ...     }': &&{unknown}\n     [149; 157) '&content': &&{unknown}\n     [150; 157) 'content': &{unknown}\n-    [182; 189) 'content': &&{unknown}\n-    [192; 314) 'if ICE...     }': &&{unknown}\n+    [182; 189) 'content': &{unknown}\n+    [192; 314) 'if ICE...     }': &{unknown}\n     [195; 232) 'ICE_RE..._VALUE': {unknown}\n     [195; 248) 'ICE_RE...&name)': bool\n     [242; 247) '&name': &&&{unknown}\n@@ -3282,7 +3401,7 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>\n+    (*s, s.foo())<|>;\n }\n \"#,\n     );\n@@ -3356,7 +3475,7 @@ trait Deref {\n }\n \n struct Arc<T>;\n-impl<T: ?Sized> Deref for Arc<T> {\n+impl<T> Deref for Arc<T> {\n     type Target = T;\n }\n \n@@ -3366,7 +3485,7 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>\n+    (*s, s.foo())<|>;\n }\n \"#,\n     );\n@@ -4406,121 +4525,3 @@ fn no_such_field_diagnostics() {\n     \"###\n     );\n }\n-\n-mod branching_with_never_tests {\n-    use super::type_at;\n-\n-    #[test]\n-    fn if_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test() {\n-    let i = if true {\n-        loop {}\n-    } else {\n-        3.0\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn if_else_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(input: bool) {\n-    let i = if input {\n-        2.0\n-    } else {\n-        return\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_first_arm_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        1 => return,\n-        2 => 2.0,\n-        3 => loop {},\n-        _ => 3.0,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_second_arm_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        1 => 3.0,\n-        2 => loop {},\n-        3 => 3.0,\n-        _ => return,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-\n-    #[test]\n-    fn match_all_arms_never() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        2 => return,\n-        _ => loop {},\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"!\");\n-    }\n-\n-    #[test]\n-    fn match_no_never_arms() {\n-        let t = type_at(\n-            r#\"\n-//- /main.rs\n-fn test(a: i32) {\n-    let i = match a {\n-        2 => 2.0,\n-        _ => 3.0,\n-    };\n-    i<|>\n-    ()\n-}\n-\"#,\n-        );\n-        assert_eq!(t, \"f64\");\n-    }\n-}"}, {"sha": "1530fcc6378a55e895dae1793df0edf6bf933b25", "filename": "crates/ra_hir/src/ty/tests/coercion.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fcoercion.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -0,0 +1,369 @@\n+use insta::assert_snapshot;\n+use test_utils::covers;\n+\n+// Infer with some common definitions and impls.\n+fn infer(source: &str) -> String {\n+    let defs = r#\"\n+        #[lang = \"sized\"]\n+        pub trait Sized {}\n+        #[lang = \"unsize\"]\n+        pub trait Unsize<T: ?Sized> {}\n+        #[lang = \"coerce_unsized\"]\n+        pub trait CoerceUnsized<T> {}\n+\n+        impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+        impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+    \"#;\n+\n+    // Append to the end to keep positions unchanged.\n+    super::infer(&format!(\"{}{}\", source, defs))\n+}\n+\n+#[test]\n+fn infer_block_expr_type_mismatch() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let a: i32 = { 1i64 };\n+}\n+\"#),\n+        @r###\"\n+    [11; 41) '{     ...4 }; }': ()\n+    [21; 22) 'a': i32\n+    [30; 38) '{ 1i64 }': i64\n+    [32; 36) '1i64': i64\n+    \"###);\n+}\n+\n+#[test]\n+fn coerce_places() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S<T> { a: T }\n+\n+fn f<T>(_: &[T]) -> T { loop {} }\n+fn g<T>(_: S<&[T]>) -> T { loop {} }\n+\n+fn gen<T>() -> *mut [T; 2] { loop {} }\n+fn test1<U>() -> *mut [U] {\n+    gen()\n+}\n+\n+fn test2() {\n+    let arr: &[u8; 1] = &[1];\n+\n+    let a: &[_] = arr;\n+    let b = f(arr);\n+    let c: &[_] = { arr };\n+    let d = g(S { a: arr });\n+    let e: [&[_]; 1] = [arr];\n+    let f: [&[_]; 2] = [arr; 2];\n+    let g: (&[_], &[_]) = (arr, arr);\n+}\n+\"#),\n+        @r###\"\n+    [31; 32) '_': &[T]\n+    [45; 56) '{ loop {} }': T\n+    [47; 54) 'loop {}': !\n+    [52; 54) '{}': ()\n+    [65; 66) '_': S<&[T]>\n+    [82; 93) '{ loop {} }': T\n+    [84; 91) 'loop {}': !\n+    [89; 91) '{}': ()\n+    [122; 133) '{ loop {} }': *mut [T;_]\n+    [124; 131) 'loop {}': !\n+    [129; 131) '{}': ()\n+    [160; 173) '{     gen() }': *mut [U]\n+    [166; 169) 'gen': fn gen<U>() -> *mut [T;_]\n+    [166; 171) 'gen()': *mut [U;_]\n+    [186; 420) '{     ...rr); }': ()\n+    [196; 199) 'arr': &[u8;_]\n+    [212; 216) '&[1]': &[u8;_]\n+    [213; 216) '[1]': [u8;_]\n+    [214; 215) '1': u8\n+    [227; 228) 'a': &[u8]\n+    [237; 240) 'arr': &[u8;_]\n+    [250; 251) 'b': u8\n+    [254; 255) 'f': fn f<u8>(&[T]) -> T\n+    [254; 260) 'f(arr)': u8\n+    [256; 259) 'arr': &[u8;_]\n+    [270; 271) 'c': &[u8]\n+    [280; 287) '{ arr }': &[u8]\n+    [282; 285) 'arr': &[u8;_]\n+    [297; 298) 'd': u8\n+    [301; 302) 'g': fn g<u8>(S<&[T]>) -> T\n+    [301; 316) 'g(S { a: arr })': u8\n+    [303; 315) 'S { a: arr }': S<&[u8]>\n+    [310; 313) 'arr': &[u8;_]\n+    [326; 327) 'e': [&[u8];_]\n+    [341; 346) '[arr]': [&[u8];_]\n+    [342; 345) 'arr': &[u8;_]\n+    [356; 357) 'f': [&[u8];_]\n+    [371; 379) '[arr; 2]': [&[u8];_]\n+    [372; 375) 'arr': &[u8;_]\n+    [377; 378) '2': usize\n+    [389; 390) 'g': (&[u8], &[u8])\n+    [407; 417) '(arr, arr)': (&[u8], &[u8])\n+    [408; 411) 'arr': &[u8;_]\n+    [413; 416) 'arr': &[u8;_]\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_let_stmt_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let x: &[i32] = &[1];\n+}\n+\"#),\n+        @r###\"\n+    [11; 40) '{     ...[1]; }': ()\n+    [21; 22) 'x': &[i32]\n+    [33; 37) '&[1]': &[i32;_]\n+    [34; 37) '[1]': [i32;_]\n+    [35; 36) '1': i32\n+    \"###);\n+}\n+\n+#[test]\n+fn infer_custom_coerce_unsized() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct A<T: ?Sized>(*const T);\n+struct B<T: ?Sized>(*const T);\n+struct C<T: ?Sized> { inner: *const T }\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<B<U>> for B<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<C<U>> for C<T> {}\n+\n+fn foo1<T>(x: A<[T]>) -> A<[T]> { x }\n+fn foo2<T>(x: B<[T]>) -> B<[T]> { x }\n+fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n+\n+fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n+    let d = foo1(a);\n+    let e = foo2(b);\n+    let f = foo3(c);\n+}\n+\"#),\n+        @r###\"\n+    [258; 259) 'x': A<[T]>\n+    [279; 284) '{ x }': A<[T]>\n+    [281; 282) 'x': A<[T]>\n+    [296; 297) 'x': B<[T]>\n+    [317; 322) '{ x }': B<[T]>\n+    [319; 320) 'x': B<[T]>\n+    [334; 335) 'x': C<[T]>\n+    [355; 360) '{ x }': C<[T]>\n+    [357; 358) 'x': C<[T]>\n+    [370; 371) 'a': A<[u8;_]>\n+    [385; 386) 'b': B<[u8;_]>\n+    [400; 401) 'c': C<[u8;_]>\n+    [415; 481) '{     ...(c); }': ()\n+    [425; 426) 'd': A<[{unknown}]>\n+    [429; 433) 'foo1': fn foo1<{unknown}>(A<[T]>) -> A<[T]>\n+    [429; 436) 'foo1(a)': A<[{unknown}]>\n+    [434; 435) 'a': A<[u8;_]>\n+    [446; 447) 'e': B<[u8]>\n+    [450; 454) 'foo2': fn foo2<u8>(B<[T]>) -> B<[T]>\n+    [450; 457) 'foo2(b)': B<[u8]>\n+    [455; 456) 'b': B<[u8;_]>\n+    [467; 468) 'f': C<[u8]>\n+    [471; 475) 'foo3': fn foo3<u8>(C<[T]>) -> C<[T]>\n+    [471; 478) 'foo3(c)': C<[u8]>\n+    [476; 477) 'c': C<[u8;_]>\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_if_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        foo(&[1])\n+    } else {\n+        &[1]\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': &[T]\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 97) '{     ...     }': &[i32]\n+    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [82; 91) 'foo(&[1])': &[i32]\n+    [86; 90) '&[1]': &[i32;_]\n+    [87; 90) '[1]': [i32;_]\n+    [88; 89) '1': i32\n+    [103; 123) '{     ...     }': &[i32;_]\n+    [113; 117) '&[1]': &[i32;_]\n+    [114; 117) '[1]': [i32;_]\n+    [115; 116) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_if_else_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        &[1]\n+    } else {\n+        foo(&[1])\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': &[T]\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 92) '{     ...     }': &[i32;_]\n+    [82; 86) '&[1]': &[i32;_]\n+    [83; 86) '[1]': [i32;_]\n+    [84; 85) '1': i32\n+    [98; 123) '{     ...     }': &[i32]\n+    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [108; 117) 'foo(&[1])': &[i32]\n+    [112; 116) '&[1]': &[i32;_]\n+    [113; 116) '[1]': [i32;_]\n+    [114; 115) '1': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_first_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        2 => foo(&[2]),\n+        1 => &[1],\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': &[T]\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '2': i32\n+    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [93; 102) 'foo(&[2])': &[i32]\n+    [97; 101) '&[2]': &[i32;_]\n+    [98; 101) '[2]': [i32;_]\n+    [99; 100) '2': i32\n+    [112; 113) '1': i32\n+    [117; 121) '&[1]': &[i32;_]\n+    [118; 121) '[1]': [i32;_]\n+    [119; 120) '1': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_second_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        1 => &[1],\n+        2 => foo(&[2]),\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': &[T]\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '1': i32\n+    [93; 97) '&[1]': &[i32;_]\n+    [94; 97) '[1]': [i32;_]\n+    [95; 96) '1': i32\n+    [107; 108) '2': i32\n+    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [112; 121) 'foo(&[2])': &[i32]\n+    [116; 120) '&[2]': &[i32;_]\n+    [117; 120) '[2]': [i32;_]\n+    [118; 119) '2': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn coerce_merge_one_by_one1() {\n+    covers!(coerce_merge_fail_fallback);\n+\n+    assert_snapshot!(\n+        infer(r#\"\n+fn test() {\n+    let t = &mut 1;\n+    let x = match 1 {\n+        1 => t as *mut i32,\n+        2 => t as &i32,\n+        _ => t as *const i32,\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 145) '{     ...  }; }': ()\n+    [21; 22) 't': &mut i32\n+    [25; 31) '&mut 1': &mut i32\n+    [30; 31) '1': i32\n+    [41; 42) 'x': *const i32\n+    [45; 142) 'match ...     }': *const i32\n+    [51; 52) '1': i32\n+    [63; 64) '1': i32\n+    [68; 69) 't': &mut i32\n+    [68; 81) 't as *mut i32': *mut i32\n+    [91; 92) '2': i32\n+    [96; 97) 't': &mut i32\n+    [96; 105) 't as &i32': &i32\n+    [115; 116) '_': i32\n+    [120; 121) 't': &mut i32\n+    [120; 135) 't as *const i32': *const i32\n+    \"###\n+    );\n+}"}, {"sha": "c202f545a3799852f93f47dbc1be8872a08b796c", "filename": "crates/ra_hir/src/ty/tests/never_type.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79376abb43e3e1e607b5307e85dd43251ad6c5e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fnever_type.rs?ref=79376abb43e3e1e607b5307e85dd43251ad6c5e3", "patch": "@@ -0,0 +1,246 @@\n+use super::type_at;\n+\n+#[test]\n+fn infer_never1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let t = return;\n+    t<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn infer_never2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn gen<T>() -> T { loop {} }\n+\n+fn test() {\n+    let a = gen();\n+    if false { a } else { loop {} };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn infer_never3() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn gen<T>() -> T { loop {} }\n+\n+fn test() {\n+    let a = gen();\n+    if false { loop {} } else { a };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn never_type_in_generic_args() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<!>\");\n+}\n+\n+#[test]\n+fn never_type_can_be_reinferred1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn gen<T>() -> T { loop {} }\n+\n+fn test() {\n+    let a = gen();\n+    if false { loop {} } else { a };\n+    a<|>;\n+    if false { a };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"()\");\n+}\n+\n+#[test]\n+fn never_type_can_be_reinferred2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+    match 42 {\n+        42 => a,\n+        _ => Option::Some(42),\n+    };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<i32>\");\n+}\n+#[test]\n+fn never_type_can_be_reinferred3() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { None, Some(T) }\n+\n+fn test() {\n+    let a = if true { Option::None } else { Option::Some(return) };\n+    a<|>;\n+    match 42 {\n+        42 => a,\n+        _ => Option::Some(\"str\"),\n+    };\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Option<&str>\");\n+}\n+\n+#[test]\n+fn match_no_arm() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+enum Void {}\n+\n+fn test(a: Void) {\n+    let t = match a {};\n+    t<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn if_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let i = if true {\n+        loop {}\n+    } else {\n+        3.0\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn if_else_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(input: bool) {\n+    let i = if input {\n+        2.0\n+    } else {\n+        return\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_first_arm_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => return,\n+        2 => 2.0,\n+        3 => loop {},\n+        _ => 3.0,\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_second_arm_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => 3.0,\n+        2 => loop {},\n+        3 => 3.0,\n+        _ => return,\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}\n+\n+#[test]\n+fn match_all_arms_never() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => return,\n+        _ => loop {},\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"!\");\n+}\n+\n+#[test]\n+fn match_no_never_arms() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => 2.0,\n+        _ => 3.0,\n+    };\n+    i<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"f64\");\n+}"}]}