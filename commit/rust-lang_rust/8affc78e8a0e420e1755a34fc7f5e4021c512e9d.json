{"sha": "8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZmZjNzhlOGEwZTQyMGUxNzU1YTM0ZmM3ZjVlNDAyMWM1MTJlOWQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-04T05:31:38Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-04T05:31:38Z"}, "message": "Turn constants in back::abi into uints, and propagate types\n\nThis means GEPi now takes a list of uints. Apologies in advance\nif this is hard to rebase against, but it gets rid of many a cast :-)\n\nAlso modernized some for loops here and there.", "tree": {"sha": "d0014ffd443a1c07d34f713022ea446f4e633dbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0014ffd443a1c07d34f713022ea446f4e633dbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "html_url": "https://github.com/rust-lang/rust/commit/8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2830bc3d311a2ea1a7a6df505abf81192f12ffbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2830bc3d311a2ea1a7a6df505abf81192f12ffbd", "html_url": "https://github.com/rust-lang/rust/commit/2830bc3d311a2ea1a7a6df505abf81192f12ffbd"}], "stats": {"total": 383, "additions": 184, "deletions": 199}, "files": [{"sha": "70606d9f885a95f866d8cb09c9557024638cc45f", "filename": "src/rustc/back/abi.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fabi.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -1,55 +1,54 @@\n \n \n \n-// FIXME: Most of these should be uints.\n-const rc_base_field_refcnt: int = 0;\n+const rc_base_field_refcnt: uint = 0u;\n \n-const task_field_refcnt: int = 0;\n+const task_field_refcnt: uint = 0u;\n \n-const task_field_stk: int = 2;\n+const task_field_stk: uint = 2u;\n \n-const task_field_runtime_sp: int = 3;\n+const task_field_runtime_sp: uint = 3u;\n \n-const task_field_rust_sp: int = 4;\n+const task_field_rust_sp: uint = 4u;\n \n-const task_field_gc_alloc_chain: int = 5;\n+const task_field_gc_alloc_chain: uint = 5u;\n \n-const task_field_dom: int = 6;\n+const task_field_dom: uint = 6u;\n \n-const n_visible_task_fields: int = 7;\n+const n_visible_task_fields: uint = 7u;\n \n-const dom_field_interrupt_flag: int = 1;\n+const dom_field_interrupt_flag: uint = 1u;\n \n-const frame_glue_fns_field_mark: int = 0;\n+const frame_glue_fns_field_mark: uint = 0u;\n \n-const frame_glue_fns_field_drop: int = 1;\n+const frame_glue_fns_field_drop: uint = 1u;\n \n-const frame_glue_fns_field_reloc: int = 2;\n+const frame_glue_fns_field_reloc: uint = 2u;\n \n-const box_field_refcnt: int = 0;\n-const box_field_tydesc: int = 1;\n-const box_field_prev: int = 2;\n-const box_field_next: int = 3;\n-const box_field_body: int = 4;\n+const box_field_refcnt: uint = 0u;\n+const box_field_tydesc: uint = 1u;\n+const box_field_prev: uint = 2u;\n+const box_field_next: uint = 3u;\n+const box_field_body: uint = 4u;\n \n-const general_code_alignment: int = 16;\n+const general_code_alignment: uint = 16u;\n \n-const tydesc_field_first_param: int = 0;\n-const tydesc_field_size: int = 1;\n-const tydesc_field_align: int = 2;\n-const tydesc_field_take_glue: int = 3;\n-const tydesc_field_drop_glue: int = 4;\n-const tydesc_field_free_glue: int = 5;\n-const tydesc_field_unused: int = 6;\n-const tydesc_field_sever_glue: int = 7;\n-const tydesc_field_mark_glue: int = 8;\n-const tydesc_field_unused2: int = 9;\n-const tydesc_field_unused_2: int = 10;\n-const tydesc_field_shape: int = 11;\n-const tydesc_field_shape_tables: int = 12;\n-const tydesc_field_n_params: int = 13;\n-const tydesc_field_obj_params: int = 14; // FIXME unused\n-const n_tydesc_fields: int = 15;\n+const tydesc_field_first_param: uint = 0u;\n+const tydesc_field_size: uint = 1u;\n+const tydesc_field_align: uint = 2u;\n+const tydesc_field_take_glue: uint = 3u;\n+const tydesc_field_drop_glue: uint = 4u;\n+const tydesc_field_free_glue: uint = 5u;\n+const tydesc_field_unused: uint = 6u;\n+const tydesc_field_sever_glue: uint = 7u;\n+const tydesc_field_mark_glue: uint = 8u;\n+const tydesc_field_unused2: uint = 9u;\n+const tydesc_field_unused_2: uint = 10u;\n+const tydesc_field_shape: uint = 11u;\n+const tydesc_field_shape_tables: uint = 12u;\n+const tydesc_field_n_params: uint = 13u;\n+const tydesc_field_obj_params: uint = 14u; // FIXME unused (#2351)\n+const n_tydesc_fields: uint = 15u;\n \n const cmp_glue_op_eq: uint = 0u;\n \n@@ -58,23 +57,23 @@ const cmp_glue_op_lt: uint = 1u;\n const cmp_glue_op_le: uint = 2u;\n \n // The two halves of a closure: code and environment.\n-const fn_field_code: int = 0;\n-const fn_field_box: int = 1;\n+const fn_field_code: uint = 0u;\n+const fn_field_box: uint = 1u;\n \n // closures, see trans_closure.rs\n-const closure_body_ty_params: int = 0;\n-const closure_body_bindings: int = 1;\n+const closure_body_ty_params: uint = 0u;\n+const closure_body_bindings: uint = 1u;\n \n-const vec_elt_fill: int = 0;\n+const vec_elt_fill: uint = 0u;\n \n-const vec_elt_alloc: int = 1;\n+const vec_elt_alloc: uint = 1u;\n \n-const vec_elt_elems: int = 2;\n+const vec_elt_elems: uint = 2u;\n \n-const slice_elt_base: int = 0;\n-const slice_elt_len: int = 1;\n+const slice_elt_base: uint = 0u;\n+const slice_elt_len: uint = 1u;\n \n-const worst_case_glue_call_args: int = 7;\n+const worst_case_glue_call_args: uint = 7u;\n \n const abi_version: uint = 1u;\n "}, {"sha": "3dae38d94963ce6bcda27a8484abb1e3210aec72", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -274,7 +274,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-        blobptr = GEPi(bcx, enumptr, [0, 1]);\n+        blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n     }\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n@@ -410,7 +410,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         let mut rec_vals = [];\n         for vec::each(rec_fields) {|field_name|\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            rec_vals += [GEPi(bcx, val, [0, ix as int])];\n+            rec_vals += [GEPi(bcx, val, [0u, ix])];\n         }\n         compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n                          rec_vals + vals_left, chk, exits);\n@@ -425,7 +425,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         };\n         let mut tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n-            tup_vals += [GEPi(bcx, val, [0, i as int])];\n+            tup_vals += [GEPi(bcx, val, [0u, i])];\n             i += 1u;\n         }\n         compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n@@ -436,7 +436,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n-        let unboxed = GEPi(bcx, box, [0, abi::box_field_body]);\n+        let unboxed = GEPi(bcx, box, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n                          + vals_left, chk, exits);\n         ret;\n@@ -462,7 +462,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n             } else {\n                 let enumptr =\n                     PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                let discrimptr = GEPi(bcx, enumptr, [0, 0]);\n+                let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -711,22 +711,22 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n         for vec::each(fields) {|f|\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n-            let fldptr = GEPi(bcx, val, [0, ix as int]);\n+            let fldptr = GEPi(bcx, val, [0u, ix]);\n             bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, make_copy);\n         }\n       }\n       ast::pat_tup(elems) {\n         let mut i = 0u;\n         for vec::each(elems) {|elem|\n-            let fldptr = GEPi(bcx, val, [0, i as int]);\n+            let fldptr = GEPi(bcx, val, [0u, i]);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;\n         }\n       }\n       ast::pat_box(inner) {\n         let box = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0, abi::box_field_body]);\n+            GEPi(bcx, box, [0u, abi::box_field_body]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {"}, {"sha": "a06d78c24bb423bda2ca7e52577ba2685ba854f5", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 56, "deletions": 62, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -301,7 +301,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n-    GEPi(bcx, typed_blobptr, [0, ix as int])\n+    GEPi(bcx, typed_blobptr, [0u, ix])\n }\n \n // trans_shared_malloc: expects a type indicating which pointer type we want\n@@ -324,7 +324,7 @@ fn opaque_box_body(bcx: block,\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n-    let bodyptr = GEPi(bcx, boxptr, [1]);\n+    let bodyptr = GEPi(bcx, boxptr, [1u]);\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n@@ -356,7 +356,7 @@ fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n     let mut ti = none;\n     let box = malloc_boxed_raw(bcx, t, ti);\n-    let body = GEPi(bcx, box, [0, abi::box_field_body]);\n+    let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n \n@@ -603,7 +603,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v, [0, 1]));\n+        let box = Load(bcx, GEPi(bcx, v, [0u, 1u]));\n         incr_refcnt_of_boxed(bcx, box);\n         bcx\n       }\n@@ -623,7 +623,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n     let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n-    let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n+    let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n     let rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n@@ -638,7 +638,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n-        let body = GEPi(bcx, v, [0, abi::box_field_body]);\n+        let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n@@ -650,8 +650,8 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n-        let td = Load(bcx, GEPi(bcx, v, [0, abi::box_field_tydesc]));\n-        let valptr = GEPi(bcx, v, [0, abi::box_field_body]);\n+        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n+        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n                               none);\n         trans_free(bcx, v)\n@@ -698,7 +698,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v0, [0, 1]));\n+        let box = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n         decr_refcnt_maybe_free(bcx, box, ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n@@ -742,9 +742,9 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n     let ccx = bcx.ccx();\n     let inner_t_s = ty::subst_tps(ccx.tcx, tps, inner_t);\n \n-    let drop_flag = GEPi(bcx, rs, [0, 0]);\n+    let drop_flag = GEPi(bcx, rs, [0u, 0u]);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n-        let valptr = GEPi(bcx, rs, [0, 1]);\n+        let valptr = GEPi(bcx, rs, [0u, 1u]);\n         // Find and call the actual destructor.\n         let dtor_addr = get_res_dtor(ccx, did, tps);\n         let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n@@ -782,7 +782,7 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n     let llbox_ty = T_opaque_box_ptr(ccx);\n     let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n     with_cond(bcx, IsNotNull(bcx, box_ptr)) {|bcx|\n-        let rc_ptr = GEPi(bcx, box_ptr, [0, abi::box_field_refcnt]);\n+        let rc_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_refcnt]);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n@@ -888,12 +888,12 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n-fn load_inbounds(cx: block, p: ValueRef, idxs: [int]) -> ValueRef {\n+fn load_inbounds(cx: block, p: ValueRef, idxs: [uint]) -> ValueRef {\n     ret Load(cx, GEPi(cx, p, idxs));\n }\n \n fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n-                  idxs: [int]) {\n+                  idxs: [uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n@@ -933,7 +933,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n         for vec::eachi(fields) {|i, fld|\n-            let llfld_a = GEPi(cx, av, [0, i as int]);\n+            let llfld_a = GEPi(cx, av, [0u, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n         }\n       }\n@@ -944,14 +944,14 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(args) {\n         for vec::eachi(args) {|i, arg|\n-            let llfld_a = GEPi(cx, av, [0, i as int]);\n+            let llfld_a = GEPi(cx, av, [0u, i]);\n             cx = f(cx, llfld_a, arg);\n         }\n       }\n       ty::ty_res(_, inner, substs) {\n         let tcx = cx.tcx();\n         let inner1 = ty::subst(tcx, substs, inner);\n-        let llfld_a = GEPi(cx, av, [0, 1]);\n+        let llfld_a = GEPi(cx, av, [0u, 1u]);\n         ret f(cx, llfld_a, inner1);\n       }\n       ty::ty_enum(tid, substs) {\n@@ -967,8 +967,8 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let llenumty = T_opaque_enum_ptr(ccx);\n         let av_enum = PointerCast(cx, av, llenumty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n-        let llunion_a_ptr = GEPi(cx, av_enum, [0, 1]);\n+        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n+        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]);\n         let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n@@ -993,12 +993,11 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_class(did, substs) {\n           // a class is like a record type\n-        let mut i: int = 0;\n-        for vec::each(ty::class_items_as_fields(cx.tcx(), did, substs)) {|fld|\n-            let llfld_a = GEPi(cx, av, [0, i]);\n-            cx = f(cx, llfld_a, fld.mt.ty);\n-            i += 1;\n-        }\n+          for vec::eachi(ty::class_items_as_fields(cx.tcx(), did, substs))\n+           {|i, fld|\n+             let llfld_a = GEPi(cx, av, [0u, i]);\n+             cx = f(cx, llfld_a, fld.mt.ty);\n+           }\n       }\n       _ { cx.sess().unimpl(\"type in iter_structural_ty\"); }\n     }\n@@ -1012,7 +1011,7 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n }\n \n-fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n+fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            static_ti: option<@tydesc_info>) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     alt static_ti {\n@@ -1069,7 +1068,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: int,\n }\n \n fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n-                         field: int, static_ti: option<@tydesc_info>) {\n+                         field: uint, static_ti: option<@tydesc_info>) {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue_full\");\n     lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n     if cx.unreachable { ret; }\n@@ -1093,7 +1092,7 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n     let llfn = {\n         alt static_glue_fn {\n           none {\n-            let llfnptr = GEPi(cx, tydesc, [0, field]);\n+            let llfnptr = GEPi(cx, tydesc, [0u, field]);\n             Load(cx, llfnptr)\n           }\n           some(sgf) { sgf }\n@@ -1104,7 +1103,7 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                     C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]);\n }\n \n-fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n+fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint) ->\n    block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let mut ti = none;\n@@ -1126,7 +1125,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n     let lltydesc = get_tydesc_simple(bcx.ccx(), t);\n     let lltydescs =\n-        Load(bcx, GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]));\n+        Load(bcx, GEPi(bcx, lltydesc, [0u, abi::tydesc_field_first_param]));\n \n     let llfn = bcx.ccx().upcalls.cmp_type;\n \n@@ -1605,7 +1604,7 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n     loop {\n         alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n-            let body = GEPi(cx, v1, [0, abi::box_field_body]);\n+            let body = GEPi(cx, v1, [0u, abi::box_field_body]);\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n@@ -1626,7 +1625,7 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n           }\n           ty::ty_res(did, inner, substs) {\n             t1 = ty::subst(ccx.tcx, substs, inner);\n-            v1 = GEPi(cx, v1, [0, 1]);\n+            v1 = GEPi(cx, v1, [0u, 1u]);\n           }\n           ty::ty_enum(did, substs) {\n             let variants = ty::enum_variants(ccx.tcx, did);\n@@ -2251,7 +2250,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             // FIXME: This pointer cast probably isn't necessary\n             let llenumty = type_of(ccx, enum_ty);\n             let llenumptr = PointerCast(cx, llenumblob, T_ptr(llenumty));\n-            let lldiscrimptr = GEPi(cx, llenumptr, [0, 0]);\n+            let lldiscrimptr = GEPi(cx, llenumptr, [0u, 0u]);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);\n             let lldiscrim = Load(cx, lldiscrim_gv);\n             Store(cx, lldiscrim, lldiscrimptr);\n@@ -2293,7 +2292,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                  base expr has non-record type\"); }\n         };\n     let ix = field_idx_strict(bcx.tcx(), sp, field, fields);\n-    let val = GEPi(bcx, val, [0, ix as int]);\n+    let val = GEPi(bcx, val, [0u, ix]);\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n@@ -2400,10 +2399,10 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         let t = expr_ty(cx, base);\n         let val = alt check ty::get(t).struct {\n           ty::ty_box(_) {\n-            GEPi(sub.bcx, sub.val, [0, abi::box_field_body])\n+            GEPi(sub.bcx, sub.val, [0u, abi::box_field_body])\n           }\n           ty::ty_res(_, _, _) {\n-            GEPi(sub.bcx, sub.val, [0, 1])\n+            GEPi(sub.bcx, sub.val, [0u, 1u])\n           }\n           ty::ty_enum(_, _) {\n             let ety = expr_ty(cx, e);\n@@ -2528,7 +2527,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n             let cx = e_res.bcx;\n             let llenumty = T_opaque_enum_ptr(ccx);\n             let av_enum = PointerCast(cx, e_res.val, llenumty);\n-            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0, 0]);\n+            let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             alt k_out {\n               cast_integral {int_cast(e_res.bcx, ll_t_out,\n@@ -2658,7 +2657,7 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n               owned_imm { lv.val }\n             }\n         };\n-        let body_ptr = GEPi(bcx, box_ptr, [0, abi::box_field_body]);\n+        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n         ret lval_temp(bcx, body_ptr);\n       }\n \n@@ -2685,8 +2684,8 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n                val_str(bcx.ccx().tn, val),\n                val_str(bcx.ccx().tn, p));\n \n-        Store(bcx, base, GEPi(bcx, p, [0, abi::slice_elt_base]));\n-        Store(bcx, len, GEPi(bcx, p, [0, abi::slice_elt_len]));\n+        Store(bcx, base, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n+        Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n         ret lval_temp(bcx, p);\n       }\n \n@@ -2832,9 +2831,9 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n                 faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n             }\n             let pair = faddr;\n-            faddr = GEPi(bcx, pair, [0, abi::fn_field_code]);\n+            faddr = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n             faddr = Load(bcx, faddr);\n-            let llclosure = GEPi(bcx, pair, [0, abi::fn_field_box]);\n+            let llclosure = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n             Load(bcx, llclosure)\n           }\n         };\n@@ -3010,14 +3009,13 @@ fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n-    let mut temp_cleanups = [], i = 0;\n-    for vec::each(elts) {|e|\n-        let dst = GEPi(bcx, addr, [0, i]);\n+    let mut temp_cleanups = [];\n+    for vec::eachi(elts) {|i, e|\n+        let dst = GEPi(bcx, addr, [0u, i]);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n         temp_cleanups += [dst];\n-        i += 1;\n     }\n     for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n     ret bcx;\n@@ -3046,25 +3044,23 @@ fn trans_rec(bcx: block, fields: [ast::field],\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n         }));\n-        let dst = GEPi(bcx, addr, [0, ix as int]);\n+        let dst = GEPi(bcx, addr, [0u, ix]);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n         temp_cleanups += [dst];\n     }\n     alt base {\n       some(bexp) {\n         let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp);\n-        let mut i = 0;\n         bcx = cx;\n         // Copy over inherited fields\n-        for ty_fields.each {|tf|\n+        for ty_fields.eachi {|i, tf|\n             if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n-                let dst = GEPi(bcx, addr, [0, i]);\n-                let base = GEPi(bcx, base_val, [0, i]);\n+                let dst = GEPi(bcx, addr, [0u, i]);\n+                let base = GEPi(bcx, base_val, [0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n                 bcx = copy_val(bcx, INIT, dst, val, tf.mt.ty);\n             }\n-            i += 1;\n         }\n       }\n       none {}\n@@ -4199,9 +4195,9 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n     };\n     let llretptr = fcx.llretptr;\n \n-    let dst = GEPi(bcx, llretptr, [0, 1]);\n+    let dst = GEPi(bcx, llretptr, [0u, 1u]);\n     memmove_ty(bcx, dst, arg, arg_t);\n-    let flag = GEPi(bcx, llretptr, [0, 0]);\n+    let flag = GEPi(bcx, llretptr, [0u, 0u]);\n     let one = C_u8(1u);\n     Store(bcx, one, flag);\n     build_return(bcx);\n@@ -4238,14 +4234,13 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     } else {\n         let llenumptr =\n             PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n-        let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n+        let lldiscrimptr = GEPi(bcx, llenumptr, [0u, 0u]);\n         Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-        GEPi(bcx, llenumptr, [0, 1])\n+        GEPi(bcx, llenumptr, [0u, 1u])\n     };\n-    let mut i = 0u;\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n-    for vec::each(variant.node.args) {|va|\n+    for vec::eachi(variant.node.args) {|i, va|\n         let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n                                  ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n@@ -4256,7 +4251,6 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n         };\n         let arg_ty = arg_tys[i].ty;\n         memmove_ty(bcx, lldestptr, llarg, arg_ty);\n-        i += 1u;\n     }\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -4433,7 +4427,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // drop their LHS\n   for fields.each {|field|\n      let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n-     bcx = zero_alloca(bcx, GEPi(bcx, selfptr, [0, ix]),\n+     bcx = zero_alloca(bcx, GEPi(bcx, selfptr, [0u, ix]),\n                        field.mt.ty);\n   }\n \n@@ -4673,9 +4667,9 @@ fn create_real_fn_pair(cx: block, llfnty: TypeRef, llfn: ValueRef,\n fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n                 llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n-    let code_cell = GEPi(bcx, pair, [0, abi::fn_field_code]);\n+    let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n-    let env_cell = GEPi(bcx, pair, [0, abi::fn_field_box]);\n+    let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n     let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n     Store(bcx, llenvblobptr, env_cell);\n }"}, {"sha": "6c2cd8b57de170bf97f674a9bb3af801720e417e", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -427,7 +427,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n-fn GEPi(cx: block, base: ValueRef, ixs: [int]) -> ValueRef {\n+fn GEPi(cx: block, base: ValueRef, ixs: [uint]) -> ValueRef {\n     let mut v: [ValueRef] = [];\n     for vec::each(ixs) {|i| v += [C_i32(i as i32)]; }\n     count_insn(cx, \"gepi\");"}, {"sha": "706eee8e3260ba40bb85a7b64e9bd72b412ef7f2", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -154,7 +154,7 @@ fn allocate_cbox(bcx: block,\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n-        let ref_cnt = GEPi(bcx, box, [0, abi::box_field_refcnt]);\n+        let ref_cnt = GEPi(bcx, box, [0u, abi::box_field_refcnt]);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n     }\n@@ -163,7 +163,7 @@ fn allocate_cbox(bcx: block,\n                     cdata_ty: ty::t,\n                     box: ValueRef,\n                     &ti: option<@tydesc_info>) -> block {\n-        let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n+        let bound_tydesc = GEPi(bcx, box, [0u, abi::box_field_tydesc]);\n         let td = base::get_tydesc(bcx.ccx(), cdata_ty, ti);\n         Store(bcx, td, bound_tydesc);\n         bcx\n@@ -243,8 +243,7 @@ fn store_environment(bcx: block,\n         }\n \n         let bound_data = GEPi(bcx, llbox,\n-                              [0, abi::box_field_body,\n-                               abi::closure_body_bindings, i as int]);\n+             [0u, abi::box_field_body, abi::closure_body_bindings, i]);\n         alt bv {\n           env_expr(e, _) {\n             bcx = base::trans_expr_save_in(bcx, e, bound_data);\n@@ -353,28 +352,28 @@ fn load_environment(fcx: fn_ctxt,\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n     // Populate the upvars from the environment.\n-    let mut i = 0;\n+    let mut i = 0u;\n     vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n             let mut upvarptr =\n-                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, i]);\n+                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, i]);\n             alt ck {\n               ty::ck_block { upvarptr = Load(bcx, upvarptr); }\n               ty::ck_uniq | ty::ck_box { }\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n             fcx.llupvars.insert(def_id.node, upvarptr);\n-            i += 1;\n+            i += 1u;\n           }\n         }\n     }\n     if load_ret_handle {\n         let flagptr = Load(bcx, GEPi(bcx, llcdata,\n-                                     [0, abi::closure_body_bindings, i]));\n+                                     [0u, abi::closure_body_bindings, i]));\n         let retptr = Load(bcx, GEPi(bcx, llcdata,\n-                                    [0, abi::closure_body_bindings, i+1]));\n+                                    [0u, abi::closure_body_bindings, i+1u]));\n         fcx.loop_ret = some({flagptr: flagptr, retptr: retptr});\n     }\n }\n@@ -510,7 +509,7 @@ fn make_fn_glue(\n     let tcx = cx.tcx();\n \n     let fn_env = fn@(ck: ty::closure_kind) -> block {\n-        let box_cell_v = GEPi(cx, v, [0, abi::fn_field_box]);\n+        let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n         let box_ptr_v = Load(cx, box_cell_v);\n         with_cond(cx, IsNotNull(cx, box_ptr_v)) {|bcx|\n             let closure_ty = ty::mk_opaque_closure_ptr(tcx, ck);\n@@ -548,10 +547,10 @@ fn make_opaque_cbox_take_glue(\n     with_cond(bcx, IsNotNull(bcx, cbox_in)) {|bcx|\n         // Load the size from the type descr found in the cbox\n         let cbox_in = PointerCast(bcx, cbox_in, llopaquecboxty);\n-        let tydescptr = GEPi(bcx, cbox_in, [0, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox_in, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, T_ptr(ccx.tydesc_type));\n-        let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n+        let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n@@ -564,12 +563,12 @@ fn make_opaque_cbox_take_glue(\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor\n-        let tydesc_out = GEPi(bcx, cbox_out, [0, abi::box_field_tydesc]);\n+        let tydesc_out = GEPi(bcx, cbox_out, [0u, abi::box_field_tydesc]);\n         let bcx = take_ty(bcx, tydesc_out, ty::mk_type(tcx));\n \n         // Take the data in the tuple\n         let ti = none;\n-        let cdata_out = GEPi(bcx, cbox_out, [0, abi::box_field_body]);\n+        let cdata_out = GEPi(bcx, cbox_out, [0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata_out, tydesc,\n                               abi::tydesc_field_take_glue, ti);\n         bcx\n@@ -611,13 +610,13 @@ fn make_opaque_cbox_free_glue(\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n         let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n-        let tydescptr = GEPi(bcx, cbox, [0, abi::box_field_tydesc]);\n+        let tydescptr = GEPi(bcx, cbox, [0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);\n \n         // Drop the tuple data then free the descriptor\n         let ti = none;\n-        let cdata = GEPi(bcx, cbox, [0, abi::box_field_body]);\n+        let cdata = GEPi(bcx, cbox, [0u, abi::box_field_body]);\n         call_tydesc_glue_full(bcx, cdata, tydesc,\n                               abi::tydesc_field_drop_glue, ti);\n \n@@ -711,26 +710,26 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // target function lives in the first binding spot.\n     let (lltargetfn, lltargetenv, starting_idx) = alt target_info {\n       target_static(fptr) {\n-        (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n+        (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0u)\n       }\n       target_closure {\n-        let pair = GEPi(bcx, llcdata, [0, abi::closure_body_bindings, 0]);\n+        let pair = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]);\n         let lltargetenv =\n-            Load(bcx, GEPi(bcx, pair, [0, abi::fn_field_box]));\n+            Load(bcx, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n         let lltargetfn = Load\n-            (bcx, GEPi(bcx, pair, [0, abi::fn_field_code]));\n-        (lltargetfn, lltargetenv, 1)\n+            (bcx, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n+        (lltargetfn, lltargetenv, 1u)\n       }\n       target_self {\n         let fptr = Load(bcx, GEPi(bcx, llcdata,\n-                                  [0, abi::closure_body_bindings, 0]));\n-        let slfbox = GEPi(bcx, llcdata, [0, abi::closure_body_bindings, 1]);\n-        let selfptr = GEPi(bcx, Load(bcx, slfbox), [0, abi::box_field_body]);\n-        (fptr, PointerCast(bcx, selfptr, T_opaque_cbox_ptr(ccx)), 2)\n+                                  [0u, abi::closure_body_bindings, 0u]));\n+        let slfbox = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 1u]);\n+        let selfptr = GEPi(bcx, Load(bcx, slfbox), [0u, abi::box_field_body]);\n+        (fptr, PointerCast(bcx, selfptr, T_opaque_cbox_ptr(ccx)), 2u)\n       }\n       target_static_self(fptr) {\n-        let slfptr = GEPi(bcx, llcdata, [0, abi::closure_body_bindings, 0]);\n-        (fptr, PointerCast(bcx, slfptr, T_opaque_cbox_ptr(ccx)), 1)\n+        let slfptr = GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, 0u]);\n+        (fptr, PointerCast(bcx, slfptr, T_opaque_cbox_ptr(ccx)), 1u)\n       }\n     };\n \n@@ -744,7 +743,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let mut llargs: [ValueRef] = [fcx.llretptr, lltargetenv];\n \n     let mut a: uint = first_real_arg; // retptr, env come first\n-    let mut b: int = starting_idx;\n+    let mut b: uint = starting_idx;\n     let mut outgoing_arg_index: uint = 0u;\n     for vec::each(args) {|arg|\n         let out_arg = outgoing_args[outgoing_arg_index];\n@@ -753,7 +752,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n           // closure.\n           some(e) {\n             let mut val =\n-                GEPi(bcx, llcdata, [0, abi::closure_body_bindings, b]);\n+                GEPi(bcx, llcdata, [0u, abi::closure_body_bindings, b]);\n \n             alt ty::resolved_mode(tcx, out_arg.mode) {\n               ast::by_val {\n@@ -768,7 +767,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n               ast::by_ref | ast::by_mutbl_ref | ast::by_move { }\n             }\n             llargs += [val];\n-            b += 1;\n+            b += 1u;\n           }\n \n           // Arg will be provided when the thunk is invoked."}, {"sha": "d71773a138d1b95714b5b43f201c6e500453e3b4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -552,11 +552,11 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n+fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n-        vec::from_elem::<TypeRef>(abi::n_tydesc_fields as uint,\n+        vec::from_elem::<TypeRef>(abi::n_tydesc_fields,\n                                  T_nil());\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     to_ptr::<TypeRef>(tydesc_elts));\n@@ -902,12 +902,12 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n \n fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n                     fields: [ty::field])\n-    -> int {\n+    -> uint {\n     alt ty::field_idx(ident, fields) {\n-            none { cx.sess.span_bug(sp, #fmt(\"base expr doesn't appear to \\\n-                     have a field named %s\", ident)); }\n-            some(i) { i as int }\n-        }\n+       none { cx.sess.span_bug(sp, #fmt(\"base expr doesn't appear to \\\n+                 have a field named %s\", ident)); }\n+       some(i) { i }\n+    }\n }\n \n fn dummy_substs(tps: [ty::t]) -> ty::substs {"}, {"sha": "5f50bb283a15b6a0a3791716e62b49e8a0e9cb92", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -78,7 +78,7 @@ fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n     let llfty = type_of::type_of_fn_from_ty(ccx, fty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n-    let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0u, n_method]));\n     {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n@@ -153,11 +153,11 @@ fn trans_iface_callee(bcx: block, base: @ast::expr,\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_iface_callee\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n+    let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]),\n                                      T_ptr(T_ptr(T_vtable()))));\n-    let box = Load(bcx, GEPi(bcx, val, [0, 1]));\n+    let box = Load(bcx, GEPi(bcx, val, [0u, 1u]));\n     // FIXME[impl] I doubt this is alignment-safe\n-    let self = GEPi(bcx, box, [0, abi::box_field_body]);\n+    let self = GEPi(bcx, box, [0u, abi::box_field_body]);\n     let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(box));\n     trans_vtable_callee(bcx, env, vtable, callee_id, n_method)\n }\n@@ -282,12 +282,12 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let bcx = trans_expr_save_in(bcx, val, body);\n     revoke_clean(bcx, box);\n     let result = get_dest_addr(dest);\n-    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),\n+    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]),\n                                 T_ptr(val_ty(box))));\n     let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n-    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0, 0]),\n+    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0u, 0u]),\n                                    T_ptr(val_ty(vtable))));\n     bcx\n }"}, {"sha": "77e3a1f30671c29b5ce5705d4d53f8b5e8c9a56d", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -599,7 +599,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     let mut atys = x86_64.arg_tys;\n                     let mut attrs = x86_64.attrs;\n                     if x86_64.sret {\n-                        let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         let llretloc = Load(bcx, llretptr);\n                         llargvals = [llretloc];\n                         atys = vec::tail(atys);\n@@ -608,14 +608,14 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     while i < n {\n                         let llargval = if atys[i].cast {\n                             let arg_ptr = GEPi(bcx, llargbundle,\n-                                               [0, i as int]);\n+                                               [0u, i]);\n                             let arg_ptr = BitCast(bcx, arg_ptr,\n                                               T_ptr(atys[i].ty));\n                             Load(bcx, arg_ptr)\n                         } else if option::is_some(attrs[i]) {\n-                            GEPi(bcx, llargbundle, [0, i as int])\n+                            GEPi(bcx, llargbundle, [0u, i])\n                         } else {\n-                            load_inbounds(bcx, llargbundle, [0, i as int])\n+                            load_inbounds(bcx, llargbundle, [0u, i])\n                         };\n                         llargvals += [llargval];\n                         i += 1u;\n@@ -624,7 +624,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                 _ {\n                     while i < n {\n                         let llargval = load_inbounds(bcx, llargbundle,\n-                                                          [0, i as int]);\n+                                                          [0u, i]);\n                         llargvals += [llargval];\n                         i += 1u;\n                     }\n@@ -652,7 +652,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                         ret;\n                     }\n                     let n = vec::len(tys.arg_tys);\n-                    let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                    let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                     let llretloc = Load(bcx, llretptr);\n                     if x86_64.ret_ty.cast {\n                         let tmp_ptr = BitCast(bcx, llretloc,\n@@ -666,7 +666,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     if tys.ret_def {\n                         let n = vec::len(tys.arg_tys);\n                         // R** llretptr = &args->r;\n-                        let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n                         // R* llretloc = *llretptr; /* (args->r) */\n                         let llretloc = Load(bcx, llretptr);\n                         // *args->r = r;\n@@ -736,11 +736,11 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             let implicit_args = first_real_arg; // ret + env\n             while i < n {\n                 let llargval = get_param(llwrapfn, i + implicit_args);\n-                store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n+                store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n                 i += 1u;\n             }\n             let llretptr = get_param(llwrapfn, 0u);\n-            store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+            store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n         }\n \n         fn build_ret(bcx: block, _tys: @c_stack_tys,\n@@ -868,12 +868,12 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             let mut llargvals = [];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n-            let llretptr = load_inbounds(bcx, llargbundle, [0, n as int]);\n+            let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n             llargvals += [llretptr];\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n             llargvals += [llenvptr];\n             while i < n {\n-                let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n+                let llargval = load_inbounds(bcx, llargbundle, [0u, i]);\n                 llargvals += [llargval];\n                 i += 1u;\n             }\n@@ -924,33 +924,28 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         let mut argval = get_param(llwrapfn, i + j);\n                         if option::is_some(attrs[i]) {\n                             argval = Load(bcx, argval);\n-                            store_inbounds(bcx, argval, llargbundle,\n-                                                        [0, i as int]);\n+                            store_inbounds(bcx, argval, llargbundle, [0u, i]);\n                         } else if atys[i].cast {\n-                            let argptr = GEPi(bcx, llargbundle,\n-                                              [0, i as int]);\n+                            let argptr = GEPi(bcx, llargbundle, [0u, i]);\n                             let argptr = BitCast(bcx, argptr,\n                                                  T_ptr(atys[i].ty));\n                             Store(bcx, argval, argptr);\n                         } else {\n-                            store_inbounds(bcx, argval, llargbundle,\n-                                                        [0, i as int]);\n+                            store_inbounds(bcx, argval, llargbundle, [0u, i]);\n                         }\n                         i += 1u;\n                     }\n-                    store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n                 }\n                 _ {\n                     let llretptr = alloca(bcx, tys.ret_ty);\n-                    let mut i = 0u;\n                     let n = vec::len(tys.arg_tys);\n-                    while i < n {\n+                    uint::range(0u, n) {|i|\n                         let llargval = get_param(llwrapfn, i);\n                         store_inbounds(bcx, llargval, llargbundle,\n-                                                      [0, i as int]);\n-                        i += 1u;\n-                    }\n-                    store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+                                                      [0u, i]);\n+                    };\n+                    store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n                 }\n             }\n         }\n@@ -965,8 +960,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         ret;\n                     }\n                     let n = vec::len(tys.arg_tys);\n-                    let llretval = load_inbounds(bcx, llargbundle,\n-                                                      [0, n as int]);\n+                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]);\n                     let llretval = if x86_64.ret_ty.cast {\n                         let retptr = BitCast(bcx, llretval,\n                                                   T_ptr(x86_64.ret_ty.ty));\n@@ -978,8 +972,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 }\n                 _ {\n                     let n = vec::len(tys.arg_tys);\n-                    let llretval = load_inbounds(bcx, llargbundle,\n-                                                      [0, n as int]);\n+                    let llretval = load_inbounds(bcx, llargbundle, [0u, n]);\n                     let llretval = Load(bcx, llretval);\n                     Ret(bcx, llretval);\n                 }"}, {"sha": "bcc5bbc3fa06632cff6063d566be9a35538239cc", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8affc78e8a0e420e1755a34fc7f5e4021c512e9d/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8affc78e8a0e420e1755a34fc7f5e4021c512e9d", "patch": "@@ -13,18 +13,18 @@ import common::*;\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n-    Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n-    Store(bcx, fill, GEPi(bcx, vptr, [0, abi::vec_elt_fill]));\n+    Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_alloc]))\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n-    let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems]);\n+    let ptr = GEPi(bcx, vptr, [0u, abi::vec_elt_elems]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n@@ -41,8 +41,8 @@ fn alloc_uniq_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n     let llvecty = ccx.opaque_vec_type;\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n     let vecptr = shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    Store(bcx, fill, GEPi(bcx, vecptr, [0, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, vecptr, [0, abi::vec_elt_alloc]));\n+    Store(bcx, fill, GEPi(bcx, vecptr, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, vecptr, [0u, abi::vec_elt_alloc]));\n     ret {bcx: bcx, val: vecptr};\n }\n \n@@ -69,7 +69,7 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let newptr = shared_malloc(bcx, val_ty(vptr), size);\n     call_memmove(bcx, newptr, vptr, size);\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n+    Store(bcx, fill, GEPi(bcx, newptr, [0u, abi::vec_elt_alloc]));\n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         iter_vec(bcx, newptr, vec_ty, base::take_ty)\n     } else { bcx };\n@@ -127,8 +127,8 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n \n             let p = base::alloca(bcx, T_struct([T_ptr(llunitty),\n                                                 ccx.int_type]));\n-            Store(bcx, vp, GEPi(bcx, p, [0, abi::slice_elt_base]));\n-            Store(bcx, len, GEPi(bcx, p, [0, abi::slice_elt_len]));\n+            Store(bcx, vp, GEPi(bcx, p, [0u, abi::slice_elt_base]));\n+            Store(bcx, len, GEPi(bcx, p, [0u, abi::slice_elt_len]));\n \n             {bcx: bcx, val: p, dataptr: vp}\n           }\n@@ -205,14 +205,14 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n \n     alt vstore {\n       ty::vstore_fixed(n) {\n-        let base = GEPi(cx, v, [0, 0]);\n+        let base = GEPi(cx, v, [0u, 0u]);\n         let n = if ty::type_is_str(e_ty) { n + 1u } else { n };\n         let len = Mul(cx, C_uint(ccx, n), unit_sz);\n         (base, len)\n       }\n       ty::vstore_slice(_) {\n-        let base = Load(cx, GEPi(cx, v, [0, abi::slice_elt_base]));\n-        let len = Load(cx, GEPi(cx, v, [0, abi::slice_elt_len]));\n+        let base = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_base]));\n+        let len = Load(cx, GEPi(cx, v, [0u, abi::slice_elt_len]));\n         (base, len)\n       }\n       ty::vstore_uniq {"}]}