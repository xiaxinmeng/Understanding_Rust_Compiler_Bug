{"sha": "b664341d917cafade5a2470579a4c122fdcf941b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NjQzNDFkOTE3Y2FmYWRlNWEyNDcwNTc5YTRjMTIyZmRjZjk0MWI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2019-01-29T20:58:17Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2019-01-29T20:58:17Z"}, "message": "Make weak_count return an Option<usize>", "tree": {"sha": "8307da96f6597dc0d8a534bf49ba37bddcda6b0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8307da96f6597dc0d8a534bf49ba37bddcda6b0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b664341d917cafade5a2470579a4c122fdcf941b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b664341d917cafade5a2470579a4c122fdcf941b", "html_url": "https://github.com/rust-lang/rust/commit/b664341d917cafade5a2470579a4c122fdcf941b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b664341d917cafade5a2470579a4c122fdcf941b/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e0edb39baa02c58c373f05014ffd8e3058c93ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0edb39baa02c58c373f05014ffd8e3058c93ad", "html_url": "https://github.com/rust-lang/rust/commit/7e0edb39baa02c58c373f05014ffd8e3058c93ad"}], "stats": {"total": 48, "additions": 22, "deletions": 26}, "files": [{"sha": "72b43b5d6adffe26911ada778370cb26c9edaace", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b664341d917cafade5a2470579a4c122fdcf941b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b664341d917cafade5a2470579a4c122fdcf941b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b664341d917cafade5a2470579a4c122fdcf941b", "patch": "@@ -1300,22 +1300,20 @@ impl<T: ?Sized> Weak<T> {\n \n     /// Gets the number of `Weak` pointers pointing to this value.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return 0. If not,\n-    /// the returned value is at least 1, since `self` still points to the\n+    /// If `self` was created using [`Weak::new`], this will return `None`. If\n+    /// not, the returned value is at least 1, since `self` still points to the\n     /// value.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"0\")]\n-    pub fn weak_count(&self) -> usize {\n-        if let Some(inner) = self.inner() {\n+    pub fn weak_count(&self) -> Option<usize> {\n+        self.inner().map(|inner| {\n             if inner.strong() > 0 {\n                 inner.weak() - 1  // subtract the implicit weak ptr\n             } else {\n                 inner.weak()\n             }\n-        } else {\n-            0\n-        }\n+        })\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n@@ -1658,28 +1656,28 @@ mod tests {\n \n     #[test]\n     fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n+        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n         assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n         let a = Rc::new(0);\n         let w = Rc::downgrade(&a);\n         assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(1));\n         let w2 = w.clone();\n         assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), 2);\n+        assert_eq!(Weak::weak_count(&w), Some(2));\n         assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), 2);\n+        assert_eq!(Weak::weak_count(&w2), Some(2));\n         drop(w);\n         assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         let a2 = a.clone();\n         assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         drop(a2);\n         drop(a);\n         assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         drop(w2);\n     }\n "}, {"sha": "777851e192501eeac943a9a0e0f15214a3b28895", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b664341d917cafade5a2470579a4c122fdcf941b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b664341d917cafade5a2470579a4c122fdcf941b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b664341d917cafade5a2470579a4c122fdcf941b", "patch": "@@ -1146,12 +1146,12 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"0\")]\n-    pub fn weak_count(&self) -> usize {\n+    pub fn weak_count(&self) -> Option<usize> {\n         // Due to the implicit weak pointer added when any strong pointers are\n         // around, we cannot implement `weak_count` correctly since it\n         // necessarily requires accessing the strong count and weak count in an\n         // unsynchronized fashion. So this version is a bit racy.\n-        if let Some(inner) = self.inner() {\n+        self.inner().map(|inner| {\n             let strong = inner.strong.load(SeqCst);\n             let weak = inner.weak.load(SeqCst);\n             if strong == 0 {\n@@ -1169,9 +1169,7 @@ impl<T: ?Sized> Weak<T> {\n                 // pointer), we guard against that specifically.\n                 cmp::max(1, weak - 1)\n             }\n-        } else {\n-            0\n-        }\n+        })\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n@@ -1695,28 +1693,28 @@ mod tests {\n \n     #[test]\n     fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n+        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n         assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n         let a = Arc::new(0);\n         let w = Arc::downgrade(&a);\n         assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), 1);\n+        assert_eq!(Weak::weak_count(&w), Some(1));\n         let w2 = w.clone();\n         assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), 2);\n+        assert_eq!(Weak::weak_count(&w), Some(2));\n         assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), 2);\n+        assert_eq!(Weak::weak_count(&w2), Some(2));\n         drop(w);\n         assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         let a2 = a.clone();\n         assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         drop(a2);\n         drop(a);\n         assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), 1);\n+        assert_eq!(Weak::weak_count(&w2), Some(1));\n         drop(w2);\n     }\n "}]}