{"sha": "dc7f3df27fd17b41b3448f461138947db4c9bab2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjN2YzZGYyN2ZkMTdiNDFiMzQ0OGY0NjExMzg5NDdkYjRjOWJhYjI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-07-13T01:35:47Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-09-06T20:35:12Z"}, "message": "awesome new bug! added test case", "tree": {"sha": "e5e4f6db426356fb44c6bb0bcec6f3392d2f2f50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e4f6db426356fb44c6bb0bcec6f3392d2f2f50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc7f3df27fd17b41b3448f461138947db4c9bab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7f3df27fd17b41b3448f461138947db4c9bab2", "html_url": "https://github.com/rust-lang/rust/commit/dc7f3df27fd17b41b3448f461138947db4c9bab2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc7f3df27fd17b41b3448f461138947db4c9bab2/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b548e71806b735a215f7dba26a20771c4f924bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b548e71806b735a215f7dba26a20771c4f924bd", "html_url": "https://github.com/rust-lang/rust/commit/7b548e71806b735a215f7dba26a20771c4f924bd"}], "stats": {"total": 81, "additions": 68, "deletions": 13}, "files": [{"sha": "3a5b9f2f7c674c2832868041170e8103291d5955", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 68, "deletions": 13, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dc7f3df27fd17b41b3448f461138947db4c9bab2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7f3df27fd17b41b3448f461138947db4c9bab2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dc7f3df27fd17b41b3448f461138947db4c9bab2", "patch": "@@ -420,7 +420,6 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                     span: span\n                 }\n             });\n-            let fm = fresh_mark();\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n@@ -1533,7 +1532,7 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, EMPTY_CTXT};\n-    use ast_util::{get_sctable, mtwt_resolve, new_rename};\n+    use ast_util::{get_sctable, mtwt_marksof, mtwt_resolve, new_rename};\n     use codemap;\n     use codemap::Spanned;\n     use parse;\n@@ -1709,31 +1708,40 @@ mod test {\n     //\n     // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n     // names; differences in marks don't matter any more.\n-    type renaming_test = (&'static str, ~[~[uint]]);\n+    //\n+    // oog... I also want tests that check \"binding-identifier-=?\". That is,\n+    // not just \"do these have the same name\", but \"do they have the same\n+    // name *and* the same marks\"? Understanding this is really pretty painful.\n+    // in principle, you might want to control this boolean on a per-varref basis,\n+    // but that would make things even harder to understand, and might not be\n+    // necessary for thorough testing.\n+    type renaming_test = (&'static str, ~[~[uint]], bool);\n \n     #[test]\n     fn automatic_renaming () {\n-        // need some other way to test these...\n         let tests : ~[renaming_test] =\n             ~[// b & c should get new names throughout, in the expr too:\n                 (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n-                 ~[~[0,1],~[2]]),\n+                 ~[~[0,1],~[2]], false),\n                 // both x's should be renamed (how is this causing a bug?)\n                 (\"fn main () {let x : int = 13;x;}\",\n-                 ~[~[0]]),\n+                 ~[~[0]], false),\n                 // the use of b after the + should be renamed, the other one not:\n                 (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n-                 ~[~[1]]),\n+                 ~[~[1]], false),\n                 // the b before the plus should not be renamed (requires marks)\n                 (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n-                 ~[~[1]]),\n+                 ~[~[1]], false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}))\n                   fn main() -> int {user!(z)}\",\n-                 ~[~[0]])\n+                 ~[~[0]], false),\n+                // can't believe I missed this one : a macro def that refers to a local var:\n+                (\"fn main() {let x = 19; macro_rules! getx(()=>(x)); getx!();}\",\n+                ~[~[0]], true)\n                 // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n                 // commenting it out.\n                 // the z flows into and out of two macros (g & f) along one path, and one\n@@ -1750,10 +1758,10 @@ mod test {\n         }\n     }\n \n-\n+    // run one of the renaming tests\n     fn run_renaming_test(t : &renaming_test) {\n-        let (teststr, bound_connections) = match *t {\n-            (ref str,ref conns) => (str.to_managed(), conns.clone())\n+        let (teststr, bound_connections, bound_ident_check) = match *t {\n+            (ref str,ref conns, bic) => (str.to_managed(), conns.clone(), bic)\n         };\n         let cr = expand_crate_str(teststr.to_managed());\n         // find the bindings:\n@@ -1766,15 +1774,18 @@ mod test {\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n             let binding_name = mtwt_resolve(bindings[binding_idx]);\n+            let binding_marks = mtwt_marksof(bindings[binding_idx].ctxt,binding_name);\n             // shouldmatch can't name varrefs that don't exist:\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n                 if shouldmatch.contains(&idx) {\n                     // it should be a path of length 1, and it should\n-                    // be free-identifier=? to the given binding\n+                    // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n                     let varref_name = mtwt_resolve(varref.segments[0].identifier);\n+                    let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n+                                                    binding_name);\n                     if (!(varref_name==binding_name)){\n                         std::io::println(\"uh oh, should match but doesn't:\");\n                         std::io::println(fmt!(\"varref: %?\",varref));\n@@ -1786,6 +1797,10 @@ mod test {\n                         }\n                     }\n                     assert_eq!(varref_name,binding_name);\n+                    if (bound_ident_check) {\n+                        // we need to check the marks, too:\n+                        assert_eq!(varref_marks,binding_marks.clone());\n+                    }\n                 } else {\n                     let fail = (varref.segments.len() == 1)\n                         && (mtwt_resolve(varref.segments[0].identifier) == binding_name);\n@@ -1854,6 +1869,46 @@ mod test {\n         };\n     }\n \n+    #[test] fn fmt_in_macro_used_inside_module_macro() {\n+        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>(fmt!(\\\"left: %?\\\", $b)))\n+macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n+foo_module!()\n+\";\n+        let cr = expand_crate_str(crate_str);\n+        // find the xx binding\n+        let bindings = @mut ~[];\n+        visit::walk_crate(&mut new_name_finder(bindings), cr, ());\n+        let cxbinds : ~[&ast::Ident] =\n+            bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n+        let cxbind = match cxbinds {\n+            [b] => b,\n+            _ => fail!(\"expected just one binding for ext_cx\")\n+        };\n+        let resolved_binding = mtwt_resolve(*cxbind);\n+        // find all the xx varrefs:\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), cr, ());\n+        // the xx binding should bind all of the xx varrefs:\n+        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n+                                          && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n+                                     }).enumerate() {\n+            if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n+                std::io::println(\"uh oh, xx binding didn't match xx varref:\");\n+                std::io::println(fmt!(\"this is xx varref # %?\",idx));\n+                std::io::println(fmt!(\"binding: %?\",cxbind));\n+                std::io::println(fmt!(\"resolves to: %?\",resolved_binding));\n+                std::io::println(fmt!(\"varref: %?\",v.segments[0].identifier));\n+                std::io::println(fmt!(\"resolves to: %?\",mtwt_resolve(v.segments[0].identifier)));\n+                let table = get_sctable();\n+                std::io::println(\"SC table:\");\n+                for (idx,val) in table.table.iter().enumerate() {\n+                    std::io::println(fmt!(\"%4u : %?\",idx,val));\n+                }\n+            }\n+            assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);\n+        };\n+    }\n+\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");"}]}