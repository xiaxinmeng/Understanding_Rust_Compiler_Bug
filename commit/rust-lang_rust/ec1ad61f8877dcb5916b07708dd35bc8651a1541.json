{"sha": "ec1ad61f8877dcb5916b07708dd35bc8651a1541", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjMWFkNjFmODg3N2RjYjU5MTZiMDc3MDhkZDM1YmM4NjUxYTE1NDE=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-02-12T15:48:03Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:29Z"}, "message": "Implement AST lowering for asm!", "tree": {"sha": "48f40f58a145d957c4d800739cbc210887afbc6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f40f58a145d957c4d800739cbc210887afbc6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec1ad61f8877dcb5916b07708dd35bc8651a1541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1ad61f8877dcb5916b07708dd35bc8651a1541", "html_url": "https://github.com/rust-lang/rust/commit/ec1ad61f8877dcb5916b07708dd35bc8651a1541", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec1ad61f8877dcb5916b07708dd35bc8651a1541/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b1501d8c3deda64c5b43ce2c9a0c51dd91169a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b1501d8c3deda64c5b43ce2c9a0c51dd91169a", "html_url": "https://github.com/rust-lang/rust/commit/d5b1501d8c3deda64c5b43ce2c9a0c51dd91169a"}], "stats": {"total": 326, "additions": 320, "deletions": 6}, "files": [{"sha": "f713db9a6cc195991a8496a5c5206249c4efe634", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 294, "deletions": 2, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=ec1ad61f8877dcb5916b07708dd35bc8651a1541", "patch": "@@ -3,13 +3,17 @@ use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericAr\n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_target::asm;\n+use std::collections::hash_map::Entry;\n+use std::fmt::Write;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n@@ -175,7 +179,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_asm(asm),\n+                ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n+                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Struct(\n@@ -968,7 +973,294 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         result\n     }\n \n-    fn lower_expr_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n+    fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n+        let asm_arch = if let Some(asm_arch) = self.sess.asm_arch {\n+            asm_arch\n+        } else {\n+            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n+            return hir::ExprKind::Err;\n+        };\n+\n+        // Lower operands to HIR, filter_map skips any operands with invalid\n+        // register classes.\n+        let sess = self.sess;\n+        let operands: Vec<_> = asm\n+            .operands\n+            .iter()\n+            .filter_map(|(op, op_sp)| {\n+                let lower_reg = |reg| {\n+                    Some(match reg {\n+                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+                            asm::InlineAsmReg::parse(\n+                                asm_arch,\n+                                |feature| {\n+                                    self.sess.target_features.contains(&Symbol::intern(feature))\n+                                },\n+                                s,\n+                            )\n+                            .map_err(|e| {\n+                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            })\n+                            .ok()?,\n+                        ),\n+                        InlineAsmRegOrRegClass::RegClass(s) => {\n+                            asm::InlineAsmRegOrRegClass::RegClass(\n+                                asm::InlineAsmRegClass::parse(asm_arch, s)\n+                                    .map_err(|e| {\n+                                        let msg = format!(\n+                                            \"invalid register class `{}`: {}\",\n+                                            s.as_str(),\n+                                            e\n+                                        );\n+                                        sess.struct_span_err(*op_sp, &msg).emit();\n+                                    })\n+                                    .ok()?,\n+                            )\n+                        }\n+                    })\n+                };\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(*reg)?,\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(*reg)?,\n+                        late: *late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                    },\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(*reg)?,\n+                        late: *late,\n+                        expr: self.lower_expr_mut(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(*reg)?,\n+                            late: *late,\n+                            in_expr: self.lower_expr_mut(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { expr } => {\n+                        hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n+                    }\n+                    InlineAsmOperand::Sym { expr } => {\n+                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+                    }\n+                };\n+                Some(op)\n+            })\n+            .collect();\n+\n+        // Stop if there were any errors when lowering the register classes\n+        if operands.len() != asm.operands.len() {\n+            return hir::ExprKind::Err;\n+        }\n+\n+        // Validate template modifiers against the register classes for the operands\n+        for p in &asm.template {\n+            if let asm::InlineAsmTemplatePiece::Placeholder {\n+                operand_idx,\n+                modifier: Some(modifier),\n+                span: placeholder_span,\n+            } = *p\n+            {\n+                let op_sp = asm.operands[operand_idx].1;\n+                match &operands[operand_idx] {\n+                    hir::InlineAsmOperand::In { reg, .. }\n+                    | hir::InlineAsmOperand::Out { reg, .. }\n+                    | hir::InlineAsmOperand::InOut { reg, .. }\n+                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n+                        let class = reg.reg_class();\n+                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if !valid_modifiers.contains(&modifier) {\n+                            let mut err = sess.struct_span_err(\n+                                placeholder_span,\n+                                \"invalid asm template modifier for this register class\",\n+                            );\n+                            err.span_label(placeholder_span, \"template modifier\");\n+                            err.span_label(op_sp, \"argument\");\n+                            if !valid_modifiers.is_empty() {\n+                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n+                                for m in &valid_modifiers[1..] {\n+                                    let _ = write!(mods, \", `{}`\", m);\n+                                }\n+                                err.note(&format!(\n+                                    \"the `{}` register class supports \\\n+                                     the following template modifiers: {}\",\n+                                    class.name(),\n+                                    mods\n+                                ));\n+                            } else {\n+                                err.note(&format!(\n+                                    \"the `{}` register class does not support template modifiers\",\n+                                    class.name()\n+                                ));\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::Const { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `const` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                    hir::InlineAsmOperand::Sym { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `sym` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut used_input_regs = FxHashMap::default();\n+        let mut used_output_regs = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            let op_sp = asm.operands[idx].1;\n+            if let Some(reg) = op.reg() {\n+                // Validate register classes against currently enabled target\n+                // features. We check that at least one type is available for\n+                // the current target.\n+                let reg_class = reg.reg_class();\n+                let mut required_features = vec![];\n+                for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                    if let Some(feature) = feature {\n+                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                            required_features.clear();\n+                            break;\n+                        } else {\n+                            required_features.push(feature);\n+                        }\n+                    } else {\n+                        required_features.clear();\n+                        break;\n+                    }\n+                }\n+                required_features.sort();\n+                required_features.dedup();\n+                match &required_features[..] {\n+                    [] => {}\n+                    [feature] => {\n+                        let msg = format!(\n+                            \"register class `{}` requires the `{}` target feature\",\n+                            reg_class.name(),\n+                            feature\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                    features => {\n+                        let msg = format!(\n+                            \"register class `{}` requires at least one target feature: {}\",\n+                            reg_class.name(),\n+                            features.join(\", \")\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                }\n+\n+                // Check for conflicts between explicit register operands.\n+                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    let (input, output) = match op {\n+                        hir::InlineAsmOperand::In { .. } => (true, false),\n+                        // Late output do not conflict with inputs, but normal outputs do\n+                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n+                        hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n+                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                            unreachable!()\n+                        }\n+                    };\n+\n+                    // Flag to output the error only once per operand\n+                    let mut skip = false;\n+                    reg.overlapping_regs(|r| {\n+                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n+                                         input| {\n+                            match used_regs.entry(r) {\n+                                Entry::Occupied(o) => {\n+                                    if !skip {\n+                                        skip = true;\n+\n+                                        let idx2 = *o.get();\n+                                        let op2 = &operands[idx2];\n+                                        let op_sp2 = asm.operands[idx2].1;\n+                                        let reg2 = match op2.reg() {\n+                                            Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                            _ => unreachable!(),\n+                                        };\n+\n+                                        let msg = format!(\n+                                            \"register `{}` conflicts with register `{}`\",\n+                                            reg.name(),\n+                                            reg2.name()\n+                                        );\n+                                        let mut err = sess.struct_span_err(op_sp, &msg);\n+                                        err.span_label(\n+                                            op_sp,\n+                                            &format!(\"register `{}`\", reg.name()),\n+                                        );\n+                                        err.span_label(\n+                                            op_sp2,\n+                                            &format!(\"register `{}`\", reg2.name()),\n+                                        );\n+\n+                                        match (op, op2) {\n+                                            (\n+                                                hir::InlineAsmOperand::In { .. },\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                            )\n+                                            | (\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                                hir::InlineAsmOperand::In { .. },\n+                                            ) => {\n+                                                assert!(!*late);\n+                                                let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                                let msg = &format!(\n+                                                    \"use `lateout` instead of \\\n+                                                     `out` to avoid conflict\"\n+                                                );\n+                                                err.span_help(out_op_sp, msg);\n+                                            }\n+                                            _ => {}\n+                                        }\n+\n+                                        err.emit();\n+                                    }\n+                                }\n+                                Entry::Vacant(v) => {\n+                                    v.insert(idx);\n+                                }\n+                            }\n+                        };\n+                        if input {\n+                            check(&mut used_input_regs, true);\n+                        }\n+                        if output {\n+                            check(&mut used_output_regs, false);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        let operands = self.arena.alloc_from_iter(operands);\n+        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options };\n+        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n+    }\n+\n+    fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::LlvmInlineAsmInner {\n             inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n             outputs: asm"}, {"sha": "fabb17134a3c7fc98759efcbfc6b4ce62e2cc15b", "filename": "src/librustc_hir/arena.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_hir%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_hir%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Farena.rs?ref=ec1ad61f8877dcb5916b07708dd35bc8651a1541", "patch": "@@ -14,6 +14,8 @@ macro_rules! arena_types {\n             // HIR types\n             [few] hir_krate: rustc_hir::Crate<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n+            [] asm_operand: rustc_hir::InlineAsmOperand<$tcx>,\n+            [] asm_template: rustc_target::asm::InlineAsmTemplatePiece,\n             [] attribute: rustc_ast::ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,\n             [] bare_fn_ty: rustc_hir::BareFnTy<$tcx>,\n@@ -28,7 +30,8 @@ macro_rules! arena_types {\n             [] fn_decl: rustc_hir::FnDecl<$tcx>,\n             [] foreign_item: rustc_hir::ForeignItem<$tcx>,\n             [] impl_item_ref: rustc_hir::ImplItemRef<$tcx>,\n-            [] inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n+            [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n+            [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n             [few] macro_def: rustc_hir::MacroDef<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,"}, {"sha": "5a76802014e0d18b8bb4d1a6d53355f76a15f914", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=ec1ad61f8877dcb5916b07708dd35bc8651a1541", "patch": "@@ -42,12 +42,15 @@ use std::{panic, thread};\n /// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(\n     cfg: &mut CrateConfig,\n-    sess: &Session,\n+    sess: &mut Session,\n     codegen_backend: &dyn CodegenBackend,\n ) {\n     let tf = sym::target_feature;\n \n-    cfg.extend(codegen_backend.target_features(sess).into_iter().map(|feat| (tf, Some(feat))));\n+    let target_features = codegen_backend.target_features(sess);\n+    sess.target_features.extend(target_features.iter().cloned());\n+\n+    cfg.extend(target_features.into_iter().map(|feat| (tf, Some(feat))));\n \n     if sess.crt_static(None) {\n         cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n@@ -75,7 +78,7 @@ pub fn create_session(\n     let codegen_backend = get_codegen_backend(&sess);\n \n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n-    add_configuration(&mut cfg, &sess, &*codegen_backend);\n+    add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n     sess.parse_sess.config = cfg;\n \n     (Lrc::new(sess), Lrc::new(codegen_backend), source_map)"}, {"sha": "143401dd3b62244d0d1692e36b4b0c6c80abaf72", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec1ad61f8877dcb5916b07708dd35bc8651a1541/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=ec1ad61f8877dcb5916b07708dd35bc8651a1541", "patch": "@@ -23,6 +23,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{self, FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n use rustc_span::{SourceFileHashAlgorithm, Symbol};\n+use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple, TlsModel};\n \n@@ -31,6 +32,7 @@ use std::env;\n use std::io::Write;\n use std::num::NonZeroU32;\n use std::path::PathBuf;\n+use std::str::FromStr;\n use std::sync::Arc;\n use std::time::Duration;\n \n@@ -158,6 +160,12 @@ pub struct Session {\n     /// if Rust was built with path remapping to `/rustc/$hash` enabled\n     /// (the `rust.remap-debuginfo` option in `config.toml`).\n     pub real_rust_source_base_dir: Option<PathBuf>,\n+\n+    /// Architecture to use for interpreting asm!.\n+    pub asm_arch: Option<InlineAsmArch>,\n+\n+    /// Set of enabled features for the current target.\n+    pub target_features: FxHashSet<Symbol>,\n }\n \n pub struct PerfStats {\n@@ -1183,6 +1191,12 @@ pub fn build_session_with_source_map(\n         if candidate.join(\"src/libstd/lib.rs\").is_file() { Some(candidate) } else { None }\n     };\n \n+    let asm_arch = if target_cfg.target.options.allow_asm {\n+        InlineAsmArch::from_str(&target_cfg.target.arch).ok()\n+    } else {\n+        None\n+    };\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1223,6 +1237,8 @@ pub fn build_session_with_source_map(\n         ctfe_backtrace,\n         miri_unleashed_features: Lock::new(Default::default()),\n         real_rust_source_base_dir,\n+        asm_arch,\n+        target_features: FxHashSet::default(),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}]}