{"sha": "d6c15d9b2daecdbe32eca894bda40c424798f5a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YzE1ZDliMmRhZWNkYmUzMmVjYTg5NGJkYTQwYzQyNDc5OGY1YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-04T06:40:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-04T06:40:12Z"}, "message": "Auto merge of #21919 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "a9e08bd10dc4cb6cb0d489e120001c3445e89b00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9e08bd10dc4cb6cb0d489e120001c3445e89b00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6c15d9b2daecdbe32eca894bda40c424798f5a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c15d9b2daecdbe32eca894bda40c424798f5a0", "html_url": "https://github.com/rust-lang/rust/commit/d6c15d9b2daecdbe32eca894bda40c424798f5a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6c15d9b2daecdbe32eca894bda40c424798f5a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450", "html_url": "https://github.com/rust-lang/rust/commit/3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450"}, {"sha": "70ecd8ed38d5bedbeb281d78c3da44477764236a", "url": "https://api.github.com/repos/rust-lang/rust/commits/70ecd8ed38d5bedbeb281d78c3da44477764236a", "html_url": "https://github.com/rust-lang/rust/commit/70ecd8ed38d5bedbeb281d78c3da44477764236a"}], "stats": {"total": 6336, "additions": 5885, "deletions": 451}, "files": [{"sha": "326946837bf661ee0c158a212832a00cbd303525", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -2432,6 +2432,8 @@ The currently implemented features of the reference compiler are:\n * `simd` - Allows use of the `#[simd]` attribute, which is overly simple and\n            not the SIMD interface we want to expose in the long term.\n \n+* `staged_api` - Allows usage of stability markers and `#![staged_api]` in a crate\n+\n * `struct_inherit` - Allows using struct inheritance, which is barely\n                      implemented and will probably be removed. Don't use this.\n \n@@ -2459,6 +2461,11 @@ The currently implemented features of the reference compiler are:\n                         which is considered wildly unsafe and will be\n                         obsoleted by language improvements.\n \n+* `unmarked_api` - Allows use of items within a `#![staged_api]` crate\n+                   which have not been marked with a stability marker.\n+                   Such items should not be allowed by the compiler to exist,\n+                   so if you need this there probably is a compiler bug.\n+\n * `associated_types` - Allows type aliases in traits. Experimental.\n \n If a feature is promoted to a language feature, then all existing programs will"}, {"sha": "340a8d59612f21af31e685b6f5e40fb824b234cf", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -45,22 +45,18 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use core::prelude::*;\n+\n use core::any::Any;\n-use core::clone::Clone;\n-use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n+use core::cmp::Ordering;\n use core::default::Default;\n use core::error::{Error, FromError};\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::iter::Iterator;\n-use core::marker::Sized;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n-use core::option::Option;\n use core::ptr::Unique;\n use core::raw::TraitObject;\n-use core::result::Result::{Ok, Err};\n-use core::result::Result;\n \n /// A value that represents the heap. This is the default place that the `box` keyword allocates\n /// into when no place is supplied.\n@@ -296,18 +292,20 @@ impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-impl<'a, T> Iterator for Box<Iterator<Item=T> + 'a> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        (**self).next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (**self).size_hint()\n-    }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator + ?Sized> Iterator for Box<I> {\n+    type Item = I::Item;\n+    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n+    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E: Error + 'a> FromError<E> for Box<Error + 'a> {\n     fn from_error(err: E) -> Box<Error + 'a> {\n         Box::new(err)"}, {"sha": "abcf358a1926c00baee9db9d8f8d8042da941603", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 193, "deletions": 1, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -13,6 +13,8 @@\n \n #![allow(missing_docs)]\n \n+pub use self::Entry::*;\n+\n use core::prelude::*;\n \n use core::cmp::Ordering;\n@@ -66,6 +68,32 @@ pub struct VecMap<V> {\n     v: Vec<Option<V>>,\n }\n \n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub enum Entry<'a, V:'a> {\n+    /// A vacant Entry\n+    Vacant(VacantEntry<'a, V>),\n+    /// An occupied Entry\n+    Occupied(OccupiedEntry<'a, V>),\n+}\n+\n+/// A vacant Entry.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub struct VacantEntry<'a, V:'a> {\n+    map: &'a mut VecMap<V>,\n+    index: usize,\n+}\n+\n+/// An occupied Entry.\n+#[unstable(feature = \"collections\",\n+           reason = \"precise API still under development\")]\n+pub struct OccupiedEntry<'a, V:'a> {\n+    map: &'a mut VecMap<V>,\n+    index: usize,\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> Default for VecMap<V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -485,6 +513,119 @@ impl<V> VecMap<V> {\n         let result = &mut self.v[*key];\n         result.take()\n     }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecMap;\n+    /// use std::collections::vec_map::Entry;\n+    ///\n+    /// let mut count: VecMap<u32> = VecMap::new();\n+    ///\n+    /// // count the number of occurrences of numbers in the vec\n+    /// for x in vec![1, 2, 1, 2, 3, 4, 1, 2, 4].iter() {\n+    ///     match count.entry(*x) {\n+    ///         Entry::Vacant(view) => {\n+    ///             view.insert(1);\n+    ///         },\n+    ///         Entry::Occupied(mut view) => {\n+    ///             let v = view.get_mut();\n+    ///             *v += 1;\n+    ///         },\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(count[1], 3);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"precise API still under development\")]\n+    pub fn entry(&mut self, key: usize) -> Entry<V> {\n+        // FIXME(Gankro): this is basically the dumbest implementation of\n+        // entry possible, because weird non-lexical borrows issues make it\n+        // completely insane to do any other way. That said, Entry is a border-line\n+        // useless construct on VecMap, so it's hardly a big loss.\n+        if self.contains_key(&key) {\n+            Occupied(OccupiedEntry {\n+                map: self,\n+                index: key,\n+            })\n+        } else {\n+            Vacant(VacantEntry {\n+                map: self,\n+                index: key,\n+            })\n+        }\n+    }\n+}\n+\n+\n+impl<'a, V> Entry<'a, V> {\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, V>> {\n+        match self {\n+            Occupied(entry) => Ok(entry.into_mut()),\n+            Vacant(entry) => Err(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, V> VacantEntry<'a, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        let index = self.index;\n+        self.map.insert(index, value);\n+        &mut self.map[index]\n+    }\n+}\n+\n+impl<'a, V> OccupiedEntry<'a, V> {\n+    /// Gets a reference to the value in the entry.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn get(&self) -> &V {\n+        let index = self.index;\n+        &self.map[index]\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        let index = self.index;\n+        &mut self.map[index]\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        let index = self.index;\n+        &mut self.map[index]\n+    }\n+\n+    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// and returns the entry's old value.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        let index = self.index;\n+        self.map.insert(index, value).unwrap()\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    #[unstable(feature = \"collections\",\n+               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+    pub fn remove(self) -> V {\n+        let index = self.index;\n+        self.map.remove(&index).unwrap()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -783,7 +924,7 @@ mod test_map {\n     use prelude::*;\n     use core::hash::{hash, SipHasher};\n \n-    use super::VecMap;\n+    use super::{VecMap, Occupied, Vacant};\n \n     #[test]\n     fn test_get_mut() {\n@@ -1135,6 +1276,57 @@ mod test_map {\n \n         map[4];\n     }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: VecMap<i32> = xs.iter().map(|&x| x).collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.insert(100), 10);\n+            }\n+        }\n+        assert_eq!(map.get(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                *v *= 10;\n+            }\n+        }\n+        assert_eq!(map.get(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.remove(), 30);\n+            }\n+        }\n+        assert_eq!(map.get(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.insert(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "161f6c78921630e68c952fdeb90de7fe4627620c", "filename": "src/libcore/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -51,7 +51,7 @@\n //! use std::error::FromError;\n //! use std::old_io::{File, IoError};\n //! use std::os::{MemoryMap, MapError};\n-//! use std::path::Path;\n+//! use std::old_path::Path;\n //!\n //! enum MyError {\n //!     Io(IoError),"}, {"sha": "60262857765e26854a24012b825df22eb3f06ae9", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -264,6 +264,7 @@ pub trait Show {\n #[lang = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n@@ -290,6 +291,7 @@ pub trait String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Display {\n     /// Formats the value using the given formatter.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n "}, {"sha": "23157072d536b554e14e47d01207755a4120665b", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -101,16 +101,11 @@ pub trait Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n }\n \n-impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        (**self).next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (**self).size_hint()\n-    }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n+    type Item = I::Item;\n+    fn next(&mut self) -> Option<I::Item> { (**self).next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n }\n \n /// Conversion from an `Iterator`\n@@ -119,6 +114,7 @@ impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n@@ -548,9 +544,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next() == Some(5));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref<'r>(&'r mut self) -> ByRef<'r, Self> {\n-        ByRef{iter: self}\n-    }\n+    fn by_ref(&mut self) -> &mut Self { self }\n \n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n@@ -723,11 +717,12 @@ pub trait IteratorExt: Iterator + Sized {\n         P: FnMut(Self::Item) -> bool,\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n-        let len = self.len();\n-        for i in (0..len).rev() {\n-            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n+        let mut i = self.len() - 1;\n+        while let Some(v) = self.next_back() {\n+            if predicate(v) {\n                 return Some(i);\n             }\n+            i -= 1;\n         }\n         None\n     }\n@@ -1017,15 +1012,22 @@ impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n-/// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n-/// elements from the *same* range, and do not work independently of each other.\n+/// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and\n+/// `next_back()` exhaust elements from the *same* range, and do not work\n+/// independently of each other.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// Yield an element from the end of the range, returning `None` if the range is empty.\n+    /// Yield an element from the end of the range, returning `None` if the\n+    /// range is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n+    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n+}\n+\n /// An object implementing random access indexing by `usize`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n@@ -1065,6 +1067,9 @@ pub trait ExactSizeIterator: Iterator {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n+\n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1117,32 +1122,6 @@ impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAcc\n     }\n }\n \n-/// A mutable reference to an iterator\n-#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ByRef<'a, I:'a> {\n-    iter: &'a mut I,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next_back() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I> ExactSizeIterator for ByRef<'a, I> where I: 'a + ExactSizeIterator {}\n-\n /// A trait for iterators over elements which can be added together\n #[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n@@ -1821,6 +1800,7 @@ impl<I: Iterator> Peekable<I> {\n     /// Return a reference to the next element of the iterator with out\n     /// advancing it, or None if the iterator is exhausted.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&mut self) -> Option<&I::Item> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();"}, {"sha": "1c931856fa17c5a9e9c9d82be30304d8e41fe715", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -17,7 +17,7 @@ use std::cmp::Ordering;\n use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n-use std::path::BytesContainer;\n+use std::old_path::BytesContainer;\n use std::slice;\n \n // Note 1: It is not clear whether the flexibility of providing both"}, {"sha": "ea584407944abeaa89d657e1cf47953fa62700ef", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprClosure(_, _, _, ref b) => {\n+            ast::ExprClosure(_, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", e.span),"}, {"sha": "c0fabb2a3481d7c622145e6ec939388e7f49ee40", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -959,7 +959,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprClosure(_, _, _, ref blk) => {\n+          ast::ExprClosure(_, _, ref blk) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n "}, {"sha": "156ff43e2bab3c690e1e491c6d33ace9dfef276f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -739,7 +739,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             };\n \n             match fn_expr.node {\n-                ast::ExprClosure(_, _, _, ref body) => body.id,\n+                ast::ExprClosure(_, _, ref body) => body.id,\n                 _ => unreachable!()\n             }\n         };"}, {"sha": "3304bd4ae2952226f0fd3f0769280562e7a18300", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -14,6 +14,7 @@\n use session::Session;\n use lint;\n use middle::ty;\n+use middle::privacy::PublicItems;\n use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -44,15 +45,16 @@ pub struct Index {\n // A private tree-walker for producing an Index.\n struct Annotator<'a> {\n     sess: &'a Session,\n-    index: Index,\n-    parent: Option<Stability>\n+    index: &'a mut Index,\n+    parent: Option<Stability>,\n+    export_map: &'a PublicItems,\n }\n \n impl<'a> Annotator<'a> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n-                   attrs: &Vec<Attribute>, item_sp: Span, f: F) where\n+                   attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n         F: FnOnce(&mut Annotator),\n     {\n         match attr::find_stability(self.sess.diagnostic(), attrs.as_slice(), item_sp) {\n@@ -70,7 +72,14 @@ impl<'a> Annotator<'a> {\n             }\n             None => {\n                 if use_parent {\n-                    self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                    if let Some(stab) = self.parent.clone() {\n+                        self.index.local.insert(id, stab);\n+                    } else if self.index.staged_api && required\n+                           && self.export_map.contains(&id)\n+                           && !self.sess.opts.test {\n+                        self.sess.span_err(item_sp,\n+                                           \"This node does not have a stability attribute\");\n+                    }\n                 }\n                 f(self);\n             }\n@@ -93,11 +102,19 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n             _ => true,\n         };\n \n-        self.annotate(i.id, use_parent, &i.attrs, i.span, |v| visit::walk_item(v, i));\n+        // In case of a `pub use <mod>;`, we should not error since the stability\n+        // is inherited from the module itself\n+        let required = match i.node {\n+            ast::ItemUse(_) => i.vis != ast::Public,\n+            _ => true\n+        };\n+\n+        self.annotate(i.id, use_parent, &i.attrs, i.span,\n+                      |v| visit::walk_item(v, i), required);\n \n         if let ast::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n-                self.annotate(id, true, &i.attrs, i.span, |_| {})\n+                self.annotate(id, true, &i.attrs, i.span, |_| {}, true)\n             });\n         }\n     }\n@@ -106,7 +123,7 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n                 _: &'v Block, sp: Span, _: NodeId) {\n         if let FkMethod(_, _, meth) = fk {\n             // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, true, &meth.attrs, sp, |_| {});\n+            self.annotate(meth.id, true, &meth.attrs, sp, |_| {}, true);\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n@@ -126,27 +143,41 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n             TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs,\n                                            typedef.ty_param.span),\n         };\n-        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t));\n+        self.annotate(id, true, attrs, sp, |v| visit::walk_trait_item(v, t), true);\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n         self.annotate(var.node.id, true, &var.node.attrs, var.span,\n-                      |v| visit::walk_variant(v, var, g))\n+                      |v| visit::walk_variant(v, var, g), true)\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n         self.annotate(s.node.id, true, &s.node.attrs, s.span,\n-                      |v| visit::walk_struct_field(v, s));\n+                      |v| visit::walk_struct_field(v, s), true);\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        self.annotate(i.id, true, &i.attrs, i.span, |_| {});\n+        self.annotate(i.id, true, &i.attrs, i.span, |_| {}, true);\n     }\n }\n \n impl Index {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(sess: &Session, krate: &Crate) -> Index {\n+    pub fn build(&mut self, sess: &Session, krate: &Crate, export_map: &PublicItems) {\n+        if !self.staged_api {\n+            return;\n+        }\n+        let mut annotator = Annotator {\n+            sess: sess,\n+            index: self,\n+            parent: None,\n+            export_map: export_map,\n+        };\n+        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs, krate.span,\n+                           |v| visit::walk_crate(v, krate), true);\n+    }\n+\n+    pub fn new(krate: &Crate) -> Index {\n         let mut staged_api = false;\n         for attr in &krate.attrs {\n             if attr.name().get() == \"staged_api\" {\n@@ -159,22 +190,11 @@ impl Index {\n                 }\n             }\n         }\n-        let index = Index {\n+        Index {\n             staged_api: staged_api,\n             local: NodeMap(),\n             extern_cache: DefIdMap()\n-        };\n-        if !staged_api {\n-            return index;\n         }\n-        let mut annotator = Annotator {\n-            sess: sess,\n-            index: index,\n-            parent: None\n-        };\n-        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs, krate.span,\n-                           |v| visit::walk_crate(v, krate));\n-        annotator.index\n     }\n }\n \n@@ -234,10 +254,19 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             None => {\n                 // This is an 'unmarked' API, which should not exist\n                 // in the standard library.\n-                self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n-                self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n-                                               using or a bug in the compiler - there is \\\n-                                               no way to use this feature\");\n+                if self.tcx.sess.features.borrow().unmarked_api {\n+                    self.tcx.sess.span_warn(span, \"use of unmarked library feature\");\n+                    self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                                                   using and a bug in the compiler - please \\\n+                                                   report it in both places\");\n+                } else {\n+                    self.tcx.sess.span_err(span, \"use of unmarked library feature\");\n+                    self.tcx.sess.span_note(span, \"this is either a bug in the library you are \\\n+                                                   using and a bug in the compiler - please \\\n+                                                   report it in both places\");\n+                    self.tcx.sess.span_note(span, \"use #![feature(unmarked_api)] in the \\\n+                                                   crate attributes to override this\");\n+                }\n             }\n         }\n     }"}, {"sha": "c2a451b405bb5008018d635a94662460178a746c", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -80,37 +80,23 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-    let result = infcx.try(|snapshot| {\n+    infcx.try(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n \n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n-            Ok(Some(obligations)) => {\n+            Ok(result) => {\n                 match infcx.leak_check(&skol_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &obligations)),\n-                    Err(e) => Err(Some(MismatchedProjectionTypes { err: e })),\n+                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n+                    Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n             }\n-            Ok(None) => {\n-                // Signal ambiguity using Err just so that infcx.try()\n-                // rolls back the snapshot. We adapt below.\n-                Err(None)\n-            }\n             Err(e) => {\n-                Err(Some(e))\n+                Err(e)\n             }\n         }\n-    });\n-\n-    // Above, we use Err(None) to signal ambiguity so that the\n-    // snapshot will be rolled back. But here, we want to translate to\n-    // Ok(None). Kind of weird.\n-    match result {\n-        Ok(obligations) => Ok(Some(obligations)),\n-        Err(None) => Ok(None),\n-        Err(Some(e)) => Err(e),\n-    }\n+    })\n }\n \n /// Evaluates constraints of the form:\n@@ -132,7 +118,10 @@ fn project_and_unify_type<'cx,'tcx>(\n                                             obligation.cause.clone(),\n                                             obligation.recursion_depth) {\n             Some(n) => n,\n-            None => { return Ok(None); }\n+            None => {\n+                consider_unification_despite_ambiguity(selcx, obligation);\n+                return Ok(None);\n+            }\n         };\n \n     debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n@@ -147,6 +136,50 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n+fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n+                                                    obligation: &ProjectionObligation<'tcx>) {\n+    debug!(\"consider_unification_despite_ambiguity(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n+    match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n+        Some(_) => { }\n+        None => { return; }\n+    }\n+\n+    let infcx = selcx.infcx();\n+    let self_ty = obligation.predicate.projection_ty.trait_ref.self_ty();\n+    let self_ty = infcx.shallow_resolve(self_ty);\n+    debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n+           self_ty.sty);\n+    match self_ty.sty {\n+        ty::ty_closure(closure_def_id, _, substs) => {\n+            let closure_typer = selcx.closure_typer();\n+            let closure_type = closure_typer.closure_type(closure_def_id, substs);\n+            let ty::Binder((_, ret_type)) =\n+                util::closure_trait_ref_and_return_type(infcx.tcx,\n+                                                        def_id,\n+                                                        self_ty,\n+                                                        &closure_type.sig,\n+                                                        util::TupleArgumentsFlag::No);\n+            let (ret_type, _) =\n+                infcx.replace_late_bound_regions_with_fresh_var(\n+                    obligation.cause.span,\n+                    infer::AssocTypeProjection(obligation.predicate.projection_ty.item_name),\n+                    &ty::Binder(ret_type));\n+            debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n+                   ret_type.repr(selcx.tcx()));\n+            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+            let obligation_ty = obligation.predicate.ty;\n+            match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n+                Ok(()) => { }\n+                Err(_) => { /* ignore errors */ }\n+            }\n+        }\n+        _ => { }\n+    }\n+}\n+\n /// Normalizes any associated type projections in `value`, replacing\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that"}, {"sha": "b8af91add9efb56d6485cfcf145d88b39e873d85", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -233,21 +233,77 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    /// Evaluates whether the obligation can be satisfied. Returns an indication of whether the\n-    /// obligation can be satisfied and, if so, by what means. Never affects surrounding typing\n-    /// environment.\n+    /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n+    /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n-            None => Ok(None),\n+            None => {\n+                self.consider_unification_despite_ambiguity(obligation);\n+                Ok(None)\n+            }\n             Some(candidate) => Ok(Some(try!(self.confirm_candidate(obligation, candidate)))),\n         }\n     }\n \n+    /// In the particular case of unboxed closure obligations, we can\n+    /// sometimes do some amount of unification for the\n+    /// argument/return types even though we can't yet fully match obligation.\n+    /// The particular case we are interesting in is an obligation of the form:\n+    ///\n+    ///    C : FnFoo<A>\n+    ///\n+    /// where `C` is an unboxed closure type and `FnFoo` is one of the\n+    /// `Fn` traits. Because we know that users cannot write impls for closure types\n+    /// themselves, the only way that `C : FnFoo` can fail to match is under two\n+    /// conditions:\n+    ///\n+    /// 1. The closure kind for `C` is not yet known, because inference isn't complete.\n+    /// 2. The closure kind for `C` *is* known, but doesn't match what is needed.\n+    ///    For example, `C` may be a `FnOnce` closure, but a `Fn` closure is needed.\n+    ///\n+    /// In either case, we always know what argument types are\n+    /// expected by `C`, no matter what kind of `Fn` trait it\n+    /// eventually matches. So we can go ahead and unify the argument\n+    /// types, even though the end result is ambiguous.\n+    ///\n+    /// Note that this is safe *even if* the trait would never be\n+    /// matched (case 2 above). After all, in that case, an error will\n+    /// result, so it kind of doesn't matter what we do --- unifying\n+    /// the argument types can only be helpful to the user, because\n+    /// once they patch up the kind of closure that is expected, the\n+    /// argment types won't really change.\n+    fn consider_unification_despite_ambiguity(&mut self, obligation: &TraitObligation<'tcx>) {\n+        // Is this a `C : FnFoo(...)` trait reference for some trait binding `FnFoo`?\n+        match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+            Some(_) => { }\n+            None => { return; }\n+        }\n+\n+        // Is the self-type a closure type? We ignore bindings here\n+        // because if it is a closure type, it must be a closure type from\n+        // within this current fn, and hence none of the higher-ranked\n+        // lifetimes can appear inside the self-type.\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            _ => { return; }\n+        };\n+        assert!(!substs.has_escaping_regions());\n+\n+        let closure_trait_ref = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                           obligation.predicate.to_poly_trait_ref(),\n+                                           closure_trait_ref) {\n+            Ok(()) => { }\n+            Err(_) => { /* Silently ignore errors. */ }\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -1003,7 +1059,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -2303,22 +2359,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations\n     }\n \n-    fn fn_family_trait_kind(&self,\n-                            trait_def_id: ast::DefId)\n-                            -> Option<ty::ClosureKind>\n-    {\n-        let tcx = self.tcx();\n-        if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            Some(ty::FnClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            Some(ty::FnMutClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            Some(ty::FnOnceClosureKind)\n-        } else {\n-            None\n-        }\n-    }\n-\n     #[allow(unused_comparisons)]\n     fn derived_cause(&self,\n                      obligation: &TraitObligation<'tcx>,"}, {"sha": "bffee9d49334da43c3bedcb1d7743a7e66523f1b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -306,7 +306,7 @@ impl Target {\n         use std::env;\n         use std::ffi::OsString;\n         use std::old_io::File;\n-        use std::path::Path;\n+        use std::old_path::Path;\n         use serialize::json;\n \n         fn load_file(path: &Path) -> Result<Target, String> {"}, {"sha": "b9d2b9ec263ab450480bf3fa02db5c5505a6dd28", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -324,7 +324,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprClosure(_, _, _, ref block) => {\n+            ast::ExprClosure(_, _, ref block) => {\n                 block.id\n             }\n             _ => {"}, {"sha": "8ede037594a007557d57fae70632df52507d9313", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -594,9 +594,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"loop checking\", (), |_|\n          middle::check_loop::check_crate(&sess, krate));\n \n-    let stability_index = time(time_passes, \"stability index\", (), |_|\n-                               stability::Index::build(&sess, krate));\n-\n     time(time_passes, \"static item recursion checking\", (), |_|\n          middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n \n@@ -608,7 +605,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             freevars,\n                             region_map,\n                             lang_items,\n-                            stability_index);\n+                            stability::Index::new(krate));\n \n     // passes are timed inside typeck\n     typeck::check_crate(&ty_cx, trait_map);\n@@ -628,6 +625,10 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n                  rustc_privacy::check_crate(&ty_cx, &export_map, a, b));\n \n+    // Do not move this check past lint\n+    time(time_passes, \"stability index\", (), |_|\n+         ty_cx.stability.borrow_mut().build(&ty_cx.sess, krate, &public_items));\n+\n     time(time_passes, \"intrinsic checking\", (), |_|\n          middle::intrinsicck::check_crate(&ty_cx));\n "}, {"sha": "7dc0d9be53924f9103e1872dc4cf023bbc723dea", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -125,7 +125,6 @@ fn test_env<F>(source_string: &str,\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n-    let stability_index = stability::Index::build(&sess, krate);\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,\n                           def_map,\n@@ -134,7 +133,7 @@ fn test_env<F>(source_string: &str,\n                           freevars,\n                           region_map,\n                           lang_items,\n-                          stability_index);\n+                          stability::Index::new(krate));\n     let infcx = infer::new_infer_ctxt(&tcx);\n     body(Env { infcx: &infcx });\n     infcx.resolve_regions_and_report_errors(ast::CRATE_NODE_ID);"}, {"sha": "dd739059ed0ddf13c10d19ea06ce7a9aab9a90bb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -4521,7 +4521,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprClosure(_, _, ref fn_decl, ref block) => {\n+            ExprClosure(_, ref fn_decl, ref block) => {\n                 self.resolve_function(ClosureRibKind(expr.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);"}, {"sha": "b0ce9641cf440e8a658e9bcb314d129720692fbe", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1394,7 +1394,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                       type, found {:?}\", ty)[]),\n                 }\n             },\n-            ast::ExprClosure(_, _, ref decl, ref body) => {\n+            ast::ExprClosure(_, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n                 }"}, {"sha": "6901eb25b31feb1dda95147af59f7ec977ba1b13", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1340,7 +1340,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, _, ref blk) => {\n+                ast::ExprClosure(_, _, ref blk) => {\n                     blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")"}, {"sha": "c6b70e1a1abc354a47b187b628d4d94b93c584ce", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1283,7 +1283,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n+                ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(&name[]);\n                     (name, &**fn_decl,\n@@ -1590,7 +1590,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                     Some(ref p) if p.is_relative() => {\n                         // prepend \"./\" if necessary\n                         let dotdot = b\"..\";\n-                        let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n+                        let prefix: &[u8] = &[dotdot[0], ::std::old_path::SEP_BYTE];\n                         let mut path_bytes = p.as_vec().to_vec();\n \n                         if &path_bytes[..2] != prefix &&\n@@ -3595,7 +3595,7 @@ fn create_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprClosure(_, _, ref decl, ref block) => {\n+            ast::ExprClosure(_, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,"}, {"sha": "44eb5b190e1a65666aafad1f46abd1cb44ac9793", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1095,7 +1095,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n-        ast::ExprClosure(_, _, ref decl, ref body) => {\n+        ast::ExprClosure(_, ref decl, ref body) => {\n             closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {"}, {"sha": "b2a676e878e6302e556e8aab29e462d8942da6fb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 90, "deletions": 61, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -25,46 +25,21 @@ use util::ppaux::Repr;\n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n-                                   opt_kind: Option<ast::ClosureKind>,\n                                    decl: &'tcx ast::FnDecl,\n                                    body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={},expected={})\",\n            expr.repr(fcx.tcx()),\n            expected.repr(fcx.tcx()));\n \n-    let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_expectations_from_expected_type(fcx, ty)\n-    });\n-\n-    match opt_kind {\n-        None => {\n-            // If users didn't specify what sort of closure they want,\n-            // examine the expected type. For now, if we see explicit\n-            // evidence than an unboxed closure is desired, we'll use\n-            // that. Otherwise, we leave it unspecified, to be filled\n-            // in by upvar inference.\n-            match expected_sig_and_kind {\n-                None => { // don't have information about the kind, request explicit annotation\n-                    check_closure(fcx, expr, None, decl, body, None);\n-                },\n-                Some((sig, kind)) => {\n-                    check_closure(fcx, expr, Some(kind), decl, body, Some(sig));\n-                }\n-            }\n-        }\n-\n-        Some(kind) => {\n-            let kind = match kind {\n-                ast::FnClosureKind => ty::FnClosureKind,\n-                ast::FnMutClosureKind => ty::FnMutClosureKind,\n-                ast::FnOnceClosureKind => ty::FnOnceClosureKind,\n-            };\n-\n-            let expected_sig = expected_sig_and_kind.map(|t| t.0);\n-            check_closure(fcx, expr, Some(kind), decl, body, expected_sig);\n-        }\n-    }\n+    // It's always helpful for inference if we know the kind of\n+    // closure sooner rather than later, so first examine the expected\n+    // type, and see if can glean a closure kind from there.\n+    let (expected_sig,expected_kind) = match expected.to_option(fcx) {\n+        Some(ty) => deduce_expectations_from_expected_type(fcx, ty),\n+        None => (None, None)\n+    };\n+    check_closure(fcx, expr, expected_kind, decl, body, expected_sig)\n }\n \n fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -133,55 +108,92 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n fn deduce_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n+    -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n+    debug!(\"deduce_expectations_from_expected_type(expected_ty={})\",\n+           expected_ty.repr(fcx.tcx()));\n+\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n-            proj_bounds.iter()\n-                       .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n-                       .next()\n+            let expectations =\n+                proj_bounds.iter()\n+                           .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n+                           .next();\n+\n+            match expectations {\n+                Some((sig, kind)) => (Some(sig), Some(kind)),\n+                None => (None, None)\n+            }\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n-            None\n+            (None, None)\n         }\n     }\n }\n \n fn deduce_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+    -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n     let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n-    fulfillment_cx.pending_obligations()\n-                  .iter()\n-                  .filter_map(|obligation| {\n-                      match obligation.predicate {\n-                          ty::Predicate::Projection(ref proj_predicate) => {\n-                              let trait_ref = proj_predicate.to_poly_trait_ref();\n-                              let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-                              match self_ty.sty {\n-                                  ty::ty_infer(ty::TyVar(v)) if expected_vid == v => {\n-                                      deduce_expectations_from_projection(fcx, proj_predicate)\n-                                  }\n-                                  _ => {\n-                                      None\n-                                  }\n-                              }\n-                          }\n-                          _ => {\n-                              None\n-                          }\n-                      }\n-                  })\n-                  .next()\n+    let expected_sig_and_kind =\n+        fulfillment_cx\n+        .pending_obligations()\n+        .iter()\n+        .filter_map(|obligation| {\n+            debug!(\"deduce_expectations_from_obligations: obligation.predicate={}\",\n+                   obligation.predicate.repr(fcx.tcx()));\n+\n+            match obligation.predicate {\n+                // Given a Projection predicate, we can potentially infer\n+                // the complete signature.\n+                ty::Predicate::Projection(ref proj_predicate) => {\n+                    let trait_ref = proj_predicate.to_poly_trait_ref();\n+                    self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n+                        .and_then(|_| deduce_expectations_from_projection(fcx, proj_predicate))\n+                }\n+                _ => {\n+                    None\n+                }\n+            }\n+        })\n+        .next();\n+\n+    match expected_sig_and_kind {\n+        Some((sig, kind)) => { return (Some(sig), Some(kind)); }\n+        None => { }\n+    }\n+\n+    // Even if we can't infer the full signature, we may be able to\n+    // infer the kind. This can occur if there is a trait-reference\n+    // like `F : Fn<A>`.\n+    let expected_kind =\n+        fulfillment_cx\n+        .pending_obligations()\n+        .iter()\n+        .filter_map(|obligation| {\n+            let opt_trait_ref = match obligation.predicate {\n+                ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Equate(..) => None,\n+                ty::Predicate::RegionOutlives(..) => None,\n+                ty::Predicate::TypeOutlives(..) => None,\n+            };\n+            opt_trait_ref\n+                .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n+                .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n+        })\n+        .next();\n+\n+    (None, expected_kind)\n }\n \n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n@@ -229,3 +241,20 @@ fn deduce_expectations_from_projection<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n+fn self_type_matches_expected_vid<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    expected_vid: ty::TyVid)\n+    -> Option<ty::PolyTraitRef<'tcx>>\n+{\n+    let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+    debug!(\"self_type_matches_expected_vid(trait_ref={}, self_ty={})\",\n+           trait_ref.repr(fcx.tcx()),\n+           self_ty.repr(fcx.tcx()));\n+    match self_ty.sty {\n+        ty::ty_infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+        _ => None,\n+    }\n+}\n+\n+"}, {"sha": "adf15fbf28a8f040708e9e9aaea3b371558fdd9a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -3736,8 +3736,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprMatch(ref discrim, ref arms, match_src) => {\n         _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected, match_src);\n       }\n-      ast::ExprClosure(capture, opt_kind, ref decl, ref body) => {\n-          closure::check_expr_closure(fcx, expr, capture, opt_kind, &**decl, &**body, expected);\n+      ast::ExprClosure(capture, ref decl, ref body) => {\n+          closure::check_expr_closure(fcx, expr, capture, &**decl, &**body, expected);\n       }\n       ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, &**b, expected);"}, {"sha": "9df0403794d7c8e8bd03087dda0a33a387ab2a47", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -638,7 +638,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprClosure(_, _, _, ref body) => {\n+        ast::ExprClosure(_, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n "}, {"sha": "f452c8488ce1c7eb2fe900db03205d06889460ac", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -83,7 +83,7 @@ struct SeedBorrowKind<'a,'tcx:'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n-            ast::ExprClosure(cc, _, _, ref body) => {\n+            ast::ExprClosure(cc, _, ref body) => {\n                 self.check_closure(expr, cc, &**body);\n             }\n "}, {"sha": "f047a36c56095fcc3433b872c2edb9480f1addb7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -118,7 +118,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprClosure(_, _, ref decl, _) => {\n+            ast::ExprClosure(_, ref decl, _) => {\n                 for input in &decl.inputs {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);"}, {"sha": "57eaf042aa02edc676697cb3173d92d881dd0209", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -49,7 +49,7 @@ use rustc::middle::stability;\n use std::rc::Rc;\n use std::u32;\n use std::str::Str as StrTrait; // Conflicts with Str variant\n-use std::path::Path as FsPath; // Conflicts with Path struct\n+use std::old_path::Path as FsPath; // Conflicts with Path struct\n \n use core::DocContext;\n use doctree;"}, {"sha": "517907bcf58e347c3e94b7f876e66026a7aef97d", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -14,7 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n-use std::path;\n+use std::old_path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n@@ -538,29 +538,29 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl Encodable for path::posix::Path {\n+impl Encodable for old_path::posix::Path {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl Decodable for path::posix::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<path::posix::Path, D::Error> {\n+impl Decodable for old_path::posix::Path {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::posix::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(path::posix::Path::new(bytes))\n+        Ok(old_path::posix::Path::new(bytes))\n     }\n }\n \n-impl Encodable for path::windows::Path {\n+impl Encodable for old_path::windows::Path {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl Decodable for path::windows::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<path::windows::Path, D::Error> {\n+impl Decodable for old_path::windows::Path {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::windows::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(path::windows::Path::new(bytes))\n+        Ok(old_path::windows::Path::new(bytes))\n     }\n }\n "}, {"sha": "559a68542efc890492144a2ec5289b739e059b68", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -57,7 +57,7 @@ pub fn current_dir() -> IoResult<Path> {\n ///\n /// ```rust\n /// use std::env;\n-/// use std::path::Path;\n+/// use std::old_path::Path;\n ///\n /// let root = Path::new(\"/\");\n /// assert!(env::set_current_dir(&root).is_ok());"}, {"sha": "07a4f17796c4994f14638ac3258ee15a0da40b4e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -24,6 +24,7 @@ pub use self::os_str::OsStr;\n mod c_str;\n mod os_str;\n \n+// FIXME (#21670): these should be defined in the os_str module\n /// Freely convertible to an `&OsStr` slice.\n pub trait AsOsStr {\n     /// Convert to an `&OsStr` slice."}, {"sha": "4d7292b6eb417469e4aea7a03002ca0063a10fe2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -41,7 +41,7 @@ use string::{String, CowString};\n use ops;\n use cmp;\n use hash::{Hash, Hasher, Writer};\n-use path::{Path, GenericPath};\n+use old_path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};"}, {"sha": "2fd6631ecc4371fec61b516fab453d9cf05c8d7f", "filename": "src/libstd/io/buffered.rs", "status": "added", "additions": 676, "deletions": 0, "changes": 676, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,676 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+//! Buffering wrappers for I/O traits\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use cmp;\n+use error::Error as StdError;\n+use error::FromError;\n+use fmt;\n+use io::{self, Cursor, DEFAULT_BUF_SIZE, Error, ErrorKind};\n+use ptr;\n+\n+/// Wraps a `Read` and buffers input from it\n+///\n+/// It can be excessively inefficient to work directly with a `Read` instance.\n+/// For example, every call to `read` on `TcpStream` results in a system call.\n+/// A `BufReader` performs large, infrequent reads on the underlying `Read`\n+/// and maintains an in-memory buffer of the results.\n+pub struct BufReader<R> {\n+    inner: R,\n+    buf: Cursor<Vec<u8>>,\n+}\n+\n+impl<R: Read> BufReader<R> {\n+    /// Creates a new `BufReader` with a default buffer capacity\n+    pub fn new(inner: R) -> BufReader<R> {\n+        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufReader` with the specified buffer capacity\n+    pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n+        BufReader {\n+            inner: inner,\n+            buf: Cursor::new(Vec::with_capacity(cap)),\n+        }\n+    }\n+\n+    /// Gets a reference to the underlying reader.\n+    pub fn get_ref<'a>(&self) -> &R { &self.inner }\n+\n+    /// Gets a mutable reference to the underlying reader.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n+\n+    /// Unwraps this `BufReader`, returning the underlying reader.\n+    ///\n+    /// Note that any leftover data in the internal buffer is lost.\n+    pub fn into_inner(self) -> R { self.inner }\n+}\n+\n+impl<R: Read> Read for BufReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        // If we don't have any buffered data and we're doing a massive read\n+        // (larger than our internal buffer), bypass our internal buffer\n+        // entirely.\n+        if self.buf.get_ref().len() == self.buf.position() as usize &&\n+            buf.len() >= self.buf.get_ref().capacity() {\n+            return self.inner.read(buf);\n+        }\n+        try!(self.fill_buf());\n+        self.buf.read(buf)\n+    }\n+}\n+\n+impl<R: Read> BufRead for BufReader<R> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the underlying reader.\n+        if self.buf.position() as usize == self.buf.get_ref().len() {\n+            self.buf.set_position(0);\n+            let v = self.buf.get_mut();\n+            v.truncate(0);\n+            let inner = &mut self.inner;\n+            try!(super::with_end_to_cap(v, |b| inner.read(b)));\n+        }\n+        self.buf.fill_buf()\n+    }\n+\n+    fn consume(&mut self, amt: uint) {\n+        self.buf.consume(amt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"BufReader {{ reader: {:?}, buffer: {}/{} }}\",\n+               self.inner, self.buf.position(), self.buf.get_ref().len())\n+    }\n+}\n+\n+/// Wraps a Writer and buffers output to it\n+///\n+/// It can be excessively inefficient to work directly with a `Write`. For\n+/// example, every call to `write` on `TcpStream` results in a system call. A\n+/// `BufWriter` keeps an in memory buffer of data and writes it to the\n+/// underlying `Write` in large, infrequent batches.\n+///\n+/// This writer will be flushed when it is dropped.\n+pub struct BufWriter<W> {\n+    inner: Option<W>,\n+    buf: Vec<u8>,\n+}\n+\n+/// An error returned by `into_inner` which indicates whether a flush error\n+/// happened or not.\n+#[derive(Debug)]\n+pub struct IntoInnerError<W>(W, Error);\n+\n+impl<W: Write> BufWriter<W> {\n+    /// Creates a new `BufWriter` with a default buffer capacity\n+    pub fn new(inner: W) -> BufWriter<W> {\n+        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufWriter` with the specified buffer capacity\n+    pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n+        BufWriter {\n+            inner: Some(inner),\n+            buf: Vec::with_capacity(cap),\n+        }\n+    }\n+\n+    fn flush_buf(&mut self) -> io::Result<()> {\n+        let mut written = 0;\n+        let len = self.buf.len();\n+        let mut ret = Ok(());\n+        while written < len {\n+            match self.inner.as_mut().unwrap().write(&self.buf[written..]) {\n+                Ok(0) => {\n+                    ret = Err(Error::new(ErrorKind::WriteZero,\n+                                         \"failed to flush\", None));\n+                    break;\n+                }\n+                Ok(n) => written += n,\n+                Err(e) => { ret = Err(e); break }\n+\n+            }\n+        }\n+        if written > 0 {\n+            // NB: would be better expressed as .remove(0..n) if it existed\n+            unsafe {\n+                ptr::copy_memory(self.buf.as_mut_ptr(),\n+                                 self.buf.as_ptr().offset(written as isize),\n+                                 len - written);\n+            }\n+        }\n+        self.buf.truncate(len - written);\n+        ret\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n+\n+    /// Gets a mutable reference to the underlying write.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to directly read from the underlying writer.\n+    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n+\n+    /// Unwraps this `BufWriter`, returning the underlying writer.\n+    ///\n+    /// The buffer is flushed before returning the writer.\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError(self, e)),\n+            Ok(()) => Ok(self.inner.take().unwrap())\n+        }\n+    }\n+}\n+\n+impl<W: Write> Write for BufWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            try!(self.flush_buf());\n+        }\n+        if buf.len() >= self.buf.capacity() {\n+            self.inner.as_mut().unwrap().write(buf)\n+        } else {\n+            let amt = cmp::min(buf.len(), self.buf.capacity());\n+            Write::write(&mut self.buf, &buf[..amt])\n+        }\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.flush_buf().and_then(|()| self.get_mut().flush())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n+               self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<W: Write> Drop for BufWriter<W> {\n+    fn drop(&mut self) {\n+        if self.inner.is_some() {\n+            // dtors should not panic, so we ignore a failed flush\n+            let _r = self.flush_buf();\n+        }\n+    }\n+}\n+\n+impl<W> IntoInnerError<W> {\n+    /// Returns the error which caused the call to `into_inner` to fail.\n+    ///\n+    /// This error was returned when attempting to flush the internal buffer.\n+    pub fn error(&self) -> &Error { &self.1 }\n+\n+    /// Returns the underlying `BufWriter` instance which generated the error.\n+    ///\n+    /// The returned object can be used to retry a flush or re-inspect the\n+    /// buffer.\n+    pub fn into_inner(self) -> W { self.0 }\n+}\n+\n+impl<W> FromError<IntoInnerError<W>> for Error {\n+    fn from_error(iie: IntoInnerError<W>) -> Error { iie.1 }\n+}\n+\n+impl<W> StdError for IntoInnerError<W> {\n+    fn description(&self) -> &str { self.error().description() }\n+}\n+\n+impl<W> fmt::Display for IntoInnerError<W> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.error().fmt(f)\n+    }\n+}\n+\n+/// Wraps a Writer and buffers output to it, flushing whenever a newline\n+/// (`0x0a`, `'\\n'`) is detected.\n+///\n+/// This writer will be flushed when it is dropped.\n+pub struct LineWriter<W> {\n+    inner: BufWriter<W>,\n+}\n+\n+impl<W: Write> LineWriter<W> {\n+    /// Creates a new `LineWriter`\n+    pub fn new(inner: W) -> LineWriter<W> {\n+        // Lines typically aren't that long, don't use a giant buffer\n+        LineWriter { inner: BufWriter::with_capacity(1024, inner) }\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// This type does not expose the ability to get a mutable reference to the\n+    /// underlying reader because that could possibly corrupt the buffer.\n+    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+\n+    /// Unwraps this `LineWriter`, returning the underlying writer.\n+    ///\n+    /// The internal buffer is flushed before returning the writer.\n+    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n+        self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n+            IntoInnerError(LineWriter { inner: buf }, e)\n+        })\n+    }\n+}\n+\n+impl<W: Write> Write for LineWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match buf.rposition_elem(&b'\\n') {\n+            Some(i) => {\n+                let n = try!(self.inner.write(&buf[..i + 1]));\n+                if n != i + 1 { return Ok(n) }\n+                try!(self.inner.flush());\n+                self.inner.write(&buf[i + 1..]).map(|i| n + i)\n+            }\n+            None => self.inner.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n+               self.inner.inner, self.inner.buf.len(),\n+               self.inner.buf.capacity())\n+    }\n+}\n+\n+struct InternalBufWriter<W>(BufWriter<W>);\n+\n+impl<W> InternalBufWriter<W> {\n+    fn get_mut(&mut self) -> &mut BufWriter<W> {\n+        let InternalBufWriter(ref mut w) = *self;\n+        return w;\n+    }\n+}\n+\n+impl<W: Read> Read for InternalBufWriter<W> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.get_mut().inner.as_mut().unwrap().read(buf)\n+    }\n+}\n+\n+/// Wraps a Stream and buffers input and output to and from it.\n+///\n+/// It can be excessively inefficient to work directly with a `Stream`. For\n+/// example, every call to `read` or `write` on `TcpStream` results in a system\n+/// call. A `BufStream` keeps in memory buffers of data, making large,\n+/// infrequent calls to `read` and `write` on the underlying `Stream`.\n+///\n+/// The output half will be flushed when this stream is dropped.\n+pub struct BufStream<S> {\n+    inner: BufReader<InternalBufWriter<S>>\n+}\n+\n+impl<S: Read + Write> BufStream<S> {\n+    /// Creates a new buffered stream with explicitly listed capacities for the\n+    /// reader/writer buffer.\n+    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n+                           -> BufStream<S> {\n+        let writer = BufWriter::with_capacity(writer_cap, inner);\n+        let internal_writer = InternalBufWriter(writer);\n+        let reader = BufReader::with_capacity(reader_cap, internal_writer);\n+        BufStream { inner: reader }\n+    }\n+\n+    /// Creates a new buffered stream with the default reader/writer buffer\n+    /// capacities.\n+    pub fn new(inner: S) -> BufStream<S> {\n+        BufStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Gets a reference to the underlying stream.\n+    pub fn get_ref(&self) -> &S {\n+        let InternalBufWriter(ref w) = self.inner.inner;\n+        w.get_ref()\n+    }\n+\n+    /// Gets a mutable reference to the underlying stream.\n+    ///\n+    /// # Warning\n+    ///\n+    /// It is inadvisable to read directly from or write directly to the\n+    /// underlying stream.\n+    pub fn get_mut(&mut self) -> &mut S {\n+        let InternalBufWriter(ref mut w) = self.inner.inner;\n+        w.get_mut()\n+    }\n+\n+    /// Unwraps this `BufStream`, returning the underlying stream.\n+    ///\n+    /// The internal buffer is flushed before returning the stream. Any leftover\n+    /// data in the read buffer is lost.\n+    pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n+        let BufReader { inner: InternalBufWriter(w), buf } = self.inner;\n+        w.into_inner().map_err(|IntoInnerError(w, e)| {\n+            IntoInnerError(BufStream {\n+                inner: BufReader { inner: InternalBufWriter(w), buf: buf },\n+            }, e)\n+        })\n+    }\n+}\n+\n+impl<S: Read + Write> BufRead for BufStream<S> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n+    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+}\n+\n+impl<S: Read + Write> Read for BufStream<S> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+\n+impl<S: Read + Write> Write for BufStream<S> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.inner.get_mut().write(buf)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.inner.get_mut().flush()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<S> fmt::Debug for BufStream<S> where S: fmt::Debug {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let reader = &self.inner;\n+        let writer = &self.inner.inner.0;\n+        write!(fmt, \"BufStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n+               writer.inner,\n+               writer.buf.len(), writer.buf.capacity(),\n+               reader.buf.position(), reader.buf.get_ref().len())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use io::{self, BufReader, BufWriter, BufStream, Cursor, LineWriter};\n+    use test;\n+\n+    /// A dummy reader intended at testing short-reads propagation.\n+    pub struct ShortReader {\n+        lengths: Vec<usize>,\n+    }\n+\n+    impl Read for ShortReader {\n+        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n+            if self.lengths.is_empty() {\n+                Ok(0)\n+            } else {\n+                Ok(self.lengths.remove(0))\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_buffered_reader() {\n+        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+        let mut reader = BufReader::with_capacity(2, inner);\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(3), nread);\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(2), nread);\n+        let b: &[_] = &[0, 1];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[2];\n+        assert_eq!(buf, b);\n+\n+        let mut buf = [0, 0, 0];\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[3, 0, 0];\n+        assert_eq!(buf, b);\n+\n+        let nread = reader.read(&mut buf);\n+        assert_eq!(Ok(1), nread);\n+        let b: &[_] = &[4, 0, 0];\n+        assert_eq!(buf, b);\n+\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_buffered_writer() {\n+        let inner = Vec::new();\n+        let mut writer = BufWriter::with_capacity(2, inner);\n+\n+        writer.write(&[0, 1]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.write(&[2]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.write(&[3]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+        writer.write(&[4]).unwrap();\n+        writer.write(&[5]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+        writer.write(&[6]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n+\n+        writer.write(&[7, 8]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n+\n+        writer.write(&[9, 10, 11]).unwrap();\n+        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+    }\n+\n+    #[test]\n+    fn test_buffered_writer_inner_flushes() {\n+        let mut w = BufWriter::with_capacity(3, Vec::new());\n+        w.write(&[0, 1]).unwrap();\n+        assert_eq!(*w.get_ref(), []);\n+        let w = w.into_inner().unwrap();\n+        assert_eq!(w, [0, 1]);\n+    }\n+\n+    // This is just here to make sure that we don't infinite loop in the\n+    // newtype struct autoderef weirdness\n+    #[test]\n+    fn test_buffered_stream() {\n+        struct S;\n+\n+        impl Write for S {\n+            fn write(&mut self, b: &[u8]) -> io::Result<usize> { Ok(b.len()) }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+\n+        impl Read for S {\n+            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+        }\n+\n+        let mut stream = BufStream::new(S);\n+        assert_eq!(stream.read(&mut [0; 10]), Ok(0));\n+        stream.write(&[0; 10]).unwrap();\n+        stream.flush().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_read_until() {\n+        let inner: &[u8] = &[0, 1, 2, 1, 0];\n+        let mut reader = BufReader::with_capacity(2, inner);\n+        let mut v = Vec::new();\n+        reader.read_until(0, &mut v).unwrap();\n+        assert_eq!(v, [0]);\n+        v.truncate(0);\n+        reader.read_until(2, &mut v).unwrap();\n+        assert_eq!(v, [1, 2]);\n+        v.truncate(0);\n+        reader.read_until(1, &mut v).unwrap();\n+        assert_eq!(v, [1]);\n+        v.truncate(0);\n+        reader.read_until(8, &mut v).unwrap();\n+        assert_eq!(v, [0]);\n+        v.truncate(0);\n+        reader.read_until(9, &mut v).unwrap();\n+        assert_eq!(v, []);\n+    }\n+\n+    #[test]\n+    fn test_line_buffer() {\n+        let mut writer = LineWriter::new(Vec::new());\n+        writer.write(&[0]).unwrap();\n+        assert_eq!(*writer.get_ref(), []);\n+        writer.write(&[1]).unwrap();\n+        assert_eq!(*writer.get_ref(), []);\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1]);\n+        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n+        writer.flush().unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        writer.write(&[3, b'\\n']).unwrap();\n+        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n+    }\n+\n+    #[test]\n+    fn test_read_line() {\n+        let in_buf = b\"a\\nb\\nc\";\n+        let mut reader = BufReader::with_capacity(2, in_buf);\n+        let mut s = String::new();\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"a\\n\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"b\\n\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"c\");\n+        s.truncate(0);\n+        reader.read_line(&mut s).unwrap();\n+        assert_eq!(s, \"\");\n+    }\n+\n+    #[test]\n+    fn test_lines() {\n+        let in_buf = b\"a\\nb\\nc\";\n+        let mut reader = BufReader::with_capacity(2, in_buf);\n+        let mut it = reader.lines();\n+        assert_eq!(it.next(), Some(Ok(\"a\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"b\".to_string())));\n+        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_short_reads() {\n+        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n+        let mut reader = BufReader::new(inner);\n+        let mut buf = [0, 0];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(2));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn read_char_buffered() {\n+        let buf = [195u8, 159u8];\n+        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        assert_eq!(reader.chars().next(), Some(Ok('\u00df')));\n+    }\n+\n+    #[test]\n+    fn test_chars() {\n+        let buf = [195u8, 159u8, b'a'];\n+        let mut reader = BufReader::with_capacity(1, &buf[]);\n+        let mut it = reader.chars();\n+        assert_eq!(it.next(), Some(Ok('\u00df')));\n+        assert_eq!(it.next(), Some(Ok('a')));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn dont_panic_in_drop_on_panicked_flush() {\n+        struct FailFlushWriter;\n+\n+        impl Write for FailFlushWriter {\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+            fn flush(&mut self) -> io::Result<()> {\n+                Err(io::Error::last_os_error())\n+            }\n+        }\n+\n+        let writer = FailFlushWriter;\n+        let _writer = BufWriter::new(writer);\n+\n+        // If writer panics *again* due to the flush error then the process will\n+        // abort.\n+        panic!();\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_reader(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            BufReader::new(io::empty())\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_writer(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            BufWriter::new(io::sink())\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_buffered_stream(b: &mut test::Bencher) {\n+        let mut buf = Cursor::new(Vec::new());\n+        b.iter(|| {\n+            BufStream::new(&mut buf);\n+        });\n+    }\n+}"}, {"sha": "9f3655de20fc245c91bbd9b79527bdc58bc6b5bc", "filename": "src/libstd/io/cursor.rs", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,408 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_copy_implementations)]\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use cmp;\n+use io::{self, SeekFrom, Error, ErrorKind};\n+use iter::repeat;\n+use num::Int;\n+use slice;\n+\n+/// A `Cursor` is a type which wraps another I/O object to provide a `Seek`\n+/// implementation.\n+///\n+/// Cursors are currently typically used with memory buffer objects in order to\n+/// allow `Seek` plus `Read` and `Write` implementations. For example, common\n+/// cursor types include:\n+///\n+/// * `Cursor<Vec<u8>>`\n+/// * `Cursor<&[u8]>`\n+///\n+/// Implementations of the I/O traits for `Cursor<T>` are not currently generic\n+/// over `T` itself. Instead, specific implementations are provided for various\n+/// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n+pub struct Cursor<T> {\n+    inner: T,\n+    pos: u64,\n+}\n+\n+impl<T> Cursor<T> {\n+    /// Create a new cursor wrapping the provided underlying I/O object.\n+    pub fn new(inner: T) -> Cursor<T> {\n+        Cursor { pos: 0, inner: inner }\n+    }\n+\n+    /// Consume this cursor, returning the underlying value.\n+    pub fn into_inner(self) -> T { self.inner }\n+\n+    /// Get a reference to the underlying value in this cursor.\n+    pub fn get_ref(&self) -> &T { &self.inner }\n+\n+    /// Get a mutable reference to the underlying value in this cursor.\n+    ///\n+    /// Care should be taken to avoid modifying the internal I/O state of the\n+    /// underlying value as it may corrupt this cursor's position.\n+    pub fn get_mut(&mut self) -> &mut T { &mut self.inner }\n+\n+    /// Returns the current value of this cursor\n+    pub fn position(&self) -> u64 { self.pos }\n+\n+    /// Sets the value of this cursor\n+    pub fn set_position(&mut self, pos: u64) { self.pos = pos; }\n+}\n+\n+macro_rules! seek {\n+    () => {\n+        fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n+            let pos = match style {\n+                SeekFrom::Start(n) => { self.pos = n; return Ok(n) }\n+                SeekFrom::End(n) => self.inner.len() as i64 + n,\n+                SeekFrom::Current(n) => self.pos as i64 + n,\n+            };\n+\n+            if pos < 0 {\n+                Err(Error::new(ErrorKind::InvalidInput,\n+                               \"invalid seek to a negative position\",\n+                               None))\n+            } else {\n+                self.pos = pos as u64;\n+                Ok(self.pos)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> io::Seek for Cursor<&'a [u8]> { seek!(); }\n+impl<'a> io::Seek for Cursor<&'a mut [u8]> { seek!(); }\n+impl io::Seek for Cursor<Vec<u8>> { seek!(); }\n+\n+macro_rules! read {\n+    () => {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let n = try!(Read::read(&mut try!(self.fill_buf()), buf));\n+            self.pos += n as u64;\n+            Ok(n)\n+        }\n+    }\n+}\n+\n+impl<'a> Read for Cursor<&'a [u8]> { read!(); }\n+impl<'a> Read for Cursor<&'a mut [u8]> { read!(); }\n+impl Read for Cursor<Vec<u8>> { read!(); }\n+\n+macro_rules! buffer {\n+    () => {\n+        fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+            let amt = cmp::min(self.pos, self.inner.len() as u64);\n+            Ok(&self.inner[(amt as usize)..])\n+        }\n+        fn consume(&mut self, amt: usize) { self.pos += amt as u64; }\n+    }\n+}\n+\n+impl<'a> BufRead for Cursor<&'a [u8]> { buffer!(); }\n+impl<'a> BufRead for Cursor<&'a mut [u8]> { buffer!(); }\n+impl<'a> BufRead for Cursor<Vec<u8>> { buffer!(); }\n+\n+impl<'a> Write for Cursor<&'a mut [u8]> {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        let pos = cmp::min(self.pos, self.inner.len() as u64);\n+        let amt = try!((&mut self.inner[(pos as usize)..]).write(data));\n+        self.pos += amt as u64;\n+        Ok(amt)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl Write for Cursor<Vec<u8>> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        // Make sure the internal buffer is as least as big as where we\n+        // currently are\n+        let pos = self.position();\n+        let amt = pos.saturating_sub(self.inner.len() as u64);\n+        self.inner.extend(repeat(0).take(amt as usize));\n+\n+        // Figure out what bytes will be used to overwrite what's currently\n+        // there (left), and what will be appended on the end (right)\n+        let space = self.inner.len() - pos as usize;\n+        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n+        slice::bytes::copy_memory(&mut self.inner[(pos as usize)..], left);\n+        self.inner.push_all(right);\n+\n+        // Bump us forward\n+        self.set_position(pos + buf.len() as u64);\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use core::prelude::*;\n+\n+    use io::prelude::*;\n+    use io::{Cursor, SeekFrom};\n+    use vec::Vec;\n+\n+    #[test]\n+    fn test_vec_writer() {\n+        let mut writer = Vec::new();\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(writer, b);\n+    }\n+\n+    #[test]\n+    fn test_mem_writer() {\n+        let mut writer = Cursor::new(Vec::new());\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer() {\n+        let mut buf = [0 as u8; 9];\n+        {\n+            let mut writer = Cursor::new(&mut buf[]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write(&[0]), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+            assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+            assert_eq!(writer.position(), 8);\n+            assert_eq!(writer.write(&[]), Ok(0));\n+            assert_eq!(writer.position(), 8);\n+\n+            assert_eq!(writer.write(&[8, 9]), Ok(1));\n+            assert_eq!(writer.write(&[10]), Ok(0));\n+        }\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+        assert_eq!(buf, b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer_seek() {\n+        let mut buf = [0 as u8; 8];\n+        {\n+            let mut writer = Cursor::new(&mut buf[]);\n+            assert_eq!(writer.position(), 0);\n+            assert_eq!(writer.write(&[1]), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+\n+            assert_eq!(writer.seek(SeekFrom::Start(2)), Ok(2));\n+            assert_eq!(writer.position(), 2);\n+            assert_eq!(writer.write(&[2]), Ok(1));\n+            assert_eq!(writer.position(), 3);\n+\n+            assert_eq!(writer.seek(SeekFrom::Current(-2)), Ok(1));\n+            assert_eq!(writer.position(), 1);\n+            assert_eq!(writer.write(&[3]), Ok(1));\n+            assert_eq!(writer.position(), 2);\n+\n+            assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n+            assert_eq!(writer.position(), 7);\n+            assert_eq!(writer.write(&[4]), Ok(1));\n+            assert_eq!(writer.position(), 8);\n+\n+        }\n+        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n+        assert_eq!(buf, b);\n+    }\n+\n+    #[test]\n+    fn test_buf_writer_error() {\n+        let mut buf = [0 as u8; 2];\n+        let mut writer = Cursor::new(&mut buf[]);\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.write(&[0, 0]), Ok(1));\n+        assert_eq!(writer.write(&[0, 0]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_mem_reader() {\n+        let mut reader = Cursor::new(vec!(0u8, 1, 2, 3, 4, 5, 6, 7));\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.position(), 5);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf, b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut reader = Cursor::new(vec!(0u8, 1, 2, 3, 4, 5, 6, 7));\n+        let mut v = Vec::new();\n+        reader.read_to_end(&mut v).ok().unwrap();\n+        assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n+    }\n+\n+    #[test]\n+    fn test_slice_reader() {\n+        let in_buf = vec![0u8, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = &mut in_buf.as_slice();\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.len(), 7);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf.as_slice(), b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.len(), 3);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_buf_reader() {\n+        let in_buf = vec![0u8, 1, 2, 3, 4, 5, 6, 7];\n+        let mut reader = Cursor::new(in_buf.as_slice());\n+        let mut buf = [];\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.position(), 0);\n+        let mut buf = [0];\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.position(), 1);\n+        let b: &[_] = &[0];\n+        assert_eq!(buf, b);\n+        let mut buf = [0; 4];\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n+        assert_eq!(reader.position(), 5);\n+        let b: &[_] = &[1, 2, 3, 4];\n+        assert_eq!(buf, b);\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n+        let b: &[_] = &[5, 6, 7];\n+        assert_eq!(&buf[..3], b);\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+    }\n+\n+    #[test]\n+    fn test_read_char() {\n+        let b = b\"Vi\\xE1\\xBB\\x87t\";\n+        let mut c = Cursor::new(b).chars();\n+        assert_eq!(c.next(), Some(Ok('V')));\n+        assert_eq!(c.next(), Some(Ok('i')));\n+        assert_eq!(c.next(), Some(Ok('\u1ec7')));\n+        assert_eq!(c.next(), Some(Ok('t')));\n+        assert_eq!(c.next(), None);\n+    }\n+\n+    #[test]\n+    fn test_read_bad_char() {\n+        let b = b\"\\x80\";\n+        let mut c = Cursor::new(b).chars();\n+        assert!(c.next().unwrap().is_err());\n+    }\n+\n+    #[test]\n+    fn seek_past_end() {\n+        let buf = [0xff];\n+        let mut r = Cursor::new(&buf[]);\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.read(&mut [0]), Ok(0));\n+\n+        let mut r = Cursor::new(vec!(10u8));\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.read(&mut [0]), Ok(0));\n+\n+        let mut buf = [0];\n+        let mut r = Cursor::new(&mut buf[]);\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.write(&[3]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn seek_before_0() {\n+        let buf = [0xff_u8];\n+        let mut r = Cursor::new(&buf[]);\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+        let mut r = Cursor::new(vec!(10u8));\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+        let mut buf = [0];\n+        let mut r = Cursor::new(&mut buf[]);\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+    }\n+\n+    #[test]\n+    fn test_seekable_mem_writer() {\n+        let mut writer = Cursor::new(Vec::<u8>::new());\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[0]), Ok(1));\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(writer.write(&[1, 2, 3]), Ok(3));\n+        assert_eq!(writer.write(&[4, 5, 6, 7]), Ok(4));\n+        assert_eq!(writer.position(), 8);\n+        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::Start(0)), Ok(0));\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[3, 4]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::Current(1)), Ok(3));\n+        assert_eq!(writer.write(&[0, 1]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::End(-1)), Ok(7));\n+        assert_eq!(writer.write(&[1, 2]), Ok(2));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n+        assert_eq!(&writer.get_ref()[], b);\n+\n+        assert_eq!(writer.seek(SeekFrom::End(1)), Ok(10));\n+        assert_eq!(writer.write(&[1]), Ok(1));\n+        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n+        assert_eq!(&writer.get_ref()[], b);\n+    }\n+\n+    #[test]\n+    fn vec_seek_past_end() {\n+        let mut r = Cursor::new(Vec::new());\n+        assert_eq!(r.seek(SeekFrom::Start(10)), Ok(10));\n+        assert_eq!(r.write(&[3]), Ok(1));\n+    }\n+\n+    #[test]\n+    fn vec_seek_before_0() {\n+        let mut r = Cursor::new(Vec::new());\n+        assert!(r.seek(SeekFrom::End(-2)).is_err());\n+    }\n+}"}, {"sha": "9f3cd8c8b15deb4b68978d0df8c8343fe8486831", "filename": "src/libstd/io/error.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::Box;\n+use clone::Clone;\n+use error::Error as StdError;\n+use fmt;\n+use option::Option::{self, Some, None};\n+use result;\n+use string::String;\n+use sys;\n+\n+/// A type for results generated by I/O related functions where the `Err` type\n+/// is hard-wired to `io::Error`.\n+///\n+/// This typedef is generally used to avoid writing out `io::Error` directly and\n+/// is otherwise a direct mapping to `std::result::Result`.\n+pub type Result<T> = result::Result<T, Error>;\n+\n+/// The error type for I/O operations of the `Read`, `Write`, `Seek`, and\n+/// associated traits.\n+///\n+/// Errors mostly originate from the underlying OS, but custom instances of\n+/// `Error` can be created with crafted error messages and a particular value of\n+/// `ErrorKind`.\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+pub struct Error {\n+    repr: Repr,\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+enum Repr {\n+    Os(i32),\n+    Custom(Box<Custom>),\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+struct Custom {\n+    kind: ErrorKind,\n+    desc: &'static str,\n+    detail: Option<String>\n+}\n+\n+/// A list specifying general categories of I/O error.\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+pub enum ErrorKind {\n+    /// The file was not found.\n+    FileNotFound,\n+    /// The file permissions disallowed access to this file.\n+    PermissionDenied,\n+    /// The connection was refused by the remote server.\n+    ConnectionRefused,\n+    /// The connection was reset by the remote server.\n+    ConnectionReset,\n+    /// The connection was aborted (terminated) by the remote server.\n+    ConnectionAborted,\n+    /// The network operation failed because it was not connected yet.\n+    NotConnected,\n+    /// The operation failed because a pipe was closed.\n+    BrokenPipe,\n+    /// A file already existed with that name.\n+    PathAlreadyExists,\n+    /// No file exists at that location.\n+    PathDoesntExist,\n+    /// The path did not specify the type of file that this operation required.\n+    /// For example, attempting to copy a directory with the `fs::copy()`\n+    /// operation will fail with this error.\n+    MismatchedFileTypeForOperation,\n+    /// The operation temporarily failed (for example, because a signal was\n+    /// received), and retrying may succeed.\n+    ResourceUnavailable,\n+    /// A parameter was incorrect in a way that caused an I/O error not part of\n+    /// this list.\n+    InvalidInput,\n+    /// The I/O operation's timeout expired, causing it to be canceled.\n+    TimedOut,\n+    /// An error returned when an operation could not be completed because a\n+    /// call to `write` returned `Ok(0)`.\n+    ///\n+    /// This typically means that an operation could only succeed if it wrote a\n+    /// particular number of bytes but only a smaller number of bytes could be\n+    /// written.\n+    WriteZero,\n+    /// This operation was interrupted\n+    Interrupted,\n+    /// Any I/O error not part of this list.\n+    Other,\n+}\n+\n+impl Error {\n+    /// Creates a new custom error from a specified kind/description/detail.\n+    pub fn new(kind: ErrorKind,\n+               description: &'static str,\n+               detail: Option<String>) -> Error {\n+        Error {\n+            repr: Repr::Custom(Box::new(Custom {\n+                kind: kind,\n+                desc: description,\n+                detail: detail,\n+            }))\n+        }\n+    }\n+\n+    /// Returns an error representing the last OS error which occurred.\n+    ///\n+    /// This function reads the value of `errno` for the target platform (e.g.\n+    /// `GetLastError` on Windows) and will return a corresponding instance of\n+    /// `Error` for the error code.\n+    pub fn last_os_error() -> Error {\n+        Error::from_os_error(sys::os::errno() as i32)\n+    }\n+\n+    /// Creates a new instance of an `Error` from a particular OS error code.\n+    pub fn from_os_error(code: i32) -> Error {\n+        Error { repr: Repr::Os(code) }\n+    }\n+\n+    /// Return the corresponding `ErrorKind` for this error.\n+    pub fn kind(&self) -> ErrorKind {\n+        match self.repr {\n+            Repr::Os(code) => sys::decode_error_kind(code),\n+            Repr::Custom(ref c) => c.kind,\n+        }\n+    }\n+\n+    /// Returns a short description for this error message\n+    pub fn description(&self) -> &str {\n+        match self.repr {\n+            Repr::Os(..) => \"os error\",\n+            Repr::Custom(ref c) => c.desc,\n+        }\n+    }\n+\n+    /// Returns a detailed error message for this error (if one is available)\n+    pub fn detail(&self) -> Option<String> {\n+        match self.repr {\n+            Repr::Os(code) => Some(sys::os::error_string(code)),\n+            Repr::Custom(ref s) => s.detail.clone(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.repr {\n+            Repr::Os(code) => {\n+                let detail = sys::os::error_string(code);\n+                write!(fmt, \"{} (os error {})\", detail, code)\n+            }\n+            Repr::Custom(ref c) => {\n+                match **c {\n+                    Custom {\n+                        kind: ErrorKind::Other,\n+                        desc: \"unknown error\",\n+                        detail: Some(ref detail)\n+                    } => {\n+                        write!(fmt, \"{}\", detail)\n+                    }\n+                    Custom { detail: None, desc, .. } =>\n+                        write!(fmt, \"{}\", desc),\n+                    Custom { detail: Some(ref detail), desc, .. } =>\n+                        write!(fmt, \"{} ({})\", desc, detail)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl StdError for Error {\n+    fn description(&self) -> &str {\n+        match self.repr {\n+            Repr::Os(..) => \"os error\",\n+            Repr::Custom(ref c) => c.desc,\n+        }\n+    }\n+}"}, {"sha": "7f3ce7924c1caaa0fe8bfefdcf4968c80e95d201", "filename": "src/libstd/io/impls.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use boxed::Box;\n+use cmp;\n+use io::{self, SeekFrom, Read, Write, Seek, BufRead};\n+use mem;\n+use slice;\n+use vec::Vec;\n+\n+// =============================================================================\n+// Forwarding implementations\n+\n+impl<'a, R: Read + ?Sized> Read for &'a mut R {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+}\n+impl<'a, W: Write + ?Sized> Write for &'a mut W {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+}\n+impl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+}\n+impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+}\n+\n+impl<R: Read + ?Sized> Read for Box<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { (**self).read(buf) }\n+}\n+impl<W: Write + ?Sized> Write for Box<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+}\n+impl<S: Seek + ?Sized> Seek for Box<S> {\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+}\n+impl<B: BufRead + ?Sized> BufRead for Box<B> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+}\n+\n+// =============================================================================\n+// In-memory buffer implementations\n+\n+impl<'a> Read for &'a [u8] {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        let amt = cmp::min(buf.len(), self.len());\n+        let (a, b) = self.split_at(amt);\n+        slice::bytes::copy_memory(buf, a);\n+        *self = b;\n+        Ok(amt)\n+    }\n+}\n+\n+impl<'a> BufRead for &'a [u8] {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n+    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n+}\n+\n+impl<'a> Write for &'a mut [u8] {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        let amt = cmp::min(data.len(), self.len());\n+        let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n+        slice::bytes::copy_memory(a, &data[..amt]);\n+        *self = b;\n+        Ok(amt)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+impl Write for Vec<u8> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.push_all(buf);\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}"}, {"sha": "0832206a48b6086bf77b0e5cca1fdb2f87a9c88b", "filename": "src/libstd/io/mod.rs", "status": "added", "additions": 948, "deletions": 0, "changes": 948, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,948 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Traits, helpers, and type definitions for core I/O functionality.\n+//!\n+//! > **NOTE**: This module is very much a work in progress and is under active\n+//! > development. At this time it is still recommended to use the `old_io`\n+//! > module while the details of this module shake out.\n+\n+#![unstable(feature = \"io\",\n+            reason = \"this new I/O module is still under active deveopment and \\\n+                      APIs are subject to tweaks fairly regularly\")]\n+\n+use cmp;\n+use unicode::str as core_str;\n+use error::Error as StdError;\n+use fmt;\n+use iter::Iterator;\n+use marker::Sized;\n+use mem;\n+use ops::{Drop, FnOnce};\n+use option::Option::{self, Some, None};\n+use ptr::PtrExt;\n+use result::Result::{Ok, Err};\n+use result;\n+use slice::{self, SliceExt};\n+use string::String;\n+use str::{self, StrExt};\n+use vec::Vec;\n+\n+pub use self::buffered::{BufReader, BufWriter, BufStream, LineWriter};\n+pub use self::buffered::IntoInnerError;\n+pub use self::cursor::Cursor;\n+pub use self::error::{Result, Error, ErrorKind};\n+pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n+\n+pub mod prelude;\n+mod buffered;\n+mod cursor;\n+mod error;\n+mod impls;\n+mod util;\n+\n+const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n+\n+// Acquires a slice of the vector `v` from its length to its capacity\n+// (uninitialized data), reads into it, and then updates the length.\n+//\n+// This function is leveraged to efficiently read some bytes into a destination\n+// vector without extra copying and taking advantage of the space that's already\n+// in `v`.\n+//\n+// The buffer we're passing down, however, is pointing at uninitialized data\n+// (the end of a `Vec`), and many operations will be *much* faster if we don't\n+// have to zero it out. In order to prevent LLVM from generating an `undef`\n+// value when reads happen from this uninitialized memory, we force LLVM to\n+// think it's initialized by sending it through a black box. This should prevent\n+// actual undefined behavior after optimizations.\n+fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n+    where F: FnOnce(&mut [u8]) -> Result<usize>\n+{\n+    unsafe {\n+        let n = try!(f({\n+            let base = v.as_mut_ptr().offset(v.len() as isize);\n+            black_box(slice::from_raw_mut_buf(mem::copy_lifetime(v, &base),\n+                                              v.capacity() - v.len()))\n+        }));\n+\n+        // If the closure (typically a `read` implementation) reported that it\n+        // read a larger number of bytes than the vector actually has, we need\n+        // to be sure to clamp the vector to at most its capacity.\n+        let new_len = cmp::min(v.capacity(), v.len() + n);\n+        v.set_len(new_len);\n+        return Ok(n);\n+    }\n+\n+    // Semi-hack used to prevent LLVM from retaining any assumptions about\n+    // `dummy` over this function call\n+    unsafe fn black_box<T>(mut dummy: T) -> T {\n+        asm!(\"\" :: \"r\"(&mut dummy) : \"memory\");\n+        dummy\n+    }\n+}\n+\n+// A few methods below (read_to_string, read_line) will append data into a\n+// `String` buffer, but we need to be pretty careful when doing this. The\n+// implementation will just call `.as_mut_vec()` and then delegate to a\n+// byte-oriented reading method, but we must ensure that when returning we never\n+// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n+//\n+// To this end, we use an RAII guard (to protect against panics) which updates\n+// the length of the string when it is dropped. This guard initially truncates\n+// the string to the prior length and only afer we've validated that the\n+// new contents are valid UTF-8 do we allow it to set a longer length.\n+//\n+// The unsafety in this function is twofold:\n+//\n+// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n+//    checks.\n+// 2. We're passing a raw buffer to the function `f`, and it is expected that\n+//    the function only *appends* bytes to the buffer. We'll get undefined\n+//    behavior if existing bytes are overwritten to have non-UTF-8 data.\n+fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>\n+    where F: FnOnce(&mut Vec<u8>) -> Result<()>\n+{\n+    struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }\n+    #[unsafe_destructor]\n+    impl<'a> Drop for Guard<'a> {\n+        fn drop(&mut self) {\n+            unsafe { self.s.set_len(self.len); }\n+        }\n+    }\n+\n+    unsafe {\n+        let mut g = Guard { len: buf.len(), s: buf.as_mut_vec() };\n+        let ret = f(g.s);\n+        if str::from_utf8(&g.s[g.len..]).is_err() {\n+            ret.and_then(|()| {\n+                Err(Error::new(ErrorKind::InvalidInput,\n+                               \"stream did not contain valid UTF-8\", None))\n+            })\n+        } else {\n+            g.len = g.s.len();\n+            ret\n+        }\n+    }\n+}\n+\n+fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<()> {\n+    loop {\n+        if buf.capacity() == buf.len() {\n+            buf.reserve(DEFAULT_BUF_SIZE);\n+        }\n+        match with_end_to_cap(buf, |b| r.read(b)) {\n+            Ok(0) => return Ok(()),\n+            Ok(_) => {}\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            Err(e) => return Err(e),\n+        }\n+    }\n+}\n+\n+/// A trait for objects which are byte-oriented sources.\n+///\n+/// Readers are defined by one method, `read`. Each call to `read` will attempt\n+/// to pull bytes from this source into a provided buffer.\n+///\n+/// Readers are intended to be composable with one another. Many objects\n+/// throughout the I/O and related libraries take and provide types which\n+/// implement the `Read` trait.\n+pub trait Read {\n+    /// Pull some bytes from this source into the specified buffer, returning\n+    /// how many bytes were read.\n+    ///\n+    /// This function does not provide any guarantees about whether it blocks\n+    /// waiting for data, but if an object needs to block for a read but cannot\n+    /// it will typically signal this via an `Err` return value.\n+    ///\n+    /// If the return value of this method is `Ok(n)`, then it must be\n+    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n+    /// that the buffer `buf` has ben filled in with `n` bytes of data from this\n+    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n+    ///\n+    /// 1. This reader has reached its \"end of file\" and will likely no longer\n+    ///    be able to produce bytes. Note that this does not mean that the\n+    ///    reader will *always* no longer be able to produce bytes.\n+    /// 2. The buffer specified was 0 bytes in length.\n+    ///\n+    /// No guarantees are provided about the contents of `buf` when this\n+    /// function is called, implementations cannot rely on any property of the\n+    /// contents of `buf` being true. It is recommended that implementations\n+    /// only write data to `buf` instead of reading its contents.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters any form of I/O or other error, an error\n+    /// variant will be returned. If an error is returned then it must be\n+    /// guaranteed that no bytes were read.\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n+\n+    /// Read all bytes until EOF in this source, placing them into `buf`.\n+    ///\n+    /// All bytes read from this source will be appended to the specified buffer\n+    /// `buf`. This function will return a call to `read` either:\n+    ///\n+    /// 1. Returns `Ok(0)`.\n+    /// 2. Returns an error which is not of the kind `ErrorKind::Interrupted`.\n+    ///\n+    /// Until one of these conditions is met the function will continuously\n+    /// invoke `read` to append more data to `buf`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind\n+    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n+    /// will continue.\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns. Any bytes which have already been read will be appended to\n+    /// `buf`.\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<()> {\n+        read_to_end(self, buf)\n+    }\n+\n+    /// Read all bytes until EOF in this source, placing them into `buf`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the data in this stream is *not* valid UTF-8 then an error is\n+    /// returned and `buf` is unchanged.\n+    ///\n+    /// See `read_to_end` for other error semantics.\n+    fn read_to_string(&mut self, buf: &mut String) -> Result<()> {\n+        // Note that we do *not* call `.read_to_end()` here. We are passing\n+        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n+        // method to fill it up. An arbitrary implementation could overwrite the\n+        // entire contents of the vector, not just append to it (which is what\n+        // we are expecting).\n+        //\n+        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n+        // we pass it to our hardcoded `read_to_end` implementation which we\n+        // know is guaranteed to only read data into the end of the buffer.\n+        append_to_string(buf, |b| read_to_end(self, b))\n+    }\n+}\n+\n+/// Extension methods for all instances of `Read`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait ReadExt: Read + Sized {\n+    /// Create a \"by reference\" adaptor for this instance of `Read`.\n+    ///\n+    /// The returned adaptor also implements `Read` and will simply borrow this\n+    /// current reader.\n+    fn by_ref(&mut self) -> &mut Self { self }\n+\n+    /// Transform this `Read` instance to an `Iterator` over its bytes.\n+    ///\n+    /// The returned type implements `Iterator` where the `Item` is `Result<u8,\n+    /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n+    /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n+    /// this iterator.\n+    fn bytes(self) -> Bytes<Self> {\n+        Bytes { inner: self }\n+    }\n+\n+    /// Transform this `Read` instance to an `Iterator` over `char`s.\n+    ///\n+    /// This adaptor will attempt to interpret this reader as an UTF-8 encoded\n+    /// sequence of characters. The returned iterator will return `None` once\n+    /// EOF is reached for this reader. Otherwise each element yielded will be a\n+    /// `Result<char, E>` where `E` may contain information about what I/O error\n+    /// occurred or where decoding failed.\n+    ///\n+    /// Currently this adaptor will discard intermediate data read, and should\n+    /// be avoided if this is not desired.\n+    fn chars(self) -> Chars<Self> {\n+        Chars { inner: self }\n+    }\n+\n+    /// Create an adaptor which will chain this stream with another.\n+    ///\n+    /// The returned `Read` instance will first read all bytes from this object\n+    /// until EOF is encountered. Afterwards the output is equivalent to the\n+    /// output of `next`.\n+    fn chain<R: Read>(self, next: R) -> Chain<Self, R> {\n+        Chain { first: self, second: next, done_first: false }\n+    }\n+\n+    /// Create an adaptor which will read at most `limit` bytes from it.\n+    ///\n+    /// This function returns a new instance of `Read` which will read at most\n+    /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n+    /// read errors will not count towards the number of bytes read and future\n+    /// calls to `read` may succeed.\n+    fn take(self, limit: u64) -> Take<Self> {\n+        Take { inner: self, limit: limit }\n+    }\n+\n+    /// Creates a reader adaptor which will write all read data into the given\n+    /// output stream.\n+    ///\n+    /// Whenever the returned `Read` instance is read it will write the read\n+    /// data to `out`. The current semantics of this implementation imply that\n+    /// a `write` error will not report how much data was initially read.\n+    fn tee<W: Write>(self, out: W) -> Tee<Self, W> {\n+        Tee { reader: self, writer: out }\n+    }\n+}\n+\n+impl<T: Read> ReadExt for T {}\n+\n+/// A trait for objects which are byte-oriented sinks.\n+///\n+/// The `write` method will attempt to write some data into the object,\n+/// returning how many bytes were successfully written.\n+///\n+/// The `flush` method is useful for adaptors and explicit buffers themselves\n+/// for ensuring that all buffered data has been pushed out to the \"true sink\".\n+///\n+/// Writers are intended to be composable with one another. Many objects\n+/// throughout the I/O and related libraries take and provide types which\n+/// implement the `Write` trait.\n+pub trait Write {\n+    /// Write a buffer into this object, returning how many bytes were written.\n+    ///\n+    /// This function will attempt to write the entire contents of `buf`, but\n+    /// the entire write may not succeed, or the write may also generate an\n+    /// error. A call to `write` represents *at most one* attempt to write to\n+    /// any wrapped object.\n+    ///\n+    /// Calls to `write` are not guaranteed to block waiting for data to be\n+    /// written, and a write which would otherwise block can indicated through\n+    /// an `Err` variant.\n+    ///\n+    /// If the return value is `Ok(n)` then it must be guaranteed that\n+    /// `0 <= n <= buf.len()`. A return value of `0` typically means that the\n+    /// underlying object is no longer able to accept bytes and will likely not\n+    /// be able to in the future as well, or that the buffer provided is empty.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Each call to `write` may generate an I/O error indicating that the\n+    /// operation could not be completed. If an error is returned then no bytes\n+    /// in the buffer were written to this writer.\n+    ///\n+    /// It is **not** considered an error if the entire buffer could not be\n+    /// written to this writer.\n+    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n+\n+    /// Flush this output stream, ensuring that all intermediately buffered\n+    /// contents reach their destination.\n+    ///\n+    /// # Errors\n+    ///\n+    /// It is considered an error if not all bytes could be written due to\n+    /// I/O errors or EOF being reached.\n+    fn flush(&mut self) -> Result<()>;\n+\n+    /// Attempts to write an entire buffer into this write.\n+    ///\n+    /// This method will continuously call `write` while there is more data to\n+    /// write. This method will not return until the entire buffer has been\n+    /// successfully written or an error occurs. The first error generated from\n+    /// this method will be returned.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return the first error that `write` returns.\n+    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n+        while buf.len() > 0 {\n+            match self.write(buf) {\n+                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n+                                               \"failed to write whole buffer\",\n+                                               None)),\n+                Ok(n) => buf = &buf[n..],\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Writes a formatted string into this writer, returning any error\n+    /// encountered.\n+    ///\n+    /// This method is primarily used to interface with the `format_args!`\n+    /// macro, but it is rare that this should explicitly be called. The\n+    /// `write!` macro should be favored to invoke this method instead.\n+    ///\n+    /// This function internally uses the `write_all` method on this trait and\n+    /// hence will continuously write data so long as no errors are received.\n+    /// This also means that partial writes are not indicated in this signature.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return any I/O error reported while formatting.\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n+        // Create a shim which translates a Writer to a fmt::Writer and saves\n+        // off I/O errors. instead of discarding them\n+        struct Adaptor<'a, T: ?Sized + 'a> {\n+            inner: &'a mut T,\n+            error: Result<()>,\n+        }\n+\n+        impl<'a, T: Write + ?Sized> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write_all(s.as_bytes()) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut output = Adaptor { inner: self, error: Ok(()) };\n+        match fmt::write(&mut output, fmt) {\n+            Ok(()) => Ok(()),\n+            Err(..) => output.error\n+        }\n+    }\n+}\n+\n+/// Extension methods for all instances of `Write`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait WriteExt: Write + Sized {\n+    /// Create a \"by reference\" adaptor for this instance of `Write`.\n+    ///\n+    /// The returned adaptor also implements `Write` and will simply borrow this\n+    /// current writer.\n+    fn by_ref(&mut self) -> &mut Self { self }\n+\n+    /// Creates a new writer which will write all data to both this writer and\n+    /// another writer.\n+    ///\n+    /// All data written to the returned writer will both be written to `self`\n+    /// as well as `other`. Note that the error semantics of the current\n+    /// implementation do not precisely track where errors happen. For example\n+    /// an error on the second call to `write` will not report that the first\n+    /// call to `write` succeeded.\n+    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W> {\n+        Broadcast { first: self, second: other }\n+    }\n+}\n+\n+impl<T: Write> WriteExt for T {}\n+\n+/// An object implementing `Seek` internally has some form of cursor which can\n+/// be moved within a stream of bytes.\n+///\n+/// The stream typically has a fixed size, allowing seeking relative to either\n+/// end or the current offset.\n+pub trait Seek {\n+    /// Seek to an offset, in bytes, in a stream\n+    ///\n+    /// A seek beyond the end of a stream is allowed, but seeking before offset\n+    /// 0 is an error.\n+    ///\n+    /// Seeking past the end of the stream does not modify the underlying\n+    /// stream, but the next write may cause the previous data to be filled in\n+    /// with a bit pattern.\n+    ///\n+    /// This method returns the new position within the stream if the seek\n+    /// operation completed successfully.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Seeking to a negative offset is considered an error\n+    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n+}\n+\n+/// Enumeration of possible methods to seek within an I/O object.\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+pub enum SeekFrom {\n+    /// Set the offset to the provided number of bytes.\n+    Start(u64),\n+\n+    /// Set the offset to the size of this object plus the specified number of\n+    /// bytes.\n+    ///\n+    /// It is possible to seek beyond the end of an object, but is an error to\n+    /// seek before byte 0.\n+    End(i64),\n+\n+    /// Set the offset to the current position plus the specified number of\n+    /// bytes.\n+    ///\n+    /// It is possible to seek beyond the end of an object, but is an error to\n+    /// seek before byte 0.\n+    Current(i64),\n+}\n+\n+fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n+                                   -> Result<()> {\n+    loop {\n+        let (done, used) = {\n+            let available = match r.fill_buf() {\n+                Ok(n) => n,\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                Err(e) => return Err(e)\n+            };\n+            match available.position_elem(&delim) {\n+                Some(i) => {\n+                    buf.push_all(&available[..i + 1]);\n+                    (true, i + 1)\n+                }\n+                None => {\n+                    buf.push_all(available);\n+                    (false, available.len())\n+                }\n+            }\n+        };\n+        r.consume(used);\n+        if done || used == 0 {\n+            return Ok(());\n+        }\n+    }\n+}\n+\n+/// A Buffer is a type of reader which has some form of internal buffering to\n+/// allow certain kinds of reading operations to be more optimized than others.\n+///\n+/// This type extends the `Read` trait with a few methods that are not\n+/// possible to reasonably implement with purely a read interface.\n+pub trait BufRead: Read {\n+    /// Fills the internal buffer of this object, returning the buffer contents.\n+    ///\n+    /// None of the contents will be \"read\" in the sense that later calling\n+    /// `read` may return the same contents.\n+    ///\n+    /// The `consume` function must be called with the number of bytes that are\n+    /// consumed from this buffer returned to ensure that the bytes are never\n+    /// returned twice.\n+    ///\n+    /// An empty buffer returned indicates that the stream has reached EOF.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an I/O error if the underlying reader was\n+    /// read, but returned an error.\n+    fn fill_buf(&mut self) -> Result<&[u8]>;\n+\n+    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n+    /// so they should no longer be returned in calls to `read`.\n+    fn consume(&mut self, amt: usize);\n+\n+    /// Read all bytes until the delimiter `byte` is reached.\n+    ///\n+    /// This function will continue to read (and buffer) bytes from the\n+    /// underlying stream until the delimiter or EOF is found. Once found, all\n+    /// bytes up to, and including, the delimiter (if found) will be appended to\n+    /// `buf`.\n+    ///\n+    /// If this buffered reader is currently at EOF, then this function will not\n+    /// place any more bytes into `buf` and will return `Ok(())`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will ignore all instances of `ErrorKind::Interrupted` and\n+    /// will otherwise return any errors returned by `fill_buf`.\n+    ///\n+    /// If an I/O error is encountered then all bytes read so far will be\n+    /// present in `buf` and its length will have been adjusted appropriately.\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<()> {\n+        read_until(self, byte, buf)\n+    }\n+\n+    /// Read all bytes until a newline byte (the 0xA byte) is reached.\n+    ///\n+    /// This function will continue to read (and buffer) bytes from the\n+    /// underlying stream until the newline delimiter (the 0xA byte) or EOF is\n+    /// found. Once found, all bytes up to, and including, the delimiter (if\n+    /// found) will be appended to `buf`.\n+    ///\n+    /// If this reader is currently at EOF then this function will not modify\n+    /// `buf` and will return `Ok(())`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function has the same error semantics as `read_until` and will also\n+    /// return an error if the read bytes are not valid UTF-8. If an I/O error\n+    /// is encountered then `buf` may contain some bytes already read in the\n+    /// event that all data read so far was valid UTF-8.\n+    fn read_line(&mut self, buf: &mut String) -> Result<()> {\n+        // Note that we are not calling the `.read_until` method here, but\n+        // rather our hardcoded implementation. For more details as to why, see\n+        // the comments in `read_to_end`.\n+        append_to_string(buf, |b| read_until(self, b'\\n', b))\n+    }\n+}\n+\n+/// Extension methods for all instances of `BufRead`, typically imported through\n+/// `std::io::prelude::*`.\n+pub trait BufReadExt: BufRead + Sized {\n+    /// Returns an iterator over the contents of this reader split on the byte\n+    /// `byte`.\n+    ///\n+    /// The iterator returned from this function will return instances of\n+    /// `io::Result<Vec<u8>>`. Each vector returned will *not* have the\n+    /// delimiter byte at the end.\n+    ///\n+    /// This function will yield errors whenever `read_until` would have also\n+    /// yielded an error.\n+    fn split(self, byte: u8) -> Split<Self> {\n+        Split { buf: self, delim: byte }\n+    }\n+\n+    /// Returns an iterator over the lines of this reader.\n+    ///\n+    /// The iterator returned from this function will yield instances of\n+    /// `io::Result<String>`. Each string returned will *not* have a newline\n+    /// byte (the 0xA byte) at the end.\n+    ///\n+    /// This function will yield errors whenever `read_string` would have also\n+    /// yielded an error.\n+    fn lines(self) -> Lines<Self> {\n+        Lines { buf: self }\n+    }\n+}\n+\n+impl<T: BufRead> BufReadExt for T {}\n+\n+/// A `Write` adaptor which will write data to multiple locations.\n+///\n+/// For more information, see `WriteExt::broadcast`.\n+pub struct Broadcast<T, U> {\n+    first: T,\n+    second: U,\n+}\n+\n+impl<T: Write, U: Write> Write for Broadcast<T, U> {\n+    fn write(&mut self, data: &[u8]) -> Result<usize> {\n+        let n = try!(self.first.write(data));\n+        // FIXME: what if the write fails? (we wrote something)\n+        try!(self.second.write_all(&data[..n]));\n+        Ok(n)\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        self.first.flush().and(self.second.flush())\n+    }\n+}\n+\n+/// Adaptor to chain together two instances of `Read`.\n+///\n+/// For more information, see `ReadExt::chain`.\n+pub struct Chain<T, U> {\n+    first: T,\n+    second: U,\n+    done_first: bool,\n+}\n+\n+impl<T: Read, U: Read> Read for Chain<T, U> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        if !self.done_first {\n+            match try!(self.first.read(buf)) {\n+                0 => { self.done_first = true; }\n+                n => return Ok(n),\n+            }\n+        }\n+        self.second.read(buf)\n+    }\n+}\n+\n+/// Reader adaptor which limits the bytes read from an underlying reader.\n+///\n+/// For more information, see `ReadExt::take`.\n+pub struct Take<T> {\n+    inner: T,\n+    limit: u64,\n+}\n+\n+impl<T> Take<T> {\n+    /// Returns the number of bytes that can be read before this instance will\n+    /// return EOF.\n+    ///\n+    /// # Note\n+    ///\n+    /// This instance may reach EOF after reading fewer bytes than indiccated by\n+    /// this method if the underlying `Read` instance reaches EOF.\n+    pub fn limit(&self) -> u64 { self.limit }\n+}\n+\n+impl<T: Read> Read for Take<T> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let max = cmp::min(buf.len() as u64, self.limit) as usize;\n+        let n = try!(self.inner.read(&mut buf[..max]));\n+        self.limit -= n as u64;\n+        Ok(n)\n+    }\n+}\n+\n+/// An adaptor which will emit all read data to a specified writer as well.\n+///\n+/// For more information see `ReadExt::tee`\n+pub struct Tee<R, W> {\n+    reader: R,\n+    writer: W,\n+}\n+\n+impl<R: Read, W: Write> Read for Tee<R, W> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let n = try!(self.reader.read(buf));\n+        // FIXME: what if the write fails? (we read something)\n+        try!(self.writer.write_all(&buf[..n]));\n+        Ok(n)\n+    }\n+}\n+\n+/// A bridge from implementations of `Read` to an `Iterator` of `u8`.\n+///\n+/// See `ReadExt::bytes` for more information.\n+pub struct Bytes<R> {\n+    inner: R,\n+}\n+\n+impl<R: Read> Iterator for Bytes<R> {\n+    type Item = Result<u8>;\n+\n+    fn next(&mut self) -> Option<Result<u8>> {\n+        let mut buf = [0];\n+        match self.inner.read(&mut buf) {\n+            Ok(0) => None,\n+            Ok(..) => Some(Ok(buf[0])),\n+            Err(e) => Some(Err(e)),\n+        }\n+    }\n+}\n+\n+/// A bridge from implementations of `Read` to an `Iterator` of `char`.\n+///\n+/// See `ReadExt::chars` for more information.\n+pub struct Chars<R> {\n+    inner: R,\n+}\n+\n+/// An enumeration of possible errors that can be generated from the `Chars`\n+/// adapter.\n+#[derive(PartialEq, Clone, Debug)]\n+pub enum CharsError {\n+    /// Variant representing that the underlying stream was read successfully\n+    /// but it did not contain valid utf8 data.\n+    NotUtf8,\n+\n+    /// Variant representing that an I/O error occurred.\n+    Other(Error),\n+}\n+\n+impl<R: Read> Iterator for Chars<R> {\n+    type Item = result::Result<char, CharsError>;\n+\n+    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n+        let mut buf = [0];\n+        let first_byte = match self.inner.read(&mut buf) {\n+            Ok(0) => return None,\n+            Ok(..) => buf[0],\n+            Err(e) => return Some(Err(CharsError::Other(e))),\n+        };\n+        let width = core_str::utf8_char_width(first_byte);\n+        if width == 1 { return Some(Ok(first_byte as char)) }\n+        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n+        let mut buf = [first_byte, 0, 0, 0];\n+        {\n+            let mut start = 1;\n+            while start < width {\n+                match self.inner.read(&mut buf[start..width]) {\n+                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n+                    Ok(n) => start += n,\n+                    Err(e) => return Some(Err(CharsError::Other(e))),\n+                }\n+            }\n+        }\n+        Some(match str::from_utf8(&buf[..width]).ok() {\n+            Some(s) => Ok(s.char_at(0)),\n+            None => Err(CharsError::NotUtf8),\n+        })\n+    }\n+}\n+\n+impl StdError for CharsError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n+            CharsError::Other(ref e) => e.description(),\n+        }\n+    }\n+    fn cause(&self) -> Option<&StdError> {\n+        match *self {\n+            CharsError::NotUtf8 => None,\n+            CharsError::Other(ref e) => e.cause(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CharsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CharsError::NotUtf8 => {\n+                \"byte stream did not contain valid utf8\".fmt(f)\n+            }\n+            CharsError::Other(ref e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n+/// An iterator over the contents of an instance of `BufRead` split on a\n+/// particular byte.\n+///\n+/// See `BufReadExt::split` for more information.\n+pub struct Split<B> {\n+    buf: B,\n+    delim: u8,\n+}\n+\n+impl<B: BufRead> Iterator for Split<B> {\n+    type Item = Result<Vec<u8>>;\n+\n+    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n+        let mut buf = Vec::new();\n+        match self.buf.read_until(self.delim, &mut buf) {\n+            Ok(()) if buf.len() == 0 => None,\n+            Ok(()) => {\n+                if buf[buf.len() - 1] == self.delim {\n+                    buf.pop();\n+                }\n+                Some(Ok(buf))\n+            }\n+            Err(e) => Some(Err(e))\n+        }\n+    }\n+}\n+\n+/// An iterator over the lines of an instance of `BufRead` split on a newline\n+/// byte.\n+///\n+/// See `BufReadExt::lines` for more information.\n+pub struct Lines<B> {\n+    buf: B,\n+}\n+\n+impl<B: BufRead> Iterator for Lines<B> {\n+    type Item = Result<String>;\n+\n+    fn next(&mut self) -> Option<Result<String>> {\n+        let mut buf = String::new();\n+        match self.buf.read_line(&mut buf) {\n+            Ok(()) if buf.len() == 0 => None,\n+            Ok(()) => {\n+                if buf.ends_with(\"\\n\") {\n+                    buf.pop();\n+                }\n+                Some(Ok(buf))\n+            }\n+            Err(e) => Some(Err(e))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use super::Cursor;\n+\n+    #[test]\n+    fn read_until() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut v = Vec::new();\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"12\");\n+\n+        let mut buf = Cursor::new(b\"1233\");\n+        let mut v = Vec::new();\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"123\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, b\"3\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(v, []);\n+    }\n+\n+    #[test]\n+    fn split() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut s = buf.split(b'3');\n+        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n+        assert_eq!(s.next(), None);\n+\n+        let mut buf = Cursor::new(b\"1233\");\n+        let mut s = buf.split(b'3');\n+        assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n+        assert_eq!(s.next(), Some(Ok(vec![])));\n+        assert_eq!(s.next(), None);\n+    }\n+\n+    #[test]\n+    fn read_line() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut v = String::new();\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"12\");\n+\n+        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let mut v = String::new();\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"12\\n\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"\\n\");\n+        v.truncate(0);\n+        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(v, \"\");\n+    }\n+\n+    #[test]\n+    fn lines() {\n+        let mut buf = Cursor::new(b\"12\");\n+        let mut s = buf.lines();\n+        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n+        assert_eq!(s.next(), None);\n+\n+        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let mut s = buf.lines();\n+        assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n+        assert_eq!(s.next(), Some(Ok(String::new())));\n+        assert_eq!(s.next(), None);\n+    }\n+\n+    #[test]\n+    fn read_to_end() {\n+        let mut c = Cursor::new(b\"\");\n+        let mut v = Vec::new();\n+        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(v, []);\n+\n+        let mut c = Cursor::new(b\"1\");\n+        let mut v = Vec::new();\n+        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(v, b\"1\");\n+    }\n+\n+    #[test]\n+    fn read_to_string() {\n+        let mut c = Cursor::new(b\"\");\n+        let mut v = String::new();\n+        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(v, \"\");\n+\n+        let mut c = Cursor::new(b\"1\");\n+        let mut v = String::new();\n+        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(v, \"1\");\n+\n+        let mut c = Cursor::new(b\"\\xff\");\n+        let mut v = String::new();\n+        assert!(c.read_to_string(&mut v).is_err());\n+    }\n+}"}, {"sha": "475ada2ff84b891102ba96ada6868fb84b51fc0f", "filename": "src/libstd/io/prelude.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The I/O Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of many common I/O traits\n+//! by adding a glob import to the top of I/O heavy modules:\n+//!\n+//! ```\n+//! use std::io::prelude::*;\n+//! ```\n+//!\n+//! This module contains reexports of many core I/O traits such as `Read`,\n+//! `Write`, `ReadExt`, and `WriteExt`. Structures and functions are not\n+//! contained in this module.\n+\n+pub use super::{Read, ReadExt, Write, WriteExt, BufRead, BufReadExt};\n+\n+// FIXME: pub use as `Seek` when the name isn't in the actual prelude any more\n+pub use super::Seek as NewSeek;"}, {"sha": "3d342137c62ddd3d3a340811384d1dc2e166efd8", "filename": "src/libstd/io/util.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_copy_implementations)]\n+\n+use prelude::v1::*;\n+\n+use io::{self, Read, Write, ErrorKind};\n+\n+/// Copies the entire contents of a reader into a writer.\n+///\n+/// This function will continuously read data from `r` and then write it into\n+/// `w` in a streaming fashion until `r` returns EOF.\n+///\n+/// On success the total number of bytes that were copied from `r` to `w` is\n+/// returned.\n+///\n+/// # Errors\n+///\n+/// This function will return an error immediately if any call to `read` or\n+/// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n+/// handled by this function and the underlying operation is retried.\n+pub fn copy<R: Read, W: Write>(r: &mut R, w: &mut W) -> io::Result<u64> {\n+    let mut buf = [0; super::DEFAULT_BUF_SIZE];\n+    let mut written = 0;\n+    loop {\n+        let len = match r.read(&mut buf) {\n+            Ok(0) => return Ok(written),\n+            Ok(len) => len,\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+            Err(e) => return Err(e),\n+        };\n+        try!(w.write_all(&buf[..len]));\n+        written += len as u64;\n+    }\n+}\n+\n+/// A reader which is always at EOF.\n+pub struct Empty { _priv: () }\n+\n+/// Creates an instance of an empty reader.\n+///\n+/// All reads from the returned reader will return `Ok(0)`.\n+pub fn empty() -> Empty { Empty { _priv: () } }\n+\n+impl Read for Empty {\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+}\n+\n+/// A reader which infinitely yields one byte.\n+pub struct Repeat { byte: u8 }\n+\n+/// Creates an instance of a reader that infinitely repeats one byte.\n+///\n+/// All reads from this reader will succeed by filling the specified buffer with\n+/// the given byte.\n+pub fn repeat(byte: u8) -> Repeat { Repeat { byte: byte } }\n+\n+impl Read for Repeat {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        for slot in buf.iter_mut() {\n+            *slot = self.byte;\n+        }\n+        Ok(buf.len())\n+    }\n+}\n+\n+/// A writer which will move data into the void.\n+pub struct Sink { _priv: () }\n+\n+/// Creates an instance of a writer which will successfully consume all data.\n+///\n+/// All calls to `write` on the returned instance will return `Ok(buf.len())`\n+/// and the contents of the buffer will not be inspected.\n+pub fn sink() -> Sink { Sink { _priv: () } }\n+\n+impl Write for Sink {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::v1::*;\n+\n+    use io::prelude::*;\n+    use io::{sink, empty, repeat};\n+\n+    #[test]\n+    fn sink_sinks() {\n+        let mut s = sink();\n+        assert_eq!(s.write(&[]), Ok(0));\n+        assert_eq!(s.write(&[0]), Ok(1));\n+        assert_eq!(s.write(&[0; 1024]), Ok(1024));\n+        assert_eq!(s.by_ref().write(&[0; 1024]), Ok(1024));\n+    }\n+\n+    #[test]\n+    fn empty_reads() {\n+        let mut e = empty();\n+        assert_eq!(e.read(&mut []), Ok(0));\n+        assert_eq!(e.read(&mut [0]), Ok(0));\n+        assert_eq!(e.read(&mut [0; 1024]), Ok(0));\n+        assert_eq!(e.by_ref().read(&mut [0; 1024]), Ok(0));\n+    }\n+\n+    #[test]\n+    fn repeat_repeats() {\n+        let mut r = repeat(4);\n+        let mut b = [0; 1024];\n+        assert_eq!(r.read(&mut b), Ok(1024));\n+        assert!(b.iter().all(|b| *b == 4));\n+    }\n+\n+    #[test]\n+    fn take_some_bytes() {\n+        assert_eq!(repeat(4).take(100).bytes().count(), 100);\n+        assert_eq!(repeat(4).take(100).bytes().next(), Some(Ok(4)));\n+        assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n+    }\n+\n+    #[test]\n+    fn tee() {\n+        let mut buf = [0; 10];\n+        {\n+            let mut ptr: &mut [u8] = &mut buf;\n+            assert_eq!(repeat(4).tee(&mut ptr).take(5).read(&mut [0; 10]), Ok(5));\n+        }\n+        assert_eq!(buf, [4, 4, 4, 4, 4, 0, 0, 0, 0, 0]);\n+    }\n+\n+    #[test]\n+    fn broadcast() {\n+        let mut buf1 = [0; 10];\n+        let mut buf2 = [0; 10];\n+        {\n+            let mut ptr1: &mut [u8] = &mut buf1;\n+            let mut ptr2: &mut [u8] = &mut buf2;\n+\n+            assert_eq!((&mut ptr1).broadcast(&mut ptr2)\n+                                  .write(&[1, 2, 3]), Ok(3));\n+        }\n+        assert_eq!(buf1, buf2);\n+        assert_eq!(buf1, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);\n+    }\n+}"}, {"sha": "a46cea7a44325ea60a451f64f2fe52b5079504bb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -128,9 +128,8 @@\n \n #![deny(missing_docs)]\n \n-#[cfg(test)]\n-#[macro_use]\n-extern crate log;\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n #[macro_use]\n #[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n@@ -248,9 +247,11 @@ pub mod dynamic_lib;\n pub mod ffi;\n pub mod fmt;\n pub mod old_io;\n+pub mod io;\n pub mod os;\n pub mod env;\n pub mod path;\n+pub mod old_path;\n pub mod rand;\n pub mod time;\n "}, {"sha": "88ca6667d55deba1e56b8446824b6a9f73c48ddc", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -61,8 +61,8 @@ use old_io;\n use iter::{Iterator, Extend};\n use option::Option;\n use option::Option::{Some, None};\n-use path::{Path, GenericPath};\n-use path;\n+use old_path::{Path, GenericPath};\n+use old_path;\n use result::Result::{Err, Ok};\n use slice::SliceExt;\n use string::String;\n@@ -782,7 +782,7 @@ pub trait PathExtensions {\n     fn is_dir(&self) -> bool;\n }\n \n-impl PathExtensions for path::Path {\n+impl PathExtensions for old_path::Path {\n     fn stat(&self) -> IoResult<FileStat> { stat(self) }\n     fn lstat(&self) -> IoResult<FileStat> { lstat(self) }\n     fn exists(&self) -> bool {"}, {"sha": "8c4a10a55d489d86865f8ca661754fefc97d56b5", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -23,7 +23,7 @@\n use prelude::v1::*;\n \n use ffi::CString;\n-use path::BytesContainer;\n+use old_path::BytesContainer;\n use old_io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n use sys::pipe::UnixListener as UnixListenerImp;"}, {"sha": "27af957e18e18614c591e47fd2911a9672cdd8f2", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -25,7 +25,7 @@ use old_io::{IoResult, IoError};\n use old_io;\n use libc;\n use os;\n-use path::BytesContainer;\n+use old_path::BytesContainer;\n use sync::mpsc::{channel, Receiver};\n use sys::fs::FileDesc;\n use sys::process::Process as ProcessImp;"}, {"sha": "a227116dfae997b4c3818f888fba4abf3a30e8bb", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -17,7 +17,7 @@ use old_io;\n use ops::Drop;\n use option::Option::{None, Some};\n use option::Option;\n-use path::{Path, GenericPath};\n+use old_path::{Path, GenericPath};\n use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n use str::StrExt;"}, {"sha": "0d80258d7e04f1f3b590e30db7057f2b97bed0b9", "filename": "src/libstd/old_path/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "previous_filename": "src/libstd/path/mod.rs"}, {"sha": "8bcdd89623d8fb91a0e8b10e2f38287f73cece51", "filename": "src/libstd/old_path/posix.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -445,7 +445,7 @@ mod tests {\n     use clone::Clone;\n     use iter::IteratorExt;\n     use option::Option::{self, Some, None};\n-    use path::GenericPath;\n+    use old_path::GenericPath;\n     use slice::{AsSlice, SliceExt};\n     use str::{self, Str, StrExt};\n     use string::ToString;", "previous_filename": "src/libstd/path/posix.rs"}, {"sha": "2e25403220d8264c99d15083fb5a28f86acf501d", "filename": "src/libstd/old_path/windows.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1124,7 +1124,7 @@ mod tests {\n     use clone::Clone;\n     use iter::IteratorExt;\n     use option::Option::{self, Some, None};\n-    use path::GenericPath;\n+    use old_path::GenericPath;\n     use slice::{AsSlice, SliceExt};\n     use str::Str;\n     use string::ToString;", "previous_filename": "src/libstd/path/windows.rs"}, {"sha": "36122b16ea078115b9ae204b9dd0c88bd36fde5a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -48,7 +48,7 @@ use old_io::{IoResult, IoError};\n use ops::{Drop, FnOnce};\n use option::Option::{Some, None};\n use option::Option;\n-use path::{Path, GenericPath, BytesContainer};\n+use old_path::{Path, GenericPath, BytesContainer};\n use ptr::PtrExt;\n use ptr;\n use result::Result::{Err, Ok};\n@@ -267,7 +267,7 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n ///\n /// ```rust\n /// use std::os;\n-/// use std::path::Path;\n+/// use std::old_path::Path;\n ///\n /// let key = \"PATH\";\n /// let mut paths = os::getenv_as_bytes(key).map_or(Vec::new(), os::split_paths);\n@@ -470,7 +470,7 @@ pub fn tmpdir() -> Path {\n /// # Example\n /// ```rust\n /// use std::os;\n-/// use std::path::Path;\n+/// use std::old_path::Path;\n ///\n /// // Assume we're in a path like /home/someuser\n /// let rel_path = Path::new(\"..\");\n@@ -500,7 +500,7 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// # Example\n /// ```rust\n /// use std::os;\n-/// use std::path::Path;\n+/// use std::old_path::Path;\n ///\n /// let root = Path::new(\"/\");\n /// assert!(os::change_dir(&root).is_ok());"}, {"sha": "3f4f1ec4c0db5f4afe33e516bf98a4ba02630952", "filename": "src/libstd/path.rs", "status": "added", "additions": 2577, "deletions": 0, "changes": 2577, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,2577 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Cross-platform path manipulation.\n+//!\n+//! This module provides two types, `PathBuf` and `Path` (akin to `String` and\n+//! `str`), for working with paths abstractly. These types are thin wrappers\n+//! around `OsString` and `OsStr` respectively, meaning that they work directly\n+//! on strings according to the local platform's path syntax.\n+//!\n+//! ## Simple usage\n+//!\n+//! Path manipulation involves both parsing components from slices and building\n+//! new owned paths.\n+//!\n+//! To parse a path, you can create a `Path` slice from a `str`\n+//! slice and start asking questions:\n+//!\n+//! ```rust\n+//! use std::path::Path;\n+//!\n+//! let path = Path::new(\"/tmp/foo/bar.txt\");\n+//! let file = path.file_name();\n+//! let extension = path.extension();\n+//! let parent_dir = path.parent();\n+//! ```\n+//!\n+//! To build or modify paths, use `PathBuf`:\n+//!\n+//! ```rust\n+//! use std::path::PathBuf;\n+//!\n+//! let mut path = PathBuf::new(\"c:\\\\\");\n+//! path.push(\"windows\");\n+//! path.push(\"system32\");\n+//! path.set_extension(\"dll\");\n+//! ```\n+//!\n+//! ## Path components and normalization\n+//!\n+//! The path APIs are built around the notion of \"components\", which roughly\n+//! correspond to the substrings between path separators (`/` and, on Windows,\n+//! `\\`). The APIs for path parsing are largely specified in terms of the path's\n+//! components, so it's important to clearly understand how those are determined.\n+//!\n+//! A path can always be reconstructed into an equivalent path by putting\n+//! together its components via `push`. Syntactically, the paths may differ by\n+//! the normalization described below.\n+//!\n+//! ### Component types\n+//!\n+//! Components come in several types:\n+//!\n+//! * Normal components are the default: standard references to files or\n+//! directories. The path `a/b` has two normal components, `a` and `b`.\n+//!\n+//! * Current directory components represent the `.` character. For example,\n+//! `a/.` has a normal component `a` and a current directory component.\n+//!\n+//! * The root directory component represents a separator that designates\n+//!   starting from root. For example, `/a/b` has a root directory component\n+//!   followed by normal components `a` and `b`.\n+//!\n+//! On Windows, two additional component types come into play:\n+//!\n+//! * Prefix components, of which there is a large variety. For example, `C:`\n+//! and `\\\\server\\share` are prefixes. The path `C:windows` has a prefix\n+//! component `C:` and a normal component `windows`; the path `C:\\windows` has a\n+//! prefix component `C:`, a root directory component, and a normal component\n+//! `windows`.\n+//!\n+//! * Empty components, a special case for so-called \"verbatim\" paths where very\n+//! little normalization is allowed. For example, `\\\\?\\C:\\` has a \"verbatim\"\n+//! prefix `\\\\?\\C:`, a root component, and an empty component (as a way of\n+//! representing the trailing `\\`. Such a trailing `\\` is in fact the only\n+//! situation in which an empty component is produced.\n+//!\n+//! ### Normalization\n+//!\n+//! Aside from splitting on the separator(s), there is a small amount of\n+//! \"normalization\":\n+//!\n+//! * Repeated separators are ignored: `a/b` and `a//b` both have components `a`\n+//!   and `b`.\n+//!\n+//! * Paths ending in a separator are treated as if they has a current directory\n+//!   component at the end (or, in verbatim paths, an empty component).  For\n+//!   example, while `a/b` has components `a` and `b`, the paths `a/b/` and\n+//!   `a/b/.` both have components `a`, `b`, and `.` (current directory).  The\n+//!   reason for this normalization is that `a/b` and `a/b/` are treated\n+//!   differently in some contexts, but `a/b/` and `a/b/.` are always treated\n+//!   the same.\n+//!\n+//! No other normalization takes place by default. In particular, `a/./b/` and\n+//! `a/b` are treated distinctly in terms of components, as are `a/c` and\n+//! `a/b/../c`. Further normalization is possible to build on top of the\n+//! components APIs, and will be included in this library very soon.\n+\n+#![unstable(feature = \"path\")]\n+\n+use core::prelude::*;\n+\n+use borrow::BorrowFrom;\n+use cmp;\n+use iter;\n+use mem;\n+use ops::{self, Deref};\n+use string::CowString;\n+use vec::Vec;\n+use fmt;\n+\n+use ffi::{OsStr, OsString, AsOsStr};\n+\n+use self::platform::{is_sep, is_verbatim_sep, MAIN_SEP_STR, parse_prefix, Prefix};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// GENERAL NOTES\n+////////////////////////////////////////////////////////////////////////////////\n+//\n+// Parsing in this module is done by directly transmuting OsStr to [u8] slices,\n+// taking advantage of the fact that OsStr always encodes ASCII characters\n+// as-is.  Eventually, this transmutation should be replaced by direct uses of\n+// OsStr APIs for parsing, but it will take a while for those to become\n+// available.\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Platform-specific definitions\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// The following modules give the most basic tools for parsing paths on various\n+// platforms. The bulk of the code is devoted to parsing prefixes on Windows.\n+\n+#[cfg(unix)]\n+mod platform {\n+    use core::prelude::*;\n+    use ffi::OsStr;\n+\n+    #[inline]\n+    pub fn is_sep(b: u8) -> bool {\n+        b == b'/'\n+    }\n+\n+    #[inline]\n+    pub fn is_verbatim_sep(b: u8) -> bool {\n+        b == b'/'\n+    }\n+\n+    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+        None\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+    pub struct Prefix<'a>;\n+\n+    impl<'a> Prefix<'a> {\n+        #[inline]\n+        pub fn len(&self) -> usize { 0 }\n+        #[inline]\n+        pub fn is_verbatim(&self) -> bool { false }\n+        #[inline]\n+        pub fn is_drive(&self) -> bool { false }\n+        #[inline]\n+        pub fn has_implicit_root(&self) -> bool { false }\n+    }\n+\n+    pub const MAIN_SEP_STR: &'static str = \"/\";\n+}\n+\n+#[cfg(windows)]\n+mod platform {\n+    use core::prelude::*;\n+\n+    use char::CharExt as UnicodeCharExt;\n+    use super::{os_str_as_u8_slice, u8_slice_as_os_str};\n+    use ascii::*;\n+    use ffi::OsStr;\n+\n+    #[inline]\n+    pub fn is_sep(b: u8) -> bool {\n+        b == b'/' || b == b'\\\\'\n+    }\n+\n+    #[inline]\n+    pub fn is_verbatim_sep(b: u8) -> bool {\n+        b == b'\\\\'\n+    }\n+\n+    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n+        use self::Prefix::*;\n+        unsafe {\n+            // The unsafety here stems from converting between &OsStr and &[u8]\n+            // and back. This is safe to do because (1) we only look at ASCII\n+            // contents of the encoding and (2) new &OsStr values are produced\n+            // only from ASCII-bounded slices of existing &OsStr values.\n+            let mut path = os_str_as_u8_slice(path);\n+\n+            if path.starts_with(br\"\\\\\") {\n+                // \\\\\n+                path = &path[2..];\n+                if path.starts_with(br\"?\\\") {\n+                    // \\\\?\\\n+                    path = &path[2..];\n+                    if path.starts_with(br\"UNC\\\") {\n+                        // \\\\?\\UNC\\server\\share\n+                        path = &path[4..];\n+                        let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n+                            Some((server, share)) => (u8_slice_as_os_str(server),\n+                                                      u8_slice_as_os_str(share)),\n+                            None => (u8_slice_as_os_str(path),\n+                                     u8_slice_as_os_str(&[])),\n+                        };\n+                        return Some(VerbatimUNC(server, share));\n+                    } else {\n+                        // \\\\?\\path\n+                        let idx = path.position_elem(&b'\\\\');\n+                        if idx == Some(2) && path[1] == b':' {\n+                            let c = path[0];\n+                            if c.is_ascii() && (c as char).is_alphabetic() {\n+                                // \\\\?\\C:\\ path\n+                                let slice = u8_slice_as_os_str(&path[0..1]);\n+                                return Some(VerbatimDisk(slice));\n+                            }\n+                        }\n+                        let slice = &path[.. idx.unwrap_or(path.len())];\n+                        return Some(Verbatim(u8_slice_as_os_str(slice)));\n+                    }\n+                } else if path.starts_with(b\".\\\\\") {\n+                    // \\\\.\\path\n+                    path = &path[2..];\n+                    let slice = &path[.. path.position_elem(&b'\\\\').unwrap_or(path.len())];\n+                    return Some(DeviceNS(u8_slice_as_os_str(slice)));\n+                }\n+                match parse_two_comps(path, is_sep) {\n+                    Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n+                        // \\\\server\\share\n+                        return Some(UNC(u8_slice_as_os_str(server),\n+                                        u8_slice_as_os_str(share)));\n+                    }\n+                    _ => ()\n+                }\n+            } else if path.len() > 1 && path[1] == b':' {\n+                // C:\n+                let c = path[0];\n+                if c.is_ascii() && (c as char).is_alphabetic() {\n+                    return Some(Disk(u8_slice_as_os_str(&path[0..1])));\n+                }\n+            }\n+            return None;\n+        }\n+\n+        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+            let first = match path.iter().position(|x| f(*x)) {\n+                None => return None,\n+                Some(x) => &path[.. x]\n+            };\n+            path = &path[(first.len()+1)..];\n+            let idx = path.iter().position(|x| f(*x));\n+            let second = &path[.. idx.unwrap_or(path.len())];\n+            Some((first, second))\n+        }\n+    }\n+\n+    /// Windows path prefixes.\n+    ///\n+    /// Windows uses a variety of path styles, including references to drive\n+    /// volumes (like `C:`), network shared (like `\\\\server\\share`) and\n+    /// others. In addition, some path prefixes are \"verbatim\", in which case\n+    /// `/` is *not* treated as a separator and essentially no normalization is\n+    /// performed.\n+    #[derive(Copy, Clone, Debug, Hash, Eq)]\n+    pub enum Prefix<'a> {\n+        /// Prefix `\\\\?\\`, together with the given component immediately following it.\n+        Verbatim(&'a OsStr),\n+\n+        /// Prefix `\\\\?\\UNC\\`, with the \"server\" and \"share\" components following it.\n+        VerbatimUNC(&'a OsStr, &'a OsStr),\n+\n+        /// Prefix like `\\\\?\\C:\\`, for the given drive letter\n+        VerbatimDisk(&'a OsStr),\n+\n+        /// Prefix `\\\\.\\`, together with the given component immediately following it.\n+        DeviceNS(&'a OsStr),\n+\n+        /// Prefix `\\\\server\\share`, with the given \"server\" and \"share\" components.\n+        UNC(&'a OsStr, &'a OsStr),\n+\n+        /// Prefix `C:` for the given disk drive.\n+        Disk(&'a OsStr),\n+    }\n+\n+    impl<'a> Prefix<'a> {\n+        #[inline]\n+        pub fn len(&self) -> usize {\n+            use self::Prefix::*;\n+            fn os_str_len(s: &OsStr) -> usize {\n+                os_str_as_u8_slice(s).len()\n+            }\n+            match *self {\n+                Verbatim(x) => 4 + os_str_len(x),\n+                VerbatimUNC(x,y) => 8 + os_str_len(x) +\n+                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                    else { 0 },\n+                VerbatimDisk(_) => 6,\n+                UNC(x,y) => 2 + os_str_len(x) +\n+                    if os_str_len(y) > 0 { 1 + os_str_len(y) }\n+                    else { 0 },\n+                DeviceNS(x) => 4 + os_str_len(x),\n+                Disk(_) => 2\n+            }\n+\n+        }\n+\n+        #[inline]\n+        pub fn is_verbatim(&self) -> bool {\n+            use self::Prefix::*;\n+            match *self {\n+                Verbatim(_) | VerbatimDisk(_) | VerbatimUNC(_, _) => true,\n+                _ => false\n+            }\n+        }\n+\n+        #[inline]\n+        pub fn is_drive(&self) -> bool {\n+            match *self {\n+                Prefix::Disk(_) => true,\n+                _ => false,\n+            }\n+        }\n+\n+        #[inline]\n+        pub fn has_implicit_root(&self) -> bool {\n+            !self.is_drive()\n+        }\n+    }\n+\n+    impl<'a> PartialEq for Prefix<'a> {\n+        fn eq(&self, other: &Prefix<'a>) -> bool {\n+            use self::Prefix::*;\n+            match (*self, *other) {\n+                (Verbatim(x), Verbatim(y)) => x == y,\n+                (VerbatimUNC(x1, x2), VerbatimUNC(y1, y2)) => x1 == y1 && x2 == y2,\n+                (VerbatimDisk(x), VerbatimDisk(y)) =>\n+                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n+                (DeviceNS(x), DeviceNS(y)) => x == y,\n+                (UNC(x1, x2), UNC(y1, y2)) => x1 == y1 && x2 == y2,\n+                (Disk(x), Disk(y)) =>\n+                    os_str_as_u8_slice(x).eq_ignore_ascii_case(os_str_as_u8_slice(y)),\n+                _ => false,\n+            }\n+        }\n+    }\n+\n+    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Misc helpers\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// Iterate through `iter` while it matches `prefix`; return `None` if `prefix`\n+// is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n+// `iter` after having exhausted `prefix`.\n+fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I> where\n+    I: Iterator<Item=A> + Clone, J: Iterator<Item=A>, A: PartialEq\n+{\n+    loop {\n+        let mut iter_next = iter.clone();\n+        match (iter_next.next(), prefix.next()) {\n+            (Some(x), Some(y)) => {\n+                if x != y { return None }\n+            }\n+            (Some(_), None) => return Some(iter),\n+            (None, None) => return Some(iter),\n+            (None, Some(_)) => return None,\n+        }\n+        iter = iter_next;\n+    }\n+}\n+\n+// See note at the top of this module to understand why these are used:\n+fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n+    unsafe { mem::transmute(s) }\n+}\n+unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n+    mem::transmute(s)\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Cross-platform parsing\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Says whether the path ends in a separator character and therefore needs to\n+/// be treated as if it ended with an additional `.`\n+fn has_suffix(s: &[u8], prefix: Option<Prefix>) -> bool {\n+    let (prefix_len, verbatim) = if let Some(p) = prefix {\n+        (p.len(), p.is_verbatim())\n+    } else { (0, false) };\n+    if prefix_len > 0 && prefix_len == s.len() && !verbatim { return true; }\n+    let mut splits = s[prefix_len..].split(|b| is_sep(*b));\n+    let last = splits.next_back().unwrap();\n+    let more = splits.next_back().is_some();\n+    more && last == b\"\"\n+}\n+\n+/// Says whether the first byte after the prefix is a separator.\n+fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n+    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n+    path.len() > 0 && is_sep(path[0])\n+}\n+\n+fn parse_single_component(comp: &[u8]) -> Option<Component> {\n+    match comp {\n+        b\".\" => Some(Component::CurDir),\n+        b\"..\" => Some(Component::ParentDir),\n+        b\"\" => None,\n+        _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) }))\n+    }\n+}\n+\n+// basic workhorse for splitting stem and extension\n+#[allow(unused_unsafe)] // FIXME\n+fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n+    unsafe {\n+        if os_str_as_u8_slice(file) == b\"..\" { return (Some(file), None) }\n+\n+        // The unsafety here stems from converting between &OsStr and &[u8]\n+        // and back. This is safe to do because (1) we only look at ASCII\n+        // contents of the encoding and (2) new &OsStr values are produced\n+        // only from ASCII-bounded slices of existing &OsStr values.\n+\n+        let mut iter = os_str_as_u8_slice(file).rsplitn(1, |b| *b == b'.');\n+        let after = iter.next();\n+        let before = iter.next();\n+        if before == Some(b\"\") {\n+            (Some(file), None)\n+        } else {\n+            (before.map(|s| u8_slice_as_os_str(s)),\n+             after.map(|s| u8_slice_as_os_str(s)))\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// The core iterators\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Component parsing works by a double-ended state machine; the cursors at the\n+/// front and back of the path each keep track of what parts of the path have\n+/// been consumed so far.\n+///\n+/// Going front to back, a path is made up of a prefix, a root component, a body\n+/// (of normal components), and a suffix/emptycomponent (normalized `.` or ``\n+/// for a path ending with the separator)\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n+enum State {\n+    Prefix = 0,         // c:\n+    Root = 1,           // /\n+    Body = 2,           // foo/bar/baz\n+    Suffix = 3,         // .\n+    Done = 4,\n+}\n+\n+/// A single component of a path.\n+///\n+/// See the module documentation for an in-depth explanation of components and\n+/// their role in the API.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Component<'a> {\n+    /// A Windows path prefix, e.g. `C:` or `\\server\\share`\n+    Prefix(&'a OsStr),\n+\n+    /// An empty component. Only used on Windows for the last component of\n+    /// verbatim paths ending with a separator (e.g. the last component of\n+    /// `\\\\?\\C:\\windows\\` but not `\\\\?\\C:\\windows` or `C:\\windows`).\n+    Empty,\n+\n+    /// The root directory component, appears after any prefix and before anything else\n+    RootDir,\n+\n+    /// A reference to the current directory, i.e. `.`\n+    CurDir,\n+\n+    /// A reference to the parent directory, i.e. `..`\n+    ParentDir,\n+\n+    /// A normal component, i.e. `a` and `b` in `a/b`\n+    Normal(&'a OsStr),\n+}\n+\n+impl<'a> Component<'a> {\n+    /// Extract the underlying `OsStr` slice\n+    pub fn as_os_str(self) -> &'a OsStr {\n+        match self {\n+            Component::Prefix(path) => path,\n+            Component::Empty => OsStr::from_str(\"\"),\n+            Component::RootDir => OsStr::from_str(MAIN_SEP_STR),\n+            Component::CurDir => OsStr::from_str(\".\"),\n+            Component::ParentDir => OsStr::from_str(\"..\"),\n+            Component::Normal(path) => path,\n+        }\n+    }\n+}\n+\n+/// The core iterator giving the components of a path.\n+///\n+/// See the module documentation for an in-depth explanation of components and\n+/// their role in the API.\n+#[derive(Clone)]\n+pub struct Components<'a> {\n+    // The path left to parse components from\n+    path: &'a [u8],\n+\n+    // The prefix as it was originally parsed, if any\n+    prefix: Option<Prefix<'a>>,\n+\n+    // true if path *physically* has a root separator; for most Windows\n+    // prefixes, it may have a \"logical\" rootseparator for the purposes of\n+    // normalization, e.g.  \\\\server\\share == \\\\server\\share\\.\n+    has_physical_root: bool,\n+\n+    // The iterator is double-ended, and these two states keep track of what has\n+    // been produced from either end\n+    front: State,\n+    back: State,\n+}\n+\n+/// An iterator over the components of a path, as `OsStr` slices.\n+#[derive(Clone)]\n+pub struct Iter<'a> {\n+    inner: Components<'a>\n+}\n+\n+impl<'a> Components<'a> {\n+    // how long is the prefix, if any?\n+    #[inline]\n+    fn prefix_len(&self) -> usize {\n+        self.prefix.as_ref().map(Prefix::len).unwrap_or(0)\n+    }\n+\n+    #[inline]\n+    fn prefix_verbatim(&self) -> bool {\n+        self.prefix.as_ref().map(Prefix::is_verbatim).unwrap_or(false)\n+    }\n+\n+    /// how much of the prefix is left from the point of view of iteration?\n+    #[inline]\n+    fn prefix_remaining(&self) -> usize {\n+        if self.front == State::Prefix { self.prefix_len() }\n+        else { 0 }\n+    }\n+\n+    fn prefix_and_root(&self) -> usize {\n+        let root = if self.front <= State::Root && self.has_physical_root { 1 } else { 0 };\n+        self.prefix_remaining() + root\n+    }\n+\n+    // is the iteration complete?\n+    #[inline]\n+    fn finished(&self) -> bool {\n+        self.front == State::Done || self.back == State::Done || self.front > self.back\n+    }\n+\n+    #[inline]\n+    fn is_sep(&self, b: u8) -> bool {\n+        if self.prefix_verbatim() {\n+            is_verbatim_sep(b)\n+        } else {\n+            is_sep(b)\n+        }\n+    }\n+\n+    /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    pub fn as_path(&self) -> &'a Path {\n+        let mut comps = self.clone();\n+        if comps.front == State::Body { comps.trim_left(); }\n+        if comps.back == State::Body { comps.trim_right(); }\n+        if comps.path.is_empty() && comps.front < comps.back && comps.back == State::Suffix {\n+            Path::new(\".\")\n+        } else {\n+            unsafe { Path::from_u8_slice(comps.path) }\n+        }\n+    }\n+\n+    /// Is the *original* path rooted?\n+    fn has_root(&self) -> bool {\n+        if self.has_physical_root { return true }\n+        if let Some(p) = self.prefix {\n+            if p.has_implicit_root() { return true }\n+        }\n+        false\n+    }\n+\n+    // parse a component from the left, saying how many bytes to consume to\n+    // remove the component\n+    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n+        debug_assert!(self.front == State::Body);\n+        let (extra, comp) = match self.path.iter().position(|b| self.is_sep(*b)) {\n+            None => (0, self.path),\n+            Some(i) => (1, &self.path[.. i]),\n+        };\n+        (comp.len() + extra, parse_single_component(comp))\n+    }\n+\n+    // parse a component from the right, saying how many bytes to consume to\n+    // remove the component\n+    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n+        debug_assert!(self.back == State::Body);\n+        let start = self.prefix_and_root();\n+        let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep(*b)) {\n+            None => (0, &self.path[start ..]),\n+            Some(i) => (1, &self.path[start + i + 1 ..]),\n+        };\n+        (comp.len() + extra, parse_single_component(comp))\n+    }\n+\n+    // trim away repeated separators (i.e. emtpy components) on the left\n+    fn trim_left(&mut self) {\n+        while !self.path.is_empty() {\n+            let (size, comp) = self.parse_next_component();\n+            if comp.is_some() {\n+                return;\n+            } else {\n+                self.path = &self.path[size ..];\n+            }\n+        }\n+    }\n+\n+    // trim away repeated separators (i.e. emtpy components) on the right\n+    fn trim_right(&mut self) {\n+        while self.path.len() > self.prefix_and_root() {\n+            let (size, comp) = self.parse_next_component_back();\n+            if comp.is_some() {\n+                return;\n+            } else {\n+                self.path = &self.path[.. self.path.len() - size];\n+            }\n+        }\n+    }\n+\n+    /// Examine the next component without consuming it.\n+    pub fn peek(&self) -> Option<Component<'a>> {\n+        self.clone().next()\n+    }\n+}\n+\n+impl<'a> Iter<'a> {\n+    /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    pub fn as_path(&self) -> &'a Path {\n+        self.inner.as_path()\n+    }\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = &'a OsStr;\n+\n+    fn next(&mut self) -> Option<&'a OsStr> {\n+        self.inner.next().map(Component::as_os_str)\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator for Iter<'a> {\n+    fn next_back(&mut self) -> Option<&'a OsStr> {\n+        self.inner.next_back().map(Component::as_os_str)\n+    }\n+}\n+\n+impl<'a> Iterator for Components<'a> {\n+    type Item = Component<'a>;\n+\n+    fn next(&mut self) -> Option<Component<'a>> {\n+        while !self.finished() {\n+            match self.front {\n+                State::Prefix if self.prefix_len() > 0 => {\n+                    self.front = State::Root;\n+                    debug_assert!(self.prefix_len() <= self.path.len());\n+                    let prefix = &self.path[.. self.prefix_len()];\n+                    self.path = &self.path[self.prefix_len() .. ];\n+                    return Some(Component::Prefix(unsafe { u8_slice_as_os_str(prefix) }))\n+                }\n+                State::Prefix => {\n+                    self.front = State::Root;\n+                }\n+                State::Root => {\n+                    self.front = State::Body;\n+                    if self.has_physical_root {\n+                        debug_assert!(self.path.len() > 0);\n+                        self.path = &self.path[1..];\n+                        return Some(Component::RootDir)\n+                    } else if let Some(p) = self.prefix {\n+                        if p.has_implicit_root() && !p.is_verbatim() {\n+                            return Some(Component::RootDir)\n+                        }\n+                    }\n+                }\n+                State::Body if !self.path.is_empty() => {\n+                    let (size, comp) = self.parse_next_component();\n+                    self.path = &self.path[size ..];\n+                    if comp.is_some() { return comp }\n+                }\n+                State::Body => {\n+                    self.front = State::Suffix;\n+                }\n+                State::Suffix => {\n+                    self.front = State::Done;\n+                    if self.prefix_verbatim() {\n+                        return Some(Component::Empty)\n+                    } else {\n+                        return Some(Component::CurDir)\n+                    }\n+                }\n+                State::Done => unreachable!()\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator for Components<'a> {\n+    fn next_back(&mut self) -> Option<Component<'a>> {\n+        while !self.finished() {\n+            match self.back {\n+                State::Suffix => {\n+                    self.back = State::Body;\n+                    if self.prefix_verbatim() {\n+                        return Some(Component::Empty)\n+                    } else {\n+                        return Some(Component::CurDir)\n+                    }\n+                }\n+                State::Body if self.path.len() > self.prefix_and_root() => {\n+                    let (size, comp) = self.parse_next_component_back();\n+                    self.path = &self.path[.. self.path.len() - size];\n+                    if comp.is_some() { return comp }\n+                }\n+                State::Body => {\n+                    self.back = State::Root;\n+                }\n+                State::Root => {\n+                    self.back = State::Prefix;\n+                    if self.has_physical_root {\n+                        self.path = &self.path[.. self.path.len() - 1];\n+                        return Some(Component::RootDir)\n+                    } else if let Some(p) = self.prefix {\n+                        if p.has_implicit_root() && !p.is_verbatim() {\n+                            return Some(Component::RootDir)\n+                        }\n+                    }\n+                }\n+                State::Prefix if self.prefix_len() > 0 => {\n+                    self.back = State::Done;\n+                    return Some(Component::Prefix(unsafe {\n+                        u8_slice_as_os_str(self.path)\n+                    }))\n+                }\n+                State::Prefix => {\n+                    self.back = State::Done;\n+                    return None\n+                }\n+                State::Done => unreachable!()\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+fn optional_path(path: &Path) -> Option<&Path> {\n+    if path.as_u8_slice().is_empty() { None } else { Some(path) }\n+}\n+\n+impl<'a> cmp::PartialEq for Components<'a> {\n+    fn eq(&self, other: &Components<'a>) -> bool {\n+        iter::order::eq(self.clone(), other.clone())\n+    }\n+}\n+\n+impl<'a> cmp::Eq for Components<'a> {}\n+\n+impl<'a> cmp::PartialOrd for Components<'a> {\n+    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n+        iter::order::partial_cmp(self.clone(), other.clone())\n+    }\n+}\n+\n+impl<'a> cmp::Ord for Components<'a> {\n+    fn cmp(&self, other: &Components<'a>) -> cmp::Ordering {\n+        iter::order::cmp(self.clone(), other.clone())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic types and traits\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// An owned, mutable path (akin to `String`).\n+///\n+/// This type provides methods like `push` and `set_extension` that mutate the\n+/// path in place. It also implements `Deref` to `Path`, meaning that all\n+/// methods on `Path` slices are available on `PathBuf` values as well.\n+///\n+/// More details about the overall approach can be found in\n+/// the module documentation.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::path::PathBuf;\n+///\n+/// let mut path = PathBuf::new(\"c:\\\\\");\n+/// path.push(\"windows\");\n+/// path.push(\"system32\");\n+/// path.set_extension(\"dll\");\n+/// ```\n+#[derive(Clone, Hash)]\n+pub struct PathBuf {\n+    inner: OsString\n+}\n+\n+impl PathBuf {\n+    fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Allocate a `PathBuf` with initial contents given by the\n+    /// argument.\n+    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> PathBuf {\n+        PathBuf { inner: s.as_os_str().to_os_string() }\n+    }\n+\n+    /// Extend `self` with `path`.\n+    ///\n+    /// If `path` is absolute, it replaces the current path.\n+    ///\n+    /// On Windows:\n+    ///\n+    /// * if `path` has a root but no prefix (e.g. `\\windows`), it\n+    ///   replaces everything except for the prefix (if any) of `self`.\n+    /// * if `path` has a prefix but no root, it replaces `self.\n+    pub fn push<P: ?Sized>(&mut self, path: &P) where P: AsPath {\n+        // in general, a separator is needed if the rightmost byte is not a separator\n+        let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep(*c)).unwrap_or(false);\n+\n+        // in the special case of `C:` on Windows, do *not* add a separator\n+        {\n+            let comps = self.components();\n+            if comps.prefix_len() > 0 &&\n+                comps.prefix_len() == comps.path.len() &&\n+                comps.prefix.unwrap().is_drive()\n+            {\n+                need_sep = false\n+            }\n+        }\n+\n+        let path = path.as_path();\n+\n+        // absolute `path` replaces `self`\n+        if path.is_absolute() || path.prefix().is_some() {\n+            self.as_mut_vec().truncate(0);\n+\n+        // `path` has a root but no prefix, e.g. `\\windows` (Windows only)\n+        } else if path.has_root() {\n+            let prefix_len = self.components().prefix_remaining();\n+            self.as_mut_vec().truncate(prefix_len);\n+\n+        // `path` is a pure relative path\n+        } else if need_sep {\n+            self.inner.push_os_str(OsStr::from_str(MAIN_SEP_STR));\n+        }\n+\n+        self.inner.push_os_str(path.as_os_str());\n+    }\n+\n+    /// Truncate `self` to `self.parent()`.\n+    ///\n+    /// Returns `None` and does nothing if `self.parent()` is `None`.\n+    pub fn pop(&mut self) -> bool {\n+        match self.parent().map(|p| p.as_u8_slice().len()) {\n+            Some(len) => {\n+                self.as_mut_vec().truncate(len);\n+                true\n+            }\n+            None => false\n+        }\n+    }\n+\n+    /// Updates `self.file_name()` to `file_name`.\n+    ///\n+    /// If `self.file_name()` was `None`, this is equivalent to pushing\n+    /// `file_name`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let mut buf = PathBuf::new(\"/foo/\");\n+    /// assert!(buf.file_name() == None);\n+    /// buf.set_file_name(\"bar\");\n+    /// assert!(buf == PathBuf::new(\"/foo/bar\"));\n+    /// assert!(buf.file_name().is_some());\n+    /// buf.set_file_name(\"baz.txt\");\n+    /// assert!(buf == PathBuf::new(\"/foo/baz.txt\"));\n+    /// ```\n+    pub fn set_file_name<S: ?Sized>(&mut self, file_name: &S) where S: AsOsStr {\n+        if self.file_name().is_some() && !self.pop() {\n+            // Given that there is a file name, this is reachable only for\n+            // Windows paths like c:file or paths like `foo`, but not `c:\\` or\n+            // `/`.\n+            let prefix_len = self.components().prefix_remaining();\n+            self.as_mut_vec().truncate(prefix_len);\n+        }\n+        self.push(file_name.as_os_str());\n+    }\n+\n+    /// Updates `self.extension()` to `extension`.\n+    ///\n+    /// If `self.file_name()` is `None`, does nothing and returns `false`.\n+    ///\n+    /// Otherwise, returns `tru`; if `self.exension()` is `None`, the extension\n+    /// is added; otherwise it is replaced.\n+    pub fn set_extension<S: ?Sized + AsOsStr>(&mut self, extension: &S) -> bool {\n+        if self.file_name().is_none() { return false; }\n+\n+        let mut stem = match self.file_stem() {\n+            Some(stem) => stem.to_os_string(),\n+            None => OsString::from_str(\"\"),\n+        };\n+\n+        let extension = extension.as_os_str();\n+        if os_str_as_u8_slice(extension).len() > 0 {\n+            stem.push_os_str(OsStr::from_str(\".\"));\n+            stem.push_os_str(extension.as_os_str());\n+        }\n+        self.set_file_name(&stem);\n+\n+        true\n+    }\n+}\n+\n+impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {\n+    fn from_iter<I: Iterator<Item = &'a P>>(iter: I) -> PathBuf {\n+        let mut buf = PathBuf::new(\"\");\n+        buf.extend(iter);\n+        buf\n+    }\n+}\n+\n+impl<'a, P: ?Sized + 'a> iter::Extend<&'a P> for PathBuf where P: AsPath {\n+    fn extend<I: Iterator<Item = &'a P>>(&mut self, iter: I) {\n+        for p in iter {\n+            self.push(p)\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for PathBuf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt::Debug::fmt(&**self, formatter)\n+    }\n+}\n+\n+impl ops::Deref for PathBuf {\n+    type Target = Path;\n+\n+    fn deref(&self) -> &Path {\n+        unsafe { mem::transmute(&self.inner[]) }\n+    }\n+}\n+\n+impl BorrowFrom<PathBuf> for Path {\n+    fn borrow_from(owned: &PathBuf) -> &Path {\n+        owned.deref()\n+    }\n+}\n+\n+impl cmp::PartialEq for PathBuf {\n+    fn eq(&self, other: &PathBuf) -> bool {\n+        self.components() == other.components()\n+    }\n+}\n+\n+impl cmp::Eq for PathBuf {}\n+\n+impl cmp::PartialOrd for PathBuf {\n+    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n+        self.components().partial_cmp(&other.components())\n+    }\n+}\n+\n+impl cmp::Ord for PathBuf {\n+    fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n+        self.components().cmp(&other.components())\n+    }\n+}\n+\n+/// A slice of a path (akin to `str`).\n+///\n+/// This type supports a number of operations for inspecting a path, including\n+/// breaking the path into its components (separated by `/` or `\\`, depending on\n+/// the platform), extracting the file name, determining whether the path is\n+/// absolute, and so on. More details about the overall approach can be found in\n+/// the module documentation.\n+///\n+/// This is an *unsized* type, meaning that it must always be used with behind a\n+/// pointer like `&` or `Box`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+/// let file = path.file_name();\n+/// let extension = path.extension();\n+/// let parent_dir = path.parent();\n+/// ```\n+///\n+pub struct Path {\n+    inner: OsStr\n+}\n+\n+impl Path {\n+    // The following (private!) function allows construction of a path from a u8\n+    // slice, which is only safe when it is known to follow the OsStr encoding.\n+    unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n+        mem::transmute(s)\n+    }\n+    // The following (private!) function reveals the byte encoding used for OsStr.\n+    fn as_u8_slice(&self) -> &[u8] {\n+        unsafe { mem::transmute(self) }\n+    }\n+\n+    /// Directly wrap a string slice as a `Path` slice.\n+    ///\n+    /// This is a cost-free conversion.\n+    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path {\n+        unsafe { mem::transmute(s.as_os_str()) }\n+    }\n+\n+    /// Yield a `&str` slice if the `Path` is valid unicode.\n+    ///\n+    /// This conversion may entail doing a check for UTF-8 validity.\n+    pub fn to_str(&self) -> Option<&str> {\n+        self.inner.to_str()\n+    }\n+\n+    /// Convert a `Path` to a `CowString`.\n+    ///\n+    /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    pub fn to_string_lossy(&self) -> CowString {\n+        self.inner.to_string_lossy()\n+    }\n+\n+    /// Convert a `Path` to an owned `PathBuf`.\n+    pub fn to_path_buf(&self) -> PathBuf {\n+        PathBuf::new(self)\n+    }\n+\n+    /// A path is *absolute* if it is indepedent of the current directory.\n+    ///\n+    /// * On Unix, a path is absolute if it starts with the root, so\n+    /// `is_absolute` and `has_root` are equivalent.\n+    ///\n+    /// * On Windows, a path is absolute if it has a prefix and starts with the\n+    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n+    /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    pub fn is_absolute(&self) -> bool {\n+        self.has_root() &&\n+            (cfg!(unix) || self.prefix().is_some())\n+    }\n+\n+    /// A path is *relative* if it is not absolute.\n+    pub fn is_relative(&self) -> bool {\n+        !self.is_absolute()\n+    }\n+\n+    /// Returns the *prefix* of a path, if any.\n+    ///\n+    /// Prefixes are relevant only for Windows paths, and consist of volumes\n+    /// like `C:`, UNC prefixes like `\\\\server`, and others described in more\n+    /// detail in `std::os::windows::PathExt`.\n+    pub fn prefix(&self) -> Option<&Path> {\n+        let iter = self.components();\n+        optional_path(unsafe {\n+            Path::from_u8_slice(\n+                &self.as_u8_slice()[.. iter.prefix_remaining()])\n+        })\n+    }\n+\n+    /// A path has a root if the body of the path begins with the directory separator.\n+    ///\n+    /// * On Unix, a path has a root if it begins with `/`.\n+    ///\n+    /// * On Windows, a path has a root if it:\n+    ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n+    ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n+    ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    pub fn has_root(&self) -> bool {\n+         self.components().has_root()\n+    }\n+\n+    /// The path without its final component.\n+    ///\n+    /// Does nothing, returning `None` if the path consists of just a prefix\n+    /// and/or root directory reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/foo/bar\");\n+    /// let foo = path.parent().unwrap();\n+    /// assert!(foo == Path::new(\"/foo\"));\n+    /// let root = foo.parent().unwrap();\n+    /// assert!(root == Path::new(\"/\"));\n+    /// assert!(root.parent() == None);\n+    /// ```\n+    pub fn parent(&self) -> Option<&Path> {\n+        let mut comps = self.components();\n+        let comp = comps.next_back();\n+        let rest = optional_path(comps.as_path());\n+\n+        match (comp, comps.next_back()) {\n+            (Some(Component::CurDir), Some(Component::RootDir)) => None,\n+            (Some(Component::CurDir), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Empty), Some(Component::RootDir)) => None,\n+            (Some(Component::Empty), Some(Component::Prefix(_))) => None,\n+            (Some(Component::Prefix(_)), None) => None,\n+            (Some(Component::RootDir), Some(Component::Prefix(_))) => None,\n+            _ => rest\n+        }\n+    }\n+\n+    /// The final component of the path, if it is a normal file.\n+    ///\n+    /// If the path terminates in `.`, `..`, or consists solely or a root of\n+    /// prefix, `file` will return `None`.\n+    pub fn file_name(&self) -> Option<&OsStr> {\n+        self.components().next_back().and_then(|p| match p {\n+            Component::Normal(p) => Some(p.as_os_str()),\n+            _ => None\n+        })\n+    }\n+\n+    /// Returns a path that, when joined onto `base`, yields `self`.\n+    pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where\n+        P: AsPath\n+    {\n+        iter_after(self.components(), base.as_path().components()).map(|c| c.as_path())\n+    }\n+\n+    /// Determines whether `base` is a prefix of `self`.\n+    pub fn starts_with<P: ?Sized>(&self, base: &P) -> bool where P: AsPath {\n+        iter_after(self.components(), base.as_path().components()).is_some()\n+    }\n+\n+    /// Determines whether `base` is a suffix of `self`.\n+    pub fn ends_with<P: ?Sized>(&self, child: &P) -> bool where P: AsPath {\n+        iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n+    }\n+\n+    /// Extract the stem (non-extension) portion of `self.file()`.\n+    ///\n+    /// The stem is:\n+    ///\n+    /// * None, if there is no file name;\n+    /// * The entire file name if there is no embedded `.`;\n+    /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n+    /// * Otherwise, the portion of the file name before the final `.`\n+    pub fn file_stem(&self) -> Option<&OsStr> {\n+        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n+    }\n+\n+    /// Extract the extension of `self.file()`, if possible.\n+    ///\n+    /// The extension is:\n+    ///\n+    /// * None, if there is no file name;\n+    /// * None, if there is no embedded `.`;\n+    /// * None, if the file name begins with `.` and has no other `.`s within;\n+    /// * Otherwise, the portion of the file name after the final `.`\n+    pub fn extension(&self) -> Option<&OsStr> {\n+        self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n+    }\n+\n+    /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n+    ///\n+    /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    pub fn join<P: ?Sized>(&self, path: &P) -> PathBuf where P: AsPath {\n+        let mut buf = self.to_path_buf();\n+        buf.push(path);\n+        buf\n+    }\n+\n+    /// Creates an owned `PathBuf` like `self` but with the given file name.\n+    ///\n+    /// See `PathBuf::set_file_name` for more details.\n+    pub fn with_file_name<S: ?Sized>(&self, file_name: &S) -> PathBuf where S: AsOsStr {\n+        let mut buf = self.to_path_buf();\n+        buf.set_file_name(file_name);\n+        buf\n+    }\n+\n+    /// Creates an owned `PathBuf` like `self` but with the given extension.\n+    ///\n+    /// See `PathBuf::set_extension` for more details.\n+    pub fn with_extension<S: ?Sized>(&self, extension: &S) -> PathBuf where S: AsOsStr {\n+        let mut buf = self.to_path_buf();\n+        buf.set_extension(extension);\n+        buf\n+    }\n+\n+    /// Produce an iterator over the components of the path.\n+    pub fn components(&self) -> Components {\n+        let prefix = parse_prefix(self.as_os_str());\n+        Components {\n+            path: self.as_u8_slice(),\n+            prefix: prefix,\n+            has_physical_root: has_physical_root(self.as_u8_slice(), prefix),\n+            front: State::Prefix,\n+            back: if has_suffix(self.as_u8_slice(), prefix) { State::Suffix }\n+                  else { State::Body },\n+        }\n+    }\n+\n+    /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    pub fn iter(&self) -> Iter {\n+        Iter { inner: self.components() }\n+    }\n+\n+    /// Returns an object that implements `Display` for safely printing paths\n+    /// that may contain non-Unicode data.\n+    pub fn display(&self) -> Display {\n+        Display { path: self }\n+    }\n+}\n+\n+impl AsOsStr for Path {\n+    fn as_os_str(&self) -> &OsStr {\n+        &self.inner\n+    }\n+}\n+\n+impl fmt::Debug for Path {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        self.inner.fmt(formatter)\n+    }\n+}\n+\n+/// Helper struct for safely printing paths with `format!()` and `{}`\n+pub struct Display<'a> {\n+    path: &'a Path\n+}\n+\n+impl<'a> fmt::Debug for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.path.to_string_lossy(), f)\n+    }\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.path.to_string_lossy(), f)\n+    }\n+}\n+\n+impl cmp::PartialEq for Path {\n+    fn eq(&self, other: &Path) -> bool {\n+        iter::order::eq(self.components(), other.components())\n+    }\n+}\n+\n+impl cmp::Eq for Path {}\n+\n+impl cmp::PartialOrd for Path {\n+    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n+        self.components().partial_cmp(&other.components())\n+    }\n+}\n+\n+impl cmp::Ord for Path {\n+    fn cmp(&self, other: &Path) -> cmp::Ordering {\n+        self.components().cmp(&other.components())\n+    }\n+}\n+\n+/// Freely convertible to a `Path`.\n+pub trait AsPath {\n+    /// Convert to a `Path`.\n+    fn as_path(&self) -> &Path;\n+}\n+\n+impl<T: AsOsStr + ?Sized> AsPath for T {\n+    fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ffi::OsStr;\n+    use core::prelude::*;\n+    use string::{ToString, String};\n+    use vec::Vec;\n+\n+    macro_rules! t(\n+        ($path:expr, iter: $iter:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                // Forward iteration\n+                let comps = path.iter()\n+                    .map(|p| p.to_string_lossy().into_owned())\n+                    .collect::<Vec<String>>();\n+                let exp: &[&str] = &$iter;\n+                let exps = exp.iter().map(|s| s.to_string()).collect::<Vec<String>>();\n+                assert!(comps == exps, \"iter: Expected {:?}, found {:?}\",\n+                        exps, comps);\n+\n+                // Reverse iteration\n+                let comps = Path::new($path).iter().rev()\n+                    .map(|p| p.to_string_lossy().into_owned())\n+                    .collect::<Vec<String>>();\n+                let exps = exps.into_iter().rev().collect::<Vec<String>>();\n+                assert!(comps == exps, \"iter().rev(): Expected {:?}, found {:?}\",\n+                        exps, comps);\n+            }\n+        );\n+\n+        ($path:expr, has_root: $has_root:expr, is_absolute: $is_absolute:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let act_root = path.has_root();\n+                assert!(act_root == $has_root, \"has_root: Expected {:?}, found {:?}\",\n+                        $has_root, act_root);\n+\n+                let act_abs = path.is_absolute();\n+                assert!(act_abs == $is_absolute, \"is_absolute: Expected {:?}, found {:?}\",\n+                        $is_absolute, act_abs);\n+            }\n+        );\n+\n+        ($path:expr, parent: $parent:expr, file_name: $file:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let parent = path.parent().map(|p| p.to_str().unwrap());\n+                let exp_parent: Option<&str> = $parent;\n+                assert!(parent == exp_parent, \"parent: Expected {:?}, found {:?}\",\n+                        exp_parent, parent);\n+\n+                let file = path.file_name().map(|p| p.to_str().unwrap());\n+                let exp_file: Option<&str> = $file;\n+                assert!(file == exp_file, \"file_name: Expected {:?}, found {:?}\",\n+                        exp_file, file);\n+            }\n+        );\n+\n+        ($path:expr, file_stem: $file_stem:expr, extension: $extension:expr) => (\n+            {\n+                let path = Path::new($path);\n+\n+                let stem = path.file_stem().map(|p| p.to_str().unwrap());\n+                let exp_stem: Option<&str> = $file_stem;\n+                assert!(stem == exp_stem, \"file_stem: Expected {:?}, found {:?}\",\n+                        exp_stem, stem);\n+\n+                let ext = path.extension().map(|p| p.to_str().unwrap());\n+                let exp_ext: Option<&str> = $extension;\n+                assert!(ext == exp_ext, \"extension: Expected {:?}, found {:?}\",\n+                        exp_ext, ext);\n+            }\n+        );\n+\n+        ($path:expr, iter: $iter:expr,\n+                     has_root: $has_root:expr, is_absolute: $is_absolute:expr,\n+                     parent: $parent:expr, file_name: $file:expr,\n+                     file_stem: $file_stem:expr, extension: $extension:expr) => (\n+            {\n+                t!($path, iter: $iter);\n+                t!($path, has_root: $has_root, is_absolute: $is_absolute);\n+                t!($path, parent: $parent, file_name: $file);\n+                t!($path, file_stem: $file_stem, extension: $extension);\n+            }\n+        );\n+    );\n+\n+    #[test]\n+    #[cfg(unix)]\n+    pub fn test_decompositions_unix() {\n+        t!(\"\",\n+           iter: [],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo\",\n+           iter: [\"foo\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"/\",\n+           iter: [\"/\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo\",\n+           iter: [\"/\", \"foo\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo/\",\n+           iter: [\"/\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/bar\",\n+           iter: [\"foo\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"/foo/bar\",\n+           iter: [\"/\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"///foo///\",\n+           iter: [\"/\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"///foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"///foo///bar\",\n+           iter: [\"/\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"///foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/..\",\n+           iter: [\"/\", \"..\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"/\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"../\",\n+           iter: [\"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/.\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/..\",\n+           iter: [\"foo\", \"..\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./\",\n+           iter: [\"foo\", \".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./bar\",\n+           iter: [\"foo\", \".\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/../\",\n+           iter: [\"foo\", \"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/../bar\",\n+           iter: [\"foo\", \"..\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./a\",\n+           iter: [\".\", \"a\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\".\",\n+           iter: [\".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"a/b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a//b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/./b\",\n+           iter: [\"a\", \".\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/.\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/b/c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    pub fn test_decompositions_windows() {\n+        t!(\"\",\n+           iter: [],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo\",\n+           iter: [\"foo\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"/\",\n+           iter: [\"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\",\n+           iter: [\"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\",\n+           iter: [\"c:\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"c:/\",\n+           iter: [\"c:\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo\",\n+           iter: [\"\\\\\", \"foo\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/\"),\n+           file_name: Some(\"foo\"),\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/foo/\",\n+           iter: [\"\\\\\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/bar\",\n+           iter: [\"foo\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"/foo/bar\",\n+           iter: [\"\\\\\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"///foo///\",\n+           iter: [\"\\\\\", \"foo\", \".\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"///foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"///foo///bar\",\n+           iter: [\"\\\\\", \"foo\", \"bar\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"///foo\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./.\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"/..\",\n+           iter: [\"\\\\\", \"..\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"/\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"../\",\n+           iter: [\"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/.\",\n+           iter: [\"foo\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/..\",\n+           iter: [\"foo\", \"..\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./\",\n+           iter: [\"foo\", \".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/./bar\",\n+           iter: [\"foo\", \".\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/.\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo/../\",\n+           iter: [\"foo\", \"..\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"foo/../bar\",\n+           iter: [\"foo\", \"..\", \"bar\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"foo/..\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+        t!(\"./a\",\n+           iter: [\".\", \"a\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\".\",\n+           iter: [\".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"./\",\n+           iter: [\".\", \".\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\".\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"a/b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a//b\",\n+           iter: [\"a\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/./b\",\n+           iter: [\"a\", \".\", \"b\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/.\"),\n+           file_name: Some(\"b\"),\n+           file_stem: Some(\"b\"),\n+           extension: None\n+           );\n+\n+        t!(\"a/b/c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a/b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None);\n+\n+        t!(\"a\\\\b\\\\c\",\n+           iter: [\"a\", \"b\", \"c\"],\n+           has_root: false,\n+           is_absolute: false,\n+           parent: Some(\"a\\\\b\"),\n+           file_name: Some(\"c\"),\n+           file_stem: Some(\"c\"),\n+           extension: None\n+           );\n+\n+        t!(\"\\\\a\",\n+           iter: [\"\\\\\", \"a\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"\\\\\"),\n+           file_name: Some(\"a\"),\n+           file_stem: Some(\"a\"),\n+           extension: None\n+           );\n+\n+        t!(\"c:\\\\foo.txt\",\n+           iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"c:\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n+           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\server\\\\share\",\n+           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\server\",\n+           iter: [\"\\\\\", \"server\"],\n+           has_root: true,\n+           is_absolute: false,\n+           parent: Some(\"\\\\\"),\n+           file_name: Some(\"server\"),\n+           file_stem: Some(\"server\"),\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\bar\",\n+           iter: [\"\\\\\\\\?\\\\bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\\",\n+           iter: [\"\\\\\\\\?\\\\\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\UNC\\\\\",\n+           iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n+           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n+           file_name: Some(\"foo.txt\"),\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:\\\\\",\n+           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:\",\n+           iter: [\"\\\\\\\\?\\\\C:\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\foo/bar\",\n+           iter: [\"\\\\\\\\?\\\\foo/bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\?\\\\C:/foo\",\n+           iter: [\"\\\\\\\\?\\\\C:/foo\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n+           file_name: Some(\"bar\"),\n+           file_stem: Some(\"bar\"),\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo/bar\",\n+           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n+           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n+           file_name: Some(\"baz\"),\n+           file_stem: Some(\"baz\"),\n+           extension: None\n+           );\n+\n+\n+        t!(\"\\\\\\\\.\\\\\",\n+           iter: [\"\\\\\\\\.\\\\\", \"\\\\\", \".\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: None,\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n+           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\", \"\"],\n+           has_root: true,\n+           is_absolute: true,\n+           parent: Some(\"\\\\\\\\?\\\\a\\\\b\"),\n+           file_name: None,\n+           file_stem: None,\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    pub fn test_stem_ext() {\n+        t!(\"foo\",\n+           file_stem: Some(\"foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo.\",\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"\")\n+           );\n+\n+        t!(\".foo\",\n+           file_stem: Some(\".foo\"),\n+           extension: None\n+           );\n+\n+        t!(\"foo.txt\",\n+           file_stem: Some(\"foo\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"foo.bar.txt\",\n+           file_stem: Some(\"foo.bar\"),\n+           extension: Some(\"txt\")\n+           );\n+\n+        t!(\"foo.bar.\",\n+           file_stem: Some(\"foo.bar\"),\n+           extension: Some(\"\")\n+           );\n+\n+        t!(\".\",\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"..\",\n+           file_stem: None,\n+           extension: None\n+           );\n+\n+        t!(\"\",\n+           file_stem: None,\n+           extension: None\n+           );\n+    }\n+\n+    #[test]\n+    pub fn test_push() {\n+        macro_rules! tp(\n+            ($path:expr, $push:expr, $expected:expr) => ( {\n+                let mut actual = PathBuf::new($path);\n+                actual.push($push);\n+                assert!(actual.to_str() == Some($expected),\n+                        \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n+                        $push, $path, $expected, actual.to_str().unwrap());\n+            });\n+        );\n+\n+        if cfg!(unix) {\n+            tp!(\"\", \"foo\", \"foo\");\n+            tp!(\"foo\", \"bar\", \"foo/bar\");\n+            tp!(\"foo/\", \"bar\", \"foo/bar\");\n+            tp!(\"foo//\", \"bar\", \"foo//bar\");\n+            tp!(\"foo/.\", \"bar\", \"foo/./bar\");\n+            tp!(\"foo./.\", \"bar\", \"foo././bar\");\n+            tp!(\"foo\", \"\", \"foo/\");\n+            tp!(\"foo\", \".\", \"foo/.\");\n+            tp!(\"foo\", \"..\", \"foo/..\");\n+            tp!(\"foo\", \"/\", \"/\");\n+            tp!(\"/foo/bar\", \"/\", \"/\");\n+            tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n+            tp!(\"/foo/bar\", \"./baz\", \"/foo/bar/./baz\");\n+        } else {\n+            tp!(\"\", \"foo\", \"foo\");\n+            tp!(\"foo\", \"bar\", r\"foo\\bar\");\n+            tp!(\"foo/\", \"bar\", r\"foo/bar\");\n+            tp!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n+            tp!(\"foo//\", \"bar\", r\"foo//bar\");\n+            tp!(r\"foo\\\\\", \"bar\", r\"foo\\\\bar\");\n+            tp!(\"foo/.\", \"bar\", r\"foo/.\\bar\");\n+            tp!(\"foo./.\", \"bar\", r\"foo./.\\bar\");\n+            tp!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n+            tp!(r\"foo.\\.\", \"bar\", r\"foo.\\.\\bar\");\n+            tp!(\"foo\", \"\", \"foo\\\\\");\n+            tp!(\"foo\", \".\", r\"foo\\.\");\n+            tp!(\"foo\", \"..\", r\"foo\\..\");\n+            tp!(\"foo\", \"/\", \"/\");\n+            tp!(\"foo\", r\"\\\", r\"\\\");\n+            tp!(\"/foo/bar\", \"/\", \"/\");\n+            tp!(r\"\\foo\\bar\", r\"\\\", r\"\\\");\n+            tp!(\"/foo/bar\", \"/baz\", \"/baz\");\n+            tp!(\"/foo/bar\", r\"\\baz\", r\"\\baz\");\n+            tp!(\"/foo/bar\", \"./baz\", r\"/foo/bar\\./baz\");\n+            tp!(\"/foo/bar\", r\".\\baz\", r\"/foo/bar\\.\\baz\");\n+\n+            tp!(\"c:\\\\\", \"windows\", \"c:\\\\windows\");\n+            tp!(\"c:\", \"windows\", \"c:windows\");\n+\n+            tp!(\"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n+            tp!(\"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n+            tp!(\"a\\\\b\", \".\", \"a\\\\b\\\\.\");\n+            tp!(\"a\\\\b\", \"..\\\\c\", \"a\\\\b\\\\..\\\\c\");\n+            tp!(\"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n+            tp!(\"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n+            tp!(\"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n+            tp!(\"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:d\");\n+            tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n+            tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n+            tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n+            tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n+\n+            // Note: modified from old path API\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n+\n+            tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+            tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n+            tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n+            // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n+            tp!(\"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n+\n+            tp!(\"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_pop() {\n+        macro_rules! tp(\n+            ($path:expr, $expected:expr, $output:expr) => ( {\n+                let mut actual = PathBuf::new($path);\n+                let output = actual.pop();\n+                assert!(actual.to_str() == Some($expected) && output == $output,\n+                        \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n+                        $path, $expected, $output,\n+                        actual.to_str().unwrap(), output);\n+            });\n+        );\n+\n+        tp!(\"\", \"\", false);\n+        tp!(\"/\", \"/\", false);\n+        tp!(\"foo\", \"foo\", false);\n+        tp!(\".\", \".\", false);\n+        tp!(\"/foo\", \"/\", true);\n+        tp!(\"/foo/bar\", \"/foo\", true);\n+        tp!(\"foo/bar\", \"foo\", true);\n+        tp!(\"foo/.\", \"foo\", true);\n+        tp!(\"foo//bar\", \"foo\", true);\n+\n+        if cfg!(windows) {\n+            tp!(\"a\\\\b\\\\c\", \"a\\\\b\", true);\n+            tp!(\"\\\\a\", \"\\\\\", true);\n+            tp!(\"\\\\\", \"\\\\\", false);\n+\n+            tp!(\"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n+            tp!(\"C:\\\\a\", \"C:\\\\\", true);\n+            tp!(\"C:\\\\\", \"C:\\\\\", false);\n+            tp!(\"C:a\\\\b\", \"C:a\", true);\n+            tp!(\"C:a\", \"C:\", true);\n+            tp!(\"C:\", \"C:\", false);\n+            tp!(\"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", false);\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", false);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n+            tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n+            tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n+            tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n+\n+            tp!(\"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_set_file_name() {\n+        macro_rules! tfn(\n+                ($path:expr, $file:expr, $expected:expr) => ( {\n+                let mut p = PathBuf::new($path);\n+                p.set_file_name($file);\n+                assert!(p.to_str() == Some($expected),\n+                        \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n+                        $path, $file, $expected,\n+                        p.to_str().unwrap());\n+            });\n+        );\n+\n+        tfn!(\"foo\", \"foo\", \"foo\");\n+        tfn!(\"foo\", \"bar\", \"bar\");\n+        tfn!(\"foo\", \"\", \"\");\n+        tfn!(\"\", \"foo\", \"foo\");\n+        if cfg!(unix) {\n+            tfn!(\".\", \"foo\", \"./foo\");\n+            tfn!(\"foo/\", \"bar\", \"foo/bar\");\n+            tfn!(\"foo/.\", \"bar\", \"foo/./bar\");\n+            tfn!(\"..\", \"foo\", \"../foo\");\n+            tfn!(\"foo/..\", \"bar\", \"foo/../bar\");\n+            tfn!(\"/\", \"foo\", \"/foo\");\n+        } else {\n+            tfn!(\".\", \"foo\", r\".\\foo\");\n+            tfn!(r\"foo\\\", \"bar\", r\"foo\\bar\");\n+            tfn!(r\"foo\\.\", \"bar\", r\"foo\\.\\bar\");\n+            tfn!(\"..\", \"foo\", r\"..\\foo\");\n+            tfn!(r\"foo\\..\", \"bar\", r\"foo\\..\\bar\");\n+            tfn!(r\"\\\", \"foo\", r\"\\foo\");\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_set_extension() {\n+        macro_rules! tfe(\n+                ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n+                let mut p = PathBuf::new($path);\n+                let output = p.set_extension($ext);\n+                assert!(p.to_str() == Some($expected) && output == $output,\n+                        \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n+                        $path, $ext, $expected, $output,\n+                        p.to_str().unwrap(), output);\n+            });\n+        );\n+\n+        tfe!(\"foo\", \"txt\", \"foo.txt\", true);\n+        tfe!(\"foo.bar\", \"txt\", \"foo.txt\", true);\n+        tfe!(\"foo.bar.baz\", \"txt\", \"foo.bar.txt\", true);\n+        tfe!(\".test\", \"txt\", \".test.txt\", true);\n+        tfe!(\"foo.txt\", \"\", \"foo\", true);\n+        tfe!(\"foo\", \"\", \"foo\", true);\n+        tfe!(\"\", \"foo\", \"\", false);\n+        tfe!(\".\", \"foo\", \".\", false);\n+        tfe!(\"foo/\", \"bar\", \"foo/\", false);\n+        tfe!(\"foo/.\", \"bar\", \"foo/.\", false);\n+        tfe!(\"..\", \"foo\", \"..\",  false);\n+        tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n+        tfe!(\"/\", \"foo\", \"/\", false);\n+    }\n+\n+    #[test]\n+    pub fn test_compare() {\n+        macro_rules! tc(\n+            ($path1:expr, $path2:expr, eq: $eq:expr,\n+             starts_with: $starts_with:expr, ends_with: $ends_with:expr,\n+             relative_from: $relative_from:expr) => ({\n+                 let path1 = Path::new($path1);\n+                 let path2 = Path::new($path2);\n+\n+                 let eq = path1 == path2;\n+                 assert!(eq == $eq, \"{:?} == {:?}, expected {:?}, got {:?}\",\n+                         $path1, $path2, $eq, eq);\n+\n+                 let starts_with = path1.starts_with(path2);\n+                 assert!(starts_with == $starts_with,\n+                         \"{:?}.starts_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         $starts_with, starts_with);\n+\n+                 let ends_with = path1.ends_with(path2);\n+                 assert!(ends_with == $ends_with,\n+                         \"{:?}.ends_with({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         $ends_with, ends_with);\n+\n+                 let relative_from = path1.relative_from(path2).map(|p| p.to_str().unwrap());\n+                 let exp: Option<&str> = $relative_from;\n+                 assert!(relative_from == exp,\n+                         \"{:?}.relative_from({:?}), expected {:?}, got {:?}\", $path1, $path2,\n+                         exp, relative_from);\n+            });\n+        );\n+\n+        tc!(\"\", \"\",\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n+\n+        tc!(\"foo\", \"\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"foo\")\n+            );\n+\n+        tc!(\"\", \"foo\",\n+            eq: false,\n+            starts_with: false,\n+            ends_with: false,\n+            relative_from: None\n+            );\n+\n+        tc!(\"foo\", \"foo\",\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n+\n+        tc!(\"foo/\", \"foo\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\".\")\n+            );\n+\n+        tc!(\"foo/bar\", \"foo\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\"bar\")\n+            );\n+\n+        tc!(\"foo/bar/baz\", \"foo/bar\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: false,\n+            relative_from: Some(\"baz\")\n+            );\n+\n+        tc!(\"foo/bar\", \"foo/bar/baz\",\n+            eq: false,\n+            starts_with: false,\n+            ends_with: false,\n+            relative_from: None\n+            );\n+\n+        tc!(\"./foo/bar/\", \".\",\n+            eq: false,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"foo/bar/\")\n+            );\n+    }\n+}"}, {"sha": "d2dc33451200f5f866973f03939eecf2523613c5", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -56,7 +56,7 @@\n #[doc(no_inline)] pub use vec::Vec;\n \n // NB: remove when path reform lands\n-#[doc(no_inline)] pub use path::{Path, GenericPath};\n+#[doc(no_inline)] pub use old_path::{Path, GenericPath};\n // NB: remove when I/O reform lands\n #[doc(no_inline)] pub use old_io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n // NB: remove when range syntax lands"}, {"sha": "797b9332f17dc4cfa134e8f1ab48e02bf7cb1e58", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -20,7 +20,7 @@ mod imp {\n     use self::OsRngInner::*;\n \n     use old_io::{IoResult, File};\n-    use path::Path;\n+    use old_path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::Result::Ok;"}, {"sha": "6f6b4c58717482522246ca8864b86d6855540871", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use sys::{last_error, retry};\n use ffi::CString;\n use num::Int;\n-use path::BytesContainer;\n+use old_path::BytesContainer;\n use collections;\n \n pub mod backtrace;"}, {"sha": "50a8e6b73e3866ff2b8d66879f97d3d9bbc20de7", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -143,6 +143,7 @@ extern {\n     pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n \n+    #[cfg(not(target_os = \"ios\"))]\n     pub fn getpwuid_r(uid: libc::uid_t,\n                       pwd: *mut passwd,\n                       buf: *mut libc::c_char,"}, {"sha": "427cf21ac70a9cc86021597c2b5570a755fa0875", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -18,10 +18,11 @@\n use prelude::v1::*;\n \n use ffi;\n-use old_io::{self, IoResult, IoError};\n+use io::ErrorKind;\n use libc;\n use num::{Int, SignedInt};\n use num;\n+use old_io::{self, IoResult, IoError};\n use str;\n use sys_common::mkerr_libc;\n \n@@ -133,6 +134,35 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n     err\n }\n \n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::ECONNRESET => ErrorKind::ConnectionReset,\n+        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n+        libc::EPIPE => ErrorKind::BrokenPipe,\n+        libc::ENOTCONN => ErrorKind::NotConnected,\n+        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::EADDRNOTAVAIL => ErrorKind::ConnectionRefused,\n+        libc::EADDRINUSE => ErrorKind::ConnectionRefused,\n+        libc::ENOENT => ErrorKind::FileNotFound,\n+        libc::EISDIR => ErrorKind::InvalidInput,\n+        libc::EINTR => ErrorKind::Interrupted,\n+        libc::EINVAL => ErrorKind::InvalidInput,\n+        libc::ENOTTY => ErrorKind::MismatchedFileTypeForOperation,\n+        libc::ETIMEDOUT => ErrorKind::TimedOut,\n+        libc::ECANCELED => ErrorKind::TimedOut,\n+        libc::consts::os::posix88::EEXIST => ErrorKind::PathAlreadyExists,\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            ErrorKind::ResourceUnavailable,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n #[inline]\n pub fn retry<T, F> (mut f: F) -> T where\n     T: SignedInt,"}, {"sha": "5004ff713c45f42ffa2d13f3db39194a8b9f8936", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -307,23 +307,23 @@ pub fn args() -> Args {\n     let mut res = Vec::new();\n \n     unsafe {\n-        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n-        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n-        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n-        let countSel = sel_registerName(\"count\\0\".as_ptr());\n-        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+        let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n+        let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n+        let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+        let count_sel = sel_registerName(\"count\\0\".as_ptr());\n+        let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n \n         let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n-        let info = objc_msgSend(klass, processInfoSel);\n-        let args = objc_msgSend(info, argumentsSel);\n+        let info = objc_msgSend(klass, process_info_sel);\n+        let args = objc_msgSend(info, arguments_sel);\n \n-        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        let cnt: int = mem::transmute(objc_msgSend(args, count_sel));\n         for i in range(0, cnt) {\n-            let tmp = objc_msgSend(args, objectAtSel, i);\n+            let tmp = objc_msgSend(args, object_at_sel, i);\n             let utf_c_str: *const libc::c_char =\n-                mem::transmute(objc_msgSend(tmp, utf8Sel));\n-            let bytes = ffi::c_str_to_bytes(&utf_c_str).to_vec();\n-            res.push(OsString::from_vec(bytes))\n+                mem::transmute(objc_msgSend(tmp, utf8_sel));\n+            let bytes = ffi::c_str_to_bytes(&utf_c_str);\n+            res.push(OsString::from_str(str::from_utf8(bytes).unwrap()))\n         }\n     }\n \n@@ -455,9 +455,11 @@ pub fn home_dir() -> Option<Path> {\n         Path::new(os.into_vec())\n     });\n \n-    #[cfg(target_os = \"android\")]\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"ios\"))]\n     unsafe fn fallback() -> Option<OsString> { None }\n-    #[cfg(not(target_os = \"android\"))]\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"ios\")))]\n     unsafe fn fallback() -> Option<OsString> {\n         let mut amt = match libc::sysconf(c::_SC_GETPW_R_SIZE_MAX) {\n             n if n < 0 => 512 as usize,"}, {"sha": "a2c93dea6a4f504283da80a06635a9c99e88d343", "filename": "src/libstd/sys/unix/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos_str.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -20,7 +20,7 @@ use str;\n use string::{String, CowString};\n use mem;\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub struct Buf {\n     pub inner: Vec<u8>\n }"}, {"sha": "20f86227e8eaf291d384ae40a0f34dbb39259e71", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -20,7 +20,7 @@ use old_io::{self, IoResult, IoError, EndOfFile};\n use libc::{self, pid_t, c_void, c_int};\n use mem;\n use os;\n-use path::BytesContainer;\n+use old_path::BytesContainer;\n use ptr;\n use sync::mpsc::{channel, Sender, Receiver};\n use sys::fs::FileDesc;"}, {"sha": "92e309da34bef34029745a3618743be2d7227e0f", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -32,7 +32,7 @@ use libc;\n use mem;\n use ops::Drop;\n use option::Option::{Some};\n-use path::Path;\n+use old_path::Path;\n use ptr;\n use result::Result::{Ok, Err};\n use slice::SliceExt;"}, {"sha": "f1af70e2cf7d1eb341bc87ff5bee89d0133bbca1", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -15,6 +15,7 @@\n use prelude::v1::*;\n \n use ffi::OsStr;\n+use io::ErrorKind;\n use libc;\n use mem;\n use old_io::{self, IoResult, IoError};\n@@ -143,6 +144,34 @@ pub fn decode_error_detailed(errno: i32) -> IoError {\n     err\n }\n \n+pub fn decode_error_kind(errno: i32) -> ErrorKind {\n+    match errno as libc::c_int {\n+        libc::ERROR_ACCESS_DENIED => ErrorKind::PermissionDenied,\n+        libc::ERROR_ALREADY_EXISTS => ErrorKind::PathAlreadyExists,\n+        libc::ERROR_BROKEN_PIPE => ErrorKind::BrokenPipe,\n+        libc::ERROR_FILE_NOT_FOUND => ErrorKind::FileNotFound,\n+        libc::ERROR_INVALID_FUNCTION => ErrorKind::InvalidInput,\n+        libc::ERROR_INVALID_HANDLE => ErrorKind::MismatchedFileTypeForOperation,\n+        libc::ERROR_INVALID_NAME => ErrorKind::InvalidInput,\n+        libc::ERROR_NOTHING_TO_TERMINATE => ErrorKind::InvalidInput,\n+        libc::ERROR_NO_DATA => ErrorKind::BrokenPipe,\n+        libc::ERROR_OPERATION_ABORTED => ErrorKind::TimedOut,\n+\n+        libc::WSAEACCES => ErrorKind::PermissionDenied,\n+        libc::WSAEADDRINUSE => ErrorKind::ConnectionRefused,\n+        libc::WSAEADDRNOTAVAIL => ErrorKind::ConnectionRefused,\n+        libc::WSAECONNABORTED => ErrorKind::ConnectionAborted,\n+        libc::WSAECONNREFUSED => ErrorKind::ConnectionRefused,\n+        libc::WSAECONNRESET => ErrorKind::ConnectionReset,\n+        libc::WSAEINVAL => ErrorKind::InvalidInput,\n+        libc::WSAENOTCONN => ErrorKind::NotConnected,\n+        libc::WSAEWOULDBLOCK => ErrorKind::ResourceUnavailable,\n+\n+        _ => ErrorKind::Other,\n+    }\n+}\n+\n+\n #[inline]\n pub fn retry<I, F>(f: F) -> I where F: FnOnce() -> I { f() } // PR rust-lang/rust/#17020\n "}, {"sha": "af94b56bf1f71aaf39433a4072093ca4ee64475e", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -18,7 +18,7 @@ use result::Result;\n use option::Option;\n use mem;\n \n-#[derive(Clone)]\n+#[derive(Clone, Hash)]\n pub struct Buf {\n     pub inner: Wtf8Buf\n }"}, {"sha": "315c41e779a36c7abfce420642b2cebb1c357a99", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -23,7 +23,7 @@ use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;\n use os;\n-use path::BytesContainer;\n+use old_path::BytesContainer;\n use ptr;\n use str;\n use sync::{StaticMutex, MUTEX_INIT};"}, {"sha": "9de5fd1c770eccafd2d9d140ed67adba3da75aae", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -45,6 +45,7 @@ pub mod scoped;\n \n // Sure wish we had macro hygiene, no?\n #[doc(hidden)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod __impl {\n     pub use super::imp::Key as KeyInner;\n     pub use super::imp::destroy_value;"}, {"sha": "34eeedeaa7650bba3e232b1f6fe901982fb1071e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -48,7 +48,6 @@ pub use self::TraitItem::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n-pub use self::ClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n@@ -736,7 +735,7 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n-    ExprClosure(CaptureClause, Option<ClosureKind>, P<FnDecl>, P<Block>),\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),\n@@ -1687,13 +1686,6 @@ impl ForeignItem_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum ClosureKind {\n-    FnClosureKind,\n-    FnMutClosureKind,\n-    FnOnceClosureKind,\n-}\n-\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans."}, {"sha": "a85b87f47d6ee0d1a9338f262a8344bed2624ff9", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -218,7 +218,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             }\n             ast_map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, _, ref decl, ref block) =>\n+                ast::ExprClosure(_, ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "53c35ef34cd0d4293ed2803b08a26af76a62f710", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -876,14 +876,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)"}, {"sha": "739c73a70b02b1779f81232ded7357b73d0c877d", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -66,7 +66,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     );\n-    let mut rand_call = |&mut: cx: &mut ExtCtxt, span| {\n+    let rand_call = |&: cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             vec!(rng.clone()))"}, {"sha": "77440914342fb2ef4a60710bf3c16376db58934b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -322,11 +322,10 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr_match(span, into_iter_expr, vec![iter_arm])\n         }\n \n-        ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {\n+        ast::ExprClosure(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprClosure(capture_clause,\n-                                            opt_kind,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})"}, {"sha": "d7a51e1149f30b0931636d3e551a0d9e4410d976", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -119,6 +119,9 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n \n     // Allows use of #[staged_api]\n     (\"staged_api\", \"1.0.0\", Active),\n+\n+    // Allows using items which are missing stability attributes\n+    (\"unmarked_api\", \"1.0.0\", Active)\n ];\n \n enum Status {\n@@ -145,6 +148,7 @@ pub struct Features {\n     pub quote: bool,\n     pub old_orphan_check: bool,\n     pub simd_ffi: bool,\n+    pub unmarked_api: bool,\n     pub lib_features: Vec<(InternedString, Span)>\n }\n \n@@ -157,6 +161,7 @@ impl Features {\n             quote: false,\n             old_orphan_check: false,\n             simd_ffi: false,\n+            unmarked_api: false,\n             lib_features: Vec::new()\n         }\n     }\n@@ -566,6 +571,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n         quote: cx.has_feature(\"quote\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n+        unmarked_api: cx.has_feature(\"unmarked_api\"),\n         lib_features: unknown_features\n     }\n }"}, {"sha": "07b6af651f610eec1e10c9744fcd64d725657dfd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1325,9 +1325,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                         arms.move_map(|x| folder.fold_arm(x)),\n                         source)\n             }\n-            ExprClosure(capture_clause, opt_kind, decl, body) => {\n+            ExprClosure(capture_clause, decl, body) => {\n                 ExprClosure(capture_clause,\n-                            opt_kind,\n                             folder.fold_fn_decl(decl),\n                             folder.fold_block(body))\n             }"}, {"sha": "60de6c909b78bfc2d8fb7371bea068650da2a536", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -27,6 +27,7 @@ pub enum ObsoleteSyntax {\n     ProcType,\n     ProcExpr,\n     ClosureType,\n+    ClosureKind,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -65,6 +66,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`|usize| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\"\n             ),\n+            ObsoleteSyntax::ClosureKind => (\n+                \"`:`, `&mut:`, or `&:` syntax\",\n+                \"rely on inference instead\"\n+            ),\n             ObsoleteSyntax::Sized => (\n                 \"`Sized? T` syntax for removing the `Sized` bound\",\n                 \"write `T: ?Sized` instead\""}, {"sha": "2cb265033c399842c6783b9af1e97c7f29f5dc7b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -28,8 +28,6 @@ use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{FnClosureKind, FnMutClosureKind};\n-use ast::{FnOnceClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n@@ -57,7 +55,7 @@ use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef, ClosureKind};\n+use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1139,29 +1137,36 @@ impl<'a> Parser<'a> {\n         TyInfer\n     }\n \n-    /// Parses an optional closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_optional_closure_kind(&mut self) -> Option<ClosureKind> {\n-        if self.check(&token::BinOp(token::And)) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n-                self.look_ahead(2, |t| *t == token::Colon) {\n+    /// Parses an obsolete closure kind (`&:`, `&mut:`, or `:`).\n+    pub fn parse_obsolete_closure_kind(&mut self) {\n+        // let lo = self.span.lo;\n+        if\n+            self.check(&token::BinOp(token::And)) &&\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n+            self.look_ahead(2, |t| *t == token::Colon)\n+        {\n             self.bump();\n             self.bump();\n             self.bump();\n-            return Some(FnMutClosureKind)\n-        }\n-\n-        if self.token == token::BinOp(token::And) &&\n-                    self.look_ahead(1, |t| *t == token::Colon) {\n+        } else if\n+            self.token == token::BinOp(token::And) &&\n+            self.look_ahead(1, |t| *t == token::Colon)\n+        {\n             self.bump();\n             self.bump();\n-            return Some(FnClosureKind)\n-        }\n-\n-        if self.eat(&token::Colon) {\n-            return Some(FnOnceClosureKind)\n+            return;\n+        } else if\n+            self.eat(&token::Colon)\n+        {\n+            /* nothing */\n+        } else {\n+            return;\n         }\n \n-        return None\n+        // SNAP 474b324\n+        // Enable these obsolete errors after snapshot:\n+        // let span = mk_sp(lo, self.span.hi);\n+        // self.obsolete(span, ObsoleteSyntax::ClosureKind);\n     }\n \n     pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n@@ -3047,7 +3052,7 @@ impl<'a> Parser<'a> {\n                              -> P<Expr>\n     {\n         let lo = self.span.lo;\n-        let (decl, optional_closure_kind) = self.parse_fn_block_decl();\n+        let decl = self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n@@ -3060,7 +3065,7 @@ impl<'a> Parser<'a> {\n         self.mk_expr(\n             lo,\n             fakeblock.span.hi,\n-            ExprClosure(capture_clause, optional_closure_kind, decl, fakeblock))\n+            ExprClosure(capture_clause, decl, fakeblock))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {\n@@ -4529,30 +4534,29 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, Option<ClosureKind>) {\n-        let (optional_closure_kind, inputs_captures) = {\n+    fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n+        let inputs_captures = {\n             if self.eat(&token::OrOr) {\n-                (None, Vec::new())\n+                Vec::new()\n             } else {\n                 self.expect(&token::BinOp(token::Or));\n-                let optional_closure_kind =\n-                    self.parse_optional_closure_kind();\n+                self.parse_obsolete_closure_kind();\n                 let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_fn_block_arg()\n                 );\n                 self.bump();\n-                (optional_closure_kind, args)\n+                args\n             }\n         };\n         let output = self.parse_ret_ty();\n \n-        (P(FnDecl {\n+        P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n             variadic: false\n-        }), optional_closure_kind)\n+        })\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure."}, {"sha": "129c1d20bc04c6ecde9bc9bcd8aafe246538688e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -25,7 +25,7 @@ use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n use std::mem;\n use std::ops::Deref;\n-use std::path::BytesContainer;\n+use std::old_path::BytesContainer;\n use std::rc::Rc;\n \n #[allow(non_camel_case_types)]"}, {"sha": "ee8e207fa6c059b909914232d1d501cda015a9f0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -11,11 +11,9 @@\n pub use self::AnnNode::*;\n \n use abi;\n-use ast::{self, FnClosureKind, FnMutClosureKind};\n-use ast::{FnOnceClosureKind};\n+use ast;\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{ClosureKind};\n use ast_util;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -350,7 +348,7 @@ pub fn method_to_string(p: &ast::Method) -> String {\n }\n \n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    $to_string(|s| s.print_fn_block_args(p, None))\n+    $to_string(|s| s.print_fn_block_args(p))\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n@@ -1747,10 +1745,10 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprClosure(capture_clause, opt_kind, ref decl, ref body) => {\n+            ast::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl, opt_kind));\n+                try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n \n                 if !body.stmts.is_empty() || !body.expr.is_some() {\n@@ -2350,16 +2348,9 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_block_args(\n             &mut self,\n-            decl: &ast::FnDecl,\n-            closure_kind: Option<ClosureKind>)\n+            decl: &ast::FnDecl)\n             -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n-        match closure_kind {\n-            None => {}\n-            Some(FnClosureKind) => try!(self.word_space(\"&:\")),\n-            Some(FnMutClosureKind) => try!(self.word_space(\"&mut:\")),\n-            Some(FnOnceClosureKind) => try!(self.word_space(\":\")),\n-        }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n "}, {"sha": "fbcfcaadf12b71c29782e0ae4d5944b92043232a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -836,7 +836,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_arm(arm)\n             }\n         }\n-        ExprClosure(_, _, ref function_declaration, ref body) => {\n+        ExprClosure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FkFnBlock,\n                              &**function_declaration,\n                              &**body,"}, {"sha": "7ac3925fb24766385d7958742fa5dc49d84b44f0", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -11,6 +11,7 @@\n #![crate_type = \"lib\"]\n #![feature(staged_api)]\n #![staged_api]\n+#![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n@@ -31,8 +32,6 @@ pub fn unstable() {}\n #[unstable(feature = \"test_feature\", reason = \"text\")]\n pub fn unstable_text() {}\n \n-pub fn unmarked() {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stable() {}\n #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -61,8 +60,6 @@ impl MethodTester {\n     #[unstable(feature = \"test_feature\", reason = \"text\")]\n     pub fn method_unstable_text(&self) {}\n \n-    pub fn method_unmarked(&self) {}\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn method_stable(&self) {}\n     #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -79,6 +76,7 @@ impl MethodTester {\n     pub fn method_frozen_text(&self) {}\n }\n \n+#[stable(feature = \"test_feature\", since = \"1.0.0\")]\n pub trait Trait {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n     #[deprecated(since = \"1.0.0\")]\n@@ -99,8 +97,6 @@ pub trait Trait {\n     #[unstable(feature = \"test_feature\", reason = \"text\")]\n     fn trait_unstable_text(&self) {}\n \n-    fn trait_unmarked(&self) {}\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trait_stable(&self) {}\n     #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -130,7 +126,6 @@ pub struct DeprecatedStruct { pub i: int }\n pub struct DeprecatedUnstableStruct { pub i: int }\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableStruct { pub i: int }\n-pub struct UnmarkedStruct { pub i: int }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableStruct { pub i: int }\n \n@@ -142,10 +137,10 @@ pub struct DeprecatedUnitStruct;\n pub struct DeprecatedUnstableUnitStruct;\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableUnitStruct;\n-pub struct UnmarkedUnitStruct;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableUnitStruct;\n \n+#[stable(feature = \"test_feature\", since = \"1.0.0\")]\n pub enum Enum {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n     #[deprecated(since = \"1.0.0\")]\n@@ -156,7 +151,6 @@ pub enum Enum {\n     #[unstable(feature = \"test_feature\")]\n     UnstableVariant,\n \n-    UnmarkedVariant,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     StableVariant,\n }\n@@ -169,7 +163,6 @@ pub struct DeprecatedTupleStruct(pub int);\n pub struct DeprecatedUnstableTupleStruct(pub int);\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableTupleStruct(pub int);\n-pub struct UnmarkedTupleStruct(pub int);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableTupleStruct(pub int);\n "}, {"sha": "7033f5caef6c6a22d7e144861dfa008ade2f4815", "filename": "src/test/compile-fail/borrow-immutable-upvar-mutation.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,34 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n // Tests that we can't assign to or mutably borrow upvars from `Fn`\n // closures (issue #17780)\n \n fn set(x: &mut usize) { *x = 5; }\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn main() {\n     // By-ref captures\n     {\n         let mut x = 0us;\n-        let _f = |&:| x = 42; //~ ERROR cannot assign\n+        let _f = to_fn(|| x = 42); //~ ERROR cannot assign\n \n         let mut y = 0us;\n-        let _g = |&:| set(&mut y); //~ ERROR cannot borrow\n+        let _g = to_fn(|| set(&mut y)); //~ ERROR cannot borrow\n \n         let mut z = 0us;\n-        let _h = |&mut:| { set(&mut z); |&:| z = 42; }; //~ ERROR cannot assign\n+        let _h = to_fn_mut(|| { set(&mut z); to_fn(|| z = 42); }); //~ ERROR cannot assign\n     }\n+\n     // By-value captures\n     {\n         let mut x = 0us;\n-        let _f = move |&:| x = 42; //~ ERROR cannot assign\n+        let _f = to_fn(move || x = 42); //~ ERROR cannot assign\n \n         let mut y = 0us;\n-        let _g = move |&:| set(&mut y); //~ ERROR cannot borrow\n+        let _g = to_fn(move || set(&mut y)); //~ ERROR cannot borrow\n \n         let mut z = 0us;\n-        let _h = move |&mut:| { set(&mut z); move |&:| z = 42; }; //~ ERROR cannot assign\n+        let _h = to_fn_mut(move || { set(&mut z); to_fn(move || z = 42); }); //~ ERROR cannot assign\n     }\n }"}, {"sha": "a1708e7f497286c81a4d6007aafb13c7ea4420c0", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax,unboxed_closures)]\n+\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n \n pub fn main() {\n     let bar = box 3;\n-    let _g = |&mut:| {\n-        let _h = move |:| -> isize { *bar }; //~ ERROR cannot move out of captured outer variable\n-    };\n+    let _g = to_fn_mut(|| {\n+        let _h = to_fn_once(move || -> isize { *bar }); //~ ERROR cannot move out of\n+    });\n }"}, {"sha": "738755855c0703211532b79c82ce43e92581bebc", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n     let x = 1;\n-    move|:| { x = 2; };\n+    to_fn_once(move|:| { x = 2; });\n     //~^ ERROR: cannot assign to immutable captured outer variable\n \n     let s = std::old_io::stdin();\n-    move|:| { s.read_to_end(); };\n+    to_fn_once(move|:| { s.read_to_end(); });\n     //~^ ERROR: cannot borrow immutable captured outer variable\n }"}, {"sha": "df4dab2552e7de8922613d5f6a683a4a338778b3", "filename": "src/test/compile-fail/issue-11925.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n+\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n \n fn main() {\n     let r = {\n         let x = box 42;\n-        let f = move|:| &x; //~ ERROR: `x` does not live long enough\n+        let f = to_fn_once(move|| &x); //~ ERROR: `x` does not live long enough\n         f()\n     };\n "}, {"sha": "40d446b91a5a8b659d56cb79dcbec7b202c8249d", "filename": "src/test/compile-fail/issue-12127.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n \n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n fn do_it(x: &isize) { }\n \n fn main() {\n     let x = box 22;\n-    let f = move|:| do_it(&*x);\n-    (move|:| {\n+    let f = to_fn_once(move|| do_it(&*x));\n+    to_fn_once(move|| {\n         f();\n         f();\n         //~^ ERROR: use of moved value: `f`"}, {"sha": "4cf75bf15de275bd44262c8812893786967c4b7f", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -20,7 +20,7 @@\n #![staged_api]\n \n #[macro_use]\n-extern crate lint_stability; //~ ERROR: use of unmarked library feature\n+extern crate lint_stability;\n \n mod cross_crate {\n     extern crate stability_cfg1;\n@@ -61,10 +61,6 @@ mod cross_crate {\n         foo.method_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n         foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n \n-        unmarked(); //~ ERROR use of unmarked library feature\n-        foo.method_unmarked(); //~ ERROR use of unmarked library feature\n-        foo.trait_unmarked(); //~ ERROR use of unmarked library feature\n-\n         stable();\n         foo.method_stable();\n         foo.trait_stable();\n@@ -77,28 +73,24 @@ mod cross_crate {\n         let _ = DeprecatedUnstableStruct { i: 0 }; //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n         let _ = UnstableStruct { i: 0 }; //~ WARNING use of unstable library feature\n-        let _ = UnmarkedStruct { i: 0 }; //~ ERROR use of unmarked library feature\n         let _ = StableStruct { i: 0 };\n \n         let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n         let _ = DeprecatedUnstableUnitStruct; //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n         let _ = UnstableUnitStruct; //~ WARNING use of unstable library feature\n-        let _ = UnmarkedUnitStruct; //~ ERROR use of unmarked library feature\n         let _ = StableUnitStruct;\n \n         let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n         let _ = Enum::DeprecatedUnstableVariant; //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n         let _ = Enum::UnstableVariant; //~ WARNING use of unstable library feature\n-        let _ = Enum::UnmarkedVariant; //~ ERROR use of unmarked library feature\n         let _ = Enum::StableVariant;\n \n         let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n         let _ = DeprecatedUnstableTupleStruct (1); //~ ERROR use of deprecated item\n         //~^ WARNING use of unstable library feature\n         let _ = UnstableTupleStruct (1); //~ WARNING use of unstable library feature\n-        let _ = UnmarkedTupleStruct (1); //~ ERROR use of unmarked library feature\n         let _ = StableTupleStruct (1);\n \n         // At the moment, the lint checker only checks stability in\n@@ -123,7 +115,6 @@ mod cross_crate {\n         //~^ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n         foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n-        foo.trait_unmarked(); //~ ERROR use of unmarked library feature\n         foo.trait_stable();\n     }\n \n@@ -136,7 +127,6 @@ mod cross_crate {\n         //~^ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n         foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n-        foo.trait_unmarked(); //~ ERROR use of unmarked library feature\n         foo.trait_stable();\n     }\n \n@@ -183,8 +173,6 @@ mod this_crate {\n     #[unstable(feature = \"test_feature\", reason = \"text\")]\n     pub fn unstable_text() {}\n \n-    pub fn unmarked() {}\n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stable() {}\n     #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -206,8 +194,6 @@ mod this_crate {\n         #[unstable(feature = \"test_feature\", reason = \"text\")]\n         pub fn method_unstable_text(&self) {}\n \n-        pub fn method_unmarked(&self) {}\n-\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn method_stable(&self) {}\n         #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -227,8 +213,6 @@ mod this_crate {\n         #[unstable(feature = \"test_feature\", reason = \"text\")]\n         fn trait_unstable_text(&self) {}\n \n-        fn trait_unmarked(&self) {}\n-\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         fn trait_stable(&self) {}\n         #[stable(feature = \"rust1\", since = \"1.0.0\", reason = \"text\")]\n@@ -242,7 +226,6 @@ mod this_crate {\n     pub struct DeprecatedStruct { i: isize }\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableStruct { i: isize }\n-    pub struct UnmarkedStruct { i: isize }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableStruct { i: isize }\n \n@@ -251,7 +234,6 @@ mod this_crate {\n     pub struct DeprecatedUnitStruct;\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableUnitStruct;\n-    pub struct UnmarkedUnitStruct;\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableUnitStruct;\n \n@@ -262,7 +244,6 @@ mod this_crate {\n         #[unstable(feature = \"test_feature\")]\n         UnstableVariant,\n \n-        UnmarkedVariant,\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         StableVariant,\n     }\n@@ -272,7 +253,6 @@ mod this_crate {\n     pub struct DeprecatedTupleStruct(isize);\n     #[unstable(feature = \"test_feature\")]\n     pub struct UnstableTupleStruct(isize);\n-    pub struct UnmarkedTupleStruct(isize);\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub struct StableTupleStruct(isize);\n \n@@ -299,10 +279,6 @@ mod this_crate {\n         foo.method_unstable_text();\n         foo.trait_unstable_text();\n \n-        unmarked();\n-        foo.method_unmarked();\n-        foo.trait_unmarked();\n-\n         stable();\n         foo.method_stable();\n         foo.trait_stable();\n@@ -313,22 +289,18 @@ mod this_crate {\n \n         let _ = DeprecatedStruct { i: 0 }; //~ ERROR use of deprecated item\n         let _ = UnstableStruct { i: 0 };\n-        let _ = UnmarkedStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n         let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n         let _ = UnstableUnitStruct;\n-        let _ = UnmarkedUnitStruct;\n         let _ = StableUnitStruct;\n \n         let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n         let _ = Enum::UnstableVariant;\n-        let _ = Enum::UnmarkedVariant;\n         let _ = Enum::StableVariant;\n \n         let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n         let _ = UnstableTupleStruct (1);\n-        let _ = UnmarkedTupleStruct (1);\n         let _ = StableTupleStruct (1);\n     }\n \n@@ -337,7 +309,6 @@ mod this_crate {\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n-        foo.trait_unmarked();\n         foo.trait_stable();\n     }\n \n@@ -346,7 +317,6 @@ mod this_crate {\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n-        foo.trait_unmarked();\n         foo.trait_stable();\n     }\n "}, {"sha": "14dd983161b4a0219a39ed4ea6559414b34dc6ed", "filename": "src/test/compile-fail/missing-stability.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that exported items without stability attributes cause an error\n+\n+#![crate_type=\"lib\"]\n+#![feature(staged_api)]\n+#![staged_api]\n+\n+pub fn unmarked() {\n+    //~^ ERROR This node does not have a stability attribute\n+    ()\n+}\n+\n+#[unstable(feature = \"foo\")]\n+pub mod foo {\n+    // #[unstable] is inherited\n+    pub fn unmarked() {}\n+}\n+\n+#[stable(feature = \"bar\", since=\"1.0.0\")]\n+pub mod bar {\n+    // #[stable] is not inherited\n+    pub fn unmarked() {}\n+    //~^ ERROR This node does not have a stability attribute\n+}\n\\ No newline at end of file"}, {"sha": "4251be36ab43805591025cea7e8a01b83f6294b2", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n \n use std::usize;\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+\n fn test(_x: Box<usize>) {}\n \n fn main() {\n     let i = box 3;\n-    let _f = |&:| test(i); //~ ERROR cannot move out\n+    let _f = to_fn(|| test(i)); //~ ERROR cannot move out\n }"}, {"sha": "78c575d33bad0a932285d3389d7377bf35933bbf", "filename": "src/test/compile-fail/range-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Frange-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Frange-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-3.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -13,4 +13,4 @@\n pub fn main() {\n     let r = 1..2..3;\n     //~^ ERROR expected one of `.`, `;`, or an operator, found `..`\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a3e27fbbe9aa39938935897dd49df88f17858d99", "filename": "src/test/compile-fail/range-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Frange-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Frange-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-4.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -13,4 +13,4 @@\n pub fn main() {\n     let r = ..1..2;\n     //~^ ERROR expected one of `.`, `;`, or an operator, found `..`\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2d559794919817754daa3e1c606253d58c39afd2", "filename": "src/test/compile-fail/unboxed-closer-non-implicit-copyable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -10,8 +10,10 @@\n \n #![feature(unboxed_closures)]\n \n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n-    let f = move|:| ();\n+    let f = to_fn_once(move|| ());\n     f();\n     f(); //~ ERROR use of moved value\n }"}, {"sha": "224cbc2bef3245c624a949cc1e382cd92304417b", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -15,31 +15,35 @@\n // if the upvar is captured by ref or the closure takes self by\n // reference.\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n     // By-ref cases\n     {\n         let x = box 0us;\n-        let f = |&:| drop(x); //~ ERROR cannot move\n+        let f = to_fn(|| drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |&mut:| drop(x); //~ ERROR cannot move\n+        let f = to_fn_mut(|| drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |:| drop(x); // OK -- FnOnce\n+        let f = to_fn_once(|| drop(x)); // OK -- FnOnce\n     }\n     // By-value cases\n     {\n         let x = box 0us;\n-        let f = move |&:| drop(x); //~ ERROR cannot move\n+        let f = to_fn(move || drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |&mut:| drop(x); //~ ERROR cannot move\n+        let f = to_fn_mut(move || drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |:| drop(x); // this one is ok\n+        let f = to_fn_once(move || drop(x)); // this one is ok\n     }\n }"}, {"sha": "650bb17bb7758f9ce60d81d2dcc7ec38ff7cab7b", "filename": "src/test/compile-fail/unboxed-closures-mutate-upvar.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -12,51 +12,56 @@\n // as `mut` through a closure. Also test that we CAN mutate a moved copy,\n // unless this is a `Fn` closure. Issue #16749.\n \n+#![feature(unboxed_closures)]\n+\n use std::mem;\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn a() {\n     let n = 0u8;\n-    let mut f = |&mut:| { //~ ERROR closure cannot assign\n+    let mut f = to_fn_mut(|| { //~ ERROR closure cannot assign\n         n += 1;\n-    };\n+    });\n }\n \n fn b() {\n     let mut n = 0u8;\n-    let mut f = |&mut:| {\n+    let mut f = to_fn_mut(|| {\n         n += 1; // OK\n-    };\n+    });\n }\n \n fn c() {\n     let n = 0u8;\n-    let mut f = move |&mut:| {\n+    let mut f = to_fn_mut(move || {\n         // If we just did a straight-forward desugaring, this would\n         // compile, but we do something a bit more subtle, and hence\n         // we get an error.\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn d() {\n     let mut n = 0u8;\n-    let mut f = move |&mut:| {\n+    let mut f = to_fn_mut(move || {\n         n += 1; // OK\n-    };\n+    });\n }\n \n fn e() {\n     let n = 0u8;\n-    let mut f = move |&:| {\n+    let mut f = to_fn(move || {\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn f() {\n     let mut n = 0u8;\n-    let mut f = move |&:| {\n+    let mut f = to_fn(move || {\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn main() { }"}, {"sha": "f430e9fc7590228fba05867ea5a3e855a85f8188", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -10,8 +10,10 @@\n \n #![feature(unboxed_closures)]\n \n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn main() {\n-    let mut_ = |&mut: x| x;\n+    let mut_ = to_fn_mut(|x| x);\n     mut_.call((0, )); //~ ERROR does not implement any method in scope named `call`\n }\n "}, {"sha": "c2a2e5162ace070a12c18aa6383f7cc9078ab323", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -12,12 +12,14 @@\n \n use std::ops::FnMut;\n \n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn call_it<F:FnMut(isize,isize)->isize>(y: isize, mut f: F) -> isize {\n     f(2, y)\n }\n \n pub fn main() {\n-    let f = |&mut: x: usize, y: isize| -> isize { (x as isize) + y };\n+    let f = to_fn_mut(|x: usize, y: isize| -> isize { (x as isize) + y });\n     let z = call_it(3, f);\n     //~^ ERROR type mismatch\n     //~| ERROR type mismatch"}, {"sha": "2ada0dd22e75f4a160cdbc28aa8972a451b6cac5", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=3b2ed14906fd9f9daa27cc7d1dad263d2f5ff450", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(lang_items, overloaded_calls, unboxed_closures)]\n-\n-fn c<F:Fn(isize, isize) -> isize>(f: F) -> isize {\n-    f(5, 6)\n-}\n-\n-fn main() {\n-    let z: isize = 7;\n-    assert_eq!(c(|&mut: x: isize, y| x + y + z), 10);\n-    //~^ ERROR not implemented\n-    //~| ERROR not implemented\n-}\n-"}, {"sha": "0f6f0ac6ae7566b76fe5742209ae2876f5d95360", "filename": "src/test/debuginfo/associated-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -149,4 +149,4 @@ fn main() {\n     assoc_enum(Enum::Variant2(8i64, 9i32));\n }\n \n-fn zzz() { () }\n\\ No newline at end of file\n+fn zzz() { () }"}, {"sha": "3bd0273216de31e352315a0d7dd93e9dfa7272b5", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n \n-fn foo(i: int) -> int { i + 1 }\n+fn foo(i: isize) -> isize { i + 1 }\n \n fn apply<A, F>(f: F, v: A) -> A where F: FnOnce(A) -> A { f(v) }\n \n pub fn main() {\n-    let f = {|: i| foo(i)};\n+    let f = {|i| foo(i)};\n     assert_eq!(apply(f, 2), 3);\n }"}, {"sha": "b37c71bc326270ba0d745fe883275e2fd44d9f4c", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -11,7 +11,7 @@\n use std::slice::SliceExt;\n use std::old_io::{Command, fs, USER_RWX};\n use std::os;\n-use std::path::BytesContainer;\n+use std::old_path::BytesContainer;\n use std::rand::random;\n \n fn main() {"}, {"sha": "0d85f61e51350d7dbc3715882505ab855f3f3d6e", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -15,8 +14,8 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n \n-use std::path::{Path};\n-use std::path;\n+use std::old_path::{Path};\n+use std::old_path;\n use std::result;\n use std::thunk::Thunk;\n \n@@ -28,7 +27,7 @@ fn tester()\n         result::Result::Ok(\"more blah\".to_string())\n     };\n \n-    let path = path::Path::new(\"blah\");\n+    let path = old_path::Path::new(\"blah\");\n     assert!(loader(&path).is_ok());\n }\n "}, {"sha": "0cd8c13a4e10a60644ec0c80d887de9f236d1919", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -14,9 +14,9 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n \n-struct A { a: Box<int> }\n+struct A { a: Box<isize> }\n \n-fn foo() -> Box<FnMut() -> int + 'static> {\n+fn foo() -> Box<FnMut() -> isize + 'static> {\n     let k = box 22;\n     let _u = A {a: k.clone()};\n     let result  = |&mut:| 22;"}, {"sha": "c6fd55272610957b83f1f05a1c11beb360f4f7f4", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -20,7 +20,7 @@ use std::old_io;\n use std::old_io::fs;\n use std::old_io::Command;\n use std::os;\n-use std::path::Path;\n+use std::old_path::Path;\n \n fn main() {\n     let my_args = os::args();"}, {"sha": "8e3d44df798a7679333ad85536e334b4d73c906c", "filename": "src/test/run-pass/unboxed-closures-zero-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c15d9b2daecdbe32eca894bda40c424798f5a0/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs?ref=d6c15d9b2daecdbe32eca894bda40c424798f5a0", "patch": "@@ -11,7 +11,7 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    let mut zero = |&mut:| {};\n-    let () = zero.call_mut(());\n+    let mut zero = || {};\n+    let () = zero();\n }\n "}]}