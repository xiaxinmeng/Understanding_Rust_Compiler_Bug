{"sha": "c0eb9384af9f623563df59a9ae454ffedea1f4f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZWI5Mzg0YWY5ZjYyMzU2M2RmNTlhOWFlNDU0ZmZlZGVhMWY0Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-22T03:38:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-22T03:38:20Z"}, "message": "Auto merge of #24674 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "aaa36f5462dfe299902c6829795a8a8988f3061e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaa36f5462dfe299902c6829795a8a8988f3061e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0eb9384af9f623563df59a9ae454ffedea1f4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0eb9384af9f623563df59a9ae454ffedea1f4f8", "html_url": "https://github.com/rust-lang/rust/commit/c0eb9384af9f623563df59a9ae454ffedea1f4f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0eb9384af9f623563df59a9ae454ffedea1f4f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2baf3482537f5a245a9c17ca730398f1a8b001d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2baf3482537f5a245a9c17ca730398f1a8b001d7", "html_url": "https://github.com/rust-lang/rust/commit/2baf3482537f5a245a9c17ca730398f1a8b001d7"}, {"sha": "58150640254e939519e57bf643af841cc60c1ac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/58150640254e939519e57bf643af841cc60c1ac3", "html_url": "https://github.com/rust-lang/rust/commit/58150640254e939519e57bf643af841cc60c1ac3"}], "stats": {"total": 10883, "additions": 2574, "deletions": 8309}, "files": [{"sha": "d25f98321423516d173fa26a88f99d4e3f9678d5", "filename": "mk/main.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,12 +13,12 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.0.0\n+CFG_RELEASE_NUM=1.1.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n # versions (section 9)\n-CFG_PRERELEASE_VERSION=.3\n+CFG_PRERELEASE_VERSION=.1\n \n CFG_FILENAME_EXTRA=4e7c5e5c\n "}, {"sha": "01ef88dde227024c54e050e502f4ed06577025f3", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -24,13 +24,15 @@ is the first. After this:\n * [Syntax and Semantics][ss] - Each bit of Rust, broken down into small chunks.\n * [Nightly Rust][nr] - Cutting-edge features that aren\u2019t in stable builds yet.\n * [Glossary][gl] - A reference of terms used in the book.\n+* [Academic Research][ar] - Literature that influenced Rust.\n \n [gs]: getting-started.html\n [lr]: learn-rust.html\n [er]: effective-rust.html\n [ss]: syntax-and-semantics.html\n [nr]: nightly-rust.html\n [gl]: glossary.html\n+[ar]: academic-research.html\n \n After reading this introduction, you\u2019ll want to dive into either \u2018Learn Rust\u2019\n or \u2018Syntax and Semantics\u2019, depending on your preference: \u2018Learn Rust\u2019 if you"}, {"sha": "81a550b0f9a3d7734c49fbd817ea9ad987e0bc22", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -55,6 +55,7 @@\n     * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n     * [Raw Pointers](raw-pointers.md)\n+    * [`unsafe`](unsafe.md)\n * [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)"}, {"sha": "55e2787cc2591032f349e564f06f9bd84e88779f", "filename": "src/doc/trpl/associated-types.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-types.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,8 +1,8 @@\n % Associated Types\n \n-Associated types are a powerful part of Rust's type system. They're related to\n-the idea of a 'type family', in other words, grouping multiple types together. That\n-description is a bit abstract, so let's dive right into an example. If you want\n+Associated types are a powerful part of Rust\u2019s type system. They\u2019re related to\n+the idea of a \u2018type family\u2019, in other words, grouping multiple types together. That\n+description is a bit abstract, so let\u2019s dive right into an example. If you want\n to write a `Graph` trait, you have two types to be generic over: the node type\n and the edge type. So you might write a trait, `Graph<N, E>`, that looks like\n this:\n@@ -48,11 +48,11 @@ fn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n \n No need to deal with the `E`dge type here!\n \n-Let's go over all this in more detail.\n+Let\u2019s go over all this in more detail.\n \n ## Defining associated types\n \n-Let's build that `Graph` trait. Here's the definition:\n+Let\u2019s build that `Graph` trait. Here\u2019s the definition:\n \n ```rust\n trait Graph {\n@@ -86,7 +86,7 @@ trait Graph {\n ## Implementing associated types\n \n Just like any trait, traits that use associated types use the `impl` keyword to\n-provide implementations. Here's a simple implementation of Graph:\n+provide implementations. Here\u2019s a simple implementation of Graph:\n \n ```rust\n # trait Graph {\n@@ -118,13 +118,13 @@ impl Graph for MyGraph {\n This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n gives you an idea of how to implement this kind of thing. We first need three\n `struct`s, one for the graph, one for the node, and one for the edge. If it made\n-more sense to use a different type, that would work as well, we're just going to\n+more sense to use a different type, that would work as well, we\u2019re just going to\n use `struct`s for all three here.\n \n Next is the `impl` line, which is just like implementing any other trait.\n \n From here, we use `=` to define our associated types. The name the trait uses\n-goes on the left of the `=`, and the concrete type we're `impl`ementing this\n+goes on the left of the `=`, and the concrete type we\u2019re `impl`ementing this\n for goes on the right. Finally, we use the concrete types in our function\n declarations.\n "}, {"sha": "f0c673b561a0ee2f662fd6f0a67b02c8a7eebff2", "filename": "src/doc/trpl/casting-between-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -33,7 +33,7 @@ let b = a as u32; // four eights makes 32\n \n It\u2019s a \u2018non-scalar cast\u2019 because we have multiple values here: the four\n elements of the array. These kinds of casts are very dangerous, because they\n-make assumptions about the way that multiple underlying strucutres are\n+make assumptions about the way that multiple underlying structures are\n implemented. For this, we need something more dangerous.\n \n # `transmute`\n@@ -59,7 +59,7 @@ unsafe {\n }\n ```\n \n-We have to wrap the operation in an `unsafe` block, but this will compile\n+We have to wrap the operation in an `unsafe` block for this to compile\n successfully. Technically, only the `mem::transmute` call itself needs to be in\n the block, but it's nice in this case to enclose everything related, so you\n know where to look. In this case, the details about `a` are also important, and"}, {"sha": "604dcb739df63812f18e56600fd1978bddc991b8", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,9 +1,9 @@\n % Closures\n \n Rust not only has named functions, but anonymous functions as well. Anonymous\n-functions that have an associated environment are called 'closures', because they\n+functions that have an associated environment are called \u2018closures\u2019, because they\n close over an environment. Rust has a really great implementation of them, as\n-we'll see.\n+we\u2019ll see.\n \n # Syntax\n \n@@ -15,7 +15,7 @@ let plus_one = |x: i32| x + 1;\n assert_eq!(2, plus_one(1));\n ```\n \n-We create a binding, `plus_one`, and assign it to a closure. The closure's\n+We create a binding, `plus_one`, and assign it to a closure. The closure\u2019s\n arguments go between the pipes (`|`), and the body is an expression, in this\n case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line\n closures too:\n@@ -33,7 +33,7 @@ let plus_two = |x| {\n assert_eq!(4, plus_two(2));\n ```\n \n-You'll notice a few things about closures that are a bit different than regular\n+You\u2019ll notice a few things about closures that are a bit different than regular\n functions defined with `fn`. The first of which is that we did not need to\n annotate the types of arguments the closure takes or the values it returns. We\n can:\n@@ -44,13 +44,13 @@ let plus_one = |x: i32| -> i32 { x + 1 };\n assert_eq!(2, plus_one(1));\n ```\n \n-But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.\n+But we don\u2019t have to. Why is this? Basically, it was chosen for ergonomic reasons.\n While specifying the full type for named functions is helpful with things like\n documentation and type inference, the types of closures are rarely documented\n since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n that inferring named function types can.\n \n-The second is that the syntax is similar, but a bit different. I've added spaces\n+The second is that the syntax is similar, but a bit different. I\u2019ve added spaces\n here to make them look a little closer:\n \n ```rust\n@@ -59,11 +59,11 @@ let plus_one_v2 = |x: i32 | -> i32 { x + 1 };\n let plus_one_v3 = |x: i32 |          x + 1  ;\n ```\n \n-Small differences, but they're similar in ways.\n+Small differences, but they\u2019re similar in ways.\n \n # Closures and their environment\n \n-Closures are called such because they 'close over their environment.' It\n+Closures are called such because they \u2018close over their environment\u2019. It\n looks like this:\n \n ```rust\n@@ -105,7 +105,7 @@ fn main() {\n ^\n ```\n \n-A verbose yet helpful error message! As it says, we can't take a mutable borrow\n+A verbose yet helpful error message! As it says, we can\u2019t take a mutable borrow\n on `num` because the closure is already borrowing it. If we let the closure go\n out of scope, we can:\n \n@@ -140,7 +140,7 @@ let takes_nums = || nums;\n ```\n \n `Vec<T>` has ownership over its contents, and therefore, when we refer to it\n-in our closure, we have to take ownership of `nums`. It's the same as if we'd\n+in our closure, we have to take ownership of `nums`. It\u2019s the same as if we\u2019d\n passed `nums` to a function that took ownership of it.\n \n ## `move` closures\n@@ -156,7 +156,7 @@ let owns_num = move |x: i32| x + num;\n \n Now, even though the keyword is `move`, the variables follow normal move semantics.\n In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy\n-of `num`. So what's the difference?\n+of `num`. So what\u2019s the difference?\n \n ```rust\n let mut num = 5;\n@@ -171,11 +171,11 @@ assert_eq!(10, num);\n ```\n \n So in this case, our closure took a mutable reference to `num`, and then when\n-we called `add_num`, it mutated the underlying value, as we'd expect. We also\n+we called `add_num`, it mutated the underlying value, as we\u2019d expect. We also\n needed to declare `add_num` as `mut` too, because we\u2019re mutating its\n environment.\n \n-If we change to a `move` closure, it's different:\n+If we change to a `move` closure, it\u2019s different:\n \n ```rust\n let mut num = 5;\n@@ -203,8 +203,8 @@ you tons of control over what your code does, and closures are no different.\n \n # Closure implementation\n \n-Rust's implementation of closures is a bit different than other languages. They\n-are effectively syntax sugar for traits. You'll want to make sure to have read\n+Rust\u2019s implementation of closures is a bit different than other languages. They\n+are effectively syntax sugar for traits. You\u2019ll want to make sure to have read\n the [traits chapter][traits] before this one, as well as the chapter on [trait\n objects][trait-objects].\n \n@@ -237,9 +237,9 @@ pub trait FnOnce<Args> {\n # }\n ```\n \n-You'll notice a few differences between these traits, but a big one is `self`:\n+You\u2019ll notice a few differences between these traits, but a big one is `self`:\n `Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This\n-covers all three kinds of `self` via the usual method call syntax. But we've\n+covers all three kinds of `self` via the usual method call syntax. But we\u2019ve\n split them up into three traits, rather than having a single one. This gives us\n a large amount of control over what kind of closures we can take.\n \n@@ -253,7 +253,7 @@ Now that we know that closures are traits, we already know how to accept and\n return closures: just like any other trait!\n \n This also means that we can choose static vs dynamic dispatch as well. First,\n-let's write a function which takes something callable, calls it, and returns\n+let\u2019s write a function which takes something callable, calls it, and returns\n the result:\n \n ```rust\n@@ -271,7 +271,7 @@ assert_eq!(3, answer);\n We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n suggests: it calls the closure, giving it `1` as an argument.\n \n-Let's examine the signature of `call_with_one` in more depth:\n+Let\u2019s examine the signature of `call_with_one` in more depth:\n \n ```rust\n fn call_with_one<F>(some_closure: F) -> i32\n@@ -280,7 +280,7 @@ fn call_with_one<F>(some_closure: F) -> i32\n ```\n \n We take one parameter, and it has the type `F`. We also return a `i32`. This part\n-isn't interesting. The next part is:\n+isn\u2019t interesting. The next part is:\n \n ```rust\n # fn call_with_one<F>(some_closure: F) -> i32\n@@ -292,9 +292,9 @@ Because `Fn` is a trait, we can bound our generic with it. In this case, our clo\n takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n is `Fn(i32) -> i32`.\n \n-There's one other key point here: because we're bounding a generic with a\n-trait, this will get monomorphized, and therefore, we'll be doing static\n-dispatch into the closure. That's pretty neat. In many langauges, closures are\n+There\u2019s one other key point here: because we\u2019re bounding a generic with a\n+trait, this will get monomorphized, and therefore, we\u2019ll be doing static\n+dispatch into the closure. That\u2019s pretty neat. In many langauges, closures are\n inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n we can stack allocate our closure environment, and statically dispatch the\n call. This happens quite often with iterators and their adapters, which often\n@@ -320,7 +320,7 @@ to our closure when we pass it to `call_with_one`, so we use `&||`.\n \n It\u2019s very common for functional-style code to return closures in various\n situations. If you try to return a closure, you may run into an error. At\n-first, it may seem strange, but we'll figure it out. Here's how you'd probably\n+first, it may seem strange, but we\u2019ll figure it out. Here\u2019s how you\u2019d probably\n try to return a closure from a function:\n \n ```rust,ignore\n@@ -361,7 +361,7 @@ In order to return something from a function, Rust needs to know what\n size the return type is. But since `Fn` is a trait, it could be various\n things of various sizes: many different types can implement `Fn`. An easy\n way to give something a size is to take a reference to it, as references\n-have a known size. So we'd write this:\n+have a known size. So we\u2019d write this:\n \n ```rust,ignore\n fn factory() -> &(Fn(i32) -> Vec<i32>) {\n@@ -385,7 +385,7 @@ fn factory() -> &(Fn(i32) -> i32) {\n ```\n \n Right. Because we have a reference, we need to give it a lifetime. But\n-our `factory()` function takes no arguments, so elision doesn't kick in\n+our `factory()` function takes no arguments, so elision doesn\u2019t kick in\n here. What lifetime can we choose? `'static`:\n \n ```rust,ignore\n@@ -414,15 +414,15 @@ error: mismatched types:\n \n ```\n \n-This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,\n+This error is letting us know that we don\u2019t have a `&'static Fn(i32) -> i32`,\n we have a `[closure <anon>:7:9: 7:20]`. Wait, what?\n \n Because each closure generates its own environment `struct` and implementation\n of `Fn` and friends, these types are anonymous. They exist just solely for\n this closure. So Rust shows them as `closure <anon>`, rather than some\n autogenerated name.\n \n-But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,\n+But why doesn\u2019t our closure implement `&'static Fn`? Well, as we discussed before,\n closures borrow their environment. And in this case, our environment is based\n on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime\n of the stack frame. So if we returned this closure, the function call would be\n@@ -445,7 +445,7 @@ assert_eq!(6, answer);\n # }\n ```\n \n-We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:\n+We use a trait object, by `Box`ing up the `Fn`. There\u2019s just one last problem:\n \n ```text\n error: `num` does not live long enough\n@@ -471,5 +471,5 @@ assert_eq!(6, answer);\n ```\n \n By making the inner closure a `move Fn`, we create a new stack frame for our\n-closure. By `Box`ing it up, we've given it a known size, and allowing it to\n+closure. By `Box`ing it up, we\u2019ve given it a known size, and allowing it to\n escape our stack frame."}, {"sha": "3ab3401e61264d046ddb81a3b8449d796a43e8da", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,27 +1,27 @@\n % Crates and Modules\n \n-When a project starts getting large, it's considered good software\n+When a project starts getting large, it\u2019s considered good software\n engineering practice to split it up into a bunch of smaller pieces, and then\n-fit them together. It's also important to have a well-defined interface, so\n+fit them together. It\u2019s also important to have a well-defined interface, so\n that some of your functionality is private, and some is public. To facilitate\n these kinds of things, Rust has a module system.\n \n # Basic terminology: Crates and Modules\n \n-Rust has two distinct terms that relate to the module system: *crate* and\n-*module*. A crate is synonymous with a *library* or *package* in other\n-languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n+Rust has two distinct terms that relate to the module system: \u2018crate\u2019 and\n+\u2018module\u2019. A crate is synonymous with a \u2018library\u2019 or \u2018package\u2019 in other\n+languages. Hence \u201cCargo\u201d as the name of Rust\u2019s package management tool: you\n ship your crates to others with Cargo. Crates can produce an executable or a\n library, depending on the project.\n \n Each crate has an implicit *root module* that contains the code for that crate.\n You can then define a tree of sub-modules under that root module. Modules allow\n you to partition your code within the crate itself.\n \n-As an example, let's make a *phrases* crate, which will give us various phrases\n-in different languages. To keep things simple, we'll stick to \"greetings\" and\n-\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n-two languages for those phrases to be in. We'll use this module layout:\n+As an example, let\u2019s make a *phrases* crate, which will give us various phrases\n+in different languages. To keep things simple, we\u2019ll stick to \u2018greetings\u2019 and\n+\u2018farewells\u2019 as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n+two languages for those phrases to be in. We\u2019ll use this module layout:\n \n ```text\n                                     +-----------+\n@@ -47,7 +47,7 @@ In this example, `phrases` is the name of our crate. All of the rest are\n modules.  You can see that they form a tree, branching out from the crate\n *root*, which is the root of the tree: `phrases` itself.\n \n-Now that we have a plan, let's define these modules in code. To start,\n+Now that we have a plan, let\u2019s define these modules in code. To start,\n generate a new crate with Cargo:\n \n ```bash\n@@ -72,7 +72,7 @@ above.\n \n # Defining Modules\n \n-To define each of our modules, we use the `mod` keyword. Let's make our\n+To define each of our modules, we use the `mod` keyword. Let\u2019s make our\n `src/lib.rs` look like this:\n \n ```\n@@ -101,7 +101,7 @@ Within a given `mod`, you can declare sub-`mod`s. We can refer to sub-modules\n with double-colon (`::`) notation: our four nested modules are\n `english::greetings`, `english::farewells`, `japanese::greetings`, and\n `japanese::farewells`. Because these sub-modules are namespaced under their\n-parent module, the names don't conflict: `english::greetings` and\n+parent module, the names don\u2019t conflict: `english::greetings` and\n `japanese::greetings` are distinct, even though their names are both\n `greetings`.\n \n@@ -116,11 +116,11 @@ build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native\n ```\n \n `libphrase-hash.rlib` is the compiled crate. Before we see how to use this\n-crate from another crate, let's break it up into multiple files.\n+crate from another crate, let\u2019s break it up into multiple files.\n \n # Multiple file crates\n \n-If each crate were just one file, these files would get very large. It's often\n+If each crate were just one file, these files would get very large. It\u2019s often\n easier to split up crates into multiple files, and Rust supports this in two\n ways.\n \n@@ -141,7 +141,7 @@ mod english;\n If we do that, Rust will expect to find either a `english.rs` file, or a\n `english/mod.rs` file with the contents of our module.\n \n-Note that in these files, you don't need to re-declare the module: that's\n+Note that in these files, you don\u2019t need to re-declare the module: that\u2019s\n already been done with the initial `mod` declaration.\n \n Using these two techniques, we can break up our crate into two directories and\n@@ -180,7 +180,7 @@ mod japanese;\n \n These two declarations tell Rust to look for either `src/english.rs` and\n `src/japanese.rs`, or `src/english/mod.rs` and `src/japanese/mod.rs`, depending\n-on our preference. In this case, because our modules have sub-modules, we've\n+on our preference. In this case, because our modules have sub-modules, we\u2019ve\n chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n@@ -192,11 +192,11 @@ mod farewells;\n Again, these declarations tell Rust to look for either\n `src/english/greetings.rs` and `src/japanese/greetings.rs` or\n `src/english/farewells/mod.rs` and `src/japanese/farewells/mod.rs`. Because\n-these sub-modules don't have their own sub-modules, we've chosen to make them\n+these sub-modules don\u2019t have their own sub-modules, we\u2019ve chosen to make them\n `src/english/greetings.rs` and `src/japanese/farewells.rs`. Whew!\n \n The contents of `src/english/greetings.rs` and `src/japanese/farewells.rs` are\n-both empty at the moment. Let's add some functions.\n+both empty at the moment. Let\u2019s add some functions.\n \n Put this in `src/english/greetings.rs`:\n \n@@ -223,7 +223,7 @@ fn hello() -> String {\n ```\n \n Of course, you can copy and paste this from this web page, or just type\n-something else. It's not important that you actually put \"konnichiwa\" to learn\n+something else. It\u2019s not important that you actually put \u2018konnichiwa\u2019 to learn\n about the module system.\n \n Put this in `src/japanese/farewells.rs`:\n@@ -234,17 +234,17 @@ fn goodbye() -> String {\n }\n ```\n \n-(This is \"Say\u014dnara\", if you're curious.)\n+(This is \u2018Say\u014dnara\u2019, if you\u2019re curious.)\n \n-Now that we have some functionality in our crate, let's try to use it from\n+Now that we have some functionality in our crate, let\u2019s try to use it from\n another crate.\n \n # Importing External Crates\n \n-We have a library crate. Let's make an executable crate that imports and uses\n+We have a library crate. Let\u2019s make an executable crate that imports and uses\n our library.\n \n-Make a `src/main.rs` and put this in it (it won't quite compile yet):\n+Make a `src/main.rs` and put this in it (it won\u2019t quite compile yet):\n \n ```rust,ignore\n extern crate phrases;\n@@ -259,18 +259,18 @@ fn main() {\n ```\n \n The `extern crate` declaration tells Rust that we need to compile and link to\n-the `phrases` crate. We can then use `phrases`' modules in this one. As we\n+the `phrases` crate. We can then use `phrases`\u2019 modules in this one. As we\n mentioned earlier, you can use double colons to refer to sub-modules and the\n functions inside of them.\n \n Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n rather than a library crate. Our package now has two crates: `src/lib.rs` and\n `src/main.rs`. This pattern is quite common for executable crates: most\n functionality is in a library crate, and the executable crate uses that\n-library. This way, other programs can also use the library crate, and it's also\n+library. This way, other programs can also use the library crate, and it\u2019s also\n a nice separation of concerns.\n \n-This doesn't quite work yet, though. We get four errors that look similar to\n+This doesn\u2019t quite work yet, though. We get four errors that look similar to\n this:\n \n ```bash\n@@ -287,14 +287,14 @@ note: in expansion of format_args!\n phrases/src/main.rs:4:5: 4:76 note: expansion site\n ```\n \n-By default, everything is private in Rust. Let's talk about this in some more\n+By default, everything is private in Rust. Let\u2019s talk about this in some more\n depth.\n \n # Exporting a Public Interface\n \n Rust allows you to precisely control which aspects of your interface are\n public, and so private is the default. To make things public, you use the `pub`\n-keyword. Let's focus on the `english` module first, so let's reduce our `src/main.rs`\n+keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n to just this:\n \n ```{rust,ignore}\n@@ -306,21 +306,21 @@ fn main() {\n }\n ```\n \n-In our `src/lib.rs`, let's add `pub` to the `english` module declaration:\n+In our `src/lib.rs`, let\u2019s add `pub` to the `english` module declaration:\n \n ```{rust,ignore}\n pub mod english;\n mod japanese;\n ```\n \n-And in our `src/english/mod.rs`, let's make both `pub`:\n+And in our `src/english/mod.rs`, let\u2019s make both `pub`:\n \n ```{rust,ignore}\n pub mod greetings;\n pub mod farewells;\n ```\n \n-In our `src/english/greetings.rs`, let's add `pub` to our `fn` declaration:\n+In our `src/english/greetings.rs`, let\u2019s add `pub` to our `fn` declaration:\n \n ```{rust,ignore}\n pub fn hello() -> String {\n@@ -358,12 +358,12 @@ Goodbye in English: Goodbye.\n Now that our functions are public, we can use them. Great! However, typing out\n `phrases::english::greetings::hello()` is very long and repetitive. Rust has\n another keyword for importing names into the current scope, so that you can\n-refer to them with shorter names. Let's talk about `use`.\n+refer to them with shorter names. Let\u2019s talk about `use`.\n \n # Importing Modules with `use`\n \n Rust has a `use` keyword, which allows us to import names into our local scope.\n-Let's change our `src/main.rs` to look like this:\n+Let\u2019s change our `src/main.rs` to look like this:\n \n ```{rust,ignore}\n extern crate phrases;\n@@ -378,7 +378,7 @@ fn main() {\n ```\n \n The two `use` lines import each module into the local scope, so we can refer to\n-the functions by a much shorter name. By convention, when importing functions, it's\n+the functions by a much shorter name. By convention, when importing functions, it\u2019s\n considered best practice to import the module, rather than the function directly. In\n other words, you _can_ do this:\n \n@@ -395,7 +395,7 @@ fn main() {\n ```\n \n But it is not idiomatic. This is significantly more likely to introduce a\n-naming conflict. In our short program, it's not a big deal, but as it grows, it\n+naming conflict. In our short program, it\u2019s not a big deal, but as it grows, it\n becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n this:\n@@ -423,7 +423,7 @@ error: aborting due to previous error\n Could not compile `phrases`.\n ```\n \n-If we're importing multiple names from the same module, we don't have to type it out\n+If we\u2019re importing multiple names from the same module, we don\u2019t have to type it out\n twice. Instead of this:\n \n ```{rust,ignore}\n@@ -439,11 +439,11 @@ use phrases::english::{greetings, farewells};\n \n ## Re-exporting with `pub use`\n \n-You don't just use `use` to shorten identifiers. You can also use it inside of your crate\n+You don\u2019t just use `use` to shorten identifiers. You can also use it inside of your crate\n to re-export a function inside another module. This allows you to present an external\n interface that may not directly map to your internal code organization.\n \n-Let's look at an example. Modify your `src/main.rs` to read like this:\n+Let\u2019s look at an example. Modify your `src/main.rs` to read like this:\n \n ```{rust,ignore}\n extern crate phrases;\n@@ -494,11 +494,11 @@ mod farewells;\n ```\n \n The `pub use` declaration brings the function into scope at this part of our\n-module hierarchy. Because we've `pub use`d this inside of our `japanese`\n+module hierarchy. Because we\u2019ve `pub use`d this inside of our `japanese`\n module, we now have a `phrases::japanese::hello()` function and a\n `phrases::japanese::goodbye()` function, even though the code for them lives in\n `phrases::japanese::greetings::hello()` and\n-`phrases::japanese::farewells::goodbye()`. Our internal organization doesn't\n+`phrases::japanese::farewells::goodbye()`. Our internal organization doesn\u2019t\n define our external interface.\n \n Here we have a `pub use` for each function we want to bring into the\n@@ -507,13 +507,13 @@ everything from `greetings` into the current scope: `pub use self::greetings::*`\n \n What about the `self`? Well, by default, `use` declarations are absolute paths,\n starting from your crate root. `self` makes that path relative to your current\n-place in the hierarchy instead. There's one more special form of `use`: you can\n+place in the hierarchy instead. There\u2019s one more special form of `use`: you can\n `use super::` to reach one level up the tree from your current location. Some\n-people like to think of `self` as `.` and `super` as `..`, from many shells'\n+people like to think of `self` as `.` and `super` as `..`, from many shells\u2019\n display for the current directory and the parent directory.\n \n Outside of `use`, paths are relative: `foo::bar()` refers to a function inside\n-of `foo` relative to where we are. If that's prefixed with `::`, as in\n+of `foo` relative to where we are. If that\u2019s prefixed with `::`, as in\n `::foo::bar()`, it refers to a different `foo`, an absolute path from your\n crate root.\n "}, {"sha": "9fa870ab1ac7cf27796ffc56f77121e5cd3e15bf", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,20 +1,20 @@\n % Macros\n \n-By now you've learned about many of the tools Rust provides for abstracting and\n+By now you\u2019ve learned about many of the tools Rust provides for abstracting and\n reusing code. These units of code reuse have a rich semantic structure. For\n example, functions have a type signature, type parameters have trait bounds,\n and overloaded functions must belong to a particular trait.\n \n-This structure means that Rust's core abstractions have powerful compile-time\n+This structure means that Rust\u2019s core abstractions have powerful compile-time\n correctness checking. But this comes at the price of reduced flexibility. If\n-you visually identify a pattern of repeated code, you may find it's difficult\n+you visually identify a pattern of repeated code, you may find it\u2019s difficult\n or cumbersome to express that pattern as a generic function, a trait, or\n-anything else within Rust's semantics.\n+anything else within Rust\u2019s semantics.\n \n-Macros allow us to abstract at a *syntactic* level. A macro invocation is\n+Macros allow us to abstract at a syntactic level. A macro invocation is\n shorthand for an \"expanded\" syntactic form. This expansion happens early in\n compilation, before any static checking. As a result, macros can capture many\n-patterns of code reuse that Rust's core abstractions cannot.\n+patterns of code reuse that Rust\u2019s core abstractions cannot.\n \n The drawback is that macro-based code can be harder to understand, because\n fewer of the built-in rules apply. Like an ordinary function, a well-behaved\n@@ -23,8 +23,8 @@ difficult to design a well-behaved macro!  Additionally, compiler errors in\n macro code are harder to interpret, because they describe problems in the\n expanded code, not the source-level form that developers use.\n \n-These drawbacks make macros something of a \"feature of last resort\". That's not\n-to say that macros are bad; they are part of Rust because sometimes they're\n+These drawbacks make macros something of a \"feature of last resort\". That\u2019s not\n+to say that macros are bad; they are part of Rust because sometimes they\u2019re\n needed for truly concise, well-abstracted code. Just keep this tradeoff in\n mind.\n \n@@ -40,7 +40,7 @@ let x: Vec<u32> = vec![1, 2, 3];\n # assert_eq!(x, [1, 2, 3]);\n ```\n \n-This can't be an ordinary function, because it takes any number of arguments.\n+This can\u2019t be an ordinary function, because it takes any number of arguments.\n But we can imagine it as syntactic shorthand for\n \n ```rust\n@@ -77,20 +77,20 @@ macro_rules! vec {\n # }\n ```\n \n-Whoa, that's a lot of new syntax! Let's break it down.\n+Whoa, that\u2019s a lot of new syntax! Let\u2019s break it down.\n \n ```ignore\n macro_rules! vec { ... }\n ```\n \n-This says we're defining a macro named `vec`, much as `fn vec` would define a\n-function named `vec`. In prose, we informally write a macro's name with an\n+This says we\u2019re defining a macro named `vec`, much as `fn vec` would define a\n+function named `vec`. In prose, we informally write a macro\u2019s name with an\n exclamation point, e.g. `vec!`. The exclamation point is part of the invocation\n syntax and serves to distinguish a macro from an ordinary function.\n \n ## Matching\n \n-The macro is defined through a series of *rules*, which are pattern-matching\n+The macro is defined through a series of rules, which are pattern-matching\n cases. Above, we had\n \n ```ignore\n@@ -99,13 +99,13 @@ cases. Above, we had\n \n This is like a `match` expression arm, but the matching happens on Rust syntax\n trees, at compile time. The semicolon is optional on the last (here, only)\n-case. The \"pattern\" on the left-hand side of `=>` is known as a *matcher*.\n+case. The \"pattern\" on the left-hand side of `=>` is known as a \u2018matcher\u2019.\n These have [their own little grammar] within the language.\n \n [their own little grammar]: ../reference.html#macros\n \n The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n-to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;\n+to the \u2018metavariable\u2019 `$x`. The identifier `expr` is a \u2018fragment specifier\u2019;\n the full possibilities are enumerated in the [advanced macros chapter][].\n Surrounding the matcher with `$(...),*` will match zero or more expressions,\n separated by commas.\n@@ -158,8 +158,8 @@ Each matched expression `$x` will produce a single `push` statement in the\n macro expansion. The repetition in the expansion proceeds in \"lockstep\" with\n repetition in the matcher (more on this in a moment).\n \n-Because `$x` was already declared as matching an expression, we don't repeat\n-`:expr` on the right-hand side. Also, we don't include a separating comma as\n+Because `$x` was already declared as matching an expression, we don\u2019t repeat\n+`:expr` on the right-hand side. Also, we don\u2019t include a separating comma as\n part of the repetition operator. Instead, we have a terminating semicolon\n within the repeated block.\n \n@@ -180,7 +180,7 @@ The outer braces are part of the syntax of `macro_rules!`. In fact, you can use\n The inner braces are part of the expanded syntax. Remember, the `vec!` macro is\n used in an expression context. To write an expression with multiple statements,\n including `let`-bindings, we use a block. If your macro expands to a single\n-expression, you don't need this extra layer of braces.\n+expression, you don\u2019t need this extra layer of braces.\n \n Note that we never *declared* that the macro produces an expression. In fact,\n this is not determined until we use the macro as an expression. With care, you\n@@ -194,7 +194,7 @@ The repetition operator follows two principal rules:\n 1. `$(...)*` walks through one \"layer\" of repetitions, for all of the `$name`s\n    it contains, in lockstep, and\n 2. each `$name` must be under at least as many `$(...)*`s as it was matched\n-   against. If it is under more, it'll be duplicated, as appropriate.\n+   against. If it is under more, it\u2019ll be duplicated, as appropriate.\n \n This baroque macro illustrates the duplication of variables from outer\n repetition levels.\n@@ -219,7 +219,7 @@ fn main() {\n }\n ```\n \n-That's most of the matcher syntax. These examples use `$(...)*`, which is a\n+That\u2019s most of the matcher syntax. These examples use `$(...)*`, which is a\n \"zero or more\" match. Alternatively you can write `$(...)+` for a \"one or\n more\" match. Both forms optionally include a separator, which can be any token\n except `+` or `*`.\n@@ -244,9 +244,9 @@ int main() {\n ```\n \n After expansion we have `5 * 2 + 3`, and multiplication has greater precedence\n-than addition. If you've used C macros a lot, you probably know the standard\n+than addition. If you\u2019ve used C macros a lot, you probably know the standard\n idioms for avoiding this problem, as well as five or six others. In Rust, we\n-don't have to worry about it.\n+don\u2019t have to worry about it.\n \n ```rust\n macro_rules! five_times {\n@@ -261,8 +261,8 @@ fn main() {\n The metavariable `$x` is parsed as a single expression node, and keeps its\n place in the syntax tree even after substitution.\n \n-Another common problem in macro systems is *variable capture*. Here's a C\n-macro, using [a GNU C extension] to emulate Rust's expression blocks.\n+Another common problem in macro systems is \u2018variable capture\u2019. Here\u2019s a C\n+macro, using [a GNU C extension] to emulate Rust\u2019s expression blocks.\n \n [a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n \n@@ -275,7 +275,7 @@ macro, using [a GNU C extension] to emulate Rust's expression blocks.\n })\n ```\n \n-Here's a simple use case that goes terribly wrong:\n+Here\u2019s a simple use case that goes terribly wrong:\n \n ```text\n const char *state = \"reticulating splines\";\n@@ -315,10 +315,10 @@ fn main() {\n ```\n \n This works because Rust has a [hygienic macro system][]. Each macro expansion\n-happens in a distinct *syntax context*, and each variable is tagged with the\n-syntax context where it was introduced. It's as though the variable `state`\n+happens in a distinct \u2018syntax context\u2019, and each variable is tagged with the\n+syntax context where it was introduced. It\u2019s as though the variable `state`\n inside `main` is painted a different \"color\" from the variable `state` inside\n-the macro, and therefore they don't conflict.\n+the macro, and therefore they don\u2019t conflict.\n \n [hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro\n \n@@ -336,7 +336,7 @@ fn main() {\n }\n ```\n \n-Instead you need to pass the variable name into the invocation, so it's tagged\n+Instead you need to pass the variable name into the invocation, so it\u2019s tagged\n with the right syntax context.\n \n ```rust\n@@ -368,7 +368,7 @@ fn main() {\n \n # Recursive macros\n \n-A macro's expansion can include more macro invocations, including invocations\n+A macro\u2019s expansion can include more macro invocations, including invocations\n of the very same macro being expanded.  These recursive macros are useful for\n processing tree-structured input, as illustrated by this (simplistic) HTML\n shorthand:\n@@ -429,7 +429,7 @@ they are unstable and require feature gates.\n Even when Rust code contains un-expanded macros, it can be parsed as a full\n [syntax tree][ast]. This property can be very useful for editors and other\n tools that process code. It also has a few consequences for the design of\n-Rust's macro system.\n+Rust\u2019s macro system.\n \n [ast]: glossary.html#abstract-syntax-tree\n \n@@ -454,13 +454,13 @@ consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n must be balanced within a macro invocation. For example, `foo!([)` is\n forbidden. This allows Rust to know where the macro invocation ends.\n \n-More formally, the macro invocation body must be a sequence of *token trees*.\n+More formally, the macro invocation body must be a sequence of \u2018token trees\u2019.\n A token tree is defined recursively as either\n \n * a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n * any other single token.\n \n-Within a matcher, each metavariable has a *fragment specifier*, identifying\n+Within a matcher, each metavariable has a \u2018fragment specifier\u2019, identifying\n which syntactic form it matches.\n \n * `ident`: an identifier. Examples: `x`; `foo`.\n@@ -482,7 +482,7 @@ There are additional rules regarding the next token after a metavariable:\n * `pat` variables must be followed by one of: `=> , =`\n * Other variables may be followed by any token.\n \n-These rules provide some flexibility for Rust's syntax to evolve without\n+These rules provide some flexibility for Rust\u2019s syntax to evolve without\n breaking existing macros.\n \n The macro system does not deal with parse ambiguity at all. For example, the\n@@ -500,16 +500,16 @@ One downside is that scoping works differently for macros, compared to other\n constructs in the language.\n \n Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n+lexical-order traversal of a crate\u2019s source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n A macro defined within the body of a single `fn`, or anywhere else not at\n module scope, is visible only within that item.\n \n If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n+parent module after the child\u2019s `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent\u2019s `mod`\n item, and so forth.\n \n The `macro_use` attribute can also appear on `extern crate`. In this context\n@@ -524,7 +524,7 @@ If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n defined with the `#[macro_export]` attribute may be loaded.\n \n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+To load a crate\u2019s macros without linking it into the output, use `#[no_link]`\n as well.\n \n An example:\n@@ -619,12 +619,12 @@ only appear at the root of your crate, not inside `mod`. This ensures that\n \n The introductory chapter mentioned recursive macros, but it did not give the\n full story. Recursive macros are useful for another reason: Each recursive\n-invocation gives you another opportunity to pattern-match the macro's\n+invocation gives you another opportunity to pattern-match the macro\u2019s\n arguments.\n \n As an extreme example, it is possible, though hardly advisable, to implement\n the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n-within Rust's macro system.\n+within Rust\u2019s macro system.\n \n ```rust\n macro_rules! bct {\n@@ -765,9 +765,9 @@ as `unimplemented!` until you\u2019re ready to write them.\n \n # Procedural macros\n \n-If Rust's macro system can't do what you need, you may want to write a\n+If Rust\u2019s macro system can\u2019t do what you need, you may want to write a\n [compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason.\n+extension plugins are sometimes called \u2018procedural macros\u2019 for this reason."}, {"sha": "e4af03869d1d85e2c9e0c976b900f9acb0715a21", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -168,6 +168,7 @@ like arrays:\n ```rust\n let a = [0, 1, 2, 3, 4];\n let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n+let complete = &a[..]; // A slice containing all of the elements in a\n ```\n \n Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover"}, {"sha": "fcf928e427c254c1792705d061215e73bc06ad4e", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -87,3 +87,33 @@ fn main() {\n     point.y = 6; // this causes an error\n }\n ```\n+\n+# Update syntax\n+\n+A `struct` can include `..` to indicate that you want to use a copy of some\n+other struct for some of the values. For example:\n+\n+```rust\n+struct Point3d {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+\n+let mut point = Point3d { x: 0, y: 0, z: 0 };\n+point = Point3d { y: 1, .. point };\n+```\n+\n+This gives `point` a new `y`, but keeps the old `x` and `z` values. It doesn\u2019t\n+have to be the same `struct` either, you can use this syntax when making new\n+ones, and it will copy the values you don\u2019t specify:\n+\n+```rust\n+# struct Point3d {\n+#     x: i32,\n+#     y: i32,\n+#     z: i32,\n+# }\n+let origin = Point3d { x: 0, y: 0, z: 0 };\n+let point = Point3d { z: 1, x: 2, .. origin };\n+```"}, {"sha": "52f8cb335a93a0c8eb92953a2432a836320c2755", "filename": "src/doc/trpl/trait-objects.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,15 +1,15 @@\n % Trait Objects\n \n When code involves polymorphism, there needs to be a mechanism to determine\n-which specific version is actually run. This is called 'dispatch.' There are\n+which specific version is actually run. This is called \u2018dispatch\u2019. There are\n two major forms of dispatch: static dispatch and dynamic dispatch. While Rust\n favors static dispatch, it also supports dynamic dispatch through a mechanism\n-called 'trait objects.'\n+called \u2018trait objects\u2019.\n \n ## Background\n \n-For the rest of this chapter, we'll need a trait and some implementations.\n-Let's make a simple one, `Foo`. It has one method that is expected to return a\n+For the rest of this chapter, we\u2019ll need a trait and some implementations.\n+Let\u2019s make a simple one, `Foo`. It has one method that is expected to return a\n `String`.\n \n ```rust\n@@ -18,7 +18,7 @@ trait Foo {\n }\n ```\n \n-We'll also implement this trait for `u8` and `String`:\n+We\u2019ll also implement this trait for `u8` and `String`:\n \n ```rust\n # trait Foo { fn method(&self) -> String; }\n@@ -53,7 +53,7 @@ fn main() {\n }\n ```\n \n-Rust uses 'monomorphization' to perform static dispatch here. This means that\n+Rust uses \u2018monomorphization\u2019 to perform static dispatch here. This means that\n Rust will create a special version of `do_something()` for both `u8` and\n `String`, and then replace the call sites with calls to these specialized\n functions. In other words, Rust generates something like this:\n@@ -82,7 +82,7 @@ fn main() {\n This has a great upside: static dispatch allows function calls to be\n inlined because the callee is known at compile time, and inlining is\n the key to good optimization. Static dispatch is fast, but it comes at\n-a tradeoff: 'code bloat', due to many copies of the same function\n+a tradeoff: \u2018code bloat\u2019, due to many copies of the same function\n existing in the binary, one for each type.\n \n Furthermore, compilers aren\u2019t perfect and may \u201coptimize\u201d code to become slower.\n@@ -99,7 +99,7 @@ reason.\n \n ## Dynamic dispatch\n \n-Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n+Rust provides dynamic dispatch through a feature called \u2018trait objects\u2019. Trait\n objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n *any* type that implements the given trait, where the precise type can only be\n known at runtime.\n@@ -109,12 +109,12 @@ implements the trait by *casting* it (e.g. `&x as &Foo`) or *coercing* it\n (e.g. using `&x` as an argument to a function that takes `&Foo`).\n \n These trait object coercions and casts also work for pointers like `&mut T` to\n-`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n+`&mut Foo` and `Box<T>` to `Box<Foo>`, but that\u2019s all at the moment. Coercions\n and casts are identical.\n \n-This operation can be seen as \"erasing\" the compiler's knowledge about the\n+This operation can be seen as \u2018erasing\u2019 the compiler\u2019s knowledge about the\n specific type of the pointer, and hence trait objects are sometimes referred to\n-as \"type erasure\".\n+as \u2018type erasure\u2019.\n \n Coming back to the example above, we can use the same trait to perform dynamic\n dispatch with trait objects by casting:\n@@ -167,7 +167,7 @@ on the heap to store it.\n \n For `Foo`, we would need to have a value that could be at least either a\n `String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n-dependent crates may implement `Foo` (any number of bytes at all). There's no\n+dependent crates may implement `Foo` (any number of bytes at all). There\u2019s no\n way to guarantee that this last point can work if the values are stored without\n a pointer, because those other types can be arbitrarily large.\n \n@@ -177,14 +177,14 @@ when we are tossing a trait object around, only the size of the pointer itself.\n ### Representation\n \n The methods of the trait can be called on a trait object via a special record\n-of function pointers traditionally called a 'vtable' (created and managed by\n+of function pointers traditionally called a \u2018vtable\u2019 (created and managed by\n the compiler).\n \n Trait objects are both simple and complicated: their core representation and\n layout is quite straight-forward, but there are some curly error messages and\n surprising behaviors to discover.\n \n-Let's start simple, with the runtime representation of a trait object. The\n+Let\u2019s start simple, with the runtime representation of a trait object. The\n `std::raw` module contains structs with layouts that are the same as the\n complicated built-in types, [including trait objects][stdraw]:\n \n@@ -199,20 +199,20 @@ pub struct TraitObject {\n \n [stdraw]: ../std/raw/struct.TraitObject.html\n \n-That is, a trait object like `&Foo` consists of a \"data\" pointer and a \"vtable\"\n+That is, a trait object like `&Foo` consists of a \u2018data\u2019 pointer and a \u2018vtable\u2019\n pointer.\n \n The data pointer addresses the data (of some unknown type `T`) that the trait\n-object is storing, and the vtable pointer points to the vtable (\"virtual method\n-table\") corresponding to the implementation of `Foo` for `T`.\n+object is storing, and the vtable pointer points to the vtable (\u2018virtual method\n+table\u2019) corresponding to the implementation of `Foo` for `T`.\n \n \n A vtable is essentially a struct of function pointers, pointing to the concrete\n piece of machine code for each method in the implementation. A method call like\n `trait_object.method()` will retrieve the correct pointer out of the vtable and\n then do a dynamic call of it. For example:\n \n-```{rust,ignore}\n+```rust,ignore\n struct FooVtable {\n     destructor: fn(*mut ()),\n     size: usize,\n@@ -261,7 +261,7 @@ static Foo_for_String_vtable: FooVtable = FooVtable {\n ```\n \n The `destructor` field in each vtable points to a function that will clean up\n-any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n+any resources of the vtable\u2019s type, for `u8` it is trivial, but for `String` it\n will free the memory. This is necessary for owning trait objects like\n `Box<Foo>`, which need to clean-up both the `Box` allocation as well as the\n internal type when they go out of scope. The `size` and `align` fields store\n@@ -270,11 +270,11 @@ essentially unused at the moment since the information is embedded in the\n destructor, but will be used in the future, as trait objects are progressively\n made more flexible.\n \n-Suppose we've got some values that implement `Foo`, then the explicit form of\n+Suppose we\u2019ve got some values that implement `Foo`, then the explicit form of\n construction and use of `Foo` trait objects might look a bit like (ignoring the\n-type mismatches: they're all just pointers anyway):\n+type mismatches: they\u2019re all just pointers anyway):\n \n-```{rust,ignore}\n+```rust,ignore\n let a: String = \"foo\".to_string();\n let x: u8 = 1;\n "}, {"sha": "3e77d3c603bac90909a481f68df961c545b4f566", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -336,7 +336,7 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-# Default methods\n+## Default methods\n \n There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:"}, {"sha": "bdaef70711ae418990568151a86fa624d00f135a", "filename": "src/doc/trpl/tuple-structs.md", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuple-structs.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,16 +1,20 @@\n % Tuple Structs\n \n-Rust has another data type that's like a hybrid between a tuple and a struct,\n-called a *tuple struct*. Tuple structs do have a name, but their fields don't:\n+Rust has another data type that's like a hybrid between a [tuple][tuple] and a\n+[struct][struct], called a \u2018tuple struct\u2019. Tuple structs have a name, but\n+their fields don\u2019t:\n \n-```{rust}\n+```rust\n struct Color(i32, i32, i32);\n struct Point(i32, i32, i32);\n ```\n \n+[tuple]: primitive-types.html#tuples\n+[struct]: structs.html\n+\n These two will not be equal, even if they have the same values:\n \n-```{rust}\n+```rust\n # struct Color(i32, i32, i32);\n # struct Point(i32, i32, i32);\n let black = Color(0, 0, 0);\n@@ -20,7 +24,7 @@ let origin = Point(0, 0, 0);\n It is almost always better to use a struct than a tuple struct. We would write\n `Color` and `Point` like this instead:\n \n-```{rust}\n+```rust\n struct Color {\n     red: i32,\n     blue: i32,\n@@ -37,12 +41,12 @@ struct Point {\n Now, we have actual names, rather than positions. Good names are important,\n and with a struct, we have actual names.\n \n-There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this the *newtype* pattern, because\n+There _is_ one case when a tuple struct is very useful, though, and that\u2019s a\n+tuple struct with only one element. We call this the \u2018newtype\u2019 pattern, because\n it allows you to create a new type, distinct from that of its contained value\n and expressing its own semantic meaning:\n \n-```{rust}\n+```rust\n struct Inches(i32);\n \n let length = Inches(10);\n@@ -52,5 +56,5 @@ println!(\"length is {} inches\", integer_length);\n ```\n \n As you can see here, you can extract the inner integer type through a\n-destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n+destructuring `let`, as we discussed previously in \u2018tuples\u2019. In this case, the\n `let Inches(integer_length)` assigns `10` to `integer_length`."}, {"sha": "7fe9a1fd27e8e9af544a8266b5af7b38c0d8951e", "filename": "src/doc/trpl/unsafe.md", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1,4 +1,4 @@\n-% Unsafe Code\n+% Unsafe\n \n Rust\u2019s main draw is its powerful static guarantees about behavior. But safety\n checks are conservative by nature: there are some programs that are actually\n@@ -76,7 +76,7 @@ behaviors that are certainly bad, but are expressly _not_ unsafe:\n * Integer overflow\n \n Rust cannot prevent all kinds of software problems. Buggy code can and will be\n-written in Rust. These things arne\u2019t great, but they don\u2019t qualify as `unsafe`\n+written in Rust. These things aren\u2019t great, but they don\u2019t qualify as `unsafe`\n specifically.\n \n # Unsafe Superpowers", "previous_filename": "src/doc/trpl/unsafe-code.md"}, {"sha": "fe9feb3538d15493fb8f425743b053dd4d84058a", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -46,13 +46,8 @@ def run(args):\n \n f.write(\"\\n\")\n \n-version = run([llconfig, '--version']).strip()\n-\n # LLVM libs\n-if version < '3.5':\n-    args = [llconfig, '--libs']\n-else:\n-    args = [llconfig, '--libs', '--system-libs']\n+args = [llconfig, '--libs', '--system-libs']\n \n args.extend(components)\n out = run(args)\n@@ -73,11 +68,6 @@ def run(args):\n         f.write(\", kind = \\\"static\\\"\")\n     f.write(\")]\\n\")\n \n-# llvm-config before 3.5 didn't have a system-libs flag\n-if version < '3.5':\n-    if os == 'win32':\n-        f.write(\"#[link(name = \\\"imagehlp\\\")]\")\n-\n # LLVM ldflags\n out = run([llconfig, '--ldflags'])\n for lib in out.strip().split(' '):"}, {"sha": "554ca3ea539cbb9b1acf96297123ccb15988b5f1", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -77,7 +77,6 @@ use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::fmt;\n use core::cmp::Ordering;\n-use core::default::Default;\n use core::mem::{min_align_of, size_of};\n use core::mem;\n use core::nonzero::NonZero;"}, {"sha": "7696abd659f02ff24e6e65c0c4e649617650b8f1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -55,7 +55,6 @@ use core::prelude::*;\n \n use core::any::Any;\n use core::cmp::Ordering;\n-use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::mem;"}, {"sha": "0f05e5796aa15fb044a173337e989472b7449982", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -152,8 +152,7 @@\n \n use core::prelude::*;\n \n-use core::default::Default;\n-use core::iter::{FromIterator, IntoIterator};\n+use core::iter::{FromIterator};\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n@@ -250,28 +249,6 @@ impl<T: Ord> BinaryHeap<T> {\n         Iter { iter: self.data.iter() }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each value out of\n-    /// the binary heap in arbitrary order. The binary heap cannot be used\n-    /// after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in heap.into_iter() {\n-    ///     // x has type i32, not &i32\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { iter: self.data.into_iter() }\n-    }\n-\n     /// Returns the greatest item in the binary heap, or `None` if it is empty.\n     ///\n     /// # Examples\n@@ -675,8 +652,25 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the binary heap in arbitrary order. The binary heap cannot be used\n+    /// after calling this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in heap.into_iter() {\n+    ///     // x has type i32, not &i32\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        IntoIter { iter: self.data.into_iter() }\n     }\n }\n "}, {"sha": "d9151298a35e3165a1dbfe7ad7fc4659dfaac45a", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -40,7 +40,6 @@\n //! ```\n //! # #![feature(collections, core, step_by)]\n //! use std::collections::{BitSet, BitVec};\n-//! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;\n@@ -85,12 +84,11 @@ use core::prelude::*;\n \n use core::cmp::Ordering;\n use core::cmp;\n-use core::default::Default;\n use core::fmt;\n use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n-use core::iter::{self, FromIterator, IntoIterator};\n+use core::iter::{self, FromIterator};\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};"}, {"sha": "291b66939e5ef038eab3fc1cb3b4bf4b724b4b8d", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -20,10 +20,9 @@ use self::Entry::*;\n use core::prelude::*;\n \n use core::cmp::Ordering;\n-use core::default::Default;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Map, FromIterator, IntoIterator};\n+use core::iter::{Map, FromIterator};\n use core::ops::Index;\n use core::{iter, fmt, mem, usize};\n use Bound::{self, Included, Excluded, Unbounded};\n@@ -471,8 +470,32 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n \n+    /// Gets an owning iterator over the entries of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// map.insert(3, \"c\");\n+    ///\n+    /// for (key, value) in map.into_iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n+        let len = self.len();\n+        let mut lca = VecDeque::new();\n+        lca.push_back(Traverse::traverse(self.root));\n+        IntoIter {\n+            inner: AbsIter {\n+                traversals: lca,\n+                size: len,\n+            }\n+        }\n     }\n }\n \n@@ -1263,35 +1286,6 @@ impl<K, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Gets an owning iterator over the entries of the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(2, \"b\");\n-    /// map.insert(3, \"c\");\n-    ///\n-    /// for (key, value) in map.into_iter() {\n-    ///     println!(\"{}: {}\", key, value);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<K, V> {\n-        let len = self.len();\n-        let mut lca = VecDeque::new();\n-        lca.push_back(Traverse::traverse(self.root));\n-        IntoIter {\n-            inner: AbsIter {\n-                traversals: lca,\n-                size: len,\n-            }\n-        }\n-    }\n-\n     /// Gets an iterator over the keys of the map.\n     ///\n     /// # Examples"}, {"sha": "fc346151e0b4bf70415f6d36176e1a70130b2a3f", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,10 +14,9 @@\n use core::prelude::*;\n \n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::default::Default;\n use core::fmt::Debug;\n use core::fmt;\n-use core::iter::{Peekable, Map, FromIterator, IntoIterator};\n+use core::iter::{Peekable, Map, FromIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use borrow::Borrow;\n@@ -132,27 +131,6 @@ impl<T> BTreeSet<T> {\n     pub fn iter(&self) -> Iter<T> {\n         Iter { iter: self.map.keys() }\n     }\n-\n-    /// Gets an iterator for moving out the BtreeSet's contents.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::collections::BTreeSet;\n-    ///\n-    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n-    ///\n-    /// let v: Vec<usize> = set.into_iter().collect();\n-    /// assert_eq!(v, [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n-\n-        IntoIter { iter: self.map.into_iter().map(first) }\n-    }\n }\n \n impl<T: Ord> BTreeSet<T> {\n@@ -500,8 +478,24 @@ impl<T> IntoIterator for BTreeSet<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Gets an iterator for moving out the BtreeSet's contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(core)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n+    ///\n+    /// let v: Vec<usize> = set.into_iter().collect();\n+    /// assert_eq!(v, [1, 2, 3, 4]);\n+    /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n+\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n "}, {"sha": "e6cdb88d3e1746eb90872a1fb7a2a896a06b4e4f", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,7 +16,7 @@\n use core::prelude::*;\n use core::marker;\n use core::fmt;\n-use core::iter::{FromIterator, IntoIterator};\n+use core::iter::{FromIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be wrong here)"}, {"sha": "2b502b2227ef343449971c36363ee0d94cfafe68", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -175,7 +175,6 @@\n //! # #![feature(core, std_misc)]\n //! use std::fmt;\n //! use std::f64;\n-//! use std::num::Float;\n //!\n //! #[derive(Debug)]\n //! struct Vector2D {\n@@ -200,10 +199,11 @@\n //!         let magnitude = magnitude.sqrt();\n //!\n //!         // Respect the formatting flags by using the helper method\n-//!         // `pad_integral` on the Formatter object. See the method documentation\n-//!         // for details, and the function `pad` can be used to pad strings.\n+//!         // `pad_integral` on the Formatter object. See the method\n+//!         // documentation for details, and the function `pad` can be used\n+//!         // to pad strings.\n //!         let decimals = f.precision().unwrap_or(3);\n-//!         let string = f64::to_str_exact(magnitude, decimals);\n+//!         let string = format!(\"{:.*}\", decimals, magnitude);\n //!         f.pad_integral(true, \"\", &string)\n //!     }\n //! }\n@@ -260,7 +260,6 @@\n //! Example usage is:\n //!\n //! ```\n-//! # #![feature(old_io)]\n //! # #![allow(unused_must_use)]\n //! use std::io::Write;\n //! let mut w = Vec::new();\n@@ -288,7 +287,6 @@\n //! off, some example usage is:\n //!\n //! ```\n-//! # #![feature(old_io)]\n //! use std::fmt;\n //! use std::io::{self, Write};\n //!"}, {"sha": "0ea8975bbde1f4b81b447dd09f2454875c30395f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -38,6 +38,7 @@\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(step_by)]\n #![feature(str_char)]\n+#![feature(str_words)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![feature(utf8_error)]"}, {"sha": "deb1476c23f096375fce6fd7cfeb919e5e322ed4", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,10 +25,9 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::cmp::Ordering;\n-use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::iter::{self, FromIterator, IntoIterator};\n+use core::iter::{self, FromIterator};\n use core::mem;\n use core::ptr;\n \n@@ -296,13 +295,6 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n-    /// Consumes the list into an iterator yielding elements by value.\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        IntoIter{list: self}\n-    }\n-\n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -852,8 +844,10 @@ impl<T> IntoIterator for LinkedList<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Consumes the list into an iterator yielding elements by value.\n+    #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        IntoIter{list: self}\n     }\n }\n \n@@ -941,7 +935,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n #[cfg(test)]\n mod test {\n     use std::clone::Clone;\n-    use std::iter::Iterator;\n+    use std::iter::{Iterator, IntoIterator};\n     use std::option::Option::{Some, None, self};\n     use std::__rand::{thread_rng, Rng};\n     use std::thread;"}, {"sha": "6622d8a9c40633a3b1a2bb374056d6cd0f69ec9c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -98,7 +98,7 @@ use self::Direction::*;\n use borrow::{Borrow, BorrowMut, ToOwned};\n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, Windows};\n+pub use core::slice::{Chunks, Windows};\n pub use core::slice::{Iter, IterMut};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};"}, {"sha": "db9f526a0f22e368459aacb92c48aba6493aa8f8", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -67,7 +67,7 @@ use rustc_unicode;\n use vec::Vec;\n use slice::SliceConcatExt;\n \n-pub use core::str::{FromStr, Utf8Error, Str};\n+pub use core::str::{FromStr, Utf8Error};\n pub use core::str::{Lines, LinesAny, CharRange};\n pub use core::str::{Split, RSplit};\n pub use core::str::{SplitN, RSplitN};\n@@ -76,7 +76,7 @@ pub use core::str::{Matches, RMatches};\n pub use core::str::{MatchIndices, RMatchIndices};\n pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n-pub use rustc_unicode::str::{Words, Graphemes, GraphemeIndices};\n+pub use rustc_unicode::str::{SplitWhitespace, Words, Graphemes, GraphemeIndices};\n pub use core::str::pattern;\n \n /*\n@@ -1737,27 +1737,44 @@ impl str {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n \n-    /// An iterator over the non-empty words of `self`.\n-    ///\n-    /// A 'word' is a subsequence separated by any sequence of whitespace.\n-    /// Sequences of whitespace\n-    /// are collapsed, so empty \"words\" are not included.\n+    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n+    /// and which are separated by any amount of whitespace.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// # #![feature(str_words)]\n+    /// # #![allow(deprecated)]\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///\n     /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n+    #[deprecated(reason = \"words() will be removed. Use split_whitespace() instead\",\n+                 since = \"1.1.0\")]\n     #[unstable(feature = \"str_words\",\n                reason = \"the precise algorithm to use is unclear\")]\n+    #[allow(deprecated)]\n     pub fn words(&self) -> Words {\n         UnicodeStr::words(&self[..])\n     }\n \n+    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n+    /// and which are separated by any amount of whitespace.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.split_whitespace().collect();\n+    ///\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    pub fn split_whitespace(&self) -> SplitWhitespace {\n+        UnicodeStr::split_whitespace(&self[..])\n+    }\n+\n     /// Returns a string's displayed width in columns.\n     ///\n     /// Control characters have zero width."}, {"sha": "a37a26ef22ac3af2852ebeb9c106fa799a3445cc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,10 +14,9 @@\n \n use core::prelude::*;\n \n-use core::default::Default;\n use core::fmt;\n use core::hash;\n-use core::iter::{IntoIterator, FromIterator};\n+use core::iter::FromIterator;\n use core::mem;\n use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n@@ -837,15 +836,6 @@ impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n     fn ne(&self, other: &Cow<'a, str>) -> bool { PartialEq::ne(&self[..], &other[..]) }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n-#[allow(deprecated)]\n-impl Str for String {\n-    #[inline]\n-    fn as_slice(&self) -> &str {\n-        unsafe { mem::transmute(&*self.vec) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for String {\n     #[inline]\n@@ -1067,19 +1057,17 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<'a> Str for Cow<'a, str> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        &**self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         self.push_str(s);\n         Ok(())\n     }\n+\n+    #[inline]\n+    fn write_char(&mut self, c: char) -> fmt::Result {\n+        self.push(c);\n+        Ok(())\n+    }\n }"}, {"sha": "526150915a705a0fb0289774776e5aae88c03b42", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 28, "deletions": 46, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -53,11 +53,10 @@ use alloc::boxed::Box;\n use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::cmp::max;\n use core::cmp::Ordering;\n-use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::intrinsics::assume;\n-use core::iter::{repeat, FromIterator, IntoIterator};\n+use core::iter::{repeat, FromIterator};\n use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Index, IndexMut, Deref, Add};\n@@ -450,37 +449,6 @@ impl<T> Vec<T> {\n         &mut self[..]\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each value out of\n-    /// the vector (from start to end). The vector cannot be used after calling\n-    /// this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n-    /// for s in v.into_iter() {\n-    ///     // s has type String, not &String\n-    ///     println!(\"{}\", s);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let ptr = *self.ptr;\n-            assume(!ptr.is_null());\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as usize + self.len()) as *const T\n-            } else {\n-                ptr.offset(self.len() as isize) as *const T\n-            };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n-        }\n-    }\n-\n     /// Sets the length of a vector.\n     ///\n     /// This will explicitly set the size of the vector, without actually\n@@ -1512,8 +1480,34 @@ impl<T> IntoIterator for Vec<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the vector (from start to end). The vector cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n+    /// for s in v.into_iter() {\n+    ///     // s has type String, not &String\n+    ///     println!(\"{}\", s);\n+    /// }\n+    /// ```\n+    #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        unsafe {\n+            let ptr = *self.ptr;\n+            assume(!ptr.is_null());\n+            let cap = self.cap;\n+            let begin = ptr as *const T;\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as usize + self.len()) as *const T\n+            } else {\n+                ptr.offset(self.len() as isize) as *const T\n+            };\n+            mem::forget(self);\n+            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n+        }\n     }\n }\n \n@@ -1597,18 +1591,6 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"will be replaced by slice syntax\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for Vec<T> {\n-    /// Deprecated: use `&mut s[..]` instead.\n-    #[inline]\n-    fn as_slice(&self) -> &[T] {\n-        self\n-    }\n-}\n-\n #[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {"}, {"sha": "bbe7830b4238c5fe2518e388f3c326d4ea949070", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -21,9 +21,8 @@\n use core::prelude::*;\n \n use core::cmp::Ordering;\n-use core::default::Default;\n use core::fmt;\n-use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n+use core::iter::{self, repeat, FromIterator, RandomAccessIterator};\n use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};\n@@ -557,14 +556,6 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Consumes the list into a front-to-back iterator yielding elements by value.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        IntoIter {\n-            inner: self,\n-        }\n-    }\n-\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     #[inline]\n@@ -1728,8 +1719,12 @@ impl<T> IntoIterator for VecDeque<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Consumes the list into a front-to-back iterator yielding elements by\n+    /// value.\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        IntoIter {\n+            inner: self,\n+        }\n     }\n }\n "}, {"sha": "d473504d5445470e676f4cce2e142f6c90215115", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -18,10 +18,9 @@ use self::Entry::*;\n use core::prelude::*;\n \n use core::cmp::{max, Ordering};\n-use core::default::Default;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n+use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n use core::iter;\n use core::mem::{replace, swap};\n use core::ops::{Index, IndexMut};\n@@ -301,35 +300,6 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Returns an iterator visiting all key-value pairs in ascending order of\n-    /// the keys, consuming the original `VecMap`.\n-    /// The iterator's element type is `(usize, &'r V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// map.insert(1, \"a\");\n-    /// map.insert(3, \"c\");\n-    /// map.insert(2, \"b\");\n-    ///\n-    /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n-    ///\n-    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<V> {\n-        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n-            v.map(|v| (i, v))\n-        }\n-        let filter: fn((usize, Option<V>)) -> Option<(usize, V)> = filter; // coerce to fn ptr\n-\n-        IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n-    }\n-\n     /// Moves all elements from `other` into the map while overwriting existing keys.\n     ///\n     /// # Examples\n@@ -800,8 +770,32 @@ impl<T> IntoIterator for VecMap<T> {\n     type Item = (usize, T);\n     type IntoIter = IntoIter<T>;\n \n+    /// Returns an iterator visiting all key-value pairs in ascending order of\n+    /// the keys, consuming the original `VecMap`.\n+    /// The iterator's element type is `(usize, &'r V)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections)]\n+    /// use std::collections::VecMap;\n+    ///\n+    /// let mut map = VecMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(3, \"c\");\n+    /// map.insert(2, \"b\");\n+    ///\n+    /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n+    ///\n+    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        fn filter<A>((i, v): (usize, Option<A>)) -> Option<(usize, A)> {\n+            v.map(|v| (i, v))\n+        }\n+        let filter: fn((usize, Option<T>)) -> Option<(usize, T)> = filter; // coerce to fn ptr\n+\n+        IntoIter { iter: self.v.into_iter().enumerate().filter_map(filter) }\n     }\n }\n "}, {"sha": "5c109dc8104f21492347aa57d7a549d1a5028a10", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,7 +14,6 @@\n #![feature(hash)]\n #![feature(rand)]\n #![feature(rustc_private)]\n-#![feature(str_words)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "170f49ab15be553d5177122d4033da1e65bbaf85", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -939,9 +939,9 @@ fn test_rsplitn() {\n }\n \n #[test]\n-fn test_words() {\n+fn test_split_whitespace() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-    let words: Vec<&str> = data.words().collect();\n+    let words: Vec<&str> = data.split_whitespace().collect();\n     assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n }\n "}, {"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,15 +11,15 @@\n pub use self::ExponentFormat::*;\n pub use self::SignificantDigits::*;\n \n-use char::{self, CharExt};\n+use prelude::*;\n+\n+use char;\n use fmt;\n-use iter::Iterator;\n-use num::{cast, Float, ToPrimitive};\n+use num::Float;\n use num::FpCategory as Fp;\n-use ops::FnOnce;\n-use result::Result::Ok;\n-use slice::{self, SliceExt};\n-use str::{self, StrExt};\n+use ops::{Div, Rem, Mul};\n+use slice;\n+use str;\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -42,6 +42,21 @@ pub enum SignificantDigits {\n     DigExact(usize)\n }\n \n+#[doc(hidden)]\n+pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n+                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n+    fn from_u32(u: u32) -> Self;\n+    fn to_i32(&self) -> i32;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl MyFloat for $t {\n+        fn from_u32(u: u32) -> $t { u as $t }\n+        fn to_i32(&self) -> i32 { *self as i32 }\n+    })*)\n+}\n+doit! { f32 f64 }\n+\n /// Converts a float number to its string representation.\n /// This is meant to be a common base implementation for various formatting styles.\n /// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n@@ -63,7 +78,7 @@ pub enum SignificantDigits {\n /// # Panics\n ///\n /// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: Float, U, F>(\n+pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n     num: T,\n     digits: SignificantDigits,\n     exp_format: ExponentFormat,\n@@ -72,10 +87,10 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n ) -> U where\n     F: FnOnce(&str) -> U,\n {\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n+    let _0: T = T::zero();\n+    let _1: T = T::one();\n     let radix: u32 = 10;\n-    let radix_f: T = cast(radix).unwrap();\n+    let radix_f = T::from_u32(radix);\n \n     assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n \n@@ -99,7 +114,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let (num, exp) = match exp_format {\n         ExpDec if num != _0 => {\n             let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), cast::<T, i32>(exp).unwrap())\n+            (num / radix_f.powf(exp), exp.to_i32())\n         }\n         _ => (num, 0)\n     };\n@@ -114,7 +129,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_f;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -158,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let current_digit = deccum.trunc();\n \n-            let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n+            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n "}, {"sha": "0178b321e88c35a68be363b49bf4a91eb4b097c4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,21 +12,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n-use char::CharExt;\n-use clone::Clone;\n-use iter::Iterator;\n-use marker::{Copy, PhantomData, Sized};\n+use marker::PhantomData;\n use mem;\n-use num::Float;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use ops::{Deref, FnOnce};\n+use ops::Deref;\n use result;\n-use slice::SliceExt;\n+use num::Float;\n use slice;\n-use str::{self, StrExt};\n+use str;\n use self::rt::v1::Alignment;\n \n pub use self::num::radix;\n@@ -83,6 +78,23 @@ pub trait Write {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_str(&mut self, s: &str) -> Result;\n \n+    /// Writes a `char` into this writer, returning whether the write succeeded.\n+    ///\n+    /// A single `char` may be encoded as more than one byte.\n+    /// This method can only succeed if the entire byte sequence was successfully\n+    /// written, and this method will not return until all data has been\n+    /// written or an error occurs.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an instance of `FormatError` on error.\n+    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n+    fn write_char(&mut self, c: char) -> Result {\n+        let mut utf_8 = [0u8; 4];\n+        let bytes_written = c.encode_utf8(&mut utf_8).unwrap_or(0);\n+        self.write_str(unsafe { mem::transmute(&utf_8[..bytes_written]) })\n+    }\n+\n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n@@ -912,7 +924,8 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: Float, F>(num: &T, precision: Option<usize>, post: F) -> Result\n+fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n+                                             post: F) -> Result\n         where F : FnOnce(&str) -> Result {\n     let digits = match precision {\n         Some(i) => float::DigExact(i),\n@@ -950,8 +963,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),\n@@ -969,8 +980,6 @@ macro_rules! floating { ($ty:ident) => {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n             let digits = match fmt.precision {\n                 Some(i) => float::DigExact(i),\n                 None => float::DigMax(6),"}, {"sha": "122fffc5959056a99c3edbe3d97155ec878c0d66", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,12 +14,28 @@\n \n #![allow(unsigned_negation)]\n \n+use prelude::*;\n+\n use fmt;\n-use iter::Iterator;\n-use num::{Int, cast};\n-use slice::SliceExt;\n+use num::Zero;\n+use ops::{Div, Rem, Sub};\n use str;\n \n+#[doc(hidden)]\n+trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n+           Sub<Output=Self> + Copy {\n+    fn from_u8(u: u8) -> Self;\n+    fn to_u8(&self) -> u8;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl Int for $t {\n+        fn from_u8(u: u8) -> $t { u as $t }\n+        fn to_u8(&self) -> u8 { *self as u8 }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n /// A type that represents a specific radix\n #[doc(hidden)]\n trait GenericRadix {\n@@ -33,33 +49,32 @@ trait GenericRadix {\n     fn digit(&self, x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n-    #[allow(deprecated)] // Int\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 64\n         // characters for a base 2 number.\n-        let zero = Int::zero();\n+        let zero = T::zero();\n         let is_positive = x >= zero;\n         let mut buf = [0; 64];\n         let mut curr = buf.len();\n-        let base = cast(self.base()).unwrap();\n+        let base = T::from_u8(self.base());\n         if is_positive {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;                         // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = x % base;              // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);                // Get the current place value.\n-                x = x / base;                             // Deaccumulate the number.\n-                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                let n = zero - (x % base);     // Get the current place value.\n+                x = x / base;                  // Deaccumulate the number.\n+                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };                   // No more digits left to accumulate.\n+                if x == zero { break };        // No more digits left to accumulate.\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };"}, {"sha": "e848a44e01ce0ef267e6f1d7df00c0e7df5c90ab", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -62,7 +62,6 @@\n \n use prelude::*;\n \n-use default::Default;\n use mem;\n \n pub use self::sip::SipHasher;"}, {"sha": "be419e2cdadb0ed9c33a86eb708c6d513063f029", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,7 +13,6 @@\n #![allow(deprecated)] // until the next snapshot for inherent wrapping ops\n \n use prelude::*;\n-use default::Default;\n use super::Hasher;\n \n /// An implementation of SipHash 2-4."}, {"sha": "233ed018119302deceb23bedcdac7e0175a9b0e0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -64,7 +64,7 @@ use cmp::{Ord, PartialOrd, PartialEq};\n use default::Default;\n use marker;\n use mem;\n-use num::{Int, Zero, One};\n+use num::{Zero, One};\n use ops::{self, Add, Sub, FnMut, Mul, RangeFrom};\n use option::Option::{self, Some, None};\n use marker::Sized;\n@@ -2327,9 +2327,8 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n /// ```\n-/// # #![feature(core)]\n+/// #![feature(core)]\n /// use std::iter::Unfold;\n-/// use std::num::Int; // For `.checked_add()`\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max\n /// // value of `u32`. You can simply change `u32` to `u64` in this line if\n@@ -2647,80 +2646,6 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     }\n }\n \n-/// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-pub struct RangeStepInclusive<A> {\n-    state: A,\n-    stop: A,\n-    step: A,\n-    rev: bool,\n-    done: bool,\n-}\n-\n-/// Returns an iterator over the range [start, stop] by `step`.\n-///\n-/// It handles overflow by stopping.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::iter::range_step_inclusive;\n-///\n-/// for i in range_step_inclusive(0, 10, 2) {\n-///     println!(\"{}\", i);\n-/// }\n-/// ```\n-///\n-/// This prints:\n-///\n-/// ```text\n-/// 0\n-/// 2\n-/// 4\n-/// 6\n-/// 8\n-/// 10\n-/// ```\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n-    let rev = step < Int::zero();\n-    RangeStepInclusive {\n-        state: start,\n-        stop: stop,\n-        step: step,\n-        rev: rev,\n-        done: false,\n-    }\n-}\n-\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n-impl<A: Int> Iterator for RangeStepInclusive<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        if !self.done && ((self.rev && self.state >= self.stop) ||\n-                          (!self.rev && self.state <= self.stop)) {\n-            let result = self.state;\n-            match self.state.checked_add(self.step) {\n-                Some(x) => self.state = x,\n-                None => self.done = true\n-            }\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "249f0a0c389a3deda580019f845e047ed3aed18d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -108,6 +108,7 @@ mod uint_macros;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n+#[macro_use]\n pub mod num;\n \n /* The libcore prelude, not as all-encompassing as the libstd prelude */"}, {"sha": "fdabdbc5ed4ce0c59c8d2853e662084247d7544c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -35,7 +35,16 @@ use hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub unsafe trait Send {\n+    // empty.\n+}\n+\n+/// Types able to be transferred across thread boundaries.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"send\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[cfg(stage0)]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -51,7 +60,17 @@ impl !Send for Managed { }\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n-#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub trait Sized {\n+    // Empty.\n+}\n+\n+/// Types with a constant size known at compile-time.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sized\"]\n+#[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n+#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n+#[cfg(stage0)]\n pub trait Sized : MarkerTrait {\n     // Empty.\n }\n@@ -199,13 +218,23 @@ pub trait Copy : Clone {\n /// the `sync` crate do ensure that any mutation cannot cause data\n /// races.  Hence these types are `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell` wrapper around the\n-/// value(s) which can be mutated when behind a `&` reference; not doing this is undefined\n-/// behaviour (for example, `transmute`-ing from `&T` to `&mut T` is illegal).\n+/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n+/// wrapper around the value(s) which can be mutated when behind a `&`\n+/// reference; not doing this is undefined behaviour (for example,\n+/// `transmute`-ing from `&T` to `&mut T` is illegal).\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[lang=\"sync\"]\n+#[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+pub unsafe trait Sync {\n+    // Empty\n+}\n+\n+/// dox\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n-#[allow(deprecated)]\n pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n@@ -272,42 +301,20 @@ macro_rules! impls{\n         )\n }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n+/// dox\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n #[cfg(stage0)]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n \n-/// `MarkerTrait` is deprecated and no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-pub trait MarkerTrait { }\n-\n-#[allow(deprecated)]\n-impl<T:?Sized> MarkerTrait for T { }\n+#[cfg(stage0)]\n+impl<T: ?Sized> MarkerTrait for T {}\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n+/// dox\n #[lang=\"phantom_fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n #[cfg(stage0)]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n }\n \n-/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n-#[cfg(not(stage0))]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n-}\n-\n-#[allow(deprecated)]\n-#[cfg(not(stage0))]\n-impl<A:?Sized,R:?Sized,T:?Sized> PhantomFn<A,R> for T { }\n-\n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n /// of your code.\n@@ -454,8 +461,14 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n-pub trait Reflect : MarkerTrait {\n-}\n+#[cfg(not(stage0))]\n+pub trait Reflect {}\n+\n+/// dox\n+#[rustc_reflect_like]\n+#[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[cfg(stage0)]\n+pub trait Reflect: MarkerTrait {}\n \n impl Reflect for .. { }\n "}, {"sha": "9ea44c39fe9c6382c6a27b441df0f0a028d62a36", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,12 +10,17 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n-use marker::{Sized, MarkerTrait};\n+use marker::Sized;\n use ops::Deref;\n+#[cfg(stage0)] use marker::MarkerTrait;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n-#[allow(deprecated)]\n-pub unsafe trait Zeroable : MarkerTrait {}\n+#[cfg(not(stage0))]\n+pub unsafe trait Zeroable {}\n+\n+/// Unsafe trait to indicate what types are usable with the NonZero struct\n+#[cfg(stage0)]\n+pub unsafe trait Zeroable: MarkerTrait {}\n \n unsafe impl<T:?Sized> Zeroable for *const T {}\n unsafe impl<T:?Sized> Zeroable for *mut T {}"}, {"sha": "50dd3f1661adf6c0fa632841668af366e683c104", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,11 +16,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n+use num::{Float, ParseFloatError};\n use num::FpCategory as Fp;\n-use option::Option;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +34,6 @@ pub const DIGITS: u32 = 6;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n-/// Smallest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN`\")]\n-pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n-/// Smallest positive, normalized f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n-/// Largest finite f32 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MAX`\")]\n-pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n-\n /// Smallest finite f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f32 = -3.40282347e+38_f32;\n@@ -118,26 +106,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n@@ -179,6 +155,8 @@ impl Float for f32 {\n     #[inline]\n     fn one() -> f32 { 1.0 }\n \n+    from_str_radix_float_impl! { f32 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -218,56 +196,6 @@ impl Float for f32 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f32 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f32 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f32 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { mem::transmute(self) };\n@@ -310,9 +238,6 @@ impl Float for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "62b566e7eb40cb65f8b45d704e0f8c2fa83d22f7", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,11 +16,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n use num::FpCategory as Fp;\n-use option::Option;\n+use num::{Float, ParseFloatError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -33,19 +34,6 @@ pub const DIGITS: u32 = 15;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n-/// Smallest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN`\")]\n-pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n-/// Smallest positive, normalized f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN_POSITIVE`\")]\n-pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n-/// Largest finite f64 value\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MAX`\")]\n-pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n-\n /// Smallest finite f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: f64 = -1.7976931348623157e+308_f64;\n@@ -118,26 +106,14 @@ pub mod consts {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n-    pub const FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n-\n     /// sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n-    pub const SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n-\n     /// 1.0/sqrt(2.0)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n-    pub const FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n-\n     /// Euler's number\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n@@ -179,6 +155,8 @@ impl Float for f64 {\n     #[inline]\n     fn one() -> f64 { 1.0 }\n \n+    from_str_radix_float_impl! { f64 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -218,56 +196,6 @@ impl Float for f64 {\n         }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> usize { MANTISSA_DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> usize { DIGITS as usize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn epsilon() -> f64 { EPSILON }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> isize { MIN_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> isize { MAX_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> isize { MIN_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> isize { MAX_10_EXP as isize }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f64 { MIN }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POSITIVE }\n-\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f64 { MAX }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { mem::transmute(self) };\n@@ -310,9 +238,6 @@ impl Float for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "5ee0dc19f9bf684ca855056f2a8551e63a6ffc2c", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -18,3 +18,145 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n+\n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        fn from_str_radix(src: &str, radix: u32)\n+                          -> Result<$T, ParseFloatError> {\n+            use num::FloatErrorKind::*;\n+            use num::ParseFloatError as PFE;\n+\n+            // Special values\n+            match src {\n+                \"inf\"   => return Ok(Float::infinity()),\n+                \"-inf\"  => return Ok(Float::neg_infinity()),\n+                \"NaN\"   => return Ok(Float::nan()),\n+                _       => {},\n+            }\n+\n+            let (is_positive, src) =  match src.slice_shift_char() {\n+                None             => return Err(PFE { kind: Empty }),\n+                Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n+                Some(('-', src)) => (false, src),\n+                Some((_, _))     => (true,  src),\n+            };\n+\n+            // The significand to accumulate\n+            let mut sig = if is_positive { 0.0 } else { -0.0 };\n+            // Necessary to detect overflow\n+            let mut prev_sig = sig;\n+            let mut cs = src.chars().enumerate();\n+            // Exponent prefix and exponent index offset\n+            let mut exp_info = None::<(char, usize)>;\n+\n+            // Parse the integer part of the significand\n+            for (i, c) in cs.by_ref() {\n+                match c.to_digit(radix) {\n+                    Some(digit) => {\n+                        // shift significand one digit left\n+                        sig = sig * (radix as $T);\n+\n+                        // add/subtract current digit depending on sign\n+                        if is_positive {\n+                            sig = sig + ((digit as isize) as $T);\n+                        } else {\n+                            sig = sig - ((digit as isize) as $T);\n+                        }\n+\n+                        // Detect overflow by comparing to last value, except\n+                        // if we've not seen any non-zero digits.\n+                        if prev_sig != 0.0 {\n+                            if is_positive && sig <= prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig >= prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+\n+                            // Detect overflow by reversing the shift-and-add process\n+                            if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                { return Ok(Float::neg_infinity()); }\n+                        }\n+                        prev_sig = sig;\n+                    },\n+                    None => match c {\n+                        'e' | 'E' | 'p' | 'P' => {\n+                            exp_info = Some((c, i + 1));\n+                            break;  // start of exponent\n+                        },\n+                        '.' => {\n+                            break;  // start of fractional part\n+                        },\n+                        _ => {\n+                            return Err(PFE { kind: Invalid });\n+                        },\n+                    },\n+                }\n+            }\n+\n+            // If we are not yet at the exponent parse the fractional\n+            // part of the significand\n+            if exp_info.is_none() {\n+                let mut power = 1.0;\n+                for (i, c) in cs.by_ref() {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // Decrease power one order of magnitude\n+                            power = power / (radix as $T);\n+                            // add/subtract current digit depending on sign\n+                            sig = if is_positive {\n+                                sig + (digit as $T) * power\n+                            } else {\n+                                sig - (digit as $T) * power\n+                            };\n+                            // Detect overflow by comparing to last value\n+                            if is_positive && sig < prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig > prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break; // start of exponent\n+                            },\n+                            _ => {\n+                                return Err(PFE { kind: Invalid });\n+                            },\n+                        },\n+                    }\n+                }\n+            }\n+\n+            // Parse and calculate the exponent\n+            let exp = match exp_info {\n+                Some((c, offset)) => {\n+                    let base = match c {\n+                        'E' | 'e' if radix == 10 => 10.0,\n+                        'P' | 'p' if radix == 16 => 2.0,\n+                        _ => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    // Parse the exponent as decimal integer\n+                    let src = &src[offset..];\n+                    let (is_positive, exp) = match src.slice_shift_char() {\n+                        Some(('-', src)) => (false, src.parse::<usize>()),\n+                        Some(('+', src)) => (true,  src.parse::<usize>()),\n+                        Some((_, _))     => (true,  src.parse::<usize>()),\n+                        None             => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    match (is_positive, exp) {\n+                        (true,  Ok(exp)) => base.powi(exp as i32),\n+                        (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n+                        (_, Err(_))      => return Err(PFE { kind: Invalid }),\n+                    }\n+                },\n+                None => 1.0, // no exponent\n+            };\n+\n+            Ok(sig * exp)\n+        }\n+    }\n+}"}, {"sha": "44d5333ce1f46bb582a11b97e2fe08718c52029e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 123, "deletions": 1736, "changes": 1859, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,18 +13,14 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-use self::wrapping::{OverflowingOps, WrappingOps};\n+use self::wrapping::OverflowingOps;\n \n use char::CharExt;\n-use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord};\n+use cmp::{Eq, PartialOrd};\n use fmt;\n use intrinsics;\n-use iter::Iterator;\n use marker::Copy;\n use mem::size_of;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n@@ -98,736 +94,20 @@ macro_rules! zero_one_impl_float {\n }\n zero_one_impl_float! { f32 f64 }\n \n-/// A built-in signed or unsigned integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait Int\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd + Ord\n-    + PartialEq + Eq\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-    + Not<Output=Self>\n-    + BitAnd<Output=Self>\n-    + BitOr<Output=Self>\n-    + BitXor<Output=Self>\n-    + Shl<usize, Output=Self>\n-    + Shr<usize, Output=Self>\n-    + WrappingOps\n-    + OverflowingOps\n-{\n-    /// Returns the `0` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-\n-    /// Returns the `1` value of this integer type.\n-    // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    /// Returns the smallest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-\n-    /// Returns the largest value that can be represented by this integer type.\n-    // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"core\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-\n-    /// Returns the number of ones in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_ones(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn count_ones(self) -> u32;\n-\n-    /// Returns the number of zeros in the binary representation of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b01001100u8;\n-    ///\n-    /// assert_eq!(n.count_zeros(), 5);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn count_zeros(self) -> u32 {\n-        (!self).count_ones()\n-    }\n-\n-    /// Returns the number of leading zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.leading_zeros(), 10);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn leading_zeros(self) -> u32;\n-\n-    /// Returns the number of trailing zeros in the binary representation\n-    /// of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0b0101000u16;\n-    ///\n-    /// assert_eq!(n.trailing_zeros(), 3);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn trailing_zeros(self) -> u32;\n-\n-    /// Shifts the bits to the left by a specified amount, `n`, wrapping\n-    /// the truncated bits to the end of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0x3456789ABCDEF012u64;\n-    ///\n-    /// assert_eq!(n.rotate_left(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_left(self, n: u32) -> Self;\n-\n-    /// Shifts the bits to the right by a specified amount, `n`, wrapping\n-    /// the truncated bits to the beginning of the resulting integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xDEF0123456789ABCu64;\n-    ///\n-    /// assert_eq!(n.rotate_right(12), m);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    fn rotate_right(self, n: u32) -> Self;\n-\n-    /// Reverses the byte order of the integer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xEFCDAB8967452301u64;\n-    ///\n-    /// assert_eq!(n.swap_bytes(), m);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn swap_bytes(self) -> Self;\n-\n-    /// Converts an integer from big endian to the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(Int::from_be(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_be(x: Self) -> Self {\n-        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts an integer from little endian to the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(Int::from_le(n), n)\n-    /// } else {\n-    ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn from_le(x: Self) -> Self {\n-        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to big endian from the target's endianness.\n-    ///\n-    /// On big endian this is a no-op. On little endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"big\") {\n-    ///     assert_eq!(n.to_be(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_be(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_be(self) -> Self { // or not to be?\n-        if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Converts `self` to little endian from the target's endianness.\n-    ///\n-    /// On little endian this is a no-op. On big endian the bytes are swapped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    ///\n-    /// if cfg!(target_endian = \"little\") {\n-    ///     assert_eq!(n.to_le(), n)\n-    /// } else {\n-    ///     assert_eq!(n.to_le(), n.swap_bytes())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn to_le(self) -> Self {\n-        if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n-    }\n-\n-    /// Checked integer addition. Computes `self + other`, returning `None` if\n-    /// overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.checked_add(65530), Some(65535));\n-    /// assert_eq!(6u16.checked_add(65530), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_add(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer subtraction. Computes `self - other`, returning `None`\n-    /// if underflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-    /// assert_eq!((-128i8).checked_sub(1), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_sub(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer multiplication. Computes `self * other`, returning\n-    /// `None` if underflow or overflow occurred.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u8.checked_mul(51), Some(255));\n-    /// assert_eq!(5u8.checked_mul(52), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_mul(self, other: Self) -> Option<Self>;\n-\n-    /// Checked integer division. Computes `self / other`, returning `None` if\n-    /// `other == 0` or the operation results in underflow or overflow.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-    /// assert_eq!((-128i8).checked_div(-1), None);\n-    /// assert_eq!((1i8).checked_div(0), None);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn checked_div(self, other: Self) -> Option<Self>;\n-\n-    /// Saturating integer addition. Computes `self + other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_add(65534), 65535);\n-    /// assert_eq!((-5i16).saturating_add(-32767), -32768);\n-    /// assert_eq!(100u32.saturating_add(4294967294), 4294967295);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_add(self, other: Self) -> Self {\n-        match self.checked_add(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::max_value(),\n-            None                         => Int::min_value(),\n-        }\n-    }\n-\n-    /// Saturating integer subtraction. Computes `self - other`, saturating at\n-    /// the numeric bounds instead of overflowing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(5u16.saturating_sub(65534), 0);\n-    /// assert_eq!(5i16.saturating_sub(-32767), 32767);\n-    /// assert_eq!(100u32.saturating_sub(4294967294), 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn saturating_sub(self, other: Self) -> Self {\n-        match self.checked_sub(other) {\n-            Some(x)                      => x,\n-            None if other >= Int::zero() => Int::min_value(),\n-            None                         => Int::max_value(),\n-        }\n-    }\n-\n-    /// Raises self to the power of `exp`, using exponentiation by squaring.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Int;\n-    ///\n-    /// assert_eq!(2.pow(4), 16);\n-    /// ```\n-    #[unstable(feature = \"core\",\n-               reason = \"pending integer conventions\")]\n-    #[inline]\n-    fn pow(self, mut exp: u32) -> Self {\n-        let mut base = self;\n-        let mut acc: Self = Int::one();\n-\n-        let mut prev_base = self;\n-        let mut base_oflo = false;\n-        while exp > 0 {\n-            if (exp & 1) == 1 {\n-                if base_oflo {\n-                    // ensure overflow occurs in the same manner it\n-                    // would have otherwise (i.e. signal any exception\n-                    // it would have otherwise).\n-                    acc = acc * (prev_base * prev_base);\n-                } else {\n-                    acc = acc * base;\n-                }\n-            }\n-            prev_base = base;\n-            let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-            base = new_base;\n-            base_oflo = new_base_oflo;\n-            exp /= 2;\n-        }\n-        acc\n-    }\n-}\n-\n macro_rules! checked_op {\n     ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n         if overflowed { None } else { Some(result as $T) }\n     }}\n }\n \n-macro_rules! uint_impl {\n-    ($T:ty = $ActualT:ty, $BITS:expr,\n-     $ctpop:path,\n-     $ctlz:path,\n-     $cttz:path,\n-     $bswap:path,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { 0 }\n-\n-            #[inline]\n-            fn max_value() -> $T { !0 }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 {\n-                unsafe { $ctpop(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                unsafe { $ctlz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                unsafe { $cttz(self as $ActualT) as u32 }\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self << n) | (self >> (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self >> n) | (self << (($BITS - n) % $BITS))\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                unsafe { $bswap(self as $ActualT) as $T }\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0 => None,\n-                    v => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n /// Swapping a single byte is a no-op. This is marked as `unsafe` for\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-uint_impl! { u8 = u8, 8,\n-    intrinsics::ctpop8,\n-    intrinsics::ctlz8,\n-    intrinsics::cttz8,\n-    bswap8,\n-    intrinsics::u8_add_with_overflow,\n-    intrinsics::u8_sub_with_overflow,\n-    intrinsics::u8_mul_with_overflow }\n-\n-uint_impl! { u16 = u16, 16,\n-    intrinsics::ctpop16,\n-    intrinsics::ctlz16,\n-    intrinsics::cttz16,\n-    intrinsics::bswap16,\n-    intrinsics::u16_add_with_overflow,\n-    intrinsics::u16_sub_with_overflow,\n-    intrinsics::u16_mul_with_overflow }\n-\n-uint_impl! { u32 = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-uint_impl! { u64 = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-uint_impl! { usize = u32, 32,\n-    intrinsics::ctpop32,\n-    intrinsics::ctlz32,\n-    intrinsics::cttz32,\n-    intrinsics::bswap32,\n-    intrinsics::u32_add_with_overflow,\n-    intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-uint_impl! { usize = u64, 64,\n-    intrinsics::ctpop64,\n-    intrinsics::ctlz64,\n-    intrinsics::cttz64,\n-    intrinsics::bswap64,\n-    intrinsics::u64_add_with_overflow,\n-    intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow }\n-\n-macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n-     $add_with_overflow:path,\n-     $sub_with_overflow:path,\n-     $mul_with_overflow:path) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl Int for $T {\n-            #[inline]\n-            fn zero() -> $T { 0 }\n-\n-            #[inline]\n-            fn one() -> $T { 1 }\n-\n-            #[inline]\n-            fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n-\n-            #[inline]\n-            fn max_value() -> $T { let min: $T = Int::min_value(); !min }\n-\n-            #[inline]\n-            fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n-\n-            #[inline]\n-            fn leading_zeros(self) -> u32 {\n-                (self as $UnsignedT).leading_zeros()\n-            }\n-\n-            #[inline]\n-            fn trailing_zeros(self) -> u32 {\n-                (self as $UnsignedT).trailing_zeros()\n-            }\n-\n-            #[inline]\n-            fn rotate_left(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_left(n) as $T\n-            }\n-\n-            #[inline]\n-            fn rotate_right(self, n: u32) -> $T {\n-                (self as $UnsignedT).rotate_right(n) as $T\n-            }\n-\n-            #[inline]\n-            fn swap_bytes(self) -> $T {\n-                (self as $UnsignedT).swap_bytes() as $T\n-            }\n-\n-            #[inline]\n-            fn checked_add(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_sub(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_mul(self, other: $T) -> Option<$T> {\n-                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n-            }\n-\n-            #[inline]\n-            fn checked_div(self, v: $T) -> Option<$T> {\n-                match v {\n-                    0   => None,\n-                   -1 if self == Int::min_value()\n-                        => None,\n-                    v   => Some(self / v),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-int_impl! { i8 = i8, u8, 8,\n-    intrinsics::i8_add_with_overflow,\n-    intrinsics::i8_sub_with_overflow,\n-    intrinsics::i8_mul_with_overflow }\n-\n-int_impl! { i16 = i16, u16, 16,\n-    intrinsics::i16_add_with_overflow,\n-    intrinsics::i16_sub_with_overflow,\n-    intrinsics::i16_mul_with_overflow }\n-\n-int_impl! { i32 = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-int_impl! { i64 = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"32\")]\n-int_impl! { isize = i32, u32, 32,\n-    intrinsics::i32_add_with_overflow,\n-    intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow }\n-\n-#[cfg(target_pointer_width = \"64\")]\n-int_impl! { isize = i64, u64, 64,\n-    intrinsics::i64_add_with_overflow,\n-    intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow }\n-\n-/// A built-in two's complement integer.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n-#[allow(deprecated)]\n-pub trait SignedInt\n-    : Int\n-    + Neg<Output=Self>\n-{\n-    /// Computes the absolute value of `self`. `Int::min_value()` will be\n-    /// returned if the number is `Int::min_value()`.\n-    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n-    fn abs(self) -> Self;\n-\n-    /// Returns a number representing sign of `self`.\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-\n-    /// Returns `true` if `self` is positive and `false` if the number\n-    /// is zero or negative.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-\n-    /// Returns `true` if `self` is negative and `false` if the number\n-    /// is zero or positive.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-}\n-\n-macro_rules! signed_int_impl {\n-    ($T:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl SignedInt for $T {\n-            #[inline]\n-            fn abs(self) -> $T {\n-                if self.is_negative() { -self } else { self }\n-            }\n-\n-            #[inline]\n-            fn signum(self) -> $T {\n-                match self {\n-                    n if n > 0 =>  1,\n-                    0          =>  0,\n-                    _          => -1,\n-                }\n-            }\n-\n-            #[inline]\n-            fn is_positive(self) -> bool { self > 0 }\n-\n-            #[inline]\n-            fn is_negative(self) -> bool { self < 0 }\n-        }\n-    }\n-}\n-\n-signed_int_impl! { i8 }\n-signed_int_impl! { i16 }\n-signed_int_impl! { i32 }\n-signed_int_impl! { i64 }\n-signed_int_impl! { isize }\n-\n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($T:ident = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -840,7 +120,7 @@ macro_rules! int_impl {\n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn max_value() -> $T {\n-            let min: $T = Int::min_value(); !min\n+            let min = $T::min_value(); !min\n         }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -859,17 +139,14 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -883,9 +160,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -902,9 +176,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -921,9 +192,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -940,9 +208,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -961,9 +226,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -980,8 +242,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -1001,14 +261,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1025,14 +283,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1049,8 +305,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -1073,8 +327,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -1095,8 +347,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -1112,8 +362,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -1129,8 +377,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1146,8 +392,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1439,17 +683,14 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n-            <Self as FromStrRadix>::from_str_radix(src, radix)\n+            from_str_radix(src, radix)\n         }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -1465,9 +706,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -1484,9 +722,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -1503,9 +738,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -1522,9 +754,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -1545,9 +774,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -1566,8 +792,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -1587,14 +811,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1611,14 +833,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1635,8 +855,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -1659,8 +877,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -1681,8 +897,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -1698,8 +912,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -1715,8 +927,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1732,8 +942,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1866,10 +1074,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n-        /// assert_eq!(2.pow(4), 16);\n+        /// assert_eq!(2i32.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -2007,575 +1212,6 @@ impl usize {\n         intrinsics::u64_mul_with_overflow }\n }\n \n-/// A generic trait for converting a value to a number.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n-    fn to_int(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `isize`.\n-    #[inline]\n-    fn to_isize(&self) -> Option<isize> {\n-        self.to_i64().and_then(|x| x.to_isize())\n-    }\n-\n-    /// Converts the value of `self` to an `i8`.\n-    #[inline]\n-    fn to_i8(&self) -> Option<i8> {\n-        self.to_i64().and_then(|x| x.to_i8())\n-    }\n-\n-    /// Converts the value of `self` to an `i16`.\n-    #[inline]\n-    fn to_i16(&self) -> Option<i16> {\n-        self.to_i64().and_then(|x| x.to_i16())\n-    }\n-\n-    /// Converts the value of `self` to an `i32`.\n-    #[inline]\n-    fn to_i32(&self) -> Option<i32> {\n-        self.to_i64().and_then(|x| x.to_i32())\n-    }\n-\n-    /// Converts the value of `self` to an `i64`.\n-    fn to_i64(&self) -> Option<i64>;\n-\n-    /// Converts the value of `self` to an `usize`.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n-    fn to_uint(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to a `usize`.\n-    #[inline]\n-    fn to_usize(&self) -> Option<usize> {\n-        self.to_u64().and_then(|x| x.to_usize())\n-    }\n-\n-    /// Converts the value of `self` to an `u8`.\n-    #[inline]\n-    fn to_u8(&self) -> Option<u8> {\n-        self.to_u64().and_then(|x| x.to_u8())\n-    }\n-\n-    /// Converts the value of `self` to an `u16`.\n-    #[inline]\n-    fn to_u16(&self) -> Option<u16> {\n-        self.to_u64().and_then(|x| x.to_u16())\n-    }\n-\n-    /// Converts the value of `self` to an `u32`.\n-    #[inline]\n-    fn to_u32(&self) -> Option<u32> {\n-        self.to_u64().and_then(|x| x.to_u32())\n-    }\n-\n-    /// Converts the value of `self` to an `u64`.\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64>;\n-\n-    /// Converts the value of `self` to an `f32`.\n-    #[inline]\n-    fn to_f32(&self) -> Option<f32> {\n-        self.to_f64().and_then(|x| x.to_f32())\n-    }\n-\n-    /// Converts the value of `self` to an `f64`.\n-    #[inline]\n-    fn to_f64(&self) -> Option<f64> {\n-        self.to_i64().and_then(|x| x.to_f64())\n-    }\n-}\n-\n-macro_rules! impl_to_primitive_int_to_int {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let n = $slf as i64;\n-                let min_value: $DstT = Int::min_value();\n-                let max_value: $DstT = Int::max_value();\n-                if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            let zero: $SrcT = Int::zero();\n-            let max_value: $DstT = Int::max_value();\n-            if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_int {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_int! { isize }\n-impl_to_primitive_int! { i8 }\n-impl_to_primitive_int! { i16 }\n-impl_to_primitive_int! { i32 }\n-impl_to_primitive_int! { i64 }\n-\n-macro_rules! impl_to_primitive_uint_to_int {\n-    ($DstT:ty, $slf:expr) => (\n-        {\n-            let max_value: $DstT = Int::max_value();\n-            if $slf as u64 <= max_value as u64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint_to_uint {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some($slf as $DstT)\n-            } else {\n-                let zero: $SrcT = Int::zero();\n-                let max_value: $DstT = Int::max_value();\n-                if zero <= $slf && $slf as u64 <= max_value as u64 {\n-                    Some($slf as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_uint {\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16, *self) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32, *self) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> {\n-                impl_to_primitive_uint_to_uint!($T, usize, *self)\n-            }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16, *self) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32, *self) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64, *self) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_uint! { usize }\n-impl_to_primitive_uint! { u8 }\n-impl_to_primitive_uint! { u16 }\n-impl_to_primitive_uint! { u32 }\n-impl_to_primitive_uint! { u64 }\n-\n-macro_rules! impl_to_primitive_float_to_float {\n-    ($SrcT:ident, $DstT:ident, $slf:expr) => (\n-        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some($slf as $DstT)\n-        } else {\n-            let n = $slf as f64;\n-            let max_value: $SrcT = ::$SrcT::MAX;\n-            if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some($slf as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-}\n-\n-macro_rules! impl_to_primitive_float {\n-    ($T:ident) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_isize(&self) -> Option<isize> { Some(*self as isize) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_usize(&self) -> Option<usize> { Some(*self as usize) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32, *self) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n-        }\n-    )\n-}\n-\n-impl_to_primitive_float! { f32 }\n-impl_to_primitive_float! { f64 }\n-\n-/// A generic trait for converting a number to a value.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait FromPrimitive : ::marker::Sized {\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-    fn from_int(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `isize` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_isize(n: isize) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Converts an `i64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_i64(n: i64) -> Option<Self>;\n-\n-    /// Converts an `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n-    fn from_uint(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts a `usize` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_usize(n: usize) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Converts an `u64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_u64(n: u64) -> Option<Self>;\n-\n-    /// Converts a `f32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_f64(n as f64)\n-    }\n-\n-    /// Converts a `f64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-pub fn from_int<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_isize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_isize<A: FromPrimitive>(n: isize) -> Option<A> {\n-    FromPrimitive::from_isize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n-    FromPrimitive::from_i8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n-    FromPrimitive::from_i16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n-    FromPrimitive::from_i32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n-    FromPrimitive::from_i64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n-pub fn from_uint<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_usize`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_usize<A: FromPrimitive>(n: usize) -> Option<A> {\n-    FromPrimitive::from_usize(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n-    FromPrimitive::from_u8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n-    FromPrimitive::from_u16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n-    FromPrimitive::from_u32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n-    FromPrimitive::from_u64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n-    FromPrimitive::from_f32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n-    FromPrimitive::from_f64(n)\n-}\n-\n-macro_rules! impl_from_primitive {\n-    ($T:ty, $to_ty:ident) => (\n-        #[allow(deprecated)]\n-        impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: isize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_uint(n: usize) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { n.$to_ty() }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { n.$to_ty() }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n-        }\n-    )\n-}\n-\n-impl_from_primitive! { isize, to_int }\n-impl_from_primitive! { i8, to_i8 }\n-impl_from_primitive! { i16, to_i16 }\n-impl_from_primitive! { i32, to_i32 }\n-impl_from_primitive! { i64, to_i64 }\n-impl_from_primitive! { usize, to_uint }\n-impl_from_primitive! { u8, to_u8 }\n-impl_from_primitive! { u16, to_u16 }\n-impl_from_primitive! { u32, to_u32 }\n-impl_from_primitive! { u64, to_u64 }\n-impl_from_primitive! { f32, to_f32 }\n-impl_from_primitive! { f64, to_f64 }\n-\n-/// Casts from one machine scalar to another.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::num;\n-///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n-/// assert_eq!(twenty, 20f32);\n-/// ```\n-///\n-#[inline]\n-#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n-pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n-    NumCast::from(n)\n-}\n-\n-/// An interface for casting between machine scalars.\n-#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n-pub trait NumCast: ToPrimitive {\n-    /// Creates a number from another value that can be converted into a primitive via the\n-    /// `ToPrimitive` trait.\n-    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n-}\n-\n-macro_rules! impl_num_cast {\n-    ($T:ty, $conv:ident) => (\n-        impl NumCast for $T {\n-            #[inline]\n-            #[allow(deprecated)]\n-            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n-                // `$conv` could be generated using `concat_idents!`, but that\n-                // macro seems to be broken at the moment\n-                n.$conv()\n-            }\n-        }\n-    )\n-}\n-\n-impl_num_cast! { u8,    to_u8 }\n-impl_num_cast! { u16,   to_u16 }\n-impl_num_cast! { u32,   to_u32 }\n-impl_num_cast! { u64,   to_u64 }\n-impl_num_cast! { usize,  to_uint }\n-impl_num_cast! { i8,    to_i8 }\n-impl_num_cast! { i16,   to_i16 }\n-impl_num_cast! { i32,   to_i32 }\n-impl_num_cast! { i64,   to_i64 }\n-impl_num_cast! { isize,   to_int }\n-impl_num_cast! { f32,   to_f32 }\n-impl_num_cast! { f64,   to_f64 }\n-\n /// Used for representing the classification of floating point numbers\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2602,93 +1238,22 @@ pub enum FpCategory {\n }\n \n /// A built-in floating point number.\n-// FIXME(#5527): In a future version of Rust, many of these functions will\n-//               become constants.\n-//\n-// FIXME(#8888): Several of these functions have a parameter named\n-//               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable(feature = \"core\",\n-           reason = \"distribution of methods between core/std is unclear\")]\n #[doc(hidden)]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n+pub trait Float {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n-    /// Returns the `0` value.\n-    fn zero() -> Self;\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n-    /// Returns the `1` value.\n+    /// Returns 0.0.\n+    fn zero() -> Self;\n+    /// Returns 1.0.\n     fn one() -> Self;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Returns the number of binary digits of mantissa that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the number of base-10 digits of precision that this type supports.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Returns the minimum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum binary exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the minimum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the maximum base-10 exponent that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Returns the smallest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN` or `std::f64::MIN` as appropriate\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_POSITIVE` or \\\n-                           `std::f64::MIN_POSITIVE` as appropriate\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX` or `std::f64::MAX` as appropriate\")]\n-    fn max_value() -> Self;\n+    /// Parses the string `s` with the radix `r` as a float.\n+    fn from_str_radix(s: &str, r: u32) -> Result<Self, ParseFloatError>;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n@@ -2705,16 +1270,16 @@ pub trait Float\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Returns the largest integer less than or equal to a number.\n+    /// Return the largest integer less than or equal to a number.\n     fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Return the smallest integer greater than or equal to a number.\n     fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n     fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n+    /// Return the integer part of a number.\n     fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n+    /// Return the fractional part of a number.\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2737,21 +1302,21 @@ pub trait Float\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n-    /// Raises a number to an integer power.\n+    /// Raise a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n+    /// Raise a number to a floating point power.\n     fn powf(self, n: Self) -> Self;\n \n-    /// Takes the square root of a number.\n+    /// Take the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -2767,39 +1332,14 @@ pub trait Float\n     /// Returns the base 10 logarithm of the number.\n     fn log10(self) -> Self;\n \n-    /// Converts radians to degrees.\n+    /// Convert radians to degrees.\n     fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n+    /// Convert degrees to radians.\n     fn to_radians(self) -> Self;\n }\n \n-/// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-pub trait FromStrRadix {\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-    type Err;\n-\n-    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n-    #[allow(deprecated)]\n-    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n-}\n-\n-/// A utility function that just calls `FromStrRadix::from_str_radix`.\n-#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use e.g. i32::from_str_radix\")]\n-#[allow(deprecated)]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n-                                       -> Result<T, T::Err> {\n-    FromStrRadix::from_str_radix(str, radix)\n-}\n-\n-macro_rules! from_str_radix_float_impl {\n-    ($T:ty) => {\n+macro_rules! from_str_float_impl {\n+    ($T:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n             type Err = ParseFloatError;\n@@ -2827,265 +1367,113 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n+            /// `Err(ParseFloatError)` if the string did not represent a valid\n+            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                from_str_radix(src, 10)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseFloatError;\n-\n-            /// Converts a string in a given base to a float.\n-            ///\n-            /// Due to possible conflicts, this function does **not** accept\n-            /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-            /// does it recognize exponents of any kind.\n-            ///\n-            /// Leading and trailing whitespace represent an error.\n-            ///\n-            /// # Arguments\n-            ///\n-            /// * src - A string\n-            /// * radix - The base to use. Must lie in the range [2 .. 36]\n-            ///\n-            /// # Return value\n-            ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseFloatError> {\n-                use self::FloatErrorKind::*;\n-                use self::ParseFloatError as PFE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n-\n-                // Special values\n-                match src {\n-                    \"inf\"   => return Ok(Float::infinity()),\n-                    \"-inf\"  => return Ok(Float::neg_infinity()),\n-                    \"NaN\"   => return Ok(Float::nan()),\n-                    _       => {},\n-                }\n-\n-                let (is_positive, src) =  match src.slice_shift_char() {\n-                    None             => return Err(PFE { kind: Empty }),\n-                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n-                    Some(('-', src)) => (false, src),\n-                    Some((_, _))     => (true,  src),\n-                };\n-\n-                // The significand to accumulate\n-                let mut sig = if is_positive { 0.0 } else { -0.0 };\n-                // Necessary to detect overflow\n-                let mut prev_sig = sig;\n-                let mut cs = src.chars().enumerate();\n-                // Exponent prefix and exponent index offset\n-                let mut exp_info = None::<(char, usize)>;\n-\n-                // Parse the integer part of the significand\n-                for (i, c) in cs.by_ref() {\n-                    match c.to_digit(radix) {\n-                        Some(digit) => {\n-                            // shift significand one digit left\n-                            sig = sig * (radix as $T);\n-\n-                            // add/subtract current digit depending on sign\n-                            if is_positive {\n-                                sig = sig + ((digit as isize) as $T);\n-                            } else {\n-                                sig = sig - ((digit as isize) as $T);\n-                            }\n-\n-                            // Detect overflow by comparing to last value, except\n-                            // if we've not seen any non-zero digits.\n-                            if prev_sig != 0.0 {\n-                                if is_positive && sig <= prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig >= prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-\n-                                // Detect overflow by reversing the shift-and-add process\n-                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                    { return Ok(Float::neg_infinity()); }\n-                            }\n-                            prev_sig = sig;\n-                        },\n-                        None => match c {\n-                            'e' | 'E' | 'p' | 'P' => {\n-                                exp_info = Some((c, i + 1));\n-                                break;  // start of exponent\n-                            },\n-                            '.' => {\n-                                break;  // start of fractional part\n-                            },\n-                            _ => {\n-                                return Err(PFE { kind: Invalid });\n-                            },\n-                        },\n-                    }\n-                }\n-\n-                // If we are not yet at the exponent parse the fractional\n-                // part of the significand\n-                if exp_info.is_none() {\n-                    let mut power = 1.0;\n-                    for (i, c) in cs.by_ref() {\n-                        match c.to_digit(radix) {\n-                            Some(digit) => {\n-                                // Decrease power one order of magnitude\n-                                power = power / (radix as $T);\n-                                // add/subtract current digit depending on sign\n-                                sig = if is_positive {\n-                                    sig + (digit as $T) * power\n-                                } else {\n-                                    sig - (digit as $T) * power\n-                                };\n-                                // Detect overflow by comparing to last value\n-                                if is_positive && sig < prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig > prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-                                prev_sig = sig;\n-                            },\n-                            None => match c {\n-                                'e' | 'E' | 'p' | 'P' => {\n-                                    exp_info = Some((c, i + 1));\n-                                    break; // start of exponent\n-                                },\n-                                _ => {\n-                                    return Err(PFE { kind: Invalid });\n-                                },\n-                            },\n-                        }\n-                    }\n-                }\n-\n-                // Parse and calculate the exponent\n-                let exp = match exp_info {\n-                    Some((c, offset)) => {\n-                        let base = match c {\n-                            'E' | 'e' if radix == 10 => 10.0,\n-                            'P' | 'p' if radix == 16 => 2.0,\n-                            _ => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        // Parse the exponent as decimal integer\n-                        let src = &src[offset..];\n-                        let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, src.parse::<usize>()),\n-                            Some(('+', src)) => (true,  src.parse::<usize>()),\n-                            Some((_, _))     => (true,  src.parse::<usize>()),\n-                            None             => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        match (is_positive, exp) {\n-                            (true,  Ok(exp)) => base.powi(exp as i32),\n-                            (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n-                        }\n-                    },\n-                    None => 1.0, // no exponent\n-                };\n-\n-                Ok(sig * exp)\n+                $T::from_str_radix(src, 10)\n             }\n         }\n     }\n }\n-from_str_radix_float_impl! { f32 }\n-from_str_radix_float_impl! { f64 }\n+from_str_float_impl!(f32);\n+from_str_float_impl!(f64);\n \n macro_rules! from_str_radix_int_impl {\n-    ($T:ty) => {\n+    ($($T:ident)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n         impl FromStr for $T {\n             type Err = ParseIntError;\n-            #[inline]\n             fn from_str(src: &str) -> Result<$T, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n+    )*}\n+}\n+from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[allow(deprecated)]\n-        impl FromStrRadix for $T {\n-            type Err = ParseIntError;\n-            fn from_str_radix(src: &str, radix: u32)\n-                              -> Result<$T, ParseIntError> {\n-                use self::IntErrorKind::*;\n-                use self::ParseIntError as PIE;\n-                assert!(radix >= 2 && radix <= 36,\n-                       \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n-                       radix);\n-\n-                let is_signed_ty = (0 as $T) > Int::min_value();\n-\n-                match src.slice_shift_char() {\n-                    Some(('-', \"\")) => Err(PIE { kind: Empty }),\n-                    Some(('-', src)) if is_signed_ty => {\n-                        // The number is negative\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                            result = match result.checked_sub(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Underflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    Some((_, _)) => {\n-                        // The number is signed\n-                        let mut result = 0;\n-                        for c in src.chars() {\n-                            let x = match c.to_digit(radix) {\n-                                Some(x) => x,\n-                                None => return Err(PIE { kind: InvalidDigit }),\n-                            };\n-                            result = match result.checked_mul(radix as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                            result = match result.checked_add(x as $T) {\n-                                Some(result) => result,\n-                                None => return Err(PIE { kind: Overflow }),\n-                            };\n-                        }\n-                        Ok(result)\n-                    },\n-                    None => Err(ParseIntError { kind: Empty }),\n-                }\n+#[doc(hidden)]\n+trait FromStrRadixHelper: PartialOrd + Copy {\n+    fn min_value() -> Self;\n+    fn from_u32(u: u32) -> Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_sub(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl FromStrRadixHelper for $t {\n+        fn min_value() -> Self { <$t>::min_value() }\n+        fn from_u32(u: u32) -> Self { u as $t }\n+        fn checked_mul(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_mul(*self, other as $t)\n+        }\n+        fn checked_sub(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_sub(*self, other as $t)\n+        }\n+        fn checked_add(&self, other: u32) -> Option<Self> {\n+            <$t>::checked_add(*self, other as $t)\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n+                                         -> Result<T, ParseIntError> {\n+    use self::IntErrorKind::*;\n+    use self::ParseIntError as PIE;\n+    assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let is_signed_ty = T::from_u32(0) > T::min_value();\n+\n+    match src.slice_shift_char() {\n+        Some(('-', \"\")) => Err(PIE { kind: Empty }),\n+        Some(('-', src)) if is_signed_ty => {\n+            // The number is negative\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n+                result = match result.checked_sub(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Underflow }),\n+                };\n             }\n-        }\n+            Ok(result)\n+        },\n+        Some((_, _)) => {\n+            // The number is signed\n+            let mut result = T::from_u32(0);\n+            for c in src.chars() {\n+                let x = match c.to_digit(radix) {\n+                    Some(x) => x,\n+                    None => return Err(PIE { kind: InvalidDigit }),\n+                };\n+                result = match result.checked_mul(radix) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+                result = match result.checked_add(x) {\n+                    Some(result) => result,\n+                    None => return Err(PIE { kind: Overflow }),\n+                };\n+            }\n+            Ok(result)\n+        },\n+        None => Err(ParseIntError { kind: Empty }),\n     }\n }\n-from_str_radix_int_impl! { isize }\n-from_str_radix_int_impl! { i8 }\n-from_str_radix_int_impl! { i16 }\n-from_str_radix_int_impl! { i32 }\n-from_str_radix_int_impl! { i64 }\n-from_str_radix_int_impl! { usize }\n-from_str_radix_int_impl! { u8 }\n-from_str_radix_int_impl! { u16 }\n-from_str_radix_int_impl! { u32 }\n-from_str_radix_int_impl! { u64 }\n \n /// An error which can be returned when parsing an integer.\n #[derive(Debug, Clone, PartialEq)]\n@@ -3121,11 +1509,10 @@ impl fmt::Display for ParseIntError {\n \n /// An error which can be returned when parsing a float.\n #[derive(Debug, Clone, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseFloatError { kind: FloatErrorKind }\n+pub struct ParseFloatError { pub kind: FloatErrorKind }\n \n #[derive(Debug, Clone, PartialEq)]\n-enum FloatErrorKind {\n+pub enum FloatErrorKind {\n     Empty,\n     Invalid,\n }"}, {"sha": "b7ca497db18637bcd0d1d83a9c1d945a550b5b24", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,8 +15,6 @@ use super::Wrapping;\n \n use ops::*;\n \n-use intrinsics::{overflowing_add, overflowing_sub, overflowing_mul};\n-\n use intrinsics::{i8_add_with_overflow, u8_add_with_overflow};\n use intrinsics::{i16_add_with_overflow, u16_add_with_overflow};\n use intrinsics::{i32_add_with_overflow, u32_add_with_overflow};\n@@ -32,14 +30,6 @@ use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n use ::{i8,i16,i32,i64};\n \n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n-pub trait WrappingOps {\n-    fn wrapping_add(self, rhs: Self) -> Self;\n-    fn wrapping_sub(self, rhs: Self) -> Self;\n-    fn wrapping_mul(self, rhs: Self) -> Self;\n-}\n-\n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n@@ -99,27 +89,6 @@ sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n-        impl WrappingOps for $t {\n-            #[inline(always)]\n-            fn wrapping_add(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_add(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_sub(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_sub(self, rhs)\n-                }\n-            }\n-            #[inline(always)]\n-            fn wrapping_mul(self, rhs: $t) -> $t {\n-                unsafe {\n-                    overflowing_mul(self, rhs)\n-                }\n-            }\n-        }\n-\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;"}, {"sha": "d1bc24bd9baa5d433906b708c25986302c7c81f4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -551,25 +551,6 @@ impl<T> Option<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n     }\n \n-    /// Returns a consuming iterator over the possibly contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x = Some(\"string\");\n-    /// let v: Vec<&str> = x.into_iter().collect();\n-    /// assert_eq!(v, [\"string\"]);\n-    ///\n-    /// let x = None;\n-    /// let v: Vec<&str> = x.into_iter().collect();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { inner: Item { opt: self } }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n@@ -770,6 +751,30 @@ impl<T> Default for Option<T> {\n     fn default() -> Option<T> { None }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> IntoIterator for Option<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Some(\"string\");\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert_eq!(v, [\"string\"]);\n+    ///\n+    /// let x = None;\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[inline]\n+    fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { inner: Item { opt: self } }\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "a4d529ad47d09036fe32366fd9bd3150db89f4a6", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -37,11 +37,10 @@ pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use convert::{AsRef, AsMut, Into, From};\n+pub use default::Default;\n+pub use iter::IntoIterator;\n pub use iter::{Iterator, DoubleEndedIterator, Extend, ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n pub use result::Result::{self, Ok, Err};\n pub use slice::SliceExt;\n pub use str::StrExt;\n-\n-#[allow(deprecated)] pub use slice::AsSlice;\n-#[allow(deprecated)] pub use str::Str;"}, {"sha": "e909946ece40221ffa548666aed832ce44b2e9fd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -234,8 +234,6 @@ use fmt;\n use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n-#[allow(deprecated)]\n-use slice::AsSlice;\n use slice;\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n@@ -547,25 +545,6 @@ impl<T, E> Result<T, E> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n \n-    /// Returns a consuming iterator over the possibly contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x: Result<u32, &str> = Ok(5);\n-    /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, [5]);\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"nothing!\");\n-    /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, []);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        IntoIter { inner: self.ok() }\n-    }\n-\n     ////////////////////////////////////////////////////////////////////////\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n@@ -787,23 +766,27 @@ impl<T: fmt::Debug, E> Result<T, E> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"core\",\n-           reason = \"waiting on the stability of the trait itself\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use inherent method instead\")]\n-#[allow(deprecated)]\n-impl<T, E> AsSlice<T> for Result<T, E> {\n-    /// Converts from `Result<T, E>` to `&[T]` (without copying)\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, E> IntoIterator for Result<T, E> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Result<u32, &str> = Ok(5);\n+    /// let v: Vec<u32> = x.into_iter().collect();\n+    /// assert_eq!(v, [5]);\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"nothing!\");\n+    /// let v: Vec<u32> = x.into_iter().collect();\n+    /// assert_eq!(v, []);\n+    /// ```\n     #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        match *self {\n-            Ok(ref x) => slice::ref_slice(x),\n-            Err(_) => {\n-                // work around lack of implicit coercion from fixed-size array to slice\n-                let emp: &[_] = &[];\n-                emp\n-            }\n-        }\n+    fn into_iter(self) -> IntoIter<T> {\n+        IntoIter { inner: self.ok() }\n     }\n }\n "}, {"sha": "1e96d761d405a948e3db12b02f4f45f18ca27c19", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -51,7 +51,7 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use mem::size_of;\n-use marker::{Send, Sized, Sync, self};\n+use marker::{Send, Sync, self};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -595,37 +595,6 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n // Common traits\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Data that is viewable as a slice.\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by slice syntax\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::convert::AsRef<[T]> instead\")]\n-pub trait AsSlice<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { self }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n-    #[inline(always)]\n-    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n-}\n-\n-#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-#[allow(deprecated)]\n-impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n-    #[inline(always)]\n-    fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Default for &'a [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4d343ea0f1e42c37712371a6b2fc47a70d72d93b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,7 +25,6 @@ use default::Default;\n use fmt;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n-use marker::Sized;\n use mem;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -1463,30 +1462,6 @@ mod traits {\n     }\n }\n \n-/// Any string that can be represented as a slice\n-#[unstable(feature = \"core\",\n-           reason = \"Instead of taking this bound generically, this trait will be \\\n-                     replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n-                     a more generic conversion trait\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::convert::AsRef<str> instead\")]\n-pub trait Str {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a str;\n-}\n-\n-#[allow(deprecated)]\n-impl Str for str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str { self }\n-}\n-\n-#[allow(deprecated)]\n-impl<'a, S: ?Sized> Str for &'a S where S: Str {\n-    #[inline]\n-    fn as_slice(&self) -> &str { Str::as_slice(*self) }\n-}\n-\n /// Methods for string slices\n #[allow(missing_docs)]\n #[doc(hidden)]"}, {"sha": "e0d396c68b4c4847cb572580b497066de3a00689", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -110,8 +110,6 @@ fn test_partial_max() {\n \n #[test]\n fn test_user_defined_eq() {\n-    use core::num::SignedInt;\n-\n     // Our type.\n     struct SketchyNum {\n         num : isize"}, {"sha": "2866c193c3b1546a99f10736c0f4d11bade8343a", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,7 +11,6 @@\n use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n-use core::num::SignedInt;\n use core::usize;\n use core::cmp;\n \n@@ -783,16 +782,6 @@ fn test_range_step() {\n     assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n }\n \n-#[test]\n-fn test_range_step_inclusive() {\n-    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<isize>>(), [0, 5, 10, 15, 20]);\n-    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<isize>>(), [20, 15, 10, 5, 0]);\n-    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n-    assert_eq!(range_step_inclusive(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<isize>>(), []);\n-    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<isize>>(), [200]);\n-}\n-\n #[test]\n fn test_reverse() {\n     let mut ys = [1, 2, 3, 4, 5];"}, {"sha": "e0e8e46af6cdde2a241b352e7d427013866a9ce9", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,8 +10,8 @@\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n+\n #![feature(box_syntax)]\n-#![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n #![feature(core)]\n@@ -21,13 +21,11 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(hash)]\n-#![feature(io)]\n-#![feature(collections)]\n #![feature(debug_builders)]\n #![feature(unique)]\n #![feature(step_by)]\n #![feature(slice_patterns)]\n-#![allow(deprecated)] // rand\n+#![feature(float_from_str_radix)]\n \n extern crate core;\n extern crate test;"}, {"sha": "b1c8aec3c35e9798b9e30e030001b16e4139ee17", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! int_module { ($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n     use core::isize;\n-    use core::num::{FromStrRadix, Int, SignedInt};\n     use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n \n@@ -129,30 +128,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n         assert!(isize::MIN.checked_div(-1) == None);\n     }\n \n@@ -180,26 +179,26 @@ mod tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n+        assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+        assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+        assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+        assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+        assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+        assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+        assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+        assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n     }\n \n     #[test]"}, {"sha": "85ca547da85260bfda02b72c8644362ae853e46f", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,6 @@\n \n use core::cmp::PartialEq;\n use core::fmt::Debug;\n-use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n \n@@ -32,18 +31,12 @@ mod u64;\n \n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n      + Rem<Output=T> + Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n@@ -56,33 +49,33 @@ mod test {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n-    use core::num::from_str_radix;\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix(\"1000\", 10).ok();\n+        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix(\"80000\", 10).ok();\n+        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10).ok();\n+        let s = \"10000000000000000000000000000000000000000\";\n+        let f : Option<f32> = f32::from_str_radix(s, 10).ok();\n         assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = from_str_radix(\"1e40\", 10).ok();\n+        let fe : Option<f32> = f32::from_str_radix(\"1e40\", 10).ok();\n         assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]\n     fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10).ok();\n+        let x1 : Option<f64> = f64::from_str_radix(\"-123.456\", 10).ok();\n         assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix(\"123.456\", 10).ok();\n+        let x2 : Option<f32> = f32::from_str_radix(\"123.456\", 10).ok();\n         assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10).ok();\n+        let x3 : Option<f32> = f32::from_str_radix(\"-0.0\", 10).ok();\n         assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix(\"0.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"0.0\", 10).ok();\n         assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix(\"1.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"1.0\", 10).ok();\n         assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10).ok();\n+        let x5 : Option<f32> = f32::from_str_radix(\"-1.0\", 10).ok();\n         assert_eq!(x5, Some(-1.0));\n     }\n "}, {"sha": "1712345f9d9a7c8316b04f1e8e85e3980873a0fd", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n-    use core::num::Int;\n     use num;\n     use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n \n@@ -97,30 +96,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n     }\n }\n "}, {"sha": "5782c57834eedc6f14ab226aff6ca7f35b1a8b33", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -91,7 +91,6 @@\n \n #![deny(missing_docs)]\n #![feature(staged_api)]\n-#![feature(str_words)]\n #![feature(str_char)]\n #![cfg_attr(test, feature(rustc_private))]\n \n@@ -771,7 +770,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // Normalize desc to contain words separated by one space character\n         let mut desc_normalized_whitespace = String::new();\n-        for word in desc.words() {\n+        for word in desc.split_whitespace() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push(' ');\n         }"}, {"sha": "4fbcdaa378e25cef101fcc258c5b695266fa536a", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -3536,6 +3536,30 @@ pub mod consts {\n             pub const IPV6_DROP_MEMBERSHIP: c_int = 21;\n \n             pub const TCP_NODELAY: c_int = 1;\n+            pub const TCP_MAXSEG: c_int = 2;\n+            pub const TCP_CORK: c_int = 3;\n+            pub const TCP_KEEPIDLE: c_int = 4;\n+            pub const TCP_KEEPINTVL: c_int = 5;\n+            pub const TCP_KEEPCNT: c_int = 6;\n+            pub const TCP_SYNCNT: c_int = 7;\n+            pub const TCP_LINGER2: c_int = 8;\n+            pub const TCP_DEFER_ACCEPT: c_int = 9;\n+            pub const TCP_WINDOW_CLAMP: c_int = 10;\n+            pub const TCP_INFO: c_int = 11;\n+            pub const TCP_QUICKACK: c_int = 12;\n+            pub const TCP_CONGESTION: c_int = 13;\n+            pub const TCP_MD5SIG: c_int = 14;\n+            pub const TCP_COOKIE_TRANSACTIONS: c_int = 15;\n+            pub const TCP_THIN_LINEAR_TIMEOUTS: c_int = 16;\n+            pub const TCP_THIN_DUPACK: c_int = 17;\n+            pub const TCP_USER_TIMEOUT: c_int = 18;\n+            pub const TCP_REPAIR: c_int = 19;\n+            pub const TCP_REPAIR_QUEUE: c_int = 20;\n+            pub const TCP_QUEUE_SEQ: c_int = 21;\n+            pub const TCP_REPAIR_OPTIONS: c_int = 22;\n+            pub const TCP_FASTOPEN: c_int = 23;\n+            pub const TCP_TIMESTAMP: c_int = 24;\n+\n             pub const SOL_SOCKET: c_int = 1;\n \n             pub const SO_DEBUG: c_int = 1;"}, {"sha": "9cd3b74e1552d95adef258408645af0715a20bd6", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,8 +11,6 @@\n //! The ChaCha random number generator.\n \n use core::prelude::*;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key"}, {"sha": "4ea81b8e61938b4f9c5f2e54f369a754750ee644", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -18,7 +18,7 @@\n //! that do not need to record state.\n \n use core::prelude::*;\n-use core::num::{Float, Int};\n+use core::num::Float;\n use core::marker::PhantomData;\n \n use {Rng, Rand};"}, {"sha": "4916e305b70e369141ad8e7743fe59aebdc78865", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,8 +13,6 @@\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::PartialOrd;\n-use core::num::Int;\n-use core::num::wrapping::WrappingOps;\n \n use Rng;\n use distributions::{Sample, IndependentSample};\n@@ -73,7 +71,7 @@ pub trait SampleRange {\n }\n \n macro_rules! integer_impl {\n-    ($ty:ty, $unsigned:ty) => {\n+    ($ty:ident, $unsigned:ident) => {\n         impl SampleRange for $ty {\n             // we play free and fast with unsigned vs signed here\n             // (when $ty is signed), but that's fine, since the\n@@ -83,7 +81,7 @@ macro_rules! integer_impl {\n \n             fn construct_range(low: $ty, high: $ty) -> Range<$ty> {\n                 let range = (high as $unsigned).wrapping_sub(low as $unsigned);\n-                let unsigned_max: $unsigned = Int::max_value();\n+                let unsigned_max: $unsigned = $unsigned::max_value();\n \n                 // this is the largest number that fits into $unsigned\n                 // that `range` divides evenly, so, if we've sampled\n@@ -148,7 +146,6 @@ float_impl! { f64 }\n \n #[cfg(test)]\n mod tests {\n-    use std::num::Int;\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range as Range;\n@@ -168,11 +165,11 @@ mod tests {\n     fn test_integers() {\n         let mut rng = ::test::rng();\n         macro_rules! t {\n-            ($($ty:ty),*) => {{\n+            ($($ty:ident),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n                                             (10, 127),\n-                                            (Int::min_value(), Int::max_value())];\n+                                            ($ty::min_value(), $ty::max_value())];\n                    for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in 0..1000 {"}, {"sha": "ea084b2816dd1f349e8a38ff0073841a91cfb498", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,7 +14,6 @@\n use core::prelude::*;\n \n use {Rng, SeedableRng};\n-use core::default::Default;\n \n /// How many bytes of entropy the underling RNG is allowed to generate\n /// before it is reseeded.\n@@ -126,7 +125,6 @@ mod test {\n \n     use core::iter::{order, repeat};\n     use super::{ReseedingRng, ReseedWithDefault};\n-    use std::default::Default;\n     use {SeedableRng, Rng};\n \n     struct Counter {"}, {"sha": "b7938397038b490d6b02c4b0092ad4ad8b62966a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -836,7 +836,6 @@ pub mod writer {\n     use std::io::prelude::*;\n     use std::io::{self, SeekFrom, Cursor};\n     use std::slice::bytes;\n-    use std::num::ToPrimitive;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n@@ -1070,10 +1069,10 @@ pub mod writer {\n     impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if let Some(v) = v.to_u8() {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v)\n-            } else if let Some(v) = v.to_u32() {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v)\n+            if v as u8 as usize == v {\n+                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n+            } else if v as u32 as usize == v {\n+                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n                                    &format!(\"length or variant id too big: {}\",\n@@ -1101,21 +1100,24 @@ pub mod writer {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            match v.to_u32() {\n-                Some(v) => self.emit_u32(v),\n-                None => self.wr_tagged_raw_u64(EsU64 as usize, v)\n+            if v as u32 as u64 == v {\n+                self.emit_u32(v as u32)\n+            } else {\n+                self.wr_tagged_raw_u64(EsU64 as usize, v)\n             }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            match v.to_u16() {\n-                Some(v) => self.emit_u16(v),\n-                None => self.wr_tagged_raw_u32(EsU32 as usize, v)\n+            if v as u16 as u32 == v {\n+                self.emit_u16(v as u16)\n+            } else {\n+                self.wr_tagged_raw_u32(EsU32 as usize, v)\n             }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            match v.to_u8() {\n-                Some(v) => self.emit_u8(v),\n-                None => self.wr_tagged_raw_u16(EsU16 as usize, v)\n+            if v as u8 as u16 == v {\n+                self.emit_u8(v as u8)\n+            } else {\n+                self.wr_tagged_raw_u16(EsU16 as usize, v)\n             }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n@@ -1126,21 +1128,24 @@ pub mod writer {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            match v.to_i32() {\n-                Some(v) => self.emit_i32(v),\n-                None => self.wr_tagged_raw_i64(EsI64 as usize, v)\n+            if v as i32 as i64 == v {\n+                self.emit_i32(v as i32)\n+            } else {\n+                self.wr_tagged_raw_i64(EsI64 as usize, v)\n             }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            match v.to_i16() {\n-                Some(v) => self.emit_i16(v),\n-                None => self.wr_tagged_raw_i32(EsI32 as usize, v)\n+            if v as i16 as i32 == v {\n+                self.emit_i16(v as i16)\n+            } else {\n+                self.wr_tagged_raw_i32(EsI32 as usize, v)\n             }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            match v.to_i8() {\n-                Some(v) => self.emit_i8(v),\n-                None => self.wr_tagged_raw_i16(EsI16 as usize, v)\n+            if v as i8 as i16 == v {\n+                self.emit_i8(v as i8)\n+            } else {\n+                self.wr_tagged_raw_i16(EsI16 as usize, v)\n             }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {"}, {"sha": "33ecc0ce205074b347f82d939949e5e66ce33266", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -208,7 +208,7 @@ fn main() {\n     unsafe { f(); }\n }\n \n-See also http://doc.rust-lang.org/book/unsafe-code.html\n+See also http://doc.rust-lang.org/book/unsafe.html\n \"##,\n \n E0152: r##\""}, {"sha": "9093b3b9f5c91b8169b9a6c198c96cbbb248036a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -38,7 +38,6 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(path_ext)]\n-#![feature(str_words)]\n #![feature(str_char)]\n #![feature(into_cow)]\n #![feature(slice_patterns)]\n@@ -69,6 +68,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n+#[macro_use]\n+mod macros;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -142,6 +144,7 @@ pub mod util {\n     pub mod ppaux;\n     pub mod nodemap;\n     pub mod lev_distance;\n+    pub mod num;\n }\n \n pub mod lib {"}, {"sha": "ed764ebd9f95dd4e27b579342fc0f4c66e77a486", "filename": "src/librustc/macros.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "06a40f1dd277da124749bebf2b9ede7b975b18fa", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -116,37 +116,39 @@ pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-#[repr(usize)]\n-pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n-    tag_ast = 0x50,\n-\n-    tag_tree = 0x51,\n-\n-    tag_id_range = 0x52,\n-\n-    tag_table = 0x53,\n-    // GAP 0x54, 0x55\n-    tag_table_def = 0x56,\n-    tag_table_node_type = 0x57,\n-    tag_table_item_subst = 0x58,\n-    tag_table_freevars = 0x59,\n-    tag_table_tcache = 0x5a,\n-    tag_table_param_defs = 0x5b,\n-    tag_table_mutbl = 0x5c,\n-    tag_table_last_use = 0x5d,\n-    tag_table_spill = 0x5e,\n-    tag_table_method_map = 0x5f,\n-    tag_table_vtable_map = 0x60,\n-    tag_table_adjustments = 0x61,\n-    tag_table_moves_map = 0x62,\n-    tag_table_capture_map = 0x63,\n-    tag_table_closure_tys = 0x64,\n-    tag_table_closure_kinds = 0x65,\n-    tag_table_upvar_capture_map = 0x66,\n-    tag_table_capture_modes = 0x67,\n-    tag_table_object_cast_map = 0x68,\n-    tag_table_const_qualif = 0x69,\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    #[repr(usize)]\n+    pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n+        tag_ast = 0x50,\n+\n+        tag_tree = 0x51,\n+\n+        tag_id_range = 0x52,\n+\n+        tag_table = 0x53,\n+        // GAP 0x54, 0x55\n+        tag_table_def = 0x56,\n+        tag_table_node_type = 0x57,\n+        tag_table_item_subst = 0x58,\n+        tag_table_freevars = 0x59,\n+        tag_table_tcache = 0x5a,\n+        tag_table_param_defs = 0x5b,\n+        tag_table_mutbl = 0x5c,\n+        tag_table_last_use = 0x5d,\n+        tag_table_spill = 0x5e,\n+        tag_table_method_map = 0x5f,\n+        tag_table_vtable_map = 0x60,\n+        tag_table_adjustments = 0x61,\n+        tag_table_moves_map = 0x62,\n+        tag_table_capture_map = 0x63,\n+        tag_table_closure_tys = 0x64,\n+        tag_table_closure_kinds = 0x65,\n+        tag_table_upvar_capture_map = 0x66,\n+        tag_table_capture_modes = 0x67,\n+        tag_table_object_cast_map = 0x68,\n+        tag_table_const_qualif = 0x69,\n+    }\n }\n \n pub const tag_item_trait_item_sort: usize = 0x70;"}, {"sha": "1f18b13fc46fe26fff04ab9c29d40db0d2f499fd", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -68,11 +68,13 @@ pub enum LinkagePreference {\n     RequireStatic,\n }\n \n-#[derive(Copy, Clone, PartialEq, FromPrimitive)]\n-pub enum NativeLibraryKind {\n-    NativeStatic,    // native static library (.a archive)\n-    NativeFramework, // OSX-specific\n-    NativeUnknown,   // default way to specify a dynamic library\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq)]\n+    pub enum NativeLibraryKind {\n+        NativeStatic,    // native static library (.a archive)\n+        NativeFramework, // OSX-specific\n+        NativeUnknown,   // default way to specify a dynamic library\n+    }\n }\n \n // Where a crate came from on the local filesystem. One of these two options"}, {"sha": "cbd542567709c13f9b114d9949b1fc62784de9d3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -35,7 +35,6 @@ use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n use std::io;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::slice::bytes;\n use std::str;\n@@ -1349,7 +1348,7 @@ pub fn get_native_libraries(cdata: Cmd)\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibraryKind =\n-            FromPrimitive::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n+            cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n         let name = name_doc.as_str().to_string();\n         result.push((kind, name));\n         true\n@@ -1359,7 +1358,7 @@ pub fn get_native_libraries(cdata: Cmd)\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n     reader::maybe_get_doc(rbml::Doc::new(data), tag_plugin_registrar_fn)\n-        .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n+        .map(|doc| reader::doc_as_u32(doc))\n }\n \n pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n@@ -1407,7 +1406,7 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     let mut result = Vec::new();\n     reader::tagged_docs(items, tag_lang_items_missing, |missing_docs| {\n         let item: lang_items::LangItem =\n-            FromPrimitive::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n+            lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n         result.push(item);\n         true\n     });"}, {"sha": "bbb2452ca29ee84d7334c1962b52e224859b849e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -692,11 +692,16 @@ pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n \n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data = match ar.read(METADATA_FILENAME) {\n-            Some(data) => data as *const [u8],\n-            None => {\n-                debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                return None;\n+        let data = {\n+            let section = ar.iter().find(|sect| {\n+                sect.name() == Some(METADATA_FILENAME)\n+            });\n+            match section {\n+                Some(s) => s.data() as *const [u8],\n+                None => {\n+                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                    return None;\n+                }\n             }\n         };\n "}, {"sha": "ee8373279d976f9f4d95c76cbba2a566121b93f2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -41,7 +41,6 @@ use syntax;\n use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n-use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::fmt::Debug;\n \n@@ -1713,7 +1712,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n-        let decoded_tag: Option<c::astencode_tag> = FromPrimitive::from_usize(tag);\n+        let tag = tag as u32;\n+        let decoded_tag: Option<c::astencode_tag> = c::astencode_tag::from_u32(tag);\n         match decoded_tag {\n             None => {\n                 dcx.tcx.sess.bug("}, {"sha": "2c6ffb3281fcb4922cd173710578565938bf65d3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -20,6 +20,7 @@ use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n use middle::astconv_util::ast_ty_to_prim_ty;\n+use util::num::ToPrimitive;\n \n use syntax::ast::{self, Expr};\n use syntax::codemap::Span;\n@@ -30,7 +31,6 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n-use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};"}, {"sha": "c77a43e75cdc089a3dc70f8396bae1675f27619f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -36,7 +36,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n use std::iter::Enumerate;\n-use std::num::FromPrimitive;\n use std::slice;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -46,9 +45,12 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[derive(Copy, Clone, FromPrimitive, PartialEq, Eq, Hash)]\n-pub enum LangItem {\n-    $($variant),*\n+\n+enum_from_u32! {\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    pub enum LangItem {\n+        $($variant,)*\n+    }\n }\n \n pub struct LanguageItems {\n@@ -71,7 +73,7 @@ impl LanguageItems {\n     }\n \n     pub fn item_name(index: usize) -> &'static str {\n-        let item: Option<LangItem> = FromPrimitive::from_usize(index);\n+        let item: Option<LangItem> = LangItem::from_u32(index as u32);\n         match item {\n             $( Some($variant) => $name, )*\n             None => \"???\""}, {"sha": "2c94399f92138c981f0ca805b039bbb7f404cd26", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -63,6 +63,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n+use util::num::ToPrimitive;\n \n use arena::TypedArena;\n use std::borrow::{Borrow, Cow};\n@@ -71,7 +72,6 @@ use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n use std::mem;\n-use std::num::ToPrimitive;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;"}, {"sha": "f4ea069447fdfc5124a232cac8fe6cea9f5644ee", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -418,7 +418,7 @@ macro_rules! options {\n                       -> bool {\n             match v {\n                 Some(s) => {\n-                    for s in s.words() {\n+                    for s in s.split_whitespace() {\n                         slot.push(s.to_string());\n                     }\n                     true\n@@ -431,7 +431,7 @@ macro_rules! options {\n                       -> bool {\n             match v {\n                 Some(s) => {\n-                    let v = s.words().map(|s| s.to_string()).collect();\n+                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n                     *slot = Some(v);\n                     true\n                 },"}, {"sha": "da04976a96a37234b4f1cfaf05af3b622ce865ab", "filename": "src/librustc/util/num.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Futil%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc%2Futil%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnum.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait ToPrimitive {\n+    fn to_i8(&self) -> Option<i8>;\n+    fn to_i16(&self) -> Option<i16>;\n+    fn to_i32(&self) -> Option<i32>;\n+    fn to_i64(&self) -> Option<i64>;\n+    fn to_u8(&self) -> Option<u8>;\n+    fn to_u16(&self) -> Option<u16>;\n+    fn to_u32(&self) -> Option<u32>;\n+    fn to_u64(&self) -> Option<u64>;\n+}\n+\n+impl ToPrimitive for i64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self < i8::min_value() as i64 || *self > i8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i8)\n+        }\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self < i16::min_value() as i64 || *self > i16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i16)\n+        }\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self < i32::min_value() as i64 || *self > i32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as i32)\n+        }\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        Some(*self)\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self < 0 || *self > u8::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u8)\n+        }\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self < 0 || *self > u16::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u16)\n+        }\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self < 0 || *self > u32::max_value() as i64 {\n+            None\n+        } else {\n+            Some(*self as u32)\n+        }\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        if *self < 0 {None} else {Some(*self as u64)}\n+    }\n+}\n+\n+impl ToPrimitive for u64 {\n+    fn to_i8(&self) -> Option<i8> {\n+        if *self > i8::max_value() as u64 {None} else {Some(*self as i8)}\n+    }\n+    fn to_i16(&self) -> Option<i16> {\n+        if *self > i16::max_value() as u64 {None} else {Some(*self as i16)}\n+    }\n+    fn to_i32(&self) -> Option<i32> {\n+        if *self > i32::max_value() as u64 {None} else {Some(*self as i32)}\n+    }\n+    fn to_i64(&self) -> Option<i64> {\n+        if *self > i64::max_value() as u64 {None} else {Some(*self as i64)}\n+    }\n+    fn to_u8(&self) -> Option<u8> {\n+        if *self > u8::max_value() as u64 {None} else {Some(*self as u8)}\n+    }\n+    fn to_u16(&self) -> Option<u16> {\n+        if *self > u16::max_value() as u64 {None} else {Some(*self as u16)}\n+    }\n+    fn to_u32(&self) -> Option<u32> {\n+        if *self > u32::max_value() as u64 {None} else {Some(*self as u32)}\n+    }\n+    fn to_u64(&self) -> Option<u64> {\n+        Some(*self)\n+    }\n+}"}, {"sha": "37d784692fd0e48faf035d1168f6a78cba8e6b11", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,13 +11,14 @@\n //! A helper class for dealing with static archives\n \n use std::env;\n-use std::fs;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, Stdio};\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n+use rustc_llvm::archive_ro::ArchiveRO;\n \n use tempdir::TempDir;\n \n@@ -282,45 +283,61 @@ impl<'a> ArchiveBuilder<'a> {\n                       mut skip: F) -> io::Result<()>\n         where F: FnMut(&str) -> bool,\n     {\n-        let loc = TempDir::new(\"rsar\").unwrap();\n-\n-        // First, extract the contents of the archive to a temporary directory.\n-        // We don't unpack directly into `self.work_dir` due to the possibility\n-        // of filename collisions.\n-        let archive = env::current_dir().unwrap().join(archive);\n-        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               \"x\", Some(loc.path()), &[&archive]);\n+        let archive = match ArchiveRO::open(archive) {\n+            Some(ar) => ar,\n+            None => return Err(io::Error::new(io::ErrorKind::Other,\n+                                              \"failed to open archive\")),\n+        };\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // We move each file into `self.work_dir` under its new unique name.\n+        // We write each file into `self.work_dir` under its new unique name.\n         // The reason for this renaming is that archives are keyed off the name\n         // of the files, so if two files have the same name they will override\n         // one another in the archive (bad).\n         //\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = try!(fs::read_dir(loc.path()));\n-        for file in files {\n-            let file = try!(file).path();\n-            let filename = file.file_name().unwrap().to_str().unwrap();\n-            if skip(filename) { continue }\n+        for file in archive.iter() {\n+            let filename = match file.name() {\n+                Some(s) => s,\n+                None => continue,\n+            };\n             if filename.contains(\".SYMDEF\") { continue }\n+            if skip(filename) { continue }\n \n-            let filename = format!(\"r-{}-{}\", name, filename);\n-            // LLDB (as mentioned in back::link) crashes on filenames of exactly\n-            // 16 bytes in length. If we're including an object file with\n-            // exactly 16-bytes of characters, give it some prefix so that it's\n-            // not 16 bytes.\n-            let filename = if filename.len() == 16 {\n-                format!(\"lldb-fix-{}\", filename)\n-            } else {\n-                filename\n-            };\n-            let new_filename = self.work_dir.path().join(&filename[..]);\n-            try!(fs::rename(&file, &new_filename));\n-            self.members.push(PathBuf::from(filename));\n+            // An archive can contain files of the same name multiple times, so\n+            // we need to be sure to not have them overwrite one another when we\n+            // extract them. Consequently we need to find a truly unique file\n+            // name for us!\n+            let mut new_filename = String::new();\n+            for n in 0.. {\n+                let n = if n == 0 {String::new()} else {format!(\"-{}\", n)};\n+                new_filename = format!(\"r{}-{}-{}\", n, name, filename);\n+\n+                // LLDB (as mentioned in back::link) crashes on filenames of\n+                // exactly\n+                // 16 bytes in length. If we're including an object file with\n+                //    exactly 16-bytes of characters, give it some prefix so\n+                //    that it's not 16 bytes.\n+                new_filename = if new_filename.len() == 16 {\n+                    format!(\"lldb-fix-{}\", new_filename)\n+                } else {\n+                    new_filename\n+                };\n+\n+                let present = self.members.iter().filter_map(|p| {\n+                    p.file_name().and_then(|f| f.to_str())\n+                }).any(|s| s == new_filename);\n+                if !present {\n+                    break\n+                }\n+            }\n+            let dst = self.work_dir.path().join(&new_filename);\n+            try!(try!(File::create(&dst)).write_all(file.data()));\n+            self.members.push(PathBuf::from(new_filename));\n         }\n+\n         Ok(())\n     }\n }"}, {"sha": "22dea4757ed662a8942c198ab7ac0e7b5a38b655", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -46,6 +46,7 @@\n extern crate syntax;\n extern crate libc;\n extern crate serialize;\n+extern crate rustc_llvm;\n #[macro_use] extern crate log;\n \n pub mod abi;"}, {"sha": "9ed827da8b2e4de2194e8289b282b2b6f6c4e5a0", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,10 +12,7 @@\n //! use. This implementation is not intended for external use or for any use where security is\n //! important.\n \n-#![allow(deprecated)] // to_be32\n-\n use std::iter::repeat;\n-use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n \n@@ -61,10 +58,10 @@ impl ToBits for u64 {\n \n /// Adds the specified number of bytes to the bit count. panic!() if this would cause numeric\n /// overflow.\n-fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n+fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > T::zero() {\n+    if new_high_bits > 0 {\n         panic!(\"numeric overflow occurred.\")\n     }\n \n@@ -543,14 +540,14 @@ mod tests {\n     // A normal addition - no overflow occurs\n     #[test]\n     fn test_add_bytes_to_bits_ok() {\n-        assert!(super::add_bytes_to_bits::<u64>(100, 10) == 180);\n+        assert!(super::add_bytes_to_bits(100, 10) == 180);\n     }\n \n     // A simple failure case - adding 1 to the max value\n     #[test]\n     #[should_panic]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(u64::MAX, 1);\n+        super::add_bytes_to_bits(u64::MAX, 1);\n     }\n \n     struct Test {"}, {"sha": "c8f3e204c4e10d0488d7e89cac812dd6c8f6ac9c", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,15 +10,23 @@\n \n //! A wrapper around LLVM's archive (.a) code\n \n-use libc;\n use ArchiveRef;\n \n use std::ffi::CString;\n-use std::slice;\n use std::path::Path;\n+use std::slice;\n+use std::str;\n \n-pub struct ArchiveRO {\n-    ptr: ArchiveRef,\n+pub struct ArchiveRO { ptr: ArchiveRef }\n+\n+pub struct Iter<'a> {\n+    archive: &'a ArchiveRO,\n+    ptr: ::ArchiveIteratorRef,\n+}\n+\n+pub struct Child<'a> {\n+    name: Option<&'a str>,\n+    data: &'a [u8],\n }\n \n impl ArchiveRO {\n@@ -52,18 +60,9 @@ impl ArchiveRO {\n         }\n     }\n \n-    /// Reads a file in the archive\n-    pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n+    pub fn iter(&self) -> Iter {\n         unsafe {\n-            let mut size = 0 as libc::size_t;\n-            let file = CString::new(file).unwrap();\n-            let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n-                                                   &mut size);\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                Some(slice::from_raw_parts(ptr as *const u8, size as usize))\n-            }\n+            Iter { ptr: ::LLVMRustArchiveIteratorNew(self.ptr), archive: self }\n         }\n     }\n }\n@@ -75,3 +74,47 @@ impl Drop for ArchiveRO {\n         }\n     }\n }\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = Child<'a>;\n+\n+    fn next(&mut self) -> Option<Child<'a>> {\n+        unsafe {\n+            let ptr = ::LLVMRustArchiveIteratorCurrent(self.ptr);\n+            if ptr.is_null() {\n+                return None\n+            }\n+            let mut name_len = 0;\n+            let name_ptr = ::LLVMRustArchiveChildName(ptr, &mut name_len);\n+            let mut data_len = 0;\n+            let data_ptr = ::LLVMRustArchiveChildData(ptr, &mut data_len);\n+            let child = Child {\n+                name: if name_ptr.is_null() {\n+                    None\n+                } else {\n+                    let name = slice::from_raw_parts(name_ptr as *const u8,\n+                                                     name_len as usize);\n+                    str::from_utf8(name).ok().map(|s| s.trim())\n+                },\n+                data: slice::from_raw_parts(data_ptr as *const u8,\n+                                            data_len as usize),\n+            };\n+            ::LLVMRustArchiveIteratorNext(self.ptr);\n+            Some(child)\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for Iter<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            ::LLVMRustArchiveIteratorFree(self.ptr);\n+        }\n+    }\n+}\n+\n+impl<'a> Child<'a> {\n+    pub fn name(&self) -> Option<&'a str> { self.name }\n+    pub fn data(&self) -> &'a [u8] { self.data }\n+}"}, {"sha": "80e01154655e78ed499961e37d919e7161407c02", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -30,6 +30,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n+#![feature(unsafe_destructor)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -488,9 +489,12 @@ pub type PassRef = *mut Pass_opaque;\n #[allow(missing_copy_implementations)]\n pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *mut TargetMachine_opaque;\n-#[allow(missing_copy_implementations)]\n pub enum Archive_opaque {}\n pub type ArchiveRef = *mut Archive_opaque;\n+pub enum ArchiveIterator_opaque {}\n+pub type ArchiveIteratorRef = *mut ArchiveIterator_opaque;\n+pub enum ArchiveChild_opaque {}\n+pub type ArchiveChildRef = *mut ArchiveChild_opaque;\n #[allow(missing_copy_implementations)]\n pub enum Twine_opaque {}\n pub type TwineRef = *mut Twine_opaque;\n@@ -2051,13 +2055,17 @@ extern {\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-    pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n-                                      out_len: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef);\n+    pub fn LLVMRustArchiveIteratorCurrent(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n+                                    size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n     pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n     pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n-    pub fn LLVMVersionMajor() -> c_int;\n-    pub fn LLVMVersionMinor() -> c_int;\n \n     pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n                                   data: *mut *const c_char) -> c_int;"}, {"sha": "6457140bcc0f987ba68fef92b00428c45cccc2b9", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -21,9 +21,6 @@ use libc;\n use flate;\n \n use std::ffi::CString;\n-use std::mem;\n-#[allow(deprecated)]\n-use std::num::Int;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String]) {\n@@ -63,13 +60,13 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in 0.. {\n-            let bc_encoded = time(sess.time_passes(),\n-                                  &format!(\"check for {}.{}.bytecode.deflate\", name, i),\n-                                  (),\n-                                  |_| {\n-                                      archive.read(&format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i))\n-                                  });\n+            let filename = format!(\"{}.{}.bytecode.deflate\", file, i);\n+            let msg = format!(\"check for {}\", filename);\n+            let bc_encoded = time(sess.time_passes(), &msg, (), |_| {\n+                archive.iter().find(|section| {\n+                    section.name() == Some(&filename[..])\n+                })\n+            });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n@@ -79,9 +76,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                            path.display()));\n                     }\n                     // No more bitcode files to read.\n-                    break;\n-                },\n+                    break\n+                }\n             };\n+            let bc_encoded = bc_encoded.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n                 time(sess.time_passes(), &format!(\"decode {}.{}.bc\", file, i), (), |_| {\n@@ -198,19 +196,15 @@ fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n-    return read_from_le_bytes::<u32>(bc, link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET);\n+    let pos = link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET;\n+    let byte_data = &bc[pos..pos + 4];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u32) };\n+    u32::from_le(data)\n }\n \n fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n-    return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n-}\n-\n-#[allow(deprecated)]\n-fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n-    let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n-    let data = unsafe {\n-        *(byte_data.as_ptr() as *const T)\n-    };\n-\n-    Int::from_le(data)\n+    let pos = link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET;\n+    let byte_data = &bc[pos..pos + 8];\n+    let data = unsafe { *(byte_data.as_ptr() as *const u64) };\n+    u64::from_le(data)\n }"}, {"sha": "488a4a8082f9dc8b24d41a323d73f851a2dafb2c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -348,7 +348,7 @@ unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n \n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n-            sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n+            sess.codemap().with_expn_info(ExpnId::from_u32(cookie), |info| match info {\n                 Some(ei) => sess.span_err(ei.call_site, msg),\n                 None     => sess.err(msg),\n             });"}, {"sha": "e2827eeae15d0bbb0cf17ae56fa57d6e4b8fc82f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -45,8 +45,6 @@\n \n pub use self::Repr::*;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};"}, {"sha": "27128827e267603e0a9b90c155647755093b7dd8", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -138,7 +138,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx().llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.to_llvm_cookie());\n+        let val: llvm::ValueRef = C_i32(bcx.ccx(), ia.expn_id.into_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bcx.ccx().llcx(), &val, 1));"}, {"sha": "b8c45d4751ef8894022e26b28a800420b7e17f92", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -878,16 +878,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     // were introduced in LLVM 3.4, so we case on that.\n     macro_rules! compatible_ifn {\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n-            if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n-                // The `if key == $name` is already in ifn!\n-                ifn!($name, fn($($arg),*) -> $ret);\n-            } else if *key == $name {\n-                let f = declare::declare_cfn(ccx, stringify!($cname),\n-                                             Type::func(&[$($arg),*], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n-                ccx.intrinsics().borrow_mut().insert($name, f.clone());\n-                return Some(f);\n-            }\n+            ifn!($name, fn($($arg),*) -> $ret);\n         )\n     }\n "}, {"sha": "7c769eca74aabe71669823c41cf0febe067acdc4", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -2653,26 +2653,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.contains(&composite_type_metadata) {\n-            let (llvm_version_major, llvm_version_minor) = unsafe {\n-                (llvm::LLVMVersionMajor(), llvm::LLVMVersionMinor())\n-            };\n-\n-            let actual_llvm_version = llvm_version_major * 1000000 + llvm_version_minor * 1000;\n-            let min_supported_llvm_version = 3 * 1000000 + 4 * 1000;\n-\n-            if actual_llvm_version < min_supported_llvm_version {\n-                cx.sess().warn(&format!(\"This version of rustc was built with LLVM \\\n-                                        {}.{}. Rustc just ran into a known \\\n-                                        debuginfo corruption problem thatoften \\\n-                                        occurs with LLVM versions below 3.4. \\\n-                                        Please use a rustc built with anewer \\\n-                                        version of LLVM.\",\n-                                       llvm_version_major,\n-                                       llvm_version_minor));\n-            } else {\n-                cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n-                               Already completed forward declaration re-encountered.\");\n-            }\n+            cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n+                           Already completed forward declaration re-encountered.\");\n         } else {\n             composite_types_completed.insert(composite_type_metadata);\n         }"}, {"sha": "6bfa80f9c40b360f5dd119494dc7987f60b30680", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -746,11 +746,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let src = to_arg_ty(bcx, llargs[2], tp_ty);\n                     let res = AtomicCmpXchg(bcx, ptr, cmp, src, order,\n                                             strongest_failure_ordering);\n-                    if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n-                        ExtractValue(bcx, res, 0)\n-                    } else {\n-                        res\n-                    }\n+                    ExtractValue(bcx, res, 0)\n                 }\n \n                 \"load\" => {"}, {"sha": "9f01521313633360909b34399635ecc7049b589d", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -21,8 +21,6 @@ use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n-#[allow(deprecated)]\n-use std::num::Int;\n use syntax::abi;\n use syntax::ast;\n "}, {"sha": "edfa8db311f358d7da8bd1ab0c4a38545b9478eb", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -45,7 +45,7 @@ mod u_str;\n pub mod char;\n \n pub mod str {\n-    pub use u_str::{UnicodeStr, Words, Graphemes, GraphemeIndices};\n+    pub use u_str::{UnicodeStr, SplitWhitespace, Words, Graphemes, GraphemeIndices};\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n     pub use u_str::{utf16_items, Utf16Encoder};\n }"}, {"sha": "898844e3bf12ba71db877cdf10c8401bc9d9f165", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,9 +25,16 @@ use core::str::Split;\n \n use tables::grapheme::GraphemeCat;\n \n-/// An iterator over the words of a string, separated by a sequence of whitespace\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Words<'a> {\n+#[deprecated(reason = \"struct Words is being replaced by struct SplitWhitespace\",\n+             since = \"1.1.0\")]\n+#[unstable(feature = \"str_words\",\n+           reason = \"words() will be replaced by split_whitespace() in 1.1.0\")]\n+pub type Words<'a> = SplitWhitespace<'a>;\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+pub struct SplitWhitespace<'a> {\n     inner: Filter<Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }\n \n@@ -36,7 +43,9 @@ pub struct Words<'a> {\n pub trait UnicodeStr {\n     fn graphemes<'a>(&'a self, is_extended: bool) -> Graphemes<'a>;\n     fn grapheme_indices<'a>(&'a self, is_extended: bool) -> GraphemeIndices<'a>;\n+    #[allow(deprecated)]\n     fn words<'a>(&'a self) -> Words<'a>;\n+    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n     fn width(&self, is_cjk: bool) -> usize;\n@@ -56,15 +65,21 @@ impl UnicodeStr for str {\n         GraphemeIndices { start_offset: self.as_ptr() as usize, iter: self.graphemes(is_extended) }\n     }\n \n+    #[allow(deprecated)]\n     #[inline]\n     fn words(&self) -> Words {\n+        self.split_whitespace()\n+    }\n+\n+    #[inline]\n+    fn split_whitespace(&self) -> SplitWhitespace {\n         fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n         let is_not_empty: fn(&&str) -> bool = is_not_empty; // coerce to fn pointer\n \n         fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n         let is_whitespace: fn(char) -> bool = is_whitespace; // coerce to fn pointer\n \n-        Words { inner: self.split(is_whitespace).filter(is_not_empty) }\n+        SplitWhitespace { inner: self.split(is_whitespace).filter(is_not_empty) }\n     }\n \n     #[inline]\n@@ -545,11 +560,11 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n     }\n }\n \n-impl<'a> Iterator for Words<'a> {\n+impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n \n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n }\n-impl<'a> DoubleEndedIterator for Words<'a> {\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }"}, {"sha": "17053e4f10ad37760d967c79bfb77676b00d8884", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -274,7 +274,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.words().map(|s| s.to_ascii_lowercase())\n+        let id = s.split_whitespace().map(|s| s.to_ascii_lowercase())\n             .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered"}, {"sha": "9c393d6f897372531de74158e42e40d56f4251a9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -31,7 +31,6 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]\n-#![feature(str_words)]\n #![feature(path_ext)]\n #![feature(path_relative_from)]\n #![feature(slice_patterns)]\n@@ -240,7 +239,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<String> = test_args.iter()\n-                                          .flat_map(|s| s.words())\n+                                          .flat_map(|s| s.split_whitespace())\n                                           .map(|s| s.to_string())\n                                           .collect();\n \n@@ -404,13 +403,13 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n                     }\n                     clean::NameValue(ref x, ref value)\n                             if \"passes\" == *x => {\n-                        for pass in value.words() {\n+                        for pass in value.split_whitespace() {\n                             passes.push(pass.to_string());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n                             if \"plugins\" == *x => {\n-                        for p in value.words() {\n+                        for p in value.split_whitespace() {\n                             plugins.push(p.to_string());\n                         }\n                     }"}, {"sha": "baa6493533d2929c54f486e24d27e97bfb8a1188", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -204,12 +204,10 @@ use std::io::prelude::*;\n use std::io;\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n-#[allow(deprecated)]\n-use std::num::wrapping::WrappingOps;\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n-use std::{char, f64, fmt, num, str};\n+use std::{char, f64, fmt, str};\n use std;\n use rustc_unicode::str as unicode_str;\n use rustc_unicode::str::Utf16Item;\n@@ -460,8 +458,8 @@ fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n         Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n-        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6),\n-        _ => f64::to_str_digits(v, 6) + \".0\",\n+        _ if v.fract() != 0f64 => v.to_string(),\n+        _ => v.to_string() + \".0\",\n     }\n }\n \n@@ -1165,7 +1163,7 @@ impl Json {\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {\n             Json::I64(n) => Some(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::U64(n) => Some(n as i64),\n             _ => None\n         }\n     }\n@@ -1174,7 +1172,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_u64(&self) -> Option<u64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as u64),\n             Json::U64(n) => Some(n),\n             _ => None\n         }\n@@ -1184,8 +1182,8 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_f64(&self) -> Option<f64> {\n         match *self {\n-            Json::I64(n) => num::cast(n),\n-            Json::U64(n) => num::cast(n),\n+            Json::I64(n) => Some(n as f64),\n+            Json::U64(n) => Some(n as f64),\n             Json::F64(n) => Some(n),\n             _ => None\n         }\n@@ -1556,7 +1554,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n \n     #[allow(deprecated)] // possible resolve bug is mapping these to traits\n     fn parse_u64(&mut self) -> Result<u64, ParserError> {\n-        let mut accum = 0;\n+        let mut accum = 0u64;\n         let last_accum = 0; // necessary to detect overflow.\n \n         match self.ch_or_null() {\n@@ -2059,7 +2057,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n     }\n }\n \n-/// Decodes a json value from an `&mut old_io::Reader`\n+/// Decodes a json value from an `&mut io::Read`\n pub fn from_reader(rdr: &mut Read) -> Result<Json, BuilderError> {\n     let mut contents = Vec::new();\n     match rdr.read_to_end(&mut contents) {\n@@ -2121,14 +2119,8 @@ macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n         fn $name(&mut self) -> DecodeResult<$ty> {\n             match self.pop() {\n-                Json::I64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n-                Json::U64(f) => match num::cast(f) {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n-                },\n+                Json::I64(f) => Ok(f as $ty),\n+                Json::U64(f) => Ok(f as $ty),\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec."}, {"sha": "9ba90c470f8ae667776078f2d3a267b998145099", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -914,33 +914,6 @@ impl<K, V, S> HashMap<K, V, S>\n         IterMut { inner: self.table.iter_mut() }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each key-value\n-    /// pair out of the map in arbitrary order. The map cannot be used after\n-    /// calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n-        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n-\n-        IntoIter {\n-            inner: self.table.into_iter().map(last_two)\n-        }\n-    }\n-\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n@@ -1388,8 +1361,30 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S>\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n \n+    /// Creates a consuming iterator, that is, one that moves each key-value\n+    /// pair out of the map in arbitrary order. The map cannot be used after\n+    /// calling this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n+    /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n-        self.into_iter()\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n+\n+        IntoIter {\n+            inner: self.table.into_iter().map(last_two)\n+        }\n     }\n }\n \n@@ -1625,7 +1620,7 @@ mod test_map {\n \n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n-    use iter::{range_inclusive, range_step_inclusive, repeat};\n+    use iter::{range_inclusive, repeat};\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n \n@@ -1861,7 +1856,7 @@ mod test_map {\n             }\n \n             // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n+            for i in (1..1001).rev() {\n                 assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {"}, {"sha": "f7e43b38539f1b5367ecbf1f824e9b477cfa40bc", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -269,34 +269,6 @@ impl<T, S> HashSet<T, S>\n         Iter { iter: self.map.keys() }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each value out\n-    /// of the set in arbitrary order. The set cannot be used after calling\n-    /// this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\".to_string());\n-    /// set.insert(\"b\".to_string());\n-    ///\n-    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n-    /// let v: Vec<String> = set.into_iter().collect();\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in v.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        let first: fn((T, ())) -> T = first;\n-\n-        IntoIter { iter: self.map.into_iter().map(first) }\n-    }\n-\n     /// Visit the values representing the difference.\n     ///\n     /// # Examples\n@@ -848,8 +820,31 @@ impl<T, S> IntoIterator for HashSet<T, S>\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n+    /// Creates a consuming iterator, that is, one that moves each value out\n+    /// of the set in arbitrary order. The set cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\".to_string());\n+    /// set.insert(\"b\".to_string());\n+    ///\n+    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n+    /// let v: Vec<String> = set.into_iter().collect();\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in v.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        self.into_iter()\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first;\n+\n+        IntoIter { iter: self.map.into_iter().map(first) }\n     }\n }\n "}, {"sha": "3a63e2ab59cc85ed5ddfd4356cac3813eb437c93", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,7 +17,7 @@ use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n-use num::wrapping::{OverflowingOps, WrappingOps};\n+use num::wrapping::OverflowingOps;\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};"}, {"sha": "8ca462f5a3870a41fd9c8471af830b371ef666a6", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -259,19 +259,14 @@ mod dl {\n \n #[cfg(target_os = \"windows\")]\n mod dl {\n+    use prelude::v1::*;\n+\n     use ffi::OsStr;\n-    use iter::Iterator;\n     use libc;\n     use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-    use ops::FnOnce;\n     use sys::os;\n     use os::windows::prelude::*;\n-    use option::Option::{self, Some, None};\n     use ptr;\n-    use result::Result;\n-    use result::Result::{Ok, Err};\n-    use string::String;\n-    use vec::Vec;\n     use sys::c::compat::kernel32::SetThreadErrorMode;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {"}, {"sha": "114d0dd79a0a3056b338498bd472607fc52292c5", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -18,7 +18,6 @@\n \n use prelude::v1::*;\n \n-use iter::IntoIterator;\n use error::Error;\n use ffi::{OsStr, OsString};\n use fmt;\n@@ -772,7 +771,7 @@ mod tests {\n     }\n \n     fn eq(a: Option<OsString>, b: Option<&str>) {\n-        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::from_str).map(|s| &*s));\n+        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::new).map(|s| &*s));\n     }\n \n     #[test]\n@@ -895,7 +894,7 @@ mod tests {\n     fn join_paths_unix() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n@@ -911,7 +910,7 @@ mod tests {\n     fn join_paths_windows() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));"}, {"sha": "dfe706e077366c609f2fb43c9ae95d3a12fa2ca3", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -20,11 +20,3 @@ pub use self::os_str::{OsString, OsStr};\n \n mod c_str;\n mod os_str;\n-\n-// FIXME (#21670): these should be defined in the os_str module\n-/// Freely convertible to an `&OsStr` slice.\n-#[unstable(feature = \"std_misc\")]\n-pub trait AsOsStr {\n-    /// Converts to an `&OsStr` slice.\n-    fn as_os_str(&self) -> &OsStr;\n-}"}, {"sha": "97bf33335b02a8091af837556176f015ad494508", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -46,7 +46,6 @@ use vec::Vec;\n \n use sys::os_str::{Buf, Slice};\n use sys_common::{AsInner, IntoInner, FromInner};\n-use super::AsOsStr;\n \n /// Owned, mutable OS strings.\n #[derive(Clone)]\n@@ -226,14 +225,6 @@ impl OsStr {\n         s.as_ref()\n     }\n \n-    /// Coerces directly from a `&str` slice to a `&OsStr` slice.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `OsStr::new` instead\")]\n-    pub fn from_str(s: &str) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(s)) }\n-    }\n-\n     /// Yields a `&str` slice if the `OsStr` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n@@ -378,46 +369,6 @@ impl ToOwned for OsStr {\n     fn to_owned(&self) -> OsString { self.to_os_string() }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n-    fn as_os_str(&self) -> &OsStr {\n-        (*self).as_os_str()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for OsStr {\n-    fn as_os_str(&self) -> &OsStr {\n-        self\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for OsString {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self[..]\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for str {\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for String {\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(Slice::from_str(self)) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<OsStr> for OsStr {\n     fn as_ref(&self) -> &OsStr {"}, {"sha": "b5dfbf796d3bce212ab4c1053710a8334f27a32a", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -706,7 +706,7 @@ pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// Given a path, query the file system to get information about a file,\n /// directory, etc.\n ///\n-/// This function will traverse soft links to query information about the\n+/// This function will traverse symbolic links to query information about the\n /// destination file.\n ///\n /// # Examples\n@@ -820,9 +820,13 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n     fs_imp::link(src.as_ref(), dst.as_ref())\n }\n \n-/// Creates a new soft link on the filesystem.\n+/// Creates a new symbolic link on the filesystem.\n ///\n-/// The `dst` path will be a soft link pointing to the `src` path.\n+/// The `dst` path will be a symbolic link pointing to the `src` path.\n+/// On Windows, this will be a file symlink, not a directory symlink;\n+/// for this reason, the platform-specific `std::os::unix::fs::symlink`\n+/// and `std::os::windows::fs::{symlink_file, symlink_dir}` should be\n+/// used instead to make the intent explicit.\n ///\n /// # Examples\n ///\n@@ -834,17 +838,20 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// # Ok(())\n /// # }\n /// ```\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"replaced with std::os::unix::fs::symlink and \\\n+                       std::os::windows::fs::{symlink_file, symlink_dir}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::symlink(src.as_ref(), dst.as_ref())\n }\n \n-/// Reads a soft link, returning the file that the link points to.\n+/// Reads a symbolic link, returning the file that the link points to.\n ///\n /// # Errors\n ///\n /// This function will return an error on failure. Failure conditions include\n-/// reading a file that does not exist or reading a file that is not a soft\n+/// reading a file that does not exist or reading a file that is not a symbolic\n /// link.\n ///\n /// # Examples\n@@ -937,8 +944,8 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// Removes a directory at this path, after removing all its contents. Use\n /// carefully!\n ///\n-/// This function does **not** follow soft links and it will simply remove the\n-/// soft link itself.\n+/// This function does **not** follow symbolic links and it will simply remove the\n+/// symbolic link itself.\n ///\n /// # Errors\n ///"}, {"sha": "97c5a29d308a11c8975611bac9680094f78a153e", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -172,13 +172,6 @@ impl Error {\n         Error { repr: Repr::Os(code) }\n     }\n \n-    /// Creates a new instance of an `Error` from a particular OS error code.\n-    #[unstable(feature = \"io\", reason = \"deprecated\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_raw_os_error\")]\n-    pub fn from_os_error(code: i32) -> Error {\n-        Error { repr: Repr::Os(code) }\n-    }\n-\n     /// Returns the OS error that this error represents (if any).\n     ///\n     /// If this `Error` was constructed via `last_os_error` then this function"}, {"sha": "96665259a4d0c2d6cbf5328cf7fac00602b3ac13", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -128,6 +128,8 @@\n #![feature(std_misc)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n+#![feature(zero_one)]\n+#![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}, {"sha": "3bfc764e540b21b900f0a95673a4c3c7288dbd03", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -18,8 +18,6 @@\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n-#[allow(deprecated)] // Int\n-use num::Int;\n use sys_common::net2 as net_imp;\n \n pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n@@ -55,10 +53,21 @@ pub enum Shutdown {\n     Both,\n }\n \n-#[allow(deprecated)] // Int\n-fn hton<I: Int>(i: I) -> I { i.to_be() }\n-#[allow(deprecated)] // Int\n-fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n+#[doc(hidden)]\n+trait NetInt {\n+    fn from_be(i: Self) -> Self;\n+    fn to_be(&self) -> Self;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl NetInt for $t {\n+        fn from_be(i: Self) -> Self { <$t>::from_be(i) }\n+        fn to_be(&self) -> Self { <$t>::to_be(*self) }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n+fn hton<I: NetInt>(i: I) -> I { i.to_be() }\n+fn ntoh<I: NetInt>(i: I) -> I { I::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(&SocketAddr) -> io::Result<T>"}, {"sha": "0efc04ef83c6874e96f28ef71dcbd2e0bdeea5ad", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 112, "deletions": 544, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,18 +17,14 @@\n \n use prelude::v1::*;\n \n+use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n-\n-use core::num;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n-pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n@@ -74,294 +70,16 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f32 {\n-    #[inline]\n-    fn nan() -> f32 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f32 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f32 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f32 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f32 { num::Float::one() }\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f32>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f32 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f32 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f32 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f32 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f32 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f32 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f32 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f32 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f32 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f32 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f32 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f32 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f32 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f32 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f32 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f32 { num::Float::log10(self) }\n-    #[inline]\n-    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n-\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n-    /// power of `exp`\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f32 {\n-        unsafe { cmath::ldexpf(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f32, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f32) -> f32 {\n-        unsafe { cmath::fdimf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f32 {\n-        unsafe { cmath::cbrtf(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f32) -> f32 {\n-        unsafe { cmath::hypotf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f32 {\n-        unsafe { intrinsics::sinf32(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f32 {\n-        unsafe { intrinsics::cosf32(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f32 {\n-        unsafe { cmath::tanf(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f32 {\n-        unsafe { cmath::asinf(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f32 {\n-        unsafe { cmath::acosf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f32 {\n-        unsafe { cmath::atanf(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f32) -> f32 {\n-        unsafe { cmath::atan2f(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f32, f32) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f32 {\n-        unsafe { cmath::expm1f(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f32 {\n-        unsafe { cmath::log1pf(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f32 {\n-        unsafe { cmath::sinhf(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f32 {\n-        unsafe { cmath::coshf(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f32 {\n-        unsafe { cmath::tanhf(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f32 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f32 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f32 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f32 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f32, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -617,11 +335,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_positive(self) -> bool { num::Float::is_positive(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n-    #[inline]\n-    pub fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-\n     /// Returns `true` if `self`'s sign is negative, including `-0.0`\n     /// and `NEG_INFINITY`.\n     ///\n@@ -641,11 +354,6 @@ impl f32 {\n     #[inline]\n     pub fn is_sign_negative(self) -> bool { num::Float::is_negative(self) }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n-    #[inline]\n-    pub fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n@@ -729,24 +437,6 @@ impl f32 {\n     #[inline]\n     pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::f32;\n-    ///\n-    /// let f = 4.0f32;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1339,7 +1029,7 @@ impl f32 {\n     #[inline]\n     pub fn acosh(self) -> f32 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => ::f32::NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1363,116 +1053,9 @@ impl f32 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f32) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f32, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f32, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use f32;\n     use f32::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1496,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f32 = Float::nan();\n+        let nan: f32 = f32::NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1508,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f32 = Float::infinity();\n+        let inf: f32 = f32::INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1520,7 +1103,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1532,7 +1115,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f32 = Float::zero();\n+        let zero: f32 = 0.0f32;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1545,7 +1128,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f32 = Float::neg_zero();\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1558,7 +1141,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f32 = Float::one();\n+        let one: f32 = 1.0f32;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1571,9 +1154,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f32.is_nan());\n         assert!(!5.3f32.is_nan());\n@@ -1584,9 +1167,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1597,9 +1180,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1610,11 +1193,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1627,11 +1210,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1774,9 +1357,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n@@ -1790,9 +1373,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.recip(), 1.0);\n         assert_eq!(2.0f32.recip(), 0.5);\n         assert_eq!((-0.4f32).recip(), -2.5);\n@@ -1804,9 +1387,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powi(1), 1.0);\n         assert_approx_eq!((-3.1f32).powi(2), 9.61);\n         assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n@@ -1818,9 +1401,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n         assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n@@ -1843,30 +1426,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f32).rsqrt().is_nan());\n-        assert_eq!((-0.0f32).rsqrt(), neg_inf);\n-        assert_eq!(0.0f32.rsqrt(), inf);\n-        assert_eq!(1.0f32.rsqrt(), 1.0);\n-        assert_eq!(4.0f32.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n         assert_approx_eq!(2.718282, 1.0f32.exp());\n         assert_approx_eq!(148.413162, 5.0f32.exp());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1877,19 +1445,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f32.exp2());\n         assert_eq!(1.0, 0.0f32.exp2());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1902,12 +1470,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log(10.0), 1.0);\n         assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n-        assert_eq!(1.0f32.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n         assert!(1.0f32.log(1.0).is_nan());\n         assert!(1.0f32.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1920,9 +1488,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(10.0f32.log2(), 3.321928);\n         assert_approx_eq!(2.3f32.log2(), 1.201634);\n         assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n@@ -1936,9 +1504,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log10(), 1.0);\n         assert_approx_eq!(2.3f32.log10(), 0.361728);\n         assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n@@ -1954,9 +1522,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1968,9 +1536,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_radians(), 0.0);\n         assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n@@ -1984,50 +1552,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f32.ldexp(-123), f1);\n-        assert_eq!(1f32.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f32, -12), f3);\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f32::ldexp(1f32, -123), f1);\n+        assert_eq!(f32::ldexp(1f32, -111), f2);\n+        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n+        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n+        assert_eq!(f32::ldexp(inf, -123), inf);\n+        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f32::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n         assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f32::ldexp(x1, exp1), f1);\n+        assert_eq!(f32::ldexp(x2, exp2), f2);\n+        assert_eq!(f32::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -2056,9 +1624,9 @@ mod tests {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n         assert_eq!((-0.0f32).asinh(), -0.0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -2071,9 +1639,9 @@ mod tests {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n         assert!(0.999f32.acosh().is_nan());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -2086,17 +1654,17 @@ mod tests {\n         assert_eq!(0.0f32.atanh(), 0.0f32);\n         assert_eq!((-0.0f32).atanh(), -0.0f32);\n \n-        let inf32: f32 = Float::infinity();\n-        let neg_inf32: f32 = Float::neg_infinity();\n+        let inf32: f32 = f32::INFINITY;\n+        let neg_inf32: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.atanh(), inf32);\n         assert_eq!((-1.0f32).atanh(), neg_inf32);\n \n         assert!(2f64.atanh().atanh().is_nan());\n         assert!((-2f64).atanh().atanh().is_nan());\n \n-        let inf64: f32 = Float::infinity();\n-        let neg_inf64: f32 = Float::neg_infinity();\n-        let nan32: f32 = Float::nan();\n+        let inf64: f32 = f32::INFINITY;\n+        let neg_inf64: f32 = f32::NEG_INFINITY;\n+        let nan32: f32 = f32::NAN;\n         assert!(inf64.atanh().is_nan());\n         assert!(neg_inf64.atanh().is_nan());\n         assert!(nan32.atanh().is_nan());\n@@ -2118,9 +1686,9 @@ mod tests {\n         let frac_pi_8: f32 = consts::FRAC_PI_8;\n         let frac_1_pi: f32 = consts::FRAC_1_PI;\n         let frac_2_pi: f32 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f32 = consts::SQRT2;\n-        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f32 = consts::SQRT_2;\n+        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n         let e: f32 = consts::E;\n         let log2_e: f32 = consts::LOG2_E;\n         let log10_e: f32 = consts::LOG10_E;"}, {"sha": "e1497f3958dabf1bd897c62f0c2598fcd3763999", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 110, "deletions": 531, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,18 +16,14 @@\n \n use prelude::v1::*;\n \n+use core::num;\n use intrinsics;\n use libc::c_int;\n-use num::{Float, FpCategory};\n-use num::strconv;\n-use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n-use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n-use num::strconv::SignFormat::SignNeg;\n-\n-use core::num;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n-pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n-pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n@@ -82,295 +78,16 @@ mod cmath {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Float for f64 {\n-    // inlined methods from `num::Float`\n-    #[inline]\n-    fn nan() -> f64 { num::Float::nan() }\n-    #[inline]\n-    fn infinity() -> f64 { num::Float::infinity() }\n-    #[inline]\n-    fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n-    #[inline]\n-    fn zero() -> f64 { num::Float::zero() }\n-    #[inline]\n-    fn neg_zero() -> f64 { num::Float::neg_zero() }\n-    #[inline]\n-    fn one() -> f64 { num::Float::one() }\n-\n-\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn mantissa_digits(unused_self: Option<f64>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn epsilon() -> f64 { num::Float::epsilon() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_value() -> f64 { num::Float::min_value() }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n-    #[allow(deprecated)]\n-    #[inline]\n-    fn max_value() -> f64 { num::Float::max_value() }\n-\n-    #[inline]\n-    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n-    #[inline]\n-    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n-    #[inline]\n-    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n-    #[inline]\n-    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n-    #[inline]\n-    fn classify(self) -> FpCategory { num::Float::classify(self) }\n-\n-    #[inline]\n-    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n-\n-    #[inline]\n-    fn floor(self) -> f64 { num::Float::floor(self) }\n-    #[inline]\n-    fn ceil(self) -> f64 { num::Float::ceil(self) }\n-    #[inline]\n-    fn round(self) -> f64 { num::Float::round(self) }\n-    #[inline]\n-    fn trunc(self) -> f64 { num::Float::trunc(self) }\n-    #[inline]\n-    fn fract(self) -> f64 { num::Float::fract(self) }\n-\n-    #[inline]\n-    fn abs(self) -> f64 { num::Float::abs(self) }\n-    #[inline]\n-    fn signum(self) -> f64 { num::Float::signum(self) }\n-    #[inline]\n-    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n-    #[inline]\n-    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n-\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n-    #[inline]\n-    fn recip(self) -> f64 { num::Float::recip(self) }\n-\n-    #[inline]\n-    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n-    #[inline]\n-    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n-\n-    #[inline]\n-    fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n-    #[inline]\n-    fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n-    #[inline]\n-    fn exp(self) -> f64 { num::Float::exp(self) }\n-    #[inline]\n-    fn exp2(self) -> f64 { num::Float::exp2(self) }\n-    #[inline]\n-    fn ln(self) -> f64 { num::Float::ln(self) }\n-    #[inline]\n-    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n-    #[inline]\n-    fn log2(self) -> f64 { num::Float::log2(self) }\n-    #[inline]\n-    fn log10(self) -> f64 { num::Float::log10(self) }\n-\n-    #[inline]\n-    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n-    #[inline]\n-    fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n-\n-    #[inline]\n-    fn ldexp(self, exp: isize) -> f64 {\n-        unsafe { cmath::ldexp(self, exp as c_int) }\n-    }\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    /// - `self = x * pow(2, exp)`\n-    /// - `0.5 <= abs(x) < 1.0`\n-    #[inline]\n-    fn frexp(self) -> (f64, isize) {\n-        unsafe {\n-            let mut exp = 0;\n-            let x = cmath::frexp(self, &mut exp);\n-            (x, exp as isize)\n-        }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    #[inline]\n-    fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(self, other: f64) -> f64 {\n-        unsafe { cmath::fdim(self, other) }\n-    }\n-\n-    #[inline]\n-    fn cbrt(self) -> f64 {\n-        unsafe { cmath::cbrt(self) }\n-    }\n-\n-    #[inline]\n-    fn hypot(self, other: f64) -> f64 {\n-        unsafe { cmath::hypot(self, other) }\n-    }\n-\n-    #[inline]\n-    fn sin(self) -> f64 {\n-        unsafe { intrinsics::sinf64(self) }\n-    }\n-\n-    #[inline]\n-    fn cos(self) -> f64 {\n-        unsafe { intrinsics::cosf64(self) }\n-    }\n-\n-    #[inline]\n-    fn tan(self) -> f64 {\n-        unsafe { cmath::tan(self) }\n-    }\n-\n-    #[inline]\n-    fn asin(self) -> f64 {\n-        unsafe { cmath::asin(self) }\n-    }\n-\n-    #[inline]\n-    fn acos(self) -> f64 {\n-        unsafe { cmath::acos(self) }\n-    }\n-\n-    #[inline]\n-    fn atan(self) -> f64 {\n-        unsafe { cmath::atan(self) }\n-    }\n-\n-    #[inline]\n-    fn atan2(self, other: f64) -> f64 {\n-        unsafe { cmath::atan2(self, other) }\n-    }\n-\n-    /// Simultaneously computes the sine and cosine of the number\n-    #[inline]\n-    fn sin_cos(self) -> (f64, f64) {\n-        (self.sin(), self.cos())\n-    }\n-\n-    /// Returns the exponential of the number, minus `1`, in a way that is\n-    /// accurate even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f64 {\n-        unsafe { cmath::expm1(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n-    /// accurately than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f64 {\n-        unsafe { cmath::log1p(self) }\n-    }\n-\n-    #[inline]\n-    fn sinh(self) -> f64 {\n-        unsafe { cmath::sinh(self) }\n-    }\n-\n-    #[inline]\n-    fn cosh(self) -> f64 {\n-        unsafe { cmath::cosh(self) }\n-    }\n-\n-    #[inline]\n-    fn tanh(self) -> f64 {\n-        unsafe { cmath::tanh(self) }\n-    }\n-\n-    /// Inverse hyperbolic sine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n-    /// - `NAN` if `self` is `NAN`\n-    #[inline]\n-    fn asinh(self) -> f64 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic cosine\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `INFINITY` if `self` is `INFINITY`\n-    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n-    #[inline]\n-    fn acosh(self) -> f64 {\n-        match self {\n-            x if x < 1.0 => Float::nan(),\n-            x => (x + ((x * x) - 1.0).sqrt()).ln(),\n-        }\n-    }\n-\n-    /// Inverse hyperbolic tangent\n-    ///\n-    /// # Returns\n-    ///\n-    /// - on success, the inverse hyperbolic tangent of `self` will be returned\n-    /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `INFINITY` if `self` is `1.0`\n-    /// - `NEG_INFINITY` if `self` is `-1.0`\n-    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `INFINITY` and `NEG_INFINITY`)\n-    #[inline]\n-    fn atanh(self) -> f64 {\n-        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n-    }\n-}\n-\n #[cfg(not(test))]\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f64 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f64, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -726,22 +443,6 @@ impl f64 {\n     #[inline]\n     pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// let f = 4.0_f64;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1304,7 +1005,7 @@ impl f64 {\n     #[inline]\n     pub fn acosh(self) -> f64 {\n         match self {\n-            x if x < 1.0 => Float::nan(),\n+            x if x < 1.0 => NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1328,116 +1029,9 @@ impl f64 {\n     }\n }\n \n-//\n-// Section: String Conversions\n-//\n-\n-/// Converts a float to a string\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n-pub fn to_string(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in hexadecimal format\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_hex(num: f64) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 16, true, SignNeg, DigAll, ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string in a given radix, and a flag indicating\n-/// whether it's a special value\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * radix - The base to use\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n-pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n-    strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n-}\n-\n-/// Converts a float to a string with exactly the number of\n-/// provided significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string with a maximum number of\n-/// significant digits\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of significant digits\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f64, dig: usize) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with exactly the number of\n-/// provided digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n-    r\n-}\n-\n-/// Converts a float to a string using the exponential notation with the maximum number of\n-/// digits after the decimal point in the significand\n-///\n-/// # Arguments\n-///\n-/// * num - The float value\n-/// * digits - The number of digits after the decimal point\n-/// * upper - Use `E` instead of `e` for the exponent sign\n-#[inline]\n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f64, dig: usize, upper: bool) -> String {\n-    let (r, _) = strconv::float_to_str_common(\n-        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n-    r\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use f64;\n     use f64::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1461,7 +1055,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f64 = Float::nan();\n+        let nan: f64 = NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1473,7 +1067,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f64 = Float::infinity();\n+        let inf: f64 = INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1485,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1497,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f64 = Float::zero();\n+        let zero: f64 = 0.0f64;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1510,7 +1104,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f64 = Float::neg_zero();\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1523,7 +1117,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f64 = Float::one();\n+        let one: f64 = 1.0f64;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1536,9 +1130,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f64.is_nan());\n         assert!(!5.3f64.is_nan());\n@@ -1549,9 +1143,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1562,9 +1156,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1575,11 +1169,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1592,11 +1186,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1738,9 +1332,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n@@ -1754,9 +1348,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.recip(), 1.0);\n         assert_eq!(2.0f64.recip(), 0.5);\n         assert_eq!((-0.4f64).recip(), -2.5);\n@@ -1768,9 +1362,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powi(1), 1.0);\n         assert_approx_eq!((-3.1f64).powi(2), 9.61);\n         assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n@@ -1782,9 +1376,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n         assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n@@ -1807,30 +1401,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f64).rsqrt().is_nan());\n-        assert_eq!((-0.0f64).rsqrt(), neg_inf);\n-        assert_eq!(0.0f64.rsqrt(), inf);\n-        assert_eq!(1.0f64.rsqrt(), 1.0);\n-        assert_eq!(4.0f64.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n         assert_approx_eq!(2.718282, 1.0f64.exp());\n         assert_approx_eq!(148.413159, 5.0f64.exp());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1841,19 +1420,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f64.exp2());\n         assert_eq!(1.0, 0.0f64.exp2());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1866,12 +1445,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log(10.0), 1.0);\n         assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n-        assert_eq!(1.0f64.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n         assert!(1.0f64.log(1.0).is_nan());\n         assert!(1.0f64.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1884,9 +1463,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(10.0f64.log2(), 3.321928);\n         assert_approx_eq!(2.3f64.log2(), 1.201634);\n         assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n@@ -1900,9 +1479,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log10(), 1.0);\n         assert_approx_eq!(2.3f64.log10(), 0.361728);\n         assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n@@ -1918,9 +1497,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1932,9 +1511,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_radians(), 0.0);\n         assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n@@ -1948,50 +1527,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f64.ldexp(-123), f1);\n-        assert_eq!(1f64.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f64, -12), f3);\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f64::ldexp(1f64, -123), f1);\n+        assert_eq!(f64::ldexp(1f64, -111), f2);\n+        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n+        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n+        assert_eq!(f64::ldexp(inf, -123), inf);\n+        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f64::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n         assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f64::ldexp(x1, exp1), f1);\n+        assert_eq!(f64::ldexp(x2, exp2), f2);\n+        assert_eq!(f64::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -2020,9 +1599,9 @@ mod tests {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -2035,9 +1614,9 @@ mod tests {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_nan());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -2050,9 +1629,9 @@ mod tests {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_nan());\n@@ -2076,9 +1655,9 @@ mod tests {\n         let frac_pi_8: f64 = consts::FRAC_PI_8;\n         let frac_1_pi: f64 = consts::FRAC_1_PI;\n         let frac_2_pi: f64 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f64 = consts::SQRT2;\n-        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f64 = consts::SQRT_2;\n+        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n         let e: f64 = consts::E;\n         let log2_e: f64 = consts::LOG2_E;\n         let log10_e: f64 = consts::LOG10_E;"}, {"sha": "cd26be013c41eaa814ec13e728f33290146b4cf1", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 52, "deletions": 1589, "changes": 1641, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,1124 +15,59 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n-#![allow(deprecated)]\n \n-#[cfg(test)] use fmt::Debug;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use fmt;\n+use core::num;\n \n-use marker::Copy;\n-use clone::Clone;\n-use cmp::{PartialOrd, PartialEq};\n-\n-pub use core::num::{Int, SignedInt, Zero, One};\n-pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n-pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n-pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n-pub use core::num::{from_f32, from_f64};\n-pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::{Zero, One};\n+pub use core::num::{FpCategory, ParseIntError};\n pub use core::num::{wrapping, Wrapping};\n \n-use option::Option;\n-\n-#[unstable(feature = \"std_misc\", reason = \"likely to be removed\")]\n-pub mod strconv;\n-\n-/// Mathematical operations on primitive floating point numbers.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"replaced by inherent methods; use rust-lang/num for generics\")]\n-pub trait Float\n-    : Copy + Clone\n-    + NumCast\n-    + PartialOrd\n-    + PartialEq\n-    + Neg<Output=Self>\n-    + Add<Output=Self>\n-    + Sub<Output=Self>\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Rem<Output=Self>\n-{\n-    // inlined methods from `num::Float`\n-    /// Returns the `NaN` value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let nan: f32 = Float::nan();\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn nan() -> Self;\n-    /// Returns the infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let infinity: f32 = Float::infinity();\n-    ///\n-    /// assert!(infinity.is_infinite());\n-    /// assert!(!infinity.is_finite());\n-    /// assert!(infinity > f32::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn infinity() -> Self;\n-    /// Returns the negative infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let neg_infinity: f32 = Float::neg_infinity();\n-    ///\n-    /// assert!(neg_infinity.is_infinite());\n-    /// assert!(!neg_infinity.is_finite());\n-    /// assert!(neg_infinity < f32::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_infinity() -> Self;\n-    /// Returns `0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn zero() -> Self;\n-    /// Returns `-0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn neg_zero() -> Self;\n-    /// Returns `1.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let one: f32 = Float::one();\n-    ///\n-    /// assert_eq!(one, 1.0f32);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn one() -> Self;\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n-    /// instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> usize;\n-    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    fn epsilon() -> Self;\n-    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> isize;\n-    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> isize;\n-\n-    /// Returns the smallest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::min_value();\n-    ///\n-    /// assert_eq!(x, f64::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_value() -> Self;\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn min_pos_value(unused_self: Option<Self>) -> Self;\n-    /// Returns the largest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::max_value();\n-    /// assert_eq!(x, f64::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn max_value() -> Self;\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0;\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// assert!(!f.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_nan(self) -> bool;\n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(!f.is_infinite());\n-    /// assert!(!nan.is_infinite());\n-    ///\n-    /// assert!(inf.is_infinite());\n-    /// assert!(neg_inf.is_infinite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_infinite(self) -> bool;\n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n-    ///\n-    /// assert!(f.is_finite());\n-    ///\n-    /// assert!(!nan.is_finite());\n-    /// assert!(!inf.is_finite());\n-    /// assert!(!neg_inf.is_finite());\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_finite(self) -> bool;\n-\n-    /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal][subnormal], or `NaN`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n-    /// let max = f32::MAX;\n-    /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0f32;\n-    ///\n-    /// assert!(min.is_normal());\n-    /// assert!(max.is_normal());\n-    ///\n-    /// assert!(!zero.is_normal());\n-    /// assert!(!f32::NAN.is_normal());\n-    /// assert!(!f32::INFINITY.is_normal());\n-    /// // Values between `0` and `min` are Subnormal.\n-    /// assert!(!lower_than_min.is_normal());\n-    /// ```\n-    /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n-    fn is_normal(self) -> bool;\n-\n-    /// Returns the floating point category of the number. If only one property\n-    /// is going to be tested, it is generally faster to use the specific\n-    /// predicate instead.\n-    ///\n-    /// ```\n-    /// use std::num::{Float, FpCategory};\n-    /// use std::f32;\n-    ///\n-    /// let num = 12.4f32;\n-    /// let inf = f32::INFINITY;\n-    ///\n-    /// assert_eq!(num.classify(), FpCategory::Normal);\n-    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn classify(self) -> FpCategory;\n-\n-    /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n-    /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n-    /// The floating point encoding is documented in the [Reference][floating-point].\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let num = 2.0f32;\n-    ///\n-    /// // (8388608, -22, 1)\n-    /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n-    ///\n-    /// // 1 * 8388608 * 2^(-22) == 2\n-    /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    /// [floating-point]: ../../../../../reference.html#machine-types\n-    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n-    /// Returns the largest integer less than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.99;\n-    /// let g = 3.0;\n-    ///\n-    /// assert_eq!(f.floor(), 3.0);\n-    /// assert_eq!(g.floor(), 3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn floor(self) -> Self;\n-    /// Returns the smallest integer greater than or equal to a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.01;\n-    /// let g = 4.0;\n-    ///\n-    /// assert_eq!(f.ceil(), 4.0);\n-    /// assert_eq!(g.ceil(), 4.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ceil(self) -> Self;\n-    /// Returns the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.3;\n-    ///\n-    /// assert_eq!(f.round(), 3.0);\n-    /// assert_eq!(g.round(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn round(self) -> Self;\n-    /// Returns the integer part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.7;\n-    ///\n-    /// assert_eq!(f.trunc(), 3.0);\n-    /// assert_eq!(g.trunc(), -3.0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trunc(self) -> Self;\n-    /// Returns the fractional part of a number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    /// let abs_difference_x = (x.fract() - 0.5).abs();\n-    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fract(self) -> Self;\n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n-    ///\n-    /// let abs_difference_x = (x.abs() - x).abs();\n-    /// let abs_difference_y = (y.abs() - (-y)).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    ///\n-    /// assert!(f64::NAN.abs().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn abs(self) -> Self;\n-    /// Returns a number that represents the sign of `self`.\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = 3.5;\n-    ///\n-    /// assert_eq!(f.signum(), 1.0);\n-    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n-    ///\n-    /// assert!(f64::NAN.signum().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signum(self) -> Self;\n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(f.is_positive());\n-    /// assert!(!g.is_positive());\n-    /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_positive(self) -> bool;\n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n-    ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n-    ///\n-    /// assert!(!f.is_negative());\n-    /// assert!(g.is_negative());\n-    /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_negative(self) -> bool;\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n-    /// error. This produces a more accurate result with better performance than\n-    /// a separate multiplication operation followed by an add.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let m = 10.0;\n-    /// let x = 4.0;\n-    /// let b = 60.0;\n-    ///\n-    /// // 100.0\n-    /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Takes the reciprocal (inverse) of a number, `1/x`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn recip(self) -> Self;\n-\n-    /// Raises a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powi(2) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powi(self, n: i32) -> Self;\n-    /// Raises a number to a floating point power.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let abs_difference = (x.powf(2.0) - x*x).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn powf(self, n: Self) -> Self;\n-    /// Takes the square root of a number.\n-    ///\n-    /// Returns NaN if `self` is a negative number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let positive = 4.0;\n-    /// let negative = -4.0;\n-    ///\n-    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// assert!(negative.sqrt().is_nan());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sqrt(self) -> Self;\n-\n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 4.0;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn rsqrt(self) -> Self;\n-\n-    /// Returns `e^(self)`, (the exponential function).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp(self) -> Self;\n-    /// Returns `2^(self)`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 2.0;\n-    ///\n-    /// // 2^2 - 4 == 0\n-    /// let abs_difference = (f.exp2() - 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn exp2(self) -> Self;\n-    /// Returns the natural logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n-    /// // e^1\n-    /// let e = one.exp();\n-    ///\n-    /// // ln(e) - 1 == 0\n-    /// let abs_difference = (e.ln() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ln(self) -> Self;\n-    /// Returns the logarithm of the number with respect to an arbitrary base.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    /// let two = 2.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference_10 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log(self, base: Self) -> Self;\n-    /// Returns the base 2 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let two = 2.0;\n-    ///\n-    /// // log2(2) - 1 == 0\n-    /// let abs_difference = (two.log2() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log2(self) -> Self;\n-    /// Returns the base 10 logarithm of the number.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    ///\n-    /// // log10(10) - 1 == 0\n-    /// let abs_difference = (ten.log10() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn log10(self) -> Self;\n-\n-    /// Converts radians to degrees.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = consts::PI;\n-    ///\n-    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_degrees(self) -> Self;\n-    /// Converts degrees to radians.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n-    ///\n-    /// let angle = 180.0;\n-    ///\n-    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n-    fn to_radians(self) -> Self;\n-    /// Constructs a floating point number of `x*2^exp`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn ldexp(self, exp: isize) -> Self;\n-    /// Breaks the number into a normalized fraction and a base-2 exponent,\n-    /// satisfying:\n-    ///\n-    ///  * `self = x * 2^exp`\n-    ///  * `0.5 <= abs(x) < 1.0`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 4.0;\n-    ///\n-    /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n-    /// let f = x.frexp();\n-    /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"pending integer conventions\")]\n-    fn frexp(self) -> (Self, isize);\n-    /// Returns the next representable floating-point value in the direction of\n-    /// `other`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0f32;\n-    ///\n-    /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n-    ///\n-    /// assert!(abs_diff < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn next_after(self, other: Self) -> Self;\n-\n-    /// Returns the maximum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.max(y), y);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn max(self, other: Self) -> Self;\n-    /// Returns the minimum of the two numbers.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n-    ///\n-    /// assert_eq!(x.min(y), x);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn min(self, other: Self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// * If `self <= other`: `0:0`\n-    /// * Else: `self - other`\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.0;\n-    /// let y = -3.0;\n-    ///\n-    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n-    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n-    ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn abs_sub(self, other: Self) -> Self;\n-    /// Takes the cubic root of a number.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 8.0;\n-    ///\n-    /// // x^(1/3) - 2 == 0\n-    /// let abs_difference = (x.cbrt() - 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn cbrt(self) -> Self;\n-    /// Calculates the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let y = 3.0;\n-    ///\n-    /// // sqrt(x^2 + y^2)\n-    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    fn hypot(self, other: Self) -> Self;\n-\n-    /// Computes the sine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/2.0;\n-    ///\n-    /// let abs_difference = (x.sin() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin(self) -> Self;\n-    /// Computes the cosine of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = 2.0*f64::consts::PI;\n-    ///\n-    /// let abs_difference = (x.cos() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cos(self) -> Self;\n-    /// Computes the tangent of a number (in radians).\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let abs_difference = (x.tan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-14);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tan(self) -> Self;\n-    /// Computes the arcsine of a number. Return value is in radians in\n-    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 2.0;\n-    ///\n-    /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asin(self) -> Self;\n-    /// Computes the arccosine of a number. Return value is in radians in\n-    /// the range [0, pi] or NaN if the number is outside the range\n-    /// [-1, 1].\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let f = f64::consts::PI / 4.0;\n-    ///\n-    /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acos(self) -> Self;\n-    /// Computes the arctangent of a number. Return value is in radians in the\n-    /// range [-pi/2, pi/2];\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 1.0;\n-    ///\n-    /// // atan(tan(1))\n-    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan(self) -> Self;\n-    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n-    ///\n-    /// * `x = 0`, `y = 0`: `0`\n-    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n-    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n-    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let pi = f64::consts::PI;\n-    /// // All angles from horizontal right (+x)\n-    /// // 45 deg counter-clockwise\n-    /// let x1 = 3.0;\n-    /// let y1 = -3.0;\n-    ///\n-    /// // 135 deg clockwise\n-    /// let x2 = -3.0;\n-    /// let y2 = 3.0;\n-    ///\n-    /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n-    /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n-    ///\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atan2(self, other: Self) -> Self;\n-    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n-    /// `(sin(x), cos(x))`.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::PI/4.0;\n-    /// let f = x.sin_cos();\n-    ///\n-    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n-    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n-    ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sin_cos(self) -> (Self, Self);\n-\n-    /// Returns `e^(self) - 1` in a way that is accurate even if the\n-    /// number is close to zero.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 7.0;\n-    ///\n-    /// // e^(ln(7)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn exp_m1(self) -> Self;\n-    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n-    /// the operations were performed separately.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x = f64::consts::E - 1.0;\n-    ///\n-    /// // ln(1 + (e - 1)) == ln(e) == 1\n-    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n-    fn ln_1p(self) -> Self;\n-\n-    /// Hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.sinh();\n-    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n-    /// let g = (e*e - 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sinh(self) -> Self;\n-    /// Hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    /// let f = x.cosh();\n-    /// // Solving cosh() at 1 gives this result\n-    /// let g = (e*e + 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// // Same result\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cosh(self) -> Self;\n-    /// Hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n-    ///\n-    /// let f = x.tanh();\n-    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n-    /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n-    /// let abs_difference = (f - g).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn tanh(self) -> Self;\n-    /// Inverse hyperbolic sine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.sinh().asinh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn asinh(self) -> Self;\n-    /// Inverse hyperbolic cosine function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let f = x.cosh().acosh();\n-    ///\n-    /// let abs_difference = (f - x).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn acosh(self) -> Self;\n-    /// Inverse hyperbolic tangent function.\n-    ///\n-    /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let e = f64::consts::E;\n-    /// let f = e.tanh().atanh();\n-    ///\n-    /// let abs_difference = (f - e).abs();\n-    ///\n-    /// assert!(abs_difference < 1.0e-10);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn atanh(self) -> Self;\n-}\n+#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)] use cmp::PartialEq;\n+#[cfg(test)] use marker::Copy;\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Debug\n+     + Rem<Output=T> + fmt::Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n     assert_eq!(ten.div(two),  ten / two);\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n+/// An error which can be returned when parsing a float.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError { inner: num::ParseFloatError }\n+\n+impl ::sys_common::FromInner<num::ParseFloatError> for ParseFloatError {\n+    fn from_inner(inner: num::ParseFloatError) -> ParseFloatError {\n+        ParseFloatError { inner: inner }\n+    }\n+}\n+\n+impl ParseFloatError {\n+    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    pub fn description(&self) -> &str {\n+        self.inner.description()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n@@ -1148,432 +83,7 @@ mod tests {\n     use u64;\n     use usize;\n     use string::ToString;\n-\n-    macro_rules! test_cast_20 {\n-        ($_20:expr) => ({\n-            let _20 = $_20;\n-\n-            assert_eq!(20usize, _20.to_uint().unwrap());\n-            assert_eq!(20u8,    _20.to_u8().unwrap());\n-            assert_eq!(20u16,   _20.to_u16().unwrap());\n-            assert_eq!(20u32,   _20.to_u32().unwrap());\n-            assert_eq!(20u64,   _20.to_u64().unwrap());\n-            assert_eq!(20,      _20.to_int().unwrap());\n-            assert_eq!(20i8,    _20.to_i8().unwrap());\n-            assert_eq!(20i16,   _20.to_i16().unwrap());\n-            assert_eq!(20i32,   _20.to_i32().unwrap());\n-            assert_eq!(20i64,   _20.to_i64().unwrap());\n-            assert_eq!(20f32,   _20.to_f32().unwrap());\n-            assert_eq!(20f64,   _20.to_f64().unwrap());\n-\n-            assert_eq!(_20, NumCast::from(20usize).unwrap());\n-            assert_eq!(_20, NumCast::from(20u8).unwrap());\n-            assert_eq!(_20, NumCast::from(20u16).unwrap());\n-            assert_eq!(_20, NumCast::from(20u32).unwrap());\n-            assert_eq!(_20, NumCast::from(20u64).unwrap());\n-            assert_eq!(_20, NumCast::from(20).unwrap());\n-            assert_eq!(_20, NumCast::from(20i8).unwrap());\n-            assert_eq!(_20, NumCast::from(20i16).unwrap());\n-            assert_eq!(_20, NumCast::from(20i32).unwrap());\n-            assert_eq!(_20, NumCast::from(20i64).unwrap());\n-            assert_eq!(_20, NumCast::from(20f32).unwrap());\n-            assert_eq!(_20, NumCast::from(20f64).unwrap());\n-\n-            assert_eq!(_20, cast(20usize).unwrap());\n-            assert_eq!(_20, cast(20u8).unwrap());\n-            assert_eq!(_20, cast(20u16).unwrap());\n-            assert_eq!(_20, cast(20u32).unwrap());\n-            assert_eq!(_20, cast(20u64).unwrap());\n-            assert_eq!(_20, cast(20).unwrap());\n-            assert_eq!(_20, cast(20i8).unwrap());\n-            assert_eq!(_20, cast(20i16).unwrap());\n-            assert_eq!(_20, cast(20i32).unwrap());\n-            assert_eq!(_20, cast(20i64).unwrap());\n-            assert_eq!(_20, cast(20f32).unwrap());\n-            assert_eq!(_20, cast(20f64).unwrap());\n-        })\n-    }\n-\n-    #[test] fn test_u8_cast()    { test_cast_20!(20u8)    }\n-    #[test] fn test_u16_cast()   { test_cast_20!(20u16)   }\n-    #[test] fn test_u32_cast()   { test_cast_20!(20u32)   }\n-    #[test] fn test_u64_cast()   { test_cast_20!(20u64)   }\n-    #[test] fn test_uint_cast()  { test_cast_20!(20usize) }\n-    #[test] fn test_i8_cast()    { test_cast_20!(20i8)    }\n-    #[test] fn test_i16_cast()   { test_cast_20!(20i16)   }\n-    #[test] fn test_i32_cast()   { test_cast_20!(20i32)   }\n-    #[test] fn test_i64_cast()   { test_cast_20!(20i64)   }\n-    #[test] fn test_int_cast()   { test_cast_20!(20)      }\n-    #[test] fn test_f32_cast()   { test_cast_20!(20f32)   }\n-    #[test] fn test_f64_cast()   { test_cast_20!(20f64)   }\n-\n-    #[test]\n-    fn test_cast_range_int_min() {\n-        assert_eq!(isize::MIN.to_int(),  Some(isize::MIN as isize));\n-        assert_eq!(isize::MIN.to_i8(),   None);\n-        assert_eq!(isize::MIN.to_i16(),  None);\n-        // isize::MIN.to_i32() is word-size specific\n-        assert_eq!(isize::MIN.to_i64(),  Some(isize::MIN as i64));\n-        assert_eq!(isize::MIN.to_uint(), None);\n-        assert_eq!(isize::MIN.to_u8(),   None);\n-        assert_eq!(isize::MIN.to_u16(),  None);\n-        assert_eq!(isize::MIN.to_u32(),  None);\n-        assert_eq!(isize::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), Some(isize::MIN as i32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_min() {\n-        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as isize));\n-        assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n-        assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n-        assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n-        assert_eq!(i8::MIN.to_i64(),  Some(i8::MIN as i64));\n-        assert_eq!(i8::MIN.to_uint(), None);\n-        assert_eq!(i8::MIN.to_u8(),   None);\n-        assert_eq!(i8::MIN.to_u16(),  None);\n-        assert_eq!(i8::MIN.to_u32(),  None);\n-        assert_eq!(i8::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_min() {\n-        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as isize));\n-        assert_eq!(i16::MIN.to_i8(),   None);\n-        assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n-        assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n-        assert_eq!(i16::MIN.to_i64(),  Some(i16::MIN as i64));\n-        assert_eq!(i16::MIN.to_uint(), None);\n-        assert_eq!(i16::MIN.to_u8(),   None);\n-        assert_eq!(i16::MIN.to_u16(),  None);\n-        assert_eq!(i16::MIN.to_u32(),  None);\n-        assert_eq!(i16::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_min() {\n-        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as isize));\n-        assert_eq!(i32::MIN.to_i8(),   None);\n-        assert_eq!(i32::MIN.to_i16(),  None);\n-        assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n-        assert_eq!(i32::MIN.to_i64(),  Some(i32::MIN as i64));\n-        assert_eq!(i32::MIN.to_uint(), None);\n-        assert_eq!(i32::MIN.to_u8(),   None);\n-        assert_eq!(i32::MIN.to_u16(),  None);\n-        assert_eq!(i32::MIN.to_u32(),  None);\n-        assert_eq!(i32::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_min() {\n-        // i64::MIN.to_int() is word-size specific\n-        assert_eq!(i64::MIN.to_i8(),   None);\n-        assert_eq!(i64::MIN.to_i16(),  None);\n-        assert_eq!(i64::MIN.to_i32(),  None);\n-        assert_eq!(i64::MIN.to_i64(),  Some(i64::MIN as i64));\n-        assert_eq!(i64::MIN.to_uint(), None);\n-        assert_eq!(i64::MIN.to_u8(),   None);\n-        assert_eq!(i64::MIN.to_u16(),  None);\n-        assert_eq!(i64::MIN.to_u32(),  None);\n-        assert_eq!(i64::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_int_max() {\n-        assert_eq!(isize::MAX.to_int(),  Some(isize::MAX as isize));\n-        assert_eq!(isize::MAX.to_i8(),   None);\n-        assert_eq!(isize::MAX.to_i16(),  None);\n-        // isize::MAX.to_i32() is word-size specific\n-        assert_eq!(isize::MAX.to_i64(),  Some(isize::MAX as i64));\n-        assert_eq!(isize::MAX.to_u8(),   None);\n-        assert_eq!(isize::MAX.to_u16(),  None);\n-        // isize::MAX.to_u32() is word-size specific\n-        assert_eq!(isize::MAX.to_u64(),  Some(isize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), Some(isize::MAX as i32));\n-            assert_eq!(isize::MAX.to_u32(), Some(isize::MAX as u32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), None);\n-            assert_eq!(isize::MAX.to_u32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_max() {\n-        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as isize));\n-        assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n-        assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n-        assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n-        assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n-        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as usize));\n-        assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n-        assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n-        assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n-        assert_eq!(i8::MAX.to_u64(),  Some(i8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_max() {\n-        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as isize));\n-        assert_eq!(i16::MAX.to_i8(),   None);\n-        assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n-        assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n-        assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n-        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as usize));\n-        assert_eq!(i16::MAX.to_u8(),   None);\n-        assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n-        assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n-        assert_eq!(i16::MAX.to_u64(),  Some(i16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_max() {\n-        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as isize));\n-        assert_eq!(i32::MAX.to_i8(),   None);\n-        assert_eq!(i32::MAX.to_i16(),  None);\n-        assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n-        assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n-        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as usize));\n-        assert_eq!(i32::MAX.to_u8(),   None);\n-        assert_eq!(i32::MAX.to_u16(),  None);\n-        assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n-        assert_eq!(i32::MAX.to_u64(),  Some(i32::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_max() {\n-        // i64::MAX.to_int() is word-size specific\n-        assert_eq!(i64::MAX.to_i8(),   None);\n-        assert_eq!(i64::MAX.to_i16(),  None);\n-        assert_eq!(i64::MAX.to_i32(),  None);\n-        assert_eq!(i64::MAX.to_i64(),  Some(i64::MAX as i64));\n-        // i64::MAX.to_uint() is word-size specific\n-        assert_eq!(i64::MAX.to_u8(),   None);\n-        assert_eq!(i64::MAX.to_u16(),  None);\n-        assert_eq!(i64::MAX.to_u32(),  None);\n-        assert_eq!(i64::MAX.to_u64(),  Some(i64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  None);\n-            assert_eq!(i64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as isize));\n-            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_min() {\n-        assert_eq!(usize::MIN.to_int(),  Some(usize::MIN as isize));\n-        assert_eq!(usize::MIN.to_i8(),   Some(usize::MIN as i8));\n-        assert_eq!(usize::MIN.to_i16(),  Some(usize::MIN as i16));\n-        assert_eq!(usize::MIN.to_i32(),  Some(usize::MIN as i32));\n-        assert_eq!(usize::MIN.to_i64(),  Some(usize::MIN as i64));\n-        assert_eq!(usize::MIN.to_uint(), Some(usize::MIN as usize));\n-        assert_eq!(usize::MIN.to_u8(),   Some(usize::MIN as u8));\n-        assert_eq!(usize::MIN.to_u16(),  Some(usize::MIN as u16));\n-        assert_eq!(usize::MIN.to_u32(),  Some(usize::MIN as u32));\n-        assert_eq!(usize::MIN.to_u64(),  Some(usize::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_min() {\n-        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as isize));\n-        assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n-        assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n-        assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n-        assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n-        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as usize));\n-        assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n-        assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n-        assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n-        assert_eq!(u8::MIN.to_u64(),  Some(u8::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_min() {\n-        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as isize));\n-        assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n-        assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n-        assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n-        assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n-        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as usize));\n-        assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n-        assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n-        assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n-        assert_eq!(u16::MIN.to_u64(),  Some(u16::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_min() {\n-        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as isize));\n-        assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n-        assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n-        assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n-        assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n-        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as usize));\n-        assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n-        assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n-        assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n-        assert_eq!(u32::MIN.to_u64(),  Some(u32::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_min() {\n-        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as isize));\n-        assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n-        assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n-        assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n-        assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n-        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as usize));\n-        assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n-        assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n-        assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n-        assert_eq!(u64::MIN.to_u64(),  Some(u64::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_max() {\n-        assert_eq!(usize::MAX.to_int(),  None);\n-        assert_eq!(usize::MAX.to_i8(),   None);\n-        assert_eq!(usize::MAX.to_i16(),  None);\n-        assert_eq!(usize::MAX.to_i32(),  None);\n-        // usize::MAX.to_i64() is word-size specific\n-        assert_eq!(usize::MAX.to_u8(),   None);\n-        assert_eq!(usize::MAX.to_u16(),  None);\n-        // usize::MAX.to_u32() is word-size specific\n-        assert_eq!(usize::MAX.to_u64(),  Some(usize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), Some(usize::MAX as u32));\n-            assert_eq!(usize::MAX.to_i64(), Some(usize::MAX as i64));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), None);\n-            assert_eq!(usize::MAX.to_i64(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_max() {\n-        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as isize));\n-        assert_eq!(u8::MAX.to_i8(),   None);\n-        assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n-        assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n-        assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n-        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as usize));\n-        assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n-        assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n-        assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n-        assert_eq!(u8::MAX.to_u64(),  Some(u8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_max() {\n-        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as isize));\n-        assert_eq!(u16::MAX.to_i8(),   None);\n-        assert_eq!(u16::MAX.to_i16(),  None);\n-        assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n-        assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n-        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as usize));\n-        assert_eq!(u16::MAX.to_u8(),   None);\n-        assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n-        assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n-        assert_eq!(u16::MAX.to_u64(),  Some(u16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_max() {\n-        // u32::MAX.to_int() is word-size specific\n-        assert_eq!(u32::MAX.to_i8(),   None);\n-        assert_eq!(u32::MAX.to_i16(),  None);\n-        assert_eq!(u32::MAX.to_i32(),  None);\n-        assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n-        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as usize));\n-        assert_eq!(u32::MAX.to_u8(),   None);\n-        assert_eq!(u32::MAX.to_u16(),  None);\n-        assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n-        assert_eq!(u32::MAX.to_u64(),  Some(u32::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_max() {\n-        assert_eq!(u64::MAX.to_int(),  None);\n-        assert_eq!(u64::MAX.to_i8(),   None);\n-        assert_eq!(u64::MAX.to_i16(),  None);\n-        assert_eq!(u64::MAX.to_i32(),  None);\n-        assert_eq!(u64::MAX.to_i64(),  None);\n-        // u64::MAX.to_uint() is word-size specific\n-        assert_eq!(u64::MAX.to_u8(),   None);\n-        assert_eq!(u64::MAX.to_u16(),  None);\n-        assert_eq!(u64::MAX.to_u32(),  None);\n-        assert_eq!(u64::MAX.to_u64(),  Some(u64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n+    use ops::Mul;\n \n     #[test]\n     fn test_saturating_add_uint() {\n@@ -1596,23 +106,23 @@ mod tests {\n     #[test]\n     fn test_saturating_add_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_add(5), 8);\n-        assert_eq!(3.saturating_add(MAX-1), MAX);\n+        assert_eq!(3i32.saturating_add(5), 8);\n+        assert_eq!(3isize.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n         assert_eq!((MAX-2).saturating_add(1), MAX-1);\n-        assert_eq!(3.saturating_add(-5), -2);\n+        assert_eq!(3i32.saturating_add(-5), -2);\n         assert_eq!(MIN.saturating_add(-1), MIN);\n-        assert_eq!((-2).saturating_add(-MAX), MIN);\n+        assert_eq!((-2isize).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_sub(5), -2);\n+        assert_eq!(3i32.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n-        assert_eq!((-2).saturating_sub(MAX), MIN);\n-        assert_eq!(3.saturating_sub(-5), 8);\n-        assert_eq!(3.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!((-2isize).saturating_sub(MAX), MIN);\n+        assert_eq!(3i32.saturating_sub(-5), 8);\n+        assert_eq!(3isize.saturating_sub(-(MAX-1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n         assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n     }\n@@ -1716,56 +226,10 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n \n-    #[derive(PartialEq, Debug)]\n-    struct Value { x: isize }\n-\n-    impl ToPrimitive for Value {\n-        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }\n-        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }\n-    }\n-\n-    impl FromPrimitive for Value {\n-        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }\n-        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }\n-    }\n-\n-    #[test]\n-    fn test_to_primitive() {\n-        let value = Value { x: 5 };\n-        assert_eq!(value.to_int(),  Some(5));\n-        assert_eq!(value.to_i8(),   Some(5));\n-        assert_eq!(value.to_i16(),  Some(5));\n-        assert_eq!(value.to_i32(),  Some(5));\n-        assert_eq!(value.to_i64(),  Some(5));\n-        assert_eq!(value.to_uint(), Some(5));\n-        assert_eq!(value.to_u8(),   Some(5));\n-        assert_eq!(value.to_u16(),  Some(5));\n-        assert_eq!(value.to_u32(),  Some(5));\n-        assert_eq!(value.to_u64(),  Some(5));\n-        assert_eq!(value.to_f32(),  Some(5f32));\n-        assert_eq!(value.to_f64(),  Some(5f64));\n-    }\n-\n-    #[test]\n-    fn test_from_primitive() {\n-        assert_eq!(from_int(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_i16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_uint(5),   Some(Value { x: 5 }));\n-        assert_eq!(from_u8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_u16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_f32(5f32), Some(Value { x: 5 }));\n-        assert_eq!(from_f64(5f64), Some(Value { x: 5 }));\n-    }\n-\n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Int>(base: T, exp: usize) -> T {\n-            let one: T = Int::one();\n+        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T {\n+            let one: T = T::one();\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n@@ -1775,11 +239,11 @@ mod tests {\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n         }\n-        assert_pow!((3,     0 ) => 1);\n-        assert_pow!((5,     1 ) => 5);\n-        assert_pow!((-4,    2 ) => 16);\n-        assert_pow!((8,     3 ) => 512);\n-        assert_pow!((2u64,   50) => 1125899906842624);\n+        assert_pow!((3u32,     0 ) => 1);\n+        assert_pow!((5u32,     1 ) => 5);\n+        assert_pow!((-4i32,    2 ) => 16);\n+        assert_pow!((8u32,     3 ) => 512);\n+        assert_pow!((2u64,     50) => 1125899906842624);\n     }\n \n     #[test]\n@@ -1854,12 +318,11 @@ mod tests {\n mod bench {\n     extern crate test;\n     use self::test::Bencher;\n-    use num::Int;\n     use prelude::v1::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = (0..1024).collect::<Vec<_>>();\n-        b.iter(|| {v.iter().fold(0, |old, new| old.pow(*new as u32));});\n+        let v = (0..1024).collect::<Vec<u32>>();\n+        b.iter(|| {v.iter().fold(0u32, |old, new| old.pow(*new as u32));});\n     }\n }"}, {"sha": "ce1da4742d1dffe0c5c042d6dc627f7bb8713f16", "filename": "src/libstd/num/strconv.rs", "status": "removed", "additions": 0, "deletions": 556, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -1,556 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(missing_docs)]\n-#![allow(deprecated)]\n-\n-use self::ExponentFormat::*;\n-use self::SignificantDigits::*;\n-use self::SignFormat::*;\n-\n-use char;\n-use num::{self, Int, Float, ToPrimitive};\n-use num::FpCategory as Fp;\n-use ops::FnMut;\n-use string::String;\n-use vec::Vec;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-#[derive(Copy, Clone)]\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec,\n-    /// Use exponential notation with the exponent having a base of 2 and the\n-    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n-    ExpBin,\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-#[derive(Copy, Clone)]\n-pub enum SignificantDigits {\n-    /// All calculable digits will be printed.\n-    ///\n-    /// Note that bignums or fractions may cause a surprisingly large number\n-    /// of digits to be printed.\n-    DigAll,\n-\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-/// How to emit the sign of a number.\n-#[derive(Copy, Clone)]\n-pub enum SignFormat {\n-    /// No sign will be printed. The exponent sign will also be emitted.\n-    SignNone,\n-    /// `-` will be printed for negative values, but no sign will be emitted\n-    /// for positive numbers.\n-    SignNeg,\n-    /// `+` will be printed for positive values, and `-` will be printed for\n-    /// negative values.\n-    SignAll,\n-}\n-\n-/// Converts an integral number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all integral string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36.\n-/// - `sign`          - How to emit the sign. Options are:\n-///     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n-///     - `SignNeg`:  Only `-` on negative values.\n-///     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n-/// - `f`             - a callback which will be invoked for each ascii character\n-///                     which composes the string representation of this integer\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T, F>(num: T, radix: usize, sign: SignFormat, mut f: F) where\n-    T: Int,\n-    F: FnMut(u8),\n-{\n-    assert!(2 <= radix && radix <= 36);\n-\n-    let _0: T = Int::zero();\n-\n-    let neg = num < _0;\n-    let radix_gen: T = num::cast(radix).unwrap();\n-\n-    let mut deccum = num;\n-    // This is just for integral types, the largest of which is a u64. The\n-    // smallest base that we can have is 2, so the most number of digits we're\n-    // ever going to have is 64\n-    let mut buf = [0; 64];\n-    let mut cur = 0;\n-\n-    // Loop at least once to make sure at least a `0` gets emitted.\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit_signed = deccum % radix_gen;\n-        let current_digit = if current_digit_signed < _0 {\n-            _0 - current_digit_signed\n-        } else {\n-            current_digit_signed\n-        };\n-        buf[cur] = match current_digit.to_u8().unwrap() {\n-            i @ 0...9 => b'0' + i,\n-            i         => b'a' + (i - 10),\n-        };\n-        cur += 1;\n-\n-        deccum = deccum / radix_gen;\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => { f(b'-'); }\n-        SignAll => { f(b'+'); }\n-        _ => ()\n-    }\n-\n-    // We built the number in reverse order, so un-reverse it here\n-    while cur > 0 {\n-        cur -= 1;\n-        f(buf[cur]);\n-    }\n-}\n-\n-/// Converts a number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all numeric string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert. Accepts any number that\n-///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n-///                     is used, then this base is only used for the significand. The exponent\n-///                     itself always printed using a base of 10.\n-/// - `negative_zero` - Whether to treat the special value `-0` as\n-///                     `-0` or as `+0`.\n-/// - `sign`          - How to emit the sign. See `SignFormat`.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-///\n-/// # Return value\n-///\n-/// A tuple containing the byte vector, and a boolean flag indicating\n-/// whether it represents a special value like `inf`, `-inf`, `NaN` or not.\n-/// It returns a tuple because there can be ambiguity between a special value\n-/// and a number representation at higher bases.\n-///\n-/// # Panics\n-///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-/// - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n-///   between digit and exponent sign `'e'`.\n-/// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n-///   between digit and exponent sign `'p'`.\n-pub fn float_to_str_bytes_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n-        ) -> (Vec<u8>, bool) {\n-    assert!(2 <= radix && radix <= 36);\n-    match exp_format {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ => ()\n-    }\n-\n-    let _0: T = Float::zero();\n-    let _1: T = Float::one();\n-\n-    match num.classify() {\n-        Fp::Nan => { return (b\"NaN\".to_vec(), true); }\n-        Fp::Infinite if num > _0 => {\n-            return match sign {\n-                SignAll => (b\"+inf\".to_vec(), true),\n-                _       => (b\"inf\".to_vec(), true)\n-            };\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return match sign {\n-                SignNone => (b\"inf\".to_vec(), true),\n-                _        => (b\"-inf\".to_vec(), true),\n-            };\n-        }\n-        _ => {}\n-    }\n-\n-    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    let mut buf = Vec::new();\n-    let radix_gen: T = num::cast(radix as isize).unwrap();\n-\n-    let (num, exp) = match exp_format {\n-        ExpNone => (num, 0),\n-        ExpDec | ExpBin => {\n-            if num == _0 {\n-                (num, 0)\n-            } else {\n-                let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n-                    ExpNone => unreachable!()\n-                };\n-\n-                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n-            }\n-        }\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit = (deccum % radix_gen).abs();\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_gen;\n-        deccum = deccum.trunc();\n-\n-        buf.push(char::from_digit(current_digit.to_isize().unwrap() as u32, radix)\n-             .unwrap() as u8);\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigAll          => (false, 0,       false),\n-        DigMax(count)   => (true,  count+1, false),\n-        DigExact(count) => (true,  count+1, true)\n-    };\n-\n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg | SignAll if neg => {\n-            buf.push(b'-');\n-        }\n-        SignAll => {\n-            buf.push(b'+');\n-        }\n-        _ => ()\n-    }\n-\n-    buf.reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = buf.len();\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf.push(b'.');\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_gen;\n-\n-            // Calculate the absolute value of each digit.\n-            // See note in first loop.\n-            let current_digit = deccum.trunc().abs();\n-\n-            buf.push(char::from_digit(\n-                current_digit.to_isize().unwrap() as u32, radix).unwrap() as u8);\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf.pop().unwrap());\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = buf.len() as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        buf.insert((i + 1) as usize, value2ascii(1));\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = buf.len() - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                buf = buf[.. (i + 1)].to_vec();\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = buf.len() - 1;\n-        if buf[max_i] == b'.' {\n-            buf = buf[.. max_i].to_vec();\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => (),\n-        _ => {\n-            buf.push(match exp_format {\n-                ExpDec if exp_upper => 'E',\n-                ExpDec if !exp_upper => 'e',\n-                ExpBin if exp_upper => 'P',\n-                ExpBin if !exp_upper => 'p',\n-                _ => unreachable!()\n-            } as u8);\n-\n-            int_to_str_bytes_common(exp, 10, sign, |c| buf.push(c));\n-        }\n-    }\n-\n-    (buf, false)\n-}\n-\n-/// Converts a number to its string representation. This is a wrapper for\n-/// `to_str_bytes_common()`, for details see there.\n-#[inline]\n-pub fn float_to_str_common<T: Float>(\n-        num: T, radix: u32, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n-        ) -> (String, bool) {\n-    let (bytes, special) = float_to_str_bytes_common(num, radix,\n-                               negative_zero, sign, digits, exp_format, exp_capital);\n-    (String::from_utf8(bytes).unwrap(), special)\n-}\n-\n-// Some constants for from_str_bytes_common's input validation,\n-// they define minimum radix values for which the character is a valid digit.\n-const DIGIT_P_RADIX: u32 = ('p' as u32) - ('a' as u32) + 11;\n-const DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n-\n-#[cfg(test)]\n-mod tests {\n-    use core::num::wrapping::WrappingOps;\n-    use string::ToString;\n-\n-    #[test]\n-    fn test_int_to_str_overflow() {\n-        let mut i8_val: i8 = 127;\n-        assert_eq!(i8_val.to_string(), \"127\");\n-\n-        i8_val = i8_val.wrapping_add(1);\n-        assert_eq!(i8_val.to_string(), \"-128\");\n-\n-        let mut i16_val: i16 = 32_767;\n-        assert_eq!(i16_val.to_string(), \"32767\");\n-\n-        i16_val = i16_val.wrapping_add(1);\n-        assert_eq!(i16_val.to_string(), \"-32768\");\n-\n-        let mut i32_val: i32 = 2_147_483_647;\n-        assert_eq!(i32_val.to_string(), \"2147483647\");\n-\n-        i32_val = i32_val.wrapping_add(1);\n-        assert_eq!(i32_val.to_string(), \"-2147483648\");\n-\n-        let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-        assert_eq!(i64_val.to_string(), \"9223372036854775807\");\n-\n-        i64_val = i64_val.wrapping_add(1);\n-        assert_eq!(i64_val.to_string(), \"-9223372036854775808\");\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(deprecated)] // rand\n-    extern crate test;\n-\n-    mod usize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: usize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n-        }\n-    }\n-\n-    mod isize {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use std::fmt;\n-\n-        #[inline]\n-        fn to_string(x: isize, base: u8) {\n-            format!(\"{}\", fmt::radix(x, base));\n-        }\n-\n-        #[bench]\n-        fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n-        }\n-\n-        #[bench]\n-        fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n-        }\n-\n-        #[bench]\n-        fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n-        }\n-\n-        #[bench]\n-        fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n-        }\n-\n-        #[bench]\n-        fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n-        }\n-    }\n-\n-    mod f64 {\n-        use super::test::Bencher;\n-        use rand::{thread_rng, Rng};\n-        use f64;\n-\n-        #[bench]\n-        fn float_to_string(b: &mut Bencher) {\n-            let mut rng = thread_rng();\n-            b.iter(|| { f64::to_string(rng.gen()); })\n-        }\n-    }\n-}"}, {"sha": "96b0ba1c77f8da8c600cf02a16eebabe43fe0960", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,12 +12,11 @@\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n \n-macro_rules! uint_module { ($T:ty) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use num::FromStrRadix;\n \n     fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n         ::str::FromStr::from_str(t).ok()\n@@ -38,15 +37,15 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n+        assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n }\n "}, {"sha": "11b057d0094ae1d0674b22db405f03307eb35a47", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -19,7 +19,6 @@ use rt::{backtrace, unwind};\n use sys::stdio::Stderr;\n use thread;\n \n-// Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n         RefCell::new(None)"}, {"sha": "e8052041aeb300a669eee29af47b3a74287fed9a", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -103,14 +103,14 @@ use core::prelude::*;\n use ascii::*;\n use borrow::{Borrow, IntoCow, ToOwned, Cow};\n use cmp;\n-use iter::{self, IntoIterator};\n+use iter;\n use mem;\n use ops::{self, Deref};\n use string::String;\n use vec::Vec;\n use fmt;\n \n-use ffi::{OsStr, OsString, AsOsStr};\n+use ffi::{OsStr, OsString};\n \n use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n@@ -1184,14 +1184,6 @@ impl AsRef<OsStr> for PathBuf {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for PathBuf {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self.inner[..]\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Into<OsString> for PathBuf {\n     fn into(self) -> OsString {\n@@ -1652,14 +1644,6 @@ impl AsRef<OsStr> for Path {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for Path {\n-    fn as_os_str(&self) -> &OsStr {\n-        &self.inner\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Path {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n@@ -1711,22 +1695,6 @@ impl cmp::Ord for Path {\n     }\n }\n \n-/// Freely convertible to a `Path`.\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n-pub trait AsPath {\n-    /// Converts to a `Path`.\n-    #[unstable(feature = \"std_misc\")]\n-    fn as_path(&self) -> &Path;\n-}\n-\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n-#[allow(deprecated)]\n-impl<T: AsOsStr + ?Sized> AsPath for T {\n-    fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Path {\n     fn as_ref(&self) -> &Path { self }"}, {"sha": "6dc11c505a914a6f76b597e3fa53d8d5c194a8cf", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -26,17 +26,19 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use boxed::Box;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use borrow::ToOwned;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use clone::Clone;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n-#[unstable(feature = \"convert\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use iter::DoubleEndedIterator;\n+#[doc(no_inline)] pub use default::Default;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use iter::ExactSizeIterator;\n+#[doc(no_inline)] pub use iter::{Iterator, Extend, IntoIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(no_inline)] pub use iter::{Iterator, Extend};\n+#[doc(no_inline)] pub use iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use option::Option::{self, Some, None};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2837bac445697348b4472a7034d27e92e193b059", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -67,7 +67,6 @@ mod test {\n     use prelude::v1::*;\n \n     use super::ReaderRng;\n-    use num::Int;\n     use rand::Rng;\n \n     #[test]\n@@ -78,18 +77,18 @@ mod test {\n                   0,   0, 0, 0, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u64(), 1.to_be());\n-        assert_eq!(rng.next_u64(), 2.to_be());\n-        assert_eq!(rng.next_u64(), 3.to_be());\n+        assert_eq!(rng.next_u64(), 1u64.to_be());\n+        assert_eq!(rng.next_u64(), 2u64.to_be());\n+        assert_eq!(rng.next_u64(), 3u64.to_be());\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n         let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u32(), 1.to_be());\n-        assert_eq!(rng.next_u32(), 2.to_be());\n-        assert_eq!(rng.next_u32(), 3.to_be());\n+        assert_eq!(rng.next_u32(), 1u32.to_be());\n+        assert_eq!(rng.next_u32(), 2u32.to_be());\n+        assert_eq!(rng.next_u32(), 3u32.to_be());\n     }\n     #[test]\n     fn test_reader_rng_fill_bytes() {"}, {"sha": "c2964b7a4f12506d15033e15ef93833f2c14c937", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -161,14 +161,6 @@ impl Condvar {\n         }\n     }\n \n-    /// Deprecated: use `wait_timeout_ms` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use wait_timeout_ms instead\")]\n-    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n-        self.wait_timeout_ms(guard, dur.num_milliseconds() as u32)\n-    }\n-\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///"}, {"sha": "fc21effb45a8da06cf01b0c57534325bbd2c1d06", "filename": "src/libstd/sys/common/net.rs", "status": "removed", "additions": 0, "deletions": 971, "changes": 971, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -1,971 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-use self::SocketStatus::*;\n-use self::InAddr::*;\n-\n-use ffi::{CString, CStr};\n-use old_io::net::addrinfo;\n-use old_io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n-use old_io::{IoResult, IoError};\n-use libc::{self, c_char, c_int};\n-use mem;\n-use num::Int;\n-use ptr::{self, null, null_mut};\n-use str;\n-use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n-          wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n-          decode_error_detailed};\n-use sync::{Arc, Mutex};\n-#[cfg(not(target_os = \"linux\"))]\n-use sync::MutexGuard;\n-use sys_common::{self, keep_going, short_write, timeout};\n-use cmp;\n-use old_io;\n-\n-// FIXME: move uses of Arc and deadline tracking to std::io\n-\n-#[derive(Debug)]\n-pub enum SocketStatus {\n-    Readable,\n-    Writable,\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// sockaddr and misc bindings\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn htons(u: u16) -> u16 {\n-    u.to_be()\n-}\n-pub fn ntohs(u: u16) -> u16 {\n-    Int::from_be(u)\n-}\n-\n-pub enum InAddr {\n-    In4Addr(libc::in_addr),\n-    In6Addr(libc::in6_addr),\n-}\n-\n-pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n-    match ip {\n-        Ipv4Addr(a, b, c, d) => {\n-            let ip = ((a as u32) << 24) |\n-                     ((b as u32) << 16) |\n-                     ((c as u32) <<  8) |\n-                     ((d as u32) <<  0);\n-            In4Addr(libc::in_addr {\n-                s_addr: Int::from_be(ip)\n-            })\n-        }\n-        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            In6Addr(libc::in6_addr {\n-                s6_addr: [\n-                    htons(a),\n-                    htons(b),\n-                    htons(c),\n-                    htons(d),\n-                    htons(e),\n-                    htons(f),\n-                    htons(g),\n-                    htons(h),\n-                ]\n-            })\n-        }\n-    }\n-}\n-\n-pub fn addr_to_sockaddr(addr: SocketAddr,\n-                    storage: &mut libc::sockaddr_storage)\n-                    -> libc::socklen_t {\n-    unsafe {\n-        let len = match ip_to_inaddr(addr.ip) {\n-            In4Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in;\n-                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n-                (*storage).sin_port = htons(addr.port);\n-                (*storage).sin_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in>()\n-            }\n-            In6Addr(inaddr) => {\n-                let storage = storage as *mut _ as *mut libc::sockaddr_in6;\n-                (*storage).sin6_family = libc::AF_INET6 as libc::sa_family_t;\n-                (*storage).sin6_port = htons(addr.port);\n-                (*storage).sin6_addr = inaddr;\n-                mem::size_of::<libc::sockaddr_in6>()\n-            }\n-        };\n-        return len as libc::socklen_t;\n-    }\n-}\n-\n-pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n-    unsafe {\n-        let fam = match addr.ip {\n-            Ipv4Addr(..) => libc::AF_INET,\n-            Ipv6Addr(..) => libc::AF_INET6,\n-        };\n-        match libc::socket(fam, ty, 0) as i32 {\n-            -1 => Err(last_net_error()),\n-            fd => Ok(fd as sock_t),\n-        }\n-    }\n-}\n-\n-pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n-                 payload: T) -> IoResult<()> {\n-    unsafe {\n-        let payload = &payload as *const T as *const libc::c_void;\n-        let ret = libc::setsockopt(fd, opt, val,\n-                                   payload,\n-                                   mem::size_of::<T>() as libc::socklen_t);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n-                           val: libc::c_int) -> IoResult<T> {\n-    unsafe {\n-        let mut slot: T = mem::zeroed();\n-        let mut len = mem::size_of::<T>() as libc::socklen_t;\n-        let ret = c::getsockopt(fd, opt, val,\n-                                &mut slot as *mut _ as *mut _,\n-                                &mut len);\n-        if ret != 0 {\n-            Err(last_net_error())\n-        } else {\n-            assert!(len as usize == mem::size_of::<T>());\n-            Ok(slot)\n-        }\n-    }\n-}\n-\n-pub fn sockname(fd: sock_t,\n-            f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n-                                         *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<SocketAddr>\n-{\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-    unsafe {\n-        let storage = &mut storage as *mut libc::sockaddr_storage;\n-        let ret = f(fd,\n-                    storage as *mut libc::sockaddr,\n-                    &mut len as *mut libc::socklen_t);\n-        if ret != 0 {\n-            return Err(last_net_error())\n-        }\n-    }\n-    return sockaddr_to_addr(&storage, len as usize);\n-}\n-\n-pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: usize) -> IoResult<SocketAddr> {\n-    match storage.ss_family as libc::c_int {\n-        libc::AF_INET => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n-            let storage: &libc::sockaddr_in = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let ip = (storage.sin_addr.s_addr as u32).to_be();\n-            let a = (ip >> 24) as u8;\n-            let b = (ip >> 16) as u8;\n-            let c = (ip >>  8) as u8;\n-            let d = (ip >>  0) as u8;\n-            Ok(SocketAddr {\n-                ip: Ipv4Addr(a, b, c, d),\n-                port: ntohs(storage.sin_port),\n-            })\n-        }\n-        libc::AF_INET6 => {\n-            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n-            let storage: &libc::sockaddr_in6 = unsafe {\n-                mem::transmute(storage)\n-            };\n-            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n-            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n-            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n-            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n-            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n-            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n-            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n-            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(SocketAddr {\n-                ip: Ipv6Addr(a, b, c, d, e, f, g, h),\n-                port: ntohs(storage.sin6_port),\n-            })\n-        }\n-        _ => {\n-            Err(IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"invalid argument\",\n-                detail: None,\n-            })\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_host_addresses\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getaddrinfo(node: *const c_char, service: *const c_char,\n-                   hints: *const libc::addrinfo,\n-                   res: *mut *mut libc::addrinfo) -> c_int;\n-    fn freeaddrinfo(res: *mut libc::addrinfo);\n-}\n-\n-pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<addrinfo::Hint>)\n-                          -> Result<Vec<addrinfo::Info>, IoError>\n-{\n-    sys::init_net();\n-\n-    assert!(host.is_some() || servname.is_some());\n-\n-    let c_host = match host {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = match servname {\n-        Some(x) => Some(try!(CString::new(x))),\n-        None => None,\n-    };\n-    let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-\n-    let hint = hint.map(|hint| {\n-        libc::addrinfo {\n-            ai_flags: hint.flags as c_int,\n-            ai_family: hint.family as c_int,\n-            ai_socktype: 0,\n-            ai_protocol: 0,\n-            ai_addrlen: 0,\n-            ai_canonname: null_mut(),\n-            ai_addr: null_mut(),\n-            ai_next: null_mut()\n-        }\n-    });\n-\n-    let hint_ptr = hint.as_ref().map_or(null(), |x| {\n-        x as *const libc::addrinfo\n-    });\n-    let mut res = null_mut();\n-\n-    // Make the call\n-    let s = unsafe {\n-        getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n-    };\n-\n-    // Error?\n-    if s != 0 {\n-        return Err(last_gai_error(s));\n-    }\n-\n-    // Collect all the results we found\n-    let mut addrs = Vec::new();\n-    let mut rp = res;\n-    while !rp.is_null() {\n-        unsafe {\n-            let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                             (*rp).ai_addrlen as usize));\n-            addrs.push(addrinfo::Info {\n-                address: addr,\n-                family: (*rp).ai_family as usize,\n-                socktype: None,\n-                protocol: None,\n-                flags: (*rp).ai_flags as usize\n-            });\n-\n-            rp = (*rp).ai_next as *mut libc::addrinfo;\n-        }\n-    }\n-\n-    unsafe { freeaddrinfo(res); }\n-\n-    Ok(addrs)\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// get_address_name\n-////////////////////////////////////////////////////////////////////////////////\n-\n-extern \"system\" {\n-    fn getnameinfo(sa: *const libc::sockaddr, salen: libc::socklen_t,\n-        host: *mut c_char, hostlen: libc::size_t,\n-        serv: *mut c_char, servlen: libc::size_t,\n-        flags: c_int) -> c_int;\n-}\n-\n-const NI_MAXHOST: usize = 1025;\n-\n-pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n-    let addr = SocketAddr{ip: addr, port: 0};\n-\n-    let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-    let len = addr_to_sockaddr(addr, &mut storage);\n-\n-    let mut hostbuf = [0 as c_char; NI_MAXHOST];\n-\n-    let res = unsafe {\n-        getnameinfo(&storage as *const _ as *const libc::sockaddr, len,\n-            hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n-            ptr::null_mut(), 0,\n-            0)\n-    };\n-\n-    if res != 0 {\n-        return Err(last_gai_error(res));\n-    }\n-\n-    unsafe {\n-        let data = CStr::from_ptr(hostbuf.as_ptr());\n-        Ok(str::from_utf8(data.to_bytes()).unwrap().to_string())\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Timeout helpers\n-//\n-// The read/write functions below are the helpers for reading/writing a socket\n-// with a possible deadline specified. This is generally viewed as a timed out\n-// I/O operation.\n-//\n-// From the application's perspective, timeouts apply to the I/O object, not to\n-// the underlying file descriptor (it's one timeout per object). This means that\n-// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n-//\n-// The next idea to implement timeouts would be to use nonblocking I/O. An\n-// invocation of select() would wait (with a timeout) for a socket to be ready.\n-// Once its ready, we can perform the operation. Note that the operation *must*\n-// be nonblocking, even though select() says the socket is ready. This is\n-// because some other thread could have come and stolen our data (handles can be\n-// cloned).\n-//\n-// To implement nonblocking I/O, the first option we have is to use the\n-// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n-// I/O objects, so this was initially viewed as unwise.\n-//\n-// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n-// send/recv, but the niftiness wears off once you realize it only works well on\n-// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n-// operation on Linux (no flag fiddling, no affecting other objects), but not on\n-// other platforms.\n-//\n-// To work around this constraint on other platforms, we end up using the\n-// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n-// could cause other objects' blocking operations to suddenly become\n-// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n-// falls back to using the same code path as nonblocking operations, but with an\n-// infinite timeout (select + send/recv). This helps emulate blocking\n-// reads/writes despite the underlying descriptor being nonblocking, as well as\n-// optimizing the fast path of just hitting one syscall in the good case.\n-//\n-// As a final caveat, this implementation uses a mutex so only one thread is\n-// doing a nonblocking operation at at time. This is the operation that comes\n-// after the select() (at which point we think the socket is ready). This is\n-// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n-// expect (wouldn't want someone turning it on when it should be off!). All\n-// operations performed in the lock are *nonblocking* to avoid holding the mutex\n-// forever.\n-//\n-// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n-// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n-// reads/writes are still blocking.\n-//\n-// Fun, fun!\n-//\n-// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n-// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n-\n-pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    R: FnMut(bool) -> libc::c_int,\n-{\n-    let mut ret = -1;\n-    if deadline == 0 {\n-        ret = retry(|| read(false));\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        loop {\n-            // With a timeout, first we wait for the socket to become\n-            // readable using select(), specifying the relevant timeout for\n-            // our previously set deadline.\n-            try!(await(&[fd], deadline, Readable));\n-\n-            // At this point, we're still within the timeout, and we've\n-            // determined that the socket is readable (as returned by\n-            // select). We must still read the socket in *nonblocking* mode\n-            // because some other thread could come steal our data. If we\n-            // fail to read some data, we retry (hence the outer loop) and\n-            // wait for the socket to become readable again.\n-            let _guard = lock();\n-            match retry(|| read(deadline.is_some())) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-               n => { ret = n; break }\n-            }\n-        }\n-    }\n-\n-    match ret {\n-        0 => Err(sys_common::eof()),\n-        n if n < 0 => Err(last_net_error()),\n-        n => Ok(n as usize)\n-    }\n-}\n-\n-pub fn write<T, L, W>(fd: sock_t,\n-                      deadline: u64,\n-                      buf: &[u8],\n-                      write_everything: bool,\n-                      mut lock: L,\n-                      mut write: W) -> IoResult<usize> where\n-    L: FnMut() -> T,\n-    W: FnMut(bool, *const u8, usize) -> i64,\n-{\n-    let mut ret = -1;\n-    let mut written = 0;\n-    if deadline == 0 {\n-        if write_everything {\n-            ret = keep_going(buf, |inner, len| {\n-                written = buf.len() - len;\n-                write(false, inner, len)\n-            });\n-        } else {\n-            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as usize; }\n-        }\n-    }\n-\n-    if deadline != 0 || (ret == -1 && wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        while written < buf.len() && (write_everything || written == 0) {\n-            // As with read(), first wait for the socket to be ready for\n-            // the I/O operation.\n-            match await(&[fd], deadline, Writable) {\n-                Err(ref e) if e.kind == old_io::EndOfFile && written > 0 => {\n-                    assert!(deadline.is_some());\n-                    return Err(short_write(written, \"short write\"))\n-                }\n-                Err(e) => return Err(e),\n-                Ok(()) => {}\n-            }\n-\n-            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforeseen circumstances.\n-            let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n-            let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len)) {\n-                -1 if wouldblock() => {}\n-                -1 => return Err(last_net_error()),\n-                n => { written += n as usize; }\n-            }\n-        }\n-        ret = 0;\n-    }\n-    if ret < 0 {\n-        Err(last_net_error())\n-    } else {\n-        Ok(written)\n-    }\n-}\n-\n-// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-// derived from.\n-pub fn connect_timeout(fd: sock_t,\n-                       addrp: *const libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n-    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n-    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n-    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n-\n-    // Make sure the call to connect() doesn't block\n-    set_nonblocking(fd, true);\n-\n-    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-        // If the connection is in progress, then we need to wait for it to\n-        // finish (with a timeout). The current strategy for doing this is\n-        // to use select() with a timeout.\n-        -1 if os::errno() as isize == INPROGRESS as isize ||\n-              os::errno() as isize == WOULDBLOCK as isize => {\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            c::fd_set(&mut set, fd);\n-            match await(fd, &mut set, timeout_ms) {\n-                0 => Err(timeout(\"connection timed out\")),\n-                -1 => Err(last_net_error()),\n-                _ => {\n-                    let err: libc::c_int = try!(\n-                        getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                    if err == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(decode_error_detailed(err))\n-                    }\n-                }\n-            }\n-        }\n-\n-        -1 => Err(last_net_error()),\n-        _ => Ok(()),\n-    };\n-\n-    // be sure to turn blocking I/O back on\n-    set_nonblocking(fd, false);\n-    return ret;\n-\n-    #[cfg(unix)]\n-    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let start = timer::now();\n-        retry(|| unsafe {\n-            // Recalculate the timeout each iteration (it is generally\n-            // undefined what the value of the 'tv' is after select\n-            // returns EINTR).\n-            let mut tv = ms_to_timeval(timeout - (timer::now() - start));\n-            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n-                      ptr::null_mut(), &mut tv)\n-        })\n-    }\n-    #[cfg(windows)]\n-    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n-        let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n-    }\n-}\n-\n-pub fn await(fds: &[sock_t], deadline: Option<u64>,\n-             status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    let mut max = 0;\n-    for &fd in fds {\n-        c::fd_set(&mut set, fd);\n-        max = cmp::max(max, fd + 1);\n-    }\n-    if cfg!(windows) {\n-        max = fds.len() as sock_t;\n-    }\n-\n-    let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::null_mut()),\n-        Writable => (ptr::null_mut(), &mut set as *mut _),\n-    };\n-    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n-\n-    match retry(|| {\n-        let now = timer::now();\n-        let tvp = match deadline {\n-            None => ptr::null_mut(),\n-            Some(deadline) => {\n-                // If we're past the deadline, then pass a 0 timeout to\n-                // select() so we can poll the status\n-                let ms = if deadline < now {0} else {deadline - now};\n-                tv = ms_to_timeval(ms);\n-                &mut tv as *mut _\n-            }\n-        };\n-        let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n-        };\n-        r\n-    }) {\n-        -1 => Err(last_net_error()),\n-        0 => Err(timeout(\"timed out\")),\n-        _ => Ok(()),\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Basic socket representation\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct Inner {\n-    fd: sock_t,\n-\n-    // Unused on Linux, where this lock is not necessary.\n-    #[allow(dead_code)]\n-    lock: Mutex<()>,\n-}\n-\n-impl Inner {\n-    fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: Mutex::new(()) }\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-pub struct Guard<'a> {\n-    pub fd: sock_t,\n-    pub guard: MutexGuard<'a, ()>,\n-}\n-\n-#[cfg(not(target_os = \"linux\"))]\n-#[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n-    fn drop(&mut self) {\n-        set_nonblocking(self.fd, false);\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// TCP streams\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl TcpStream {\n-    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpStream::new(fd);\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match timeout {\n-            Some(timeout) => {\n-                try!(connect_timeout(fd, addrp, len, timeout));\n-                Ok(ret)\n-            },\n-            None => {\n-                match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(last_error()),\n-                    _ => Ok(ret),\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn new(fd: sock_t) -> TcpStream {\n-        TcpStream {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n-                   nodelay as libc::c_int)\n-    }\n-\n-    pub fn set_keepalive(&mut self, seconds: Option<usize>) -> IoResult<()> {\n-        let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n-                             seconds.is_some() as libc::c_int);\n-        match seconds {\n-            Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n-            None => ret,\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(target_os = \"openbsd\")]\n-    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n-                   seconds as libc::c_int)\n-    }\n-    #[cfg(not(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\",\n-                  target_os = \"openbsd\")))]\n-    fn set_tcp_keepalive(&mut self, _seconds: usize) -> IoResult<()> {\n-        Ok(())\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let doread = |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recv(fd,\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as wrlen,\n-                       flags) as libc::c_int\n-        };\n-        read(fd, self.read_deadline, dolock, doread)\n-    }\n-\n-    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::send(fd,\n-                       buf as *const _,\n-                       len as wrlen,\n-                       flags) as i64\n-        };\n-        write(fd, self.write_deadline, buf, true, dolock, dowrite).map(|_| ())\n-    }\n-    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getpeername)\n-    }\n-\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-impl Clone for TcpStream {\n-    fn clone(&self) -> TcpStream {\n-        TcpStream {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// UDP\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct UdpSocket {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n-}\n-\n-impl UdpSocket {\n-    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n-        sys::init_net();\n-\n-        let fd = try!(socket(addr, libc::SOCK_DGRAM));\n-        let ret = UdpSocket {\n-            inner: Arc::new(Inner::new(fd)),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        };\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n-            _ => Ok(ret),\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_BROADCAST,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n-                   on as libc::c_int)\n-    }\n-\n-    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> {\n-        match ip_to_inaddr(addr) {\n-            In4Addr(addr) => {\n-                let mreq = libc::ip_mreq {\n-                    imr_multiaddr: addr,\n-                    // interface == INADDR_ANY\n-                    imr_interface: libc::in_addr { s_addr: 0x0 },\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IP, opt, mreq)\n-            }\n-            In6Addr(addr) => {\n-                let mreq = libc::ip6_mreq {\n-                    ipv6mr_multiaddr: addr,\n-                    ipv6mr_interface: 0,\n-                };\n-                setsockopt(self.fd(), libc::IPPROTO_IPV6, opt, mreq)\n-            }\n-        }\n-    }\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn lock_nonblocking(&self) {}\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n-        let ret = Guard {\n-            fd: self.fd(),\n-            guard: self.inner.lock.lock().unwrap(),\n-        };\n-        set_nonblocking(self.fd(), true);\n-        ret\n-    }\n-\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n-        let fd = self.fd();\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n-        let mut addrlen: libc::socklen_t =\n-                mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-\n-        let dolock = || self.lock_nonblocking();\n-        let n = try!(read(fd, self.read_deadline, dolock, |nb| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::recvfrom(fd,\n-                           buf.as_mut_ptr() as *mut libc::c_void,\n-                           buf.len() as msglen_t,\n-                           flags,\n-                           storagep,\n-                           &mut addrlen) as libc::c_int\n-        }));\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize).unwrap()))\n-    }\n-\n-    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        let mut storage = unsafe { mem::zeroed() };\n-        let dstlen = addr_to_sockaddr(dst, &mut storage);\n-        let dstp = &storage as *const _ as *const libc::sockaddr;\n-\n-        let fd = self.fd();\n-        let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: usize| unsafe {\n-            let flags = if nb {c::MSG_DONTWAIT} else {0};\n-            libc::sendto(fd,\n-                         buf as *const libc::c_void,\n-                         len as msglen_t,\n-                         flags,\n-                         dstp,\n-                         dstlen) as i64\n-        };\n-\n-        let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n-        assert!(n == buf.len(), \"UDP packet not completely written.\");\n-        Ok(())\n-    }\n-\n-    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n-            }\n-        }\n-    }\n-    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        match multi {\n-            Ipv4Addr(..) => {\n-                self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n-            }\n-            Ipv6Addr(..) => {\n-                self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n-            }\n-        }\n-    }\n-\n-    pub fn multicast_time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n-                   ttl as libc::c_int)\n-    }\n-    pub fn time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n-        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n-    }\n-\n-    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-        self.read_deadline = deadline;\n-        self.write_deadline = deadline;\n-    }\n-    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl Clone for UdpSocket {\n-    fn clone(&self) -> UdpSocket {\n-        UdpSocket {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        }\n-    }\n-}"}, {"sha": "56a952e6a7ef6e0d291e34c74cd853507917b7b0", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -35,10 +35,8 @@ use borrow::Cow;\n use cmp;\n use fmt;\n use hash::{Hash, Hasher};\n-use iter::{FromIterator, IntoIterator};\n+use iter::FromIterator;\n use mem;\n-#[allow(deprecated)] // Int\n-use num::Int;\n use ops;\n use slice;\n use str;"}, {"sha": "ed6382e000ac90278a0c2e5b852e4c3cd154a2e2", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,7 +17,6 @@ use sys::mutex::{self, Mutex};\n use sys::time;\n use sys::sync as ffi;\n use time::Duration;\n-use num::{Int, NumCast};\n \n pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n \n@@ -70,8 +69,8 @@ impl Condvar {\n         let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n-        let seconds = NumCast::from(dur.num_seconds());\n-        let timeout = match seconds.and_then(|s| sys_now.tv_sec.checked_add(s)) {\n+        let seconds = dur.num_seconds() as libc::time_t;\n+        let timeout = match sys_now.tv_sec.checked_add(seconds) {\n             Some(sec) => {\n                 libc::timespec {\n                     tv_sec: sec,\n@@ -81,7 +80,7 @@ impl Condvar {\n             }\n             None => {\n                 libc::timespec {\n-                    tv_sec: Int::max_value(),\n+                    tv_sec: <libc::time_t>::max_value(),\n                     tv_nsec: 1_000_000_000 - 1,\n                 }\n             }"}, {"sha": "9504fe636978859d6b103d9317dd41cababe9a3b", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -189,8 +189,12 @@ pub mod ffi {\n #[unstable(feature = \"fs_ext\",\n            reason = \"may want a more useful mode abstraction\")]\n pub mod fs {\n+    use sys;\n     use sys_common::{FromInner, AsInner, AsInnerMut};\n     use fs::{Permissions, OpenOptions};\n+    use path::Path;\n+    use convert::AsRef;\n+    use io;\n \n     /// Unix-specific extensions to `Permissions`\n     pub trait PermissionsExt {\n@@ -220,6 +224,36 @@ pub mod fs {\n             self.as_inner_mut().mode(mode); self\n         }\n     }\n+\n+    /// Creates a new symbolic link on the filesystem.\n+    ///\n+    /// The `dst` path will be a symbolic link pointing to the `src` path.\n+    ///\n+    /// # Note\n+    ///\n+    /// On Windows, you must specify whether a symbolic link points to a file\n+    /// or directory.  Use `os::windows::fs::symlink_file` to create a\n+    /// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n+    /// symbolic link to a directory.  Additionally, the process must have\n+    /// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n+    /// symbolic link.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(fs_ext)]\n+    /// use std::os::unix::fs;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// try!(fs::symlink(\"a.txt\", \"b.txt\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n+    {\n+        sys::fs2::symlink(src.as_ref(), dst.as_ref())\n+    }\n+\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "fe0ede80fc663cbda1451a8cfffecb65aaecb178", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use libc;\n-use sys::os;\n-\n-use sys::fs::FileDesc;\n-\n-pub type signal = libc::c_int;\n-\n-pub fn new() -> (signal, signal) {\n-    let (a, b) = unsafe { os::pipe().unwrap() };\n-    (a.unwrap(), b.unwrap())\n-}\n-\n-pub fn signal(fd: libc::c_int) {\n-    FileDesc::new(fd, false).write(&[0]).unwrap();\n-}\n-\n-pub fn close(fd: libc::c_int) {\n-    let _fd = FileDesc::new(fd, true);\n-}"}, {"sha": "d99753a6a4c800c47b0237b23fa2b5dfb328d652", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,7 +15,8 @@ use prelude::v1::*;\n \n use io::{self, ErrorKind};\n use libc;\n-use num::{Int, SignedInt};\n+use num::One;\n+use ops::Neg;\n \n pub mod backtrace;\n pub mod c;\n@@ -63,23 +64,8 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-#[inline]\n-#[allow(deprecated)]\n-pub fn retry<T, F> (mut f: F) -> T where\n-    T: SignedInt,\n-    F: FnMut() -> T,\n-{\n-    let one: T = Int::one();\n-    loop {\n-        let n = f();\n-        if n == -one && os::errno() == libc::EINTR as i32 { }\n-        else { return n }\n-    }\n-}\n-\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + PartialEq + Neg<Output=T>>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(io::Error::last_os_error())\n     } else {\n@@ -89,7 +75,7 @@ pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n \n #[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: SignedInt, F: FnMut() -> T\n+    where T: One + PartialEq + Neg<Output=T>, F: FnMut() -> T\n {\n     loop {\n         match cvt(f()) {"}, {"sha": "4e7c4d241f53209b2f0acbf99aef8a467d2d7ea8", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -19,7 +19,7 @@ use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n use ptr;\n use sys::pipe2::AnonPipe;\n-use sys::{self, retry, c, cvt};\n+use sys::{self, c, cvt, cvt_r};\n use sys::fs2::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -273,7 +273,7 @@ impl Process {\n                     }\n                 }\n             };\n-            retry(|| libc::dup2(fd.raw(), dst)) != -1\n+            cvt_r(|| libc::dup2(fd.raw(), dst)).is_ok()\n         };\n \n         if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n@@ -317,19 +317,19 @@ impl Process {\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n         let mut status = 0 as c_int;\n-        try!(cvt(retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) })));\n+        try!(cvt_r(|| unsafe { c::waitpid(self.pid, &mut status, 0) }));\n         Ok(translate_status(status))\n     }\n \n     pub fn try_wait(&self) -> Option<ExitStatus> {\n         let mut status = 0 as c_int;\n-        match retry(|| unsafe {\n+        match cvt_r(|| unsafe {\n             c::waitpid(self.pid, &mut status, c::WNOHANG)\n         }) {\n-            n if n == self.pid => Some(translate_status(status)),\n-            0 => None,\n-            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n-                       io::Error::last_os_error()),\n+            Ok(0) => None,\n+            Ok(n) if n == self.pid => Some(translate_status(status)),\n+            Ok(n) => panic!(\"unkown pid: {}\", n),\n+            Err(e) => panic!(\"unknown waitpid error: {}\", e),\n         }\n     }\n }"}, {"sha": "331bfbfff36f9bbe169e077e599782ced061e3fd", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -54,6 +54,8 @@ pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n pub const FSCTL_GET_REPARSE_POINT: libc::DWORD = 0x900a8;\n pub const IO_REPARSE_TAG_SYMLINK: libc::DWORD = 0xa000000c;\n \n+pub const SYMBOLIC_LINK_FLAG_DIRECTORY: libc::DWORD = 0x1;\n+\n // Note that these are not actually HANDLEs, just values to pass to GetStdHandle\n pub const STD_INPUT_HANDLE: libc::DWORD = -10i32 as libc::DWORD;\n pub const STD_OUTPUT_HANDLE: libc::DWORD = -11i32 as libc::DWORD;"}, {"sha": "eac6496870eabcd2f79720e8c647a20df9b7ff6d", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -191,7 +191,11 @@ pub mod ffi {\n #[unstable(feature = \"fs_ext\", reason = \"may require more thought/methods\")]\n pub mod fs {\n     use fs::OpenOptions;\n+    use sys;\n     use sys_common::AsInnerMut;\n+    use path::Path;\n+    use convert::AsRef;\n+    use io;\n \n     /// Windows-specific extensions to `OpenOptions`\n     pub trait OpenOptionsExt {\n@@ -235,6 +239,50 @@ pub mod fs {\n             self.as_inner_mut().share_mode(access); self\n         }\n     }\n+\n+    /// Creates a new file symbolic link on the filesystem.\n+    ///\n+    /// The `dst` path will be a file symbolic link pointing to the `src`\n+    /// path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// #![feature(fs_ext)]\n+    /// use std::os::windows::fs;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// try!(fs::symlink_file(\"a.txt\", \"b.txt\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n+                                                        -> io::Result<()>\n+    {\n+        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n+    }\n+\n+    /// Creates a new directory symlink on the filesystem.\n+    ///\n+    /// The `dst` path will be a directory symbolic link pointing to the `src`\n+    /// path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// #![feature(fs_ext)]\n+    /// use std::os::windows::fs;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// try!(fs::symlink_file(\"a\", \"b\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>> (src: P, dst: Q)\n+                                                        -> io::Result<()>\n+    {\n+        sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n+    }\n }\n \n /// A prelude for conveniently writing platform-specific code."}, {"sha": "5ac9a0ace5801ba08d6b914935d5bea27f72792b", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,8 +12,7 @@ use core::prelude::*;\n use io::prelude::*;\n use os::windows::prelude::*;\n \n-use default::Default;\n-use ffi::{OsString, AsOsStr};\n+use ffi::OsString;\n use fmt;\n use io::{self, Error, SeekFrom};\n use libc::{self, HANDLE};\n@@ -412,11 +411,16 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    symlink_inner(src, dst, false)\n+}\n+\n+pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n     use sys::c::compat::kernel32::CreateSymbolicLinkW;\n     let src = to_utf16(src);\n     let dst = to_utf16(dst);\n+    let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     try!(cvt(unsafe {\n-        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n+        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n     }));\n     Ok(())\n }"}, {"sha": "5ae5f6f201bad0bcffb03d7f8e978544bb60ba52", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,8 +17,7 @@ use prelude::v1::*;\n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n-#[allow(deprecated)]\n-use num::Int;\n+use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n \n@@ -144,9 +143,8 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-#[allow(deprecated)]\n-fn cvt<I: Int>(i: I) -> io::Result<I> {\n-    if i == Int::zero() {\n+fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n+    if i == I::zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)"}, {"sha": "6bbcd968157aba084deecae84dbe9fad92a8456a", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,8 +15,8 @@ use libc::consts::os::extra::INVALID_SOCKET;\n use libc::{self, c_int, c_void};\n use mem;\n use net::SocketAddr;\n-#[allow(deprecated)]\n-use num::{SignedInt, Int};\n+use num::One;\n+use ops::Neg;\n use rt;\n use sync::{Once, ONCE_INIT};\n use sys::c;\n@@ -49,11 +49,8 @@ fn last_error() -> io::Error {\n /// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n /// and if so, returns the last error from the Windows socket interface. . This\n /// function must be called before another call to the socket API is made.\n-///\n-/// FIXME: generics needed?\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + Neg<Output=T> + PartialEq>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(last_error())\n     } else {\n@@ -70,7 +67,9 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n /// Provides the functionality of `cvt` for a closure.\n #[allow(deprecated)]\n-pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+    where F: FnMut() -> T, T: One + Neg<Output=T> + PartialEq\n+{\n     cvt(f())\n }\n "}, {"sha": "5ddcf3d1ea2991f9f62ce90b436b2d6a3510b005", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -140,7 +140,7 @@ impl Process {\n         // read the *child's* PATH if one is provided. See #15149 for more details.\n         let program = cfg.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n-                if OsStr::from_str(\"PATH\") != &**key { continue }\n+                if OsStr::new(\"PATH\") != &**key { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n@@ -463,7 +463,7 @@ mod tests {\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             String::from_utf16(\n-                &make_command_line(OsStr::from_str(prog),\n+                &make_command_line(OsStr::new(prog),\n                                    &args.iter()\n                                         .map(|a| OsString::from(a))\n                                         .collect::<Vec<OsString>>())).unwrap()"}, {"sha": "c65377e238f8fb589fe2d6125970fe050b612dec", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -497,15 +497,6 @@ pub fn sleep_ms(ms: u32) {\n     imp::sleep(Duration::milliseconds(ms as i64))\n }\n \n-/// Deprecated: use `sleep_ms` instead.\n-#[unstable(feature = \"thread_sleep\",\n-           reason = \"recently added, needs an RFC, and `Duration` itself is \\\n-                     unstable\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use sleep_ms instead\")]\n-pub fn sleep(dur: Duration) {\n-    imp::sleep(dur)\n-}\n-\n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n ///\n /// See the module doc for more detail.\n@@ -546,13 +537,6 @@ pub fn park_timeout_ms(ms: u32) {\n     *guard = false;\n }\n \n-/// Deprecated: use `park_timeout_ms`\n-#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use park_timeout_ms instead\")]\n-pub fn park_timeout(duration: Duration) {\n-    park_timeout_ms(duration.num_milliseconds() as u32)\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "636a0dd697a2bb6003f0a15d87e9f1e2f09bfdd2", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,13 +12,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use prelude::v1::*;\n+\n use {fmt, i64};\n-use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n-use option::Option;\n-use option::Option::{Some, None};\n-#[allow(deprecated)] // Int\n-use num::Int;\n-use result::Result::Ok;\n+use ops::{Add, Sub, Mul, Div, Neg};\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "399810cb7f5010ae6d6a4042efadd15bbd347e1e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -66,8 +66,6 @@ use parse::lexer;\n use ptr::P;\n \n use std::fmt;\n-#[allow(deprecated)]\n-use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -1142,16 +1140,24 @@ pub enum Sign {\n }\n \n impl Sign {\n-    #[allow(deprecated)] // Int\n-    pub fn new<T:Int>(n: T) -> Sign {\n-        if n < Int::zero() {\n-            Minus\n-        } else {\n-            Plus\n-        }\n+    pub fn new<T: IntSign>(n: T) -> Sign {\n+        n.sign()\n     }\n }\n \n+pub trait IntSign {\n+    fn sign(&self) -> Sign;\n+}\n+macro_rules! doit {\n+    ($($t:ident)*) => ($(impl IntSign for $t {\n+        #[allow(unused_comparisons)]\n+        fn sign(&self) -> Sign {\n+            if *self < 0 {Minus} else {Plus}\n+        }\n+    })*)\n+}\n+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n     SignedIntLit(IntTy, Sign),"}, {"sha": "78f06ce5fd5d07f8025a4c5e1b688d0ce32afbcb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -238,7 +238,7 @@ pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident {\n     let mut pretty = match ty {\n         Some(t) => pprust::ty_to_string(t),\n-        None => String::from_str(\"..\")\n+        None => String::from(\"..\")\n     };\n \n     match *trait_ref {"}, {"sha": "34ad192845c58e2f94a6f5d150b81b6e3a893452", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -20,13 +20,11 @@\n pub use self::MacroFormat::*;\n \n use std::cell::RefCell;\n-use std::num::ToPrimitive;\n use std::ops::{Add, Sub};\n use std::rc::Rc;\n \n use std::fmt;\n \n-use libc::c_uint;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n \n@@ -287,13 +285,12 @@ pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n \n impl ExpnId {\n-    pub fn from_llvm_cookie(cookie: c_uint) -> ExpnId {\n-        ExpnId(cookie)\n+    pub fn from_u32(id: u32) -> ExpnId {\n+        ExpnId(id)\n     }\n \n-    pub fn to_llvm_cookie(self) -> i32 {\n-        let ExpnId(cookie) = self;\n-        cookie as i32\n+    pub fn into_u32(self) -> u32 {\n+        self.0\n     }\n }\n \n@@ -557,9 +554,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from_str(&src[3..])\n+            String::from(&src[3..])\n         } else {\n-            String::from_str(&src[..])\n+            String::from(&src[..])\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -594,8 +591,8 @@ impl CodeMap {\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n                                 source_len: usize,\n-                                file_local_lines: Vec<BytePos>,\n-                                file_local_multibyte_chars: Vec<MultiByteChar>)\n+                                mut file_local_lines: Vec<BytePos>,\n+                                mut file_local_multibyte_chars: Vec<MultiByteChar>)\n                                 -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n@@ -606,19 +603,21 @@ impl CodeMap {\n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);\n \n-        let lines = file_local_lines.map_in_place(|pos| pos + start_pos);\n-        let multibyte_chars = file_local_multibyte_chars.map_in_place(|mbc| MultiByteChar {\n-            pos: mbc.pos + start_pos,\n-            bytes: mbc.bytes\n-        });\n+        for pos in &mut file_local_lines {\n+            *pos = *pos + start_pos;\n+        }\n+\n+        for mbc in &mut file_local_multibyte_chars {\n+            mbc.pos = mbc.pos + start_pos;\n+        }\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n-            lines: RefCell::new(lines),\n-            multibyte_chars: RefCell::new(multibyte_chars),\n+            lines: RefCell::new(file_local_lines),\n+            multibyte_chars: RefCell::new(file_local_multibyte_chars),\n         });\n \n         files.push(filemap.clone());\n@@ -862,7 +861,11 @@ impl CodeMap {\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);\n-        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+        let len = expansions.len();\n+        if len > u32::max_value() as usize {\n+            panic!(\"too many ExpnInfo's!\");\n+        }\n+        ExpnId(len as u32 - 1)\n     }\n \n     pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where"}, {"sha": "366806bc19b4962882552eb27725679acb9d1177", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -284,8 +284,15 @@ impl<'a> fold::Folder for CfgAttrFolder<'a> {\n             return fold::noop_fold_attribute(attr, self);\n         }\n \n-        let (cfg, mi) = match attr.meta_item_list() {\n-            Some([ref cfg, ref mi]) => (cfg, mi),\n+        let attr_list = match attr.meta_item_list() {\n+            Some(attr_list) => attr_list,\n+            None => {\n+                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                return None;\n+            }\n+        };\n+        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n+            (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n                 self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n                 return None;"}, {"sha": "a7453636c445c6c6d7d546e022d5f06b68760dee", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -644,7 +644,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n \n             try!(write!(&mut err.dst, \"{}\", s));\n-            let mut s = String::from_str(\"^\");\n+            let mut s = String::from(\"^\");\n             let count = match lastc {\n                 // Most terminals have a tab stop every eight columns by default\n                 '\\t' => 8 - col%8,"}, {"sha": "6de4edafa0bf5cafaadd4457d54aeca6d6093bcd", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -54,8 +54,8 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<MacResult+'cx> {\n-    let code = match token_tree {\n-        [ast::TtToken(_, token::Ident(code, _))] => code,\n+    let code = match (token_tree.len(), token_tree.get(0)) {\n+        (1, Some(&ast::TtToken(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n     };\n     with_used_diagnostics(|diagnostics| {\n@@ -77,20 +77,25 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    MacEager::expr(quote_expr!(ecx, ()))\n+    MacEager::expr(ecx.expr_tuple(span, Vec::new()))\n }\n \n pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<MacResult+'cx> {\n-    let (code, description) = match token_tree {\n-        [ast::TtToken(_, token::Ident(ref code, _))] => {\n+    let (code, description) = match (\n+        token_tree.len(),\n+        token_tree.get(0),\n+        token_tree.get(1),\n+        token_tree.get(2)\n+    ) {\n+        (1, Some(&ast::TtToken(_, token::Ident(ref code, _))), None, None) => {\n             (code, None)\n         },\n-        [ast::TtToken(_, token::Ident(ref code, _)),\n-         ast::TtToken(_, token::Comma),\n-         ast::TtToken(_, token::Literal(token::StrRaw(description, _), None))] => {\n+        (3, Some(&ast::TtToken(_, token::Ident(ref code, _))),\n+            Some(&ast::TtToken(_, token::Comma)),\n+            Some(&ast::TtToken(_, token::Literal(token::StrRaw(description, _), None)))) => {\n             (code, Some(description))\n         }\n         _ => unreachable!()\n@@ -123,15 +128,23 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n     let sym = Ident::new(token::gensym(&(\n         \"__register_diagnostic_\".to_string() + &token::get_ident(*code)\n     )));\n-    MacEager::items(SmallVector::many(vec![quote_item!(ecx, mod $sym {}).unwrap()]))\n+    MacEager::items(SmallVector::many(vec![\n+        ecx.item_mod(\n+            span,\n+            span,\n+            sym,\n+            Vec::new(),\n+            Vec::new()\n+        )\n+    ]))\n }\n \n pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n-    let name = match token_tree {\n-        [ast::TtToken(_, token::Ident(ref name, _))] => name,\n+    let name = match (token_tree.len(), token_tree.get(0)) {\n+        (1, Some(&ast::TtToken(_, token::Ident(ref name, _)))) => name,\n         _ => unreachable!()\n     };\n \n@@ -148,7 +161,37 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             (descriptions.len(), ecx.expr_vec(span, descriptions))\n         });\n \n-    MacEager::items(SmallVector::many(vec![quote_item!(ecx,\n-        pub static $name: [(&'static str, &'static str); $count] = $expr;\n-    ).unwrap()]))\n+    let static_ = ecx.lifetime(span, ecx.name_of(\"'static\"));\n+    let ty_str = ecx.ty_rptr(\n+        span,\n+        ecx.ty_ident(span, ecx.ident_of(\"str\")),\n+        Some(static_),\n+        ast::MutImmutable,\n+    );\n+\n+    let ty = ecx.ty(\n+        span,\n+        ast::TyFixedLengthVec(\n+            ecx.ty(\n+                span,\n+                ast::TyTup(vec![ty_str.clone(), ty_str])\n+            ),\n+            ecx.expr_usize(span, count),\n+        ),\n+    );\n+\n+    MacEager::items(SmallVector::many(vec![\n+        P(ast::Item {\n+            ident: name.clone(),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::ItemStatic(\n+                ty,\n+                ast::MutImmutable,\n+                expr,\n+            ),\n+            vis: ast::Public,\n+            span: span,\n+        })\n+    ]))\n }"}, {"sha": "50ab430f148ca7ece5e5f4468913e78b6ab95586", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -262,10 +262,10 @@ macro_rules! make_MacEager {\n         impl MacEager {\n             $(\n                 pub fn $fld(v: $t) -> Box<MacResult> {\n-                    box MacEager {\n+                    Box::new(MacEager {\n                         $fld: Some(v),\n                         ..Default::default()\n-                    }\n+                    })\n                 }\n             )*\n         }\n@@ -331,7 +331,7 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: false, span: sp }\n+        Box::new(DummyResult { expr_only: false, span: sp })\n     }\n \n     /// Create a default MacResult that can only be an expression.\n@@ -340,7 +340,7 @@ impl DummyResult {\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n     pub fn expr(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: true, span: sp }\n+        Box::new(DummyResult { expr_only: true, span: sp })\n     }\n \n     /// A plain dummy expression."}, {"sha": "94cc0d9c493f21dc0abfe6e09b1082138fb26f27", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -106,8 +106,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n                 };\n "}, {"sha": "61eb81c6755e2663e37baf05b61c1804dd5f6902", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -29,8 +29,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         cs_fold(\n             true,  // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n \n@@ -46,8 +46,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         cs_fold(\n             true,  // use foldl\n             |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n                 };\n "}, {"sha": "dbb779decace27715f6eab03ff5ac36299a91a58", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -47,7 +47,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n     let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n     let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                     None,\n-                                    vec![box ordering_ty],\n+                                    vec![Box::new(ordering_ty)],\n                                     true));\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -150,8 +150,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n+                let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                    (1, Some(o_f)) => o_f,\n                     _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n                 };\n \n@@ -208,8 +208,8 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n             get use the binops to avoid auto-deref dereferencing too many\n             layers of pointers, if the type includes pointers.\n             */\n-            let other_f = match other_fs {\n-                [ref o_f] => o_f,\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             };\n "}, {"sha": "0b31f06f87d0676c19615d079c461f87ef4fe30f", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -68,14 +68,14 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                     vec!(), true))))\n                 },\n                 explicit_self: None,\n-                args: vec!(Ptr(box Literal(Path::new_local(\"__D\")),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__D\"))),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(box Self_, box Literal(Path::new_(\n+                    vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n                         vec![\"__D\", \"Error\"], None, vec![], false\n-                    ))),\n+                    )))),\n                     true\n                 )),\n                 attributes: Vec::new(),"}, {"sha": "92944d649332f04617e1dea75f8cd75d10687090", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -144,14 +144,14 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                     vec!(), true))))\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(box Literal(Path::new_local(\"__S\")),\n+                args: vec!(Ptr(Box::new(Literal(Path::new_local(\"__S\"))),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(box Tuple(Vec::new()), box Literal(Path::new_(\n+                    vec!(Box::new(Tuple(Vec::new())), Box::new(Literal(Path::new_(\n                         vec![\"__S\", \"Error\"], None, vec![], false\n-                    ))),\n+                    )))),\n                     true\n                 )),\n                 attributes: Vec::new(),"}, {"sha": "4c05cd973ff6f3252751ee7c2a96e644010b9840", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -807,7 +807,7 @@ impl<'a> MethodDef<'a> {\n                 Self_ if nonstatic  => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(box Self_, _) if nonstatic => {\n+                Ptr(ref ty, _) if **ty == Self_ && nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {\n@@ -1103,7 +1103,7 @@ impl<'a> MethodDef<'a> {\n                     subpats.push(p);\n                     idents\n                 };\n-                for self_arg_name in self_arg_names.tail() {\n+                for self_arg_name in &self_arg_names[1..] {\n                     let (p, idents) = mk_self_pat(cx, &self_arg_name[..]);\n                     subpats.push(p);\n                     self_pats_idents.push(idents);"}, {"sha": "9e8e68c0b8cce1e49c80434939b7bc42dba67984", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -24,7 +24,7 @@ use parse::token::special_idents;\n use ptr::P;\n \n /// The types of pointers\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum PtrTy<'a> {\n     /// &'lifetime mut\n     Borrowed(Option<&'a str>, ast::Mutability),\n@@ -34,7 +34,7 @@ pub enum PtrTy<'a> {\n \n /// A path, e.g. `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub struct Path<'a> {\n     pub path: Vec<&'a str> ,\n     pub lifetime: Option<&'a str>,\n@@ -85,7 +85,7 @@ impl<'a> Path<'a> {\n }\n \n /// A type. Supports pointers, Self, and literals\n-#[derive(Clone)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum Ty<'a> {\n     Self_,\n     /// &/Box/ Ty\n@@ -109,7 +109,7 @@ pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n }\n \n pub fn borrowed_self<'r>() -> Ty<'r> {\n-    borrowed(box Self_)\n+    borrowed(Box::new(Self_))\n }\n \n pub fn nil_ty<'r>() -> Ty<'r> {"}, {"sha": "b9835eda791f7f004589c170bc7b600d76eb1fab", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                                   vec![path_std!(cx, core::hash::Hasher)])],\n                 },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(box Literal(arg), Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(Box::new(Literal(arg)), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 attributes: vec![],\n                 combine_substructure: combine_substructure(Box::new(|a, b, c| {\n@@ -56,8 +56,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n }\n \n fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let state_expr = match substr.nonself_args {\n-        [ref state_expr] => state_expr,\n+    let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n+        (1, Some(o_f)) => o_f,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\")\n     };\n     let call_hash = |span, thing_expr| {"}, {"sha": "a972cfe135511d99f6961edc9bc6fc37ad5a4dd7", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -40,7 +40,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path_local!(i64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self_),\n+                                           vec!(Box::new(Self_)),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n@@ -55,7 +55,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path_local!(u64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self_),\n+                                           vec!(Box::new(Self_)),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,\n@@ -71,8 +71,8 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    let n = match substr.nonself_args {\n-        [ref n] => n,\n+    let n = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n+        (1, Some(o_f)) => o_f,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(FromPrimitive)`\")\n     };\n "}, {"sha": "3ce1f6f12ceab58ac7cbf5a01cc3d4bd2a3764ef", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,7 +25,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             push: &mut FnMut(P<Item>))\n {\n     // &mut ::std::fmt::Formatter\n-    let fmtr = Ptr(box Literal(path_std!(cx, core::fmt::Formatter)),\n+    let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {"}, {"sha": "d1db956adb3f5a13f28576ff6ac5ceab1802a800", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -1962,8 +1962,8 @@ foo_module!();\n                 \"xx\" == string\n             }).collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[..];\n-        let cxbind = match cxbinds {\n-            [b] => b,\n+        let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n+            (1, Some(b)) => *b,\n             _ => panic!(\"expected just one binding for ext_cx\")\n         };\n         let resolved_binding = mtwt::resolve(*cxbind);"}, {"sha": "08bb4ca106486207cc377ed8c57175b1832b5101", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -128,7 +128,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree\n         }\n     }\n \n-    box ExpandResult { p: p }\n+    Box::new(ExpandResult { p: p })\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "646e6fec405534de3f62a18ae55dc8f57b6ff83c", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -28,12 +28,11 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n         return base::DummyResult::any(sp);\n     }\n \n-\n-    match tt {\n-        [ast::TtToken(_, ref tok)] if tok.is_keyword(keywords::True) => {\n+    match (tt.len(), tt.first()) {\n+        (1, Some(&ast::TtToken(_, ref tok))) if tok.is_keyword(keywords::True) => {\n             cx.set_trace_macros(true);\n         }\n-        [ast::TtToken(_, ref tok)] if tok.is_keyword(keywords::False) => {\n+        (1, Some(&ast::TtToken(_, ref tok))) if tok.is_keyword(keywords::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}, {"sha": "5521c68e75c6950f513c3519411d009983f1f490", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -165,7 +165,7 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(&ms[..]);\n     let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n-    box MatcherPos {\n+    Box::new(MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n@@ -176,7 +176,7 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         match_cur: 0,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n-    }\n+    })\n }\n \n /// NamedMatch is a pattern-match result for a single token::MATCH_NONTERMINAL:\n@@ -396,7 +396,7 @@ pub fn parse(sess: &ParseSess,\n                         let matches: Vec<_> = (0..ei.matches.len())\n                             .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n-                        cur_eis.push(box MatcherPos {\n+                        cur_eis.push(Box::new(MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n                             idx: 0,\n@@ -407,7 +407,7 @@ pub fn parse(sess: &ParseSess,\n                             up: Some(ei_t),\n                             sp_lo: sp.lo,\n                             top_elts: Tt(TtSequence(sp, seq)),\n-                        });\n+                        }));\n                     }\n                     TtToken(_, MatchNt(..)) => {\n                         // Built-in nonterminals never start with these tokens,\n@@ -533,15 +533,15 @@ pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n       \"ty\" => token::NtTy(p.parse_ty()),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n-        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(box sn,b) }\n+        token::Ident(sn,b) => { panictry!(p.bump()); token::NtIdent(Box::new(sn),b) }\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             panic!(p.fatal(&format!(\"expected ident, found {}\",\n                              &token_str[..])))\n         }\n       },\n       \"path\" => {\n-        token::NtPath(box panictry!(p.parse_path(LifetimeAndTypesWithoutColons)))\n+        token::NtPath(Box::new(panictry!(p.parse_path(LifetimeAndTypesWithoutColons))))\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       _ => {"}, {"sha": "27a00290ee01ea81e8502b256102eca808ec7f17", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -192,15 +192,15 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 panictry!(p.check_unknown_macro_variable());\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n-                return box ParserAnyMacro {\n+                return Box::new(ParserAnyMacro {\n                     parser: RefCell::new(p),\n \n                     // Pass along the original expansion site and the name of the macro\n                     // so we can print a useful error message if the parse of the expanded\n                     // macro leaves unparsed tokens.\n                     site_span: sp,\n                     macro_ident: name\n-                }\n+                })\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -281,12 +281,12 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n-    let exp: Box<_> = box MacroRulesMacroExpander {\n+    let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n-    };\n+    });\n \n     NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n }"}, {"sha": "368a9f0c27e56fd3e721693bd308702c82d5c75f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -294,9 +294,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             // sidestep the interpolation tricks for ident because\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n-                            MatchedNonterminal(NtIdent(box sn, b)) => {\n+                            MatchedNonterminal(NtIdent(ref sn, b)) => {\n                                 r.cur_span = sp;\n-                                r.cur_tok = token::Ident(sn, b);\n+                                r.cur_tok = token::Ident(**sn, b);\n                                 return ret_val;\n                             }\n                             MatchedNonterminal(ref other_whole_nt) => {"}, {"sha": "8ba36cefc65dd49bf80d897d6d8d0ae1399dadc6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -677,10 +677,10 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(box id, is_mod_name) =>\n-            token::NtIdent(box fld.fold_ident(id), is_mod_name),\n+        token::NtIdent(id, is_mod_name) =>\n+            token::NtIdent(Box::new(fld.fold_ident(*id)), is_mod_name),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n-        token::NtPath(box path) => token::NtPath(box fld.fold_path(path)),\n+        token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n         token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n     }\n }"}, {"sha": "d8beeb6a5503b2e9599de4369d7571536a8cb60e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,19 +25,13 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(libc)]\n-#![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(slice_patterns)]\n \n extern crate arena;\n extern crate fmt_macros;\n@@ -98,6 +92,7 @@ pub mod parse;\n pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n+pub mod str;\n pub mod test;\n pub mod visit;\n "}, {"sha": "fb3a96f4c2887fdbd2b5c2875d239f50a37c9dc5", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,11 +13,12 @@ pub use self::CommentStyle::*;\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n-use parse::lexer::{is_whitespace, Reader};\n-use parse::lexer::{StringReader, TokenAndSpan};\n use parse::lexer::is_block_doc_comment;\n+use parse::lexer::{StringReader, TokenAndSpan};\n+use parse::lexer::{is_whitespace, Reader};\n use parse::lexer;\n use print::pprust;\n+use str::char_at;\n \n use std::io::Read;\n use std::usize;\n@@ -209,7 +210,7 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let mut col = col.to_usize();\n     let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n-        let ch = s.char_at(cursor);\n+        let ch = char_at(s, cursor);\n         if !ch.is_whitespace() {\n             return None;\n         }\n@@ -246,7 +247,7 @@ fn read_block_comment(rdr: &mut StringReader,\n     rdr.bump();\n     rdr.bump();\n \n-    let mut curr_line = String::from_str(\"/*\");\n+    let mut curr_line = String::from(\"/*\");\n \n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !rdr.nextch_is('*')) || rdr.curr_is('!') {"}, {"sha": "8e37b983e21e0425e845223056e33dcecdd6b097", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,10 +13,11 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use diagnostic::SpanHandler;\n use ext::tt::transcribe::tt_next_token;\n-use parse::token;\n use parse::token::str_to_ident;\n+use parse::token;\n+use str::char_at;\n \n-use std::borrow::{IntoCow, Cow};\n+use std::borrow::Cow;\n use std::char;\n use std::fmt;\n use std::mem::replace;\n@@ -289,31 +290,31 @@ impl<'a> StringReader<'a> {\n                           s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n-            let ch = s.char_at(i);\n+            let ch = char_at(s, i);\n             let next = i + ch.len_utf8();\n             if ch == '\\r' {\n-                if next < s.len() && s.char_at(next) == '\\n' {\n-                    return translate_crlf_(self, start, s, errmsg, i).into_cow();\n+                if next < s.len() && char_at(s, next) == '\\n' {\n+                    return translate_crlf_(self, start, s, errmsg, i).into();\n                 }\n                 let pos = start + BytePos(i as u32);\n                 let end_pos = start + BytePos(next as u32);\n                 self.err_span_(pos, end_pos, errmsg);\n             }\n             i = next;\n         }\n-        return s.into_cow();\n+        return s.into();\n \n         fn translate_crlf_(rdr: &StringReader, start: BytePos,\n                         s: &str, errmsg: &str, mut i: usize) -> String {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n-                let ch = s.char_at(i);\n+                let ch = char_at(s, i);\n                 let next = i + ch.len_utf8();\n                 if ch == '\\r' {\n                     if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n-                    if next >= s.len() || s.char_at(next) != '\\n' {\n+                    if next >= s.len() || char_at(s, next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n                         let end_pos = start + BytePos(next as u32);\n                         rdr.err_span_(pos, end_pos, errmsg);\n@@ -335,7 +336,7 @@ impl<'a> StringReader<'a> {\n         if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let ch = self.source_text.char_at(current_byte_offset);\n+            let ch = char_at(&self.source_text, current_byte_offset);\n             let next = current_byte_offset + ch.len_utf8();\n             let byte_offset_diff = next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n@@ -357,7 +358,7 @@ impl<'a> StringReader<'a> {\n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         if offset < self.source_text.len() {\n-            Some(self.source_text.char_at(offset))\n+            Some(char_at(&self.source_text, offset))\n         } else {\n             None\n         }\n@@ -371,9 +372,9 @@ impl<'a> StringReader<'a> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n-        let next = offset + s.char_at(offset).len_utf8();\n+        let next = offset + char_at(s, offset).len_utf8();\n         if next < s.len() {\n-            Some(s.char_at(next))\n+            Some(char_at(s, next))\n         } else {\n             None\n         }\n@@ -564,7 +565,7 @@ impl<'a> StringReader<'a> {\n                 let string = if has_cr {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n-                } else { string.into_cow() };\n+                } else { string.into() };\n                 token::DocComment(token::intern(&string[..]))\n             } else {\n                 token::Comment"}, {"sha": "1a1713a8ba632fb9fa3d3f99e539525a27266665", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,14 +16,12 @@ use diagnostic::{SpanHandler, mk_span_handler, default_handler, Auto, FatalError\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n use ptr::P;\n-\n+use str::char_at;\n \n use std::cell::{Cell, RefCell};\n use std::fs::File;\n use std::io::Read;\n use std::iter;\n-#[allow(deprecated)] // Int\n-use std::num::Int;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n@@ -288,7 +286,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n     let srdr = lexer::StringReader::new(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser::new(sess, cfg, box srdr);\n+    let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n     panictry!(p1.parse_all_token_trees())\n }\n \n@@ -297,7 +295,7 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n-    let mut p = Parser::new(sess, cfg, box trdr);\n+    let mut p = Parser::new(sess, cfg, Box::new(trdr));\n     panictry!(p.check_unknown_macro_variable());\n     p\n }\n@@ -360,7 +358,7 @@ pub mod with_hygiene {\n         use super::lexer::make_reader_with_embedded_idents as make_reader;\n         let cfg = Vec::new();\n         let srdr = make_reader(&sess.span_diagnostic, filemap);\n-        let mut p1 = Parser::new(sess, cfg, box srdr);\n+        let mut p1 = Parser::new(sess, cfg, Box::new(srdr));\n         panictry!(p1.parse_all_token_trees())\n     }\n }\n@@ -536,7 +534,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n // check if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n-        first_chars.contains(&s.char_at(0)) &&\n+        first_chars.contains(&char_at(s, 0)) &&\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n@@ -673,8 +671,8 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     let orig = s;\n     let mut ty = ast::UnsuffixedIntLit(ast::Plus);\n \n-    if s.char_at(0) == '0' && s.len() > 1 {\n-        match s.char_at(1) {\n+    if char_at(s, 0) == '0' && s.len() > 1 {\n+        match char_at(s, 1) {\n             'x' => base = 16,\n             'o' => base = 8,\n             'b' => base = 2,\n@@ -834,28 +832,44 @@ mod test {\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n         let tts: &[ast::TokenTree] = &tts[..];\n-        match tts {\n-            [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n-             ast::TtToken(_, token::Not),\n-             ast::TtToken(_, token::Ident(name_zip, token::Plain)),\n-             ast::TtDelimited(_, ref macro_delimed)]\n+\n+        match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n+            (\n+                4,\n+                Some(&ast::TtToken(_, token::Ident(name_macro_rules, token::Plain))),\n+                Some(&ast::TtToken(_, token::Not)),\n+                Some(&ast::TtToken(_, token::Ident(name_zip, token::Plain))),\n+                Some(&ast::TtDelimited(_, ref macro_delimed)),\n+            )\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match &macro_delimed.tts[..] {\n-                    [ast::TtDelimited(_, ref first_delimed),\n-                     ast::TtToken(_, token::FatArrow),\n-                     ast::TtDelimited(_, ref second_delimed)]\n+                let tts = &macro_delimed.tts[..];\n+                match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n+                    (\n+                        3,\n+                        Some(&ast::TtDelimited(_, ref first_delimed)),\n+                        Some(&ast::TtToken(_, token::FatArrow)),\n+                        Some(&ast::TtDelimited(_, ref second_delimed)),\n+                    )\n                     if macro_delimed.delim == token::Paren => {\n-                        match &first_delimed.tts[..] {\n-                            [ast::TtToken(_, token::Dollar),\n-                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                        let tts = &first_delimed.tts[..];\n+                        match (tts.len(), tts.get(0), tts.get(1)) {\n+                            (\n+                                2,\n+                                Some(&ast::TtToken(_, token::Dollar)),\n+                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                            )\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n-                        match &second_delimed.tts[..] {\n-                            [ast::TtToken(_, token::Dollar),\n-                             ast::TtToken(_, token::Ident(name, token::Plain))]\n+                        let tts = &second_delimed.tts[..];\n+                        match (tts.len(), tts.get(0), tts.get(1)) {\n+                            (\n+                                2,\n+                                Some(&ast::TtToken(_, token::Dollar)),\n+                                Some(&ast::TtToken(_, token::Ident(name, token::Plain))),\n+                            )\n                             if second_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),"}, {"sha": "796bc2a3513f3d02a972b312c541971c9ea3c5f1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -78,6 +78,7 @@ use parse::PResult;\n use diagnostic::FatalError;\n \n use std::collections::HashSet;\n+use std::fs;\n use std::io::prelude::*;\n use std::mem;\n use std::path::{Path, PathBuf};\n@@ -436,10 +437,11 @@ impl<'a> Parser<'a> {\n             // leave it in the input\n             Ok(())\n         } else {\n-            let mut expected = edible.iter().map(|x| TokenType::Token(x.clone()))\n-                                            .collect::<Vec<_>>();\n-            expected.extend(inedible.iter().map(|x| TokenType::Token(x.clone())));\n-            expected.push_all(&*self.expected_tokens);\n+            let mut expected = edible.iter()\n+                .map(|x| TokenType::Token(x.clone()))\n+                .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n+                .chain(self.expected_tokens.iter().cloned())\n+                .collect::<Vec<_>>();\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n             let expect = tokens_to_string(&expected[..]);\n@@ -490,8 +492,10 @@ impl<'a> Parser<'a> {\n         debug!(\"commit_expr {:?}\", e);\n         if let ExprPath(..) = e.node {\n             // might be unit-struct construction; check for recoverableinput error.\n-            let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n-            expected.push_all(inedible);\n+            let expected = edible.iter()\n+                .cloned()\n+                .chain(inedible.iter().cloned())\n+                .collect::<Vec<_>>();\n             try!(self.check_for_erroneous_unit_struct_expecting(&expected[..]));\n         }\n         self.expect_one_of(edible, inedible)\n@@ -509,8 +513,10 @@ impl<'a> Parser<'a> {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n-            let mut expected = edible.iter().cloned().collect::<Vec<_>>();\n-            expected.push_all(&inedible);\n+            let expected = edible.iter()\n+                .cloned()\n+                .chain(inedible.iter().cloned())\n+                .collect::<Vec<_>>();\n             try!(self.check_for_erroneous_unit_struct_expecting(&expected));\n         }\n         self.expect_one_of(edible, inedible)\n@@ -897,7 +903,7 @@ impl<'a> Parser<'a> {\n         self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         self.last_token = if self.token.is_ident() || self.token.is_path() {\n-            Some(box self.token.clone())\n+            Some(Box::new(self.token.clone()))\n         } else {\n             None\n         };\n@@ -1187,7 +1193,7 @@ impl<'a> Parser<'a> {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         try!(p.parse_inner_attrs_and_block());\n-                    attrs.push_all(&inner_attrs[..]);\n+                    attrs.extend(inner_attrs.iter().cloned());\n                     Some(body)\n                   }\n \n@@ -1578,8 +1584,8 @@ impl<'a> Parser<'a> {\n             token::Interpolated(token::NtPath(_)) => Some(try!(self.bump_and_get())),\n             _ => None,\n         };\n-        if let Some(token::Interpolated(token::NtPath(box path))) = found {\n-            return Ok(path);\n+        if let Some(token::Interpolated(token::NtPath(path))) = found {\n+            return Ok(*path);\n         }\n \n         let lo = self.span.lo;\n@@ -4770,8 +4776,8 @@ impl<'a> Parser<'a> {\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n                 let default_path = dir_path.join(&default_path_str[..]);\n                 let secondary_path = dir_path.join(&secondary_path_str[..]);\n-                let default_exists = default_path.exists();\n-                let secondary_exists = secondary_path.exists();\n+                let default_exists = fs::metadata(&default_path).is_ok();\n+                let secondary_exists = fs::metadata(&secondary_path).is_ok();\n \n                 if !self.owns_directory {\n                     self.span_err(id_sp,\n@@ -4834,7 +4840,7 @@ impl<'a> Parser<'a> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n-                let mut err = String::from_str(\"circular modules: \");\n+                let mut err = String::from(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in &included_mod_stack[i.. len] {\n                     err.push_str(&p.to_string_lossy());"}, {"sha": "15aaf9cf390fd18c0110aed288fdec802858cc29", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -131,7 +131,7 @@ pub fn buf_str(toks: &[Token],\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = string::String::from_str(\"[\");\n+    let mut s = string::String::from(\"[\");\n     while i != right && l != 0 {\n         l -= 1;\n         if i != left {"}, {"sha": "5a57e09fcfff2a4fb5b9625da34a5db36e085271", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -28,7 +28,7 @@ use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n \n-use std::{ascii, mem};\n+use std::ascii;\n use std::io::{self, Write, Read};\n use std::iter;\n \n@@ -187,18 +187,13 @@ impl<'a> State<'a> {\n pub fn to_string<F>(f: F) -> String where\n     F: FnOnce(&mut State) -> io::Result<()>,\n {\n-    use std::raw::TraitObject;\n-    let mut s = rust_printer(box Vec::new());\n-    f(&mut s).unwrap();\n-    eof(&mut s.s).unwrap();\n-    let wr = unsafe {\n-        // FIXME(pcwalton): A nasty function to extract the string from an `Write`\n-        // that we \"know\" to be a `Vec<u8>` that works around the lack of checked\n-        // downcasts.\n-        let obj: &TraitObject = mem::transmute(&s.s.out);\n-        mem::transmute::<*mut (), &Vec<u8>>(obj.data)\n-    };\n-    String::from_utf8(wr.clone()).unwrap()\n+    let mut wr = Vec::new();\n+    {\n+        let mut printer = rust_printer(Box::new(&mut wr));\n+        f(&mut printer).unwrap();\n+        eof(&mut printer.s).unwrap();\n+    }\n+    String::from_utf8(wr).unwrap()\n }\n \n pub fn binop_to_string(op: BinOpToken) -> &'static str {\n@@ -2799,13 +2794,13 @@ impl<'a> State<'a> {\n         match lit.node {\n             ast::LitStr(ref st, style) => self.print_string(&st, style),\n             ast::LitByte(byte) => {\n-                let mut res = String::from_str(\"b'\");\n+                let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n                 word(&mut self.s, &res[..])\n             }\n             ast::LitChar(ch) => {\n-                let mut res = String::from_str(\"'\");\n+                let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n                 word(&mut self.s, &res[..])"}, {"sha": "83e321f110c5875dfb39694307fbde3afd1f94f1", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -52,7 +52,7 @@ pub struct P<T> {\n /// Construct a `P<T>` from a `T` value.\n pub fn P<T: 'static>(value: T) -> P<T> {\n     P {\n-        ptr: box value\n+        ptr: Box::new(value)\n     }\n }\n "}, {"sha": "d0f47629b10e5b42fd877c563c6d299e9097b85f", "filename": "src/libsyntax/str.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstr.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn char_at(s: &str, byte: usize) -> char {\n+    s[byte..].chars().next().unwrap()\n+}"}, {"sha": "6adeb30a94ec4d3c68f8a8af5bfe2d3f2e218edc", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,6 +15,7 @@ use parse::new_parser_from_source_str;\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n+use str::char_at;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n@@ -96,24 +97,24 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n         else if idx_a == a.len() {return false;}\n         else if idx_b == b.len() {\n             // maybe the stuff left in a is all ws?\n-            if is_whitespace(a.char_at(idx_a)) {\n+            if is_whitespace(char_at(a, idx_a)) {\n                 return scan_for_non_ws_or_end(a,idx_a) == a.len();\n             } else {\n                 return false;\n             }\n         }\n         // ws in both given and pattern:\n-        else if is_whitespace(a.char_at(idx_a))\n-           && is_whitespace(b.char_at(idx_b)) {\n+        else if is_whitespace(char_at(a, idx_a))\n+           && is_whitespace(char_at(b, idx_b)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n             idx_b = scan_for_non_ws_or_end(b,idx_b);\n         }\n         // ws in given only:\n-        else if is_whitespace(a.char_at(idx_a)) {\n+        else if is_whitespace(char_at(a, idx_a)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n         }\n         // *don't* silently eat ws in expected only.\n-        else if a.char_at(idx_a) == b.char_at(idx_b) {\n+        else if char_at(a, idx_a) == char_at(b, idx_b) {\n             idx_a += 1;\n             idx_b += 1;\n         }\n@@ -129,7 +130,7 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n     let mut i = idx;\n     let len = a.len();\n-    while (i < len) && (is_whitespace(a.char_at(i))) {\n+    while (i < len) && (is_whitespace(char_at(a, i))) {\n         i += 1;\n     }\n     i"}, {"sha": "153f9d4a26df155dd4773cb2a22ecdc4a32ae985", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -64,7 +64,10 @@ impl<T> SmallVector<T> {\n                 let result: &[T] = &[];\n                 result\n             }\n-            One(ref v) => slice::ref_slice(v),\n+            One(ref v) => {\n+                // FIXME: Could be replaced with `slice::ref_slice(v)` when it is stable.\n+                unsafe { slice::from_raw_parts(v, 1) }\n+            }\n             Many(ref vs) => vs\n         }\n     }"}, {"sha": "3de99088da47b3c653b9dcd6a8de63093b733df6", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -355,11 +355,4 @@ mod test {\n         assert_eq!(numfnames.len(), numnames.len());\n         assert_eq!(stringfnames.len(), stringnames.len());\n     }\n-\n-    #[test]\n-    #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n-    fn test_parse() {\n-        // FIXME #6870: Distribute a compiled file in src/tests and test there\n-        // parse(old_io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n-    }\n }"}, {"sha": "b68b1d28b356750787384c625202a81552fd2c26", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -43,7 +43,6 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n-#![cfg_attr(test, feature(old_io))]\n \n extern crate getopts;\n extern crate serialize;\n@@ -75,7 +74,6 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::{Float, Int};\n use std::path::PathBuf;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n@@ -413,7 +411,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n #[derive(Clone, PartialEq)]\n pub struct BenchSamples {\n-    ns_iter_summ: stats::Summary<f64>,\n+    ns_iter_summ: stats::Summary,\n     mb_s: usize,\n }\n \n@@ -1066,7 +1064,7 @@ impl Bencher {\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary<f64> where F: FnMut(&mut Bencher) {\n+    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary where F: FnMut(&mut Bencher) {\n         // Initial bench run to get ballpark figure.\n         let mut n = 1;\n         self.bench_n(n, |x| f(x));"}, {"sha": "c1ba1260f67e120fdd058c04f6fbf68fc0f13b4a", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,9 +13,8 @@\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::mem;\n-use std::num::{Float, FromPrimitive};\n \n-fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n+fn local_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n     if y.is_nan() {\n         Less\n@@ -30,37 +29,37 @@ fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     }\n }\n \n-fn local_sort<T: Float>(v: &mut [T]) {\n-    v.sort_by(|x: &T, y: &T| local_cmp(*x, *y));\n+fn local_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| local_cmp(*x, *y));\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: Float + FromPrimitive> {\n+pub trait Stats {\n \n     /// Sum of the samples.\n     ///\n     /// Note: this method sacrifices performance at the altar of accuracy\n     /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n     /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates\"]\n     /// (http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps)\n-    fn sum(&self) -> T;\n+    fn sum(&self) -> f64;\n \n     /// Minimum value of the samples.\n-    fn min(&self) -> T;\n+    fn min(&self) -> f64;\n \n     /// Maximum value of the samples.\n-    fn max(&self) -> T;\n+    fn max(&self) -> f64;\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n-    fn mean(&self) -> T;\n+    fn mean(&self) -> f64;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Median\n-    fn median(&self) -> T;\n+    fn median(&self) -> f64;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n     /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n@@ -69,21 +68,21 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// than `n`.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Variance\n-    fn var(&self) -> T;\n+    fn var(&self) -> f64;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n     /// See: https://en.wikipedia.org/wiki/Standard_deviation\n-    fn std_dev(&self) -> T;\n+    fn std_dev(&self) -> f64;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev_pct` for unknown distributions.\n-    fn std_dev_pct(&self) -> T;\n+    fn std_dev_pct(&self) -> f64;\n \n     /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n     /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n@@ -92,10 +91,10 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// deviation.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n-    fn median_abs_dev(&self) -> T;\n+    fn median_abs_dev(&self) -> f64;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n-    fn median_abs_dev_pct(&self) -> T;\n+    fn median_abs_dev_pct(&self) -> f64;\n \n     /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n     /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n@@ -104,44 +103,44 @@ pub trait Stats <T: Float + FromPrimitive> {\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n     /// See: http://en.wikipedia.org/wiki/Percentile\n-    fn percentile(&self, pct: T) -> T;\n+    fn percentile(&self, pct: f64) -> f64;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(&self) -> (T,T,T);\n+    fn quartiles(&self) -> (f64,f64,f64);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n-    fn iqr(&self) -> T;\n+    fn iqr(&self) -> f64;\n }\n \n /// Extracted collection of all the summary statistics of a sample set.\n #[derive(Clone, PartialEq)]\n #[allow(missing_docs)]\n-pub struct Summary<T> {\n-    pub sum: T,\n-    pub min: T,\n-    pub max: T,\n-    pub mean: T,\n-    pub median: T,\n-    pub var: T,\n-    pub std_dev: T,\n-    pub std_dev_pct: T,\n-    pub median_abs_dev: T,\n-    pub median_abs_dev_pct: T,\n-    pub quartiles: (T,T,T),\n-    pub iqr: T,\n+pub struct Summary {\n+    pub sum: f64,\n+    pub min: f64,\n+    pub max: f64,\n+    pub mean: f64,\n+    pub median: f64,\n+    pub var: f64,\n+    pub std_dev: f64,\n+    pub std_dev_pct: f64,\n+    pub median_abs_dev: f64,\n+    pub median_abs_dev_pct: f64,\n+    pub quartiles: (f64,f64,f64),\n+    pub iqr: f64,\n }\n \n-impl<T: Float + FromPrimitive> Summary<T> {\n+impl Summary {\n     /// Construct a new summary of a sample set.\n-    pub fn new(samples: &[T]) -> Summary<T> {\n+    pub fn new(samples: &[f64]) -> Summary {\n         Summary {\n             sum: samples.sum(),\n             min: samples.min(),\n@@ -159,9 +158,9 @@ impl<T: Float + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<T: Float + FromPrimitive> Stats<T> for [T] {\n+impl Stats for [f64] {\n     // FIXME #11059 handle NaN, inf and overflow\n-    fn sum(&self) -> T {\n+    fn sum(&self) -> f64 {\n         let mut partials = vec![];\n \n         for &x in self {\n@@ -170,15 +169,15 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in 0..partials.len() {\n-                let mut y: T = partials[i];\n+                let mut y: f64 = partials[i];\n                 if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);\n                 }\n                 // Rounded `x+y` is stored in `hi` with round-off stored in\n                 // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n                 let hi = x + y;\n                 let lo = y - (hi - x);\n-                if lo != Float::zero() {\n+                if lo != 0.0 {\n                     partials[j] = lo;\n                     j += 1;\n                 }\n@@ -191,89 +190,89 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n                 partials.truncate(j+1);\n             }\n         }\n-        let zero: T = Float::zero();\n+        let zero: f64 = 0.0;\n         partials.iter().fold(zero, |p, q| p + *q)\n     }\n \n-    fn min(&self) -> T {\n+    fn min(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n-    fn max(&self) -> T {\n+    fn max(&self) -> f64 {\n         assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n-    fn mean(&self) -> T {\n+    fn mean(&self) -> f64 {\n         assert!(!self.is_empty());\n-        self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n+        self.sum() / (self.len() as f64)\n     }\n \n-    fn median(&self) -> T {\n-        self.percentile(FromPrimitive::from_usize(50).unwrap())\n+    fn median(&self) -> f64 {\n+        self.percentile(50 as f64)\n     }\n \n-    fn var(&self) -> T {\n+    fn var(&self) -> f64 {\n         if self.len() < 2 {\n-            Float::zero()\n+            0.0\n         } else {\n             let mean = self.mean();\n-            let mut v: T = Float::zero();\n+            let mut v: f64 = 0.0;\n             for s in self {\n                 let x = *s - mean;\n                 v = v + x*x;\n             }\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n-            let denom = FromPrimitive::from_usize(self.len()-1).unwrap();\n+            let denom = (self.len() - 1) as f64;\n             v/denom\n         }\n     }\n \n-    fn std_dev(&self) -> T {\n+    fn std_dev(&self) -> f64 {\n         self.var().sqrt()\n     }\n \n-    fn std_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn std_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.std_dev() / self.mean()) * hundred\n     }\n \n-    fn median_abs_dev(&self) -> T {\n+    fn median_abs_dev(&self) -> f64 {\n         let med = self.median();\n-        let abs_devs: Vec<T> = self.iter().map(|&v| (med - v).abs()).collect();\n+        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n         // This constant is derived by smarter statistics brains than me, but it is\n         // consistent with how R and other packages treat the MAD.\n-        let number = FromPrimitive::from_f64(1.4826).unwrap();\n+        let number = 1.4826;\n         abs_devs.median() * number\n     }\n \n-    fn median_abs_dev_pct(&self) -> T {\n-        let hundred = FromPrimitive::from_usize(100).unwrap();\n+    fn median_abs_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n         (self.median_abs_dev() / self.median()) * hundred\n     }\n \n-    fn percentile(&self, pct: T) -> T {\n+    fn percentile(&self, pct: f64) -> f64 {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n         percentile_of_sorted(&tmp, pct)\n     }\n \n-    fn quartiles(&self) -> (T,T,T) {\n+    fn quartiles(&self) -> (f64,f64,f64) {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n-        let first = FromPrimitive::from_usize(25).unwrap();\n+        let first = 25f64;\n         let a = percentile_of_sorted(&tmp, first);\n-        let secound = FromPrimitive::from_usize(50).unwrap();\n+        let secound = 50f64;\n         let b = percentile_of_sorted(&tmp, secound);\n-        let third = FromPrimitive::from_usize(75).unwrap();\n+        let third = 75f64;\n         let c = percentile_of_sorted(&tmp, third);\n         (a,b,c)\n     }\n \n-    fn iqr(&self) -> T {\n+    fn iqr(&self) -> f64 {\n         let (a,_,c) = self.quartiles();\n         c - a\n     }\n@@ -282,41 +281,41 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n \n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n-fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n-                                                             pct: T) -> T {\n+fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     assert!(!sorted_samples.is_empty());\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }\n-    let zero: T = Float::zero();\n+    let zero: f64 = 0.0;\n     assert!(zero <= pct);\n-    let hundred = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100f64;\n     assert!(pct <= hundred);\n     if pct == hundred {\n         return sorted_samples[sorted_samples.len() - 1];\n     }\n-    let length = FromPrimitive::from_usize(sorted_samples.len() - 1).unwrap();\n+    let length = (sorted_samples.len() - 1) as f64;\n     let rank = (pct / hundred) * length;\n     let lrank = rank.floor();\n     let d = rank - lrank;\n-    let n = lrank.to_usize().unwrap();\n+    let n = lrank as usize;\n     let lo = sorted_samples[n];\n     let hi = sorted_samples[n+1];\n     lo + (hi - lo) * d\n }\n \n \n-/// Winsorize a set of samples, replacing values above the `100-pct` percentile and below the `pct`\n-/// percentile with those percentiles themselves. This is a way of minimizing the effect of\n-/// outliers, at the cost of biasing the sample. It differs from trimming in that it does not\n-/// change the number of samples, just changes the values of those that are outliers.\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n+/// and below the `pct` percentile with those percentiles themselves. This is a\n+/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n+/// It differs from trimming in that it does not change the number of samples,\n+/// just changes the values of those that are outliers.\n ///\n /// See: http://en.wikipedia.org/wiki/Winsorising\n-pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_vec();\n     local_sort(&mut tmp);\n     let lo = percentile_of_sorted(&tmp, pct);\n-    let hundred: T = FromPrimitive::from_usize(100).unwrap();\n+    let hundred = 100 as f64;\n     let hi = percentile_of_sorted(&tmp, hundred-pct);\n     for samp in samples {\n         if *samp > hi {\n@@ -339,14 +338,13 @@ mod tests {\n \n     macro_rules! assert_approx_eq {\n         ($a:expr, $b:expr) => ({\n-            use std::num::Float;\n             let (a, b) = (&$a, &$b);\n             assert!((*a - *b).abs() < 1.0e-6,\n                     \"{} is not approximately equal to {}\", *a, *b);\n         })\n     }\n \n-    fn check(samples: &[f64], summ: &Summary<f64>) {\n+    fn check(samples: &[f64], summ: &Summary) {\n \n         let summ2 = Summary::new(samples);\n "}, {"sha": "7e0630fd242d39c83dfff871136a8d0118950208", "filename": "src/rustllvm/ExecutionEngineWrapper.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FExecutionEngineWrapper.cpp?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -89,12 +89,12 @@ extern \"C\" LLVMExecutionEngineRef LLVMBuildExecutionEngine(\n     options.NoFramePointerElim = true;\n \n     ExecutionEngine *ee =\n-    #if LLVM_VERSION_MINOR <= 5\n-        EngineBuilder(unwrap(mod))\n-            .setMCJITMemoryManager(unwrap(mref))\n-    #else\n+    #if LLVM_VERSION_MINOR >= 6\n         EngineBuilder(std::unique_ptr<Module>(unwrap(mod)))\n             .setMCJITMemoryManager(std::unique_ptr<RustJITMemoryManager>(unwrap(mref)))\n+    #else\n+        EngineBuilder(unwrap(mod))\n+            .setMCJITMemoryManager(unwrap(mref))\n     #endif\n             .setEngineKind(EngineKind::JIT)\n             .setErrorStr(&error_str)"}, {"sha": "a2ab8040198ff7a3266bd58194556d2d7255fd31", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -92,9 +92,6 @@ LLVMRustCreateTargetMachine(const char *triple,\n     TargetOptions Options;\n     Options.PositionIndependentExecutable = PositionIndependentExecutable;\n     Options.NoFramePointerElim = NoFramePointerElim;\n-#if LLVM_VERSION_MINOR < 5\n-    Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-#endif\n     Options.FloatABIType = FloatABI::Default;\n     Options.UseSoftFloat = UseSoftFloat;\n     if (UseSoftFloat) {\n@@ -128,10 +125,8 @@ LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n     PassManagerBase *PM = unwrap(PMR);\n #if LLVM_VERSION_MINOR >= 6\n     PM->add(new DataLayoutPass());\n-#elif LLVM_VERSION_MINOR == 5\n-    PM->add(new DataLayoutPass(unwrap(M)));\n #else\n-    PM->add(new DataLayout(unwrap(M)));\n+    PM->add(new DataLayoutPass(unwrap(M)));\n #endif\n     unwrap(TM)->addAnalysisPasses(*PM);\n }\n@@ -202,10 +197,8 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n   raw_fd_ostream OS(path, EC, sys::fs::F_None);\n   if (EC)\n     ErrorInfo = EC.message();\n-#elif LLVM_VERSION_MINOR >= 4\n-  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_None);\n #else\n-  raw_fd_ostream OS(path, ErrorInfo, raw_fd_ostream::F_Binary);\n+  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_None);\n #endif\n   if (ErrorInfo != \"\") {\n     LLVMRustSetLastError(ErrorInfo.c_str());\n@@ -230,19 +223,13 @@ LLVMRustPrintModule(LLVMPassManagerRef PMR,\n   raw_fd_ostream OS(path, EC, sys::fs::F_None);\n   if (EC)\n     ErrorInfo = EC.message();\n-#elif LLVM_VERSION_MINOR >= 4\n-  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_None);\n #else\n-  raw_fd_ostream OS(path, ErrorInfo, raw_fd_ostream::F_Binary);\n+  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_None);\n #endif\n \n   formatted_raw_ostream FOS(OS);\n \n-#if LLVM_VERSION_MINOR >= 5\n   PM->add(createPrintModulePass(FOS));\n-#else\n-  PM->add(createPrintModulePass(&FOS));\n-#endif\n \n   PM->run(*unwrap(M));\n }"}, {"sha": "fe0a7b454c17da8740caf1fe6d4765d0f3467fd2", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -412,7 +412,7 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStaticVariable(\n     bool isLocalToUnit,\n     LLVMValueRef Val,\n     LLVMMetadataRef Decl = NULL) {\n-#if LLVM_VERSION_MINOR == 6\n+#if LLVM_VERSION_MINOR >= 6\n     return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),\n #else\n     return wrap(Builder->createStaticVariable(unwrapDI<DIDescriptor>(Context),\n@@ -440,7 +440,7 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVariable(\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n     unsigned ArgNo) {\n-#if LLVM_VERSION_MINOR < 6\n+#if LLVM_VERSION_MINOR == 5\n     if (AddrOpsCount > 0) {\n         SmallVector<llvm::Value *, 16> addr_ops;\n         llvm::Type *Int64Ty = Type::getInt64Ty(unwrap<MDNode>(Scope)->getContext());\n@@ -707,12 +707,12 @@ extern \"C\" void LLVMWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n extern \"C\" bool\n LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     Module *Dst = unwrap(dst);\n-#if LLVM_VERSION_MINOR == 5\n-    MemoryBuffer* buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n-    ErrorOr<Module *> Src = llvm::getLazyBitcodeModule(buf, Dst->getContext());\n-#else\n+#if LLVM_VERSION_MINOR >= 6\n     std::unique_ptr<MemoryBuffer> buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n     ErrorOr<Module *> Src = llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+#else\n+    MemoryBuffer* buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+    ErrorOr<Module *> Src = llvm::getLazyBitcodeModule(buf, Dst->getContext());\n #endif\n     if (!Src) {\n         LLVMRustSetLastError(Src.getError().message().c_str());\n@@ -770,53 +770,74 @@ LLVMRustOpenArchive(char *path) {\n     return ret;\n }\n \n-extern \"C\" const char*\n #if LLVM_VERSION_MINOR >= 6\n-LLVMRustArchiveReadSection(OwningBinary<Archive> *ob, char *name, size_t *size) {\n-\n-    Archive *ar = ob->getBinary();\n+typedef OwningBinary<Archive> RustArchive;\n+#define GET_ARCHIVE(a) ((a)->getBinary())\n #else\n-LLVMRustArchiveReadSection(Archive *ar, char *name, size_t *size) {\n+typedef Archive RustArchive;\n+#define GET_ARCHIVE(a) (a)\n #endif\n \n-    Archive::child_iterator child = ar->child_begin(),\n-                              end = ar->child_end();\n-    for (; child != end; ++child) {\n-        ErrorOr<StringRef> name_or_err = child->getName();\n-        if (name_or_err.getError()) continue;\n-        StringRef sect_name = name_or_err.get();\n-        if (sect_name.trim(\" \") == name) {\n-            StringRef buf = child->getBuffer();\n-            *size = buf.size();\n-            return buf.data();\n-        }\n-    }\n-    return NULL;\n+extern \"C\" void\n+LLVMRustDestroyArchive(RustArchive *ar) {\n+    delete ar;\n+}\n+\n+struct RustArchiveIterator {\n+    Archive::child_iterator cur;\n+    Archive::child_iterator end;\n+};\n+\n+extern \"C\" RustArchiveIterator*\n+LLVMRustArchiveIteratorNew(RustArchive *ra) {\n+    Archive *ar = GET_ARCHIVE(ra);\n+    RustArchiveIterator *rai = new RustArchiveIterator();\n+    rai->cur = ar->child_begin();\n+    rai->end = ar->child_end();\n+    return rai;\n+}\n+\n+extern \"C\" const Archive::Child*\n+LLVMRustArchiveIteratorCurrent(RustArchiveIterator *rai) {\n+    if (rai->cur == rai->end)\n+        return NULL;\n+    const Archive::Child &ret = *rai->cur;\n+    return &ret;\n }\n \n extern \"C\" void\n-#if LLVM_VERSION_MINOR >= 6\n-LLVMRustDestroyArchive(OwningBinary<Archive> *ar) {\n-#else\n-LLVMRustDestroyArchive(Archive *ar) {\n-#endif\n-    delete ar;\n+LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+    if (rai->cur == rai->end)\n+        return;\n+    ++rai->cur;\n }\n \n extern \"C\" void\n-LLVMRustSetDLLExportStorageClass(LLVMValueRef Value) {\n-    GlobalValue *V = unwrap<GlobalValue>(Value);\n-    V->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n+LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n+    delete rai;\n }\n \n-extern \"C\" int\n-LLVMVersionMinor() {\n-    return LLVM_VERSION_MINOR;\n+extern \"C\" const char*\n+LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n+    ErrorOr<StringRef> name_or_err = child->getName();\n+    if (name_or_err.getError())\n+        return NULL;\n+    StringRef name = name_or_err.get();\n+    *size = name.size();\n+    return name.data();\n }\n \n-extern \"C\" int\n-LLVMVersionMajor() {\n-    return LLVM_VERSION_MAJOR;\n+extern \"C\" const char*\n+LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n+    StringRef buf = child->getBuffer();\n+    *size = buf.size();\n+    return buf.data();\n+}\n+\n+extern \"C\" void\n+LLVMRustSetDLLExportStorageClass(LLVMValueRef Value) {\n+    GlobalValue *V = unwrap<GlobalValue>(Value);\n+    V->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n }\n \n // Note that the two following functions look quite similar to the"}, {"sha": "8a4330acf43417e831690e9f564207685de03e5e", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -46,17 +46,10 @@\n #include \"llvm-c/ExecutionEngine.h\"\n #include \"llvm-c/Object.h\"\n \n-#if LLVM_VERSION_MINOR >= 5\n #include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/IR/DebugInfo.h\"\n #include \"llvm/IR/DIBuilder.h\"\n #include \"llvm/Linker/Linker.h\"\n-#else\n-#include \"llvm/Assembly/PrintModulePass.h\"\n-#include \"llvm/DebugInfo.h\"\n-#include \"llvm/DIBuilder.h\"\n-#include \"llvm/Linker.h\"\n-#endif\n \n // Used by RustMCJITMemoryManager::getPointerToNamedFunction()\n // to get around glibc issues. See the function for more information."}, {"sha": "6472c08c222965b6a6ba1a4e411747d3b26bc0ee", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-pub trait Foo : MarkerTrait {\n+pub trait Foo {\n     fn bar();\n }"}, {"sha": "6cc2d427c25dcc6a41cdb3362e94147ad42a483c", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, old_path)]\n+#![feature(std_misc)]\n \n use std::dynamic_lib::DynamicLibrary;\n "}, {"sha": "37ee10c8d37333ec6e64793919ab8a1f504e14ca", "filename": "src/test/auxiliary/private_trait_xc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-trait Foo : ::std::marker::MarkerTrait {}\n+trait Foo {}"}, {"sha": "c2ff7a0054f19712bf95d0c3c34c0c5f4cf5d8e8", "filename": "src/test/auxiliary/rustdoc-default-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frustdoc-default-impl.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,7 +14,7 @@\n pub mod bar {\n     use std::marker;\n \n-    pub trait Bar: marker::MarkerTrait + 'static {}\n+    pub trait Bar: 'static {}\n \n     impl Bar for .. {}\n "}, {"sha": "31a97f695f06cdbfcf20cd27edf87cb961020bb0", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "5339fc8295c6f57f56cfd7820e41cdb3d88be0fc", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "2a5d9446f879ac65f8d8a4dff31c9616e89c7993", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "61f2f2803ab1891dc586ab781cea0158d513b8ed", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "270ce95be2bb62d70a0366920373362fb5a8e2ae", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "de4cc85a7dc4746bc238bbf344b797eb212de426", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "62f7986f1c3bd729b67c8f50677d01395f20914e", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,14 +16,12 @@\n #![crate_name = \"a\"]\n #![feature(core)]\n \n-use std::marker::MarkerTrait;\n-\n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "22e40822eecfc8b52055dbeece2d9b99e58e88e4", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "3d8a728967a4a64bcc274b11818dedc1690d5a2f", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "41d7eb7b18645f3ee181fee3406ec62aaea899fd", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "31a97f695f06cdbfcf20cd27edf87cb961020bb0", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "e405c337abe4aeb7ef7214625a275c5fc4931b75", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "9ef788c98427392bfa95bf1156149d7df9a99232", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,16 +14,13 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n \n macro_rules! three {\n     () => { 3 }\n }\n \n-pub trait U : MarkerTrait {}\n-pub trait V : MarkerTrait {}\n+pub trait U {}\n+pub trait V {}\n impl U for () {}\n impl V for () {}\n "}, {"sha": "c3ecbb014dc6b0aac1dfa9e077383a15e86b79cd", "filename": "src/test/auxiliary/trait_impl_conflict.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(core)]\n-\n-pub trait Foo : ::std::marker::MarkerTrait {\n+pub trait Foo {\n }\n \n impl Foo for isize {"}, {"sha": "2e425ac96c55f9de510c0358e93105c48424d3ba", "filename": "src/test/auxiliary/typeck_default_trait_impl_cross_crate_coherence_lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeck_default_trait_impl_cross_crate_coherence_lib.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,9 +11,7 @@\n #![feature(optin_builtin_traits, core)]\n #![crate_type = \"rlib\"]\n \n-use std::marker::MarkerTrait;\n-\n-pub trait DefaultedTrait : MarkerTrait { }\n+pub trait DefaultedTrait { }\n impl DefaultedTrait for .. { }\n \n pub struct Something<T> { t: T }"}, {"sha": "efbb5dfb5491ebe855be1249909590a2031c055a", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,7 +14,6 @@\n #![feature(rand, core)]\n \n use std::f32::consts::PI;\n-use std::num::Float;\n use std::__rand::{Rng, thread_rng};\n \n #[derive(Copy, Clone)]"}, {"sha": "c576eea3602cb6b95669ac88c29ba6564d4f92c2", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -109,8 +109,7 @@ fn main() {\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n-        use std::num::Int;\n-        let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n+        let iterations = 2i32.pow((max_depth - depth + min_depth) as u32);\n         thread::spawn(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n "}, {"sha": "accf525b4e6386ffe1e97faf4ea3189dd2c6f405", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -43,7 +43,6 @@ use std::env;\n use std::fs::File;\n use std::io::{self, BufWriter};\n use std::io::prelude::*;\n-use std::num::Float;\n \n const LINE_LENGTH: usize = 60;\n const IM: u32 = 139968;"}, {"sha": "368dbbb931c269e5b48e8041526b7c7ada882873", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -38,9 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core)]\n-\n-use std::num::Float;\n+use std::mem;\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -193,16 +191,9 @@ fn main() {\n /// longer contain the mutable reference. This is a safe operation because the\n /// two mutable borrows are entirely disjoint.\n fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n-    use std::mem;\n-    use std::raw::Repr;\n-\n-    if r.is_empty() { return None }\n-    unsafe {\n-        let mut raw = r.repr();\n-        let ret = raw.data as *mut T;\n-        raw.data = raw.data.offset(1);\n-        raw.len -= 1;\n-        *r = mem::transmute(raw);\n-        Some({ &mut *ret })\n-    }\n+    let res = mem::replace(r, &mut []);\n+    if res.is_empty() { return None }\n+    let (a, b) = res.split_at_mut(1);\n+    *r = b;\n+    Some(&mut a[0])\n }"}, {"sha": "0fa22abde3cbd9ee695ec1b392bd9aa6d415b9c1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -46,7 +46,6 @@\n use std::iter::repeat;\n use std::thread;\n use std::mem;\n-use std::num::Float;\n use std::os;\n use std::env;\n use std::raw::Repr;"}, {"sha": "16742f0a6e1a56f5ad2520beaeb591ffd597cb1b", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -16,7 +16,6 @@\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::Int;\n use std::env;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "1f9dfdb18470b3718b97289e62345b762f748e65", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "82258f124d3233da297edae2e9447118e814e45a", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,7 +11,7 @@\n // Test that we do not ICE when an impl is missing an associated type (and that we report\n // a useful error, of course).\n \n-trait Trait : ::std::marker::MarkerTrait {\n+trait Trait {\n     type Type;\n }\n "}, {"sha": "9436f825de89dd4b95a51cc7e6f7ce4ad320bcdd", "filename": "src/test/compile-fail/associated-types-multiple-types-one-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-multiple-types-one-trait.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type X;\n     type Y;\n }"}, {"sha": "bda16c8a85de15d03c00c2470688bb3cb34b158a", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -19,7 +19,7 @@\n // which checks that the trait interface itself is not considered an\n // error as long as all impls satisfy the constraint.\n \n-trait Get : ::std::marker::MarkerTrait {\n+trait Get {\n     type Value;\n }\n "}, {"sha": "233532a6085803400c5ae04f9edbf1d70b4f94a9", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -19,7 +19,7 @@\n // which checks that the trait interface itself is not considered an\n // error as long as all impls satisfy the constraint.\n \n-trait Get : ::std::marker::MarkerTrait {\n+trait Get {\n     type Value;\n }\n "}, {"sha": "aecbf217a5b25e916155829b81188bf7401049ac", "filename": "src/test/compile-fail/associated-types-unconstrained.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unconstrained.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,7 @@\n \n // Check that an associated type cannot be bound in an expression path.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     type A;\n     fn bar() -> isize;\n }"}, {"sha": "fca74e457c21e17be2a9889919730ee6926c32d4", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,7 @@\n \n use std::cell::RefCell;\n \n-trait Trait : ::std::marker::MarkerTrait {}\n+trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();"}, {"sha": "b771b959d3e507ef1cf5001777109b9f1cef7e94", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,6 @@\n \n use std::fmt::Debug;\n use std::default::Default;\n-use std::marker::MarkerTrait;\n \n // Test that two blanket impls conflict (at least without negative\n // bounds).  After all, some other crate could implement Even or Odd\n@@ -20,9 +19,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even : MarkerTrait { }\n+trait Even { }\n \n-trait Odd : MarkerTrait { }\n+trait Odd { }\n \n impl Even for isize { }\n "}, {"sha": "d3b0e7f10b91bc815a32a1f21384bc2bfd9fd5e9", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -19,9 +19,9 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-trait Even : ::std::marker::MarkerTrait { }\n+trait Even {}\n \n-trait Odd : ::std::marker::MarkerTrait { }\n+trait Odd {}\n \n impl<T:Even> MyTrait for T { //~ ERROR E0119\n     fn get(&self) -> usize { 0 }"}, {"sha": "55c9ba2a0e89aeda6cfb43ea13f0bdd4e8ba049f", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-trait MyTrait : ::std::marker::MarkerTrait {}\n+trait MyTrait {}\n \n struct TestType<T>(::std::marker::PhantomData<T>);\n "}, {"sha": "cccc8b05b3038b8ae719f192badcb5906edc43b5", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,21 +10,19 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n \n impl MyTrait for .. {}\n //~^ ERROR conflicting implementations for trait `MyTrait`\n \n-trait MySafeTrait: MarkerTrait {}\n+trait MySafeTrait {}\n \n unsafe impl MySafeTrait for .. {}\n //~^ ERROR implementing the trait `MySafeTrait` is not unsafe\n \n-unsafe trait MyUnsafeTrait: MarkerTrait {}\n+unsafe trait MyUnsafeTrait {}\n \n impl MyUnsafeTrait for .. {}\n //~^ ERROR the trait `MyUnsafeTrait` requires an `unsafe impl` declaration"}, {"sha": "a6b62d17bc4e6aa9ac34540d80911fa8b0865294", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,11 +17,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n \n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n "}, {"sha": "5a9f440f8bb6a98900bb406b1976d6a056232c1b", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,11 +15,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n \n // `MyStruct` is not declared fundamental, therefore this would"}, {"sha": "ee0d5550fd61f0ea8e514bec49a723935cf31ac6", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,11 +15,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n \n // Tuples are not fundamental, therefore this would require that"}, {"sha": "160197368d6d983c673f924eb1508fbd62e1a3b1", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,7 +15,7 @@ struct Fat<T: ?Sized> {\n }\n \n struct Foo;\n-trait Bar : ::std::marker::MarkerTrait {}\n+trait Bar {}\n impl Bar for Foo {}\n \n pub fn main() {"}, {"sha": "b30eada162b84707134573888de917956f8ca50c", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,10 +10,8 @@\n \n // Test implicit coercions involving DSTs and raw pointers.\n \n-use std::marker::MarkerTrait;\n-\n struct S;\n-trait T : MarkerTrait {}\n+trait T {}\n impl T for S {}\n \n struct Foo<T: ?Sized> {"}, {"sha": "e116966670d2b7bda22c03def4a8c3f930e065f3", "filename": "src/test/compile-fail/implicit-method-bind.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimplicit-method-bind.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::SignedInt;\n-\n fn main() {\n-    let _f = 10.abs; //~ ERROR attempted to take value of method\n+    let _f = 10i32.abs; //~ ERROR attempted to take value of method\n }"}, {"sha": "251da2c6b3ee979c020bf7e21c55d490c5a4dadd", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Node : MarkerTrait {\n+trait Node {\n     fn zomg();\n }\n "}, {"sha": "51deb99a4f2cda7747feae6e2df16f83c0f80e9e", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n-use std::marker::MarkerTrait;\n \n-trait Str : MarkerTrait {}\n+trait Str {}\n \n trait Something {\n     fn yay<T: Debug>(_: Option<Self>, thing: &[T]);"}, {"sha": "a3529c9ea90b671d21d9274c51166f826da4aa34", "filename": "src/test/compile-fail/issue-16747.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16747.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait ListItem<'a> : MarkerTrait {\n+trait ListItem<'a> {\n     fn list_name() -> &'a str;\n }\n "}, {"sha": "6300a1dc15d6015cec6aea8b0c34743a529f13f4", "filename": "src/test/compile-fail/issue-18107.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18107.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-pub trait AbstractRenderer : MarkerTrait {}\n+pub trait AbstractRenderer {}\n \n fn _create_render(_: &()) ->\n     AbstractRenderer"}, {"sha": "41be78dd7b96eede5f0c9aa46bf702cad8fe9ca1", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n-\n use std::any::Any;\n use std::any::TypeId;\n-use std::marker::MarkerTrait;\n \n-pub trait Pt : MarkerTrait {}\n-pub trait Rt : MarkerTrait {}\n+pub trait Pt {}\n+pub trait Rt {}\n \n trait Private<P: Pt, R: Rt> {\n     fn call(&self, p: P, r: R);"}, {"sha": "a662e9ca98ee812086e338e874234fd0a00a1f91", "filename": "src/test/compile-fail/issue-18611.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n fn add_state(op: <isize as HasState>::State) {\n //~^ ERROR the trait `HasState` is not implemented for the type `isize`\n }\n \n-trait HasState : MarkerTrait {\n+trait HasState {\n     type State;\n }\n "}, {"sha": "d89b2c6ce8cb0221e9a64a922e4e8f683909da57", "filename": "src/test/compile-fail/issue-18819.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18819.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     type Item;\n }\n "}, {"sha": "20bd8af7c3ef5ecf3e18cee657cfdc24276765e3", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,11 +12,9 @@\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n \n-use std::marker::MarkerTrait;\n-\n struct t(Box<t>); //~ ERROR this type cannot be instantiated\n \n-trait to_str_2 : MarkerTrait {\n+trait to_str_2 {\n     fn my_to_string() -> String;\n }\n "}, {"sha": "a38278eae2411f1c92871586e0d33d907f51faab", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,10 +14,9 @@\n // away.\n \n use std::cell::RefCell;\n-use std::marker::MarkerTrait;\n use std::ops::{Shl, Shr};\n \n-pub trait Subscriber : MarkerTrait {\n+pub trait Subscriber {\n     type Input;\n }\n "}, {"sha": "b77230a8b340d1dfb145b608b7c034409b9eeec3", "filename": "src/test/compile-fail/issue-23080-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23080-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,9 +12,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-unsafe trait Trait: MarkerTrait {\n+unsafe trait Trait {\n //~^ error: traits with default impls (`e.g. unsafe impl Trait for ..`) must have no methods or associated items\n     type Output;\n }"}, {"sha": "026ee89c0b2b5a4dd940e0ec690a6412891516aa", "filename": "src/test/compile-fail/issue-3702-2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::ToPrimitive;\n+pub trait ToPrimitive {\n+    fn to_int(&self) -> isize { 0 }\n+}\n+\n+impl ToPrimitive for i32 {}\n+impl ToPrimitive for isize {}\n \n trait Add {\n     fn to_int(&self) -> isize;"}, {"sha": "9e324cdd61eb0e82f40308131b51c72d1d1ce360", "filename": "src/test/compile-fail/issue-5035-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5035-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait I : MarkerTrait {}\n+trait I {}\n type K = I+'static;\n \n fn foo(_x: K) {} //~ ERROR: the trait `core::marker::Sized` is not implemented"}, {"sha": "9ff957b6e6deac4904d0d5066390bd4dd53e2803", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait A : MarkerTrait {}\n+trait A {}\n \n struct Struct {\n     r: A+'static\n@@ -22,6 +20,6 @@ fn new_struct(r: A+'static)\n     Struct { r: r }\n }\n \n-trait Curve : MarkerTrait {}\n+trait Curve {}\n enum E {X(Curve+'static)}\n fn main() {}"}, {"sha": "6b320f400a8091dcc9e8f5e31c1f7a26d009fe39", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,14 +10,12 @@\n \n // Test the mechanism for warning about possible missing `self` declarations.\n \n-use std::marker::MarkerTrait;\n-\n trait CtxtFn {\n     fn f8(self, usize) -> usize;\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n-trait OtherTrait : MarkerTrait {\n+trait OtherTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -26,7 +24,7 @@ trait OtherTrait : MarkerTrait {\n // declaration to match against, so we wind up prisizeing it as a\n // candidate. This seems not unreasonable -- perhaps the user meant to\n // implement it, after all.\n-trait UnusedTrait : MarkerTrait {\n+trait UnusedTrait {\n     fn f9(usize) -> usize; //~ NOTE candidate\n }\n \n@@ -54,7 +52,7 @@ impl Myisize {\n     }\n }\n \n-trait ManyImplTrait : MarkerTrait {\n+trait ManyImplTrait {\n     fn is_str() -> bool { //~ NOTE candidate\n         false\n     }"}, {"sha": "d43ddff6b9500af1b7a8d0abcd056e7f9c418945", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,12 +10,11 @@\n \n // Test which of the builtin types are considered POD.\n \n-use std::marker::MarkerTrait;\n use std::rc::Rc;\n \n fn assert_copy<T:Copy>() { }\n \n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n #[derive(Copy, Clone)]\n struct MyStruct {"}, {"sha": "66297d70ef505cccb7e3f7f9f7c0a1dfa22bad8a", "filename": "src/test/compile-fail/kindck-impl-type-params-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n }\n \n impl<T:Copy> Foo for T {"}, {"sha": "570f7ad7fe3bf214adae00a7ac6644053305dd6c", "filename": "src/test/compile-fail/kindck-send-object.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,10 +12,8 @@\n // in this file all test the \"kind\" violates detected during kindck.\n // See all `regions-bounded-by-send.rs`\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n trait Message : Send { }\n \n // careful with object types, who knows what they close over..."}, {"sha": "48d5215b7085be78f389d72df0139f2efa25130e", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,10 +12,8 @@\n // is broken into two parts because some errors occur in distinct\n // phases in the compiler. See kindck-send-object2.rs as well!\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send+'static>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {"}, {"sha": "d3d166e2a6916181d24c32984ed212bca92a07e6", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,10 +10,8 @@\n \n // Continue kindck-send-object1.rs.\n \n-use std::marker::MarkerTrait;\n-\n fn assert_send<T:Send>() { }\n-trait Dummy : MarkerTrait { }\n+trait Dummy { }\n \n fn test50() {\n     assert_send::<&'static Dummy>(); //~ ERROR the trait `core::marker::Sync` is not implemented"}, {"sha": "c6dc3b70bef37d881f3e12196ecb84b493cc0045", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -105,7 +105,7 @@ impl PrivTrait for (Private<isize>,) {\n     fn bar(&self) -> Private<isize> { panic!() }\n }\n \n-pub trait ParamTrait<T> : marker::MarkerTrait {\n+pub trait ParamTrait<T> {\n     fn foo() -> T;\n }\n "}, {"sha": "efbf3782f9796a4b34ed979e293f60837032e67e", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,9 +11,7 @@\n // Test that an object type `Box<Foo>` is not considered to implement the\n // trait `Foo`. Issue #5087.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {}\n+trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n fn take_object(f: Box<Foo>) { take_foo(f); }\n //~^ ERROR the trait `Foo` is not implemented"}, {"sha": "6a010d49692d26450a4d95225eb3695c4509b0cd", "filename": "src/test/compile-fail/object-safety-no-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-no-static.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,7 +11,7 @@\n // Check that we correctly prevent users from making trait objects\n // from traits with static methods.\n \n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n     fn foo();\n }\n "}, {"sha": "071b4db40f86f5c7a60a4869093715f993a6d90f", "filename": "src/test/compile-fail/phantom-oibit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fphantom-oibit.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,9 +14,9 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::{MarkerTrait, PhantomData};\n+use std::marker::{PhantomData};\n \n-unsafe trait Zen: MarkerTrait {}\n+unsafe trait Zen {}\n \n unsafe impl Zen for .. {}\n "}, {"sha": "7fe0574ab7d9a663902dd9433fcc6a01145f3b4c", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,9 +17,7 @@\n \n // public type, private value\n pub mod foo1 {\n-    use std::marker::MarkerTrait;\n-\n-    pub trait Bar : MarkerTrait {\n+    pub trait Bar {\n     }\n     pub struct Baz;\n \n@@ -41,7 +39,7 @@ fn test_list1() {\n \n // private type, public value\n pub mod foo2 {\n-    trait Bar : ::std::marker::MarkerTrait {\n+    trait Bar {\n     }\n     pub struct Baz;\n \n@@ -62,7 +60,7 @@ fn test_list2() {\n \n // neither public\n pub mod foo3 {\n-    trait Bar : ::std::marker::MarkerTrait {\n+    trait Bar {\n     }\n     pub struct Baz;\n "}, {"sha": "f95ee405895a9c78cd286b54e98e09ea255d2fc5", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,7 +11,7 @@\n // Test that attempts to implicitly coerce a value into an\n // object respect the lifetime bound on the object type.\n \n-trait Foo : ::std::marker::MarkerTrait {}\n+trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n // FIXME (#22405): Replace `Box::new` with `box` here when/if possible."}, {"sha": "fdc97ecaf21e271949bed51a125266d3cefb9781", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,9 +12,7 @@\n \n // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n \n-use std::marker::MarkerTrait;\n-\n-trait X : MarkerTrait {}\n+trait X {}\n \n trait Iter {\n     type Item: X;"}, {"sha": "25b8137d29cade512868ecfdaa54e2a228611ea8", "filename": "src/test/compile-fail/regions-close-over-borrowed-ref-in-obj.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-borrowed-ref-in-obj.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait { }\n+trait Foo { }\n \n impl<'a> Foo for &'a isize { }\n "}, {"sha": "b864e6ca9578b7878d0b62a1bb6d7279a3173ad3", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait TraitNotAStruct : ::std::marker::MarkerTrait { }\n+trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };"}, {"sha": "c18c5b386e8b21816be1abd6ff4e38818ea86978", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::MarkerTrait;\n-\n-trait Trait : MarkerTrait {}\n+trait Trait {}\n \n struct Foo<T:Trait> {\n     x: T,"}, {"sha": "0a36fcbed690513e6137d88b715b87db25dd8de6", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n // Tests for \"default\" bounds inferred for traits with no bounds list.\n \n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {}\n+trait Foo {}\n \n fn a(_x: Box<Foo+Send>) {\n }"}, {"sha": "dadcbd5bce710291c706ad4a4209374352549d1b", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,9 +12,7 @@\n // trait impl is only applied to a trait object, not concrete types which implement\n // the trait.\n \n-use std::marker::MarkerTrait;\n-\n-trait T : MarkerTrait {}\n+trait T {}\n \n impl<'a> T+'a {\n     fn foo(&self) {}"}, {"sha": "155b835bbc6e0704d4e24657cb40398c6d7f7615", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::Int;\n+use std::ops::Add;\n \n-trait BrokenAdd: Int {\n+trait BrokenAdd: Copy + Add<Output=Self> {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected `Self`\n@@ -20,7 +20,7 @@ trait BrokenAdd: Int {\n     }\n }\n \n-impl<T: Int> BrokenAdd for T {}\n+impl<T: Copy + Add<Output=T>> BrokenAdd for T {}\n \n pub fn main() {\n     let foo: u8 = 0;"}, {"sha": "a27f7f7ebbe0f4b405d5d701bbb8309bd9de464f", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n "}, {"sha": "24819bb4f08d63a51f7db7752df8bfbdf14766f3", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n impl<T> !MyTrait for *mut T {}"}, {"sha": "4b91d0b7a736c6f1c1f5d4b692c23fa854333894", "filename": "src/test/compile-fail/typeck-default-trait-impl-negation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,13 +10,11 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait {}\n+trait MyTrait {}\n \n impl MyTrait for .. {}\n \n-unsafe trait MyUnsafeTrait: MarkerTrait {}\n+unsafe trait MyUnsafeTrait {}\n \n unsafe impl MyUnsafeTrait for .. {}\n "}, {"sha": "c67fc92313c3a58d29e714db80e0b8003cb55419", "filename": "src/test/compile-fail/typeck-default-trait-impl-precedence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,15 +15,13 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait Defaulted : MarkerTrait { }\n+trait Defaulted { }\n impl Defaulted for .. { }\n impl<'a,T:Signed> Defaulted for &'a T { }\n impl<'a,T:Signed> Defaulted for &'a mut T { }\n fn is_defaulted<T:Defaulted>() { }\n \n-trait Signed : MarkerTrait { }\n+trait Signed { }\n impl Signed for i32 { }\n \n fn main() {"}, {"sha": "aa918119fbceef87840dcd9cb859562c23a51442", "filename": "src/test/compile-fail/typeck-default-trait-impl-superregion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,8 +13,6 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n trait MyTrait : 'static {}\n \n impl MyTrait for .. {}"}, {"sha": "c9bfdff6c0e495cd78a089e0d4b2d96fcc2fe421", "filename": "src/test/compile-fail/typeck-default-trait-impl-supertrait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,9 +13,7 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n-\n-trait NotImplemented: MarkerTrait { }\n+trait NotImplemented { }\n \n trait MyTrait : NotImplemented {}\n "}, {"sha": "4f572e87639f051208ba7efa78d14a961e8e35ab", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,11 +15,9 @@\n \n #![feature(optin_builtin_traits)]\n \n-use std::marker::MarkerTrait;\n+trait NotImplemented { }\n \n-trait NotImplemented: MarkerTrait { }\n-\n-trait MyTrait: MarkerTrait\n+trait MyTrait\n     where Option<Self> : NotImplemented\n {}\n "}, {"sha": "3f18f359d306e711ee4be2c654e0382d38a8d8c7", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n // Test `?Sized` local variables.\n \n-use std::marker;\n-\n-trait T : marker::MarkerTrait { }\n+trait T {}\n \n fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer."}, {"sha": "0245a1b5cf2c8628e39abbf80b87c47d5c868b88", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n // Test sized-ness checking in substitution in impls.\n \n-use std::marker::MarkerTrait;\n-\n-trait T : MarkerTrait {}\n+trait T {}\n \n // I would like these to fail eventually.\n // impl - bounded"}, {"sha": "67975d02b19f06f1a037091612338475d11b47fd", "filename": "src/test/debuginfo/issue13213.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue13213.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,8 +12,6 @@\n \n // aux-build:issue13213aux.rs\n \n-#![feature(old_io)]\n-\n extern crate issue13213aux;\n \n // compile-flags:-g"}, {"sha": "a5246b9300c91ad2f1f4149e0d732ad6b19634c5", "filename": "src/test/pretty/default-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(optin_builtin_traits, core)]\n+#![feature(optin_builtin_traits)]\n \n // pp-exact\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait { }\n+trait MyTrait { }\n \n impl MyTrait for .. { }\n "}, {"sha": "72c2d389e2aac7cf9beb1426568f50d33b88b002", "filename": "src/test/run-make/archive-duplicate-names/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2FMakefile?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,11 @@\n+-include ../tools.mk\n+\n+all:\n+\tmkdir $(TMPDIR)/a\n+\tmkdir $(TMPDIR)/b\n+\t$(CC) -c -o $(TMPDIR)/a/foo.o foo.c\n+\t$(CC) -c -o $(TMPDIR)/b/foo.o bar.c\n+\tar crus $(TMPDIR)/libfoo.a $(TMPDIR)/a/foo.o $(TMPDIR)/b/foo.o\n+\t$(RUSTC) foo.rs\n+\t$(RUSTC) bar.rs\n+\t$(call RUN,bar)"}, {"sha": "a25fa10f4d3ee51dabea7ba2efd91f8bf5846d1a", "filename": "src/test/run-make/archive-duplicate-names/bar.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.c?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+void bar() {}"}, {"sha": "1200a6de8e2e063302cd4b4caa8f84091f1cd6c8", "filename": "src/test/run-make/archive-duplicate-names/bar.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Fbar.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate foo;\n+\n+fn main() {\n+    foo::baz();\n+}"}, {"sha": "61d5d15407891a0a497a36c4a38dd7ab2b3526dc", "filename": "src/test/run-make/archive-duplicate-names/foo.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.c?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+void foo() {}"}, {"sha": "24b4734f2cd334fb6d10cbe6100913d868e97512", "filename": "src/test/run-make/archive-duplicate-names/foo.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Farchive-duplicate-names%2Ffoo.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+\n+#[link(name = \"foo\", kind = \"static\")]\n+extern {\n+    fn foo();\n+    fn bar();\n+}\n+\n+pub fn baz() {\n+    unsafe {\n+        foo();\n+        bar();\n+    }\n+}"}, {"sha": "fd69d2786b8d0800adb74bc000a7b73b638e1c0f", "filename": "src/test/run-make/cannot-read-embedded-idents/create_and_compile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(old_io, old_path)]\n-\n use std::env;\n use std::fs::File;\n use std::process::Command;"}, {"sha": "244f32b8ee5fc323feaf63457562faf436f95bb2", "filename": "src/test/run-make/extern-fn-reachable/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, old_path, os)]\n+#![feature(std_misc)]\n \n use std::dynamic_lib::DynamicLibrary;\n-use std::os;\n use std::path::Path;\n \n pub fn main() {"}, {"sha": "4d75e58aad938a05cb65590936ea8f9636c78e7c", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -25,8 +25,6 @@ use sub::sub2 as msalias;\n use sub::sub2;\n use sub::sub2::nested_struct as sub_struct;\n use std::num::One;\n-use std::num::cast;\n-use std::num::{from_int,from_i8,from_i32};\n \n use std::mem::size_of;\n \n@@ -42,7 +40,6 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n \n     // import tests\n     fn foo(x: &One) {}\n-    let _: Option<u8> = from_i32(45);\n \n     let x = 42;\n "}, {"sha": "2617a05fe24141e42a33e7aa438fff4e5a7807b1", "filename": "src/test/run-pass/associated-types-basic.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     type T;\n }\n "}, {"sha": "c93a0b76a95600c31ec10a6a7be9089f6f5de019", "filename": "src/test/run-pass/associated-types-issue-20371.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-issue-20371.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,10 +13,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n impl X for f64 { type Y = isize; }\n-trait X : MarkerTrait { type Y; }\n+trait X { type Y; }\n fn main() {}"}, {"sha": "83f0d360e6122cd7b6f5572ecb8af8c1267efa01", "filename": "src/test/run-pass/associated-types-nested-projections.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-nested-projections.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -14,10 +14,9 @@\n \n #![feature(core)]\n \n-use std::marker::MarkerTrait;\n use std::slice;\n \n-trait Bound : MarkerTrait {}\n+trait Bound {}\n \n impl<'a> Bound for &'a i32 {}\n "}, {"sha": "7e2d1aa23149dea229d017bbac6c56951b5bc58a", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-binding.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,12 +13,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n #![allow(dead_code)]\n \n-use std::marker::MarkerTrait;\n-\n-pub trait Integral : MarkerTrait {\n+pub trait Integral {\n     type Opposite;\n }\n "}, {"sha": "1830b41d0b50681ee7a986b259ae0ca1d7e4655a", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,17 +12,14 @@\n // `Item` originates in a where-clause, not the declaration of\n // `T`. Issue #20300.\n \n-\n-#![feature(core)]\n-\n-use std::marker::{MarkerTrait, PhantomData};\n+use std::marker::{PhantomData};\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n use std::sync::atomic::Ordering::SeqCst;\n \n static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n \n // Preamble.\n-trait Trait : MarkerTrait { type Item; }\n+trait Trait { type Item; }\n struct Struct;\n impl Trait for Struct {\n     type Item = u32;"}, {"sha": "0fa67e873f89c4bb866383c6c44f759716066d29", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,9 +11,7 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n-#![feature(unboxed_closures, old_io)]\n-\n-use std::mem;\n+#![feature(unboxed_closures)]\n \n fn call_it<F>(f: F)\n     where F : FnOnce(String) -> String"}, {"sha": "a29953bea887bbb0869515b499ac1347c673639c", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -11,7 +11,6 @@\n \n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n-        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "0234d7b0b6376e06fa6d4982a597ee0ee8d5fb5a", "filename": "src/test/run-pass/derive-no-std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fderive-no-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fderive-no-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderive-no-std.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -31,7 +31,6 @@ enum Bar {\n     Quux(u32),\n }\n \n-#[derive(FromPrimitive)]\n enum Baz { A=0, B=5, }\n \n fn main() {"}, {"sha": "4399d741cad1e104096c0b32851df7cde3005ca9", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core)]\n-\n-use std::num::FromPrimitive;\n-use std::isize;\n-\n-#[derive(PartialEq, FromPrimitive, Debug)]\n-enum A {\n-    Foo = isize::MAX,\n-    Bar = 1,\n-    Baz = 3,\n-    Qux,\n-}\n-\n-pub fn main() {\n-    let x: Option<A> = FromPrimitive::from_int(isize::MAX);\n-    assert_eq!(x, Some(A::Foo));\n-\n-    let x: Option<A> = FromPrimitive::from_int(1);\n-    assert_eq!(x, Some(A::Bar));\n-\n-    let x: Option<A> = FromPrimitive::from_int(3);\n-    assert_eq!(x, Some(A::Baz));\n-\n-    let x: Option<A> = FromPrimitive::from_int(4);\n-    assert_eq!(x, Some(A::Qux));\n-\n-    let x: Option<A> = FromPrimitive::from_int(5);\n-    assert_eq!(x, None);\n-}"}, {"sha": "15f229dbca5d908869512b48cee4d9b62561c781", "filename": "src/test/run-pass/drop-with-type-ascription-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-1.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -9,11 +9,9 @@\n // except according to those terms.\n \n \n-#![feature(str_words)]\n-\n fn main() {\n     let foo = \"hello\".to_string();\n-    let foo: Vec<&str> = foo.words().collect();\n+    let foo: Vec<&str> = foo.split_whitespace().collect();\n     let invalid_string = &foo[0];\n     assert_eq!(*invalid_string, \"hello\");\n }"}, {"sha": "0a490466ef73b3f109b38b62e50ed2e7c9402fdc", "filename": "src/test/run-pass/early-ret-binop-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,8 +10,8 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::num::Int;\n+use std::ops::Add;\n \n-fn wsucc<T:Int>(n: T) -> T { n + { return n } }\n+fn wsucc<T:Add<Output=T> + Copy>(n: T) -> T { n + { return n } }\n \n pub fn main() { }"}, {"sha": "4d54bb4ef7250170aa5027128919eecbcfd84a21", "filename": "src/test/run-pass/exponential-notation.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baf3482537f5a245a9c17ca730398f1a8b001d7/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=2baf3482537f5a245a9c17ca730398f1a8b001d7", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(std_misc)]\n-\n-use std::num::strconv::ExponentFormat::{ExpBin, ExpDec};\n-use std::num::strconv::SignificantDigits::DigMax;\n-use std::num::strconv::SignFormat::{SignAll, SignNeg};\n-use std::num::strconv::float_to_str_common as to_string;\n-\n-macro_rules! t {\n-    ($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } }\n-}\n-\n-pub fn main() {\n-    // Basic usage\n-    t!(to_string(1.2345678e-5f64, 10, true, SignNeg, DigMax(6), ExpDec, false),\n-             \"1.234568e-5\");\n-\n-    // Hexadecimal output\n-    t!(to_string(7.281738281250e+01f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n-              \"+1.2345p+6\");\n-    t!(to_string(-1.777768135071e-02f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n-             \"-1.2345p-6\");\n-\n-    // Some denormals\n-    t!(to_string(4.9406564584124654e-324f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n-             \"1p-1074\");\n-    t!(to_string(2.2250738585072009e-308f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n-             \"1p-1022\");\n-}"}, {"sha": "421b19f2864fe6050edbf81576e87640adba5567", "filename": "src/test/run-pass/extern-methods.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fextern-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-methods.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait A : MarkerTrait {\n+trait A {\n     extern \"fastcall\" fn test1(i: i32);\n     extern fn test2(i: i32);\n }"}, {"sha": "856599431fd18149dfec2e84e1072f0c9076b45c", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(std_misc)]\n-\n-use std::num::Float;\n+use std::f64;\n \n pub fn main() {\n-  let nan: f64 = Float::nan();\n+  let nan: f64 = f64::NAN;\n   assert!((nan).is_nan());\n \n-  let inf: f64 = Float::infinity();\n-  let neg_inf: f64 = Float::neg_infinity();\n+  let inf: f64 = f64::INFINITY;\n+  let neg_inf: f64 = -f64::INFINITY;\n   assert_eq!(-inf, neg_inf);\n \n   assert!( nan !=  nan);"}, {"sha": "37ceaae373b9468a0c6392493be126d533b372af", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,7 +13,6 @@\n \n macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n-        use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);"}, {"sha": "c81e16ebb7c60f3c62b4303112783fec5c03efc1", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,8 +12,6 @@\n // Make sure that if a process doesn't have its stdio/stderr descriptors set up\n // that we don't die in a large ball of fire\n \n-#![feature(old_io)]\n-\n use std::env;\n use std::process::{Command, Stdio};\n "}, {"sha": "b4621a2d053b1de4dae9e8d12d889575b2b75115", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,10 +12,7 @@\n \n #![feature(collections)]\n \n-extern crate collections;\n-\n use std::collections::BitVec;\n-use std::num::Float;\n \n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6"}, {"sha": "9da04f723553105d1f6226892e4f526afc3a7db1", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![feature(rustc_private, old_io)]\n+#![feature(rustc_private)]\n \n extern crate rbml;\n extern crate serialize;"}, {"sha": "ca68272d2d0f295f605d6df8b89f22a0f664ec49", "filename": "src/test/run-pass/issue-13105.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-13105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13105.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,11 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Foo : MarkerTrait {\n+trait Foo {\n     fn quux(u8) {}\n }\n "}, {"sha": "ba6815d5b7c6973e0a8588be3ffcb10177bb1c4b", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n \n \n-#![feature(old_io, io)]\n-\n use std::env;\n use std::process::Command;\n use std::io::{self, Write};"}, {"sha": "e3340d9767d02c1e52d86c59a0926f928e049ee7", "filename": "src/test/run-pass/issue-21245.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21245.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -20,19 +20,19 @@ use std::ptr;\n trait IntoIterator {\n     type Iter: Iterator;\n \n-    fn into_iter(self) -> Self::Iter;\n+    fn into_iter2(self) -> Self::Iter;\n }\n \n impl<I> IntoIterator for I where I: Iterator {\n     type Iter = I;\n \n-    fn into_iter(self) -> I {\n+    fn into_iter2(self) -> I {\n         self\n     }\n }\n \n fn desugared_for_loop_bad<T>(v: Vec<T>) {\n-    match IntoIterator::into_iter(v.iter()) {\n+    match IntoIterator::into_iter2(v.iter()) {\n         mut iter => {\n             loop {\n                 match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "4ebc43163ede894d451b8a85d612a218ff334271", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,35 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(zero_one)]\n \n-#![feature(core)]\n-\n-use std::num::Int;\n+use std::num::Zero;\n use std::thread;\n \n-// Avoid using constants, which would trigger compile-time errors.\n-fn min_val<T: Int>() -> T { Int::min_value() }\n-fn zero<T: Int>() -> T { Int::zero() }\n-\n fn main() {\n-    assert!(thread::spawn(move|| { min_val::<isize>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i8>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i16>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i32>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i64>() / -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize / zero::<isize>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 / zero::<i8>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 / zero::<i16>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 / zero::<i32>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 / zero::<i64>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<isize>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i8>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i16>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i32>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { min_val::<i64>() % -1; }).join().is_err());\n-    assert!(thread::spawn(move|| { 1isize % zero::<isize>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i8 % zero::<i8>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i16 % zero::<i16>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i32 % zero::<i32>(); }).join().is_err());\n-    assert!(thread::spawn(move|| { 1i64 % zero::<i64>(); }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i8::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i16::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i32::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i64::min_value() / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize / isize::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 / i8::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 / i16::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 / i32::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 / i64::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i8::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i16::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i32::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { i64::min_value() % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { 1isize % isize::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i8 % i8::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i16 % i16::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i32 % i32::zero(); }).join().is_err());\n+    assert!(thread::spawn(move|| { 1i64 % i64::zero(); }).join().is_err());\n }"}, {"sha": "74da4273b6ab0fb9b773425793bed9e05ae5df70", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,7 +12,7 @@\n // ignore-android: FIXME(#10379)\n // ignore-windows: std::dynamic_lib does not work on Windows well\n \n-#![feature(std_misc, old_path)]\n+#![feature(std_misc)]\n \n extern crate linkage_visibility as foo;\n "}, {"sha": "09759326afd911c69b942cddefb49a87c02332bc", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -12,7 +12,7 @@\n // exec-env:RUST_LOG=debug\n // compile-flags:-C debug-assertions=y\n \n-#![feature(old_io, rustc_private)]\n+#![feature(rustc_private)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "5eecf27db677bec2f0ec87f4add5a46ff439710e", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,9 +13,8 @@\n // temporary. Issue #19147.\n \n \n-#![feature(core, old_io)]\n+#![feature(core)]\n \n-use std::mem;\n use std::slice;\n \n pub type IoResult<T> = Result<T, ()>;"}, {"sha": "b7de1b5f4cbb536efd0a3276093f0bae9f24b05b", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,11 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-use std::marker::MarkerTrait;\n-\n-trait Serializer : MarkerTrait {\n+trait Serializer {\n }\n \n trait Serializable {"}, {"sha": "b1d71abc78599c0bb908e08513fa12cedb0d6df9", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -15,11 +15,7 @@\n // necessary. Testing the methods of the impls is done within the source\n // file for each numeric type.\n \n-\n-#![feature(core)]\n-\n use std::ops::Add;\n-use std::num::ToPrimitive;\n \n pub fn main() {\n // ints\n@@ -37,9 +33,4 @@ pub fn main() {\n     assert_eq!(15_u16.add(6u16), 21_u16);\n     assert_eq!(15_u32.add(6u32), 21_u32);\n     assert_eq!(15_u64.add(6u64), 21_u64);\n-\n-// floats\n-    // num\n-    assert_eq!(10_f32.to_i32().unwrap(), 10);\n-    assert_eq!(10_f64.to_i32().unwrap(), 10);\n }"}, {"sha": "5e924d015b619ca712aa6101f2c89794d21199a5", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -13,7 +13,6 @@\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::num::ToPrimitive;\n \n #[derive(PartialEq, Debug)]\n struct Point {\n@@ -23,9 +22,6 @@ struct Point {\n \n pub fn main() {\n     let box_5: Box<_> = box 5_usize;\n-    assert_eq!(Rc::new(5_usize).to_uint(), Some(5));\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    assert_eq!((Box::new(&Box::new(&Rc::new(Box::new(Box::new(&box_5)))))).to_uint(), Some(5));\n     let point = Rc::new(Point {x: 2, y: 4});\n     assert_eq!(point.x, 2);\n     assert_eq!(point.y, 4);"}, {"sha": "a155ee396b614bc917d1923cad9fe95b2ced0c9d", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -17,15 +17,13 @@\n // intact.\n \n // ignore-aarch64\n-#![feature(path, fs, os, io, old_path)]\n \n use std::io::prelude::*;\n use std::io;\n use std::fs;\n use std::process::Command;\n-use std::os;\n use std::env;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n fn main() {\n     let my_args = env::args().collect::<Vec<_>>();"}, {"sha": "db543116d17a5c3c040574a6c5a1a2937f2372d0", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,16 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(start, os, std_misc, old_io)]\n+#![feature(start, std_misc)]\n \n use std::ffi::CStr;\n use std::process::{Command, Output};\n-use std::os;\n use std::rt::unwind::try;\n-use std::rt;\n use std::str;\n-use std::thread::Thread;\n-use std::thunk::Thunk;\n \n #[start]\n fn start(argc: isize, argv: *const *const u8) -> isize {"}, {"sha": "f69b857981d788f735983ad3ebf87e70d129c181", "filename": "src/test/run-pass/syntax-trait-polarity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-trait-polarity.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,15 +10,13 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(optin_builtin_traits, core)]\n-\n-use std::marker::{MarkerTrait, Send};\n+#![feature(optin_builtin_traits)]\n \n struct TestType;\n \n impl TestType {}\n \n-trait TestTrait : MarkerTrait {}\n+trait TestTrait {}\n \n impl !Send for TestType {}\n "}, {"sha": "4a1bb5a5916f0dfaea28f83fafb7f8a55742f3ad", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n-#![allow(unknown_features)]\n-#![feature(box_syntax, old_io, std_misc, io, set_panic, set_stdio)]\n+#![feature(box_syntax, set_stdio)]\n \n use std::io::prelude::*;\n use std::io;"}, {"sha": "558e69664ecf9c840f74cd2f09f483ef929b9e0e", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0eb9384af9f623563df59a9ae454ffedea1f4f8/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=c0eb9384af9f623563df59a9ae454ffedea1f4f8", "patch": "@@ -10,9 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-\n-trait Foo : ::std::marker::MarkerTrait {\n+trait Foo {\n }\n \n fn b(_x: Box<Foo+Send>) {"}]}