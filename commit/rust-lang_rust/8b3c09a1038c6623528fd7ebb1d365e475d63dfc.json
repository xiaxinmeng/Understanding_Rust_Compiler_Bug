{"sha": "8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiM2MwOWExMDM4YzY2MjM1MjhmZDdlYmIxZDM2NWU0NzVkNjNkZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T02:24:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-20T02:24:52Z"}, "message": "auto merge of #5962 : pcwalton/rust/shootout, r=pcwalton\n\nr? @brson", "tree": {"sha": "cccb89a294c2efb90a4a319fdd50b0fc0cf6c6e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cccb89a294c2efb90a4a319fdd50b0fc0cf6c6e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "html_url": "https://github.com/rust-lang/rust/commit/8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6510fd92544467a03df93b5124644976aa79f964", "url": "https://api.github.com/repos/rust-lang/rust/commits/6510fd92544467a03df93b5124644976aa79f964", "html_url": "https://github.com/rust-lang/rust/commit/6510fd92544467a03df93b5124644976aa79f964"}, {"sha": "d2b644842a75af44d042f4026a585e4a9cf5979a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b644842a75af44d042f4026a585e4a9cf5979a", "html_url": "https://github.com/rust-lang/rust/commit/d2b644842a75af44d042f4026a585e4a9cf5979a"}], "stats": {"total": 4154, "additions": 3042, "deletions": 1112}, "files": [{"sha": "81190ea8fc62e4f8c9d805674b988057cb1d35dc", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -95,9 +95,10 @@ pub use str::{StrSlice};\n pub use container::{Container, Mutable};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n pub use ptr::Ptr;"}, {"sha": "1d7cc8515a6566d9397dd5dfe69c88d43c9cfc47", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -16,7 +16,6 @@\n use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use to_bytes::IterBytes;\n use iter::BaseIter;\n use hash::Hash;\n use iter;\n@@ -72,7 +71,7 @@ fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     }\n }\n \n-priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n+priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     #[inline(always)]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n@@ -111,9 +110,8 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline(always)]\n-    fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n-                                                           k: &Q)\n-                                                        -> SearchResult {\n+    fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n+                                               -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n@@ -303,15 +301,15 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Container for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint { self.size }\n \n     /// Return true if the map contains no elements\n     fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         for uint::range(0, self.buckets.len()) |idx| {\n@@ -321,7 +319,7 @@ impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, k: &K) -> bool {\n         match self.bucket_for_key(k) {\n@@ -458,7 +456,7 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n }\n \n-pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n+pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// Create an empty HashMap\n     fn new() -> HashMap<K, V> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n@@ -669,8 +667,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n-    fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n-                                                      -> bool {\n+    fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n         match self.bucket_for_key_equiv(key) {\n             FoundEntry(_) => {true}\n             TableFull | FoundHole(_) => {false}\n@@ -680,8 +677,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n     #[cfg(stage0)]\n-    fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                              -> Option<&'self V> {\n+    fn find_equiv<Q:Hash + Equiv<K>>(&self, k: &Q) -> Option<&'self V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n@@ -693,17 +689,15 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    fn find_equiv<'a, Q:Hash + IterBytes + Equiv<K>>(\n-        &'a self, k: &Q) -> Option<&'a V>\n-    {\n+    fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {\n+impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -724,31 +718,31 @@ pub struct HashSet<T> {\n     priv map: HashMap<T, ()>\n }\n \n-impl<T:Hash + IterBytes + Eq> BaseIter<T> for HashSet<T> {\n+impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Hash + IterBytes + Eq> Eq for HashSet<T> {\n+impl<T:Hash + Eq> Eq for HashSet<T> {\n     fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n     fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Hash + IterBytes + Eq> Container for HashSet<T> {\n+impl<T:Hash + Eq> Container for HashSet<T> {\n     /// Return the number of elements in the set\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Mutable for HashSet<T> {\n+impl<T:Hash + Eq> Mutable for HashSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Set<T> for HashSet<T> {\n+impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n@@ -816,7 +810,7 @@ impl<T:Hash + IterBytes + Eq> Set<T> for HashSet<T> {\n     }\n }\n \n-pub impl <T:Hash + IterBytes + Eq> HashSet<T> {\n+pub impl <T:Hash + Eq> HashSet<T> {\n     /// Create an empty HashSet\n     fn new() -> HashSet<T> {\n         HashSet::with_capacity(INITIAL_CAPACITY)"}, {"sha": "3dcca0e06c228c4e9f45c4b3f113ab177d2a5d5e", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -45,6 +45,10 @@ pub trait ExtendedIter<A> {\n     fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n+pub trait ExtendedMutableIter<A> {\n+    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n+}\n+\n pub trait EqIter<A:Eq> {\n     fn contains(&self, x: &A) -> bool;\n     fn count(&self, x: &A) -> uint;"}, {"sha": "945d08323b4e5360b8863e19e90e6e815b7fe652", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1097,9 +1097,12 @@ pub mod funcs {\n                 unsafe fn setbuf(stream: *FILE, buf: *c_char);\n                 // Omitted: printf and scanf variants.\n                 unsafe fn fgetc(stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fgets(buf: *mut c_char, n: c_int,\n                          stream: *FILE) -> *c_char;\n+                #[fast_ffi]\n                 unsafe fn fputc(c: c_int, stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n                 // Omitted: getc, getchar (might be macros).\n \n@@ -1109,8 +1112,10 @@ pub mod funcs {\n                 // Omitted: putc, putchar (might be macros).\n                 unsafe fn puts(s: *c_char) -> c_int;\n                 unsafe fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fread(ptr: *mut c_void, size: size_t,\n                          nobj: size_t, stream: *FILE) -> size_t;\n+                #[fast_ffi]\n                 unsafe fn fwrite(ptr: *c_void, size: size_t,\n                           nobj: size_t, stream: *FILE) -> size_t;\n                 unsafe fn fseek(stream: *FILE, offset: c_long,\n@@ -1144,9 +1149,13 @@ pub mod funcs {\n                               -> c_long;\n                 unsafe fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n                                -> c_ulong;\n+                #[fast_ffi]\n                 unsafe fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn malloc(size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn realloc(p: *c_void, size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn free(p: *c_void);\n                 unsafe fn abort() -> !;\n                 unsafe fn exit(status: c_int) -> !;\n@@ -1257,6 +1266,7 @@ pub mod funcs {\n                 unsafe fn pclose(stream: *FILE) -> c_int;\n \n                 #[link_name = \"_fdopen\"]\n+                #[fast_ffi]\n                 unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n \n                 #[link_name = \"_fileno\"]\n@@ -1340,6 +1350,7 @@ pub mod funcs {\n                         textmode: c_int) -> c_int;\n \n                 #[link_name = \"_read\"]\n+                #[fast_ffi]\n                 unsafe fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n                             -> c_int;\n \n@@ -1350,6 +1361,7 @@ pub mod funcs {\n                 unsafe fn unlink(c: *c_char) -> c_int;\n \n                 #[link_name = \"_write\"]\n+                #[fast_ffi]\n                 unsafe fn write(fd: c_int, buf: *c_void, count: c_uint)\n                              -> c_int;\n             }\n@@ -1502,6 +1514,7 @@ pub mod funcs {\n                 unsafe fn pathconf(path: *c_char, name: c_int) -> c_long;\n                 unsafe fn pause() -> c_int;\n                 unsafe fn pipe(fds: *mut c_int) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn read(fd: c_int, buf: *mut c_void,\n                         count: size_t) -> ssize_t;\n                 unsafe fn rmdir(path: *c_char) -> c_int;\n@@ -1514,6 +1527,7 @@ pub mod funcs {\n                 unsafe fn tcgetpgrp(fd: c_int) -> pid_t;\n                 unsafe fn ttyname(fd: c_int) -> *c_char;\n                 unsafe fn unlink(c: *c_char) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn write(fd: c_int, buf: *c_void, count: size_t)\n                              -> ssize_t;\n             }"}, {"sha": "e170d85cc716e6d0ef73ac00c6940798984d028c", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -503,4 +503,4 @@ mod tests {\n     fn test_range_step_zero_step() {\n         for range_step(0,10,0) |_i| {}\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "0fb6ea614d8614f9e57d264e1d3137257f56cf19", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -474,4 +474,4 @@ mod tests {\n     fn test_range_step_zero_step_down() {\n         for range_step(0,-10,0) |_i| {}\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "822fb2e476beb2de74b5149a807a9fdd85c1cf07", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -33,7 +33,7 @@ pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n-pub use iter::Times;\n+pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n@@ -46,7 +46,7 @@ pub use to_str::ToStr;\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n \n /* Reexported runtime types */"}, {"sha": "837f9c1a9adeadbb785cc406f94f6eab9b839f26", "filename": "src/libcore/str.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -67,6 +67,15 @@ pub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str {\n     return unsafe { raw::from_bytes_with_null(vv) };\n }\n \n+pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n+    unsafe {\n+        assert!(is_utf8(vector));\n+        let (ptr, len): (*u8, uint) = ::cast::transmute(vector);\n+        let string: &'a str = ::cast::transmute((ptr, len + 1));\n+        string\n+    }\n+}\n+\n /// Copy a slice into a new unique str\n pub fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes_owned(s, 0, len(s)) }\n@@ -421,6 +430,15 @@ pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n+/// Work with the string as a byte slice, not including trailing null, without\n+/// a callback.\n+#[inline(always)]\n+pub fn byte_slice_no_callback<'a>(s: &'a str) -> &'a [u8] {\n+    unsafe {\n+        cast::transmute(s)\n+    }\n+}\n+\n /// Convert a string to a unique vector of characters\n pub fn to_chars(s: &str) -> ~[char] {\n     let mut buf = ~[];"}, {"sha": "611862a79e7e0bb7a4a89f5aa58a9fc0aece3e80", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -35,6 +35,14 @@ pub mod rustrt {\n \n         #[rust_stack]\n         unsafe fn rust_upcall_free(ptr: *c_char);\n+\n+        #[fast_ffi]\n+        unsafe fn rust_upcall_malloc_noswitch(td: *c_char,\n+                                              size: uintptr_t)\n+                                           -> *c_char;\n+\n+        #[fast_ffi]\n+        unsafe fn rust_upcall_free_noswitch(ptr: *c_char);\n     }\n }\n \n@@ -81,7 +89,7 @@ pub unsafe fn exchange_free(ptr: *c_char) {\n #[lang=\"malloc\"]\n #[inline(always)]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    return rustrt::rust_upcall_malloc(td, size);\n+    return rustrt::rust_upcall_malloc_noswitch(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -90,7 +98,7 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[lang=\"free\"]\n #[inline(always)]\n pub unsafe fn local_free(ptr: *c_char) {\n-    rustrt::rust_upcall_free(ptr);\n+    rustrt::rust_upcall_free_noswitch(ptr);\n }\n \n #[lang=\"borrow_as_imm\"]"}, {"sha": "efb11271af6d50136982d0120cb395d543ba73e8", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 84, "deletions": 7, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -12,8 +12,9 @@\n \n #[warn(non_camel_case_types)];\n \n-use container::{Container, Mutable};\n+use cast::transmute;\n use cast;\n+use container::{Container, Mutable};\n use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n use iter::BaseIter;\n@@ -43,9 +44,11 @@ pub mod rustrt {\n     pub extern {\n         // These names are terrible. reserve_shared applies\n         // to ~[] and reserve_shared_actual applies to @[].\n+        #[fast_ffi]\n         unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n                                      ++v: **raw::VecRepr,\n                                      ++n: libc::size_t);\n+        #[fast_ffi]\n         unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n                                             ++v: **raw::VecRepr,\n                                             ++n: libc::size_t);\n@@ -73,6 +76,7 @@ pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n+#[inline]\n pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     use managed;\n@@ -1386,13 +1390,19 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n /// to mutate the contents as you iterate.\n #[inline(always)]\n pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n-    let mut i = 0;\n-    let n = v.len();\n-    while i < n {\n-        if !f(&mut v[i]) {\n-            return;\n+    do vec::as_mut_buf(v) |p, n| {\n+        let mut n = n;\n+        let mut p = p;\n+        while n > 0 {\n+            unsafe {\n+                let q: &'r mut T = cast::transmute_mut_region(&mut *p);\n+                if !f(q) {\n+                    break;\n+                }\n+                p = p.offset(1);\n+            }\n+            n -= 1;\n         }\n-        i += 1;\n     }\n }\n \n@@ -1424,6 +1434,22 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n     }\n }\n \n+/**\n+ * Iterates over a mutable vector's elements and indices\n+ *\n+ * Return true to continue, false to break.\n+ */\n+#[inline(always)]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+    let mut i = 0;\n+    for each_mut(v) |p| {\n+        if !f(i, p) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n /**\n  * Iterates over a vector's elements in reverse\n  *\n@@ -1806,6 +1832,7 @@ pub trait ImmutableVector<T> {\n     fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n }\n \n /// Extension methods for vectors\n@@ -1916,6 +1943,14 @@ impl<'self,T> ImmutableVector<T> for &'self [T] {\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[inline(always)]\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n+        let (ptr, _): (*T, uint) = transmute(*self);\n+        ptr.offset(index)\n+    }\n }\n \n #[cfg(stage1)]\n@@ -1941,6 +1976,7 @@ pub trait ImmutableVector<'self, T> {\n     fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n }\n \n /// Extension methods for vectors\n@@ -2062,6 +2098,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[inline(always)]\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n+        let (ptr, _): (*T, uint) = transmute(*self);\n+        ptr.offset(index)\n+    }\n }\n \n pub trait ImmutableEqVector<T:Eq> {\n@@ -2113,6 +2157,7 @@ pub trait ImmutableCopyableVector<T> {\n     fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n \n /// Extension methods for vectors\n@@ -2149,6 +2194,12 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n+\n+    /// Returns the element at the given index, without doing bounds checking.\n+    #[inline(always)]\n+    unsafe fn unsafe_get(&self, index: uint) -> T {\n+        *self.unsafe_ref(index)\n+    }\n }\n \n pub trait OwnedVector<T> {\n@@ -2289,6 +2340,25 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+pub trait MutableVector<T> {\n+    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n+    unsafe fn unsafe_set(&self, index: uint, val: T);\n+}\n+\n+impl<'self,T> MutableVector<T> for &'self mut [T] {\n+    #[inline(always)]\n+    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n+        let pair_ptr: &(*mut T, uint) = transmute(self);\n+        let (ptr, _) = *pair_ptr;\n+        ptr.offset(index)\n+    }\n+\n+    #[inline(always)]\n+    unsafe fn unsafe_set(&self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n+    }\n+}\n+\n /**\n * Constructs a vector from an unsafe pointer to a buffer\n *\n@@ -2652,6 +2722,13 @@ impl<'self,A> iter::ExtendedIter<A> for &'self [A] {\n     }\n }\n \n+impl<'self,A> iter::ExtendedMutableIter<A> for &'self mut [A] {\n+    #[inline(always)]\n+    pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n+        eachi_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {"}, {"sha": "eb7965e1ac6dd32f6bb04effc80f4a0699711a60", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -188,8 +188,10 @@ pub mod write {\n         return false;\n     }\n \n-    pub fn run_passes(sess: Session, llmod: ModuleRef,\n-            output_type: output_type, output: &Path) {\n+    pub fn run_passes(sess: Session,\n+                      llmod: ModuleRef,\n+                      output_type: output_type,\n+                      output: &Path) {\n         unsafe {\n             let opts = sess.opts;\n             if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }"}, {"sha": "7ea1fe8015825e88fa4a41eaa51a03c0f3db062e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -172,10 +172,13 @@ pub enum compile_upto {\n \n // For continuing compilation after a parsed crate has been\n // modified\n-pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n-                    upto: compile_upto, outputs: Option<@OutputFilenames>,\n+#[fixed_stack_segment]\n+pub fn compile_rest(sess: Session,\n+                    cfg: ast::crate_cfg,\n+                    upto: compile_upto,\n+                    outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n-    -> (@ast::crate, Option<ty::ctxt>) {\n+                 -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let mut crate = curr.get();\n "}, {"sha": "0ab883d330d9d3f1d0da6924c8f31bd81acc544e", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 438, "deletions": 2, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -234,983 +234,1333 @@ pub mod llvm {\n     #[abi = \"cdecl\"]\n     pub extern {\n         /* Create and destroy contexts. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMContextCreate() -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGlobalContext() -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMContextDispose(C: ContextRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n                                            Name: *c_char,\n                                            SLen: c_uint)\n                                         -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n         /* Create and destroy modules. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n                                                     C: ContextRef)\n                                                  -> ModuleRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n \n         /** Target triple. See Module::getTargetTriple. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n \n         /** See Module::dump. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDumpModule(M: ModuleRef);\n \n         /** See Module::setModuleInlineAsm. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n \n         /** See llvm::LLVMTypeKind::getTypeID. */\n         pub unsafe fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n         /** See llvm::LLVMType::getContext. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n         /* Operations on integer types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIntTypeInContext(C: ContextRef,\n                                            NumBits: c_uint) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMInt1Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt8Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt16Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt32Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt64Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n         /* Operations on real types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMFloatType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDoubleType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMX86FP80Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMFP128Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128Type() -> TypeRef;\n \n         /* Operations on function types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMFunctionType(ReturnType: TypeRef,\n                                        ParamTypes: *TypeRef,\n                                        ParamCount: c_uint,\n                                        IsVarArg: Bool)\n                                     -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n         /* Operations on struct types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMStructTypeInContext(C: ContextRef,\n                                               ElementTypes: *TypeRef,\n                                               ElementCount: c_uint,\n                                               Packed: Bool) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMStructType(ElementTypes: *TypeRef,\n                                      ElementCount: c_uint,\n                                      Packed: Bool)\n                                   -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef)\n                                                -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetStructElementTypes(StructTy: TypeRef,\n                                             Dest: *mut TypeRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n         /* Operations on array, pointer, and vector types (sequence types) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMArrayType(ElementType: TypeRef,\n                          ElementCount: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPointerType(ElementType: TypeRef,\n                            AddressSpace: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMVectorType(ElementType: TypeRef,\n                           ElementCount: c_uint) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef)\n                                               -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMVoidType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMLabelType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMetadataType() -> TypeRef;\n \n         /* Operations on all values */\n+        #[fast_ffi]\n         pub unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMDumpValue(Val: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMReplaceAllUsesWith(OldVal: ValueRef,\n                                              NewVal: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetMetadata(Val: ValueRef,\n                                       KindID: c_uint,\n                                       Node: ValueRef);\n \n         /* Operations on Uses */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUser(U: UseRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n         /* Operations on Users */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetOperand(Val: ValueRef,\n                                      Index: c_uint,\n                                      Op: ValueRef);\n \n         /* Operations on constants of any type */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n         /* all zeroes */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n         /* only for int/vector */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsNull(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n         /* Operations on metadata */\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDStringInContext(C: ContextRef,\n                                         Str: *c_char,\n                                         SLen: c_uint)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDNodeInContext(C: ContextRef,\n                                       Vals: *ValueRef,\n                                       Count: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                        Val: ValueRef);\n \n         /* Operations on scalar constants */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInt(IntTy: TypeRef,\n                                N: c_ulonglong,\n                                SignExtend: Bool)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntOfString(IntTy: TypeRef,\n                                        Text: *c_char,\n                                        Radix: u8)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n                                                   Text: *c_char,\n                                                   SLen: c_uint,\n                                                   Radix: u8)\n                                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstRealOfString(RealTy: TypeRef,\n                                         Text: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n                                                    Text: *c_char,\n                                                    SLen: c_uint)\n                                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef)\n                                             -> c_ulonglong;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef)\n                                             -> c_longlong;\n \n \n         /* Operations on composite constants */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStringInContext(C: ContextRef,\n                                            Str: *c_char,\n                                            Length: c_uint,\n                                            DontNullTerminate: Bool)\n                                         -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStructInContext(C: ContextRef,\n                                                ConstantVals: *ValueRef,\n                                                Count: c_uint,\n                                                Packed: Bool) -> ValueRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMConstString(Str: *c_char,\n                                       Length: c_uint,\n                                       DontNullTerminate: Bool)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n                                      ConstantVals: *ValueRef,\n                                      Length: c_uint)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n                                       Count: c_uint,\n                                       Packed: Bool) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                                       Size: c_uint) -> ValueRef;\n \n         /* Constant expressions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n                                    RHSConstant: ValueRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWAdd(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFAdd(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n                                    RHSConstant: ValueRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n                                       RHSConstant: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n                                       RHSConstant: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFSub(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstMul(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWMul(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWMul(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFMul(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstUDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n                                      RHSConstant: ValueRef)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstURem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSRem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFRem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAnd(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstOr(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstXor(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstShl(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstLShr(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAShr(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstGEP(ConstantVal: ValueRef,\n                         ConstantIndices: *ValueRef,\n                         NumIndices: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n                                        ConstantIndices: *ValueRef,\n                                        NumIndices: c_uint)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstTrunc(ConstantVal: ValueRef,\n                                  ToType: TypeRef)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSExt(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstZExt(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPTrunc(ConstantVal: ValueRef,\n                                    ToType: TypeRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPExt(ConstantVal: ValueRef,\n                                  ToType: TypeRef)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstUIToFP(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSIToFP(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPToUI(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPToSI(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPtrToInt(ConstantVal: ValueRef,\n                                     ToType: TypeRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntToPtr(ConstantVal: ValueRef,\n                                     ToType: TypeRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstBitCast(ConstantVal: ValueRef,\n                                    ToType: TypeRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef,\n                                          ToType: TypeRef)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef,\n                                          ToType: TypeRef)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef,\n                                           ToType: TypeRef)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPointerCast(ConstantVal: ValueRef,\n                                        ToType: TypeRef)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntCast(ConstantVal: ValueRef,\n                                        ToType: TypeRef,\n                                        isSigned: Bool)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPCast(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSelect(ConstantCondition: ValueRef,\n                                       ConstantIfTrue: ValueRef,\n                                       ConstantIfFalse: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExtractElement(VectorConstant: ValueRef,\n                                    IndexConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInsertElement(VectorConstant: ValueRef,\n                                   ElementValueConstant: ValueRef,\n                                   IndexConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n                                   VectorBConstant: ValueRef,\n                                   MaskConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExtractValue(AggConstant: ValueRef,\n                                             IdxList: *c_uint,\n                                             NumIdx: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInsertValue(AggConstant: ValueRef,\n                                            ElementValueConstant: ValueRef,\n                                            IdxList: *c_uint,\n                                            NumIdx: c_uint)\n                                         -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                               Constraints: *c_char, HasSideEffects: Bool,\n                               IsAlignStack: Bool) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef)\n                                     -> ValueRef;\n \n \n \n         /* Operations on global variables, functions, and aliases (globals) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSection(Global: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n         /* Operations on global variables */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobal(M: ModuleRef,\n                                 Ty: TypeRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n                                               Ty: TypeRef,\n                                               Name: *c_char,\n                                               AddressSpace: c_uint)\n                                            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInitializer(GlobalVar: ValueRef,\n                                          ConstantVal: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetThreadLocal(GlobalVar: ValueRef,\n                                          IsThreadLocal: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetGlobalConstant(GlobalVar: ValueRef,\n                                             IsConstant: Bool);\n \n         /* Operations on aliases */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAlias(M: ModuleRef,\n                                    Ty: TypeRef,\n                                    Aliasee: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n \n         /* Operations on functions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunction(M: ModuleRef,\n                                   Name: *c_char,\n                                   FunctionTy: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNamedFunction(M: ModuleRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteFunction(Fn: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n                                    FunctionTy: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionAttr(Fn: ValueRef,\n-                                          PA: c_ulonglong,\n-                                          HighPA: c_ulonglong);\n+                                          PA: c_uint,\n+                                          HighPA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveFunctionAttr(Fn: ValueRef,\n                                              PA: c_ulonglong,\n                                              HighPA: c_ulonglong);\n \n         /* Operations on parameters */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n         /* Operations on basic blocks */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetBasicBlocks(Fn: ValueRef,\n                                          BasicBlocks: *ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextBasicBlock(BB: BasicBlockRef)\n                                          -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef)\n                                              -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAppendBasicBlockInContext(C: ContextRef,\n                                                     Fn: ValueRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertBasicBlockInContext(C: ContextRef,\n                                                     BB: BasicBlockRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n                                        Name: *c_char)\n                                     -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n                                        Name: *c_char)\n                                     -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n         /* Operations on instructions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionParent(Inst: ValueRef)\n                                             -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n         /* Operations on call sites */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddInstrAttribute(Instr: ValueRef,\n                                             index: c_uint,\n                                             IA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n                                                index: c_uint,\n                                                IA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n                                                  index: c_uint,\n                                                  align: c_uint);\n \n         /* Operations on call instructions (only) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n         /* Operations on phi nodes */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIncoming(PhiNode: ValueRef,\n                                       IncomingValues: *ValueRef,\n                                       IncomingBlocks: *BasicBlockRef,\n                                       Count: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIncomingValue(PhiNode: ValueRef,\n                                        Index: c_uint)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n                                 Index: c_uint) -> BasicBlockRef;\n \n         /* Instruction builders */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilder() -> BuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilder(Builder: BuilderRef,\n                                           Block: BasicBlockRef,\n                                           Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n                                                 Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n                                                Block: BasicBlockRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInsertBlock(Builder: BuilderRef)\n                                       -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertIntoBuilder(Builder: BuilderRef,\n                                             Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n                                                 Instr: ValueRef,\n                                                 Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n         /* Metadata */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetCurrentDebugLocation(Builder: BuilderRef,\n                                                   L: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetCurrentDebugLocation(Builder: BuilderRef)\n                                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstDebugLocation(Builder: BuilderRef,\n                                                Inst: ValueRef);\n \n         /* Terminators */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n                                  N: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCondBr(B: BuilderRef,\n                                   If: ValueRef,\n                                   Then: BasicBlockRef,\n                                   Else: BasicBlockRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef,\n                                       Else: BasicBlockRef, NumCases: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n                                NumDests: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInvoke(B: BuilderRef,\n                                       Fn: ValueRef,\n                                       Args: *ValueRef,\n                                       NumArgs: c_uint,\n                                       Then: BasicBlockRef,\n                                       Catch: BasicBlockRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLandingPad(B: BuilderRef,\n                                       Ty: TypeRef,\n                                       PersFn: ValueRef,\n                                       NumClauses: c_uint,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n         /* Add a case to the switch instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCase(Switch: ValueRef,\n                               OnVal: ValueRef,\n                               Dest: BasicBlockRef);\n \n         /* Add a destination to the indirectbr instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDestination(IndirectBr: ValueRef,\n                                          Dest: BasicBlockRef);\n \n         /* Add a clause to the landing pad instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddClause(LandingPad: ValueRef,\n                                     ClauseVal: ValueRef);\n \n         /* Set the cleanup on a landing pad instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n         /* Arithmetic */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAdd(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWAdd(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWAdd(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFAdd(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSub(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWSub(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWSub(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFSub(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildMul(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWMul(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWMul(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFMul(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExactSDiv(B: BuilderRef,\n                                          LHS: ValueRef,\n                                          RHS: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildURem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSRem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFRem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildShl(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLShr(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAShr(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAnd(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildOr(B: BuilderRef,\n                                   LHS: ValueRef,\n                                   RHS: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildXor(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBinOp(B: BuilderRef,\n                                  Op: Opcode,\n                                  LHS: ValueRef,\n                                  RHS: ValueRef,\n                                  Name: *c_char)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNeg(B: BuilderRef,\n                                V: ValueRef,\n                                Name: *c_char)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWNeg(B: BuilderRef,\n                                   V: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWNeg(B: BuilderRef,\n                                   V: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFNeg(B: BuilderRef,\n                                 V: ValueRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNot(B: BuilderRef,\n                                V: ValueRef,\n                                Name: *c_char)\n                             -> ValueRef;\n \n         /* Memory */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildMalloc(B: BuilderRef,\n                                       Ty: TypeRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildArrayMalloc(B: BuilderRef,\n                                            Ty: TypeRef,\n                                            Val: ValueRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAlloca(B: BuilderRef,\n                                   Ty: TypeRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildArrayAlloca(B: BuilderRef,\n                                            Ty: TypeRef,\n                                            Val: ValueRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFree(B: BuilderRef,\n                                     PointerVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLoad(B: BuilderRef,\n                                 PointerVal: ValueRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildStore(B: BuilderRef,\n                                      Val: ValueRef,\n                                      Ptr: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGEP(B: BuilderRef,\n                                Pointer: ValueRef,\n                                Indices: *ValueRef,\n                                NumIndices: c_uint,\n                                Name: *c_char)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                                 Indices: *ValueRef, NumIndices: c_uint,\n                                 Name: *c_char)\n            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildStructGEP(B: BuilderRef,\n                                      Pointer: ValueRef,\n                                      Idx: c_uint,\n                                      Name: *c_char)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGlobalString(B: BuilderRef,\n                                         Str: *c_char,\n                                         Name: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n                                            Str: *c_char,\n                                            Name: *c_char)\n                                         -> ValueRef;\n \n         /* Casts */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildTrunc(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildZExt(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSExt(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPToUI(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPToSI(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUIToFP(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSIToFP(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPTrunc(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPExt(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPtrToInt(B: BuilderRef,\n                                         Val: ValueRef,\n                                         DestTy: TypeRef,\n                                         Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIntToPtr(B: BuilderRef,\n                                         Val: ValueRef,\n                                         DestTy: TypeRef,\n                                         Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBitCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                          Val: ValueRef,\n                                          DestTy: TypeRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                          Val: ValueRef,\n                                          DestTy: TypeRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                           Val: ValueRef,\n                                           DestTy: TypeRef,\n                                           Name: *c_char)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n                          DestTy: TypeRef, Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPointerCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIntCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n \n         /* Comparisons */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                          RHS: ValueRef, Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                          RHS: ValueRef, Name: *c_char) -> ValueRef;\n \n         /* Miscellaneous instructions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPhi(B: BuilderRef,\n                                    Ty: TypeRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCall(B: BuilderRef,\n                                     Fn: ValueRef,\n                                     Args: *ValueRef,\n                                     NumArgs: c_uint,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSelect(B: BuilderRef,\n                                       If: ValueRef,\n                                       Then: ValueRef,\n                                       Else: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildVAArg(B: BuilderRef,\n                                      list: ValueRef,\n                                      Ty: TypeRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExtractElement(B: BuilderRef,\n                                           VecVal: ValueRef,\n                                           Index: ValueRef,\n                                           Name: *c_char)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInsertElement(B: BuilderRef,\n                                          VecVal: ValueRef,\n                                          EltVal: ValueRef,\n                                          Index: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildShuffleVector(B: BuilderRef,\n                                          V1: ValueRef,\n                                          V2: ValueRef,\n                                          Mask: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExtractValue(B: BuilderRef,\n                                         AggVal: ValueRef,\n                                         Index: c_uint,\n                                         Name: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInsertValue(B: BuilderRef,\n                                        AggVal: ValueRef,\n                                        EltVal: ValueRef,\n                                        Index: c_uint,\n                                        Name: *c_char)\n                                     -> ValueRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIsNull(B: BuilderRef,\n                                       Val: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIsNotNull(B: BuilderRef,\n                                          Val: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPtrDiff(B: BuilderRef,\n                                        LHS: ValueRef,\n                                        RHS: ValueRef,\n@@ -1225,155 +1575,227 @@ pub mod llvm {\n                               ++Order: AtomicOrdering) -> ValueRef;\n \n         /* Selected entries from the downcasts. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n         /** Writes a module to the specified path. Returns 0 on success. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMWriteBitcodeToFile(M: ModuleRef,\n                                              Path: *c_char) -> c_int;\n \n         /** Creates target data from a target layout string. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateTargetData(StringRep: *c_char)\n                                         -> TargetDataRef;\n         /** Adds the target data to the given pass manager. The pass manager\n             references the target data only weakly. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTargetData(TD: TargetDataRef,\n                                         PM: PassManagerRef);\n         /** Number of bytes clobbered when doing a Store to *T. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n             -> c_ulonglong;\n \n         /** Number of bytes clobbered when doing a Store to *T. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n             -> c_ulonglong;\n \n         /** Distance between successive elements in an array of T.\n         Includes ABI padding. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef)\n                                      -> c_uint;\n \n         /** Returns the preferred alignment of a type. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n                                         Ty: TypeRef) -> c_uint;\n         /** Returns the minimum alignment of a type. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                                   Ty: TypeRef) -> c_uint;\n         /**\n          * Returns the minimum alignment of a type when part of a call frame.\n          */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n                                                    Ty: TypeRef)\n                                                 -> c_uint;\n \n         /** Disposes target data. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n         /** Creates a pass manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreatePassManager() -> PassManagerRef;\n         /** Disposes a pass manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposePassManager(PM: PassManagerRef);\n         /** Runs a pass manager on a module. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRunPassManager(PM: PassManagerRef,\n                                          M: ModuleRef) -> Bool;\n \n         /** Adds a verification pass. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddReassociatePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLICMPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGVNPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddSCCPPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCorrelatedValuePropagationPass(PM:\n                                                             PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderDispose(PMB:\n                                                     PassManagerBuilderRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetOptLevel(\n             PMB: PassManagerBuilderRef, OptimizationLevel: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetSizeLevel(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n             (PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderUseInlinerWithThreshold\n             (PMB: PassManagerBuilderRef, threshold: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderPopulateModulePassManager\n             (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderPopulateFunctionPassManager\n             (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n         /** Destroys a memory buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n \n \n         /* Stuff that's in rustllvm/ because it's not upstream yet. */\n \n         /** Opens an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef)\n                                         -> ObjectFileRef;\n         /** Closes an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n         /** Enumerates the sections in an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSections(ObjFile: ObjectFileRef)\n                                    -> SectionIteratorRef;\n         /** Destroys a section iterator. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n         /** Returns true if the section iterator is at the end of the section\n             list: */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                       SI: SectionIteratorRef) -> Bool;\n         /** Moves the section iterator to point to the next section. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n         /** Returns the current section name. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n         /** Returns the current section size. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionSize(SI: SectionIteratorRef)\n                                       -> c_ulonglong;\n         /** Returns the current section contents as a string buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionContents(SI: SectionIteratorRef)\n                                           -> *c_char;\n \n         /** Reads the given file and returns it as a memory buffer. Use\n             LLVMDisposeMemoryBuffer() to get rid of it. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustCreateMemoryBufferWithContentsOfFile(\n                 Path: *c_char)\n              -> MemoryBufferRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMRustWriteOutputFile(PM: PassManagerRef,\n                                               M: ModuleRef,\n                                               Triple: *c_char,\n@@ -1387,58 +1809,72 @@ pub mod llvm {\n \n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustGetLastError() -> *c_char;\n \n         /** Prepare the JIT. Returns a memory manager that can load crates. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n \n         /** Load a crate into the memory manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustLoadCrate(MM: *(),\n                                         Filename: *c_char)\n                                      -> bool;\n \n         /** Execute the JIT engine. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustExecuteJIT(MM: *(),\n                               PM: PassManagerRef,\n                               M: ModuleRef,\n                               OptLevel: c_int,\n                               EnableSegmentedStacks: bool) -> *();\n \n         /** Parses the bitcode in the given memory buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef)\n                                         -> ModuleRef;\n \n         /** Parses LLVM asm in the given file */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char)\n                                              -> ModuleRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMRustAddPrintModulePass(PM: PassManagerRef,\n                                                  M: ModuleRef,\n                                                  Output: *c_char);\n \n         /** Turn on LLVM pass-timing. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustEnableTimePasses();\n \n         /// Print the pass timings since static dtors aren't picking them up.\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustPrintPassTimings();\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char)\n                                          -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMStructSetBody(StructTy: TypeRef,\n                                         ElementTypes: *TypeRef,\n                                         ElementCount: c_uint,\n                                         Packed: Bool);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNamedStruct(S: TypeRef,\n                                            ConstantVals: *ValueRef,\n                                            Count: c_uint)\n                                         -> ValueRef;\n \n         /** Enables LLVM debug output. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetDebug(Enabled: c_int);\n \n         /** Prepares inline assembly. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                                     Constraints: *c_char, SideEffects: Bool,\n                                     AlignStack: Bool, Dialect: c_uint)"}, {"sha": "248d847f89dae2db6db8f584a90ec958453b57e2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -37,7 +37,7 @@ use std::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token::{ident_interner, special_idents};\n+use syntax::parse::token::{StringRef, ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n@@ -249,12 +249,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n \n pub fn item_type(item_id: ast::def_id, item: ebml::Doc,\n                  tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let t = doc_type(item, tcx, cdata);\n-    if family_names_type(item_family(item)) {\n-        ty::mk_with_id(tcx, t, item_id)\n-    } else {\n-        t\n-    }\n+    doc_type(item, tcx, cdata)\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::TraitRef {\n@@ -327,7 +322,13 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n \n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n-    intr.intern(@str::from_bytes(reader::doc_data(name)))\n+    do reader::with_doc_data(name) |data| {\n+        let string = str::from_bytes_slice(data);\n+        match intr.find_equiv(&StringRef(string)) {\n+            None => intr.intern(@(string.to_owned())),\n+            Some(val) => val,\n+        }\n+    }\n }\n \n fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)"}, {"sha": "709f1d4fc35d78df05e0f64dbbdef56cf0466e32", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -381,9 +381,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let def = parse_def(st, TypeWithId, conv);\n+        let _ = parse_def(st, TypeWithId, conv);\n         let inner = parse_ty(st, conv);\n-        ty::mk_with_id(st.tcx, inner, def)\n+        inner\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {"}, {"sha": "f6338f83ca61176f06ef39a15e88f177d0dc9f58", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -78,19 +78,6 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           Some(a) => { w.write_str(*a.s); return; }\n           None => {\n             let pos = w.tell();\n-            match ty::type_def_id(t) {\n-              Some(def_id) => {\n-                // Do not emit node ids that map to unexported names.  Those\n-                // are not helpful.\n-                if def_id.crate != local_crate ||\n-                    (cx.reachable)(def_id.node) {\n-                    w.write_char('\"');\n-                    w.write_str((cx.ds)(def_id));\n-                    w.write_char('|');\n-                }\n-              }\n-              _ => {}\n-            }\n             enc_sty(w, cx, /*bad*/copy ty::get(t).sty);\n             let end = w.tell();\n             let len = end - pos;"}, {"sha": "c4c7eb0b8e726f3f2b01766cb9d9d7bc6af9e6f8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 267, "deletions": 125, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -143,13 +143,17 @@ pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n     ccx.stats.fn_times.push((name, elapsed));\n }\n \n-pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n-               llty: TypeRef) -> ValueRef {\n+pub fn decl_fn(llmod: ModuleRef,\n+               name: &str,\n+               cc: lib::llvm::CallConv,\n+               llty: TypeRef)\n+               -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n         }\n     });\n+\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n@@ -406,24 +410,24 @@ pub fn set_optimize_for_size(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n                                   lib::llvm::OptimizeForSizeAttribute\n-                                  as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                    as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_no_inline(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::NoInlineAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::NoInlineAttribute as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_no_unwind(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::NoUnwindAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::NoUnwindAttribute as c_uint,\n+                                  0);\n     }\n }\n \n@@ -432,15 +436,16 @@ pub fn set_no_unwind(f: ValueRef) {\n pub fn set_uwtable(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::UWTableAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::UWTableAttribute as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_inline_hint(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n-                                  as c_ulonglong, 0u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::InlineHintAttribute as c_uint,\n+                                  0);\n     }\n }\n \n@@ -456,14 +461,15 @@ pub fn set_inline_hint_if_appr(attrs: &[ast::attribute],\n \n pub fn set_always_inline(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n-                                  as c_ulonglong, 0u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::AlwaysInlineAttribute as c_uint,\n+                                  0);\n     }\n }\n \n-pub fn set_custom_stack_growth_fn(f: ValueRef) {\n+pub fn set_fixed_stack_segment(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f, 0, 1 << (39 - 32));\n     }\n }\n \n@@ -483,29 +489,42 @@ pub fn note_unique_llvm_symbol(ccx: @CrateContext, sym: @~str) {\n }\n \n \n-pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n-                    parent_id: ast::def_id, substs: &[ty::t])\n-   -> ValueRef {\n+pub fn get_res_dtor(ccx: @CrateContext,\n+                    did: ast::def_id,\n+                    parent_id: ast::def_id,\n+                    substs: &[ty::t])\n+                 -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n-        } else { did };\n+        } else {\n+            did\n+        };\n         assert!(did.crate == ast::local_crate);\n-        let (val, _) =\n-            monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx,\n+                                                    did,\n+                                                    substs,\n+                                                    None,\n+                                                    None,\n+                                                    None);\n \n         val\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n         let name = csearch::get_symbol(ccx.sess.cstore, did);\n-        let class_ty = ty::subst_tps(tcx, substs, None,\n-                          ty::lookup_item_type(tcx, parent_id).ty);\n+        let class_ty = ty::subst_tps(tcx,\n+                                     substs,\n+                                     None,\n+                                     ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n         let name = name.to_managed(); // :-(\n-        get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n+        get_extern_fn(ccx.externs,\n+                      ccx.llmod,\n+                      name,\n+                      lib::llvm::CCallConv,\n                       llty)\n     }\n }\n@@ -809,9 +828,12 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n+pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef])\n+           -> (ValueRef, block) {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n-    if bcx.unreachable { return bcx; }\n+    if bcx.unreachable {\n+        return (C_null(T_i8()), bcx);\n+    }\n \n     match bcx.node_info {\n         None => debug!(\"invoke at ???\"),\n@@ -831,8 +853,12 @@ pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n             }\n         }\n         let normal_bcx = sub_block(bcx, ~\"normal return\");\n-        Invoke(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n-        return normal_bcx;\n+        let llresult = Invoke(bcx,\n+                              llfn,\n+                              llargs,\n+                              normal_bcx.llbb,\n+                              get_landing_pad(bcx));\n+        return (llresult, normal_bcx);\n     } else {\n         unsafe {\n             debug!(\"calling %x at %x\",\n@@ -842,8 +868,8 @@ pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n                 debug!(\"arg: %x\", ::core::cast::transmute(llarg));\n             }\n         }\n-        Call(bcx, llfn, llargs);\n-        return bcx;\n+        let llresult = Call(bcx, llfn, llargs);\n+        return (llresult, bcx);\n     }\n }\n \n@@ -1574,6 +1600,18 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n     }\n }\n \n+// Creates and returns space for, or returns the argument representing, the\n+// slot where the return value of the function must go.\n+pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n+    unsafe {\n+        if !ty::type_is_immediate(output_type) {\n+            llvm::LLVMGetParam(fcx.llfn, 0)\n+        } else {\n+            let lloutputtype = type_of::type_of(*fcx.ccx, output_type);\n+            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype)\n+        }\n+    }\n+}\n \n // NB: must keep 4 fns in sync:\n //\n@@ -1585,10 +1623,11 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         +path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n+                        output_type: ty::t,\n                         impl_id: Option<ast::def_id>,\n                         param_substs: Option<@param_substs>,\n-                        sp: Option<span>) -> fn_ctxt\n-{\n+                        sp: Option<span>)\n+                     -> fn_ctxt {\n     for param_substs.each |p| { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n@@ -1599,16 +1638,26 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n            param_substs.repr(ccx.tcx));\n \n     let llbbs = mk_standard_basic_blocks(llfndecl);\n-    return @mut fn_ctxt_ {\n+\n+    let substd_output_type = match param_substs {\n+        None => output_type,\n+        Some(substs) => {\n+            ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n+        }\n+    };\n+    let is_immediate = ty::type_is_immediate(substd_output_type);\n+\n+    let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe { llvm::LLVMGetParam(llfndecl, 1u as c_uint) },\n-          llretptr: unsafe { llvm::LLVMGetParam(llfndecl, 0u as c_uint) },\n+          llretptr: None,\n           llstaticallocas: llbbs.sa,\n           llloadenv: None,\n           llreturn: llbbs.rt,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n+          has_immediate_return_value: is_immediate,\n           llargs: @mut HashMap::new(),\n           lllocals: @mut HashMap::new(),\n           llupvars: @mut HashMap::new(),\n@@ -1619,14 +1668,18 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           path: path,\n           ccx: @ccx\n     };\n+\n+    fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+    fcx\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n                    +path: path,\n                    llfndecl: ValueRef,\n+                   output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, None, sp);\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1645,7 +1698,8 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n                                  ty_self: self_arg,\n-                                 args: &[ast::arg]) -> ~[ValueRef] {\n+                                 args: &[ast::arg])\n+                              -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n \n     match ty_self {\n@@ -1751,8 +1805,19 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n+    build_return_block(fcx);\n+}\n+\n+// Builds the return block for a function.\n+pub fn build_return_block(fcx: fn_ctxt) {\n     let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-    RetVoid(ret_cx);\n+\n+    // Return the value if this function immediate; otherwise, return void.\n+    if fcx.has_immediate_return_value {\n+        Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n+    } else {\n+        RetVoid(ret_cx)\n+    }\n }\n \n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n@@ -1782,6 +1847,8 @@ pub fn trans_closure(ccx: @CrateContext,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n+                     attributes: &[ast::attribute],\n+                     output_type: ty::t,\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n@@ -1792,10 +1859,21 @@ pub fn trans_closure(ccx: @CrateContext,\n            param_substs.repr(ccx.tcx));\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n-                                  Some(body.span));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self,\n-                                               decl.inputs);\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               llfndecl,\n+                               id,\n+                               output_type,\n+                               impl_id,\n+                               param_substs,\n+                               Some(body.span));\n+    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n+\n+    // Set the fixed stack segment flag if necessary.\n+    if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n+        set_no_inline(fcx.llfn);\n+        set_fixed_stack_segment(fcx.llfn);\n+    }\n \n     // Set GC for function.\n     if ccx.sess.opts.gc {\n@@ -1828,7 +1906,8 @@ pub fn trans_closure(ccx: @CrateContext,\n     {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n-        bcx = controlflow::trans_block(bcx, body, expr::SaveIn(fcx.llretptr));\n+        let dest = expr::SaveIn(fcx.llretptr.get());\n+        bcx = controlflow::trans_block(bcx, body, dest);\n     }\n \n     finish(bcx);\n@@ -1848,7 +1927,8 @@ pub fn trans_fn(ccx: @CrateContext,\n                 ty_self: self_arg,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n-                impl_id: Option<ast::def_id>) {\n+                impl_id: Option<ast::def_id>,\n+                attrs: &[ast::attribute]) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { time::Timespec::new(0, 0) };\n@@ -1858,8 +1938,18 @@ pub fn trans_fn(ccx: @CrateContext,\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);\n-    trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  param_substs, id, impl_id,\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n+    trans_closure(ccx,\n+                  path,\n+                  decl,\n+                  body,\n+                  llfndecl,\n+                  ty_self,\n+                  param_substs,\n+                  id,\n+                  impl_id,\n+                  attrs,\n+                  output_type,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo\n                           && fcx_has_nonzero_span(fcx) {\n@@ -1894,26 +1984,39 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n             id: varg.id,\n         }\n     };\n-    let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n-                               param_substs, None);\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n+\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => { copy substs.tys }\n         None => ~[]\n     };\n+    let enum_ty = ty::subst_tps(ccx.tcx,\n+                                ty_param_substs,\n+                                None,\n+                                ty::node_id_to_type(ccx.tcx, enum_id));\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               ~[],\n+                               llfndecl,\n+                               variant.node.id,\n+                               enum_ty,\n+                               None,\n+                               param_substs,\n+                               None);\n+\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     // XXX is there a better way to reconstruct the ty::t?\n-    let enum_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n-                                ty::node_id_to_type(ccx.tcx, enum_id));\n     let repr = adt::represent_type(ccx, enum_ty);\n \n-    adt::trans_start_init(bcx, repr, fcx.llretptr, disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n     for vec::eachi(args) |i, va| {\n-        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr,\n-                                             disr, i);\n+        let lldestptr = adt::trans_field_ptr(bcx,\n+                                             repr,\n+                                             fcx.llretptr.get(),\n+                                             disr,\n+                                             i);\n \n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n@@ -1951,10 +2054,25 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n         }\n     };\n \n+    // XXX is there a better way to reconstruct the ty::t?\n+    let ty_param_substs = match param_substs {\n+        Some(ref substs) => { copy substs.tys }\n+        None => ~[]\n+    };\n+    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n+                                ty::node_id_to_type(ccx.tcx, ctor_id));\n+    let tup_ty = match ty::get(ctor_ty).sty {\n+        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n+                                return type %s\",\n+                               ty_to_str(ccx.tcx, ctor_ty)))\n+    };\n+\n     let fcx = new_fn_ctxt_w_id(ccx,\n                                ~[],\n                                llfndecl,\n                                ctor_id,\n+                               tup_ty,\n                                None,\n                                param_substs,\n                                None);\n@@ -1966,23 +2084,14 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, ctor_id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n-    // XXX is there a better way to reconstruct the ty::t?\n-    let ty_param_substs = match param_substs {\n-        Some(ref substs) => { copy substs.tys }\n-        None => ~[]\n-    };\n-    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n-                                ty::node_id_to_type(ccx.tcx, ctor_id));\n-    let tup_ty = match ty::get(ctor_ty).sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n-                                return type %s\",\n-                               ty_to_str(ccx.tcx, ctor_ty)))\n-    };\n     let repr = adt::represent_type(ccx, tup_ty);\n \n     for fields.eachi |i, field| {\n-        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr, 0, i);\n+        let lldestptr = adt::trans_field_ptr(bcx,\n+                                             repr,\n+                                             fcx.llretptr.get(),\n+                                             0,\n+                                             i);\n         let llarg = match *fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n@@ -2032,8 +2141,16 @@ pub fn trans_struct_dtor(ccx: @CrateContext,\n   }\n   /* Translate the dtor body */\n   let decl = ast_util::dtor_dec();\n-  trans_fn(ccx, path, &decl, body, lldecl,\n-           impl_self(class_ty), psubsts, dtor_id, None);\n+  trans_fn(ccx,\n+           path,\n+           &decl,\n+           body,\n+           lldecl,\n+           impl_self(class_ty),\n+           psubsts,\n+           dtor_id,\n+           None,\n+           []);\n   lldecl\n }\n \n@@ -2074,15 +2191,24 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n-                                     vec::append(\n-                                         /*bad*/copy *path,\n-                                         ~[path_name(item.ident)]),\n-                                      decl, body, llfndecl, item.id);\n+                                      vec::append(/*bad*/copy *path,\n+                                                  ~[path_name(item.ident)]),\n+                                      decl,\n+                                      body,\n+                                      llfndecl,\n+                                      item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n-                     decl, body, llfndecl, no_self, None, item.id, None);\n+                     decl,\n+                     body,\n+                     llfndecl,\n+                     no_self,\n+                     None,\n+                     item.id,\n+                     None,\n+                     item.attrs);\n         } else {\n             for body.node.stmts.each |stmt| {\n                 match stmt.node {\n@@ -2187,7 +2313,7 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n                           llfty: TypeRef)\n-                       -> ValueRef {\n+                          -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n@@ -2207,7 +2333,9 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n                      (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n-    if is_entry { create_entry_wrapper(ccx, sp, llfn); }\n+    if is_entry {\n+        create_entry_wrapper(ccx, sp, llfn);\n+    }\n     llfn\n }\n \n@@ -2236,23 +2364,26 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, None);\n+        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, nt, None);\n \n         let bcx = top_scope_block(fcx, None);\n         let lltop = bcx.llbb;\n \n         // Call main.\n-        let lloutputarg = unsafe { llvm::LLVMGetParam(llfdecl, 0 as c_uint) };\n+        let lloutputarg = C_null(T_ptr(T_i8()));\n         let llenvarg = unsafe { llvm::LLVMGetParam(llfdecl, 1 as c_uint) };\n         let mut args = ~[lloutputarg, llenvarg];\n-        Call(bcx, main_llfn, args);\n+        let llresult = Call(bcx, main_llfn, args);\n+        Store(bcx, llresult, fcx.llretptr.get());\n \n         build_return(bcx);\n         finish_fn(fcx, lltop);\n         return llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @CrateContext, rust_main: ValueRef, use_start_lang_item:bool) {\n+    fn create_entry_fn(ccx: @CrateContext,\n+                       rust_main: ValueRef,\n+                       use_start_lang_item: bool) {\n         let llfty = T_fn(~[ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n@@ -2273,58 +2404,70 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         let bld = ccx.builder.B;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n-        }\n-\n-        let retptr = unsafe {\n-            llvm::LLVMBuildAlloca(bld, ccx.int_type, noname())\n-        };\n-\n-        let crate_map = ccx.crate_map;\n-        let opaque_crate_map = unsafe {llvm::LLVMBuildPointerCast(\n-                bld, crate_map, T_ptr(T_i8()), noname())};\n \n-        let (start_fn, args) = if use_start_lang_item {\n+            let crate_map = ccx.crate_map;\n             let start_def_id = ccx.tcx.lang_items.start_fn();\n             let start_fn = if start_def_id.crate == ast::local_crate {\n                 ccx.sess.bug(~\"start lang item is never in the local crate\")\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n-                        start_def_id).ty;\n+                                                      start_def_id).ty;\n                 trans_external_path(ccx, start_def_id, start_fn_type)\n             };\n \n-            let args = unsafe {\n-                let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                        bld, rust_main, T_ptr(T_i8()), noname());\n-\n-                ~[\n-                    retptr,\n-                    C_null(T_opaque_box_ptr(ccx)),\n-                    opaque_rust_main,\n-                    llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                    llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                    opaque_crate_map\n-                 ]\n-            };\n-            (start_fn, args)\n-        } else {\n-            debug!(\"using user-defined start fn\");\n-            let args = unsafe {\n-                ~[ retptr,\n-                   C_null(T_opaque_box_ptr(ccx)),\n-                   llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                   llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                   opaque_crate_map\n-                ]\n-            };\n+            let retptr = llvm::LLVMBuildAlloca(bld, T_i8(), noname());\n \n-            (rust_main, args)\n-        };\n+            let crate_map = ccx.crate_map;\n+            let opaque_crate_map = llvm::LLVMBuildPointerCast(bld,\n+                                                              crate_map,\n+                                                              T_ptr(T_i8()),\n+                                                              noname());\n \n-        unsafe {\n-            llvm::LLVMBuildCall(bld, start_fn, vec::raw::to_ptr(args),\n-                                args.len() as c_uint, noname());\n-            let result = llvm::LLVMBuildLoad(bld, retptr, noname());\n+            let (start_fn, args) = if use_start_lang_item {\n+                let start_def_id = ccx.tcx.lang_items.start_fn();\n+                let start_fn = if start_def_id.crate == ast::local_crate {\n+                    ccx.sess.bug(~\"start lang item is never in the local \\\n+                                   crate\")\n+                } else {\n+                    let start_fn_type = csearch::get_type(ccx.tcx,\n+                            start_def_id).ty;\n+                    trans_external_path(ccx, start_def_id, start_fn_type)\n+                };\n+\n+                let args = {\n+                    let opaque_rust_main = llvm::LLVMBuildPointerCast(\n+                            bld, rust_main, T_ptr(T_i8()), noname());\n+\n+                    ~[\n+                        retptr,\n+                        C_null(T_opaque_box_ptr(ccx)),\n+                        opaque_rust_main,\n+                        llvm::LLVMGetParam(llfn, 0),\n+                        llvm::LLVMGetParam(llfn, 1),\n+                        opaque_crate_map\n+                     ]\n+                };\n+                (start_fn, args)\n+            } else {\n+                debug!(\"using user-defined start fn\");\n+                let args = {\n+                    ~[\n+                        retptr,\n+                        C_null(T_opaque_box_ptr(ccx)),\n+                        llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                        llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                        opaque_crate_map\n+                    ]\n+                };\n+\n+                (rust_main, args)\n+            };\n+\n+            let result = llvm::LLVMBuildCall(bld,\n+                                             start_fn,\n+                                             &args[0],\n+                                             args.len() as c_uint,\n+                                             noname());\n             llvm::LLVMBuildRet(bld, result);\n         }\n     }\n@@ -2395,7 +2538,6 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     match ccx.item_vals.find(&id) {\n       Some(&v) => v,\n       None => {\n-\n         let mut exprt = false;\n         let val = match *ccx.tcx.items.get(&id) {\n           ast_map::node_item(i, pth) => {\n@@ -2487,10 +2629,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             assert!(!ty::type_has_params(class_ty));\n             let lldty = unsafe {\n                 T_fn(~[\n-                    T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n+                    T_ptr(T_i8()),\n                     T_ptr(type_of(ccx, class_ty))\n                 ],\n-                llvm::LLVMVoidType())\n+                T_nil())\n             };\n             let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n "}, {"sha": "fe2461632ad76bddb41294efbf32b329a6da8cfd", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -181,9 +181,15 @@ pub fn noname() -> *libc::c_char {\n     }\n }\n \n-pub fn Invoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n-              Then: BasicBlockRef, Catch: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+pub fn Invoke(cx: block,\n+              Fn: ValueRef,\n+              Args: &[ValueRef],\n+              Then: BasicBlockRef,\n+              Catch: BasicBlockRef)\n+           -> ValueRef {\n+    if cx.unreachable {\n+        return C_null(T_i8());\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n@@ -193,9 +199,13 @@ pub fn Invoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                         ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n-                              Args.len() as c_uint, Then, Catch,\n-                              noname());\n+        llvm::LLVMBuildInvoke(B(cx),\n+                              Fn,\n+                              vec::raw::to_ptr(Args),\n+                              Args.len() as c_uint,\n+                              Then,\n+                              Catch,\n+                              noname())\n     }\n }\n "}, {"sha": "ed028d14bd65f05476b2ebc2dd85e57430b0aa48", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -92,16 +92,19 @@ pub impl FnType {\n         return llargvals;\n     }\n \n-    fn build_shim_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], ret_def: bool,\n-                      llargbundle: ValueRef, llretval: ValueRef) {\n+    fn build_shim_ret(&self,\n+                      bcx: block,\n+                      arg_tys: &[TypeRef],\n+                      ret_def: bool,\n+                      llargbundle: ValueRef,\n+                      llretval: ValueRef) {\n         for vec::eachi(self.attrs) |i, a| {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n-                        llvm::LLVMAddInstrAttribute(\n-                            llretval, (i + 1u) as c_uint,\n-                                        attr as c_uint);\n+                        llvm::LLVMAddInstrAttribute(llretval,\n+                                                    (i + 1u) as c_uint,\n+                                                    attr as c_uint);\n                     }\n                 }\n                 _ => ()\n@@ -125,8 +128,11 @@ pub impl FnType {\n         };\n     }\n \n-    fn build_wrap_args(&self, bcx: block, ret_ty: TypeRef,\n-                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n+    fn build_wrap_args(&self,\n+                       bcx: block,\n+                       ret_ty: TypeRef,\n+                       llwrapfn: ValueRef,\n+                       llargbundle: ValueRef) {\n         let mut atys = /*bad*/copy self.arg_tys;\n         let mut attrs = /*bad*/copy self.attrs;\n         let mut j = 0u;\n@@ -161,22 +167,27 @@ pub impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    fn build_wrap_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], llargbundle: ValueRef) {\n+    fn build_wrap_ret(&self,\n+                      bcx: block,\n+                      arg_tys: &[TypeRef],\n+                      llargbundle: ValueRef) {\n         unsafe {\n             if llvm::LLVMGetTypeKind(self.ret_ty.ty) == Void {\n-                RetVoid(bcx);\n                 return;\n             }\n         }\n-        let n = vec::len(arg_tys);\n-        let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+\n+        let llretval = load_inbounds(bcx, llargbundle, ~[ 0, arg_tys.len() ]);\n         let llretval = if self.ret_ty.cast {\n             let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n             Load(bcx, retptr)\n         } else {\n             Load(bcx, llretval)\n         };\n-        Ret(bcx, llretval);\n+        let llretptr = BitCast(bcx,\n+                               bcx.fcx.llretptr.get(),\n+                               T_ptr(self.ret_ty.ty));\n+        Store(bcx, llretval, llretptr);\n     }\n }\n+"}, {"sha": "88d185740298f2c3980e3f1ebe5145d1439e868e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -314,19 +314,24 @@ pub fn trans_call(in_cx: block,\n                   args: CallArgs,\n                   id: ast::node_id,\n                   dest: expr::Dest)\n-               -> block {\n+                  -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n-    trans_call_inner(\n-        in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n-        |cx| trans(cx, f), args, dest, DontAutorefArg)\n+    trans_call_inner(in_cx,\n+                     call_ex.info(),\n+                     expr_ty(in_cx, f),\n+                     node_id_type(in_cx, id),\n+                     |cx| trans(cx, f),\n+                     args,\n+                     dest,\n+                     DontAutorefArg)\n }\n \n pub fn trans_method_call(in_cx: block,\n                          call_ex: @ast::expr,\n                          rcvr: @ast::expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                      -> block {\n+                         -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n            call_ex.repr(in_cx.tcx()),\n@@ -439,15 +444,15 @@ pub fn body_contains_ret(body: &ast::blk) -> bool {\n }\n \n // See [Note-arg-mode]\n-pub fn trans_call_inner(\n-    ++in_cx: block,\n-    call_info: Option<NodeInfo>,\n-    fn_expr_ty: ty::t,\n-    ret_ty: ty::t,\n-    get_callee: &fn(block) -> Callee,\n-    args: CallArgs,\n-    dest: expr::Dest,\n-    autoref_arg: AutorefArg) -> block {\n+pub fn trans_call_inner(++in_cx: block,\n+                        call_info: Option<NodeInfo>,\n+                        fn_expr_ty: ty::t,\n+                        ret_ty: ty::t,\n+                        get_callee: &fn(block) -> Callee,\n+                        args: CallArgs,\n+                        dest: expr::Dest,\n+                        autoref_arg: AutorefArg)\n+                        -> block {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n@@ -500,7 +505,15 @@ pub fn trans_call_inner(\n         let llretslot = trans_ret_slot(bcx, fn_expr_ty, dest);\n \n         let mut llargs = ~[];\n-        llargs.push(llretslot);\n+\n+        if ty::type_is_immediate(ret_ty) {\n+            unsafe {\n+                llargs.push(llvm::LLVMGetUndef(T_ptr(T_i8())));\n+            }\n+        } else {\n+            llargs.push(llretslot);\n+        }\n+\n         llargs.push(llenv);\n         bcx = trans_args(bcx, args, fn_expr_ty,\n                          ret_flag, autoref_arg, &mut llargs);\n@@ -527,25 +540,42 @@ pub fn trans_call_inner(\n         // If the block is terminated, then one or more of the args\n         // has type _|_. Since that means it diverges, the code for\n         // the call itself is unreachable.\n-        bcx = base::invoke(bcx, llfn, llargs);\n-        match dest { // drop the value if it is not being saved.\n+        let (llresult, new_bcx) = base::invoke(bcx, llfn, llargs);\n+        bcx = new_bcx;\n+\n+        match dest {\n             expr::Ignore => {\n+                // drop the value if it is not being saved.\n                 unsafe {\n                     if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                        if ty::type_is_immediate(ret_ty) {\n+                            let llscratchptr = alloc_ty(bcx, ret_ty);\n+                            Store(bcx, llresult, llscratchptr);\n+                            bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n+                        } else {\n+                            bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                        }\n                     }\n                 }\n             }\n-            expr::SaveIn(_) => { }\n+            expr::SaveIn(lldest) => {\n+                // If this is an immediate, store into the result location.\n+                // (If this was not an immediate, the result will already be\n+                // directly written into the output slot.)\n+                if ty::type_is_immediate(ret_ty) {\n+                    Store(bcx, llresult, lldest);\n+                }\n+            }\n         }\n+\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n             let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 for (copy bcx.fcx.loop_ret).each |&(flagptr, _)| {\n                     Store(bcx, C_bool(true), flagptr);\n-                    Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+                    Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                 }\n                 base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n                 Unreachable(bcx);\n@@ -562,11 +592,10 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(+bcx: block,\n-                      +fn_ty: ty::t,\n-                      +dest: expr::Dest) -> ValueRef\n-{\n+pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n+                      -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n+\n     match dest {\n         expr::SaveIn(dst) => dst,\n         expr::Ignore => {"}, {"sha": "cb815506c39d20c13c479a071ebfa38156067991", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -299,7 +299,7 @@ pub fn build_closure(bcx0: block,\n         // the right thing):\n         let ret_true = match bcx.fcx.loop_ret {\n             Some((_, retptr)) => retptr,\n-            None => bcx.fcx.llretptr\n+            None => bcx.fcx.llretptr.get()\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n@@ -367,8 +367,7 @@ pub fn trans_expr_fn(bcx: block,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n                      is_loop_body: Option<Option<ValueRef>>,\n-                     dest: expr::Dest) -> block\n-{\n+                     dest: expr::Dest) -> block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -400,7 +399,9 @@ pub fn trans_expr_fn(bcx: block,\n \n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, outer_id);\n+\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n+\n     let sub_path = vec::append_one(/*bad*/copy bcx.fcx.path,\n                                    path_name(special_idents::anon));\n     // XXX: Bad copy.\n@@ -409,21 +410,46 @@ pub fn trans_expr_fn(bcx: block,\n                                                  ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n+    // Always mark inline if this is a loop body. This is important for\n+    // performance on many programs with tight loops.\n+    if is_loop_body.is_some() {\n+        set_always_inline(llfn);\n+    } else {\n+        // Can't hurt.\n+        set_inline_hint(llfn);\n+    }\n+\n+    let real_return_type = if is_loop_body.is_some() {\n+        ty::mk_bool(bcx.tcx())\n+    } else {\n+        ty::ty_fn_ret(fty)\n+    };\n+\n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n             let cap_vars = *ccx.maps.capture_map.get(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n             let ClosureResult {llbox, cdata_ty, bcx}\n                 = build_closure(bcx, cap_vars, sigil, ret_handle);\n-            trans_closure(ccx, sub_path, decl,\n-                          body, llfn, no_self,\n-                          /*bad*/ copy bcx.fcx.param_substs, user_id, None,\n+            trans_closure(ccx,\n+                          sub_path,\n+                          decl,\n+                          body,\n+                          llfn,\n+                          no_self,\n+                          /*bad*/ copy bcx.fcx.param_substs,\n+                          user_id,\n+                          None,\n+                          [],\n+                          real_return_type,\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,\n                                                  ret_handle.is_some(), sigil),\n                           |bcx| {\n                               if is_loop_body.is_some() {\n-                                  Store(bcx, C_bool(true), bcx.fcx.llretptr);\n+                                  Store(bcx,\n+                                        C_bool(true),\n+                                        bcx.fcx.llretptr.get());\n                               }\n                           });\n             rslt(bcx, llbox)"}, {"sha": "76f0892277e28542e67486c56f950c0a6deb55ee", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -291,10 +291,15 @@ pub struct fn_ctxt_ {\n     // section of the executable we're generating.\n     llfn: ValueRef,\n \n-    // The two implicit arguments that arrive in the function we're creating.\n-    // For instance, foo(int, int) is really foo(ret*, env*, int, int).\n+    // The implicit environment argument that arrives in the function we're\n+    // creating.\n     llenv: ValueRef,\n-    llretptr: ValueRef,\n+\n+    // The place to store the return value. If the return type is immediate,\n+    // this is an alloca in the function. Otherwise, it's the hidden first\n+    // parameter to the function. After function construction, this should\n+    // always be Some.\n+    llretptr: Option<ValueRef>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -322,6 +327,11 @@ pub struct fn_ctxt_ {\n     // for that (flagptr, retptr)\n     loop_ret: Option<(ValueRef, ValueRef)>,\n \n+    // True if this function has an immediate return value, false otherwise.\n+    // If this is false, the llretptr will alias the first argument of the\n+    // function.\n+    has_immediate_return_value: bool,\n+\n     // Maps arguments to allocas created for them in llallocas.\n     llargs: @mut HashMap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for"}, {"sha": "69e267744351dc7ec4b8bc5744b808e9999ed496", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -274,7 +274,7 @@ pub fn trans_break_cont(bcx: block,\n           Some(bcx) => bcx,\n           // This is a return from a loop body block\n           None => {\n-            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n+            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n             cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n             return bcx;\n@@ -303,14 +303,14 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n-        Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n         match e {\n           Some(x) => PointerCast(bcx, retptr,\n                                  T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n           None => retptr\n         }\n       }\n-      None => bcx.fcx.llretptr\n+      None => bcx.fcx.llretptr.get()\n     };\n     match e {\n       Some(x) => {"}, {"sha": "477065377a5270f131da67ed715b963d001a8024", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -31,7 +31,7 @@\n  * value stored in the datum is indicated in the field `ty`.\n  *\n  * Generally speaking, you probably do not want to access the `val` field\n- * unless you know what mode the value is in.  Intead you should use one\n+ * unless you know what mode the value is in.  Instead you should use one\n  * of the following accessors:\n  *\n  * - `to_value_llval()` converts to by-value"}, {"sha": "21d62f95cc51c8fa020568da4e6ca311bd580dd0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -624,10 +624,14 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             match blk.node {\n                 ast::expr_fn_block(ref decl, ref body) => {\n-                    return closure::trans_expr_fn(bcx, sigil,\n-                                                  decl, body,\n-                                                  expr.id, blk.id,\n-                                                  Some(None), dest);\n+                    return closure::trans_expr_fn(bcx,\n+                                                  sigil,\n+                                                  decl,\n+                                                  body,\n+                                                  expr.id,\n+                                                  blk.id,\n+                                                  Some(None),\n+                                                  dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -655,15 +659,30 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_binary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       lhs,\n+                                       ~[rhs],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_unary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, subexpr, ~[], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       subexpr,\n+                                       ~[],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_index(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, base, ~[idx], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       base,\n+                                       ~[idx],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_cast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n@@ -1554,15 +1573,24 @@ fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n                        rcvr: @ast::expr,\n                        +args: ~[@ast::expr],\n-                       dest: Dest) -> block\n-{\n+                       ret_ty: ty::t,\n+                       dest: Dest)\n+                       -> block {\n     let origin = *bcx.ccx().maps.method_map.get(&expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n-    return callee::trans_call_inner(\n-        bcx, expr.info(), fty,\n-        expr_ty(bcx, expr),\n-        |bcx| meth::trans_method_callee(bcx, expr.callee_id, rcvr, origin),\n-        callee::ArgExprs(args), dest, DoAutorefArg);\n+    callee::trans_call_inner(bcx,\n+                             expr.info(),\n+                             fty,\n+                             ret_ty,\n+                             |bcx| {\n+                                meth::trans_method_callee(bcx,\n+                                                          expr.callee_id,\n+                                                          rcvr,\n+                                                          origin)\n+                             },\n+                             callee::ArgExprs(args),\n+                             dest,\n+                             DoAutorefArg)\n }\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n@@ -1697,7 +1725,11 @@ fn trans_assign_op(bcx: block,\n     if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n-        let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],\n+        let bcx = trans_overloaded_op(bcx,\n+                                      expr,\n+                                      dst,\n+                                      ~[src],\n+                                      dst_datum.ty,\n                                       SaveIn(scratch.val));\n         return scratch.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n     }"}, {"sha": "86ce556be72356603a766b56b7c130dde7992003", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 328, "deletions": 171, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -83,10 +83,11 @@ struct ShimTypes {\n struct LlvmSignature {\n     llarg_tys: ~[TypeRef],\n     llret_ty: TypeRef,\n+    sret: bool,\n }\n \n-fn foreign_signature(ccx: @CrateContext,\n-                     fn_sig: &ty::FnSig) -> LlvmSignature {\n+fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n+                     -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n      * of a function.  Note that these LLVM types are not quite the same\n@@ -97,7 +98,11 @@ fn foreign_signature(ccx: @CrateContext,\n \n     let llarg_tys = fn_sig.inputs.map(|arg| type_of(ccx, arg.ty));\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n-    LlvmSignature {llarg_tys: llarg_tys, llret_ty: llret_ty}\n+    LlvmSignature {\n+        llarg_tys: llarg_tys,\n+        llret_ty: llret_ty,\n+        sret: !ty::type_is_immediate(fn_sig.output),\n+    }\n }\n \n fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n@@ -109,20 +114,17 @@ fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n     let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n                                              T_ptr(llsig.llret_ty)),\n                              false);\n-    let ret_def =\n-        !ty::type_is_bot(fn_sig.output) &&\n-        !ty::type_is_nil(fn_sig.output);\n-    let fn_ty =\n-        abi_info(ccx).compute_info(\n-            llsig.llarg_tys,\n-            llsig.llret_ty,\n-            ret_def);\n+    let ret_def = !ty::type_is_bot(fn_sig.output) &&\n+                  !ty::type_is_nil(fn_sig.output);\n+    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys,\n+                                           llsig.llret_ty,\n+                                           ret_def);\n     ShimTypes {\n         fn_sig: fn_sig,\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_void()),\n+        shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_nil()),\n         fn_ty: fn_ty\n     }\n }\n@@ -142,13 +144,13 @@ fn build_shim_fn_(ccx: @CrateContext,\n                   tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n                   arg_builder: shim_arg_builder,\n-                  ret_builder: shim_ret_builder) -> ValueRef\n-{\n+                  ret_builder: shim_ret_builder)\n+               -> ValueRef {\n     let llshimfn = decl_internal_cdecl_fn(\n         ccx.llmod, shim_name, tys.shim_fn_ty);\n \n     // Declare the body of the shim function:\n-    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let llargbundle = get_param(llshimfn, 0u);\n@@ -159,30 +161,44 @@ fn build_shim_fn_(ccx: @CrateContext,\n \n     ret_builder(bcx, tys, llargbundle, llretval);\n \n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    // Don't finish up the function in the usual way, because this doesn't\n+    // follow the normal Rust calling conventions.\n+    tie_up_header_blocks(fcx, lltop);\n+\n+    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n+    Ret(ret_cx, C_null(T_nil()));\n \n     return llshimfn;\n }\n \n-type wrap_arg_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n-              llwrapfn: ValueRef, llargbundle: ValueRef);\n+type wrap_arg_builder<'self> = &'self fn(bcx: block,\n+                                         tys: &ShimTypes,\n+                                         llwrapfn: ValueRef,\n+                                         llargbundle: ValueRef);\n \n-type wrap_ret_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n-              llargbundle: ValueRef);\n+type wrap_ret_builder<'self> = &'self fn(bcx: block,\n+                                         tys: &ShimTypes,\n+                                         llargbundle: ValueRef);\n \n fn build_wrap_fn_(ccx: @CrateContext,\n                   tys: &ShimTypes,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n                   shim_upcall: ValueRef,\n+                  needs_c_return: bool,\n                   arg_builder: wrap_arg_builder,\n-                  ret_builder: wrap_ret_builder)\n-{\n+                  ret_builder: wrap_ret_builder) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n+\n+    // Patch up the return type if it's not immediate and we're returning via\n+    // the C ABI.\n+    if needs_c_return && !ty::type_is_immediate(tys.fn_sig.output) {\n+        let lloutputtype = type_of::type_of(*fcx.ccx, tys.fn_sig.output);\n+        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n+                                   lloutputtype));\n+    }\n+\n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n \n@@ -196,11 +212,34 @@ fn build_wrap_fn_(ccx: @CrateContext,\n     Call(bcx, shim_upcall, ~[llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n+    // Perform a custom version of `finish_fn`. First, tie up the header\n+    // blocks.\n     tie_up_header_blocks(fcx, lltop);\n \n-    // Make sure our standard return block (that we didn't use) is terminated\n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-    Unreachable(ret_cx);\n+    // Then return according to the C ABI.\n+    unsafe {\n+        let return_context = raw_block(fcx, false, fcx.llreturn);\n+\n+        let llfunctiontype = val_ty(llwrapfn);\n+        let llfunctiontype =\n+            ::lib::llvm::llvm::LLVMGetElementType(llfunctiontype);\n+        let llfunctionreturntype =\n+            ::lib::llvm::llvm::LLVMGetReturnType(llfunctiontype);\n+        if ::lib::llvm::llvm::LLVMGetTypeKind(llfunctionreturntype) ==\n+                ::lib::llvm::Void {\n+            // XXX: This might be wrong if there are any functions for which\n+            // the C ABI specifies a void output pointer and the Rust ABI\n+            // does not.\n+            RetVoid(return_context);\n+        } else {\n+            // Cast if we have to...\n+            // XXX: This is ugly.\n+            let llretptr = BitCast(return_context,\n+                                   fcx.llretptr.get(),\n+                                   T_ptr(llfunctionreturntype));\n+            Ret(return_context, Load(return_context, llretptr));\n+        }\n+    }\n }\n \n // For each foreign function F, we generate a wrapper function W and a shim\n@@ -241,8 +280,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n                          path: &ast_map::path,\n-                         foreign_mod: &ast::foreign_mod)\n-{\n+                         foreign_mod: &ast::foreign_mod) {\n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n     let arch = ccx.sess.targ_cfg.arch;\n@@ -312,27 +350,25 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     fn build_foreign_fn(ccx: @CrateContext,\n                         id: ast::node_id,\n                         foreign_item: @ast::foreign_item,\n-                        cc: lib::llvm::CallConv)\n-    {\n+                        cc: lib::llvm::CallConv) {\n         let llwrapfn = get_item_val(ccx, id);\n         let tys = shim_types(ccx, id);\n-        if attr::attrs_contains_name(\n-            foreign_item.attrs, \"rust_stack\")\n-        {\n+        if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n             build_direct_fn(ccx, llwrapfn, foreign_item,\n                             &tys, cc);\n+        } else if attr::attrs_contains_name(foreign_item.attrs, \"fast_ffi\") {\n+            build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n         } else {\n-            let llshimfn = build_shim_fn(ccx, foreign_item,\n-                                         &tys, cc);\n+            let llshimfn = build_shim_fn(ccx, foreign_item, &tys, cc);\n             build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n         }\n     }\n \n     fn build_shim_fn(ccx: @CrateContext,\n                      foreign_item: @ast::foreign_item,\n                      tys: &ShimTypes,\n-                     cc: lib::llvm::CallConv) -> ValueRef\n-    {\n+                     cc: lib::llvm::CallConv)\n+                  -> ValueRef {\n         /*!\n          *\n          * Build S, from comment above:\n@@ -344,31 +380,43 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llargbundle: ValueRef) -> ~[ValueRef] {\n+        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+                   -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n-            tys.fn_ty.build_shim_args(\n-                bcx, tys.llsig.llarg_tys, llargbundle)\n+            tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n-        fn build_ret(bcx: block, tys: &ShimTypes,\n-                     llargbundle: ValueRef, llretval: ValueRef)  {\n+        fn build_ret(bcx: block,\n+                     tys: &ShimTypes,\n+                     llargbundle: ValueRef,\n+                     llretval: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(\n-                bcx, tys.llsig.llarg_tys,\n-                tys.ret_def, llargbundle, llretval);\n+            tys.fn_ty.build_shim_ret(bcx,\n+                                     tys.llsig.llarg_tys,\n+                                     tys.ret_def,\n+                                     llargbundle,\n+                                     llretval);\n+            build_return(bcx);\n         }\n \n         let lname = link_name(ccx, foreign_item);\n         let llbasefn = base_fn(ccx, *lname, tys, cc);\n         // Name the shim function\n         let shim_name = *lname + ~\"__c_stack_shim\";\n-        return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n-                           build_args, build_ret);\n+        build_shim_fn_(ccx,\n+                       shim_name,\n+                       llbasefn,\n+                       tys,\n+                       cc,\n+                       build_args,\n+                       build_ret)\n     }\n \n-    fn base_fn(ccx: @CrateContext, lname: &str, tys: &ShimTypes,\n-               cc: lib::llvm::CallConv) -> ValueRef {\n+    fn base_fn(ccx: @CrateContext,\n+               lname: &str,\n+               tys: &ShimTypes,\n+               cc: lib::llvm::CallConv)\n+               -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n             decl_fn(ccx.llmod, lname, cc, fnty)\n@@ -377,10 +425,14 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n-    fn build_direct_fn(ccx: @CrateContext, decl: ValueRef,\n-                       item: @ast::foreign_item, tys: &ShimTypes,\n+    fn build_direct_fn(ccx: @CrateContext,\n+                       decl: ValueRef,\n+                       item: @ast::foreign_item,\n+                       tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n-        let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n+        debug!(\"build_direct_fn(%s)\", *link_name(ccx, item));\n+\n+        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n@@ -389,8 +441,37 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n             get_param(decl, i + first_real_arg)\n         });\n         let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ty::ty_fn_ret(ty)) {\n-            Store(bcx, retval, fcx.llretptr);\n+        let ret_ty = ty::ty_fn_ret(ty);\n+        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n+            Store(bcx, retval, fcx.llretptr.get());\n+        }\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+    }\n+\n+    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n+    // over the place\n+    fn build_fast_ffi_fn(ccx: @CrateContext,\n+                         decl: ValueRef,\n+                         item: @ast::foreign_item,\n+                         tys: &ShimTypes,\n+                         cc: lib::llvm::CallConv) {\n+        debug!(\"build_fast_ffi_fn(%s)\", *link_name(ccx, item));\n+\n+        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n+        let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n+        set_no_inline(fcx.llfn);\n+        set_fixed_stack_segment(fcx.llfn);\n+        let ty = ty::lookup_item_type(ccx.tcx,\n+                                      ast_util::local_def(item.id)).ty;\n+        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n+            get_param(decl, i + first_real_arg)\n+        });\n+        let retval = Call(bcx, llbasefn, args);\n+        let ret_ty = ty::ty_fn_ret(ty);\n+        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n+            Store(bcx, retval, fcx.llretptr.get());\n         }\n         build_return(bcx);\n         finish_fn(fcx, lltop);\n@@ -415,12 +496,19 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n \n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+        build_wrap_fn_(ccx,\n+                       tys,\n+                       llshimfn,\n+                       llwrapfn,\n                        ccx.upcalls.call_shim_on_c_stack,\n-                       build_args, build_ret);\n-\n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n+                       false,\n+                       build_args,\n+                       build_ret);\n+\n+        fn build_args(bcx: block,\n+                      tys: &ShimTypes,\n+                      llwrapfn: ValueRef,\n+                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n             let n = vec::len(tys.llsig.llarg_tys);\n@@ -437,14 +525,18 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n                 store_inbounds(bcx, llargval, llargbundle, ~[0u, i]);\n             }\n-            let llretptr = get_param(llwrapfn, 0u);\n+            let llretptr = bcx.fcx.llretptr.get();\n             store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n         }\n \n-        fn build_ret(bcx: block, _tys: &ShimTypes,\n-                     _llargbundle: ValueRef) {\n+        fn build_ret(bcx: block,\n+                     shim_types: &ShimTypes,\n+                     llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n-            RetVoid(bcx);\n+            let arg_count = shim_types.fn_sig.inputs.len();\n+            let llretptr = load_inbounds(bcx, llargbundle, ~[0, arg_count]);\n+            Store(bcx, Load(bcx, llretptr), bcx.fcx.llretptr.get());\n+            build_return(bcx);\n         }\n     }\n }\n@@ -457,9 +549,18 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n \n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+\n     // XXX: Bad copy.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n-                               Some(copy substs), Some(item.span));\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               decl,\n+                               item.id,\n+                               output_type,\n+                               None,\n+                               Some(copy substs),\n+                               Some(item.span));\n+\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n@@ -468,92 +569,92 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_cxchg_acq\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_cxchg_rel\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg_acq\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg_rel\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"move_val\" => {\n             // Create a datum reflecting the value being moved:\n@@ -584,13 +685,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n@@ -600,13 +701,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // FIXME (#3727): change this to T_ptr(ccx.tydesc_ty) when the\n             // core::sys copy of the get_tydesc interface dies off.\n             let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n-            Store(bcx, td, fcx.llretptr);\n+            Store(bcx, td, fcx.llretptr.get());\n         }\n         ~\"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             if !ty::type_is_nil(tp_ty) {\n-                Store(bcx, C_null(lltp_ty), fcx.llretptr);\n+                Store(bcx, C_null(lltp_ty), fcx.llretptr.get());\n             }\n         }\n         ~\"forget\" => {}\n@@ -632,20 +733,21 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n               // NB: Do not use a Load and Store here. This causes\n               // massive code bloat when reinterpret_cast is used on\n               // large structural types.\n-              let llretptr = PointerCast(bcx, fcx.llretptr, T_ptr(T_i8()));\n+              let llretptr = fcx.llretptr.get();\n+              let llretptr = PointerCast(bcx, llretptr, T_ptr(T_i8()));\n               let llcast = get_param(decl, first_real_arg);\n               let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n               call_memcpy(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n           }\n         }\n         ~\"addr_of\" => {\n-            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n+            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr.get());\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n             Store(bcx,\n                   C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n@@ -687,7 +789,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 bcx.ccx().llmod, ~\"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr,\n                                              T_ptr(T_nil()));\n-            Store(bcx, morestack_addr, fcx.llretptr);\n+            Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         ~\"memmove32\" => {\n             let dst_ptr = get_param(decl, first_real_arg);\n@@ -712,243 +814,243 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f32\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f64\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f32\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f64\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f32\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f64\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f32\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f64\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f32\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f64\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f32\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f64\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f32\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f64\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f32\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f64\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f32\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f64\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f32\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f64\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n@@ -994,9 +1096,12 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n-    fn build_rust_fn(ccx: @CrateContext, +path: ast_map::path,\n-                     decl: &ast::fn_decl, body: &ast::blk,\n-                     id: ast::node_id) -> ValueRef {\n+    fn build_rust_fn(ccx: @CrateContext,\n+                     +path: ast_map::path,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n+                     id: ast::node_id)\n+                  -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         // XXX: Bad copy.\n@@ -1006,12 +1111,24 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n             )));\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx, path, decl, body, llfndecl, no_self, None, id, None);\n+        trans_fn(ccx,\n+                 path,\n+                 decl,\n+                 body,\n+                 llfndecl,\n+                 no_self,\n+                 None,\n+                 id,\n+                 None,\n+                 []);\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @CrateContext, +path: ast_map::path,\n-                     llrustfn: ValueRef, tys: &ShimTypes) -> ValueRef {\n+    fn build_shim_fn(ccx: @CrateContext,\n+                     +path: ast_map::path,\n+                     llrustfn: ValueRef,\n+                     tys: &ShimTypes)\n+                     -> ValueRef {\n         /*!\n          *\n          * Generate the shim S:\n@@ -1029,15 +1146,21 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llargbundle: ValueRef) -> ~[ValueRef] {\n+        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+                      -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n             let ccx = bcx.ccx();\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = tys.fn_sig.inputs.len();\n-            let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n-            llargvals.push(llretptr);\n+\n+            if !ty::type_is_immediate(tys.fn_sig.output) {\n+                let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+                llargvals.push(llretptr);\n+            } else {\n+                llargvals.push(C_null(T_ptr(T_i8())));\n+            }\n+\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n             llargvals.push(llenvptr);\n             while i < n {\n@@ -1055,24 +1178,43 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n             return llargvals;\n         }\n \n-        fn build_ret(_bcx: block, _tys: &ShimTypes,\n-                     _llargbundle: ValueRef, _llretval: ValueRef)  {\n-            // Nop. The return pointer in the Rust ABI function\n-            // is wired directly into the return slot in the shim struct\n+        fn build_ret(bcx: block,\n+                     shim_types: &ShimTypes,\n+                     llargbundle: ValueRef,\n+                     llretval: ValueRef) {\n+            if ty::type_is_immediate(shim_types.fn_sig.output) {\n+                // Write the value into the argument bundle.\n+                let arg_count = shim_types.fn_sig.inputs.len();\n+                let llretptr = load_inbounds(bcx,\n+                                             llargbundle,\n+                                             ~[0, arg_count]);\n+                Store(bcx, llretval, llretptr);\n+            } else {\n+                // NB: The return pointer in the Rust ABI function is wired\n+                // directly into the return slot in the shim struct.\n+            }\n+\n+            build_return(bcx);\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(path, ast_map::path_name(\n+            ccx,\n+            vec::append_one(path, ast_map::path_name(\n                 special_idents::clownshoe_stack_shim\n             )));\n-        return build_shim_fn_(ccx, shim_name, llrustfn, tys,\n-                           lib::llvm::CCallConv,\n-                           build_args, build_ret);\n+        build_shim_fn_(ccx,\n+                       shim_name,\n+                       llrustfn,\n+                       tys,\n+                       lib::llvm::CCallConv,\n+                       build_args,\n+                       build_ret)\n     }\n \n-    fn build_wrap_fn(ccx: @CrateContext, llshimfn: ValueRef,\n-                     llwrapfn: ValueRef, tys: &ShimTypes)\n-    {\n+    fn build_wrap_fn(ccx: @CrateContext,\n+                     llshimfn: ValueRef,\n+                     llwrapfn: ValueRef,\n+                     tys: &ShimTypes) {\n         /*!\n          *\n          * Generate the wrapper W:\n@@ -1085,23 +1227,30 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+        build_wrap_fn_(ccx,\n+                       tys,\n+                       llshimfn,\n+                       llwrapfn,\n                        ccx.upcalls.call_shim_on_rust_stack,\n-                       build_args, build_ret);\n-\n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n+                       true,\n+                       build_args,\n+                       build_ret);\n+\n+        fn build_args(bcx: block,\n+                      tys: &ShimTypes,\n+                      llwrapfn: ValueRef,\n+                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(\n-                bcx, tys.llsig.llret_ty,\n-                llwrapfn, llargbundle);\n+            tys.fn_ty.build_wrap_args(bcx,\n+                                      tys.llsig.llret_ty,\n+                                      llwrapfn,\n+                                      llargbundle);\n         }\n \n-        fn build_ret(bcx: block, tys: &ShimTypes,\n-                     llargbundle: ValueRef) {\n+        fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(\n-                bcx, tys.llsig.llarg_tys, llargbundle);\n+            tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n+            build_return(bcx);\n         }\n     }\n \n@@ -1120,12 +1269,20 @@ pub fn register_foreign_fn(ccx: @CrateContext,\n                            +path: ast_map::path,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n-                        -> ValueRef {\n+                           -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n+\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n+\n     let tys = shim_types(ccx, node_id);\n     do tys.fn_ty.decl_fn |fnty| {\n-        register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n-                           t, lib::llvm::CCallConv, fnty)\n+        register_fn_fuller(ccx,\n+                           sp,\n+                           /*bad*/copy path,\n+                           node_id,\n+                           attrs,\n+                           t,\n+                           lib::llvm::CCallConv,\n+                           fnty)\n     }\n }"}, {"sha": "2072c4712457334e2022efe88175da62e0b6c6e9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -499,7 +499,8 @@ pub fn trans_struct_drop(bcx: block,\n         }\n \n         let self_arg = PointerCast(bcx, llval, params[1]);\n-        let args = ~[bcx.fcx.llretptr, self_arg];\n+        let args = ~[C_null(T_ptr(T_i8())), self_arg];\n+\n         Call(bcx, dtor_addr, args);\n \n         // Drop the fields\n@@ -575,9 +576,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-pub fn decr_refcnt_maybe_free(bcx: block,\n-                              box_ptr: ValueRef,\n-                              t: ty::t)\n+pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t)\n                            -> block {\n     let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n@@ -737,7 +736,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                helper: glue_helper)\n                             -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(ccx.tcx), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n     // All glue functions take values passed *by alias*; this is a\n@@ -756,8 +755,11 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n-                         helper: glue_helper, name: &str)\n+pub fn make_generic_glue(ccx: @CrateContext,\n+                         t: ty::t,\n+                         llfn: ValueRef,\n+                         helper: glue_helper,\n+                         name: &str)\n                       -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n@@ -767,8 +769,10 @@ pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let start = time::get_time();\n     let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n     let end = time::get_time();\n-    log_fn_time(ccx, fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n-                start, end);\n+    log_fn_time(ccx,\n+                fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n+                start,\n+                end);\n     return llval;\n }\n "}, {"sha": "3f2fb95513a39c88c5064b967470c5fc6ce3c014", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -116,7 +116,8 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                          self_kind,\n                          None,\n                          mth.id,\n-                         Some(impl_did));\n+                         Some(impl_did),\n+                         []);\n             }\n             local_def(mth.id)\n           }"}, {"sha": "d3a15cbbfe1504247a4f7d1fd103dc17c7a53fa9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -137,7 +137,8 @@ pub fn trans_method(ccx: @CrateContext,\n              self_arg,\n              param_substs,\n              method.id,\n-             Some(impl_id));\n+             Some(impl_id),\n+             []);\n }\n \n pub fn trans_self_arg(bcx: block,"}, {"sha": "a6930b339ae72ed39f8df8bf17fd07dff5c5d4e4", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -195,7 +195,16 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             }, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n-        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n+        trans_fn(ccx,\n+                 pt,\n+                 decl,\n+                 body,\n+                 d,\n+                 no_self,\n+                 psubsts,\n+                 fn_id.node,\n+                 None,\n+                 []);\n         d\n       }\n       ast_map::node_item(*) => {"}, {"sha": "30c14ab679f31d01ded824f72afe54da1a61a1a3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -288,11 +288,15 @@ pub impl Reflector {\n                 let arg = unsafe {\n                     llvm::LLVMGetParam(llfdecl, first_real_arg as c_uint)\n                 };\n-                let fcx = new_fn_ctxt(ccx, ~[], llfdecl, None);\n+                let fcx = new_fn_ctxt(ccx,\n+                                      ~[],\n+                                      llfdecl,\n+                                      ty::mk_uint(ccx.tcx),\n+                                      None);\n                 let bcx = top_scope_block(fcx, None);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n-                Store(bcx, ret, fcx.llretptr);\n+                Store(bcx, ret, fcx.llretptr.get());\n                 cleanup_and_Br(bcx, bcx, fcx.llreturn);\n                 finish_fn(fcx, bcx.llbb);\n                 llfdecl"}, {"sha": "8cac00252d0d3665d35f4931ca8f213b2b845e78", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -39,20 +39,34 @@ pub fn type_of_explicit_args(ccx: @CrateContext,\n     inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n }\n \n-pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg],\n-                  output: ty::t) -> TypeRef {\n+pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg], output: ty::t)\n+               -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];\n \n         // Arg 0: Output pointer.\n-        atys.push(T_ptr(type_of(cx, output)));\n+        // (if the output type is non-immediate)\n+        let output_is_immediate = ty::type_is_immediate(output);\n+        let lloutputtype = type_of(cx, output);\n+        if !output_is_immediate {\n+            atys.push(T_ptr(lloutputtype));\n+        } else {\n+            // XXX: Eliminate this.\n+            atys.push(T_ptr(T_i8()));\n+        }\n \n         // Arg 1: Environment\n         atys.push(T_opaque_box_ptr(cx));\n \n         // ... then explicit args.\n         atys.push_all(type_of_explicit_args(cx, inputs));\n-        return T_fn(atys, llvm::LLVMVoidType());\n+\n+        // Use the output as the actual return value if it's immediate.\n+        if output_is_immediate {\n+            T_fn(atys, lloutputtype)\n+        } else {\n+            T_fn(atys, llvm::LLVMVoidType())\n+        }\n     }\n }\n \n@@ -318,11 +332,9 @@ pub fn llvm_type_name(cx: @CrateContext,\n }\n \n pub fn type_of_dtor(ccx: @CrateContext, self_ty: ty::t) -> TypeRef {\n-    unsafe {\n-        T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n-               T_ptr(type_of(ccx, self_ty))],            // self arg\n-             llvm::LLVMVoidType())\n-    }\n+    T_fn(~[T_ptr(T_i8()),                   // output pointer\n+           T_ptr(type_of(ccx, self_ty))],   // self arg\n+         T_nil())\n }\n \n pub fn type_of_rooted(ccx: @CrateContext, t: ty::t) -> TypeRef {\n@@ -336,5 +348,5 @@ pub fn type_of_glue_fn(ccx: @CrateContext, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));\n     return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],\n-                T_void());\n+                T_nil());\n }"}, {"sha": "ff41f6f5ae125dd44fcf255359ba5089b78f74b0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 144, "deletions": 45, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -133,7 +133,6 @@ impl to_bytes::IterBytes for creader_cache_key {\n \n struct intern_key {\n     sty: *sty,\n-    o_def_id: Option<ast::def_id>\n }\n \n // NB: Do not replace this with #[deriving(Eq)]. The automatically-derived\n@@ -142,7 +141,7 @@ struct intern_key {\n impl cmp::Eq for intern_key {\n     fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n-            *self.sty == *other.sty && self.o_def_id == other.o_def_id\n+            *self.sty == *other.sty\n         }\n     }\n     fn ne(&self, other: &intern_key) -> bool {\n@@ -153,7 +152,7 @@ impl cmp::Eq for intern_key {\n impl to_bytes::IterBytes for intern_key {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n-            to_bytes::iter_bytes_2(&*self.sty, &self.o_def_id, lsb0, f);\n+            (*self.sty).iter_bytes(lsb0, f);\n         }\n     }\n }\n@@ -232,7 +231,7 @@ pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n     diag: @syntax::diagnostic::span_handler,\n-    interner: @mut HashMap<intern_key, t_box>,\n+    interner: @mut HashMap<intern_key, ~t_box_>,\n     next_id: @mut uint,\n     vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n@@ -307,7 +306,7 @@ struct ctxt_ {\n     used_unsafe: @mut HashSet<ast::node_id>,\n }\n \n-enum tbox_flag {\n+pub enum tbox_flag {\n     has_params = 1,\n     has_self = 2,\n     needs_infer = 4,\n@@ -320,13 +319,12 @@ enum tbox_flag {\n     needs_subst = 1 | 2 | 8\n }\n \n-type t_box = @t_box_;\n+pub type t_box = &'static t_box_;\n \n-struct t_box_ {\n+pub struct t_box_ {\n     sty: sty,\n     id: uint,\n     flags: uint,\n-    o_def_id: Option<ast::def_id>\n }\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -359,7 +357,6 @@ pub fn type_needs_infer(t: t) -> bool {\n pub fn type_has_regions(t: t) -> bool {\n     tbox_has_flag(get(t), has_regions)\n }\n-pub fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Eq)]\n@@ -513,6 +510,53 @@ pub struct substs {\n     tps: ~[t]\n }\n \n+mod primitives {\n+    use super::{sty, t_box_};\n+\n+    use syntax::ast;\n+\n+    macro_rules! def_prim_ty(\n+        ($name:ident, $sty:expr, $id:expr) => (\n+            pub static $name: t_box_ = t_box_ {\n+                sty: $sty,\n+                id: $id,\n+                flags: 0,\n+            };\n+        )\n+    )\n+\n+    def_prim_ty!(TY_NIL,    super::ty_nil,                  0)\n+    def_prim_ty!(TY_BOOL,   super::ty_bool,                 1)\n+    def_prim_ty!(TY_INT,    super::ty_int(ast::ty_i),       2)\n+    def_prim_ty!(TY_CHAR,   super::ty_int(ast::ty_char),    3)\n+    def_prim_ty!(TY_I8,     super::ty_int(ast::ty_i8),      4)\n+    def_prim_ty!(TY_I16,    super::ty_int(ast::ty_i16),     5)\n+    def_prim_ty!(TY_I32,    super::ty_int(ast::ty_i32),     6)\n+    def_prim_ty!(TY_I64,    super::ty_int(ast::ty_i64),     7)\n+    def_prim_ty!(TY_UINT,   super::ty_uint(ast::ty_u),      8)\n+    def_prim_ty!(TY_U8,     super::ty_uint(ast::ty_u8),     9)\n+    def_prim_ty!(TY_U16,    super::ty_uint(ast::ty_u16),    10)\n+    def_prim_ty!(TY_U32,    super::ty_uint(ast::ty_u32),    11)\n+    def_prim_ty!(TY_U64,    super::ty_uint(ast::ty_u64),    12)\n+    def_prim_ty!(TY_FLOAT,  super::ty_float(ast::ty_f),     13)\n+    def_prim_ty!(TY_F32,    super::ty_float(ast::ty_f32),   14)\n+    def_prim_ty!(TY_F64,    super::ty_float(ast::ty_f64),   15)\n+\n+    pub static TY_BOT: t_box_ = t_box_ {\n+        sty: super::ty_bot,\n+        id: 16,\n+        flags: super::has_ty_bot as uint,\n+    };\n+\n+    pub static TY_ERR: t_box_ = t_box_ {\n+        sty: super::ty_err,\n+        id: 17,\n+        flags: super::has_ty_err as uint,\n+    };\n+\n+    pub static LAST_PRIMITIVE_ID: uint = 18;\n+}\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Eq)]\n@@ -852,7 +896,7 @@ pub fn mk_ctxt(s: session::Session,\n     @ctxt_ {\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n-        next_id: @mut 0,\n+        next_id: @mut primitives::LAST_PRIMITIVE_ID,\n         vecs_implicitly_copyable: vecs_implicitly_copyable,\n         legacy_modes: legacy_modes,\n         cstore: s.cstore,\n@@ -894,16 +938,25 @@ pub fn mk_ctxt(s: session::Session,\n      }\n }\n \n-\n // Type constructors\n-fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n-    let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n+fn mk_t(cx: ctxt, +st: sty) -> t {\n+    // Check for primitive types.\n+    match st {\n+        ty_nil => return mk_nil(cx),\n+        ty_err => return mk_err(cx),\n+        ty_bool => return mk_bool(cx),\n+        ty_int(i) => return mk_mach_int(cx, i),\n+        ty_uint(u) => return mk_mach_uint(cx, u),\n+        ty_float(f) => return mk_mach_float(cx, f),\n+        _ => {}\n+    };\n+\n+    let key = intern_key { sty: to_unsafe_ptr(&st) };\n     match cx.interner.find(&key) {\n-      Some(&t) => unsafe { return cast::reinterpret_cast(&t); },\n+      Some(t) => unsafe { return cast::transmute(&t.sty); },\n       _ => ()\n     }\n \n@@ -973,66 +1026,116 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n     }\n \n-    let t = @t_box_ {\n+    let t = ~t_box_ {\n         sty: st,\n         id: *cx.next_id,\n         flags: flags,\n-        o_def_id: o_def_id\n     };\n+\n+    let sty_ptr = to_unsafe_ptr(&t.sty);\n+\n     let key = intern_key {\n-        sty: to_unsafe_ptr(&t.sty),\n-        o_def_id: o_def_id\n+        sty: sty_ptr,\n     };\n \n     cx.interner.insert(key, t);\n \n     *cx.next_id += 1;\n-    unsafe { cast::reinterpret_cast(&t) }\n+\n+    unsafe {\n+        cast::transmute::<*sty, t>(sty_ptr)\n+    }\n+}\n+\n+#[inline(always)]\n+pub fn mk_prim_t(cx: ctxt, primitive: &'static t_box_) -> t {\n+    unsafe {\n+        cast::transmute::<&'static t_box_, t>(primitive)\n+    }\n }\n \n-pub fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n+#[inline(always)]\n+pub fn mk_nil(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_NIL) }\n \n-pub fn mk_err(cx: ctxt) -> t { mk_t(cx, ty_err) }\n+#[inline(always)]\n+pub fn mk_err(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_ERR) }\n \n-pub fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n+#[inline(always)]\n+pub fn mk_bot(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOT) }\n \n-pub fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n+#[inline(always)]\n+pub fn mk_bool(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_BOOL) }\n \n-pub fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n+#[inline(always)]\n+pub fn mk_int(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_INT) }\n \n-pub fn mk_i8(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i8)) }\n+#[inline(always)]\n+pub fn mk_i8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I8) }\n \n-pub fn mk_i16(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i16)) }\n+#[inline(always)]\n+pub fn mk_i16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I16) }\n \n-pub fn mk_i32(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i32)) }\n+#[inline(always)]\n+pub fn mk_i32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I32) }\n \n-pub fn mk_i64(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i64)) }\n+#[inline(always)]\n+pub fn mk_i64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_I64) }\n \n-pub fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n+#[inline(always)]\n+pub fn mk_float(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_FLOAT) }\n \n-pub fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n+#[inline(always)]\n+pub fn mk_f32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F32) }\n \n-pub fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n+#[inline(always)]\n+pub fn mk_f64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_F64) }\n \n-pub fn mk_u16(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u16)) }\n+#[inline(always)]\n+pub fn mk_uint(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_UINT) }\n \n-pub fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n+#[inline(always)]\n+pub fn mk_u8(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U8) }\n \n-pub fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n+#[inline(always)]\n+pub fn mk_u16(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U16) }\n \n-pub fn mk_f32(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f32)) }\n+#[inline(always)]\n+pub fn mk_u32(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U32) }\n \n-pub fn mk_f64(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f64)) }\n+#[inline(always)]\n+pub fn mk_u64(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_U64) }\n \n-pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n+pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t {\n+    match tm {\n+        ast::ty_i    => mk_int(cx),\n+        ast::ty_char => mk_char(cx),\n+        ast::ty_i8   => mk_i8(cx),\n+        ast::ty_i16  => mk_i16(cx),\n+        ast::ty_i32  => mk_i32(cx),\n+        ast::ty_i64  => mk_i64(cx),\n+    }\n+}\n \n-pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n+pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t {\n+    match tm {\n+        ast::ty_u    => mk_uint(cx),\n+        ast::ty_u8   => mk_u8(cx),\n+        ast::ty_u16  => mk_u16(cx),\n+        ast::ty_u32  => mk_u32(cx),\n+        ast::ty_u64  => mk_u64(cx),\n+    }\n+}\n \n pub fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t {\n-    mk_t(cx, ty_float(tm))\n+    match tm {\n+        ast::ty_f    => mk_float(cx),\n+        ast::ty_f32  => mk_f32(cx),\n+        ast::ty_f64  => mk_f64(cx),\n+    }\n }\n \n-pub fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n+#[inline(always)]\n+pub fn mk_char(cx: ctxt) -> t { mk_prim_t(cx, &primitives::TY_CHAR) }\n \n pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n@@ -1149,10 +1252,6 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-pub fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n-    mk_t_with_id(cx, /*bad*/copy get(base).sty, Some(def_id))\n-}\n-\n // Converts s to its machine type equivalent\n pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     match get(t).sty {"}, {"sha": "36b46267316269029337b8427e5e41ca5c9f819b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1085,16 +1085,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n         let tpt = {\n-            let ty = {\n-                let t0 = ccx.to_ty(&type_rscope(region_parameterization), t);\n-                // Do not associate a def id with a named, parameterized type\n-                // like \"foo<X>\".  This is because otherwise ty_to_str will\n-                // print the name as merely \"foo\", as it has no way to\n-                // reconstruct the value of X.\n-                if generics.is_parameterized() { t0 } else {\n-                    ty::mk_with_id(tcx, t0, def_id)\n-                }\n-            };\n+            let ty = ccx.to_ty(&type_rscope(region_parameterization), t);\n             ty_param_bounds_and_ty {\n                 generics: ty_generics(ccx, rp, generics, 0),\n                 ty: ty"}, {"sha": "7b479bc7578bd96c3a8a7fae0c565f031c136d3f", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -59,10 +59,13 @@ pub mod reader {\n     use ebml::{EsVec, EsVecElt, EsVecLen, TaggedDoc};\n     use serialize;\n \n+    use core::cast::transmute;\n     use core::int;\n     use core::io;\n     use core::prelude::*;\n+    use core::ptr::offset;\n     use core::str;\n+    use core::unstable::intrinsics::bswap32;\n     use core::vec;\n \n     // ebml reading\n@@ -78,7 +81,8 @@ pub mod reader {\n         next: uint\n     }\n \n-    fn vuint_at(data: &[u8], start: uint) -> Res {\n+    #[inline(never)]\n+    fn vuint_at_slow(data: &[u8], start: uint) -> Res {\n         let a = data[start];\n         if a & 0x80u8 != 0u8 {\n             return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n@@ -87,18 +91,63 @@ pub mod reader {\n             return Res {val: ((a & 0x3fu8) as uint) << 8u |\n                         (data[start + 1u] as uint),\n                     next: start + 2u};\n-        } else if a & 0x20u8 != 0u8 {\n+        }\n+        if a & 0x20u8 != 0u8 {\n             return Res {val: ((a & 0x1fu8) as uint) << 16u |\n                         (data[start + 1u] as uint) << 8u |\n                         (data[start + 2u] as uint),\n                     next: start + 3u};\n-        } else if a & 0x10u8 != 0u8 {\n+        }\n+        if a & 0x10u8 != 0u8 {\n             return Res {val: ((a & 0x0fu8) as uint) << 24u |\n                         (data[start + 1u] as uint) << 16u |\n                         (data[start + 2u] as uint) << 8u |\n                         (data[start + 3u] as uint),\n                     next: start + 4u};\n-        } else { error!(\"vint too big\"); fail!(); }\n+        }\n+        fail!(~\"vint too big\");\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+        if data.len() - start < 4 {\n+            return vuint_at_slow(data, start);\n+        }\n+\n+        unsafe {\n+            let (ptr, _): (*u8, uint) = transmute(data);\n+            let ptr = offset(ptr, start);\n+            let ptr: *i32 = transmute(ptr);\n+            let val = bswap32(*ptr);\n+            let val: u32 = transmute(val);\n+            if (val & 0x80000000) != 0 {\n+                Res {\n+                    val: ((val >> 24) & 0x7f) as uint,\n+                    next: start + 1\n+                }\n+            } else if (val & 0x40000000) != 0 {\n+                Res {\n+                    val: ((val >> 16) & 0x3fff) as uint,\n+                    next: start + 2\n+                }\n+            } else if (val & 0x20000000) != 0 {\n+                Res {\n+                    val: ((val >> 8) & 0x1fffff) as uint,\n+                    next: start + 3\n+                }\n+            } else {\n+                Res {\n+                    val: (val & 0x0fffffff) as uint,\n+                    next: start + 4\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(target_arch = \"arm\")]\n+    pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+        vuint_at_slow(data, start)\n     }\n \n     pub fn Doc(data: @~[u8]) -> Doc {"}, {"sha": "ef4932d667a299b02e93ac950575a2fa5881bd78", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -222,7 +222,11 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                         };\n                         match connect_result {\n                             0i32 => {\n-                                debug!(\"tcp_connect successful\");\n+                                debug!(\"tcp_connect successful: \\\n+                                        stream %x,\n+                                        socket data %x\",\n+                                       stream_handle_ptr as uint,\n+                                       socket_data_ptr as uint);\n                                 // reusable data that we'll have for the\n                                 // duration..\n                                 uv::ll::set_data_for_uv_handle(\n@@ -556,13 +560,21 @@ pub fn accept(new_conn: TcpNewConnection)\n                             server_handle_ptr as *libc::c_void,\n                             client_stream_handle_ptr as *libc::c_void) {\n                             0i32 => {\n-                                debug!(\n-                                    \"successfully accepted client \\\n-                                      connection\");\n+                                debug!(\"successfully accepted client \\\n+                                        connection: \\\n+                                        stream %x, \\\n+                                        socket data %x\",\n+                                       client_stream_handle_ptr as uint,\n+                                       client_socket_data_ptr as uint);\n                                 uv::ll::set_data_for_uv_handle(\n                                     client_stream_handle_ptr,\n                                     client_socket_data_ptr\n                                     as *libc::c_void);\n+                                let ptr = uv::ll::get_data_for_uv_handle(\n+                                    client_stream_handle_ptr);\n+                                debug!(\"ptrs: %x %x\",\n+                                       client_socket_data_ptr as uint,\n+                                       ptr as uint);\n                                 result_ch.send(None);\n                             }\n                             _ => {\n@@ -1268,14 +1280,15 @@ impl ToTcpErr for uv::ll::uv_err_data {\n }\n \n extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n-                    nread: libc::ssize_t,\n-                    buf: uv::ll::uv_buf_t) {\n+                         nread: libc::ssize_t,\n+                         buf: uv::ll::uv_buf_t) {\n     unsafe {\n-        debug!(\"entering on_tcp_read_cb stream: %? nread: %?\",\n-                        stream, nread);\n+        debug!(\"entering on_tcp_read_cb stream: %x nread: %?\",\n+                        stream as uint, nread);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n         let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n             as *TcpSocketData;\n+        debug!(\"socket data is %x\", socket_data_ptr as uint);\n         match nread as int {\n           // incoming err.. probably eof\n           -1 => {"}, {"sha": "98d76c6b9aa56e1bed99e0306bd7df020c00240b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1156,8 +1156,7 @@ pub unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void,\n pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n     return rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n }\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n-                    data: *U) {\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n     rustrt::rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n                                            data as *libc::c_void);\n }"}, {"sha": "2483cacd1a69f74e1cba417fbe5e056090b9eaab", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -18,9 +18,11 @@ use util::interner;\n \n use core::cast;\n use core::char;\n+use core::cmp::Equiv;\n use core::hashmap::HashSet;\n use core::str;\n use core::task;\n+use core::to_bytes;\n \n #[auto_encode]\n #[auto_decode]\n@@ -355,23 +357,43 @@ pub mod special_idents {\n     pub static type_self: ident = ident { repr: 36u, ctxt: 0};    // `Self`\n }\n \n+pub struct StringRef<'self>(&'self str);\n+\n+impl<'self> Equiv<@~str> for StringRef<'self> {\n+    #[inline(always)]\n+    fn equiv(&self, other: &@~str) -> bool { str::eq_slice(**self, **other) }\n+}\n+\n+impl<'self> to_bytes::IterBytes for StringRef<'self> {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+        (**self).iter_bytes(lsb0, f);\n+    }\n+}\n+\n pub struct ident_interner {\n     priv interner: Interner<@~str>,\n }\n \n pub impl ident_interner {\n     fn intern(&self, val: @~str) -> ast::ident {\n-        ast::ident { repr: self.interner.intern(val), ctxt: 0}\n+        ast::ident { repr: self.interner.intern(val), ctxt: 0 }\n     }\n     fn gensym(&self, val: @~str) -> ast::ident {\n-        ast::ident { repr: self.interner.gensym(val), ctxt: 0}\n+        ast::ident { repr: self.interner.gensym(val), ctxt: 0 }\n     }\n     fn get(&self, idx: ast::ident) -> @~str {\n         self.interner.get(idx.repr)\n     }\n     fn len(&self) -> uint {\n         self.interner.len()\n     }\n+    fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+                                                     -> Option<ast::ident> {\n+        match self.interner.find_equiv(val) {\n+            Some(v) => Some(ast::ident { repr: v, ctxt: 0 }),\n+            None => None,\n+        }\n+    }\n }\n \n pub fn mk_ident_interner() -> @ident_interner {"}, {"sha": "cda1c6c0df3856bdb1f21b3119962def39d54ae1", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -16,6 +16,7 @@\n #[macro_escape];\n \n use core::prelude::*;\n+use core::cmp::Equiv;\n use core::hashmap::HashMap;\n \n pub struct Interner<T> {\n@@ -67,6 +68,14 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n+\n+    fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n+                                              -> Option<uint> {\n+        match self.map.find_equiv(val) {\n+            Some(v) => Some(*v),\n+            None => None,\n+        }\n+    }\n }\n \n /* Key for thread-local data for sneaking interner information to the"}, {"sha": "dbcbd7b83cf23aef493896df02a1ffbce7bf8362", "filename": "src/rt/rust_sched_loop.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -29,6 +29,8 @@ rust_sched_loop::rust_sched_loop(rust_scheduler *sched, int id, bool killed) :\n     should_exit(false),\n     cached_c_stack(NULL),\n     extra_c_stack(NULL),\n+    cached_big_stack(NULL),\n+    extra_big_stack(NULL),\n     dead_task(NULL),\n     killed(killed),\n     pump_signal(NULL),\n@@ -263,6 +265,11 @@ rust_sched_loop::run_single_turn() {\n             destroy_exchange_stack(kernel->region(), cached_c_stack);\n             cached_c_stack = NULL;\n         }\n+        assert(!extra_big_stack);\n+        if (cached_big_stack) {\n+            destroy_exchange_stack(kernel->region(), cached_big_stack);\n+            cached_big_stack = NULL;\n+        }\n \n         sched->release_task_thread();\n         return sched_loop_state_exit;\n@@ -392,6 +399,13 @@ rust_sched_loop::prepare_c_stack(rust_task *task) {\n         cached_c_stack = create_exchange_stack(kernel->region(),\n                                                C_STACK_SIZE);\n     }\n+    assert(!extra_big_stack);\n+    if (!cached_big_stack) {\n+        cached_big_stack = create_exchange_stack(kernel->region(),\n+                                                 C_STACK_SIZE +\n+                                                 (C_STACK_SIZE * 2));\n+        cached_big_stack->is_big = 1;\n+    }\n }\n \n void\n@@ -400,6 +414,10 @@ rust_sched_loop::unprepare_c_stack() {\n         destroy_exchange_stack(kernel->region(), extra_c_stack);\n         extra_c_stack = NULL;\n     }\n+    if (extra_big_stack) {\n+        destroy_exchange_stack(kernel->region(), extra_big_stack);\n+        extra_big_stack = NULL;\n+    }\n }\n \n //"}, {"sha": "a099c5e0c74955c82409dd79c121521db4dfed0b", "filename": "src/rt/rust_sched_loop.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -67,6 +67,8 @@ struct rust_sched_loop\n \n     stk_seg *cached_c_stack;\n     stk_seg *extra_c_stack;\n+    stk_seg *cached_big_stack;\n+    stk_seg *extra_big_stack;\n \n     rust_task_list running_tasks;\n     rust_task_list blocked_tasks;\n@@ -147,6 +149,10 @@ struct rust_sched_loop\n     stk_seg *borrow_c_stack();\n     void return_c_stack(stk_seg *stack);\n \n+    // Called by tasks when they need a big stack\n+    stk_seg *borrow_big_stack();\n+    void return_big_stack(stk_seg *stack);\n+\n     int get_id() { return this->id; }\n };\n \n@@ -202,6 +208,32 @@ rust_sched_loop::return_c_stack(stk_seg *stack) {\n     }\n }\n \n+// NB: Runs on the Rust stack. Might return NULL!\n+inline stk_seg *\n+rust_sched_loop::borrow_big_stack() {\n+    assert(cached_big_stack);\n+    stk_seg *your_stack;\n+    if (extra_big_stack) {\n+        your_stack = extra_big_stack;\n+        extra_big_stack = NULL;\n+    } else {\n+        your_stack = cached_big_stack;\n+        cached_big_stack = NULL;\n+    }\n+    return your_stack;\n+}\n+\n+// NB: Runs on the Rust stack\n+inline void\n+rust_sched_loop::return_big_stack(stk_seg *stack) {\n+    assert(!extra_big_stack);\n+    assert(stack);\n+    if (!cached_big_stack)\n+        cached_big_stack = stack;\n+    else\n+        extra_big_stack = stack;\n+}\n+\n // this is needed to appease the circular dependency gods\n #include \"rust_task.h\"\n "}, {"sha": "f07690a955ea2c7e1a38998e04a7fe300aaecc19", "filename": "src/rt/rust_stack.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_stack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_stack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -13,6 +13,8 @@\n #include \"vg/valgrind.h\"\n #include \"vg/memcheck.h\"\n \n+#include <cstdio>\n+\n #ifdef _LP64\n const uintptr_t canary_value = 0xABCDABCDABCDABCD;\n #else\n@@ -61,6 +63,7 @@ create_stack(memory_region *region, size_t sz) {\n     stk_seg *stk = (stk_seg *)region->malloc(total_sz, \"stack\");\n     memset(stk, 0, sizeof(stk_seg));\n     stk->end = (uintptr_t) &stk->data[sz];\n+    stk->is_big = 0;\n     add_stack_canary(stk);\n     register_valgrind_stack(stk);\n     return stk;\n@@ -78,6 +81,7 @@ create_exchange_stack(rust_exchange_alloc *exchange, size_t sz) {\n     stk_seg *stk = (stk_seg *)exchange->malloc(total_sz);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->end = (uintptr_t) &stk->data[sz];\n+    stk->is_big = 0;\n     add_stack_canary(stk);\n     register_valgrind_stack(stk);\n     return stk;"}, {"sha": "3b34b91e309cf55ba27c7c760de7a75a87e4cd83", "filename": "src/rt/rust_stack.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_stack.h", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_stack.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_stack.h?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -22,9 +22,7 @@ struct stk_seg {\n     stk_seg *next;\n     uintptr_t end;\n     unsigned int valgrind_id;\n-#ifndef _LP64\n-    uint32_t pad;\n-#endif\n+    uint8_t is_big;\n \n     rust_task *task;\n     uintptr_t canary;"}, {"sha": "7e146cce68e7c453f75e8ca34d7f34e4ef0c06b7", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -53,7 +53,8 @@ rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n     disallow_yield(0),\n     c_stack(NULL),\n     next_c_sp(0),\n-    next_rust_sp(0)\n+    next_rust_sp(0),\n+    big_stack(NULL)\n {\n     LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n     DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n@@ -457,8 +458,9 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n         \"min: %\" PRIdPTR \" current: %\" PRIdPTR \" requested: %\" PRIdPTR,\n         min, current, requested);\n \n-    // Allocate at least enough to accomodate the next frame\n-    size_t sz = std::max(min, requested);\n+    // Allocate at least enough to accomodate the next frame, plus a little\n+    // slack to avoid thrashing\n+    size_t sz = std::max(min, requested + (requested / 2));\n \n     // And double the stack size each allocation\n     const size_t max = 1024 * 1024;\n@@ -555,13 +557,63 @@ rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left\n     // behind by calls to prev_stack\n     assert(stk);\n+\n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n-        free_stack(stk->next);\n+\n+        if (stk->next->is_big) {\n+            assert (big_stack == stk->next);\n+            sched_loop->return_big_stack(big_stack);\n+            big_stack = NULL;\n+        } else {\n+            free_stack(stk->next);\n+        }\n+\n         stk->next = new_next;\n     }\n }\n \n+// NB: Runs on the Rust stack. Returns true if we successfully allocated the big\n+// stack and false otherwise.\n+bool\n+rust_task::new_big_stack() {\n+    // If we have a cached big stack segment, use it.\n+    if (big_stack) {\n+        // Check to see if we're already on the big stack.\n+        stk_seg *ss = stk;\n+        while (ss != NULL) {\n+            if (ss == big_stack)\n+                return false;\n+            ss = ss->prev;\n+        }\n+\n+        // Unlink the big stack.\n+        if (big_stack->next)\n+            big_stack->next->prev = big_stack->prev;\n+        if (big_stack->prev)\n+            big_stack->prev->next = big_stack->next;\n+    } else {\n+        stk_seg *borrowed_big_stack = sched_loop->borrow_big_stack();\n+        if (!borrowed_big_stack) {\n+            abort();\n+        } else {\n+            big_stack = borrowed_big_stack;\n+        }\n+    }\n+\n+    big_stack->task = this;\n+    big_stack->next = stk->next;\n+    if (big_stack->next)\n+        big_stack->next->prev = big_stack;\n+    big_stack->prev = stk;\n+    if (stk)\n+        stk->next = big_stack;\n+\n+    stk = big_stack;\n+\n+    return true;\n+}\n+\n static bool\n sp_in_stk_seg(uintptr_t sp, stk_seg *stk) {\n     // Not positive these bounds for sp are correct.  I think that the first\n@@ -601,9 +653,16 @@ rust_task::delete_all_stacks() {\n     assert(stk->next == NULL);\n     while (stk != NULL) {\n         stk_seg *prev = stk->prev;\n-        free_stack(stk);\n+\n+        if (stk->is_big)\n+            sched_loop->return_big_stack(stk);\n+        else\n+            free_stack(stk);\n+\n         stk = prev;\n     }\n+\n+    big_stack = NULL;\n }\n \n /*"}, {"sha": "34d5a5a86f2d7ad313cd67c8f0ced5aabd16095b", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -133,6 +133,9 @@\n #define RZ_BSD_32   (1024*20)\n #define RZ_BSD_64   (1024*20)\n \n+// The threshold beyond which we switch to the C stack.\n+#define STACK_THRESHOLD (1024 * 1024)\n+\n #ifdef __linux__\n #ifdef __i386__\n #define RED_ZONE_SIZE RZ_LINUX_32\n@@ -263,9 +266,13 @@ rust_task : public kernel_owned<rust_task>\n     uintptr_t next_c_sp;\n     uintptr_t next_rust_sp;\n \n+    // The big stack.\n+    stk_seg *big_stack;\n+\n     // Called when the atomic refcount reaches zero\n     void delete_this();\n \n+    bool new_big_stack();\n     void new_stack_fast(size_t requested_sz);\n     void new_stack(size_t requested_sz);\n     void free_stack(stk_seg *stk);\n@@ -568,6 +575,11 @@ rust_task::new_stack_fast(size_t requested_sz) {\n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n     size_t min_sz = sched_loop->min_stack_size;\n \n+    if (requested_sz > STACK_THRESHOLD) {\n+        if (new_big_stack())\n+            return;\n+    }\n+\n     // Try to reuse an existing stack segment\n     if (stk != NULL && stk->next != NULL) {\n         size_t next_sz = user_stack_size(stk->next);"}, {"sha": "e524e6de859c84b463c1d73aa4f89e7f4aed3b63", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -191,6 +191,14 @@ rust_upcall_malloc(type_desc *td, uintptr_t size) {\n     return upcall_malloc(td, size);\n }\n \n+extern \"C\" CDECL uintptr_t\n+rust_upcall_malloc_noswitch(type_desc *td, uintptr_t size) {\n+    rust_task *task = rust_get_current_task();\n+    s_malloc_args args = {task, 0, td, size};\n+    upcall_s_malloc(&args);\n+    return args.retval;\n+}\n+\n /**********************************************************************\n  * Called whenever an object in the task-local heap is freed.\n  */\n@@ -231,6 +239,13 @@ rust_upcall_free(void* ptr) {\n     upcall_free(ptr);\n }\n \n+extern \"C\" CDECL void\n+rust_upcall_free_noswitch(void* ptr) {\n+    rust_task *task = rust_get_current_task();\n+    s_free_args args = {task,ptr};\n+    upcall_s_free(&args);\n+}\n+\n /**********************************************************************/\n \n extern \"C\" _Unwind_Reason_Code"}, {"sha": "8cf2bd4b4acb99340654dfe6f966d7562b6dead9", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -401,8 +401,7 @@ rust_uv_get_data_for_uv_handle(uv_handle_t* handle) {\n }\n \n extern \"C\" void\n-rust_uv_set_data_for_uv_handle(uv_handle_t* handle,\n-        void* data) {\n+rust_uv_set_data_for_uv_handle(uv_handle_t* handle, void* data) {\n     handle->data = data;\n }\n "}, {"sha": "cfc7abac6eb816b3228897c42f5dcddb7126163f", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -67,7 +67,9 @@ upcall_del_stack\n upcall_reset_stack_limit\n rust_upcall_fail\n rust_upcall_free\n+rust_upcall_free_noswitch\n rust_upcall_malloc\n+rust_upcall_malloc_noswitch\n rust_uv_loop_new\n rust_uv_loop_delete\n rust_uv_walk"}, {"sha": "141276e86f098f022d88f45c0e8bdf9085339f04", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -15,6 +15,8 @@\n //\n //===----------------------------------------------------------------------===\n \n+#include \"llvm/IR/InlineAsm.h\"\n+#include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Linker.h\"\n #include \"llvm/PassManager.h\"\n #include \"llvm/IR/InlineAsm.h\"\n@@ -152,7 +154,9 @@ class RustMCJITMemoryManager : public JITMemoryManager {\n                                        unsigned SectionID);\n \n   virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n-                                       unsigned SectionID);\n+                                       unsigned SectionID, bool isReadOnly);\n+\n+  virtual bool applyPermissions(std::string *Str);\n \n   virtual void *getPointerToNamedFunction(const std::string &Name,\n                                           bool AbortOnFailure = true);\n@@ -218,12 +222,6 @@ class RustMCJITMemoryManager : public JITMemoryManager {\n   virtual void deallocateExceptionTable(void *ET) {\n     llvm_unreachable(\"Unimplemented call\");\n   }\n-  virtual uint8_t* allocateDataSection(uintptr_t, unsigned int, unsigned int, bool) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual bool applyPermissions(std::string*) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n };\n \n bool RustMCJITMemoryManager::loadCrate(const char* file, std::string* err) {\n@@ -240,18 +238,24 @@ bool RustMCJITMemoryManager::loadCrate(const char* file, std::string* err) {\n }\n \n uint8_t *RustMCJITMemoryManager::allocateDataSection(uintptr_t Size,\n-                                                    unsigned Alignment,\n-                                                    unsigned SectionID) {\n+                                                     unsigned Alignment,\n+                                                     unsigned SectionID,\n+                                                     bool isReadOnly) {\n   if (!Alignment)\n     Alignment = 16;\n   uint8_t *Addr = (uint8_t*)calloc((Size + Alignment - 1)/Alignment, Alignment);\n   AllocatedDataMem.push_back(sys::MemoryBlock(Addr, Size));\n   return Addr;\n }\n \n+bool RustMCJITMemoryManager::applyPermissions(std::string *Str) {\n+    // Empty.\n+    return true;\n+}\n+\n uint8_t *RustMCJITMemoryManager::allocateCodeSection(uintptr_t Size,\n-                                                    unsigned Alignment,\n-                                                    unsigned SectionID) {\n+                                                     unsigned Alignment,\n+                                                     unsigned SectionID) {\n   if (!Alignment)\n     Alignment = 16;\n   unsigned NeedAllocate = Alignment * ((Size + Alignment - 1)/Alignment + 1);\n@@ -451,6 +455,7 @@ LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n   TargetOptions Options;\n   Options.NoFramePointerElim = true;\n   Options.EnableSegmentedStacks = EnableSegmentedStacks;\n+  Options.FixedStackSegmentSize = 2 * 1024 * 1024;  // XXX: This is too big.\n \n   PassManager *PM = unwrap<PassManager>(PMR);\n \n@@ -484,13 +489,12 @@ LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n }\n \n extern \"C\" LLVMModuleRef LLVMRustParseAssemblyFile(const char *Filename) {\n-\n   SMDiagnostic d;\n   Module *m = ParseAssemblyFile(Filename, d, getGlobalContext());\n   if (m) {\n     return wrap(m);\n   } else {\n-    LLVMRustError = d.getMessage().data();\n+    LLVMRustError = d.getMessage().str().c_str();\n     return NULL;\n   }\n }"}, {"sha": "b75aa3c909b9692aca57a8a398f70275b9023ca6", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -88,6 +88,7 @@ fn vector<M: Map<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n     }\n }\n \n+#[fixed_stack_segment]\n fn main() {\n     let args = os::args();\n     let n_keys = {"}, {"sha": "21f38245ca3593eabc53c347bf962fa82ecf9344", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -0,0 +1,95 @@\n+use core::from_str::FromStr;\n+use core::i32::range;\n+use core::vec::MutableVector;\n+\n+fn max(a: i32, b: i32) -> i32 {\n+    if a > b {\n+        a\n+    } else {\n+        b\n+    }\n+}\n+\n+#[inline(never)]\n+fn fannkuch_redux(n: i32) -> i32 {\n+    let mut perm = vec::from_elem(n as uint, 0i32);\n+    let mut perm1 = vec::from_fn(n as uint, |i| i as i32);\n+    let mut count = vec::from_elem(n as uint, 0i32);\n+    let mut max_flips_count = 0i32, perm_count = 0i32, checksum = 0i32;\n+\n+    let mut r = n;\n+    loop {\n+        unsafe {\n+            while r != 1 {\n+                count.unsafe_set((r-1) as uint, r);\n+                r -= 1;\n+            }\n+\n+            // XXX: Need each2_mut.\n+            for vec::eachi_mut(perm) |i, perm_i| {\n+                *perm_i = perm1.unsafe_get(i);\n+            }\n+\n+            let mut flips_count: i32 = 0;\n+            let mut k: i32;\n+            loop {\n+                k = perm.unsafe_get(0);\n+                if k == 0 {\n+                    break;\n+                }\n+\n+                let k2 = (k+1) >> 1;\n+                for range(0, k2) |i| {\n+                    let (perm_i, perm_k_i) = {\n+                        (perm.unsafe_get(i as uint),\n+                            perm.unsafe_get((k-i) as uint))\n+                    };\n+                    perm.unsafe_set(i as uint, perm_k_i);\n+                    perm.unsafe_set((k-i) as uint, perm_i);\n+                }\n+                flips_count += 1;\n+            }\n+\n+            max_flips_count = max(max_flips_count, flips_count);\n+            checksum += if perm_count % 2 == 0 {\n+                flips_count\n+            } else {\n+                -flips_count\n+            };\n+\n+            // Use incremental change to generate another permutation.\n+            loop {\n+                if r == n {\n+                    println(checksum.to_str());\n+                    return max_flips_count;\n+                }\n+\n+                let perm0 = perm1[0];\n+                let mut i: i32 = 0;\n+                while i < r {\n+                    let j = i + 1;\n+                    let perm1_j = { perm1.unsafe_get(j as uint) };\n+                    perm1.unsafe_set(i as uint, perm1_j);\n+                    i = j;\n+                }\n+                perm1.unsafe_set(r as uint, perm0);\n+\n+                let count_r = { count.unsafe_get(r as uint) };\n+                count.unsafe_set(r as uint, count_r - 1);\n+                if count.unsafe_get(r as uint) > 0 {\n+                    break;\n+                }\n+                r += 1;\n+            }\n+\n+            perm_count += 1;\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    println(fmt!(\"Pfannkuchen(%d) = %d\", n as int, fannkuch_redux(n) as int));\n+}\n+"}, {"sha": "675151cf6c9da8759b03f93db742375b73b9839c", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Based on Isaac Gouy's fannkuchredux.csharp\n-extern mod std;\n-\n-fn fannkuch(n: int) -> int {\n-    fn perm1init(i: uint) -> int { return i as int; }\n-\n-    let mut perm = vec::from_elem(n as uint, 0);\n-    let mut perm1 = vec::from_fn(n as uint, |i| perm1init(i));\n-    let mut count = vec::from_elem(n as uint, 0);\n-    let mut f = 0;\n-    let mut i = 0;\n-    let mut k = 0;\n-    let mut r = 0;\n-    let mut flips = 0;\n-    let mut nperm = 0;\n-    let mut checksum = 0;\n-    r = n;\n-    while r > 0 {\n-        i = 0;\n-        while r != 1 { count[r - 1] = r; r -= 1; }\n-        while i < n { perm[i] = perm1[i]; i += 1; }\n-        // Count flips and update max and checksum\n-\n-        f = 0;\n-        k = perm[0];\n-        while k != 0 {\n-            i = 0;\n-            while 2 * i < k {\n-                let t = perm[i];\n-                perm[i] = perm[k - i];\n-                perm[k - i] = t;\n-                i += 1;\n-            }\n-            k = perm[0];\n-            f += 1;\n-        }\n-        if f > flips { flips = f; }\n-        if nperm & 0x1 == 0 { checksum += f; } else { checksum -= f; }\n-        // Use incremental change to generate another permutation\n-\n-        let mut go = true;\n-        while go {\n-            if r == n {\n-                io::println(fmt!(\"%d\", checksum));\n-                return flips;\n-            }\n-            let p0 = perm1[0];\n-            i = 0;\n-            while i < r { let j = i + 1; perm1[i] = perm1[j]; i = j; }\n-            perm1[r] = p0;\n-            count[r] -= 1;\n-            if count[r] > 0 { go = false; } else { r += 1; }\n-        }\n-        nperm += 1;\n-    }\n-    return flips;\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"10\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"8\"]\n-    } else {\n-        args\n-    };\n-\n-    let n = int::from_str(args[1]).get();\n-    io::println(fmt!(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n-}"}, {"sha": "5cb04fcd27a8f1ded9843ec1a90534ce68d41977", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -0,0 +1,204 @@\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::libc::{FILE, STDOUT_FILENO, c_int, fdopen, fputc, fputs, fwrite};\n+use core::uint::{min, range};\n+use core::vec::bytes::copy_memory;\n+\n+static LINE_LEN: uint = 60;\n+static LOOKUP_SIZE: uint = 4 * 1024;\n+static LOOKUP_SCALE: f32 = (LOOKUP_SIZE - 1) as f32;\n+\n+// Random number generator constants\n+static IM: u32 = 139968;\n+static IA: u32 = 3877;\n+static IC: u32 = 29573;\n+\n+static ALU: &'static str = \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTG\\\n+                            GGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGA\\\n+                            GACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAA\\\n+                            AATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAAT\\\n+                            CCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAAC\\\n+                            CCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTG\\\n+                            CACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+static NULL_AMINO_ACID: AminoAcid = AminoAcid { c: ' ' as u8, p: 0.0 };\n+\n+static MESSAGE_1: &'static str = \">ONE Homo sapiens alu\\n\";\n+static MESSAGE_2: &'static str = \">TWO IUB ambiguity codes\\n\";\n+static MESSAGE_3: &'static str = \">THREE Homo sapiens frequency\\n\";\n+\n+static IUB: [AminoAcid, ..15] = [\n+    AminoAcid { c: 'a' as u8, p: 0.27 },\n+    AminoAcid { c: 'c' as u8, p: 0.12 },\n+    AminoAcid { c: 'g' as u8, p: 0.12 },\n+    AminoAcid { c: 't' as u8, p: 0.27 },\n+    AminoAcid { c: 'B' as u8, p: 0.02 },\n+    AminoAcid { c: 'D' as u8, p: 0.02 },\n+    AminoAcid { c: 'H' as u8, p: 0.02 },\n+    AminoAcid { c: 'K' as u8, p: 0.02 },\n+    AminoAcid { c: 'M' as u8, p: 0.02 },\n+    AminoAcid { c: 'N' as u8, p: 0.02 },\n+    AminoAcid { c: 'R' as u8, p: 0.02 },\n+    AminoAcid { c: 'S' as u8, p: 0.02 },\n+    AminoAcid { c: 'V' as u8, p: 0.02 },\n+    AminoAcid { c: 'W' as u8, p: 0.02 },\n+    AminoAcid { c: 'Y' as u8, p: 0.02 },\n+];\n+\n+static HOMO_SAPIENS: [AminoAcid, ..4] = [\n+    AminoAcid { c: 'a' as u8, p: 0.3029549426680 },\n+    AminoAcid { c: 'c' as u8, p: 0.1979883004921 },\n+    AminoAcid { c: 'g' as u8, p: 0.1975473066391 },\n+    AminoAcid { c: 't' as u8, p: 0.3015094502008 },\n+];\n+\n+// XXX: Use map().\n+fn sum_and_scale(a: &'static [AminoAcid]) -> ~[AminoAcid] {\n+    let mut result = ~[];\n+    let mut p = 0f32;\n+    for a.each |a_i| {\n+        let mut a_i = *a_i;\n+        p += a_i.p;\n+        a_i.p = p * LOOKUP_SCALE;\n+        result.push(a_i);\n+    }\n+    result[result.len() - 1].p = LOOKUP_SCALE;\n+    result\n+}\n+\n+struct AminoAcid {\n+    c: u8,\n+    p: f32,\n+}\n+\n+struct RepeatFasta {\n+    alu: &'static str,\n+    stdout: *FILE,\n+}\n+\n+impl RepeatFasta {\n+    fn new(stdout: *FILE, alu: &'static str) -> RepeatFasta {\n+        RepeatFasta {\n+            alu: alu,\n+            stdout: stdout,\n+        }\n+    }\n+\n+    fn make(&mut self, n: uint) {\n+        unsafe {\n+            let stdout = self.stdout;\n+            let alu_len = self.alu.len();\n+            let mut buf = vec::from_elem(alu_len + LINE_LEN, 0u8);\n+            let alu: &[u8] = str::byte_slice_no_callback(self.alu);\n+\n+            copy_memory(buf, alu, alu_len);\n+            copy_memory(vec::mut_slice(buf, alu_len, buf.len()),\n+                        alu,\n+                        LINE_LEN);\n+\n+            let mut pos = 0, bytes, n = n;\n+            while n > 0 {\n+                bytes = min(LINE_LEN, n);\n+                fwrite(transmute(&buf[pos]), bytes as u64, 1, stdout);\n+                fputc('\\n' as c_int, stdout);\n+                pos += bytes;\n+                if pos > alu_len {\n+                    pos -= alu_len;\n+                }\n+                n -= bytes;\n+            }\n+        }\n+    }\n+}\n+\n+struct RandomFasta {\n+    seed: u32,\n+    stdout: *FILE,\n+    lookup: [AminoAcid, ..LOOKUP_SIZE],\n+}\n+\n+impl RandomFasta {\n+    fn new(stdout: *FILE, a: &[AminoAcid]) -> RandomFasta {\n+        RandomFasta {\n+            seed: 42,\n+            stdout: stdout,\n+            lookup: RandomFasta::make_lookup(a),\n+        }\n+    }\n+\n+    fn make_lookup(a: &[AminoAcid]) -> [AminoAcid, ..LOOKUP_SIZE] {\n+        let mut lookup = [ NULL_AMINO_ACID, ..LOOKUP_SIZE ];\n+        let mut j = 0;\n+        for vec::eachi_mut(lookup) |i, slot| {\n+            while a[j].p < (i as f32) {\n+                j += 1;\n+            }\n+            *slot = a[j];\n+        }\n+        lookup\n+    }\n+\n+    fn rng(&mut self, max: f32) -> f32 {\n+        self.seed = (self.seed * IA + IC) % IM;\n+        max * (self.seed as f32) / (IM as f32)\n+    }\n+\n+    fn nextc(&mut self) -> u8 {\n+        let r = self.rng(1.0);\n+        for self.lookup.each |a| {\n+            if a.p >= r {\n+                return a.c;\n+            }\n+        }\n+        0\n+    }\n+\n+    fn make(&mut self, n: uint) {\n+        unsafe {\n+            let lines = n / LINE_LEN, chars_left = n % LINE_LEN;\n+            let mut buf = [0, ..LINE_LEN + 1];\n+\n+            for lines.times {\n+                for range(0, LINE_LEN) |i| {\n+                    buf[i] = self.nextc();\n+                }\n+                buf[LINE_LEN] = '\\n' as u8;\n+                fwrite(transmute(&buf[0]),\n+                       LINE_LEN as u64 + 1,\n+                       1,\n+                       self.stdout);\n+            }\n+            for range(0, chars_left) |i| {\n+                buf[i] = self.nextc();\n+            }\n+            fwrite(transmute(&buf[0]), chars_left as u64, 1, self.stdout);\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: uint = FromStr::from_str(os::args()[1]).get();\n+\n+    unsafe {\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        fputs(transmute(&MESSAGE_1[0]), stdout);\n+        let mut repeat = RepeatFasta::new(stdout, ALU);\n+        repeat.make(n * 2);\n+\n+        fputs(transmute(&MESSAGE_2[0]), stdout);\n+        let iub = sum_and_scale(IUB);\n+        let mut random = RandomFasta::new(stdout, iub);\n+        random.make(n * 3);\n+\n+        fputs(transmute(&MESSAGE_3[0]), stdout);\n+        let homo_sapiens = sum_and_scale(HOMO_SAPIENS);\n+        random.lookup = RandomFasta::make_lookup(homo_sapiens);\n+        random.make(n * 5);\n+\n+        fputc('\\n' as c_int, stdout);\n+    }\n+}\n+"}, {"sha": "224885a3f79b15f0e9c64f4cf8b6690fe56a636f", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -0,0 +1,316 @@\n+// xfail-test\n+\n+extern mod std;\n+\n+use core::cast::transmute;\n+use core::i32::range;\n+use core::libc::{STDIN_FILENO, c_int, fdopen, fgets, fileno, fopen, fstat};\n+use core::libc::{stat, strlen};\n+use core::ptr::null;\n+use core::unstable::intrinsics::init;\n+use core::vec::{reverse, slice};\n+use std::sort::quick_sort3;\n+\n+static LINE_LEN: uint = 80;\n+static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n+static TABLE_SIZE: uint = 2 << 16;\n+\n+static OCCURRENCES: [&'static str, ..5] = [\n+    \"GGT\",\n+    \"GGTA\",\n+    \"GGTATT\",\n+    \"GGTATTTTAATT\",\n+    \"GGTATTTTAATTTATAGT\",\n+];\n+\n+// Code implementation\n+\n+#[deriving(Eq, Ord)]\n+struct Code(u64);\n+\n+impl Code {\n+    fn hash(&self) -> u64 {\n+        **self\n+    }\n+\n+    #[inline(always)]\n+    fn push_char(&self, c: u8) -> Code {\n+        Code((**self << 2) + (pack_symbol(c) as u64))\n+    }\n+\n+    fn rotate(&self, c: u8, frame: i32) -> Code {\n+        Code(*self.push_char(c) & ((1u64 << (2 * (frame as u64))) - 1))\n+    }\n+\n+    fn pack(string: &str) -> Code {\n+        let mut code = Code(0u64);\n+        for uint::range(0, string.len()) |i| {\n+            code = code.push_char(string[i]);\n+        }\n+        code\n+    }\n+\n+    // XXX: Inefficient.\n+    fn unpack(&self, frame: i32) -> ~str {\n+        let mut key = **self;\n+        let mut result = ~[];\n+        for (frame as uint).times {\n+            result.push(unpack_symbol((key as u8) & 3));\n+            key >>= 2;\n+        }\n+\n+        reverse(result);\n+        str::from_bytes(result)\n+    }\n+}\n+\n+// Hash table implementation\n+\n+trait TableCallback {\n+    fn f(&self, entry: &mut Entry);\n+}\n+\n+struct BumpCallback;\n+\n+impl TableCallback for BumpCallback {\n+    fn f(&self, entry: &mut Entry) {\n+        entry.count += 1;\n+    }\n+}\n+\n+struct PrintCallback(&'static str);\n+\n+impl TableCallback for PrintCallback {\n+    fn f(&self, entry: &mut Entry) {\n+        println(fmt!(\"%d\\t%s\", entry.count as int, **self));\n+    }\n+}\n+\n+struct Entry {\n+    code: Code,\n+    count: i32,\n+    next: Option<~Entry>,\n+}\n+\n+struct Table {\n+    count: i32,\n+    items: [Option<~Entry>, ..TABLE_SIZE]\n+}\n+\n+impl Table {\n+    fn new() -> Table {\n+        Table {\n+            count: 0,\n+            items: [ None, ..TABLE_SIZE ],\n+        }\n+    }\n+\n+    fn search_remainder<C:TableCallback>(item: &mut Entry, key: Code, c: C) {\n+        match item.next {\n+            None => {\n+                let mut entry = ~Entry {\n+                    code: key,\n+                    count: 0,\n+                    next: None,\n+                };\n+                c.f(entry);\n+                item.next = Some(entry);\n+            }\n+            Some(ref mut entry) => {\n+                if entry.code == key {\n+                    c.f(*entry);\n+                    return;\n+                }\n+\n+                Table::search_remainder(*entry, key, c)\n+            }\n+        }\n+    }\n+\n+    fn lookup<C:TableCallback>(&mut self, key: Code, c: C) {\n+        let index = *key % (TABLE_SIZE as u64);\n+\n+        {\n+            if self.items[index].is_none() {\n+                let mut entry = ~Entry {\n+                    code: key,\n+                    count: 0,\n+                    next: None,\n+                };\n+                c.f(entry);\n+                self.items[index] = Some(entry);\n+                return;\n+            }\n+        }\n+\n+        {\n+            let mut entry = &mut *self.items[index].get_mut_ref();\n+            if entry.code == key {\n+                c.f(*entry);\n+                return;\n+            }\n+\n+            Table::search_remainder(*entry, key, c)\n+        }\n+    }\n+\n+    fn each(&self, f: &fn(entry: &Entry) -> bool) {\n+        for self.items.each |item| {\n+            match *item {\n+                None => {}\n+                Some(ref item) => {\n+                    let mut item: &Entry = *item;\n+                    loop {\n+                        if !f(item) {\n+                            return;\n+                        }\n+\n+                        match item.next {\n+                            None => break,\n+                            Some(ref next_item) => item = &**next_item,\n+                        }\n+                    }\n+                }\n+            };\n+        }\n+    }\n+}\n+\n+// Main program\n+\n+fn pack_symbol(c: u8) -> u8 {\n+    match c {\n+        'a' as u8 | 'A' as u8 => 0,\n+        'c' as u8 | 'C' as u8 => 1,\n+        'g' as u8 | 'G' as u8 => 2,\n+        't' as u8 | 'T' as u8 => 3,\n+        _ => fail!(c.to_str())\n+    }\n+}\n+\n+fn unpack_symbol(c: u8) -> u8 {\n+    TABLE[c]\n+}\n+\n+fn next_char<'a>(mut buf: &'a [u8]) -> &'a [u8] {\n+    loop {\n+        buf = slice(buf, 1, buf.len());\n+        if buf.len() == 0 {\n+            break;\n+        }\n+        if buf[0] != (' ' as u8) && buf[0] != ('\\t' as u8) &&\n+                buf[0] != ('\\n' as u8) && buf[0] != 0 {\n+            break;\n+        }\n+    }\n+    buf\n+}\n+\n+#[inline(never)]\n+fn read_stdin() -> ~[u8] {\n+    unsafe {\n+        let mode = \"r\";\n+        //let stdin = fdopen(STDIN_FILENO as c_int, transmute(&mode[0]));\n+        let path = \"knucleotide-input.txt\";\n+        let stdin = fopen(transmute(&path[0]), transmute(&mode[0]));\n+\n+        let mut st: stat = init();\n+        fstat(fileno(stdin), &mut st);\n+        let mut buf = vec::from_elem(st.st_size as uint, 0);\n+\n+        let header = str::byte_slice_no_callback(\">THREE\");\n+        let header = vec::slice(header, 0, 6);\n+\n+        {\n+            let mut window: &mut [u8] = buf;\n+            loop {\n+                fgets(transmute(&mut window[0]), LINE_LEN as c_int, stdin);\n+\n+                {\n+                    if vec::slice(window, 0, 6) == header {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            while fgets(transmute(&mut window[0]),\n+                        LINE_LEN as c_int,\n+                        stdin) != null() {\n+                window = vec::mut_slice(window,\n+                                        strlen(transmute(&window[0])) as uint,\n+                                        window.len());\n+            }\n+        }\n+\n+        buf\n+    }\n+}\n+\n+#[inline(never)]\n+#[fixed_stack_segment]\n+fn generate_frequencies(frequencies: &mut Table,\n+                        mut input: &[u8],\n+                        frame: i32) {\n+    let mut code = Code(0);\n+    \n+    // Pull first frame.\n+    for (frame as uint).times {\n+        code = code.push_char(input[0]);\n+        input = next_char(input);\n+    }\n+    frequencies.lookup(code, BumpCallback);\n+\n+    while input.len() != 0 && input[0] != ('>' as u8) {\n+        code = code.rotate(input[0], frame);\n+        frequencies.lookup(code, BumpCallback);\n+        input = next_char(input);\n+    }\n+}\n+\n+#[inline(never)]\n+#[fixed_stack_segment]\n+fn print_frequencies(frequencies: &Table, frame: i32) {\n+    let mut vector = ~[];\n+    for frequencies.each |entry| {\n+        vector.push((entry.code, entry.count));\n+    }\n+    quick_sort3(vector);\n+\n+    let mut total_count = 0;\n+    for vector.each |&(_, count)| {\n+        total_count += count;\n+    }\n+\n+    for vector.each |&(key, count)| {\n+        println(fmt!(\"%s %.3f\",\n+                     key.unpack(frame),\n+                     (count as float * 100.0) / (total_count as float)));\n+    }\n+}\n+\n+fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n+    frequencies.lookup(Code::pack(occurrence), PrintCallback(occurrence))\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let input = read_stdin();\n+\n+    let mut frequencies = ~Table::new();\n+    generate_frequencies(frequencies, input, 1);\n+    print_frequencies(frequencies, 1);\n+\n+    *frequencies = Table::new();\n+    generate_frequencies(frequencies, input, 2);\n+    print_frequencies(frequencies, 2);\n+\n+    for range(0, 5) |i| {\n+        let occurrence = OCCURRENCES[i];\n+        *frequencies = Table::new();\n+        generate_frequencies(frequencies,\n+                             input,\n+                             occurrence.len() as i32);\n+        print_occurrences(frequencies, occurrence);\n+    }\n+}\n+"}, {"sha": "e62cb8ea849d1dbbbb59dde4f9f8798c618e6132", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 53, "deletions": 175, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1,182 +1,60 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::i32::range;\n+use core::libc::{STDOUT_FILENO, c_int, fdopen, fputc};\n \n-//  based on:\n-//  http://shootout.alioth.debian.org/\n-//   u64q/program.php?test=mandelbrot&lang=python3&id=2\n-//\n-//  takes 3 optional args:\n-//   square image size, defaults to 80_u\n-//   output path, default is \"\" (no output), \"-\" means stdout\n-//   depth (max iterations per pixel), defaults to 50_u\n-//\n-//  in the shootout, they use 16000 as image size, 50 as depth,\n-//   and write to stdout:\n-//\n-//  ./shootout_mandelbrot 16000 \"-\" 50 > /tmp/mandel.pbm\n-//\n-//  writes pbm image to output path\n+static ITER: uint = 50;\n+static LIMIT: f64 = 2.0;\n \n-use core::io::WriterUtil;\n-use core::hashmap::HashMap;\n-\n-struct cmplx {\n-    re: f64,\n-    im: f64\n-}\n-\n-impl ops::Mul<cmplx,cmplx> for cmplx {\n-    fn mul(&self, x: &cmplx) -> cmplx {\n-        cmplx {\n-            re: self.re*(*x).re - self.im*(*x).im,\n-            im: self.re*(*x).im + self.im*(*x).re\n-        }\n-    }\n-}\n-\n-impl ops::Add<cmplx,cmplx> for cmplx {\n-    fn add(&self, x: &cmplx) -> cmplx {\n-        cmplx {\n-            re: self.re + (*x).re,\n-            im: self.im + (*x).im\n-        }\n-    }\n-}\n-\n-struct Line {i: uint, b: ~[u8]}\n-\n-fn cabs(x: cmplx) -> f64\n-{\n-    x.re*x.re + x.im*x.im\n-}\n-\n-fn mb(x: cmplx, depth: uint) -> bool\n-{\n-    let mut z = x;\n-    let mut i = 0;\n-    while i < depth {\n-        if cabs(z) >= 4_f64 {\n-            return false;\n-        }\n-        z = z*z + x;\n-        i += 1;\n-    }\n-    true\n-}\n-\n-fn fillbyte(x: cmplx, incr: f64, depth: uint) -> u8 {\n-    let mut rv = 0_u8;\n-    let mut i = 0_u8;\n-    while i < 8_u8 {\n-        let z = cmplx {re: x.re + (i as f64)*incr, im: x.im};\n-        if mb(z, depth) {\n-            rv += 1_u8 << (7_u8 - i);\n-        }\n-        i += 1_u8;\n-    }\n-    rv\n-}\n-\n-fn chanmb(i: uint, size: uint, depth: uint) -> Line\n-{\n-    let bsize = size/8_u;\n-    let mut crv = vec::with_capacity(bsize);\n-    let incr = 2_f64/(size as f64);\n-    let y = incr*(i as f64) - 1_f64;\n-    let xincr = 8_f64*incr;\n-    for uint::range(0_u, bsize) |j| {\n-        let x = cmplx {re: xincr*(j as f64) - 1.5_f64, im: y};\n-        crv.push(fillbyte(x, incr, depth));\n-    };\n-    Line {i:i, b:crv}\n-}\n-\n-struct Devnull();\n-\n-impl io::Writer for Devnull {\n-    fn write(&self, _b: &const [u8]) {}\n-    fn seek(&self, _i: int, _s: io::SeekStyle) {}\n-    fn tell(&self) -> uint {0_u}\n-    fn flush(&self) -> int {0}\n-    fn get_type(&self) -> io::WriterType { io::File }\n-}\n-\n-fn writer(path: ~str, pport: comm::Port<Line>, size: uint)\n-{\n-    let cout: @io::Writer = match path {\n-        ~\"\" => {\n-            @Devnull as @io::Writer\n-        }\n-        ~\"-\" => {\n-            io::stdout()\n-        }\n-        _ => {\n-            result::get(\n-                &io::file_writer(&Path(path),\n-                ~[io::Create, io::Truncate]))\n-        }\n-    };\n-    cout.write_line(\"P4\");\n-    cout.write_line(fmt!(\"%u %u\", size, size));\n-    let mut lines: HashMap<uint, Line> = HashMap::new();\n-    let mut done = 0_u;\n-    let mut i = 0_u;\n-    while i < size {\n-        let aline = pport.recv();\n-        if aline.i == done {\n-            debug!(\"W %u\", done);\n-            cout.write(aline.b);\n-            done += 1_u;\n-            let mut prev = done;\n-            while prev <= i {\n-                match lines.pop(&prev) {\n-                    Some(pl) => {\n-                        debug!(\"WS %u\", prev);\n-                        cout.write(pl.b);\n-                        done += 1_u;\n-                        prev += 1_u;\n+#[fixed_stack_segment]\n+fn main() {\n+    unsafe {\n+        let w: i32 = FromStr::from_str(os::args()[1]).get(), h = w;\n+        let mut byte_acc: i8 = 0;\n+        let mut bit_num: i32 = 0;\n+\n+        println(fmt!(\"P4\\n%d %d\", w as int, h as int));\n+\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        for range(0, h) |y| {\n+            let y = y as f64;\n+            for range(0, w) |x| {\n+                let mut (Zr, Zi, Tr, Ti) = (0f64, 0f64, 0f64, 0f64);\n+                let Cr = 2.0 * (x as f64) / (w as f64) - 1.5;\n+                let Ci = 2.0 * (y as f64) / (h as f64) - 1.0;\n+\n+                for ITER.times {\n+                    if Tr + Ti > LIMIT * LIMIT {\n+                        break;\n                     }\n-                    None => break\n-                };\n-            };\n+\n+                    Zi = 2.0*Zr*Zi + Ci;\n+                    Zr = Tr - Ti + Cr;\n+                    Tr = Zr * Zr;\n+                    Ti = Zi * Zi;\n+                }\n+\n+                byte_acc <<= 1;\n+                if Tr + Ti <= LIMIT * LIMIT {\n+                    byte_acc |= 1;\n+                }\n+\n+                bit_num += 1;\n+\n+                if bit_num == 8 {\n+                    fputc(byte_acc as c_int, stdout);\n+                    byte_acc = 0;\n+                    bit_num = 0;\n+                } else if x == w - 1 {\n+                    byte_acc <<= 8 - w%8;\n+                    fputc(byte_acc as c_int, stdout);\n+                    byte_acc = 0;\n+                    bit_num = 0;\n+                }\n+            }\n         }\n-        else {\n-            debug!(\"S %u\", aline.i);\n-            lines.insert(aline.i, aline);\n-        };\n-        i += 1_u;\n     }\n }\n \n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"4000\", ~\"50\"]\n-    } else {\n-        args\n-    };\n-\n-    let depth = if vec::len(args) < 4_u { 50_u }\n-    else { uint::from_str(args[3]).get() };\n-\n-    let path = if vec::len(args) < 3_u { ~\"\" }\n-    else { copy args[2] };  // FIXME: bad for perf\n-\n-    let size = if vec::len(args) < 2_u { 80_u }\n-    else { uint::from_str(args[1]).get() };\n-\n-    let (pport, pchan) = comm::stream();\n-    let pchan = comm::SharedChan::new(pchan);\n-    for uint::range(0_u, size) |j| {\n-        let cchan = pchan.clone();\n-        do task::spawn { cchan.send(chanmb(j, size, depth)) };\n-    };\n-    writer(path, pport, size);\n-}"}, {"sha": "e633f307bc227295df41cd51bd69c0965335bc1e", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 129, "deletions": 233, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1,254 +1,150 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// based on:\n-// http://shootout.alioth.debian.org/u32/benchmark.php?test=nbody&lang=java\n-\n-extern mod std;\n-\n-use core::os;\n-\n-// Using sqrt from the standard library is way slower than using libc\n-// directly even though std just calls libc, I guess it must be\n-// because the the indirection through another dynamic linker\n-// stub. Kind of shocking. Might be able to make it faster still with\n-// an llvm intrinsic.\n-mod libc {\n-    #[nolink]\n-    pub extern {\n-        pub fn sqrt(n: float) -> float;\n-    }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"4000000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"100000\"]\n-    } else {\n-        args\n-    };\n-    let n = int::from_str(args[1]).get();\n-    let mut bodies: ~[Body::Props] = NBodySystem::make();\n-    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n-    let mut i = 0;\n-    while i < n {\n-        NBodySystem::advance(bodies, 0.01);\n-        i += 1;\n-    }\n-    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n+use core::from_str::FromStr;\n+use core::uint::range;\n+use core::unstable::intrinsics::sqrtf64;\n+\n+static PI: f64 = 3.141592653589793;\n+static SOLAR_MASS: f64 = 4.0 * PI * PI;\n+static YEAR: f64 = 365.24;\n+static N_BODIES: uint = 5;\n+\n+static BODIES: [Planet, ..N_BODIES] = [\n+    // Sun\n+    Planet {\n+        x: [ 0.0, 0.0, 0.0 ],\n+        v: [ 0.0, 0.0, 0.0 ],\n+        mass: SOLAR_MASS,\n+    },\n+    // Jupiter\n+    Planet {\n+        x: [\n+            4.84143144246472090e+00,\n+            -1.16032004402742839e+00,\n+            -1.03622044471123109e-01,\n+        ],\n+        v: [\n+            1.66007664274403694e-03 * YEAR,\n+            7.69901118419740425e-03 * YEAR,\n+            -6.90460016972063023e-05 * YEAR,\n+        ],\n+        mass: 9.54791938424326609e-04 * SOLAR_MASS,\n+    },\n+    // Saturn\n+    Planet {\n+        x: [\n+            8.34336671824457987e+00,\n+            4.12479856412430479e+00,\n+            -4.03523417114321381e-01,\n+        ],\n+        v: [\n+            -2.76742510726862411e-03 * YEAR,\n+            4.99852801234917238e-03 * YEAR,\n+            2.30417297573763929e-05 * YEAR,\n+        ],\n+        mass: 2.85885980666130812e-04 * SOLAR_MASS,\n+    },\n+    // Uranus\n+    Planet {\n+        x: [\n+            1.28943695621391310e+01,\n+            -1.51111514016986312e+01,\n+            -2.23307578892655734e-01,\n+        ],\n+        v: [\n+            2.96460137564761618e-03 * YEAR,\n+            2.37847173959480950e-03 * YEAR,\n+            -2.96589568540237556e-05 * YEAR,\n+        ],\n+        mass: 4.36624404335156298e-05 * SOLAR_MASS,\n+    },\n+    // Neptune\n+    Planet {\n+        x: [\n+            1.53796971148509165e+01,\n+            -2.59193146099879641e+01,\n+            1.79258772950371181e-01,\n+        ],\n+        v: [\n+            2.68067772490389322e-03 * YEAR,\n+            1.62824170038242295e-03 * YEAR,\n+            -9.51592254519715870e-05 * YEAR,\n+        ],\n+        mass: 5.15138902046611451e-05 * SOLAR_MASS,\n+    },\n+];\n+\n+struct Planet {\n+    x: [f64, ..3],\n+    v: [f64, ..3],\n+    mass: f64,\n }\n \n-pub mod NBodySystem {\n-    use Body;\n-\n-    pub fn make() -> ~[Body::Props] {\n-        let mut bodies: ~[Body::Props] =\n-            ~[Body::sun(),\n-              Body::jupiter(),\n-              Body::saturn(),\n-              Body::uranus(),\n-              Body::neptune()];\n-\n-        let mut px = 0.0;\n-        let mut py = 0.0;\n-        let mut pz = 0.0;\n-\n-        let mut i = 0;\n-        while i < 5 {\n-            px += bodies[i].vx * bodies[i].mass;\n-            py += bodies[i].vy * bodies[i].mass;\n-            pz += bodies[i].vz * bodies[i].mass;\n-\n-            i += 1;\n-        }\n-\n-        // side-effecting\n-        Body::offset_momentum(&mut bodies[0], px, py, pz);\n-\n-        return bodies;\n-    }\n-\n-    pub fn advance(bodies: &mut [Body::Props], dt: float) {\n-        let mut i = 0;\n-        while i < 5 {\n-            let mut j = i + 1;\n-            while j < 5 {\n-                advance_one(&mut bodies[i],\n-                            &mut bodies[j], dt);\n-                j += 1;\n+fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n+    let mut d = [ 0.0, ..3 ];\n+    for (steps as uint).times {\n+        for range(0, N_BODIES) |i| {\n+            for range(i + 1, N_BODIES) |j| {\n+                d[0] = bodies[i].x[0] - bodies[j].x[0];\n+                d[1] = bodies[i].x[1] - bodies[j].x[1];\n+                d[2] = bodies[i].x[2] - bodies[j].x[2];\n+\n+                let d2 = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];\n+                let mag = dt / (d2 * sqrtf64(d2));\n+\n+                let a_mass = bodies[i].mass, b_mass = bodies[j].mass;\n+                bodies[i].v[0] -= d[0] * b_mass * mag;\n+                bodies[i].v[1] -= d[1] * b_mass * mag;\n+                bodies[i].v[2] -= d[2] * b_mass * mag;\n+\n+                bodies[j].v[0] += d[0] * a_mass * mag;\n+                bodies[j].v[1] += d[1] * a_mass * mag;\n+                bodies[j].v[2] += d[2] * a_mass * mag;\n             }\n-\n-            i += 1;\n         }\n \n-        i = 0;\n-        while i < 5 {\n-            move_(&mut bodies[i], dt);\n-            i += 1;\n+        for vec::each_mut(*bodies) |a| {\n+            a.x[0] += dt * a.v[0];\n+            a.x[1] += dt * a.v[1];\n+            a.x[2] += dt * a.v[2];\n         }\n     }\n+}\n \n-    pub fn advance_one(bi: &mut Body::Props,\n-                       bj: &mut Body::Props,\n-                       dt: float) {\n-        unsafe {\n-            let dx = bi.x - bj.x;\n-            let dy = bi.y - bj.y;\n-            let dz = bi.z - bj.z;\n-\n-            let dSquared = dx * dx + dy * dy + dz * dz;\n-\n-            let distance = ::libc::sqrt(dSquared);\n-            let mag = dt / (dSquared * distance);\n-\n-            bi.vx -= dx * bj.mass * mag;\n-            bi.vy -= dy * bj.mass * mag;\n-            bi.vz -= dz * bj.mass * mag;\n-\n-            bj.vx += dx * bi.mass * mag;\n-            bj.vy += dy * bi.mass * mag;\n-            bj.vz += dz * bi.mass * mag;\n+fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n+    let mut e = 0.0;\n+    let mut d = [ 0.0, ..3 ];\n+    for range(0, N_BODIES) |i| {\n+        for range(0, 3) |k| {\n+            e += bodies[i].mass * bodies[i].v[k] * bodies[i].v[k] / 2.0;\n         }\n-    }\n-\n-    pub fn move_(b: &mut Body::Props, dt: float) {\n-        b.x += dt * b.vx;\n-        b.y += dt * b.vy;\n-        b.z += dt * b.vz;\n-    }\n \n-    pub fn energy(bodies: &[Body::Props]) -> float {\n-        unsafe {\n-            let mut dx;\n-            let mut dy;\n-            let mut dz;\n-            let mut distance;\n-            let mut e = 0.0;\n-\n-            let mut i = 0;\n-            while i < 5 {\n-                e +=\n-                    0.5 * bodies[i].mass *\n-                    (bodies[i].vx * bodies[i].vx\n-                     + bodies[i].vy * bodies[i].vy\n-                     + bodies[i].vz * bodies[i].vz);\n-\n-                let mut j = i + 1;\n-                while j < 5 {\n-                    dx = bodies[i].x - bodies[j].x;\n-                    dy = bodies[i].y - bodies[j].y;\n-                    dz = bodies[i].z - bodies[j].z;\n-\n-                    distance = ::libc::sqrt(dx * dx\n-                                            + dy * dy\n-                                            + dz * dz);\n-                    e -= bodies[i].mass\n-                        * bodies[j].mass / distance;\n-\n-                    j += 1;\n-                }\n-\n-                i += 1;\n+        for range(i + 1, N_BODIES) |j| {\n+            for range(0, 3) |k| {\n+                d[k] = bodies[i].x[k] - bodies[j].x[k];\n             }\n-            return e;\n+            let dist = sqrtf64(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);\n+            e -= bodies[i].mass * bodies[j].mass / dist;\n         }\n     }\n+    e\n }\n \n-pub mod Body {\n-    use Body;\n-\n-    pub static PI: float = 3.141592653589793;\n-    pub static SOLAR_MASS: float = 39.478417604357432;\n-    // was 4 * PI * PI originally\n-    pub static DAYS_PER_YEAR: float = 365.24;\n-\n-    pub struct Props {\n-        x: float,\n-        y: float,\n-        z: float,\n-        vx: float,\n-        vy: float,\n-        vz: float,\n-        mass: float\n-    }\n-\n-    pub fn jupiter() -> Body::Props {\n-        return Props {\n-            x: 4.84143144246472090e+00,\n-            y: -1.16032004402742839e+00,\n-            z: -1.03622044471123109e-01,\n-            vx: 1.66007664274403694e-03 * DAYS_PER_YEAR,\n-            vy: 7.69901118419740425e-03 * DAYS_PER_YEAR,\n-            vz: -6.90460016972063023e-05 * DAYS_PER_YEAR,\n-            mass: 9.54791938424326609e-04 * SOLAR_MASS\n-        };\n-    }\n-\n-    pub fn saturn() -> Body::Props {\n-        return Props {\n-            x: 8.34336671824457987e+00,\n-            y: 4.12479856412430479e+00,\n-            z: -4.03523417114321381e-01,\n-            vx: -2.76742510726862411e-03 * DAYS_PER_YEAR,\n-            vy: 4.99852801234917238e-03 * DAYS_PER_YEAR,\n-            vz: 2.30417297573763929e-05 * DAYS_PER_YEAR,\n-            mass: 2.85885980666130812e-04 * SOLAR_MASS\n-        };\n-    }\n-\n-    pub fn uranus() -> Body::Props {\n-        return Props {\n-            x: 1.28943695621391310e+01,\n-            y: -1.51111514016986312e+01,\n-            z: -2.23307578892655734e-01,\n-            vx: 2.96460137564761618e-03 * DAYS_PER_YEAR,\n-            vy: 2.37847173959480950e-03 * DAYS_PER_YEAR,\n-            vz: -2.96589568540237556e-05 * DAYS_PER_YEAR,\n-            mass: 4.36624404335156298e-05 * SOLAR_MASS\n-        };\n+fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n+    for range(0, N_BODIES) |i| {\n+        for range(0, 3) |k| {\n+            bodies[0].v[k] -= bodies[i].v[k] * bodies[i].mass / SOLAR_MASS;\n+        }\n     }\n+}\n \n-    pub fn neptune() -> Body::Props {\n-        return Props {\n-            x: 1.53796971148509165e+01,\n-            y: -2.59193146099879641e+01,\n-            z: 1.79258772950371181e-01,\n-            vx: 2.68067772490389322e-03 * DAYS_PER_YEAR,\n-            vy: 1.62824170038242295e-03 * DAYS_PER_YEAR,\n-            vz: -9.51592254519715870e-05 * DAYS_PER_YEAR,\n-            mass: 5.15138902046611451e-05 * SOLAR_MASS\n-        };\n-    }\n+fn main() {\n+    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let mut bodies = BODIES;\n \n-    pub fn sun() -> Body::Props {\n-        return Props {\n-            x: 0.0,\n-            y: 0.0,\n-            z: 0.0,\n-            vx: 0.0,\n-            vy: 0.0,\n-            vz: 0.0,\n-            mass: SOLAR_MASS\n-        };\n-    }\n+    offset_momentum(&mut bodies);\n+    println(fmt!(\"%.9f\", energy(&bodies) as float));\n \n-    pub fn offset_momentum(props: &mut Body::Props,\n-                           px: float,\n-                           py: float,\n-                           pz: float) {\n-        props.vx = -px / SOLAR_MASS;\n-        props.vy = -py / SOLAR_MASS;\n-        props.vz = -pz / SOLAR_MASS;\n-    }\n+    advance(&mut bodies, 0.01, n);\n \n+    println(fmt!(\"%.9f\", energy(&bodies) as float));\n }\n+"}, {"sha": "38e87358ee214e2b15a78a5d8993c1da6676c421", "filename": "src/test/bench/shootout-pidigits.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -0,0 +1,178 @@\n+// xfail-test\n+\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::libc::{STDOUT_FILENO, c_char, c_int, c_uint, c_void, fdopen, fputc};\n+use core::libc::{fputs};\n+use core::ptr::null;\n+\n+struct mpz_t {\n+    _mp_alloc: c_int,\n+    _mp_size: c_int,\n+    _mp_limb_t: *c_void,\n+}\n+\n+impl mpz_t {\n+    fn new() -> mpz_t {\n+        mpz_t {\n+            _mp_alloc: 0,\n+            _mp_size: 0,\n+            _mp_limb_t: null(),\n+        }\n+    }\n+}\n+\n+#[link_args=\"-lgmp\"]\n+extern {\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_add\"]\n+    fn mpz_add(x: *mpz_t, y: *mpz_t, z: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_cmp\"]\n+    fn mpz_cmp(x: *mpz_t, y: *mpz_t) -> c_int;\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_fdiv_qr\"]\n+    fn mpz_fdiv_qr(a: *mpz_t, b: *mpz_t, c: *mpz_t, d: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_get_ui\"]\n+    fn mpz_get_ui(x: *mpz_t) -> c_uint;\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_init\"]\n+    fn mpz_init(x: *mpz_t);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_init_set_ui\"]\n+    fn mpz_init_set_ui(x: *mpz_t, y: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_mul_2exp\"]\n+    fn mpz_mul_2exp(x: *mpz_t, y: *mpz_t, z: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_mul_ui\"]\n+    fn mpz_mul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n+    #[fast_ffi]\n+    #[link_name=\"__gmpz_submul_ui\"]\n+    fn mpz_submul_ui(x: *mpz_t, y: *mpz_t, z: c_uint);\n+}\n+\n+struct Context {\n+    numer: mpz_t,\n+    accum: mpz_t,\n+    denom: mpz_t,\n+    tmp1: mpz_t,\n+    tmp2: mpz_t,\n+}\n+\n+impl Context {\n+    fn new() -> Context {\n+        unsafe {\n+            let mut result = Context {\n+                numer: mpz_t::new(),\n+                accum: mpz_t::new(),\n+                denom: mpz_t::new(),\n+                tmp1: mpz_t::new(),\n+                tmp2: mpz_t::new(),\n+            };\n+            mpz_init(&result.tmp1);\n+            mpz_init(&result.tmp2);\n+            mpz_init_set_ui(&result.numer, 1);\n+            mpz_init_set_ui(&result.accum, 0);\n+            mpz_init_set_ui(&result.denom, 1);\n+            result\n+        }\n+    }\n+\n+    fn extract_digit(&mut self) -> i32 {\n+        unsafe {\n+            if mpz_cmp(&self.numer, &self.accum) > 0 {\n+                return -1;\n+            }\n+\n+            // Compute (numer * 3 + accum) / denom\n+            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n+            mpz_add(&self.tmp1, &self.tmp1, &self.numer);\n+            mpz_add(&self.tmp1, &self.tmp1, &self.accum);\n+            mpz_fdiv_qr(&self.tmp1, &self.tmp2, &self.tmp1, &self.denom);\n+\n+            // Now, if (numer * 4 + accum) % denom...\n+            mpz_add(&self.tmp2, &self.tmp2, &self.numer);\n+\n+            // ... is normalized, then the two divisions have the same result.\n+            if mpz_cmp(&self.tmp2, &self.denom) >= 0 {\n+                return -1;\n+            }\n+\n+            mpz_get_ui(&self.tmp1) as i32\n+        }\n+    }\n+\n+    fn next_term(&mut self, k: u32) {\n+        unsafe {\n+            let y2 = k*2 + 1;\n+\n+            mpz_mul_2exp(&self.tmp1, &self.numer, 1);\n+            mpz_add(&self.accum, &self.accum, &self.tmp1);\n+            mpz_mul_ui(&self.accum, &self.accum, y2);\n+            mpz_mul_ui(&self.numer, &self.numer, k);\n+            mpz_mul_ui(&self.denom, &self.denom, y2);\n+        }\n+    }\n+\n+    fn eliminate_digit(&mut self, d: u32) {\n+        unsafe {\n+            mpz_submul_ui(&self.accum, &self.denom, d);\n+            mpz_mul_ui(&self.accum, &self.accum, 10);\n+            mpz_mul_ui(&self.numer, &self.numer, 10);\n+        }\n+    }\n+}\n+\n+fn pidigits(n: u32) {\n+    unsafe {\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        let mut d: i32;\n+        let mut i: u32 = 0, k: u32 = 0, m: u32;\n+\n+        let mut context = Context::new();\n+        loop {\n+            loop {\n+                k += 1;\n+                context.next_term(k);\n+                d = context.extract_digit();\n+                if d != -1 {\n+                    break;\n+                }\n+            }\n+\n+            fputc((d as c_int) + ('0' as c_int), stdout);\n+\n+            i += 1;\n+            m = i % 10;\n+            if m == 0 {\n+                let res = fmt!(\"\\t:%d\\n\", i as int);\n+                fputs(transmute(&res[0]), stdout);\n+            }\n+            if i >= n {\n+                break;\n+            }\n+            context.eliminate_digit(d as u32);\n+        }\n+\n+        if m != 0 {\n+            m = 10 - m;\n+            while m != 0 {\n+                m -= 1;\n+                fputc(' ' as c_int, stdout);\n+            }\n+            let res = fmt!(\"\\t:%d\\n\", i as int);\n+            fputs(transmute(&res[0]), stdout);\n+        }\n+    }\n+}\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    let n: u32 = FromStr::from_str(os::args()[1]).get();\n+    pidigits(n);\n+}\n+"}, {"sha": "72c01c8d55cfb8d0e8258bc5346f98201cb502c1", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -0,0 +1,155 @@\n+// xfail-pretty\n+// xfail-test\n+\n+use core::cast::transmute;\n+use core::libc::{STDOUT_FILENO, c_int, fdopen, fgets, fopen, fputc, fwrite};\n+use core::libc::{size_t};\n+use core::ptr::null;\n+use core::vec::{capacity, reserve, reserve_at_least};\n+use core::vec::raw::set_len;\n+\n+static LINE_LEN: u32 = 80;\n+\n+static COMPLEMENTS: [u8, ..256] = [\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0,\n+    'T' as u8,\n+    'V' as u8,\n+    'G' as u8,\n+    'H' as u8,\n+    0,\n+    0,\n+    'C' as u8,\n+    'D' as u8,\n+    0,\n+    0,\n+    'M' as u8,\n+    0,\n+    'K' as u8,\n+    'N' as u8,\n+    0,\n+    0,\n+    0,\n+    'Y' as u8,\n+    'S' as u8,\n+    'A' as u8,\n+    'A' as u8,\n+    'B' as u8,\n+    'W' as u8,\n+    0,\n+    'R' as u8,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+\n+    0,\n+    'T' as u8,\n+    'V' as u8,\n+    'G' as u8,\n+    'H' as u8,\n+    0,\n+    0,\n+    'C' as u8,\n+    'D' as u8,\n+    0,\n+    0,\n+    'M' as u8,\n+    0,\n+    'K' as u8,\n+    'N' as u8,\n+    0,\n+    0,\n+    0,\n+    'Y' as u8,\n+    'S' as u8,\n+    'A' as u8,\n+    'A' as u8,\n+    'B' as u8,\n+    'W' as u8,\n+    0,\n+    'R' as u8,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+    0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+];\n+\n+#[fixed_stack_segment]\n+fn main() {\n+    unsafe {\n+        let mode = \"r\";\n+        //let stdin = fdopen(STDIN_FILENO as c_int, transmute(&mode[0]));\n+        let path = \"reversecomplement-input.txt\";\n+        let stdin = fopen(transmute(&path[0]), transmute(&mode[0]));\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        let mut out: ~[u8] = ~[];\n+        reserve(&mut out, 12777888);\n+        let mut pos = 0;\n+\n+        loop {\n+            let needed = pos + (LINE_LEN as uint) + 1;\n+            if capacity(&out) < needed {\n+                reserve_at_least(&mut out, needed);\n+            }\n+\n+            let mut ptr = out.unsafe_mut_ref(pos);\n+            if fgets(transmute(ptr), LINE_LEN as c_int, stdin) == null() {\n+                break;\n+            }\n+\n+            // Don't change lines that begin with '>' or ';'.\n+            let first = *ptr;\n+            if first == ('>' as u8) {\n+                while *ptr != 0 {\n+                    ptr = ptr.offset(1);\n+                }\n+                *ptr = '\\n' as u8;\n+\n+                pos = (ptr as uint) - (out.unsafe_ref(0) as uint);\n+                fwrite(transmute(out.unsafe_ref(0)),\n+                       1,\n+                       pos as size_t,\n+                       stdout);\n+\n+                pos = 0;\n+                loop;\n+            }\n+\n+            // Complement other lines.\n+            loop {\n+                let ch = *ptr;\n+                if ch == 0 {\n+                    break;\n+                }\n+                *ptr = COMPLEMENTS.unsafe_get(ch as uint);\n+                ptr = ptr.offset(1);\n+            }\n+            *ptr = '\\n' as u8;\n+\n+            pos = (ptr as uint) - (out.unsafe_ref(0) as uint);\n+        }\n+\n+        fwrite(transmute(out.unsafe_ref(0)), 1, pos as size_t, stdout);\n+    }\n+}\n+"}, {"sha": "00e255d890b9d1def58cab256733599e358329be", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 36, "deletions": 66, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -1,84 +1,54 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+use core::from_str::FromStr;\n+use core::iter::ExtendedMutableIter;\n+use core::unstable::intrinsics::sqrtf64;\n \n-// Based on spectalnorm.gcc by Sebastien Loisel\n-\n-extern mod std;\n+#[inline]\n+fn A(i: i32, j: i32) -> i32 {\n+    (i+j) * (i+j+1) / 2 + i + 1\n+}\n \n-fn eval_A(i: uint, j: uint) -> float {\n-    1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n+fn dot(v: &[f64], u: &[f64]) -> f64 {\n+    let mut sum = 0.0;\n+    for v.eachi |i, &v_i| {\n+        sum += v_i * u[i];\n+    }\n+    sum\n }\n \n-fn eval_A_times_u(u: &const [float], Au: &mut [float]) {\n-    let N = vec::len(u);\n-    let mut i = 0u;\n-    while i < N {\n-        Au[i] = 0.0;\n-        let mut j = 0u;\n-        while j < N {\n-            Au[i] += eval_A(i, j) * u[j];\n-            j += 1u;\n+fn mult_Av(v: &mut [f64], out: &mut [f64]) {\n+    for vec::eachi_mut(out) |i, out_i| {\n+        let mut sum = 0.0;\n+        for vec::eachi_mut(v) |j, &v_j| {\n+            sum += v_j / (A(i as i32, j as i32) as f64);\n         }\n-        i += 1u;\n+        *out_i = sum;\n     }\n }\n \n-fn eval_At_times_u(u: &const [float], Au: &mut [float]) {\n-    let N = vec::len(u);\n-    let mut i = 0u;\n-    while i < N {\n-        Au[i] = 0.0;\n-        let mut j = 0u;\n-        while j < N {\n-            Au[i] += eval_A(j, i) * u[j];\n-            j += 1u;\n+fn mult_Atv(v: &mut [f64], out: &mut [f64]) {\n+    for vec::eachi_mut(out) |i, out_i| {\n+        let mut sum = 0.0;\n+        for vec::eachi_mut(v) |j, &v_j| {\n+            sum += v_j / (A(j as i32, i as i32) as f64);\n         }\n-        i += 1u;\n+        *out_i = sum;\n     }\n }\n \n-fn eval_AtA_times_u(u: &const [float], AtAu: &mut [float]) {\n-    let mut v = vec::from_elem(vec::len(u), 0.0);\n-    eval_A_times_u(u, v);\n-    eval_At_times_u(v, AtAu);\n+fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n+    mult_Av(v, tmp);\n+    mult_Atv(tmp, out);\n }\n \n+#[fixed_stack_segment]\n fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"2000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"1000\"]\n-    } else {\n-        args\n-    };\n-\n-    let N = uint::from_str(args[1]).get();\n-\n-    let mut u = vec::from_elem(N, 1.0);\n-    let mut v = vec::from_elem(N, 0.0);\n-    let mut i = 0u;\n-    while i < 10u {\n-        eval_AtA_times_u(u, v);\n-        eval_AtA_times_u(v, u);\n-        i += 1u;\n-    }\n-\n-    let mut vBv = 0.0;\n-    let mut vv = 0.0;\n-    let mut i = 0u;\n-    while i < N {\n-        vBv += u[i] * v[i];\n-        vv += v[i] * v[i];\n-        i += 1u;\n+    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let mut u = vec::from_elem(n, 1f64), v = u.clone(), tmp = u.clone();\n+    for 8.times {\n+        mult_AtAv(u, v, tmp);\n+        mult_AtAv(v, u, tmp);\n     }\n \n-    io::println(fmt!(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n+    println(fmt!(\"%.9f\", sqrtf64(dot(u,v) / dot(v,v)) as float));\n }\n+"}, {"sha": "685d86c740d9706487e732f4ee4c0580616d0642", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -17,11 +17,11 @@ fn foo<T:Copy + Const>(x: T) -> T { x }\n struct F { field: int }\n \n pub fn main() {\n-    foo(1);\n+    /*foo(1);\n     foo(~\"hi\");\n     foo(~[1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2u));\n-    foo(@1);\n+    foo(@1);*/\n     foo(~1);\n }"}, {"sha": "37e531eaa8e60b5abe7a70d042dcc592748db57f", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b3c09a1038c6623528fd7ebb1d365e475d63dfc/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=8b3c09a1038c6623528fd7ebb1d365e475d63dfc", "patch": "@@ -11,7 +11,7 @@\n mod rustrt {\n     pub extern {\n         pub fn rust_dbg_call(cb: *u8, data: libc::uintptr_t)\n-                          -> libc::uintptr_t;\n+                             -> libc::uintptr_t;\n     }\n }\n "}]}