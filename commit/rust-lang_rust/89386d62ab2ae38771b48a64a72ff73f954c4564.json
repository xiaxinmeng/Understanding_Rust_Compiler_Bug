{"sha": "89386d62ab2ae38771b48a64a72ff73f954c4564", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5Mzg2ZDYyYWIyYWUzODc3MWI0OGE2NGE3MmZmNzNmOTU0YzQ1NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-17T18:57:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-17T18:57:08Z"}, "message": "Auto merge of #37837 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\n- Successful merges: #37752, #37757, #37759, #37766, #37772, #37799, #37806, #37821\n- Failed merges: #37442", "tree": {"sha": "bee5aac8fef93b5c038bb4bd8826613959f0ee4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bee5aac8fef93b5c038bb4bd8826613959f0ee4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89386d62ab2ae38771b48a64a72ff73f954c4564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89386d62ab2ae38771b48a64a72ff73f954c4564", "html_url": "https://github.com/rust-lang/rust/commit/89386d62ab2ae38771b48a64a72ff73f954c4564", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89386d62ab2ae38771b48a64a72ff73f954c4564/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "html_url": "https://github.com/rust-lang/rust/commit/c57b8261496d548e0a3cd8468061ddc5a4dcafe2"}, {"sha": "850e355d285f8ed34e2963c6fac7e0f3d72b536b", "url": "https://api.github.com/repos/rust-lang/rust/commits/850e355d285f8ed34e2963c6fac7e0f3d72b536b", "html_url": "https://github.com/rust-lang/rust/commit/850e355d285f8ed34e2963c6fac7e0f3d72b536b"}], "stats": {"total": 559, "additions": 522, "deletions": 37}, "files": [{"sha": "14a05102b9a0346406cdd451c157ab879df9606f", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -586,3 +586,45 @@ you add more examples.\n \n We haven\u2019t covered all of the details with writing documentation tests. For more,\n please see the [Documentation chapter](documentation.html).\n+\n+# Testing and concurrency\n+\n+One thing that is important to note when writing tests are run concurrently\n+using threads. For this reason you should take care that your tests are written\n+in such a way as to not depend on each-other, or on any shared state. \"Shared\n+state\" can also include the environment, such as the current working directory,\n+or environment variables.\n+\n+If this is an issue it is possible to control this concurrency, either by\n+setting the environment variable `RUST_TEST_THREADS`, or by passing the argument\n+`--test-threads` to the tests:\n+\n+```bash\n+$ RUST_TEST_THREADS=1 cargo test   # Run tests with no concurrency\n+...\n+$ cargo test -- --test-threads=1   # Same as above\n+...\n+```\n+\n+# Test output\n+\n+By default Rust's test library captures and discards output to standard\n+out/error, e.g. output from `println!()`. This too can be controlled using the\n+environment or a switch:\n+\n+\n+```bash\n+$ RUST_TEST_NOCAPTURE=1 cargo test   # Preserve stdout/stderr\n+...\n+$ cargo test -- --nocapture          # Same as above\n+...\n+```\n+\n+However a better method avoiding capture is to use logging rather than raw\n+output. Rust has a [standard logging API][log], which provides a frontend to\n+multiple logging implementations. This can be used in conjunction with the\n+default [env_logger] to output any debugging information in a manner that can be\n+controlled at runtime.\n+\n+[log]: https://crates.io/crates/log\n+[env_logger]: https://crates.io/crates/env_logger"}, {"sha": "83b0d9dec6d904c087a7f16ec18404a6006b267d", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -40,7 +40,9 @@ Ensure the ordering of the match arm is correct and remove any superfluous\n arms.\n \"##,\n \n-/*E0002: r##\"\n+E0002: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n This error indicates that an empty match expression is invalid because the type\n it is matching on is non-empty (there exist values of this type). In safe code\n it is impossible to create an instance of an empty type, so empty match\n@@ -68,10 +70,11 @@ fn foo(x: Option<String>) {\n     }\n }\n ```\n-\"##,*/\n+\"##,\n \n+E0003: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n \n-/*E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. So, the following will not compile:\n \n@@ -98,7 +101,6 @@ match number {\n }\n ```\n \"##,\n-*/\n \n E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for"}, {"sha": "d15795730a86c1567dffae3bb30bc478ccbbf8b9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let limit = if candidates.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                err.help(&format!(\"candidate #{}: `use {}`\",\n+                err.help(&format!(\"candidate #{}: `use {};`\",\n                                   i + 1,\n                                   self.tcx.item_path_str(*trait_did)));\n             }"}, {"sha": "df3a79f09bd06131e30f27971597af785d426cd1", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -14,7 +14,7 @@\n \n use hir::def_id::DefId;\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n@@ -134,6 +134,12 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n \n+                if trait_ref.references_error() {\n+                    debug!(\"coherence: skipping impl {:?} with error {:?}\",\n+                           impl_def_id, trait_ref);\n+                    return\n+                }\n+\n                 let _task =\n                     self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n "}, {"sha": "7395cc42ac578d7d17d3d9447c6a5cd0b232b6cf", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -874,12 +874,12 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n-        // then we need to render it out to the filesystem\n+        // then we need to render it out to the filesystem.\n         if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n-            // macros from other libraries get special filenames which we can\n-            // safely ignore\n+            // Macros from other libraries get special filenames which we can\n+            // safely ignore.\n             && !(item.source.filename.starts_with(\"<\")\n                 && item.source.filename.ends_with(\"macros>\")) {\n \n@@ -974,13 +974,13 @@ impl DocFolder for Cache {\n         };\n \n         // Register any generics to their corresponding string. This is used\n-        // when pretty-printing types\n+        // when pretty-printing types.\n         if let Some(generics) = item.inner.generics() {\n             self.generics(generics);\n         }\n \n-        // Propagate a trait methods' documentation to all implementors of the\n-        // trait\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n         if let clean::TraitItem(ref t) = item.inner {\n             self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n@@ -996,7 +996,7 @@ impl DocFolder for Cache {\n             }\n         }\n \n-        // Index this method for searching later on\n+        // Index this method for searching later on.\n         if let Some(ref s) = item.name {\n             let (parent, is_inherent_impl_item) = match item.inner {\n                 clean::StrippedItem(..) => ((None, None), false),\n@@ -1097,8 +1097,8 @@ impl DocFolder for Cache {\n                                       (self.stack.clone(), item.type_()));\n                 }\n             }\n-            // link variants to their parent enum because pages aren't emitted\n-            // for each variant\n+            // Link variants to their parent enum because pages aren't emitted\n+            // for each variant.\n             clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n@@ -1144,8 +1144,8 @@ impl DocFolder for Cache {\n             _ => false\n         };\n \n-        // Once we've recursively found all the generics, then hoard off all the\n-        // implementations elsewhere\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n         let ret = self.fold_item_recur(item).and_then(|item| {\n             if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n@@ -1206,7 +1206,7 @@ impl Context {\n     }\n \n     /// Recurse in the directory structure and change the \"root path\" to make\n-    /// sure it always points to the top (relatively)\n+    /// sure it always points to the top (relatively).\n     fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n         F: FnOnce(&mut Context) -> T,\n     {\n@@ -1237,11 +1237,11 @@ impl Context {\n     fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n-            None => return Ok(())\n+            None => return Ok(()),\n         };\n         item.name = Some(krate.name);\n \n-        // render the crate documentation\n+        // Render the crate documentation\n         let mut work = vec![(self, item)];\n \n         while let Some((mut cx, item)) = work.pop() {\n@@ -2987,7 +2987,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         let it = self.item;\n         let parentlen = cx.current.len() - if it.is_mod() {1} else {0};\n \n-        // the sidebar is designed to display sibling functions, modules and\n+        // The sidebar is designed to display sibling functions, modules and\n         // other miscellaneous information. since there are lots of sibling\n         // items (and that causes quadratic growth in large modules),\n         // we refactor common parts into a shared JavaScript file per module.\n@@ -3006,7 +3006,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         }\n         write!(fmt, \"</p>\")?;\n \n-        // sidebar refers to the enclosing module, not this module\n+        // Sidebar refers to the enclosing module, not this module.\n         let relpath = if it.is_mod() { \"../\" } else { \"\" };\n         write!(fmt,\n                \"<script>window.sidebarCurrent = {{\\\n@@ -3018,7 +3018,7 @@ impl<'a> fmt::Display for Sidebar<'a> {\n                ty = it.type_().css_class(),\n                path = relpath)?;\n         if parentlen == 0 {\n-            // there is no sidebar-items.js beyond the crate root path\n+            // There is no sidebar-items.js beyond the crate root path\n             // FIXME maybe dynamic crate loading can be merged here\n         } else {\n             write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\","}, {"sha": "7b7be6e2eeeb3628c61afe8c5f70da74612c1e2a", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 142, "deletions": 5, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -154,6 +154,14 @@ impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n     /// The result will represent the IP address `a`.`b`.`c`.`d`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n@@ -167,6 +175,15 @@ impl Ipv4Addr {\n     }\n \n     /// Returns the four eight-bit integers that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n@@ -176,8 +193,18 @@ impl Ipv4Addr {\n     /// Returns true for the special 'unspecified' address (0.0.0.0).\n     ///\n     /// This property is defined in _UNIX Network Programming, Second Edition_,\n-    /// W. Richard Stevens, p. 891; see also [ip7]\n-    /// [ip7][http://man7.org/linux/man-pages/man7/ip.7.html]\n+    /// W. Richard Stevens, p. 891; see also [ip7].\n+    ///\n+    /// [ip7]: http://man7.org/linux/man-pages/man7/ip.7.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n+    /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n@@ -186,7 +213,17 @@ impl Ipv4Addr {\n     /// Returns true if this is a loopback address (127.0.0.0/8).\n     ///\n     /// This property is defined by [RFC 1122].\n+    ///\n     /// [RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n@@ -195,11 +232,26 @@ impl Ipv4Addr {\n     /// Returns true if this is a private address.\n     ///\n     /// The private address ranges are defined in [RFC 1918] and include:\n-    /// [RFC 1918]: https://tools.ietf.org/html/rfc1918\n     ///\n     ///  - 10.0.0.0/8\n     ///  - 172.16.0.0/12\n     ///  - 192.168.0.0/16\n+    ///\n+    /// [RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_private(&self) -> bool {\n         match (self.octets()[0], self.octets()[1]) {\n@@ -213,15 +265,25 @@ impl Ipv4Addr {\n     /// Returns true if the address is link-local (169.254.0.0/16).\n     ///\n     /// This property is defined by [RFC 3927].\n+    ///\n     /// [RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n \n     /// Returns true if the address appears to be globally routable.\n     /// See [iana-ipv4-special-registry][ipv4-sr].\n-    /// [ipv4-sr]: http://goo.gl/RaZ7lg\n     ///\n     /// The following return false:\n     ///\n@@ -231,6 +293,24 @@ impl Ipv4Addr {\n     /// - the broadcast address (255.255.255.255/32)\n     /// - test addresses used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n     /// - the unspecified address (0.0.0.0)\n+    ///\n+    /// [ipv4-sr]: http://goo.gl/RaZ7lg\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    /// }\n+    /// ```\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation() && !self.is_unspecified()\n@@ -240,7 +320,18 @@ impl Ipv4Addr {\n     ///\n     /// Multicast addresses have a most significant octet between 224 and 239,\n     /// and is defined by [RFC 5771].\n+    ///\n     /// [RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n@@ -249,7 +340,17 @@ impl Ipv4Addr {\n     /// Returns true if this is a broadcast address (255.255.255.255).\n     ///\n     /// A broadcast address has all octets set to 255 as defined in [RFC 919].\n+    ///\n     /// [RFC 919]: https://tools.ietf.org/html/rfc919\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n@@ -259,11 +360,23 @@ impl Ipv4Addr {\n     /// Returns true if this address is in a range designated for documentation.\n     ///\n     /// This is defined in [RFC 5737]:\n-    /// [RFC 5737]: https://tools.ietf.org/html/rfc5737\n     ///\n     /// - 192.0.2.0/24 (TEST-NET-1)\n     /// - 198.51.100.0/24 (TEST-NET-2)\n     /// - 203.0.113.0/24 (TEST-NET-3)\n+    ///\n+    /// [RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_documentation(&self) -> bool {\n         match(self.octets()[0], self.octets()[1], self.octets()[2], self.octets()[3]) {\n@@ -277,6 +390,15 @@ impl Ipv4Addr {\n     /// Converts this address to an IPv4-compatible IPv6 address.\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0,\n@@ -287,6 +409,15 @@ impl Ipv4Addr {\n     /// Converts this address to an IPv4-mapped IPv6 address.\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff,\n@@ -425,6 +556,7 @@ impl Ipv6Addr {\n     /// Returns true for the special 'unspecified' address (::).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_unspecified(&self) -> bool {\n@@ -434,6 +566,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a loopback address (::1).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n@@ -458,6 +591,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a unique local address (fc00::/7).\n     ///\n     /// This property is defined in [RFC 4193].\n+    ///\n     /// [RFC 4193]: https://tools.ietf.org/html/rfc4193\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n@@ -466,6 +600,7 @@ impl Ipv6Addr {\n     /// Returns true if the address is unicast and link-local (fe80::/10).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n@@ -481,6 +616,7 @@ impl Ipv6Addr {\n     /// (2001:db8::/32).\n     ///\n     /// This property is defined in [RFC 3849].\n+    ///\n     /// [RFC 3849]: https://tools.ietf.org/html/rfc3849\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n@@ -524,6 +660,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a multicast address (ff00::/8).\n     ///\n     /// This property is defined by [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {"}, {"sha": "159aa997b27285cc8e407df79d382752eee23e84", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -67,11 +67,12 @@ pub struct TcpListener(net_imp::TcpListener);\n \n /// An infinite iterator over the connections from a `TcpListener`.\n ///\n-/// This iterator will infinitely yield `Some` of the accepted connections. It\n+/// This iterator will infinitely yield [`Some`] of the accepted connections. It\n /// is equivalent to calling `accept` in a loop.\n ///\n /// This `struct` is created by the [`incoming`] method on [`TcpListener`].\n ///\n+/// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n /// [`incoming`]: struct.TcpListener.html#method.incoming\n /// [`TcpListener`]: struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b33f27fbc8a03f43180f720f46c46d8e8e82b6b1", "filename": "src/test/compile-fail/coherence-error-suppression.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that error types in coherence do not cause error cascades.\n+\n+trait Foo {}\n+\n+impl Foo for i8 {}\n+impl Foo for i16 {}\n+impl Foo for i32 {}\n+impl Foo for i64 {}\n+impl Foo for DoesNotExist {} //~ ERROR `DoesNotExist` is undefined\n+impl Foo for u8 {}\n+impl Foo for u16 {}\n+impl Foo for u32 {}\n+impl Foo for u64 {}\n+\n+fn main() {}"}, {"sha": "ea8796d38f93c36c542d89b23114924c6bc31b0c", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -34,31 +34,31 @@ fn main() {\n     1u32.method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n     //~^^ ERROR no method named\n-    //~^^^ HELP `use foo::Bar`\n-    //~^^^^ HELP `use no_method_suggested_traits::foo::PubPub`\n+    //~^^^ HELP `use foo::Bar;`\n+    //~^^^^ HELP `use no_method_suggested_traits::foo::PubPub;`\n     std::rc::Rc::new(&mut Box::new(&1u32)).method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n     //~^^ ERROR no method named\n-    //~^^^ HELP `use foo::Bar`\n-    //~^^^^ HELP `use no_method_suggested_traits::foo::PubPub`\n+    //~^^^ HELP `use foo::Bar;`\n+    //~^^^^ HELP `use no_method_suggested_traits::foo::PubPub;`\n \n     'a'.method();\n     //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n-    //~^^^ HELP `use foo::Bar`\n+    //~^^^ HELP `use foo::Bar;`\n     std::rc::Rc::new(&mut Box::new(&'a')).method();\n     //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n-    //~^^^ HELP `use foo::Bar`\n+    //~^^^ HELP `use foo::Bar;`\n \n     1i32.method();\n     //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n-    //~^^^ HELP `use no_method_suggested_traits::foo::PubPub`\n+    //~^^^ HELP `use no_method_suggested_traits::foo::PubPub;`\n     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n     //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n-    //~^^^ HELP `use no_method_suggested_traits::foo::PubPub`\n+    //~^^^ HELP `use no_method_suggested_traits::foo::PubPub;`\n \n     Foo.method();\n     //~^ ERROR no method named"}, {"sha": "35fb583cd4ed2b623b453d61d509abe8debd1ab9", "filename": "src/test/incremental/hashes/type_defs.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftype_defs.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for `type` definitions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// We also test the ICH for `type` definitions exported in metadata. Same as\n+// above, we want to make sure that the change between rev1 and rev2 also\n+// results in a change of the ICH for the enum's metadata, and that it stays\n+// the same between rev2 and rev3.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change type (primitive) -----------------------------------------------------\n+#[cfg(cfail1)]\n+type ChangePrimitiveType = i32;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangePrimitiveType = i64;\n+\n+\n+\n+// Change mutability -----------------------------------------------------------\n+#[cfg(cfail1)]\n+type ChangeMutability = &'static i32;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeMutability = &'static mut i32;\n+\n+\n+\n+// Change mutability -----------------------------------------------------------\n+#[cfg(cfail1)]\n+type ChangeLifetime<'a> = (&'static i32, &'a i32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeLifetime<'a> = (&'a i32, &'a i32);\n+\n+\n+\n+// Change type (struct) -----------------------------------------------------------\n+struct Struct1;\n+struct Struct2;\n+\n+#[cfg(cfail1)]\n+type ChangeTypeStruct = Struct1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeTypeStruct = Struct2;\n+\n+\n+\n+// Change type (tuple) ---------------------------------------------------------\n+#[cfg(cfail1)]\n+type ChangeTypeTuple = (u32, u64);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeTypeTuple = (u32, i64);\n+\n+\n+\n+// Change type (enum) ----------------------------------------------------------\n+enum Enum1 {\n+    Var1,\n+    Var2,\n+}\n+enum Enum2 {\n+    Var1,\n+    Var2,\n+}\n+\n+#[cfg(cfail1)]\n+type ChangeTypeEnum = Enum1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeTypeEnum = Enum2;\n+\n+\n+\n+// Add tuple field -------------------------------------------------------------\n+#[cfg(cfail1)]\n+type AddTupleField = (i32, i64);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddTupleField = (i32, i64, i16);\n+\n+\n+\n+// Change nested tuple field ---------------------------------------------------\n+#[cfg(cfail1)]\n+type ChangeNestedTupleField = (i32, (i64, i16));\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type ChangeNestedTupleField = (i32, (i64, i8));\n+\n+\n+\n+// Add type param --------------------------------------------------------------\n+#[cfg(cfail1)]\n+type AddTypeParam<T1> = (T1, T1);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddTypeParam<T1, T2> = (T1, T2);\n+\n+\n+\n+// Add type param bound --------------------------------------------------------\n+#[cfg(cfail1)]\n+type AddTypeParamBound<T1> = (T1, u32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddTypeParamBound<T1: Clone> = (T1, u32);\n+\n+\n+\n+// Add type param bound in where clause ----------------------------------------\n+#[cfg(cfail1)]\n+type AddTypeParamBoundWhereClause<T1> where T1: Clone = (T1, u32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddTypeParamBoundWhereClause<T1> where T1: Clone+Copy = (T1, u32);\n+\n+\n+\n+// Add lifetime param ----------------------------------------------------------\n+#[cfg(cfail1)]\n+type AddLifetimeParam<'a> = (&'a u32, &'a u32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddLifetimeParam<'a, 'b> = (&'a u32, &'b u32);\n+\n+\n+\n+// Add lifetime param bound ----------------------------------------------------\n+#[cfg(cfail1)]\n+type AddLifetimeParamBound<'a, 'b> = (&'a u32, &'b u32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddLifetimeParamBound<'a, 'b: 'a> = (&'a u32, &'b u32);\n+\n+\n+\n+// Add lifetime param bound in where clause ------------------------------------\n+#[cfg(cfail1)]\n+type AddLifetimeParamBoundWhereClause<'a, 'b, 'c>\n+where 'b: 'a\n+    = (&'a u32, &'b u32, &'c u32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+type AddLifetimeParamBoundWhereClause<'a, 'b, 'c>\n+where 'b: 'a,\n+      'c: 'a\n+    = (&'a u32, &'b u32, &'c u32);\n+\n+\n+\n+// Change Trait Bound Indirectly -----------------------------------------------\n+trait ReferencedTrait1 {}\n+trait ReferencedTrait2 {}\n+\n+mod change_trait_bound_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    type ChangeTraitBoundIndirectly<T: Trait> = (T, u32);\n+}\n+\n+\n+\n+// Change Trait Bound Indirectly In Where Clause -------------------------------\n+mod change_trait_bound_indirectly_in_where_clause {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    type ChangeTraitBoundIndirectly<T> where T : Trait = (T, u32);\n+}"}, {"sha": "017259af190fc2d861f0d0375def08b362a0cbcb", "filename": "src/test/run-pass/path-lookahead.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Frun-pass%2Fpath-lookahead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89386d62ab2ae38771b48a64a72ff73f954c4564/src%2Ftest%2Frun-pass%2Fpath-lookahead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpath-lookahead.rs?ref=89386d62ab2ae38771b48a64a72ff73f954c4564", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Parser test for #37765\n+\n+fn with_parens<T: ToString>(arg: T) -> String { //~WARN dead_code\n+  return (<T as ToString>::to_string(&arg)); //~WARN unused_parens\n+}\n+\n+fn no_parens<T: ToString>(arg: T) -> String { //~WARN dead_code\n+  return <T as ToString>::to_string(&arg);\n+}\n+\n+fn main() {\n+\n+}"}]}