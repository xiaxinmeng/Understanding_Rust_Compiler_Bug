{"sha": "6914d32accd7cc3c29697bf0e2974e654558fe07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MTRkMzJhY2NkN2NjM2MyOTY5N2JmMGUyOTc0ZTY1NDU1OGZlMDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-13T08:23:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-13T08:23:13Z"}, "message": "Do not allow moving out of obj fields, properly check move inits\n\nCloses #591", "tree": {"sha": "c9507cfd3d819e9e81c516bb99e5750465396283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9507cfd3d819e9e81c516bb99e5750465396283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6914d32accd7cc3c29697bf0e2974e654558fe07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6914d32accd7cc3c29697bf0e2974e654558fe07", "html_url": "https://github.com/rust-lang/rust/commit/6914d32accd7cc3c29697bf0e2974e654558fe07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6914d32accd7cc3c29697bf0e2974e654558fe07/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "729fa81d3b79b9209ab6207c427c3bd598f83aa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/729fa81d3b79b9209ab6207c427c3bd598f83aa9", "html_url": "https://github.com/rust-lang/rust/commit/729fa81d3b79b9209ab6207c427c3bd598f83aa9"}], "stats": {"total": 172, "additions": 85, "deletions": 87}, "files": [{"sha": "126ad726c352ad31886f63dc800ee68a68a9e89e", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6914d32accd7cc3c29697bf0e2974e654558fe07/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6914d32accd7cc3c29697bf0e2974e654558fe07/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=6914d32accd7cc3c29697bf0e2974e654558fe07", "patch": "@@ -47,13 +47,14 @@ fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     auto v =\n         @rec(visit_fn=bind visit_fn(cx, _, _, _, _, _, _, _),\n              visit_item=bind visit_item(cx, _, _, _),\n-             visit_expr=bind visit_expr(cx, _, _, _)\n+             visit_expr=bind visit_expr(cx, _, _, _),\n+             visit_decl=bind visit_decl(cx, _, _, _)\n              with *visit::default_visitor[scope]());\n     visit::visit_crate(*crate, [], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n+fn visit_fn(&@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n             &fn_ident name, ast::node_id id, &scope sc, &vt[scope] v) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for (ast::arg arg_ in f.decl.inputs) {\n@@ -62,7 +63,7 @@ fn visit_fn(@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n     v.visit_block(f.body, [], v);\n }\n \n-fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n+fn visit_item(&@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n     alt (i.node) {\n         case (ast::item_obj(?o, _, _)) {\n             for (ast::obj_field f in o.fields) {\n@@ -74,21 +75,21 @@ fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n     visit::visit_item(i, sc, v);\n }\n \n-fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n+fn visit_expr(&@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n     auto handled = true;\n     alt (ex.node) {\n-        case (ast::expr_call(?f, ?args)) {\n+        ast::expr_call(?f, ?args) {\n             check_call(*cx, f, args, sc);\n             handled = false;\n         }\n-        case (ast::expr_be(?cl)) {\n+        ast::expr_be(?cl) {\n             check_tail_call(*cx, cl);\n             visit::visit_expr(cl, sc, v);\n         }\n-        case (ast::expr_alt(?input, ?arms)) {\n+        ast::expr_alt(?input, ?arms) {\n             check_alt(*cx, input, arms, sc, v);\n         }\n-        case (ast::expr_put(?val)) {\n+        ast::expr_put(?val) {\n             alt (val) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n@@ -102,36 +103,50 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 case (_) { }\n             }\n         }\n-        case (ast::expr_for_each(?decl, ?call, ?block)) {\n+        ast::expr_for_each(?decl, ?call, ?block) {\n             check_for_each(*cx, decl, call, block, sc, v);\n         }\n-        case (ast::expr_for(?decl, ?seq, ?block)) {\n+        ast::expr_for(?decl, ?seq, ?block) {\n             check_for(*cx, decl, seq, block, sc, v);\n         }\n-        case (ast::expr_path(?pt)) {\n+        ast::expr_path(?pt) {\n             check_var(*cx, ex, pt, ex.id, false, sc);\n             handled = false;\n         }\n-        case (ast::expr_swap(?lhs, ?rhs)) {\n+        ast::expr_swap(?lhs, ?rhs) {\n             check_lval(cx, lhs, sc, v);\n             check_lval(cx, rhs, sc, v);\n             handled = false;\n         }\n-        case (ast::expr_move(?dest, ?src)) {\n+        ast::expr_move(?dest, ?src) {\n             check_assign(cx, dest, src, sc, v);\n             check_move_rhs(cx, src, sc, v);\n         }\n-        case (ast::expr_assign(?dest, ?src)) {\n-            check_assign(cx, dest, src, sc, v);\n-        }\n-        case (ast::expr_assign_op(_, ?dest, ?src)) {\n+        ast::expr_assign(?dest, ?src) | ast::expr_assign_op(_, ?dest, ?src) {\n             check_assign(cx, dest, src, sc, v);\n         }\n-        case (_) { handled = false; }\n+        _ { handled = false; }\n     }\n     if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n+fn visit_decl(&@ctx cx, &@ast::decl d, &scope sc, &vt[scope] v) {\n+    visit::visit_decl(d, sc, v);\n+    alt (d.node) {\n+        ast::decl_local(?loc) {\n+            alt (loc.node.init) {\n+                some(?init) {\n+                    if (init.op == ast::init_move) {\n+                        check_move_rhs(cx, init.expr, sc, v);\n+                    }\n+                }\n+                none {}\n+            }\n+        }\n+        _ {}\n+    }\n+}\n+\n fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n    rec(vec[node_id] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n@@ -265,25 +280,22 @@ fn check_alt(&ctx cx, &@ast::expr input, &ast::arm[] arms, &scope sc,\n              &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n-    auto roots =\n-        alt (path_def_id(cx, root.ex)) {\n-            case (some(?did)) { [did._1] }\n-            case (_) { [] }\n-        };\n+    auto roots = alt (path_def_id(cx, root.ex)) {\n+        some(?did) { [did._1] }\n+        _ { [] }\n+    };\n     let vec[ty::t] forbidden_tp =\n-        alt (inner_mut(root.ds)) { case (some(?t)) { [t] } case (_) { [] } };\n+        alt (inner_mut(root.ds)) { some(?t) { [t] } _ { [] } };\n     for (ast::arm a in arms) {\n         auto dnums = arm_defnums(a);\n         auto new_sc = sc;\n         if (vec::len(dnums) > 0u) {\n-            new_sc =\n-                sc +\n-                    [@rec(root_vars=roots,\n-                          block_defnum=dnums.(0),\n-                          bindings=dnums,\n-                          tys=forbidden_tp,\n-                          depends_on=deps(sc, roots),\n-                          mutable ok=valid)];\n+            new_sc = sc + [@rec(root_vars=roots,\n+                                block_defnum=dnums.(0),\n+                                bindings=dnums,\n+                                tys=forbidden_tp,\n+                                depends_on=deps(sc, roots),\n+                                mutable ok=valid)];\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n@@ -331,26 +343,20 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n     visit::visit_expr(seq, sc, v);\n     auto defnum = local.node.id;\n     auto root = expr_root(cx, seq, false);\n-    auto root_def =\n-        alt (path_def_id(cx, root.ex)) {\n-            case (some(?did)) { [did._1] }\n-            case (_) { [] }\n-        };\n-    auto unsafe =\n-        alt (inner_mut(root.ds)) { case (some(?t)) { [t] } case (_) { [] } };\n-    // If this is a mutable vector, don't allow it to be touched.\n+    auto root_def = alt (path_def_id(cx, root.ex)) {\n+        some(?did) { [did._1] }\n+        _ { [] }\n+    };\n+    auto unsafe = alt (inner_mut(root.ds)) { some(?t) { [t] } _ { [] } };\n \n+    // If this is a mutable vector, don't allow it to be touched.\n     auto seq_t = ty::expr_ty(*cx.tcx, seq);\n     alt (ty::struct(*cx.tcx, seq_t)) {\n-        case (ty::ty_vec(?mt)) {\n+        ty::ty_vec(?mt) | ty::ty_ivec(?mt) {\n             if (mt.mut != ast::imm) { unsafe = [seq_t]; }\n         }\n-        case (ty::ty_str) { /* no-op */ }\n-        case (ty::ty_ivec(?mt)) {\n-            if (mt.mut != ast::imm) { unsafe = [seq_t]; }\n-        }\n-        case (ty::ty_istr) { /* no-op */ }\n-        case (_) {\n+        ty::ty_str | ty::ty_istr { /* no-op */ }\n+        _ {\n             cx.tcx.sess.span_unimpl(seq.span, \"unknown seq type \" +\n                                     util::ppaux::ty_to_str(*cx.tcx, seq_t));\n         }\n@@ -424,6 +430,13 @@ fn check_lval(&@ctx cx, &@ast::expr dest, &scope sc, &vt[scope] v) {\n fn check_move_rhs(&@ctx cx, &@ast::expr src, &scope sc, &vt[scope] v) {\n     alt (src.node) {\n         case (ast::expr_path(?p)) {\n+            alt (cx.tcx.def_map.get(src.id)) {\n+                ast::def_obj_field(_) {\n+                    cx.tcx.sess.span_err\n+                        (src.span, \"may not move out of an obj field\");\n+                }\n+                _ {}\n+            }\n             check_lval(cx, src, sc, v);\n         }\n         case (_) {\n@@ -550,16 +563,14 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                     maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        vec::push(ds,\n-                                  rec(mut=mt.mut != ast::imm,\n-                                      kind=index,\n-                                      outer_t=auto_unbox.t));\n+                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n+                                          kind=index,\n+                                          outer_t=auto_unbox.t));\n                     }\n                     case (ty::ty_ivec(?mt)) {\n-                        vec::push(ds,\n-                                  rec(mut=mt.mut != ast::imm,\n-                                      kind=index,\n-                                      outer_t=auto_unbox.t));\n+                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n+                                          kind=index,\n+                                          outer_t=auto_unbox.t));\n                     }\n                 }\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n@@ -616,72 +627,59 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n     fn helper(&ty::ctxt tcx, ty::t needle, ty::t haystack, bool mut) -> bool {\n         if (needle == haystack) { ret true; }\n         alt (ty::struct(tcx, haystack)) {\n-            case (ty::ty_tag(_, ?ts)) {\n+            ty::ty_tag(_, ?ts) {\n                 for (ty::t t in ts) {\n                     if (helper(tcx, needle, t, mut)) { ret true; }\n                 }\n                 ret false;\n             }\n-            case (ty::ty_box(?mt)) {\n+            ty::ty_box(?mt) | ty::ty_vec(?mt) | ty::ty_ptr(?mt) {\n                 ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n             }\n-            case (ty::ty_vec(?mt)) {\n-                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n-            }\n-            case (ty::ty_ptr(?mt)) {\n-                ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n-            }\n-            case (ty::ty_tup(?mts)) {\n+            ty::ty_tup(?mts) {\n                 for (ty::mt mt in mts) {\n                     if (helper(tcx, needle, mt.ty, get_mut(mut, mt))) {\n                         ret true;\n                     }\n                 }\n                 ret false;\n             }\n-            case (ty::ty_rec(?fields)) {\n+            ty::ty_rec(?fields) {\n                 for (ty::field f in fields) {\n                     if (helper(tcx, needle, f.mt.ty, get_mut(mut, f.mt))) {\n                         ret true;\n                     }\n                 }\n                 ret false;\n             }\n-            case (\n-                 // These may contain anything.\n-                 ty::ty_fn(_, _, _, _, _)) {\n+            // These may contain anything.\n+            ty::ty_fn(_, _, _, _, _) {\n                 ret true;\n             }\n-            case (ty::ty_obj(_)) { ret true; }\n-            case (\n-                 // A type param may include everything, but can only be\n-                 // treated as opaque downstream, and is thus safe unless we\n-                 // saw mutable fields, in which case the whole thing can be\n-                 // overwritten.\n-                 ty::ty_param(_)) {\n-                ret mut;\n-            }\n-            case (_) { ret false; }\n+            ty::ty_obj(_) { ret true; }\n+            // A type param may include everything, but can only be\n+            // treated as opaque downstream, and is thus safe unless we\n+            // saw mutable fields, in which case the whole thing can be\n+            // overwritten.\n+            ty::ty_param(_) { ret mut; }\n+            _ { ret false; }\n         }\n     }\n     ret helper(*cx.tcx, needle, haystack, mut);\n }\n \n fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n     ret alt (d) {\n-            case (ast::def_local(_)) { true }\n-            case (ast::def_arg(_)) { true }\n-            case (ast::def_obj_field(_)) { objfields_count }\n-            case (ast::def_binding(_)) { true }\n-            case (_) { false }\n-        };\n+        ast::def_local(_) | ast::def_arg(_) | ast::def_binding(_) { true }\n+        ast::def_obj_field(_) { objfields_count }\n+        _ { false }\n+    };\n }\n \n fn fty_args(&ctx cx, ty::t fty) -> ty::arg[] {\n     ret alt (ty::struct(*cx.tcx, ty::type_autoderef(*cx.tcx, fty))) {\n-            case (ty::ty_fn(_, ?args, _, _, _)) { args }\n-            case (ty::ty_native_fn(_, ?args, _)) { args }\n-        };\n+        ty::ty_fn(_, ?args, _, _, _) | ty::ty_native_fn(_, ?args, _) { args }\n+    };\n }\n // Local Variables:\n // mode: rust"}]}