{"sha": "e3c814e62332ec634c2de2e42468a258cf31b178", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYzgxNGU2MjMzMmVjNjM0YzJkZTJlNDI0NjhhMjU4Y2YzMWIxNzg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-12-20T18:07:30Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-12-26T17:26:57Z"}, "message": "prune ill-conceived BTreeMap iter_mut assertion and test more", "tree": {"sha": "0948c73ca040f618c016d11fefacb0e18735959b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0948c73ca040f618c016d11fefacb0e18735959b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3c814e62332ec634c2de2e42468a258cf31b178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3c814e62332ec634c2de2e42468a258cf31b178", "html_url": "https://github.com/rust-lang/rust/commit/e3c814e62332ec634c2de2e42468a258cf31b178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3c814e62332ec634c2de2e42468a258cf31b178/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "html_url": "https://github.com/rust-lang/rust/commit/acb6690e1d58fc5f262ada5b5030fe73e601f1e8"}], "stats": {"total": 177, "additions": 152, "deletions": 25}, "files": [{"sha": "0a2849f6e39612fe08b7a28b5ac2680e3afc5527", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=e3c814e62332ec634c2de2e42468a258cf31b178", "patch": "@@ -493,7 +493,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n-        // We are mutable, so we cannot be the root, so accessing this as a leaf is okay.\n+        // We are mutable, so we cannot be the shared root, so accessing this as a leaf is okay.\n         self.node.as_ptr()\n     }\n \n@@ -514,33 +514,37 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         // but we want to avoid that run-time check.\n         // Instead, we create a slice pointing into the node whenever possible.\n         // We can sometimes do this even for the shared root, as the slice will be\n-        // empty.  We cannot *always* do this because if the type is too highly\n-        // aligned, the offset of `keys` in a \"full node\" might be outside the bounds\n-        // of the header!  So we do an alignment check first, that will be\n-        // evaluated at compile-time, and only do any run-time check in the rare case\n-        // that the alignment is very big.\n-        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+        // empty and `NodeHeader` contains an empty `keys_start` array.\n+        // We cannot *always* do this because:\n+        // - `keys_start` is not correctly typed because we want `NodeHeader`'s size to\n+        //   not depend on the alignment of `K` (needed because `as_header` should be safe).\n+        //   For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n+        //   and hence just adds a size-0-align-1 field, not affecting layout).\n+        //   If the correctly typed header is more highly aligned than the allocated header,\n+        //   we cannot transmute safely.\n+        // - Even if we can transmute, the offset of a correctly typed `keys_start` might\n+        //   be different and outside the bounds of the allocated header!\n+        // So we do an alignment check and a size check first, that will be evaluated\n+        // at compile-time, and only do any run-time check in the rare case that\n+        // the compile-time checks signal danger.\n+        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n+            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n+            && self.is_shared_root()\n+        {\n             &[]\n         } else {\n-            // Thanks to the alignment check above, we know that `keys` will be\n+            // If we are a `LeafNode<K, V>`, we can always transmute to\n+            // `NodeHeader<K, V, K>` and `keys_start` always has the same offset\n+            // as the actual `keys`.\n+            // Thanks to the checks above, we know that we can transmute to\n+            // `NodeHeader<K, V, K>` and that `keys_start` will be\n             // in-bounds of some allocation even if this is the shared root!\n             // (We might be one-past-the-end, but that is allowed by LLVM.)\n-            // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n-            // field because we want its size to not depend on the alignment of `K`\n-            // (needed because `as_header` should be safe).  We cannot call `as_leaf`\n-            // because we might be the shared root.\n-            // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n-            // and hence just adds a size-0-align-1 field, not affecting layout).\n-            // We know that we can transmute `NodeHeader<K, V, ()>` to `NodeHeader<K, V, K>`\n-            // because we did the alignment check above, and hence `NodeHeader<K, V, K>`\n-            // is not bigger than `NodeHeader<K, V, ()>`!  Then we can use `NodeHeader<K, V, K>`\n+            // Thus we can use `NodeHeader<K, V, K>`\n             // to compute the pointer where the keys start.\n             // This entire hack will become unnecessary once\n             // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n             // pointer to the `keys` field of `*const InternalNode<K, V>`.\n-\n-            // This is a non-debug-assert because it can be completely compile-time evaluated.\n-            assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n             let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n             let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n             unsafe { slice::from_raw_parts(keys, self.len()) }\n@@ -549,7 +553,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n-        // We cannot be the root, so `as_leaf` is okay\n+        // We cannot be the shared root, so `as_leaf` is okay\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n@@ -567,9 +571,11 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // Same as for `into_key_slice` above, we try to avoid a run-time check\n-        // (the alignment comparison will usually be performed at compile-time).\n-        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+        // Same as for `into_key_slice` above, we try to avoid a run-time check.\n+        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n+            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n+            && self.is_shared_root()\n+        {\n             &mut []\n         } else {\n             unsafe {"}, {"sha": "35ce1354f52e09b3e9bda104963d186db8736db3", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 113, "deletions": 1, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=e3c814e62332ec634c2de2e42468a258cf31b178", "patch": "@@ -1,5 +1,7 @@\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n+use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n@@ -57,36 +59,65 @@ fn test_basic_large() {\n #[test]\n fn test_basic_small() {\n     let mut map = BTreeMap::new();\n+    // Empty, shared root:\n     assert_eq!(map.remove(&1), None);\n     assert_eq!(map.len(), 0);\n+    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.get_mut(&1), None);\n     assert_eq!(map.first_key_value(), None);\n     assert_eq!(map.last_key_value(), None);\n-    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.keys().count(), 0);\n+    assert_eq!(map.values().count(), 0);\n     assert_eq!(map.insert(1, 1), None);\n+\n+    // 1 key-value pair:\n     assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&1));\n+    assert_eq!(map.get_mut(&1), Some(&mut 1));\n     assert_eq!(map.first_key_value(), Some((&1, &1)));\n     assert_eq!(map.last_key_value(), Some((&1, &1)));\n+    assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1]);\n+    assert_eq!(map.values().collect::<Vec<_>>(), vec![&1]);\n     assert_eq!(map.insert(1, 2), Some(1));\n     assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&2));\n+    assert_eq!(map.get_mut(&1), Some(&mut 2));\n     assert_eq!(map.first_key_value(), Some((&1, &2)));\n     assert_eq!(map.last_key_value(), Some((&1, &2)));\n+    assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1]);\n+    assert_eq!(map.values().collect::<Vec<_>>(), vec![&2]);\n     assert_eq!(map.insert(2, 4), None);\n+\n+    // 2 key-value pairs:\n     assert_eq!(map.len(), 2);\n     assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.get_mut(&2), Some(&mut 4));\n     assert_eq!(map.first_key_value(), Some((&1, &2)));\n     assert_eq!(map.last_key_value(), Some((&2, &4)));\n+    assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1, &2]);\n+    assert_eq!(map.values().collect::<Vec<_>>(), vec![&2, &4]);\n     assert_eq!(map.remove(&1), Some(2));\n+\n+    // 1 key-value pair:\n     assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), None);\n+    assert_eq!(map.get_mut(&1), None);\n     assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.get_mut(&2), Some(&mut 4));\n     assert_eq!(map.first_key_value(), Some((&2, &4)));\n     assert_eq!(map.last_key_value(), Some((&2, &4)));\n+    assert_eq!(map.keys().collect::<Vec<_>>(), vec![&2]);\n+    assert_eq!(map.values().collect::<Vec<_>>(), vec![&4]);\n     assert_eq!(map.remove(&2), Some(4));\n+\n+    // Empty but private root:\n     assert_eq!(map.len(), 0);\n+    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.get_mut(&1), None);\n     assert_eq!(map.first_key_value(), None);\n     assert_eq!(map.last_key_value(), None);\n+    assert_eq!(map.keys().count(), 0);\n+    assert_eq!(map.values().count(), 0);\n     assert_eq!(map.remove(&1), None);\n }\n \n@@ -142,6 +173,87 @@ fn test_iter_rev() {\n     test(size, map.into_iter().rev());\n }\n \n+/// Specifically tests iter_mut's ability to mutate the value of pairs in-line\n+fn do_test_iter_mut_mutation<T>(size: usize)\n+where\n+    T: Copy + Debug + Ord + TryFrom<usize>,\n+    <T as std::convert::TryFrom<usize>>::Error: std::fmt::Debug,\n+{\n+    let zero = T::try_from(0).unwrap();\n+    let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n+\n+    // Forward and backward iteration sees enough pairs (also tested elsewhere)\n+    assert_eq!(map.iter_mut().count(), size);\n+    assert_eq!(map.iter_mut().rev().count(), size);\n+\n+    // Iterate forwards, trying to mutate to unique values\n+    for (i, (k, v)) in map.iter_mut().enumerate() {\n+        assert_eq!(*k, T::try_from(i).unwrap());\n+        assert_eq!(*v, zero);\n+        *v = T::try_from(i + 1).unwrap();\n+    }\n+\n+    // Iterate backwards, checking that mutations succeeded and trying to mutate again\n+    for (i, (k, v)) in map.iter_mut().rev().enumerate() {\n+        assert_eq!(*k, T::try_from(size - i - 1).unwrap());\n+        assert_eq!(*v, T::try_from(size - i).unwrap());\n+        *v = T::try_from(2 * size - i).unwrap();\n+    }\n+\n+    // Check that backward mutations succeeded\n+    for (i, (k, v)) in map.iter_mut().enumerate() {\n+        assert_eq!(*k, T::try_from(i).unwrap());\n+        assert_eq!(*v, T::try_from(size + i + 1).unwrap());\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord)]\n+#[repr(align(32))]\n+struct Align32(usize);\n+\n+impl TryFrom<usize> for Align32 {\n+    type Error = ();\n+\n+    fn try_from(s: usize) -> Result<Align32, ()> {\n+        Ok(Align32(s))\n+    }\n+}\n+\n+#[test]\n+fn test_iter_mut_mutation() {\n+    // Check many alignments because various fields precede array in NodeHeader.\n+    // Check with size 0 which should not iterate at all.\n+    // Check with size 1 for a tree with one kind of node (root = leaf).\n+    // Check with size 12 for a tree with two kinds of nodes (root and leaves).\n+    // Check with size 144 for a tree with all kinds of nodes (root, internals and leaves).\n+    do_test_iter_mut_mutation::<u8>(0);\n+    do_test_iter_mut_mutation::<u8>(1);\n+    do_test_iter_mut_mutation::<u8>(12);\n+    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test 144\n+    do_test_iter_mut_mutation::<u16>(1);\n+    do_test_iter_mut_mutation::<u16>(12);\n+    do_test_iter_mut_mutation::<u16>(144);\n+    do_test_iter_mut_mutation::<u32>(1);\n+    do_test_iter_mut_mutation::<u32>(12);\n+    do_test_iter_mut_mutation::<u32>(144);\n+    do_test_iter_mut_mutation::<u64>(1);\n+    do_test_iter_mut_mutation::<u64>(12);\n+    do_test_iter_mut_mutation::<u64>(144);\n+    do_test_iter_mut_mutation::<u128>(1);\n+    do_test_iter_mut_mutation::<u128>(12);\n+    do_test_iter_mut_mutation::<u128>(144);\n+    do_test_iter_mut_mutation::<Align32>(1);\n+    do_test_iter_mut_mutation::<Align32>(12);\n+    do_test_iter_mut_mutation::<Align32>(144);\n+}\n+\n+#[test]\n+fn test_into_key_slice_with_shared_root_past_bounds() {\n+    let mut map: BTreeMap<Align32, ()> = BTreeMap::new();\n+    assert_eq!(map.get(&Align32(1)), None);\n+    assert_eq!(map.get_mut(&Align32(1)), None);\n+}\n+\n #[test]\n fn test_values_mut() {\n     let mut a = BTreeMap::new();"}, {"sha": "265ef758cc5bc16a3201b08aae46226f043c2f0d", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3c814e62332ec634c2de2e42468a258cf31b178/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=e3c814e62332ec634c2de2e42468a258cf31b178", "patch": "@@ -302,6 +302,15 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_clear() {\n+    let mut x = BTreeSet::new();\n+    x.insert(1);\n+\n+    x.clear();\n+    assert!(x.is_empty());\n+}\n+\n #[test]\n fn test_zip() {\n     let mut x = BTreeSet::new();"}]}