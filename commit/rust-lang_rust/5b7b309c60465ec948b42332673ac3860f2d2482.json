{"sha": "5b7b309c60465ec948b42332673ac3860f2d2482", "node_id": "C_kwDOAAsO6NoAKDViN2IzMDljNjA0NjVlYzk0OGI0MjMzMjY3M2FjMzg2MGYyZDI0ODI", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-10-21T15:02:03Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:24Z"}, "message": "Improve documentation of assumptions", "tree": {"sha": "603ed4c78c21823cdc7e8ceb0f4a5abd3e1cc3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/603ed4c78c21823cdc7e8ceb0f4a5abd3e1cc3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b7b309c60465ec948b42332673ac3860f2d2482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7b309c60465ec948b42332673ac3860f2d2482", "html_url": "https://github.com/rust-lang/rust/commit/5b7b309c60465ec948b42332673ac3860f2d2482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b7b309c60465ec948b42332673ac3860f2d2482/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "062053ba7950076ce25600896302cb3a363d7862", "url": "https://api.github.com/repos/rust-lang/rust/commits/062053ba7950076ce25600896302cb3a363d7862", "html_url": "https://github.com/rust-lang/rust/commit/062053ba7950076ce25600896302cb3a363d7862"}], "stats": {"total": 116, "additions": 51, "deletions": 65}, "files": [{"sha": "8169c41d995577c04ef709e16ff4ea6a534eb066", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 51, "deletions": 65, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5b7b309c60465ec948b42332673ac3860f2d2482/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b7b309c60465ec948b42332673ac3860f2d2482/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=5b7b309c60465ec948b42332673ac3860f2d2482", "patch": "@@ -1,69 +1,49 @@\n //! This module provides a framework on top of the normal MIR dataflow framework to simplify the\n-//! implementation of analyses that track the values stored in places of interest.\n+//! implementation of analyses that track information about the values stored in certain places.\n+//! We are using the term \"place\" here to refer to a `mir::Place` (a place expression) instead of\n+//! an `interpret::Place` (a memory location).\n //!\n //! The default methods of [`ValueAnalysis`] (prefixed with `super_` instead of `handle_`)\n //! provide some behavior that should be valid for all abstract domains that are based only on the\n //! value stored in a certain place. On top of these default rules, an implementation should\n //! override some of the `handle_` methods. For an example, see `ConstAnalysis`.\n //!\n-//! An implementation must also provide a [`Map`]. Before the anaylsis begins, all places that\n-//! should be tracked during the analysis must be registered. Currently, the projections of these\n-//! places may only contain derefs, fields and downcasts (otherwise registration fails). During the\n-//! analysis, no new places can be registered.\n+//! An implementation must also provide a [`Map`]. Before the analysis begins, all places that\n+//! should be tracked during the analysis must be registered. During the analysis, no new places\n+//! can be registered. The [`State`] can be queried to retrieve the abstract value stored for a\n+//! certain place by passing the map.\n //!\n-//! Note that if you want to track values behind references, you have to register the dereferenced\n-//! place. For example: Assume `let x = (0, 0)` and that we want to propagate values from `x.0` and\n-//! `x.1` also through the assignment `let y = &x`. In this case, we should register `x.0`, `x.1`,\n-//! `(*y).0` and `(*y).1`.\n+//! This framework is currently experimental. In particular, the features related to references are\n+//! currently guarded behind `-Zunsound-mir-opts`, because their correctness relies on Stacked\n+//! Borrows. Also, only places with scalar types can be tracked currently. This is because scalar\n+//! types are indivisible, which simplifies the current implementation. But this limitation could be\n+//! lifted in the future.\n //!\n //!\n-//! # Correctness\n+//! # Notes\n //!\n-//! Warning: This is a semi-formal attempt to argue for the correctness of this analysis. If you\n-//! find any weak spots, let me know! Recommended reading: Abstract Interpretation. We will use the\n-//! term \"place\" to refer to a place expression (like `mir::Place`), and we will call the\n-//! underlying entity \"object\". For instance, `*_1` and `*_2` are not the same place, but depending\n-//! on the value of `_1` and `_2`, they could refer to the same object. Also, the same place can\n-//! refer to different objects during execution. If `_1` is reassigned, then `*_1` may refer to\n-//! different objects before and after assignment. Additionally, when saying \"access to a place\",\n-//! what we really mean is \"access to an object denoted by arbitrary projections of that place\".\n+//! - The bottom state denotes uninitialized memory. Because we are only doing a sound approximation\n+//! of the actual execution, we can also use this state for places where access would be UB.\n //!\n-//! In the following, we will assume a constant propagation analysis. Our analysis is correct if\n-//! every transfer function is correct. This is the case if for every pair (f, f#) and abstract\n-//! state s, we have f(y(s)) <= y(f#(s)), where s is a mapping from tracked place to top, bottom or\n-//! a constant. Since pointers (and mutable references) are not tracked, but can be used to change\n-//! values in the concrete domain, f# must assume that all places that can be affected in this way\n-//! for a given program point are already marked with top in s (otherwise many assignments and\n-//! function calls would have no choice but to mark all tracked places with top). This leads us to\n-//! an invariant: For all possible program points where there could possibly exist means of mutable\n-//! access to a tracked place (in the concrete domain), this place must be assigned to top (in the\n-//! abstract domain). The concretization function y can be defined as expected for the constant\n-//! propagation analysis, although the concrete state of course contains all kinds of non-tracked\n-//! data. However, by the invariant above, no mutable access to tracked places that are not marked\n-//! with top may be introduced.\n+//! - The assignment logic in `State::assign_place_idx` assumes that the places are non-overlapping,\n+//! or identical. Note that this refers to place expressions, not memory locations.\n //!\n-//! Note that we (at least currently) do not differentiate between \"this place may assume different\n-//! values\" and \"a pointer to this place escaped the analysis\". However, we still want to handle\n-//! assignments to constants as usual for f#. This adds an assumption: Whenever we have an\n-//! assignment that is captured by the analysis, all mutable access to the underlying place (which\n-//! is not observable by the analysis) must be invalidated. This is (hopefully) covered by Stacked\n-//! Borrows.\n+//! - Since pointers (and mutable references) are not tracked, but can be used to change the\n+//! underlying values, we are conservative and immediately flood the referenced place upon creation\n+//! of the pointer. Also, we have to uphold the invariant that the place must stay that way as long\n+//! as this mutable access could exist. However...\n //!\n-//! To be continued...\n+//! - Without an aliasing model like Stacked Borrows (i.e., `-Zunsound-mir-opts` is not given),\n+//! such mutable access is never revoked. And even shared references could be used to obtain the\n+//! address of a value an modify it. When not assuming Stacked Borrows, we prevent such places from\n+//! being tracked at all. This means that the analysis itself can assume that writes to a *tracked*\n+//! place always invalidate all other means of mutable access, regardless of the aliasing model.\n //!\n-//! The bottom state denotes uninitalized memory.\n-//!\n-//!\n-//! # Assumptions\n-//!\n-//! - (A1) Assignment to any tracked place invalidates all pointers that could be used to change\n-//!     the underlying value.\n-//! - (A2) `StorageLive`, `StorageDead` and `Deinit` make the underlying memory at least\n-//!     uninitialized (at least in the sense that declaring access UB is also fine).\n-//! - (A3) An assignment with `State::assign_place_idx` either involves non-overlapping places, or\n-//!     the places are the same.\n-//! - (A4) If the value behind a reference to a `Freeze` place is changed, dereferencing the\n-//!     reference is UB.\n+//! - Likewise, the analysis itself assumes that if the value of a *tracked* place behind a shared\n+//! reference is changed, the reference may not be used to access that value anymore. This is true\n+//! for all places if the referenced type is `Freeze` and we assume Stacked Borrows. If we are not\n+//! assuming Stacking Borrows (or if the referenced type could be `!Freeze`), we again prevent such\n+//! places from being tracked at all, making this assertion trivially true.\n \n use std::fmt::{Debug, Formatter};\n \n@@ -107,11 +87,12 @@ pub trait ValueAnalysis<'tcx> {\n                 self.handle_intrinsic(intrinsic, state);\n             }\n             StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                // (A2)\n+                // StorageLive leaves the local in an uninitialized state.\n+                // StorageDead makes it UB to access the local afterwards.\n                 state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::bottom());\n             }\n             StatementKind::Deinit(box place) => {\n-                // (A2)\n+                // Deinit makes the place uninitialized.\n                 state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n             }\n             StatementKind::Retag(..) => {\n@@ -477,9 +458,9 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     /// Copies `source` to `target`, including all tracked places beneath.\n     ///\n     /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n-    /// Top. Also, because this will copy all entries one after another, it may only be\n+    /// Top. Also, because this will copy all entries one after another, it may only be used for\n+    /// places that are non-overlapping or identical.\n     pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n-        // We use (A3) and copy all entries one after another.\n         let StateData::Reachable(values) = &mut self.0 else { return };\n \n         // If both places are tracked, we copy the value to the target. If the target is tracked,\n@@ -528,21 +509,24 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n                 if let Some(value_index) = map.places[target].value_index {\n                     values[value_index] = V::top();\n                 }\n-                // Instead of tracking of *where* a reference points to (as in, which place), we\n-                // track *what* it points to (as in, what do we know about the target). For an\n-                // assignment `x = &y`, we thus copy the info we have for `y` to `*x`. This is\n-                // sound because we only track places that are `Freeze`, and (A4).\n+                // Instead of tracking of *where* a reference points to (as in, which memory\n+                // location), we track *what* it points to (as in, what do we know about the\n+                // target). For an assignment `x = &y`, we thus copy the info of `y` to `*x`.\n                 if let Some(target_deref) = map.apply(target, TrackElem::Deref) {\n+                    // We know here that `*x` is `Freeze`, because we only track through\n+                    // dereferences if the target type is `Freeze`.\n                     self.assign_place_idx(target_deref, source, map);\n                 }\n             }\n         }\n     }\n \n+    /// Retrieve the value stored for a place, or \u22a5 if it is not tracked.\n     pub fn get(&self, place: PlaceRef<'_>, map: &Map) -> V {\n         map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n     }\n \n+    /// Retrieve the value stored for a place index, or \u22a5 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n             StateData::Reachable(values) => {\n@@ -569,11 +553,11 @@ impl<V: JoinSemiLattice + Clone> JoinSemiLattice for State<V> {\n     }\n }\n \n-/// A partial mapping from `Place` to `PlaceIndex`.\n+/// A partial mapping from `Place` to `PlaceIndex`, where some place indices have value indices.\n ///\n-/// Some additioanl bookkeeping is done to speed up traversal:\n+/// Some additional bookkeeping is done to speed up traversal:\n /// - For iteration, every [`PlaceInfo`] contains an intrusive linked list of its children.\n-/// - To directly get the child for a specific projection, there is `projections` map.\n+/// - To directly get the child for a specific projection, there is a `projections` map.\n #[derive(Debug)]\n pub struct Map {\n     locals: IndexVec<Local, Option<PlaceIndex>>,\n@@ -595,7 +579,7 @@ impl Map {\n     /// Returns a map that only tracks places whose type passes the filter.\n     ///\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n-    /// chosen is an implementation detail an may not be relied upon.\n+    /// chosen is an implementation detail and may not be relied upon.\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -609,7 +593,7 @@ impl Map {\n         // not yet guaranteed).\n         if tcx.sess.opts.unstable_opts.unsound_mir_opts {\n             // We might want to add additional limitations. If a struct has 10 boxed fields of\n-            // itself, will currently be `10.pow(max_derefs)` tracked places.\n+            // itself, there will currently be `10.pow(max_derefs)` tracked places.\n             map.register_with_filter(tcx, body, 2, filter, &[]);\n         } else {\n             map.register_with_filter(tcx, body, 0, filter, &escaped_places(body));\n@@ -668,7 +652,7 @@ impl Map {\n \n         if max_derefs > 0 {\n             if let Some(ty::TypeAndMut { ty: deref_ty, .. }) = ty.builtin_deref(false) {\n-                // References can only be tracked if the target is `!Freeze`.\n+                // Values behind references can only be tracked if the target is `Freeze`.\n                 if deref_ty.is_freeze(tcx.at(DUMMY_SP), param_env) {\n                     projection.push(PlaceElem::Deref);\n                     self.register_with_filter_rec(\n@@ -953,6 +937,8 @@ fn iter_fields<'tcx>(\n }\n \n /// Returns all places, that have their reference or address taken.\n+///\n+/// This includes shared references.\n fn escaped_places<'tcx>(body: &Body<'tcx>) -> Vec<Place<'tcx>> {\n     struct Collector<'tcx> {\n         result: Vec<Place<'tcx>>,"}]}