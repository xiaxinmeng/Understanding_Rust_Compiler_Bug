{"sha": "2b5257e4c770c6a4964a7897fa1348be5050797f", "node_id": "C_kwDOAAsO6NoAKDJiNTI1N2U0Yzc3MGM2YTQ5NjRhNzg5N2ZhMTM0OGJlNTA1MDc5N2Y", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-12-30T19:37:14Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-12-30T19:37:14Z"}, "message": "Remove method_call! macro", "tree": {"sha": "a71e5f4c9e78d446b2a876cf2cada69dc99b37e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a71e5f4c9e78d446b2a876cf2cada69dc99b37e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b5257e4c770c6a4964a7897fa1348be5050797f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5257e4c770c6a4964a7897fa1348be5050797f", "html_url": "https://github.com/rust-lang/rust/commit/2b5257e4c770c6a4964a7897fa1348be5050797f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b5257e4c770c6a4964a7897fa1348be5050797f/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eff589afc83e21a03a168497bbab6b4dfbb4ef6", "html_url": "https://github.com/rust-lang/rust/commit/0eff589afc83e21a03a168497bbab6b4dfbb4ef6"}], "stats": {"total": 41, "additions": 16, "deletions": 25}, "files": [{"sha": "ad07370f26d3b0dfa15adc4530077b20c38ad36f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2b5257e4c770c6a4964a7897fa1348be5050797f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5257e4c770c6a4964a7897fa1348be5050797f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2b5257e4c770c6a4964a7897fa1348be5050797f", "patch": "@@ -80,7 +80,6 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -1997,24 +1996,16 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(Symbol, &'tcx [hir::Expr<'tcx>], Span)> {\n+fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n     if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) {\n-            return Some((path.ident.name, args, span));\n+            let name = path.ident.name.as_str();\n+            return Some((name, args, span));\n         }\n     }\n     None\n }\n \n-/// Same as `method_call` but the `Symbol` is dereferenced into a temporary `&str`\n-macro_rules! method_call {\n-    ($expr:expr) => {\n-        method_call($expr)\n-            .as_ref()\n-            .map(|&(ref name, args, span)| (name.as_str(), args, span))\n-    };\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for Methods {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if expr.span.from_expansion() {\n@@ -2217,7 +2208,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n #[allow(clippy::too_many_lines)]\n fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n-    if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n+    if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n         match (name, args) {\n             (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                 zst_offset::check(cx, expr, recv);\n@@ -2233,7 +2224,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n             (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n             (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, msrv),\n-            (\"collect\", []) => match method_call!(recv) {\n+            (\"collect\", []) => match method_call(recv) {\n                 Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n                     iter_cloned_collect::check(cx, name, expr, recv2);\n                 },\n@@ -2247,14 +2238,14 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 },\n                 _ => {},\n             },\n-            (\"count\", []) => match method_call!(recv) {\n+            (\"count\", []) => match method_call(recv) {\n                 Some((name @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n                     iter_count::check(cx, expr, recv2, name);\n                 },\n                 Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n                 _ => {},\n             },\n-            (\"expect\", [_]) => match method_call!(recv) {\n+            (\"expect\", [_]) => match method_call(recv) {\n                 Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                 _ => expect_used::check(cx, expr, recv),\n             },\n@@ -2271,13 +2262,13 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 flat_map_option::check(cx, expr, arg, span);\n             },\n             (\"flatten\", []) => {\n-                if let Some((\"map\", [recv, map_arg], _)) = method_call!(recv) {\n+                if let Some((\"map\", [recv, map_arg], _)) = method_call(recv) {\n                     map_flatten::check(cx, expr, recv, map_arg);\n                 }\n             },\n             (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n             (\"for_each\", [_]) => {\n-                if let Some((\"inspect\", [_, _], span2)) = method_call!(recv) {\n+                if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n                     inspect_for_each::check(cx, expr, span2);\n                 }\n             },\n@@ -2286,7 +2277,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n             (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n             (\"map\", [m_arg]) => {\n-                if let Some((name, [recv2, args @ ..], span2)) = method_call!(recv) {\n+                if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                     match (name, args) {\n                         (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n                         (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n@@ -2301,7 +2292,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             },\n             (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n             (\"next\", []) => {\n-                if let Some((name, [recv, args @ ..], _)) = method_call!(recv) {\n+                if let Some((name, [recv, args @ ..], _)) = method_call(recv) {\n                     match (name, args) {\n                         (\"filter\", [arg]) => filter_next::check(cx, expr, recv, arg),\n                         (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv, arg, msrv),\n@@ -2312,7 +2303,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     }\n                 }\n             },\n-            (\"nth\", [n_arg]) => match method_call!(recv) {\n+            (\"nth\", [n_arg]) => match method_call(recv) {\n                 Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n                 Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n                 Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n@@ -2344,12 +2335,12 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n                 implicit_clone::check(cx, name, expr, recv, span);\n             },\n-            (\"unwrap\", []) => match method_call!(recv) {\n+            (\"unwrap\", []) => match method_call(recv) {\n                 Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n                 Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n                 _ => unwrap_used::check(cx, expr, recv),\n             },\n-            (\"unwrap_or\", [u_arg]) => match method_call!(recv) {\n+            (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n                 Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n                     manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                 },\n@@ -2358,7 +2349,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 },\n                 _ => {},\n             },\n-            (\"unwrap_or_else\", [u_arg]) => match method_call!(recv) {\n+            (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n                 Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n                 _ => {\n                     unwrap_or_else_default::check(cx, expr, recv, u_arg);\n@@ -2371,7 +2362,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call!(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }"}]}