{"sha": "cea4803d4cf56ded65be6a9e043a6219c661c572", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYTQ4MDNkNGNmNTZkZWQ2NWJlNmE5ZTA0M2E2MjE5YzY2MWM1NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T21:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T21:46:24Z"}, "message": "auto merge of #14135 : gereeter/rust/two-way-search, r=brson\n\nThis changes the previously naive string searching algorithm to a two-way search like glibc, which should be faster on average while still maintaining worst case linear time complexity. This fixes #14107. Note that I don't think this should be merged yet, as this is the only approach to speeding up search I've tried - it's worth considering options like Boyer-Moore or adding a bad character shift table to this. However, the benchmarks look quite good so far:\r\n\r\n    test str::bench::bench_contains_bad_naive                   ... bench:       290 ns/iter (+/- 12)     from 1309 ns/iter (+/- 36)\r\n    test str::bench::bench_contains_equal                       ... bench:       479 ns/iter (+/- 10)     from  137 ns/iter (+/- 2)\r\n    test str::bench::bench_contains_short_long                  ... bench:      2844 ns/iter (+/- 105)    from 5473 ns/iter (+/- 14)\r\n    test str::bench::bench_contains_short_short                 ... bench:        55 ns/iter (+/- 4)      from   57 ns/iter (+/- 6)\r\n\r\nExcept for the case specifically designed to be optimal for the naive case (`bench_contains_equal`), this gets as good or better performance as the previous code.", "tree": {"sha": "55185a34ed1bbf264c883070e6c67a59a2f8ffc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55185a34ed1bbf264c883070e6c67a59a2f8ffc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cea4803d4cf56ded65be6a9e043a6219c661c572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cea4803d4cf56ded65be6a9e043a6219c661c572", "html_url": "https://github.com/rust-lang/rust/commit/cea4803d4cf56ded65be6a9e043a6219c661c572", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cea4803d4cf56ded65be6a9e043a6219c661c572/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "html_url": "https://github.com/rust-lang/rust/commit/5e10686aabb7253e6a6e660e72c7f5de8bbba3de"}, {"sha": "39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "url": "https://api.github.com/repos/rust-lang/rust/commits/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a", "html_url": "https://github.com/rust-lang/rust/commit/39cb5b13e68b4616a1f1e8dff4fd3f5241e1842a"}], "stats": {"total": 306, "additions": 280, "deletions": 26}, "files": [{"sha": "0d820836377d395dc95fdc77f4c0fe040dd996ba", "filename": "src/libcore/str.rs", "status": "modified", "additions": 206, "deletions": 26, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/cea4803d4cf56ded65be6a9e043a6219c661c572/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea4803d4cf56ded65be6a9e043a6219c661c572/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cea4803d4cf56ded65be6a9e043a6219c661c572", "patch": "@@ -15,16 +15,19 @@\n use mem;\n use char;\n use clone::Clone;\n+use cmp;\n use cmp::{Eq, TotalEq};\n use container::Container;\n use default::Default;\n use iter::{Filter, Map, Iterator};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n+use iter::range;\n use num::Saturating;\n use option::{None, Option, Some};\n use raw::Repr;\n use slice::{ImmutableVector, Vector};\n use slice;\n+use uint;\n \n /*\n Section: Creating a string\n@@ -316,13 +319,207 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n     }\n }\n \n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using naive search\n+#[deriving(Clone)]\n+struct NaiveSearcher {\n+    position: uint\n+}\n+\n+impl NaiveSearcher {\n+    fn new() -> NaiveSearcher {\n+        NaiveSearcher { position: 0 }\n+    }\n+\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n+        while self.position + needle.len() <= haystack.len() {\n+            if haystack.slice(self.position, self.position + needle.len()) == needle {\n+                let matchPos = self.position;\n+                self.position += needle.len(); // add 1 for all matches\n+                return Some((matchPos, matchPos + needle.len()));\n+            } else {\n+                self.position += 1;\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using two-way search\n+#[deriving(Clone)]\n+struct TwoWaySearcher {\n+    // constants\n+    critPos: uint,\n+    period: uint,\n+    byteset: u64,\n+\n+    // variables\n+    position: uint,\n+    memory: uint\n+}\n+\n+impl TwoWaySearcher {\n+    fn new(needle: &[u8]) -> TwoWaySearcher {\n+        let (critPos1, period1) = TwoWaySearcher::maximal_suffix(needle, false);\n+        let (critPos2, period2) = TwoWaySearcher::maximal_suffix(needle, true);\n+\n+        let critPos;\n+        let period;\n+        if critPos1 > critPos2 {\n+            critPos = critPos1;\n+            period = period1;\n+        } else {\n+            critPos = critPos2;\n+            period = period2;\n+        }\n+\n+        let byteset = needle.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+\n+        if needle.slice_to(critPos) == needle.slice_from(needle.len() - critPos) {\n+            TwoWaySearcher {\n+                critPos: critPos,\n+                period: period,\n+                byteset: byteset,\n+\n+                position: 0,\n+                memory: 0\n+            }\n+        } else {\n+            TwoWaySearcher {\n+                critPos: critPos,\n+                period: cmp::max(critPos, needle.len() - critPos) + 1,\n+                byteset: byteset,\n+\n+                position: 0,\n+                memory: uint::MAX // Dummy value to signify that the period is long\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], longPeriod: bool) -> Option<(uint, uint)> {\n+        'search: loop {\n+            // Check that we have room to search in\n+            if self.position + needle.len() > haystack.len() {\n+                return None;\n+            }\n+\n+            // Quickly skip by large portions unrelated to our substring\n+            if (self.byteset >> (haystack[self.position + needle.len() - 1] & 0x3f)) & 1 == 0 {\n+                self.position += needle.len();\n+                continue 'search;\n+            }\n+\n+            // See if the right part of the needle matches\n+            let start = if longPeriod { self.critPos } else { cmp::max(self.critPos, self.memory) };\n+            for i in range(start, needle.len()) {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += i - self.critPos + 1;\n+                    if !longPeriod {\n+                        self.memory = 0;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // See if the left part of the needle matches\n+            let start = if longPeriod { 0 } else { self.memory };\n+            for i in range(start, self.critPos).rev() {\n+                if needle[i] != haystack[self.position + i] {\n+                    self.position += self.period;\n+                    if !longPeriod {\n+                        self.memory = needle.len() - self.period;\n+                    }\n+                    continue 'search;\n+                }\n+            }\n+\n+            // We have found a match!\n+            let matchPos = self.position;\n+            self.position += needle.len(); // add self.period for all matches\n+            if !longPeriod {\n+                self.memory = 0; // set to needle.len() - self.period for all matches\n+            }\n+            return Some((matchPos, matchPos + needle.len()));\n+        }\n+    }\n+\n+    #[inline]\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+        let mut left = -1; // Corresponds to i in the paper\n+        let mut right = 0; // Corresponds to j in the paper\n+        let mut offset = 1; // Corresponds to k in the paper\n+        let mut period = 1; // Corresponds to p in the paper\n+\n+        while right + offset < arr.len() {\n+            let a;\n+            let b;\n+            if reversed {\n+                a = arr[left + offset];\n+                b = arr[right + offset];\n+            } else {\n+                a = arr[right + offset];\n+                b = arr[left + offset];\n+            }\n+            if a < b {\n+                // Suffix is smaller, period is entire prefix so far.\n+                right += offset;\n+                offset = 1;\n+                period = right - left;\n+            } else if a == b {\n+                // Advance through repetition of the current period.\n+                if offset == period {\n+                    right += offset;\n+                    offset = 1;\n+                } else {\n+                    offset += 1;\n+                }\n+            } else {\n+                // Suffix is larger, start over from current location.\n+                left = right;\n+                right += 1;\n+                offset = 1;\n+                period = 1;\n+            }\n+        }\n+        (left + 1, period)\n+    }\n+}\n+\n+/// The internal state of an iterator that searches for matches of a substring\n+/// within a larger string using a dynamically chosed search algorithm\n+#[deriving(Clone)]\n+enum Searcher {\n+    Naive(NaiveSearcher),\n+    TwoWay(TwoWaySearcher),\n+    TwoWayLong(TwoWaySearcher)\n+}\n+\n+impl Searcher {\n+    fn new(haystack: &[u8], needle: &[u8]) -> Searcher {\n+        // FIXME: Tune this.\n+        if needle.len() > haystack.len() - 20 {\n+            Naive(NaiveSearcher::new())\n+        } else {\n+            let searcher = TwoWaySearcher::new(needle);\n+            if searcher.memory == uint::MAX { // If the period is long\n+                TwoWayLong(searcher)\n+            } else {\n+                TwoWay(searcher)\n+            }\n+        }\n+    }\n+}\n+\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[deriving(Clone)]\n pub struct MatchIndices<'a> {\n+    // constants\n     haystack: &'a str,\n     needle: &'a str,\n-    position: uint,\n+    searcher: Searcher\n }\n \n /// An iterator over the substrings of a string separated by a given\n@@ -337,31 +534,14 @@ pub struct StrSplits<'a> {\n impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n-        // See Issue #1932 for why this is a naive search\n-        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n-        let mut match_start = 0;\n-        let mut match_i = 0;\n-\n-        while self.position < h_len {\n-            if self.haystack[self.position] == self.needle[match_i] {\n-                if match_i == 0 { match_start = self.position; }\n-                match_i += 1;\n-                self.position += 1;\n-\n-                if match_i == n_len {\n-                    // found a match!\n-                    return Some((match_start, self.position));\n-                }\n-            } else {\n-                // failed match, backtrack\n-                if match_i > 0 {\n-                    match_i = 0;\n-                    self.position = match_start;\n-                }\n-                self.position += 1;\n-            }\n+        match self.searcher {\n+            Naive(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n+            TwoWay(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n+            TwoWayLong(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true)\n         }\n-        None\n     }\n }\n \n@@ -1581,7 +1761,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         MatchIndices {\n             haystack: *self,\n             needle: sep,\n-            position: 0\n+            searcher: Searcher::new(self.as_bytes(), sep.as_bytes())\n         }\n     }\n "}, {"sha": "617887e8af3ea9e5c61f53364e899b510c96710b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cea4803d4cf56ded65be6a9e043a6219c661c572/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cea4803d4cf56ded65be6a9e043a6219c661c572/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cea4803d4cf56ded65be6a9e043a6219c661c572", "patch": "@@ -2421,4 +2421,78 @@ mod bench {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n         })\n     }\n+\n+    #[bench]\n+    fn bench_contains_short_short(b: &mut Bencher) {\n+        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+        let needle = \"sit\";\n+\n+        b.iter(|| {\n+            assert!(haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_short_long(b: &mut Bencher) {\n+        let haystack = \"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum.\";\n+        let needle = \"english\";\n+\n+        b.iter(|| {\n+            assert!(!haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_bad_naive(b: &mut Bencher) {\n+        let haystack = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n+        let needle = \"aaaaaaaab\";\n+\n+        b.iter(|| {\n+            assert!(!haystack.contains(needle));\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_contains_equal(b: &mut Bencher) {\n+        let haystack = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+        let needle = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n+\n+        b.iter(|| {\n+            assert!(haystack.contains(needle));\n+        })\n+    }\n }"}]}