{"sha": "2dc6e8b01f5b5462249617baf79e29da0be363d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYzZlOGIwMWY1YjU0NjIyNDk2MTdiYWY3OWUyOWRhMGJlMzYzZDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-10T07:20:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-10T07:20:33Z"}, "message": "Merge pull request #683 from Aaron1011/feature/random\n\nImplement non-deterministc mode", "tree": {"sha": "1caf8c4cf3ba2fe778404ed8c7068d1339e4cabb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1caf8c4cf3ba2fe778404ed8c7068d1339e4cabb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dc6e8b01f5b5462249617baf79e29da0be363d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcrZlBCRBK7hj4Ov3rIwAAdHIIAIDDvTs7O4Kqc0wEimWZioAc\n8G3z9oALyJxZDQr02Sdqhcnu4YJWjH4WnIkA9vDebz1kjPPnJcrwYy971i+cO0eT\ngprlQhSgXki5nVd2tr3KyxF+07bG+JXT94AgFOzhZXXY5mq7rlvNFl2aRvgPJe83\n7rEFdaZlgFbDAnNQf3Wz/zWNhSWYFc0Td12iUtGR/hvAeu+OMfg4MM/H6xTqR3B6\nSUv1H8S6UP1FQHS8ykvRJlDGcfYu6q4fUB3GeUZIuQXi6LJDwb5JU+o9duPrtiyZ\nONkDdNpR9ryqNA0oH/yVQgAuJo/K8K4CYtNtF9SI4y/cvR005up9jX5jwKrDaMY=\n=Ec2F\n-----END PGP SIGNATURE-----\n", "payload": "tree 1caf8c4cf3ba2fe778404ed8c7068d1339e4cabb\nparent 28f2e5b17a9a4c33a810dffda8eaaf55a1b8b70d\nparent a8763f3d8d8e362f49090e8d99a86920f2e55fef\nauthor Ralf Jung <post@ralfj.de> 1554880833 +0200\ncommitter GitHub <noreply@github.com> 1554880833 +0200\n\nMerge pull request #683 from Aaron1011/feature/random\n\nImplement non-deterministc mode"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc6e8b01f5b5462249617baf79e29da0be363d0", "html_url": "https://github.com/rust-lang/rust/commit/2dc6e8b01f5b5462249617baf79e29da0be363d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dc6e8b01f5b5462249617baf79e29da0be363d0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28f2e5b17a9a4c33a810dffda8eaaf55a1b8b70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/28f2e5b17a9a4c33a810dffda8eaaf55a1b8b70d", "html_url": "https://github.com/rust-lang/rust/commit/28f2e5b17a9a4c33a810dffda8eaaf55a1b8b70d"}, {"sha": "a8763f3d8d8e362f49090e8d99a86920f2e55fef", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8763f3d8d8e362f49090e8d99a86920f2e55fef", "html_url": "https://github.com/rust-lang/rust/commit/a8763f3d8d8e362f49090e8d99a86920f2e55fef"}], "stats": {"total": 162, "additions": 136, "deletions": 26}, "files": [{"sha": "6c77315bea48b238cfe1512b8a405bc672f1f682", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -44,6 +44,8 @@ shell-escape = \"0.1.4\"\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information.\n rustc-workspace-hack = \"1.0.0\"\n+hex = \"0.3.2\"\n+rand = \"0.6.5\"\n \n [build-dependencies]\n vergen = \"3\""}, {"sha": "44a94cd61a0b42f1a20baae5409f43c06fdae035", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -24,7 +24,7 @@ impl rustc_driver::Callbacks for MiriCompilerCalls<'_> {\n             );\n \n             self.bencher.iter(|| {\n-                let config = miri::MiriConfig { validate: true, args: vec![] };\n+                let config = miri::MiriConfig { validate: true, args: vec![], seed: None };\n                 eval_main(tcx, entry_def_id, config);\n             });\n         });"}, {"sha": "ce2ad1a2715db8527cf8201635a4526ce8a9cd69", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -48,7 +48,7 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n                     fn visit_item(&mut self, i: &'hir hir::Item) {\n                         if let hir::ItemKind::Fn(.., body_id) = i.node {\n                             if i.attrs.iter().any(|attr| attr.check_name(\"test\")) {\n-                                let config = MiriConfig { validate: true, args: vec![] };\n+                                let config = MiriConfig { validate: true, args: vec![], seed: None };\n                                 let did = self.0.hir().body_owner_def_id(body_id);\n                                 println!(\"running test: {}\", self.0.def_path_debug_str(did));\n                                 miri::eval_main(self.0, did, config);\n@@ -61,7 +61,7 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n                 }\n                 tcx.hir().krate().visit_all_item_likes(&mut Visitor(tcx));\n             } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-                let config = MiriConfig { validate: true, args: vec![] };\n+                let config = MiriConfig { validate: true, args: vec![], seed: None };\n                 miri::eval_main(tcx, entry_def_id, config);\n \n                 compiler.session().abort_if_errors();"}, {"sha": "6e68f803f8584e0a6cd9cffb08d951ed9beea32b", "filename": "src/bin/miri.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -126,6 +126,7 @@ fn main() {\n \n     // Parse our arguments and split them across `rustc` and `miri`.\n     let mut validate = true;\n+    let mut seed: Option<u64> = None;\n     let mut rustc_args = vec![];\n     let mut miri_args = vec![];\n     let mut after_dashdash = false;\n@@ -145,6 +146,20 @@ fn main() {\n                 \"--\" => {\n                     after_dashdash = true;\n                 }\n+                arg if arg.starts_with(\"-Zmiri-seed=\") => {\n+                    if seed.is_some() {\n+                        panic!(\"Cannot specify -Zmiri-seed multiple times!\");\n+                    }\n+                    let seed_raw = hex::decode(arg.trim_start_matches(\"-Zmiri-seed=\")).unwrap();\n+                    if seed_raw.len() > 8 {\n+                        panic!(format!(\"-Zmiri-seed must be at most 8 bytes, was {}\", seed_raw.len()));\n+                    }\n+\n+                    let mut bytes = [0; 8];\n+                    bytes[..seed_raw.len()].copy_from_slice(&seed_raw);\n+                    seed = Some(u64::from_be_bytes(bytes));\n+\n+                },\n                 _ => {\n                     rustc_args.push(arg);\n                 }\n@@ -163,7 +178,7 @@ fn main() {\n \n     debug!(\"rustc arguments: {:?}\", rustc_args);\n     debug!(\"miri arguments: {:?}\", miri_args);\n-    let miri_config = miri::MiriConfig { validate, args: miri_args };\n+    let miri_config = miri::MiriConfig { validate, args: miri_args, seed };\n     let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n         rustc_driver::run_compiler(&rustc_args, &mut MiriCompilerCalls { miri_config }, None, None)\n     }).and_then(|result| result);"}, {"sha": "3e12c1dd1c6dc784e90c42063a6c6c40effd3948", "filename": "src/fn_call.rs", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -4,6 +4,8 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use syntax::attr;\n \n+use rand::RngCore;\n+\n use crate::*;\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n@@ -224,16 +226,26 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             \"syscall\" => {\n-                // TODO: read `syscall` IDs like `sysconf` IDs and\n-                // figure out some way to actually process some of them.\n-                //\n+                let sys_getrandom = this.eval_path_scalar(&[\"libc\", \"SYS_getrandom\"])?\n+                    .expect(\"Failed to get libc::SYS_getrandom\")\n+                    .to_usize(this)?;\n+\n                 // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n-                // is called if a `HashMap` is created the regular way.\n+                // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                 match this.read_scalar(args[0])?.to_usize(this)? {\n-                    318 | 511 => {\n-                        return err!(Unimplemented(\n-                            \"miri does not support random number generators\".to_owned(),\n-                        ))\n+                    id if id == sys_getrandom => {\n+                        let ptr = this.read_scalar(args[1])?.to_ptr()?;\n+                        let len = this.read_scalar(args[2])?.to_usize(this)?;\n+\n+                        // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n+                        // neither of which have any effect on our current PRNG\n+                        let _flags = this.read_scalar(args[3])?.to_i32()?;\n+\n+                        let data = gen_random(this, len as usize)?;\n+                        this.memory_mut().get_mut(ptr.alloc_id)?\n+                                    .write_bytes(tcx, ptr, &data)?;\n+\n+                        this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n                     }\n                     id => {\n                         return err!(Unimplemented(\n@@ -499,18 +511,13 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n-                    if let Ok(instance) = this.resolve_path(path) {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        let const_val = this.const_eval_raw(cid)?;\n-                        let const_val = this.read_scalar(const_val.into())?;\n-                        let value = const_val.to_i32()?;\n-                        if value == name {\n+                    if let Some(val) = this.eval_path_scalar(path)? {\n+                        let val = val.to_i32()?;\n+                        if val == name {\n                             result = Some(path_value);\n                             break;\n                         }\n+\n                     }\n                 }\n                 if let Some(result) = result {\n@@ -757,6 +764,17 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             \"GetCommandLineW\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.cmd_line.unwrap()), dest)?;\n             }\n+            // The actual name of 'RtlGenRandom'\n+            \"SystemFunction036\" => {\n+                let ptr = this.read_scalar(args[0])?.to_ptr()?;\n+                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+\n+                let data = gen_random(this, len as usize)?;\n+                this.memory_mut().get_mut(ptr.alloc_id)?\n+                    .write_bytes(tcx, ptr, &data)?;\n+\n+                this.write_scalar(Scalar::from_bool(true), dest)?;\n+            }\n \n             // We can't execute anything else.\n             _ => {\n@@ -774,4 +792,42 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n     fn write_null(&mut self, dest: PlaceTy<'tcx, Borrow>) -> EvalResult<'tcx> {\n         self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n+\n+    /// Evaluates the scalar at the specified path. Returns Some(val)\n+    /// if the path could be resolved, and None otherwise\n+    fn eval_path_scalar(&mut self, path: &[&str]) -> EvalResult<'tcx, Option<ScalarMaybeUndef<stacked_borrows::Borrow>>> {\n+        let this = self.eval_context_mut();\n+        if let Ok(instance) = this.resolve_path(path) {\n+            let cid = GlobalId {\n+                instance,\n+                promoted: None,\n+            };\n+            let const_val = this.const_eval_raw(cid)?;\n+            let const_val = this.read_scalar(const_val.into())?;\n+            return Ok(Some(const_val));\n+        }\n+        return Ok(None);\n+    }\n+}\n+\n+fn gen_random<'a, 'mir, 'tcx>(\n+    this: &mut MiriEvalContext<'a, 'mir, 'tcx>,\n+    len: usize,\n+) -> Result<Vec<u8>, EvalError<'tcx>>  {\n+\n+    match &mut this.machine.rng {\n+        Some(rng) => {\n+            let mut data = vec![0; len];\n+            rng.fill_bytes(&mut data);\n+            Ok(data)\n+        }\n+        None => {\n+            err!(Unimplemented(\n+                \"miri does not support gathering system entropy in deterministic mode!\n+                Use '-Zmiri-seed=<seed>' to enable random number generation.\n+                WARNING: Miri does *not* generate cryptographically secure entropy -\n+                do not use Miri to run any program that needs secure random number generation\".to_owned(),\n+            ))\n+        }\n+    }\n }"}, {"sha": "d185ec610c9a5eb0df60c3201633460f762087db", "filename": "src/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -24,6 +24,9 @@ mod stacked_borrows;\n use std::collections::HashMap;\n use std::borrow::Cow;\n \n+use rand::rngs::StdRng;\n+use rand::SeedableRng;\n+\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{LayoutOf, Size, Align};\n use rustc::hir::{self, def_id::DefId};\n@@ -60,6 +63,9 @@ pub fn miri_default_args() -> &'static [&'static str] {\n pub struct MiriConfig {\n     pub validate: bool,\n     pub args: Vec<String>,\n+\n+    // The seed to use when non-determinism is required (e.g. getrandom())\n+    pub seed: Option<u64>\n }\n \n // Used by priroda.\n@@ -71,7 +77,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n+        Evaluator::new(config.validate, config.seed),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -326,10 +332,14 @@ pub struct Evaluator<'tcx> {\n \n     /// Stacked Borrows state.\n     pub(crate) stacked_borrows: stacked_borrows::State,\n+\n+    /// The random number generator to use if Miri\n+    /// is running in non-deterministic mode\n+    pub(crate) rng: Option<StdRng>\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    fn new(validate: bool) -> Self {\n+    fn new(validate: bool, seed: Option<u64>) -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n@@ -339,6 +349,7 @@ impl<'tcx> Evaluator<'tcx> {\n             tls: TlsData::default(),\n             validate,\n             stacked_borrows: stacked_borrows::State::default(),\n+            rng: seed.map(|s| StdRng::seed_from_u64(s))\n         }\n     }\n }"}, {"sha": "4dc3e863aaaec58c0b204d036822ad3dbdea94c9", "filename": "tests/compile-fail/getrandom.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/tests%2Fcompile-fail%2Fgetrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/tests%2Fcompile-fail%2Fgetrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fgetrandom.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -0,0 +1,13 @@\n+// ignore-macos\n+// ignore-windows\n+\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+fn main() {\n+    let mut buf = [0u8; 5];\n+    unsafe {\n+        libc::syscall(libc::SYS_getrandom, buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint);\n+        //~^ ERROR constant evaluation error: miri does not support gathering system entropy in deterministic mode!\n+    }\n+}"}, {"sha": "b29b681939794e19a029e46b80c1913c93862265", "filename": "tests/run-pass/hashmap.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2dc6e8b01f5b5462249617baf79e29da0be363d0/tests%2Frun-pass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc6e8b01f5b5462249617baf79e29da0be363d0/tests%2Frun-pass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhashmap.rs?ref=2dc6e8b01f5b5462249617baf79e29da0be363d0", "patch": "@@ -1,8 +1,9 @@\n+// compile-flags: -Zmiri-seed=0000000000000000\n+\n use std::collections::{self, HashMap};\n-use std::hash::BuildHasherDefault;\n+use std::hash::{BuildHasherDefault, BuildHasher};\n \n-fn main() {\n-    let mut map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+fn test_map<S: BuildHasher>(mut map: HashMap<i32, i32, S>) {\n     map.insert(0, 0);\n     assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n \n@@ -22,4 +23,16 @@ fn main() {\n     assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2);\n \n     // TODO: Test Entry API, Iterators, ...\n+\n+}\n+\n+fn main() {\n+    // TODO: Implement random number generation on OS X\n+    if cfg!(not(target_os = \"macos\")) {\n+        let map_normal: HashMap<i32, i32> = HashMap::new();\n+        test_map(map_normal);\n+    } else {\n+        let map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n+        test_map(map);\n+    }\n }"}]}