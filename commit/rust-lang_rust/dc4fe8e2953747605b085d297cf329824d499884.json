{"sha": "dc4fe8e2953747605b085d297cf329824d499884", "node_id": "C_kwDOAAsO6NoAKGRjNGZlOGUyOTUzNzQ3NjA1YjA4NWQyOTdjZjMyOTgyNGQ0OTk4ODQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-05T09:31:27Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-05T11:42:11Z"}, "message": "Make SROA expand assignments.", "tree": {"sha": "660913c44673c969b2a25bd3afe1bdcf35704d2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/660913c44673c969b2a25bd3afe1bdcf35704d2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4fe8e2953747605b085d297cf329824d499884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4fe8e2953747605b085d297cf329824d499884", "html_url": "https://github.com/rust-lang/rust/commit/dc4fe8e2953747605b085d297cf329824d499884", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4fe8e2953747605b085d297cf329824d499884/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0843acbea6441d5d4a07576ba206ccc01949662a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0843acbea6441d5d4a07576ba206ccc01949662a", "html_url": "https://github.com/rust-lang/rust/commit/0843acbea6441d5d4a07576ba206ccc01949662a"}], "stats": {"total": 220, "additions": 188, "deletions": 32}, "files": [{"sha": "f6609704d25d4b2c2caac1ff21a511147326341b", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -78,10 +78,15 @@ fn escaping_locals(body: &Body<'_>) -> BitSet<Local> {\n             rvalue: &Rvalue<'tcx>,\n             location: Location,\n         ) {\n-            if lvalue.as_local().is_some() && let Rvalue::Aggregate(..) = rvalue {\n-                // Aggregate assignments are expanded in run_pass.\n-                self.visit_rvalue(rvalue, location);\n-                return;\n+            if lvalue.as_local().is_some() {\n+                match rvalue {\n+                    // Aggregate assignments are expanded in run_pass.\n+                    Rvalue::Aggregate(..) | Rvalue::Use(..) => {\n+                        self.visit_rvalue(rvalue, location);\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n             }\n             self.super_assign(lvalue, rvalue, location)\n         }\n@@ -195,10 +200,9 @@ fn replace_flattened_locals<'tcx>(\n         return;\n     }\n \n-    let mut fragments = IndexVec::new();\n+    let mut fragments = IndexVec::<_, Option<Vec<_>>>::from_elem(None, &body.local_decls);\n     for (k, v) in &replacements.fields {\n-        fragments.ensure_contains_elem(k.local, || Vec::new());\n-        fragments[k.local].push((k.projection, *v));\n+        fragments[k.local].get_or_insert_default().push((k.projection, *v));\n     }\n     debug!(?fragments);\n \n@@ -235,17 +239,17 @@ struct ReplacementVisitor<'tcx, 'll> {\n     all_dead_locals: BitSet<Local>,\n     /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n     /// and deinit statement and debuginfo.\n-    fragments: IndexVec<Local, Vec<(&'tcx [PlaceElem<'tcx>], Local)>>,\n+    fragments: IndexVec<Local, Option<Vec<(&'tcx [PlaceElem<'tcx>], Local)>>>,\n     patch: MirPatch<'tcx>,\n }\n \n impl<'tcx, 'll> ReplacementVisitor<'tcx, 'll> {\n     fn gather_debug_info_fragments(\n         &self,\n         place: PlaceRef<'tcx>,\n-    ) -> Vec<VarDebugInfoFragment<'tcx>> {\n+    ) -> Option<Vec<VarDebugInfoFragment<'tcx>>> {\n         let mut fragments = Vec::new();\n-        let parts = &self.fragments[place.local];\n+        let Some(parts) = &self.fragments[place.local] else { return None };\n         for (proj, replacement_local) in parts {\n             if proj.starts_with(place.projection) {\n                 fragments.push(VarDebugInfoFragment {\n@@ -254,7 +258,7 @@ impl<'tcx, 'll> ReplacementVisitor<'tcx, 'll> {\n                 });\n             }\n         }\n-        fragments\n+        Some(fragments)\n     }\n \n     fn replace_place(&self, place: PlaceRef<'tcx>) -> Option<Place<'tcx>> {\n@@ -276,8 +280,7 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         match statement.kind {\n             StatementKind::StorageLive(l) => {\n-                if self.all_dead_locals.contains(l) {\n-                    let final_locals = &self.fragments[l];\n+                if let Some(final_locals) = &self.fragments[l] {\n                     for &(_, fl) in final_locals {\n                         self.patch.add_statement(location, StatementKind::StorageLive(fl));\n                     }\n@@ -286,8 +289,7 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                 return;\n             }\n             StatementKind::StorageDead(l) => {\n-                if self.all_dead_locals.contains(l) {\n-                    let final_locals = &self.fragments[l];\n+                if let Some(final_locals) = &self.fragments[l] {\n                     for &(_, fl) in final_locals {\n                         self.patch.add_statement(location, StatementKind::StorageDead(fl));\n                     }\n@@ -297,9 +299,8 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n             }\n             StatementKind::Deinit(box ref place) => {\n                 if let Some(local) = place.as_local()\n-                    && self.all_dead_locals.contains(local)\n+                    && let Some(final_locals) = &self.fragments[local]\n                 {\n-                    let final_locals = &self.fragments[local];\n                     for &(_, fl) in final_locals {\n                         self.patch.add_statement(\n                             location,\n@@ -313,9 +314,8 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n \n             StatementKind::Assign(box (ref place, Rvalue::Aggregate(_, ref operands))) => {\n                 if let Some(local) = place.as_local()\n-                    && self.all_dead_locals.contains(local)\n+                    && let Some(final_locals) = &self.fragments[local]\n                 {\n-                    let final_locals = &self.fragments[local];\n                     for &(projection, fl) in final_locals {\n                         let &[PlaceElem::Field(index, _)] = projection else { bug!() };\n                         let index = index.as_usize();\n@@ -330,6 +330,48 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                 }\n             }\n \n+            StatementKind::Assign(box (ref place, Rvalue::Use(Operand::Constant(_)))) => {\n+                if let Some(local) = place.as_local()\n+                    && let Some(final_locals) = &self.fragments[local]\n+                {\n+                    for &(projection, fl) in final_locals {\n+                        let rvalue = Rvalue::Use(Operand::Move(place.project_deeper(projection, self.tcx)));\n+                        self.patch.add_statement(\n+                            location,\n+                            StatementKind::Assign(Box::new((fl.into(), rvalue))),\n+                        );\n+                    }\n+                    self.all_dead_locals.remove(local);\n+                    return;\n+                }\n+            }\n+\n+            StatementKind::Assign(box (ref lhs, Rvalue::Use(ref op))) => {\n+                let (rplace, copy) = match op {\n+                    Operand::Copy(rplace) => (rplace, true),\n+                    Operand::Move(rplace) => (rplace, false),\n+                    Operand::Constant(_) => bug!(),\n+                };\n+                if let Some(local) = lhs.as_local()\n+                    && let Some(final_locals) = &self.fragments[local]\n+                {\n+                    for &(projection, fl) in final_locals {\n+                        let rplace = rplace.project_deeper(projection, self.tcx);\n+                        let rvalue = if copy {\n+                            Rvalue::Use(Operand::Copy(rplace))\n+                        } else {\n+                            Rvalue::Use(Operand::Move(rplace))\n+                        };\n+                        self.patch.add_statement(\n+                            location,\n+                            StatementKind::Assign(Box::new((fl.into(), rvalue))),\n+                        );\n+                    }\n+                    statement.make_nop();\n+                    return;\n+                }\n+            }\n+\n             _ => {}\n         }\n         self.super_statement(statement, location)\n@@ -348,9 +390,8 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n             VarDebugInfoContents::Place(ref mut place) => {\n                 if let Some(repl) = self.replace_place(place.as_ref()) {\n                     *place = repl;\n-                } else if self.all_dead_locals.contains(place.local) {\n+                } else if let Some(fragments) = self.gather_debug_info_fragments(place.as_ref()) {\n                     let ty = place.ty(self.local_decls, self.tcx).ty;\n-                    let fragments = self.gather_debug_info_fragments(place.as_ref());\n                     var_debug_info.value = VarDebugInfoContents::Composite { ty, fragments };\n                 }\n             }\n@@ -361,8 +402,9 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n                         if let Some(repl) = self.replace_place(fragment.contents.as_ref()) {\n                             fragment.contents = repl;\n                             true\n-                        } else if self.all_dead_locals.contains(fragment.contents.local) {\n-                            let frg = self.gather_debug_info_fragments(fragment.contents.as_ref());\n+                        } else if let Some(frg) =\n+                            self.gather_debug_info_fragments(fragment.contents.as_ref())\n+                        {\n                             new_fragments.extend(frg.into_iter().map(|mut f| {\n                                 f.projection.splice(0..0, fragment.projection.iter().copied());\n                                 f"}, {"sha": "72610de8eafa3742186055cd2b9577d3ea97ae3b", "filename": "tests/mir-opt/sroa.copies.ScalarReplacementOfAggregates.diff", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.copies.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.copies.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.copies.ScalarReplacementOfAggregates.diff?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -0,0 +1,48 @@\n+- // MIR for `copies` before ScalarReplacementOfAggregates\n++ // MIR for `copies` after ScalarReplacementOfAggregates\n+  \n+  fn copies(_1: Foo) -> () {\n+      debug x => _1;                       // in scope 0 at $DIR/sroa.rs:+0:11: +0:12\n+      let mut _0: ();                      // return place in scope 0 at $DIR/sroa.rs:+0:19: +0:19\n+      let _2: Foo;                         // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++     let _5: u8;                          // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++     let _6: &str;                        // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n+      scope 1 {\n+-         debug y => _2;                   // in scope 1 at $DIR/sroa.rs:+1:9: +1:10\n++         debug y => Foo{ .0 => _5, .2 => _6, }; // in scope 1 at $DIR/sroa.rs:+1:9: +1:10\n+          let _3: u8;                      // in scope 1 at $DIR/sroa.rs:+2:9: +2:10\n+          scope 2 {\n+              debug t => _3;               // in scope 2 at $DIR/sroa.rs:+2:9: +2:10\n+              let _4: &str;                // in scope 2 at $DIR/sroa.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug u => _4;           // in scope 3 at $DIR/sroa.rs:+3:9: +3:10\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_2);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n+-         _2 = _1;                         // scope 0 at $DIR/sroa.rs:+1:13: +1:14\n++         StorageLive(_5);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         StorageLive(_6);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         nop;                             // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         _5 = (_1.0: u8);                 // scope 0 at $DIR/sroa.rs:+1:13: +1:14\n++         _6 = (_1.2: &str);               // scope 0 at $DIR/sroa.rs:+1:13: +1:14\n++         nop;                             // scope 0 at $DIR/sroa.rs:+1:13: +1:14\n+          StorageLive(_3);                 // scope 1 at $DIR/sroa.rs:+2:9: +2:10\n+-         _3 = (_2.0: u8);                 // scope 1 at $DIR/sroa.rs:+2:13: +2:16\n++         _3 = _5;                         // scope 1 at $DIR/sroa.rs:+2:13: +2:16\n+          StorageLive(_4);                 // scope 2 at $DIR/sroa.rs:+3:9: +3:10\n+-         _4 = (_2.2: &str);               // scope 2 at $DIR/sroa.rs:+3:13: +3:16\n++         _4 = _6;                         // scope 2 at $DIR/sroa.rs:+3:13: +3:16\n+          _0 = const ();                   // scope 0 at $DIR/sroa.rs:+0:19: +4:2\n+          StorageDead(_4);                 // scope 2 at $DIR/sroa.rs:+4:1: +4:2\n+          StorageDead(_3);                 // scope 1 at $DIR/sroa.rs:+4:1: +4:2\n+-         StorageDead(_2);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         StorageDead(_5);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         StorageDead(_6);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         nop;                             // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/sroa.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "ea7f5007224519e16759e5054db50242eb790155", "filename": "tests/mir-opt/sroa.escaping.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.escaping.ScalarReplacementOfAggregates.diff?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -17,7 +17,7 @@\n           StorageLive(_5);                 // scope 0 at $DIR/sroa.rs:+2:34: +2:37\n           _5 = g() -> bb1;                 // scope 0 at $DIR/sroa.rs:+2:34: +2:37\n                                            // mir::Constant\n-                                           // + span: $DIR/sroa.rs:78:34: 78:35\n+                                           // + span: $DIR/sroa.rs:73:34: 73:35\n                                            // + literal: Const { ty: fn() -> u32 {g}, val: Value(<ZST>) }\n       }\n   \n@@ -28,7 +28,7 @@\n           _2 = &raw const (*_3);           // scope 0 at $DIR/sroa.rs:+2:7: +2:41\n           _1 = f(move _2) -> bb2;          // scope 0 at $DIR/sroa.rs:+2:5: +2:42\n                                            // mir::Constant\n-                                           // + span: $DIR/sroa.rs:78:5: 78:6\n+                                           // + span: $DIR/sroa.rs:73:5: 73:6\n                                            // + literal: Const { ty: fn(*const u32) {f}, val: Value(<ZST>) }\n       }\n   "}, {"sha": "69631fc0213f8f5d31ab407509bdc3beb14adf2d", "filename": "tests/mir-opt/sroa.flat.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.flat.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.flat.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.flat.ScalarReplacementOfAggregates.diff?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -45,7 +45,7 @@\n +         _9 = move _6;                    // scope 0 at $DIR/sroa.rs:+1:30: +1:70\n +         _10 = const \"a\";                 // scope 0 at $DIR/sroa.rs:+1:30: +1:70\n                                            // mir::Constant\n-                                           // + span: $DIR/sroa.rs:57:52: 57:55\n+                                           // + span: $DIR/sroa.rs:53:52: 53:55\n                                            // + literal: Const { ty: &str, val: Value(Slice(..)) }\n +         _11 = move _7;                   // scope 0 at $DIR/sroa.rs:+1:30: +1:70\n +         nop;                             // scope 0 at $DIR/sroa.rs:+1:30: +1:70"}, {"sha": "1a561a9edde300b0b87cae6a44ded5fa9795ce5a", "filename": "tests/mir-opt/sroa.ref_copies.ScalarReplacementOfAggregates.diff", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.ref_copies.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.ref_copies.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.ref_copies.ScalarReplacementOfAggregates.diff?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -0,0 +1,48 @@\n+- // MIR for `ref_copies` before ScalarReplacementOfAggregates\n++ // MIR for `ref_copies` after ScalarReplacementOfAggregates\n+  \n+  fn ref_copies(_1: &Foo) -> () {\n+      debug x => _1;                       // in scope 0 at $DIR/sroa.rs:+0:15: +0:16\n+      let mut _0: ();                      // return place in scope 0 at $DIR/sroa.rs:+0:24: +0:24\n+      let _2: Foo;                         // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++     let _5: u8;                          // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++     let _6: &str;                        // in scope 0 at $DIR/sroa.rs:+1:9: +1:10\n+      scope 1 {\n+-         debug y => _2;                   // in scope 1 at $DIR/sroa.rs:+1:9: +1:10\n++         debug y => Foo{ .0 => _5, .2 => _6, }; // in scope 1 at $DIR/sroa.rs:+1:9: +1:10\n+          let _3: u8;                      // in scope 1 at $DIR/sroa.rs:+2:9: +2:10\n+          scope 2 {\n+              debug t => _3;               // in scope 2 at $DIR/sroa.rs:+2:9: +2:10\n+              let _4: &str;                // in scope 2 at $DIR/sroa.rs:+3:9: +3:10\n+              scope 3 {\n+                  debug u => _4;           // in scope 3 at $DIR/sroa.rs:+3:9: +3:10\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_2);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n+-         _2 = (*_1);                      // scope 0 at $DIR/sroa.rs:+1:13: +1:15\n++         StorageLive(_5);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         StorageLive(_6);                 // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         nop;                             // scope 0 at $DIR/sroa.rs:+1:9: +1:10\n++         _5 = ((*_1).0: u8);              // scope 0 at $DIR/sroa.rs:+1:13: +1:15\n++         _6 = ((*_1).2: &str);            // scope 0 at $DIR/sroa.rs:+1:13: +1:15\n++         nop;                             // scope 0 at $DIR/sroa.rs:+1:13: +1:15\n+          StorageLive(_3);                 // scope 1 at $DIR/sroa.rs:+2:9: +2:10\n+-         _3 = (_2.0: u8);                 // scope 1 at $DIR/sroa.rs:+2:13: +2:16\n++         _3 = _5;                         // scope 1 at $DIR/sroa.rs:+2:13: +2:16\n+          StorageLive(_4);                 // scope 2 at $DIR/sroa.rs:+3:9: +3:10\n+-         _4 = (_2.2: &str);               // scope 2 at $DIR/sroa.rs:+3:13: +3:16\n++         _4 = _6;                         // scope 2 at $DIR/sroa.rs:+3:13: +3:16\n+          _0 = const ();                   // scope 0 at $DIR/sroa.rs:+0:24: +4:2\n+          StorageDead(_4);                 // scope 2 at $DIR/sroa.rs:+4:1: +4:2\n+          StorageDead(_3);                 // scope 1 at $DIR/sroa.rs:+4:1: +4:2\n+-         StorageDead(_2);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         StorageDead(_5);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         StorageDead(_6);                 // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n++         nop;                             // scope 0 at $DIR/sroa.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/sroa.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "b80f61600c2660012ca055db55e528c6d81ce843", "filename": "tests/mir-opt/sroa.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4fe8e2953747605b085d297cf329824d499884/tests%2Fmir-opt%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsroa.rs?ref=dc4fe8e2953747605b085d297cf329824d499884", "patch": "@@ -12,17 +12,14 @@ impl Drop for Tag {\n     fn drop(&mut self) {}\n }\n \n-// EMIT_MIR sroa.dropping.ScalarReplacementOfAggregates.diff\n pub fn dropping() {\n     S(Tag(0), Tag(1), Tag(2)).1;\n }\n \n-// EMIT_MIR sroa.enums.ScalarReplacementOfAggregates.diff\n pub fn enums(a: usize) -> usize {\n     if let Some(a) = Some(a) { a } else { 0 }\n }\n \n-// EMIT_MIR sroa.structs.ScalarReplacementOfAggregates.diff\n pub fn structs(a: f32) -> f32 {\n     struct U {\n         _foo: usize,\n@@ -32,7 +29,6 @@ pub fn structs(a: f32) -> f32 {\n     U { _foo: 0, a }.a\n }\n \n-// EMIT_MIR sroa.unions.ScalarReplacementOfAggregates.diff\n pub fn unions(a: f32) -> u32 {\n     union Repr {\n         f: f32,\n@@ -41,6 +37,7 @@ pub fn unions(a: f32) -> u32 {\n     unsafe { Repr { f: a }.u }\n }\n \n+#[derive(Copy, Clone)]\n struct Foo {\n     a: u8,\n     b: (),\n@@ -52,7 +49,6 @@ fn g() -> u32 {\n     3\n }\n \n-// EMIT_MIR sroa.flat.ScalarReplacementOfAggregates.diff\n pub fn flat() {\n     let Foo { a, b, c, d } = Foo { a: 5, b: (), c: \"a\", d: Some(-4) };\n     let _ = a;\n@@ -72,17 +68,39 @@ fn f(a: *const u32) {\n     println!(\"{}\", unsafe { *a.add(2) });\n }\n \n-// EMIT_MIR sroa.escaping.ScalarReplacementOfAggregates.diff\n pub fn escaping() {\n     // Verify this struct is not flattened.\n     f(&Escaping { a: 1, b: 2, c: g() }.a);\n }\n \n+fn copies(x: Foo) {\n+    let y = x;\n+    let t = y.a;\n+    let u = y.c;\n+}\n+\n+fn ref_copies(x: &Foo) {\n+    let y = *x;\n+    let t = y.a;\n+    let u = y.c;\n+}\n+\n fn main() {\n     dropping();\n     enums(5);\n     structs(5.);\n     unions(5.);\n     flat();\n     escaping();\n+    copies(Foo { a: 5, b: (), c: \"a\", d: Some(-4) });\n+    ref_copies(&Foo { a: 5, b: (), c: \"a\", d: Some(-4) });\n }\n+\n+// EMIT_MIR sroa.dropping.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.enums.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.structs.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.unions.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.flat.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.escaping.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.copies.ScalarReplacementOfAggregates.diff\n+// EMIT_MIR sroa.ref_copies.ScalarReplacementOfAggregates.diff"}]}