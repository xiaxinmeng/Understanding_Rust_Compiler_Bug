{"sha": "b51651ae9d0161967617be930415705b2e4d5faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MTY1MWFlOWQwMTYxOTY3NjE3YmU5MzA0MTU3MDViMmU0ZDVmYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-21T06:05:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-21T06:05:39Z"}, "message": "Auto merge of #75642 - matklad:lexer-comments, r=petrochenkov\n\nMove doc comment parsing to rustc_lexer\n\nPlain comments are trivia, while doc comments are not, so it feels\nlike this belongs to the rustc_lexer.\n\nThe specific reason to do this is the desire to use rustc_lexer in\nrustdoc for syntax highlighting, without duplicating \"is this a doc\ncomment?\" logic there.\n\nr? @ghost", "tree": {"sha": "59f07e80028fa6acc2f759d55f75f9025054bb41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f07e80028fa6acc2f759d55f75f9025054bb41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b51651ae9d0161967617be930415705b2e4d5faf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b51651ae9d0161967617be930415705b2e4d5faf", "html_url": "https://github.com/rust-lang/rust/commit/b51651ae9d0161967617be930415705b2e4d5faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b51651ae9d0161967617be930415705b2e4d5faf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff5e0f1dc8c5534406169903b3b9da029d3bada5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff5e0f1dc8c5534406169903b3b9da029d3bada5", "html_url": "https://github.com/rust-lang/rust/commit/ff5e0f1dc8c5534406169903b3b9da029d3bada5"}, {"sha": "ccbe94bf77e6a32fc9f31425bc820345be3143c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccbe94bf77e6a32fc9f31425bc820345be3143c0", "html_url": "https://github.com/rust-lang/rust/commit/ccbe94bf77e6a32fc9f31425bc820345be3143c0"}], "stats": {"total": 186, "additions": 89, "deletions": 97}, "files": [{"sha": "e97c8cc4562f63d17182c28c56dc1375c577d912", "filename": "src/librustc_ast/util/comments.rs", "status": "modified", "additions": 4, "deletions": 44, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_ast%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_ast%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fcomments.rs?ref=b51651ae9d0161967617be930415705b2e4d5faf", "patch": "@@ -1,4 +1,3 @@\n-use crate::ast::AttrStyle;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, CharPos, FileName, Pos, Symbol};\n \n@@ -24,45 +23,6 @@ pub struct Comment {\n     pub pos: BytePos,\n }\n \n-/// For a full line comment string returns its doc comment style if it's a doc comment\n-/// and returns `None` if it's a regular comment.\n-pub fn line_doc_comment_style(line_comment: &str) -> Option<AttrStyle> {\n-    let line_comment = line_comment.as_bytes();\n-    assert!(line_comment.starts_with(b\"//\"));\n-    match line_comment.get(2) {\n-        // `//!` is an inner line doc comment.\n-        Some(b'!') => Some(AttrStyle::Inner),\n-        Some(b'/') => match line_comment.get(3) {\n-            // `////` (more than 3 slashes) is not considered a doc comment.\n-            Some(b'/') => None,\n-            // Otherwise `///` is an outer line doc comment.\n-            _ => Some(AttrStyle::Outer),\n-        },\n-        _ => None,\n-    }\n-}\n-\n-/// For a full block comment string returns its doc comment style if it's a doc comment\n-/// and returns `None` if it's a regular comment.\n-pub fn block_doc_comment_style(block_comment: &str, terminated: bool) -> Option<AttrStyle> {\n-    let block_comment = block_comment.as_bytes();\n-    assert!(block_comment.starts_with(b\"/*\"));\n-    assert!(!terminated || block_comment.ends_with(b\"*/\"));\n-    match block_comment.get(2) {\n-        // `/*!` is an inner block doc comment.\n-        Some(b'!') => Some(AttrStyle::Inner),\n-        Some(b'*') => match block_comment.get(3) {\n-            // `/***` (more than 2 stars) is not considered a doc comment.\n-            Some(b'*') => None,\n-            // `/**/` is not considered a doc comment.\n-            Some(b'/') if block_comment.len() == 4 => None,\n-            // Otherwise `/**` is an outer block doc comment.\n-            _ => Some(AttrStyle::Outer),\n-        },\n-        _ => None,\n-    }\n-}\n-\n /// Makes a doc string more presentable to users.\n /// Used by rustdoc and perhaps other tools, but not by rustc.\n pub fn beautify_doc_string(data: Symbol) -> String {\n@@ -216,8 +176,8 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                     }\n                 }\n             }\n-            rustc_lexer::TokenKind::BlockComment { terminated } => {\n-                if block_doc_comment_style(token_text, terminated).is_none() {\n+            rustc_lexer::TokenKind::BlockComment { doc_style, .. } => {\n+                if doc_style.is_none() {\n                     let code_to_the_right = match text[pos + token.len..].chars().next() {\n                         Some('\\r' | '\\n') => false,\n                         _ => true,\n@@ -238,8 +198,8 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                     comments.push(Comment { style, lines, pos: pos_in_file })\n                 }\n             }\n-            rustc_lexer::TokenKind::LineComment => {\n-                if line_doc_comment_style(token_text).is_none() {\n+            rustc_lexer::TokenKind::LineComment { doc_style } => {\n+                if doc_style.is_none() {\n                     comments.push(Comment {\n                         style: if code_to_the_left {\n                             CommentStyle::Trailing"}, {"sha": "e19198f863ba830cc5ab9b1a9f83c7dd1feb2be4", "filename": "src/librustc_ast/util/comments/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs?ref=b51651ae9d0161967617be930415705b2e4d5faf", "patch": "@@ -1,13 +1,6 @@\n use super::*;\n use rustc_span::with_default_session_globals;\n \n-#[test]\n-fn line_doc_comments() {\n-    assert!(line_doc_comment_style(\"///\").is_some());\n-    assert!(line_doc_comment_style(\"/// blah\").is_some());\n-    assert!(line_doc_comment_style(\"////\").is_none());\n-}\n-\n #[test]\n fn test_block_doc_comment_1() {\n     with_default_session_globals(|| {"}, {"sha": "2d80ca5a4de10449f99fbe4772dd42dc0c6ef62b", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=b51651ae9d0161967617be930415705b2e4d5faf", "patch": "@@ -51,12 +51,12 @@ impl Token {\n pub enum TokenKind {\n     // Multi-char tokens:\n     /// \"// comment\"\n-    LineComment,\n+    LineComment { doc_style: Option<DocStyle> },\n     /// `/* block comment */`\n     ///\n     /// Block comments can be recursive, so the sequence like `/* /* */`\n     /// will not be considered terminated and will result in a parsing error.\n-    BlockComment { terminated: bool },\n+    BlockComment { doc_style: Option<DocStyle>, terminated: bool },\n     /// Any whitespace characters sequence.\n     Whitespace,\n     /// \"ident\" or \"continue\"\n@@ -129,6 +129,12 @@ pub enum TokenKind {\n     Unknown,\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DocStyle {\n+    Outer,\n+    Inner,\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n     /// \"12_u8\", \"0o100\", \"0b120i99\"\n@@ -188,7 +194,7 @@ pub fn strip_shebang(input: &str) -> Option<usize> {\n         // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n         // then it may be valid Rust code, so consider it Rust code.\n         let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok|\n-            !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment | TokenKind::BlockComment { .. })\n+            !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment { .. } | TokenKind::BlockComment { .. })\n         );\n         if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n             // No other choice than to consider this a shebang.\n@@ -410,13 +416,32 @@ impl Cursor<'_> {\n     fn line_comment(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '/' && self.first() == '/');\n         self.bump();\n+\n+        let doc_style = match self.first() {\n+            // `//!` is an inner line doc comment.\n+            '!' => Some(DocStyle::Inner),\n+            // `////` (more than 3 slashes) is not considered a doc comment.\n+            '/' if self.second() != '/' => Some(DocStyle::Outer),\n+            _ => None,\n+        };\n+\n         self.eat_while(|c| c != '\\n');\n-        LineComment\n+        LineComment { doc_style }\n     }\n \n     fn block_comment(&mut self) -> TokenKind {\n         debug_assert!(self.prev() == '/' && self.first() == '*');\n         self.bump();\n+\n+        let doc_style = match self.first() {\n+            // `/*!` is an inner block doc comment.\n+            '!' => Some(DocStyle::Inner),\n+            // `/***` (more than 2 stars) is not considered a doc comment.\n+            // `/**/` is not considered a doc comment.\n+            '*' if !matches!(self.second(), '*' | '/') => Some(DocStyle::Outer),\n+            _ => None,\n+        };\n+\n         let mut depth = 1usize;\n         while let Some(c) = self.bump() {\n             match c {\n@@ -438,7 +463,7 @@ impl Cursor<'_> {\n             }\n         }\n \n-        BlockComment { terminated: depth == 0 }\n+        BlockComment { doc_style, terminated: depth == 0 }\n     }\n \n     fn whitespace(&mut self) -> TokenKind {"}, {"sha": "7503f15ac55463dc641ebccbbab322f472c11d8d", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 55, "deletions": 41, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b51651ae9d0161967617be930415705b2e4d5faf/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=b51651ae9d0161967617be930415705b2e4d5faf", "patch": "@@ -1,5 +1,5 @@\n+use rustc_ast::ast::AttrStyle;\n use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n-use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n use rustc_lexer::Base;\n@@ -15,7 +15,7 @@ mod tokentrees;\n mod unescape_error_reporting;\n mod unicode_chars;\n \n-use rustc_lexer::unescape::Mode;\n+use rustc_lexer::{unescape::Mode, DocStyle};\n use unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n #[derive(Clone, Debug)]\n@@ -168,25 +168,23 @@ impl<'a> StringReader<'a> {\n     /// symbols and runs additional validation.\n     fn cook_lexer_token(&self, token: rustc_lexer::TokenKind, start: BytePos) -> TokenKind {\n         match token {\n-            rustc_lexer::TokenKind::LineComment => {\n-                let string = self.str_from(start);\n-                if let Some(attr_style) = comments::line_doc_comment_style(string) {\n-                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n-                    // Opening delimiter of the length 3 is not included into the symbol.\n-                    token::DocComment(CommentKind::Line, attr_style, Symbol::intern(&string[3..]))\n-                } else {\n-                    token::Comment\n+            rustc_lexer::TokenKind::LineComment { doc_style } => {\n+                match doc_style {\n+                    Some(doc_style) => {\n+                        // Opening delimiter of the length 3 is not included into the symbol.\n+                        let content_start = start + BytePos(3);\n+                        let content = self.str_from(content_start);\n+\n+                        self.cook_doc_comment(content_start, content, CommentKind::Line, doc_style)\n+                    }\n+                    None => token::Comment,\n                 }\n             }\n-            rustc_lexer::TokenKind::BlockComment { terminated } => {\n-                let string = self.str_from(start);\n-                let attr_style = comments::block_doc_comment_style(string, terminated);\n-\n+            rustc_lexer::TokenKind::BlockComment { doc_style, terminated } => {\n                 if !terminated {\n-                    let msg = if attr_style.is_some() {\n-                        \"unterminated block doc-comment\"\n-                    } else {\n-                        \"unterminated block comment\"\n+                    let msg = match doc_style {\n+                        Some(_) => \"unterminated block doc-comment\",\n+                        None => \"unterminated block comment\",\n                     };\n                     let last_bpos = self.pos;\n                     self.sess\n@@ -199,18 +197,17 @@ impl<'a> StringReader<'a> {\n                         .emit();\n                     FatalError.raise();\n                 }\n-\n-                if let Some(attr_style) = attr_style {\n-                    self.forbid_bare_cr(start, string, \"bare CR not allowed in block doc-comment\");\n-                    // Opening delimiter of the length 3 and closing delimiter of the length 2\n-                    // are not included into the symbol.\n-                    token::DocComment(\n-                        CommentKind::Block,\n-                        attr_style,\n-                        Symbol::intern(&string[3..string.len() - if terminated { 2 } else { 0 }]),\n-                    )\n-                } else {\n-                    token::Comment\n+                match doc_style {\n+                    Some(doc_style) => {\n+                        // Opening delimiter of the length 3 and closing delimiter of the length 2\n+                        // are not included into the symbol.\n+                        let content_start = start + BytePos(3);\n+                        let content_end = self.pos - BytePos(if terminated { 2 } else { 0 });\n+                        let content = self.str_from_to(content_start, content_end);\n+\n+                        self.cook_doc_comment(content_start, content, CommentKind::Block, doc_style)\n+                    }\n+                    None => token::Comment,\n                 }\n             }\n             rustc_lexer::TokenKind::Whitespace => token::Whitespace,\n@@ -319,6 +316,34 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    fn cook_doc_comment(\n+        &self,\n+        content_start: BytePos,\n+        content: &str,\n+        comment_kind: CommentKind,\n+        doc_style: DocStyle,\n+    ) -> TokenKind {\n+        if content.contains('\\r') {\n+            for (idx, _) in content.char_indices().filter(|&(_, c)| c == '\\r') {\n+                self.err_span_(\n+                    content_start + BytePos(idx as u32),\n+                    content_start + BytePos(idx as u32 + 1),\n+                    match comment_kind {\n+                        CommentKind::Line => \"bare CR not allowed in doc-comment\",\n+                        CommentKind::Block => \"bare CR not allowed in block doc-comment\",\n+                    },\n+                );\n+            }\n+        }\n+\n+        let attr_style = match doc_style {\n+            DocStyle::Outer => AttrStyle::Outer,\n+            DocStyle::Inner => AttrStyle::Inner,\n+        };\n+\n+        token::DocComment(comment_kind, attr_style, Symbol::intern(content))\n+    }\n+\n     fn cook_lexer_literal(\n         &self,\n         start: BytePos,\n@@ -472,17 +497,6 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n-        let mut idx = 0;\n-        loop {\n-            idx = match s[idx..].find('\\r') {\n-                None => break,\n-                Some(it) => idx + it + 1,\n-            };\n-            self.err_span_(start + BytePos(idx as u32 - 1), start + BytePos(idx as u32), errmsg);\n-        }\n-    }\n-\n     fn report_raw_str_error(&self, start: BytePos, opt_err: Option<RawStrError>) {\n         match opt_err {\n             Some(RawStrError::InvalidStarter { bad_char }) => {"}]}