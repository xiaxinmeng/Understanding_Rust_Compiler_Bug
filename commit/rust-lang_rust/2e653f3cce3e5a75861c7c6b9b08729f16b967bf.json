{"sha": "2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNjUzZjNjY2UzZTVhNzU4NjFjN2M2YjliMDg3MjlmMTZiOTY3YmY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T16:48:57Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-07T16:48:57Z"}, "message": "shard out concurrency", "tree": {"sha": "766d92d844164c4e577b3d548e2a1f492e5dff16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/766d92d844164c4e577b3d548e2a1f492e5dff16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "html_url": "https://github.com/rust-lang/rust/commit/2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50d8656945513c6b327122e5a40650c66baa87cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d8656945513c6b327122e5a40650c66baa87cb", "html_url": "https://github.com/rust-lang/rust/commit/50d8656945513c6b327122e5a40650c66baa87cb"}], "stats": {"total": 406, "additions": 197, "deletions": 209}, "files": [{"sha": "1456e3602e0b93c49ed7abc9a0f61395097ac3ed", "filename": "SUMMARY.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/SUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/SUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/SUMMARY.md?ref=2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "patch": "@@ -31,6 +31,9 @@\n \t* [Leaking](leaking.md)\n * [Unwinding](unwinding.md)\n * [Concurrency](concurrency.md)\n+\t* [Races](races.md)\n+\t* [Send and Sync](send-and-sync.md)\n+\t* [Atomics](atomics.md)\n * [Example: Implementing Vec](vec.md)\n \t* [Layout](vec-layout.md)\n \t* [Allocating](vec-alloc.md)"}, {"sha": "e13fb01c06b60a2befcb906760a15cb4d7957229", "filename": "atomics.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/atomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/atomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/atomics.md?ref=2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "patch": "@@ -0,0 +1,47 @@\n+% Atomics\n+\n+Rust pretty blatantly just inherits C11's memory model for atomics. This is not\n+due this model being particularly excellent or easy to understand. Indeed, this\n+model is quite complex and known to have [several flaws][C11-busted]. Rather,\n+it is a pragmatic concession to the fact that *everyone* is pretty bad at modeling\n+atomics. At very least, we can benefit from existing tooling and research around\n+C.\n+\n+Trying to fully explain the model is fairly hopeless. If you want all the\n+nitty-gritty details, you should check out [C's specification][C11-model].\n+Still, we'll try to cover the basics and some of the problems Rust developers\n+face.\n+\n+The C11 memory model is fundamentally about trying to bridge the gap between C's\n+single-threaded semantics, common compiler optimizations, and hardware peculiarities\n+in the face of a multi-threaded environment. It does this by splitting memory\n+accesses into two worlds: data accesses, and atomic accesses.\n+\n+Data accesses are the bread-and-butter of the programming world. They are\n+fundamentally unsynchronized and compilers are free to aggressively optimize\n+them. In particular data accesses are free to be reordered by the compiler\n+on the assumption that the program is single-threaded. The hardware is also free\n+to propagate the changes made in data accesses as lazily and inconsistently as\n+it wants to other threads. Mostly critically, data accesses are where we get data\n+races. These are pretty clearly awful semantics to try to write a multi-threaded\n+program with.\n+\n+Atomic accesses are the answer to this. Each atomic access can be marked with\n+an *ordering*. The set of orderings Rust exposes are:\n+\n+* Sequentially Consistent (SeqCst)\n+* Release\n+* Acquire\n+* Relaxed\n+\n+(Note: We explicitly do not expose the C11 *consume* ordering)\n+\n+TODO: give simple \"basic\" explanation of these\n+TODO: implementing Arc example (why does Drop need the trailing barrier?)\n+\n+\n+\n+\n+\n+[C11-busted]: http://plv.mpi-sws.org/c11comp/popl15.pdf\n+[C11-model]: http://en.cppreference.com/w/c/atomic/memory_order"}, {"sha": "e5276323267c4615fa60484152cd0c0d574fb347", "filename": "concurrency.md", "status": "modified", "additions": 5, "deletions": 209, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/concurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/concurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/concurrency.md?ref=2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "patch": "@@ -1,217 +1,13 @@\n % Concurrency and Paralellism\n \n-\n-\n-# Data Races and Race Conditions\n-\n-Safe Rust guarantees an absence of data races, which are defined as:\n-\n-* two or more threads concurrently accessing a location of memory\n-* one of them is a write\n-* one of them is unsynchronized\n-\n-A data race has Undefined Behaviour, and is therefore impossible to perform\n-in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n-it's impossible to alias a mutable reference, so it's impossible to perform a\n-data race. Interior mutability makes this more complicated, which is largely why\n-we have the Send and Sync traits (see below).\n-\n-However Rust *does not* prevent general race conditions. This is\n-pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n-is racy, your OS is racy, the other programs on your computer are racy, and the\n-world this all runs in is racy. Any system that could genuinely claim to prevent\n-*all* race conditions would be pretty awful to use, if not just incorrect.\n-\n-So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n-something incredibly stupid with incorrect synchronization. Obviously such a\n-program isn't very good, but Rust can only hold your hand so far. Still, a\n-race condition can't violate memory safety in a Rust program on\n-its own. Only in conjunction with some other unsafe code can a race condition\n-actually violate memory safety. For instance:\n-\n-```rust\n-use std::thread;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::sync::Arc;\n-\n-let data = vec![1, 2, 3, 4];\n-// Arc so that the memory the AtomicUsize is stored in still exists for\n-// the other thread to increment, even if we completely finish executing\n-// before it. Rust won't compile the program without it, because of the\n-// lifetime requirements of thread::spawn!\n-let idx = Arc::new(AtomicUsize::new(0));\n-let other_idx = idx.clone();\n-\n-// `move` captures other_idx by-value, moving it into this thread\n-thread::spawn(move || {\n-    // It's ok to mutate idx because this value\n-    // is an atomic, so it can't cause a Data Race.\n-    other_idx.fetch_add(10, Ordering::SeqCst);\n-});\n-\n-// Index with the value loaded from the atomic. This is safe because we\n-// read the atomic memory only once, and then pass a *copy* of that value\n-// to the Vec's indexing implementation. This indexing will be correctly\n-// bounds checked, and there's no chance of the value getting changed\n-// in the middle. However our program may panic if the thread we spawned\n-// managed to increment before this ran. A race condition because correct\n-// program execution (panicing is rarely correct) depends on order of\n-// thread execution.\n-println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n-\n-if idx.load(Ordering::SeqCst) < data.len() {\n-    unsafe {\n-        // Incorrectly loading the idx *after* we did the bounds check.\n-        // It could have changed. This is a race condition, *and dangerous*\n-        // because we decided to do `get_unchecked`, which is `unsafe`.\n-        println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));\n-    }\n-}\n-```\n-\n-\n-\n-\n-# Send and Sync\n-\n-Not everything obeys inherited mutability, though. Some types allow you to multiply\n-alias a location in memory while mutating it. Unless these types use synchronization\n-to manage this access, they are absolutely not thread safe. Rust captures this with\n-through the `Send` and `Sync` traits.\n-\n-* A type is Send if it is safe to send it to another thread.\n-* A type is Sync if it is safe to share between threads (`&T` is Send).\n-\n-Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n-substantial amount of special tooling exists to make them work right. First and\n-foremost, they're *unsafe traits*. This means that they are unsafe *to implement*,\n-and other unsafe code can *trust* that they are correctly implemented. Since\n-they're *marker traits* (they have no associated items like methods), correctly\n-implemented simply means that they have the intrinsic properties an implementor\n-should have. Incorrectly implementing Send or Sync can cause Undefined Behaviour.\n-\n-Send and Sync are also what Rust calls *opt-in builtin traits*.\n-This means that, unlike every other trait, they are *automatically* derived:\n-if a type is composed entirely of Send or Sync types, then it is Send or Sync.\n-Almost all primitives are Send and Sync, and as a consequence pretty much\n-all types you'll ever interact with are Send and Sync.\n-\n-Major exceptions include:\n-\n-* raw pointers are neither Send nor Sync (because they have no safety guards)\n-* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't)\n-* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized)\n-\n-`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n-unsynchronized shared mutable state. However raw pointers are, strictly speaking,\n-marked as thread-unsafe as more of a *lint*. Doing anything useful\n-with a raw pointer requires dereferencing it, which is already unsafe. In that\n-sense, one could argue that it would be \"fine\" for them to be marked as thread safe.\n-\n-However it's important that they aren't thread safe to prevent types that\n-*contain them* from being automatically marked as thread safe. These types have\n-non-trivial untracked ownership, and it's unlikely that their author was\n-necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n-example of a type that contains a `*mut` that is *definitely* not thread safe.\n-\n-Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n-implementing them:\n-\n-```rust\n-struct MyBox(*mut u8);\n-\n-unsafe impl Send for MyBox {}\n-unsafe impl Sync for MyBox {}\n-```\n-\n-In the *incredibly rare* case that a type is *inappropriately* automatically\n-derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n-\n-```rust\n-struct SpecialThreadToken(u8);\n-\n-impl !Send for SpecialThreadToken {}\n-impl !Sync for SpecialThreadToken {}\n-```\n-\n-Note that *in and of itself* it is impossible to incorrectly derive Send and Sync.\n-Only types that are ascribed special meaning by other unsafe code can possible cause\n-trouble by being incorrectly Send or Sync.\n-\n-Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n-that Send and Sync can be derived. For instance all of Rust's standard\n-collections are Send and Sync (when they contain Send and Sync types)\n-in spite of their pervasive use raw pointers to\n-manage allocations and complex ownership. Similarly, most iterators into these\n-collections are Send and Sync because they largely behave like an `&` or `&mut`\n-into the collection.\n-\n-TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n-only to data races?\n-\n-\n-\n-\n-# Atomics\n-\n-Rust pretty blatantly just inherits C11's memory model for atomics. This is not\n-due this model being particularly excellent or easy to understand. Indeed, this\n-model is quite complex and known to have [several flaws][C11-busted]. Rather,\n-it is a pragmatic concession to the fact that *everyone* is pretty bad at modeling\n-atomics. At very least, we can benefit from existing tooling and research around\n-C.\n-\n-Trying to fully explain the model is fairly hopeless. If you want all the\n-nitty-gritty details, you should check out [C's specification][C11-model].\n-Still, we'll try to cover the basics and some of the problems Rust developers\n-face.\n-\n-The C11 memory model is fundamentally about trying to bridge the gap between C's\n-single-threaded semantics, common compiler optimizations, and hardware peculiarities\n-in the face of a multi-threaded environment. It does this by splitting memory\n-accesses into two worlds: data accesses, and atomic accesses.\n-\n-Data accesses are the bread-and-butter of the programming world. They are\n-fundamentally unsynchronized and compilers are free to aggressively optimize\n-them. In particular data accesses are free to be reordered by the compiler\n-on the assumption that the program is single-threaded. The hardware is also free\n-to propagate the changes made in data accesses as lazily and inconsistently as\n-it wants to other threads. Mostly critically, data accesses are where we get data\n-races. These are pretty clearly awful semantics to try to write a multi-threaded\n-program with.\n-\n-Atomic accesses are the answer to this. Each atomic access can be marked with\n-an *ordering*. The set of orderings Rust exposes are:\n-\n-* Sequentially Consistent (SeqCst)\n-* Release\n-* Acquire\n-* Relaxed\n-\n-(Note: We explicitly do not expose the C11 *consume* ordering)\n-\n-TODO: give simple \"basic\" explanation of these\n-TODO: implementing Arc example (why does Drop need the trailing barrier?)\n-\n-\n-\n-\n-# Actually Doing Things Concurrently\n-\n Rust as a language doesn't *really* have an opinion on how to do concurrency or\n parallelism. The standard library exposes OS threads and blocking sys-calls\n-because *everyone* has those and they're uniform enough that you can provide\n+because *everyone* has those, and they're uniform enough that you can provide\n an abstraction over them in a relatively uncontroversial way. Message passing,\n green threads, and async APIs are all diverse enough that any abstraction over\n them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n \n-However Rust's current design is setup so that you can set up your own\n-concurrent paradigm or library as you see fit. Just require the right\n-lifetimes and Send and Sync where appropriate and everything should Just Work\n-with everyone else's stuff.\n-\n-\n-\n-\n-[C11-busted]: http://plv.mpi-sws.org/c11comp/popl15.pdf\n-[C11-model]: http://en.cppreference.com/w/c/atomic/memory_order\n+However the way Rust models concurrency makes it relatively easy design your own\n+concurrency paradigm as a library and have *everyone else's* code Just Work\n+with yours. Just require the right lifetimes and Send and Sync where appropriate\n+and you're off to the races. Or rather, not having races. Races are bad."}, {"sha": "240e4aca7f6b6a6df9fb7220d912905535709bfc", "filename": "races.md", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/races.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/races.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/races.md?ref=2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "patch": "@@ -0,0 +1,66 @@\n+% Data Races and Race Conditions\n+\n+Safe Rust guarantees an absence of data races, which are defined as:\n+\n+* two or more threads concurrently accessing a location of memory\n+* one of them is a write\n+* one of them is unsynchronized\n+\n+A data race has Undefined Behaviour, and is therefore impossible to perform\n+in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n+it's impossible to alias a mutable reference, so it's impossible to perform a\n+data race. Interior mutability makes this more complicated, which is largely why\n+we have the Send and Sync traits (see below).\n+\n+However Rust *does not* prevent general race conditions. This is\n+pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n+is racy, your OS is racy, the other programs on your computer are racy, and the\n+world this all runs in is racy. Any system that could genuinely claim to prevent\n+*all* race conditions would be pretty awful to use, if not just incorrect.\n+\n+So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n+something incredibly stupid with incorrect synchronization. Obviously such a\n+program isn't very good, but Rust can only hold your hand so far. Still, a\n+race condition can't violate memory safety in a Rust program on\n+its own. Only in conjunction with some other unsafe code can a race condition\n+actually violate memory safety. For instance:\n+\n+```rust\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::Arc;\n+\n+let data = vec![1, 2, 3, 4];\n+// Arc so that the memory the AtomicUsize is stored in still exists for\n+// the other thread to increment, even if we completely finish executing\n+// before it. Rust won't compile the program without it, because of the\n+// lifetime requirements of thread::spawn!\n+let idx = Arc::new(AtomicUsize::new(0));\n+let other_idx = idx.clone();\n+\n+// `move` captures other_idx by-value, moving it into this thread\n+thread::spawn(move || {\n+    // It's ok to mutate idx because this value\n+    // is an atomic, so it can't cause a Data Race.\n+    other_idx.fetch_add(10, Ordering::SeqCst);\n+});\n+\n+// Index with the value loaded from the atomic. This is safe because we\n+// read the atomic memory only once, and then pass a *copy* of that value\n+// to the Vec's indexing implementation. This indexing will be correctly\n+// bounds checked, and there's no chance of the value getting changed\n+// in the middle. However our program may panic if the thread we spawned\n+// managed to increment before this ran. A race condition because correct\n+// program execution (panicing is rarely correct) depends on order of\n+// thread execution.\n+println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n+\n+if idx.load(Ordering::SeqCst) < data.len() {\n+    unsafe {\n+        // Incorrectly loading the idx *after* we did the bounds check.\n+        // It could have changed. This is a race condition, *and dangerous*\n+        // because we decided to do `get_unchecked`, which is `unsafe`.\n+        println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));\n+    }\n+}\n+```"}, {"sha": "0ac14a85f847f24a1fba89b6faac7a121a7c8fb2", "filename": "send-and-sync.md", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/send-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e653f3cce3e5a75861c7c6b9b08729f16b967bf/send-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/send-and-sync.md?ref=2e653f3cce3e5a75861c7c6b9b08729f16b967bf", "patch": "@@ -0,0 +1,76 @@\n+% Send and Sync\n+\n+Not everything obeys inherited mutability, though. Some types allow you to multiply\n+alias a location in memory while mutating it. Unless these types use synchronization\n+to manage this access, they are absolutely not thread safe. Rust captures this with\n+through the `Send` and `Sync` traits.\n+\n+* A type is Send if it is safe to send it to another thread.\n+* A type is Sync if it is safe to share between threads (`&T` is Send).\n+\n+Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n+substantial amount of special tooling exists to make them work right. First and\n+foremost, they're *unsafe traits*. This means that they are unsafe *to implement*,\n+and other unsafe code can *trust* that they are correctly implemented. Since\n+they're *marker traits* (they have no associated items like methods), correctly\n+implemented simply means that they have the intrinsic properties an implementor\n+should have. Incorrectly implementing Send or Sync can cause Undefined Behaviour.\n+\n+Send and Sync are also what Rust calls *opt-in builtin traits*.\n+This means that, unlike every other trait, they are *automatically* derived:\n+if a type is composed entirely of Send or Sync types, then it is Send or Sync.\n+Almost all primitives are Send and Sync, and as a consequence pretty much\n+all types you'll ever interact with are Send and Sync.\n+\n+Major exceptions include:\n+\n+* raw pointers are neither Send nor Sync (because they have no safety guards)\n+* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't)\n+* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized)\n+\n+`Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\n+unsynchronized shared mutable state. However raw pointers are, strictly speaking,\n+marked as thread-unsafe as more of a *lint*. Doing anything useful\n+with a raw pointer requires dereferencing it, which is already unsafe. In that\n+sense, one could argue that it would be \"fine\" for them to be marked as thread safe.\n+\n+However it's important that they aren't thread safe to prevent types that\n+*contain them* from being automatically marked as thread safe. These types have\n+non-trivial untracked ownership, and it's unlikely that their author was\n+necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n+example of a type that contains a `*mut` that is *definitely* not thread safe.\n+\n+Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n+implementing them:\n+\n+```rust\n+struct MyBox(*mut u8);\n+\n+unsafe impl Send for MyBox {}\n+unsafe impl Sync for MyBox {}\n+```\n+\n+In the *incredibly rare* case that a type is *inappropriately* automatically\n+derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n+\n+```rust\n+struct SpecialThreadToken(u8);\n+\n+impl !Send for SpecialThreadToken {}\n+impl !Sync for SpecialThreadToken {}\n+```\n+\n+Note that *in and of itself* it is impossible to incorrectly derive Send and Sync.\n+Only types that are ascribed special meaning by other unsafe code can possible cause\n+trouble by being incorrectly Send or Sync.\n+\n+Most uses of raw pointers should be encapsulated behind a sufficient abstraction\n+that Send and Sync can be derived. For instance all of Rust's standard\n+collections are Send and Sync (when they contain Send and Sync types)\n+in spite of their pervasive use raw pointers to\n+manage allocations and complex ownership. Similarly, most iterators into these\n+collections are Send and Sync because they largely behave like an `&` or `&mut`\n+into the collection.\n+\n+TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n+only to data races?\n\\ No newline at end of file"}]}