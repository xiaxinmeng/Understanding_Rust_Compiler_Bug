{"sha": "ff59620734fec2f87463b193c67f482285235256", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNTk2MjA3MzRmZWMyZjg3NDYzYjE5M2M2N2Y0ODIyODUyMzUyNTY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:42:24Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:42:24Z"}, "message": "Rename `hair::PatternKind` to `hair::PatKind`", "tree": {"sha": "0bee70320fab73488c8770d4b7f4bc8644e12608", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bee70320fab73488c8770d4b7f4bc8644e12608"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff59620734fec2f87463b193c67f482285235256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff59620734fec2f87463b193c67f482285235256", "html_url": "https://github.com/rust-lang/rust/commit/ff59620734fec2f87463b193c67f482285235256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff59620734fec2f87463b193c67f482285235256/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae3c36800e422734a12f28d4e72617f0ad805c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae3c36800e422734a12f28d4e72617f0ad805c5", "html_url": "https://github.com/rust-lang/rust/commit/1ae3c36800e422734a12f28d4e72617f0ad805c5"}], "stats": {"total": 444, "additions": 222, "deletions": 222}, "files": [{"sha": "7353ca9285ddb10b3cfce5133f24d2f0f8ebf8a4", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     initializer,\n                     lint_level\n                 } => {\n-                    let ignores_expr_result = if let PatternKind::Wild = *pattern.kind {\n+                    let ignores_expr_result = if let PatKind::Wild = *pattern.kind {\n                         true\n                     } else {\n                         false"}, {"sha": "288c436ae8f62c921a8ee2065f9cd505bf24a4d8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n             // Optimize the case of `let x = ...` to write directly into `x`\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mode: BindingMode::ByValue,\n                 var,\n                 subpattern: None,\n@@ -336,9 +336,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // test works with uninitialized values in a rather\n             // dubious way, so it may be that the test is kind of\n             // broken.\n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 subpattern: Pattern {\n-                    kind: box PatternKind::Binding {\n+                    kind: box PatKind::Binding {\n                         mode: BindingMode::ByValue,\n                         var,\n                         subpattern: None,\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n         match *pattern.kind {\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mutability,\n                 name,\n                 mode,\n@@ -586,12 +586,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Array {\n+            PatKind::Array {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n             }\n-            | PatternKind::Slice {\n+            | PatKind::Slice {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n@@ -609,13 +609,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n+            PatKind::Constant { .. } | PatKind::Range { .. } | PatKind::Wild => {}\n \n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 self.visit_bindings(subpattern, pattern_user_ty.deref(), f);\n             }\n \n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: hair::pattern::Ascription {\n                     ref user_ty,\n@@ -644,22 +644,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.visit_bindings(subpattern, subpattern_user_ty, f)\n             }\n \n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Leaf { ref subpatterns } => {\n                 for subpattern in subpatterns {\n                     let subpattern_user_ty = pattern_user_ty.clone().leaf(subpattern.field);\n                     debug!(\"visit_bindings: subpattern_user_ty={:?}\", subpattern_user_ty);\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n \n-            PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n+            PatKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n                     let subpattern_user_ty = pattern_user_ty.clone().variant(\n                         adt_def, variant_index, subpattern.field);\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n-            PatternKind::Or { ref pats } => {\n+            PatKind::Or { ref pats } => {\n                 for pat in pats {\n                     self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n                 }"}, {"sha": "38e23d3076b1d56db582dbc2a004df351b8de180", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.hir.tcx();\n         match *match_pair.pattern.kind {\n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: hair::pattern::Ascription {\n                     variance,\n@@ -79,12 +79,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Wild => {\n+            PatKind::Wild => {\n                 // nothing left to do\n                 Ok(())\n             }\n \n-            PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n+            PatKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n                 candidate.bindings.push(Binding {\n                     name,\n                     mutability,\n@@ -103,12 +103,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Constant { .. } => {\n+            PatKind::Constant { .. } => {\n                 // FIXME normalize patterns when possible\n                 Err(match_pair)\n             }\n \n-            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+            PatKind::Range(PatternRange { lo, hi, end }) => {\n                 let (range, bias) = match lo.ty.kind {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 if prefix.is_empty() && slice.is_some() && suffix.is_empty() {\n                     // irrefutable\n                     self.prefix_slice_suffix(&mut candidate.match_pairs,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n+            PatKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.hir.tcx().features().exhaustive_patterns &&\n@@ -174,7 +174,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n                                          &match_pair.place,\n                                          prefix,\n@@ -183,20 +183,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Ok(())\n             }\n \n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.place, subpatterns));\n                 Ok(())\n             }\n \n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 let place = match_pair.place.deref();\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n \n-            PatternKind::Or { .. } => {\n+            PatKind::Or { .. } => {\n                 Err(match_pair)\n             }\n         }"}, {"sha": "835f5e088a69991513cae1024f509202a111319d", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// It is a bug to call this with a simplifiable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n+            PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n@@ -36,7 +36,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { .. } if is_switch_ty(match_pair.pattern.ty) => {\n+            PatKind::Constant { .. } if is_switch_ty(match_pair.pattern.ty) => {\n                 // For integers, we use a `SwitchInt` match, which allows\n                 // us to handle more cases.\n                 Test {\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Eq {\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Range(range) => {\n+            PatKind::Range(range) => {\n                 assert_eq!(range.lo.ty, match_pair.pattern.ty);\n                 assert_eq!(range.hi.ty, match_pair.pattern.ty);\n                 Test {\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n                 let op = if slice.is_some() {\n                     BinOp::Ge\n@@ -84,13 +84,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatternKind::AscribeUserType { .. } |\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Or { .. } |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n+            PatKind::AscribeUserType { .. } |\n+            PatKind::Array { .. } |\n+            PatKind::Wild |\n+            PatKind::Or { .. } |\n+            PatKind::Binding { .. } |\n+            PatKind::Leaf { .. } |\n+            PatKind::Deref { .. } => {\n                 self.error_simplifyable(match_pair)\n             }\n         }\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 indices.entry(value)\n                        .or_insert_with(|| {\n                            options.push(value.eval_bits(\n@@ -120,22 +120,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                        });\n                 true\n             }\n-            PatternKind::Variant { .. } => {\n+            PatKind::Variant { .. } => {\n                 panic!(\"you should have called add_variants_to_switch instead!\");\n             }\n-            PatternKind::Range(range) => {\n+            PatKind::Range(range) => {\n                 // Check that none of the switch values are in the range.\n                 self.values_not_contained_in_range(range, indices)\n                     .unwrap_or(false)\n             }\n-            PatternKind::Slice { .. } |\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Or { .. } |\n-            PatternKind::Binding { .. } |\n-            PatternKind::AscribeUserType { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n+            PatKind::Slice { .. } |\n+            PatKind::Array { .. } |\n+            PatKind::Wild |\n+            PatKind::Or { .. } |\n+            PatKind::Binding { .. } |\n+            PatKind::AscribeUserType { .. } |\n+            PatKind::Leaf { .. } |\n+            PatKind::Deref { .. } => {\n                 // don't know how to add these patterns to a switch\n                 false\n             }\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         };\n \n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { adt_def: _ , variant_index,  .. } => {\n+            PatKind::Variant { adt_def: _ , variant_index,  .. } => {\n                 // We have a pattern testing for variant `variant_index`\n                 // set the corresponding index to true\n                 variants.insert(variant_index);\n@@ -533,7 +533,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n-             &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n+             &PatKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n                 self.candidate_after_variant_switch(match_pair_index,\n                                                     adt_def,\n@@ -548,18 +548,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n             //\n-            // FIXME(#29623) we could use PatternKind::Range to rule\n+            // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n             (&TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n-             &PatternKind::Constant { ref value })\n+             &PatKind::Constant { ref value })\n             if is_switch_ty(match_pair.pattern.ty) => {\n                 let index = indices[value];\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n             (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n-             &PatternKind::Range(range)) => {\n+             &PatKind::Range(range)) => {\n                 let not_contained = self\n                     .values_not_contained_in_range(range, indices)\n                     .unwrap_or(false);\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             (&TestKind::SwitchInt { .. }, _) => None,\n \n             (&TestKind::Len { len: test_len, op: BinOp::Eq },\n-             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+             &PatKind::Slice { ref prefix, ref slice, ref suffix }) => {\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n                     (Ordering::Equal, &None) => {\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             (&TestKind::Len { len: test_len, op: BinOp::Ge },\n-             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+             &PatKind::Slice { ref prefix, ref slice, ref suffix }) => {\n                 // the test is `$actual_len >= test_len`\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n@@ -644,7 +644,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             (&TestKind::Range(test),\n-             &PatternKind::Range(pat)) => {\n+             &PatKind::Range(pat)) => {\n                 if test == pat {\n                     self.candidate_without_match_pair(\n                         match_pair_index,\n@@ -683,7 +683,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(range), &PatternKind::Constant { value }) => {\n+            (&TestKind::Range(range), &PatKind::Constant { value }) => {\n                 if self.const_range_contains(range, value) == Some(false) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails."}, {"sha": "f1e045302eced66b802b9ce3d89f70ce17580be4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n-use crate::hair::{LintLevel, BindingMode, PatternKind};\n+use crate::hair::{LintLevel, BindingMode, PatKind};\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);\n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n-                    PatternKind::Binding {\n+                    PatKind::Binding {\n                         mutability,\n                         var,\n                         mode: BindingMode::ByValue,"}, {"sha": "33b7bd597695a550e144f49fd7fa76628a941d77", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -81,7 +81,7 @@ fn mirror_stmts<'a, 'tcx>(\n                         pattern = Pattern {\n                             ty: pattern.ty,\n                             span: pattern.span,\n-                            kind: Box::new(PatternKind::AscribeUserType {\n+                            kind: Box::new(PatKind::AscribeUserType {\n                                 ascription: hair::pattern::Ascription {\n                                     user_ty: PatternTypeProjection::from_user_type(user_ty),\n                                     user_ty_span: ty.span,"}, {"sha": "8a76ad8ee7ac74caf7bf40019247941b500e8690", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -20,7 +20,7 @@ pub mod cx;\n mod constant;\n \n pub mod pattern;\n-pub use self::pattern::{BindingMode, Pattern, PatternKind, PatternRange, FieldPat};\n+pub use self::pattern::{BindingMode, Pattern, PatKind, PatternRange, FieldPat};\n pub(crate) use self::pattern::PatternTypeProjection;\n \n mod util;\n@@ -306,7 +306,7 @@ impl Arm<'tcx> {\n     // correctly handle each case in which this method is used.\n     pub fn top_pats_hack(&self) -> &[Pattern<'tcx>] {\n         match &*self.pattern.kind {\n-            PatternKind::Or { pats } => pats,\n+            PatKind::Or { pats } => pats,\n             _ => std::slice::from_ref(&self.pattern),\n         }\n     }"}, {"sha": "77a3b7ab0310b6321386918a6682a78587a8ccf4", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -163,7 +163,7 @@ use self::WitnessPreference::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{FieldPat, Pattern, PatternKind, PatternRange};\n+use super::{FieldPat, Pattern, PatKind, PatternRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n@@ -248,27 +248,27 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n         match (&pat.ty.kind, &*pat.kind) {\n             (\n                 &ty::Ref(_, rty, _),\n-                &PatternKind::Constant { value: Const {\n+                &PatKind::Constant { value: Const {\n                     val,\n                     ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n                 } },\n             ) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n-                    kind: box PatternKind::Deref {\n+                    kind: box PatKind::Deref {\n                         subpattern: Pattern {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: self.tcx.mk_const(Const {\n+                            kind: box PatKind::Constant { value: self.tcx.mk_const(Const {\n                                 val: self.fold_const_value_deref(*val, rty, crty),\n                                 ty: rty,\n                             }) },\n                         }\n                     }\n                 }\n             }\n-            (_, &PatternKind::Binding { subpattern: Some(ref s), .. }) => {\n+            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => {\n                 s.fold_with(self)\n             }\n             _ => pat.super_fold_with(self)\n@@ -279,7 +279,7 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n impl<'tcx> Pattern<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n-            PatternKind::Binding { subpattern: None, .. } | PatternKind::Wild =>\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild =>\n                 true,\n             _ => false\n         }\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool {\n         match *pattern.kind {\n-            PatternKind::Variant { adt_def, variant_index, .. } => {\n+            PatKind::Variant { adt_def, variant_index, .. } => {\n                 let ref variant = adt_def.variants[variant_index];\n                 variant.is_field_list_non_exhaustive()\n             }\n@@ -534,7 +534,7 @@ impl<'tcx> Witness<'tcx> {\n             Pattern {\n                 ty,\n                 span: DUMMY_SP,\n-                kind: box PatternKind::Wild,\n+                kind: box PatKind::Wild,\n             }\n         }));\n         self.apply_constructor(cx, ctor, ty)\n@@ -577,26 +577,26 @@ impl<'tcx> Witness<'tcx> {\n \n                     if let ty::Adt(adt, substs) = ty.kind {\n                         if adt.is_enum() {\n-                            PatternKind::Variant {\n+                            PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n                                 variant_index: ctor.variant_index_for_adt(cx, adt),\n                                 subpatterns: pats\n                             }\n                         } else {\n-                            PatternKind::Leaf { subpatterns: pats }\n+                            PatKind::Leaf { subpatterns: pats }\n                         }\n                     } else {\n-                        PatternKind::Leaf { subpatterns: pats }\n+                        PatKind::Leaf { subpatterns: pats }\n                     }\n                 }\n \n                 ty::Ref(..) => {\n-                    PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n+                    PatKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n                 ty::Slice(_) | ty::Array(..) => {\n-                    PatternKind::Slice {\n+                    PatKind::Slice {\n                         prefix: pats.collect(),\n                         slice: None,\n                         suffix: vec![]\n@@ -605,13 +605,13 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(value) => PatternKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatternKind::Range(PatternRange {\n+                        ConstantValue(value) => PatKind::Constant { value },\n+                        ConstantRange(lo, hi, ty, end) => PatKind::Range(PatternRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             end,\n                         }),\n-                        _ => PatternKind::Wild,\n+                        _ => PatKind::Wild,\n                     }\n                 }\n             }\n@@ -783,7 +783,7 @@ where\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 // extract the length of an array/slice from a constant\n                 match (value.val, &value.ty.kind) {\n                     (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n@@ -797,11 +797,11 @@ where\n                     _ => {},\n                 }\n             }\n-            PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n+            PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n                 let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n             }\n-            PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+            PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n                 max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n                 max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n             }\n@@ -878,14 +878,14 @@ impl<'tcx> IntRange<'tcx> {\n     ) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n-                box PatternKind::Constant { value } => break ConstantValue(value),\n-                box PatternKind::Range(PatternRange { lo, hi, end }) => break ConstantRange(\n+                box PatKind::Constant { value } => break ConstantValue(value),\n+                box PatKind::Range(PatternRange { lo, hi, end }) => break ConstantRange(\n                     lo.eval_bits(tcx, param_env, lo.ty),\n                     hi.eval_bits(tcx, param_env, hi.ty),\n                     lo.ty,\n                     end,\n                 ),\n-                box PatternKind::AscribeUserType { ref subpattern, .. } => {\n+                box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n                 },\n                 _ => return None,\n@@ -1058,7 +1058,7 @@ fn compute_missing_ctors<'tcx>(\n /// inputs that will match `v` but not any of the sets in `m`.\n ///\n /// All the patterns at each column of the `matrix ++ v` matrix must\n-/// have the same type, except that wildcard (PatternKind::Wild) patterns\n+/// have the same type, except that wildcard (PatKind::Wild) patterns\n /// with type `TyErr` are also allowed, even if the \"type of the column\"\n /// is not `TyErr`. That is used to represent private fields, as using their\n /// real type would assert that they are inhabited.\n@@ -1250,7 +1250,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                             witness.0.push(Pattern {\n                                 ty: pcx.ty,\n                                 span: DUMMY_SP,\n-                                kind: box PatternKind::Wild,\n+                                kind: box PatKind::Wild,\n                             });\n                             witness\n                         }).collect()\n@@ -1296,7 +1296,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n         Pattern {\n             ty,\n             span: DUMMY_SP,\n-            kind: box PatternKind::Wild,\n+            kind: box PatKind::Wild,\n         }\n     }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n@@ -1330,36 +1330,36 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n-        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+        PatKind::AscribeUserType { ref subpattern, .. } =>\n             pat_constructors(cx, subpattern, pcx),\n-        PatternKind::Binding { .. } | PatternKind::Wild => None,\n-        PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n-        PatternKind::Variant { adt_def, variant_index, .. } => {\n+        PatKind::Binding { .. } | PatKind::Wild => None,\n+        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n+        PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n-        PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range(PatternRange { lo, hi, end }) =>\n+        PatKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatKind::Range(PatternRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n                 lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n                 hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 lo.ty,\n                 end,\n             )]),\n-        PatternKind::Array { .. } => match pcx.ty.kind {\n+        PatKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n                 Slice(length.eval_usize(cx.tcx, cx.param_env))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n-        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n                 Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n             } else {\n                 Some(vec![Slice(pat_len)])\n             }\n         }\n-        PatternKind::Or { .. } => {\n+        PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     }\n@@ -1481,7 +1481,7 @@ fn slice_pat_covered_by_const<'tcx>(\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { value } => {\n+            box PatKind::Constant { value } => {\n                 let b = value.eval_bits(tcx, param_env, pat.ty);\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n@@ -1657,8 +1657,8 @@ fn constructor_covered_by_range<'tcx>(\n     pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n-        box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range(PatternRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+        box PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+        box PatKind::Range(PatternRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n@@ -1745,30 +1745,30 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n     let pat = &r[0];\n \n     let head = match *pat.kind {\n-        PatternKind::AscribeUserType { ref subpattern, .. } => {\n+        PatKind::AscribeUserType { ref subpattern, .. } => {\n             specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns)\n         }\n \n-        PatternKind::Binding { .. } | PatternKind::Wild => {\n+        PatKind::Binding { .. } | PatKind::Wild => {\n             Some(SmallVec::from_slice(wild_patterns))\n         }\n \n-        PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n+        PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n                 .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n-        PatternKind::Leaf { ref subpatterns } => {\n+        PatKind::Leaf { ref subpatterns } => {\n             Some(patterns_for_variant(subpatterns, wild_patterns))\n         }\n \n-        PatternKind::Deref { ref subpattern } => {\n+        PatKind::Deref { ref subpattern } => {\n             Some(smallvec![subpattern])\n         }\n \n-        PatternKind::Constant { value } => {\n+        PatKind::Constant { value } => {\n             match *constructor {\n                 Slice(..) => {\n                     // we extract an `Option` for the pointer because slices of zero elements don't\n@@ -1830,7 +1830,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                             let pattern = Pattern {\n                                 ty,\n                                 span: pat.span,\n-                                kind: box PatternKind::Constant { value },\n+                                kind: box PatKind::Constant { value },\n                             };\n                             Some(&*cx.pattern_arena.alloc(pattern))\n                         }).collect()\n@@ -1847,15 +1847,15 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             }\n         }\n \n-        PatternKind::Range { .. } => {\n+        PatKind::Range { .. } => {\n             // If the constructor is a:\n             //      Single value: add a row if the pattern contains the constructor.\n             //      Range: add a row if the constructor intersects the pattern.\n             constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n         }\n \n-        PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-        PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+        PatKind::Array { ref prefix, ref slice, ref suffix } |\n+        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             match *constructor {\n                 Slice(..) => {\n                     let pat_len = prefix.len() + suffix.len();\n@@ -1888,7 +1888,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             }\n         }\n \n-        PatternKind::Or { .. } => {\n+        PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     };"}, {"sha": "c4b7661dd23dab56b19e29148e40ad172fa5ad30", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -2,7 +2,7 @@ use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n \n-use super::{Pattern, PatternContext, PatternError, PatternKind};\n+use super::{Pattern, PatternContext, PatternError, PatKind};\n \n use rustc::middle::borrowck::SignalledError;\n use rustc::session::Session;\n@@ -14,7 +14,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Pat, PatKind};\n+use rustc::hir::{self, Pat};\n \n use smallvec::smallvec;\n use std::slice;\n@@ -271,7 +271,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 origin, joined_patterns\n             );\n             err.span_label(pat.span, match &pat.kind {\n-                PatKind::Path(hir::QPath::Resolved(None, path))\n+                hir::PatKind::Path(hir::QPath::Resolved(None, path))\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n                             path.res.article(), path.res.descr())\n@@ -286,7 +286,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(_, _, ident, None) = p.kind {\n+        if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if bm != ty::BindByValue(hir::MutImmutable) {\n                     // Nothing to check.\n@@ -322,10 +322,10 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(pat: &Pat) -> bool {\n     match pat.kind {\n-        PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n+        hir::PatKind::Binding(.., None) => true,\n+        hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n+        hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n+        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n             pat_is_catchall(&p)\n         }),\n         _ => false\n@@ -421,7 +421,7 @@ fn check_not_useful(\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n ) -> Result<(), Vec<Pattern<'tcx>>> {\n-    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatternKind::Wild };\n+    let wild_pattern = Pattern { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n     match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n@@ -506,7 +506,7 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {\n-            use PatternKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            use PatKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n             match &*pattern.kind {\n                 AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n                     covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n@@ -568,7 +568,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     };\n \n     pat.walk(|p| {\n-        if let PatKind::Binding(.., sub) = &p.kind {\n+        if let hir::PatKind::Binding(.., sub) = &p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if let ty::BindByValue(..) = bm {\n                     let pat_ty = cx.tables.node_type(p.hir_id);\n@@ -619,7 +619,7 @@ impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n \n     fn visit_pat(&mut self, pat: &Pat) {\n         match pat.kind {\n-            PatKind::Binding(.., ref subpat) => {\n+            hir::PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n                     struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                      \"pattern bindings are not allowed after an `@`\")"}, {"sha": "cffcb5b796e31e4ff3a43125243a5a2281e487ed", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff59620734fec2f87463b193c67f482285235256/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ff59620734fec2f87463b193c67f482285235256", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, GenericArg};\n use rustc::ty::layout::{VariantIdx, Size};\n-use rustc::hir::{self, PatKind, RangeEnd};\n+use rustc::hir::{self, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n@@ -57,7 +57,7 @@ pub struct FieldPat<'tcx> {\n pub struct Pattern<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: Box<PatternKind<'tcx>>,\n+    pub kind: Box<PatKind<'tcx>>,\n }\n \n \n@@ -116,7 +116,7 @@ pub struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternKind<'tcx> {\n+pub enum PatKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n@@ -205,10 +205,10 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n         let mut start_or_comma = || start_or_continue(\", \");\n \n         match *self.kind {\n-            PatternKind::Wild => write!(f, \"_\"),\n-            PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            PatKind::Wild => write!(f, \"_\"),\n+            PatKind::AscribeUserType { ref subpattern, .. } =>\n                 write!(f, \"{}: _\", subpattern),\n-            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n                 let is_mut = match mode {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n                     BindingMode::ByRef(bk) => {\n@@ -225,10 +225,10 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 Ok(())\n             }\n-            PatternKind::Variant { ref subpatterns, .. } |\n-            PatternKind::Leaf { ref subpatterns } => {\n+            PatKind::Variant { ref subpatterns, .. } |\n+            PatKind::Leaf { ref subpatterns } => {\n                 let variant = match *self.kind {\n-                    PatternKind::Variant { adt_def, variant_index, .. } => {\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n                         Some(&adt_def.variants[variant_index])\n                     }\n                     _ => if let ty::Adt(adt, _) = self.ty.kind {\n@@ -252,7 +252,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n                         let mut printed = 0;\n                         for p in subpatterns {\n-                            if let PatternKind::Wild = *p.pattern.kind {\n+                            if let PatKind::Wild = *p.pattern.kind {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].ident;\n@@ -294,7 +294,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n                 Ok(())\n             }\n-            PatternKind::Deref { ref subpattern } => {\n+            PatKind::Deref { ref subpattern } => {\n                 match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n@@ -307,27 +307,27 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"{}\", subpattern)\n             }\n-            PatternKind::Constant { value } => {\n+            PatKind::Constant { value } => {\n                 write!(f, \"{}\", value)\n             }\n-            PatternKind::Range(PatternRange { lo, hi, end }) => {\n+            PatKind::Range(PatternRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n                 write!(f, \"{}\", hi)\n             }\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+            PatKind::Slice { ref prefix, ref slice, ref suffix } |\n+            PatKind::Array { ref prefix, ref slice, ref suffix } => {\n                 write!(f, \"[\")?;\n                 for p in prefix {\n                     write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n                     write!(f, \"{}\", start_or_comma())?;\n                     match *slice.kind {\n-                        PatternKind::Wild => {}\n+                        PatKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?\n                     }\n                     write!(f, \"..\")?;\n@@ -337,7 +337,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 }\n                 write!(f, \"]\")\n             }\n-            PatternKind::Or { ref pats } => {\n+            PatKind::Or { ref pats } => {\n                 for pat in pats {\n                     write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n                 }\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         // `vec![&&Option<i32>, &Option<i32>]`.\n         //\n         // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n-        // we wrap the unadjusted pattern in `PatternKind::Deref` repeatedly, consuming the\n+        // we wrap the unadjusted pattern in `PatKind::Deref` repeatedly, consuming the\n         // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n         // gets the least-dereferenced type).\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     Pattern {\n                         span: pat.span,\n                         ty: ref_ty,\n-                        kind: Box::new(PatternKind::Deref { subpattern: pat }),\n+                        kind: Box::new(PatKind::Deref { subpattern: pat }),\n                     }\n                 },\n             )\n@@ -436,9 +436,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_range_expr(\n         &mut self,\n         expr: &'tcx hir::Expr,\n-    ) -> (PatternKind<'tcx>, Option<Ascription<'tcx>>) {\n+    ) -> (PatKind<'tcx>, Option<Ascription<'tcx>>) {\n         match self.lower_lit(expr) {\n-            PatternKind::AscribeUserType {\n+            PatKind::AscribeUserType {\n                 ascription: lo_ascription,\n                 subpattern: Pattern { kind: box kind, .. },\n             } => (kind, Some(lo_ascription)),\n@@ -450,16 +450,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n         let kind = match pat.kind {\n-            PatKind::Wild => PatternKind::Wild,\n+            hir::PatKind::Wild => PatKind::Wild,\n \n-            PatKind::Lit(ref value) => self.lower_lit(value),\n+            hir::PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n+            hir::PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n                 let (lo, lo_ascription) = self.lower_range_expr(lo_expr);\n                 let (hi, hi_ascription) = self.lower_range_expr(hi_expr);\n \n                 let mut kind = match (lo, hi) {\n-                    (PatternKind::Constant { value: lo }, PatternKind::Constant { value: hi }) => {\n+                    (PatKind::Constant { value: lo }, PatKind::Constant { value: hi }) => {\n                         assert_eq!(lo.ty, ty);\n                         assert_eq!(hi.ty, ty);\n                         let cmp = compare_const_vals(\n@@ -471,21 +471,21 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range(PatternRange { lo, hi, end }),\n+                                PatKind::Range(PatternRange { lo, hi, end }),\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n                                     lo_expr.span,\n                                     E0579,\n                                     \"lower range bound must be less than upper\",\n                                 );\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                             (RangeEnd::Included, Some(Ordering::Equal)) => {\n-                                PatternKind::Constant { value: lo }\n+                                PatKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range(PatternRange { lo, hi, end })\n+                                PatKind::Range(PatternRange { lo, hi, end })\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                               to be less than or equal to the end of the range.\");\n                                 }\n                                 err.emit();\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                         }\n                     },\n@@ -519,7 +519,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             ),\n                         );\n \n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n                 };\n \n@@ -528,7 +528,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 // constants somewhere. Have them on the range pattern.\n                 for ascription in &[lo_ascription, hi_ascription] {\n                     if let Some(ascription) = ascription {\n-                        kind = PatternKind::AscribeUserType {\n+                        kind = PatKind::AscribeUserType {\n                             ascription: *ascription,\n                             subpattern: Pattern { span: pat.span, ty, kind: Box::new(kind), },\n                         };\n@@ -538,19 +538,19 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 kind\n             }\n \n-            PatKind::Path(ref qpath) => {\n+            hir::PatKind::Path(ref qpath) => {\n                 return self.lower_path(qpath, pat.hir_id, pat.span);\n             }\n \n-            PatKind::Ref(ref subpattern, _) |\n-            PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n+            hir::PatKind::Ref(ref subpattern, _) |\n+            hir::PatKind::Box(ref subpattern) => {\n+                PatKind::Deref { subpattern: self.lower_pattern(subpattern) }\n             }\n \n-            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n+            hir::PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n                 match ty.kind {\n                     ty::Ref(_, ty, _) =>\n-                        PatternKind::Deref {\n+                        PatKind::Deref {\n                             subpattern: Pattern {\n                                 ty,\n                                 span: pat.span,\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     ty::Array(..) =>\n                         self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n                     ty::Error => { // Avoid ICE\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ =>\n                         span_bug!(\n@@ -572,7 +572,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Tuple(ref subpatterns, ddpos) => {\n+            hir::PatKind::Tuple(ref subpatterns, ddpos) => {\n                 match ty.kind {\n                     ty::Tuple(ref tys) => {\n                         let subpatterns =\n@@ -584,20 +584,20 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                        })\n                                        .collect();\n \n-                        PatternKind::Leaf { subpatterns }\n+                        PatKind::Leaf { subpatterns }\n                     }\n                     ty::Error => { // Avoid ICE (#50577)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 }\n             }\n \n-            PatKind::Binding(_, id, ident, ref sub) => {\n+            hir::PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_type(pat.hir_id);\n                 if let ty::Error = var_ty.kind {\n                     // Avoid ICE\n-                    return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                    return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                 };\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n@@ -624,7 +624,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     }\n                 }\n \n-                PatternKind::Binding {\n+                PatKind::Binding {\n                     mutability,\n                     mode,\n                     name: ident.name,\n@@ -634,12 +634,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+            hir::PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt_def = match ty.kind {\n                     ty::Adt(adt_def, _) => adt_def,\n                     ty::Error => { // Avoid ICE (#50585)\n-                        return Pattern { span: pat.span, ty, kind: Box::new(PatternKind::Wild) };\n+                        return Pattern { span: pat.span, ty, kind: Box::new(PatKind::Wild) };\n                     }\n                     _ => span_bug!(pat.span,\n                                    \"tuple struct pattern not applied to an ADT {:?}\",\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n-            PatKind::Struct(ref qpath, ref fields, _) => {\n+            hir::PatKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let subpatterns =\n                     fields.iter()\n@@ -675,8 +675,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n \n-            PatKind::Or(ref pats) => {\n-                PatternKind::Or {\n+            hir::PatKind::Or(ref pats) => {\n+                PatKind::Or {\n                     pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n                 }\n             }\n@@ -715,8 +715,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         // dance because of intentional borrow-checker stupidity.\n         let kind = *orig_slice.kind;\n         match kind {\n-            PatternKind::Slice { prefix, slice, mut suffix } |\n-            PatternKind::Array { prefix, slice, mut suffix } => {\n+            PatKind::Slice { prefix, slice, mut suffix } |\n+            PatKind::Array { prefix, slice, mut suffix } => {\n                 let mut orig_prefix = orig_prefix;\n \n                 orig_prefix.extend(prefix);\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         prefix: &'tcx [P<hir::Pat>],\n         slice: &'tcx Option<P<hir::Pat>>,\n         suffix: &'tcx [P<hir::Pat>])\n-        -> PatternKind<'tcx>\n+        -> PatKind<'tcx>\n     {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n@@ -750,14 +750,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         match ty.kind {\n             ty::Slice(..) => {\n                 // matching a slice or fixed-length array\n-                PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n+                PatKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n             ty::Array(_, len) => {\n                 // fixed-length array\n                 let len = len.eval_usize(self.tcx, self.param_env);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n-                PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n+                PatKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n \n             _ => {\n@@ -773,7 +773,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPat<'tcx>>,\n-    ) -> PatternKind<'tcx> {\n+    ) -> PatKind<'tcx> {\n         let res = match res {\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_id) => {\n                 let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n@@ -791,18 +791,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         ty::Adt(_, substs) |\n                         ty::FnDef(_, substs) => substs,\n                         ty::Error => {  // Avoid ICE (#50585)\n-                            return PatternKind::Wild;\n+                            return PatKind::Wild;\n                         }\n                         _ => bug!(\"inappropriate type for def: {:?}\", ty),\n                     };\n-                    PatternKind::Variant {\n+                    PatKind::Variant {\n                         adt_def,\n                         substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns,\n                     }\n                 } else {\n-                    PatternKind::Leaf { subpatterns }\n+                    PatKind::Leaf { subpatterns }\n                 }\n             }\n \n@@ -813,18 +813,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             | Res::Def(DefKind::AssocTy, _)\n             | Res::SelfTy(..)\n             | Res::SelfCtor(..) => {\n-                PatternKind::Leaf { subpatterns }\n+                PatKind::Leaf { subpatterns }\n             }\n \n             _ => {\n                 self.errors.push(PatternError::NonConstPath(span));\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n         };\n \n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n             debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n-            kind = PatternKind::AscribeUserType {\n+            kind = PatKind::AscribeUserType {\n                 subpattern: Pattern {\n                     span,\n                     ty,\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     Pattern {\n                                         span,\n                                         kind: Box::new(\n-                                            PatternKind::AscribeUserType {\n+                                            PatKind::AscribeUserType {\n                                                 subpattern: pattern,\n                                                 ascription: Ascription {\n                                                     /// Note that use `Contravariant` here. See the\n@@ -904,7 +904,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                     span,\n                                     \"could not evaluate constant pattern\",\n                                 );\n-                                PatternKind::Wild\n+                                PatKind::Wild\n                             }\n                         }\n                     },\n@@ -914,7 +914,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         } else {\n                             PatternError::StaticInPattern(span)\n                         });\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n                 }\n             }\n@@ -932,7 +932,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     /// The special case for negation exists to allow things like `-128_i8`\n     /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n-    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n+    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatKind<'tcx> {\n         match expr.kind {\n             hir::ExprKind::Lit(ref lit) => {\n                 let ty = self.tables.expr_ty(expr);\n@@ -946,9 +946,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n-                    Err(LitToConstError::Reported) => PatternKind::Wild,\n+                    Err(LitToConstError::Reported) => PatKind::Wild,\n                 }\n             },\n             hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n@@ -968,9 +968,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n+                        PatKind::Wild\n                     },\n-                    Err(LitToConstError::Reported) => PatternKind::Wild,\n+                    Err(LitToConstError::Reported) => PatKind::Wild,\n                 }\n             }\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n@@ -1085,15 +1085,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     span,\n                     \"floating-point types cannot be used in patterns\",\n                 );\n-                PatternKind::Constant {\n+                PatKind::Constant {\n                     value: cv,\n                 }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n@@ -1106,13 +1106,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 );\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n             ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n             if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatternKind::Wild` is not technically correct.\n+                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n@@ -1122,15 +1122,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 );\n                 *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n-                PatternKind::Wild\n+                PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),\n                     Some(variant_index),\n                 );\n-                PatternKind::Variant {\n+                PatKind::Variant {\n                     adt_def,\n                     substs,\n                     variant_index,\n@@ -1139,17 +1139,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, _) => {\n                 let struct_var = adt_def.non_enum_variant();\n-                PatternKind::Leaf {\n+                PatKind::Leaf {\n                     subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n                 }\n             }\n             ty::Tuple(fields) => {\n-                PatternKind::Leaf {\n+                PatKind::Leaf {\n                     subpatterns: adt_subpatterns(fields.len(), None),\n                 }\n             }\n             ty::Array(_, n) => {\n-                PatternKind::Array {\n+                PatKind::Array {\n                     prefix: (0..n.eval_usize(self.tcx, self.param_env))\n                         .map(|i| adt_subpattern(i as usize, None))\n                         .collect(),\n@@ -1158,7 +1158,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                PatternKind::Constant {\n+                PatKind::Constant {\n                     value: cv,\n                 }\n             }\n@@ -1317,7 +1317,7 @@ pub trait PatternFolder<'tcx> : Sized {\n         pattern.super_fold_with(self)\n     }\n \n-    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n+    fn fold_pattern_kind(&mut self, kind: &PatKind<'tcx>) -> PatKind<'tcx> {\n         kind.super_fold_with(self)\n     }\n }\n@@ -1384,90 +1384,90 @@ impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n     }\n }\n \n-impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n+impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_pattern_kind(self)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            PatternKind::Wild => PatternKind::Wild,\n-            PatternKind::AscribeUserType {\n+            PatKind::Wild => PatKind::Wild,\n+            PatKind::AscribeUserType {\n                 ref subpattern,\n                 ascription: Ascription {\n                     variance,\n                     ref user_ty,\n                     user_ty_span,\n                 },\n-            } => PatternKind::AscribeUserType {\n+            } => PatKind::AscribeUserType {\n                 subpattern: subpattern.fold_with(folder),\n                 ascription: Ascription {\n                     user_ty: user_ty.fold_with(folder),\n                     variance,\n                     user_ty_span,\n                 },\n             },\n-            PatternKind::Binding {\n+            PatKind::Binding {\n                 mutability,\n                 name,\n                 mode,\n                 var,\n                 ty,\n                 ref subpattern,\n-            } => PatternKind::Binding {\n+            } => PatKind::Binding {\n                 mutability: mutability.fold_with(folder),\n                 name: name.fold_with(folder),\n                 mode: mode.fold_with(folder),\n                 var: var.fold_with(folder),\n                 ty: ty.fold_with(folder),\n                 subpattern: subpattern.fold_with(folder),\n             },\n-            PatternKind::Variant {\n+            PatKind::Variant {\n                 adt_def,\n                 substs,\n                 variant_index,\n                 ref subpatterns,\n-            } => PatternKind::Variant {\n+            } => PatKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n                 substs: substs.fold_with(folder),\n                 variant_index,\n                 subpatterns: subpatterns.fold_with(folder)\n             },\n-            PatternKind::Leaf {\n+            PatKind::Leaf {\n                 ref subpatterns,\n-            } => PatternKind::Leaf {\n+            } => PatKind::Leaf {\n                 subpatterns: subpatterns.fold_with(folder),\n             },\n-            PatternKind::Deref {\n+            PatKind::Deref {\n                 ref subpattern,\n-            } => PatternKind::Deref {\n+            } => PatKind::Deref {\n                 subpattern: subpattern.fold_with(folder),\n             },\n-            PatternKind::Constant {\n+            PatKind::Constant {\n                 value\n-            } => PatternKind::Constant {\n+            } => PatKind::Constant {\n                 value,\n             },\n-            PatternKind::Range(range) => PatternKind::Range(range),\n-            PatternKind::Slice {\n+            PatKind::Range(range) => PatKind::Range(range),\n+            PatKind::Slice {\n                 ref prefix,\n                 ref slice,\n                 ref suffix,\n-            } => PatternKind::Slice {\n+            } => PatKind::Slice {\n                 prefix: prefix.fold_with(folder),\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n-            PatternKind::Array {\n+            PatKind::Array {\n                 ref prefix,\n                 ref slice,\n                 ref suffix\n-            } => PatternKind::Array {\n+            } => PatKind::Array {\n                 prefix: prefix.fold_with(folder),\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n-            PatternKind::Or { ref pats } => PatternKind::Or { pats: pats.fold_with(folder) },\n+            PatKind::Or { ref pats } => PatKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }"}]}