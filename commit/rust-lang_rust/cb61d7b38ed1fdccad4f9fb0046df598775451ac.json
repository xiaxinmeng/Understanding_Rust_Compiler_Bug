{"sha": "cb61d7b38ed1fdccad4f9fb0046df598775451ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNjFkN2IzOGVkMWZkY2NhZDRmOWZiMDA0NmRmNTk4Nzc1NDUxYWM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-03T00:18:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-03T00:18:49Z"}, "message": "Pretty-print literals exactly as we saw them in the source.", "tree": {"sha": "096c07ae9b462445f90276d52255cfa1ec9279dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/096c07ae9b462445f90276d52255cfa1ec9279dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb61d7b38ed1fdccad4f9fb0046df598775451ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb61d7b38ed1fdccad4f9fb0046df598775451ac", "html_url": "https://github.com/rust-lang/rust/commit/cb61d7b38ed1fdccad4f9fb0046df598775451ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb61d7b38ed1fdccad4f9fb0046df598775451ac/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32", "html_url": "https://github.com/rust-lang/rust/commit/3a6b5576acbcd0ee2ae3e28847d0b41e2b82ed32"}], "stats": {"total": 126, "additions": 91, "deletions": 35}, "files": [{"sha": "b6f5ab9e9c3a640495e7029fbd35b131b01e85ae", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb61d7b38ed1fdccad4f9fb0046df598775451ac/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb61d7b38ed1fdccad4f9fb0046df598775451ac/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=cb61d7b38ed1fdccad4f9fb0046df598775451ac", "patch": "@@ -20,6 +20,7 @@ state type reader = state obj {\n     fn bump();\n     fn mark();\n     fn get_mark_chpos() -> uint;\n+    fn get_mark_str() -> str;\n     fn get_interner() -> @interner::interner[str];\n     fn get_chpos() -> uint;\n     fn get_col() -> uint;\n@@ -48,6 +49,9 @@ fn new_reader(session sess, io::reader rdr,\n         }\n \n         fn mark() { mark_chpos = chpos; }\n+        fn get_mark_str() -> str {\n+            ret str::slice(file, mark_chpos, chpos);\n+        }\n         fn get_mark_chpos() -> uint { ret mark_chpos; }\n         fn get_chpos() -> uint { ret chpos; }\n \n@@ -101,8 +105,7 @@ fn new_reader(session sess, io::reader rdr,\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];\n     auto rd = reader(sess, file, str::byte_len(file), 0u, 0u,\n-                     -1 as char,\n-                     filemap.start_pos, filemap.start_pos,\n+                     -1 as char, filemap.start_pos, filemap.start_pos,\n                      strs, filemap, itr);\n     rd.init();\n     ret rd;\n@@ -888,11 +891,29 @@ fn consume_comment(&reader rdr, bool code_to_the_left,\n     log \"<<< consume comment\";\n }\n \n-fn gather_comments(session sess, str path) -> vec[cmnt] {\n+fn is_lit(&token::token t) -> bool {\n+    ret alt (t) {\n+        case (token::LIT_INT(_)) { true }\n+        case (token::LIT_UINT(_)) { true }\n+        case (token::LIT_MACH_INT(_,_)) { true }\n+        case (token::LIT_FLOAT(_)) { true }\n+        case (token::LIT_MACH_FLOAT(_,_)) { true }\n+        case (token::LIT_STR(_)) { true }\n+        case (token::LIT_CHAR(_)) { true }\n+        case (token::LIT_BOOL(_)) { true }\n+        case (_) { false }\n+    }\n+}\n+\n+type lit = rec(str lit, uint pos);\n+\n+fn gather_comments_and_literals(session sess, str path)\n+    -> rec(vec[cmnt] cmnts, vec[lit] lits) {\n     auto srdr = io::file_reader(path);\n     auto itr = @interner::mk[str](str::hash, str::eq);\n     auto rdr = new_reader(sess, srdr, codemap::new_filemap(path, 0u), itr);\n     let vec[cmnt] comments = [];\n+    let vec[lit] literals = [];\n     while (!rdr.is_eof()) {\n         while (true) {\n             auto code_to_the_left = true;\n@@ -907,9 +928,12 @@ fn gather_comments(session sess, str path) -> vec[cmnt] {\n             }\n             break;\n         }\n-        next_token(rdr);\n+        if (is_lit(next_token(rdr))) {\n+            vec::push[lit](literals, rec(lit=rdr.get_mark_str(),\n+                                         pos=rdr.get_mark_chpos()));\n+        }\n     }\n-    ret comments;\n+    ret rec(cmnts=comments, lits=literals);\n  }\n \n "}, {"sha": "926435d29282d1857a60d68331c2dfb2ea719657", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cb61d7b38ed1fdccad4f9fb0046df598775451ac/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb61d7b38ed1fdccad4f9fb0046df598775451ac/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=cb61d7b38ed1fdccad4f9fb0046df598775451ac", "patch": "@@ -12,6 +12,9 @@ import middle::ty;\n import util::common;\n import pp;\n \n+import option::some;\n+import option::none;\n+\n import pp::printer;\n import pp::break_offset;\n import pp::word;\n@@ -37,16 +40,20 @@ tag mode {\n type ps = @rec(pp::printer s,\n                option::t[codemap] cm,\n                option::t[vec[lexer::cmnt]] comments,\n+               option::t[vec[lexer::lit]] literals,\n                mutable uint cur_cmnt,\n+               mutable uint cur_lit,\n                mutable vec[pp::breaks] boxes,\n                mode mode);\n \n fn rust_printer(io::writer writer) -> ps {\n     let vec[pp::breaks] boxes = [];\n     ret @rec(s=pp::mk_printer(writer, default_columns),\n-             cm=option::none[codemap],\n-             comments=option::none[vec[lexer::cmnt]],\n+             cm=none[codemap],\n+             comments=none[vec[lexer::cmnt]],\n+             literals=none[vec[lexer::lit]],\n              mutable cur_cmnt=0u,\n+             mutable cur_lit=0u,\n              mutable boxes=boxes,\n              mode=mo_untyped);\n }\n@@ -62,11 +69,13 @@ fn to_str[T](&T t, fn(&ps s, &T s) f) -> str {\n fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n     let vec[pp::breaks] boxes = [];\n-    auto cmnts = lexer::gather_comments(sess, filename);\n+    auto r = lexer::gather_comments_and_literals(sess, filename);\n     auto s = @rec(s=pp::mk_printer(out, default_columns),\n-                  cm=option::some[codemap](sess.get_codemap()),\n-                  comments=option::some[vec[lexer::cmnt]](cmnts),\n+                  cm=some(sess.get_codemap()),\n+                  comments=some(r.cmnts),\n+                  literals=some(r.lits),\n                   mutable cur_cmnt=0u,\n+                  mutable cur_lit=0u,\n                   mutable boxes = boxes,\n                   mode=mode);\n     print_mod(s, _mod);\n@@ -281,15 +290,15 @@ fn print_type(&ps s, &ast::ty ty) {\n             for (ast::ty_method m in methods) {\n                 hardbreak(s.s);\n                 cbox(s, indent_unit);\n-                print_ty_fn(s, m.proto, option::some[str](m.ident),\n+                print_ty_fn(s, m.proto, some(m.ident),\n                             m.inputs, m.output, m.cf);\n                 word(s.s, \";\");\n                 end(s);\n             }\n             bclose(s, ty.span);\n         }\n         case (ast::ty_fn(?proto,?inputs,?output,?cf)) {\n-            print_ty_fn(s, proto, option::none[str], inputs, output, cf);\n+            print_ty_fn(s, proto, none[str], inputs, output, cf);\n         }\n         case (ast::ty_path(?path,_)) {\n             print_path(s, path);\n@@ -351,8 +360,8 @@ fn print_item(&ps s, &@ast::item item) {\n                         print_fn(s, decl, ast::proto_fn, id, typarams);\n                         end(s); // end head-ibox\n                         alt (lname) {\n-                            case (option::none[str]) {}\n-                            case (option::some[str](?ss)) {\n+                            case (none) {}\n+                            case (some(?ss)) {\n                                 print_string(s, ss);\n                             }\n                         }\n@@ -430,7 +439,7 @@ fn print_item(&ps s, &@ast::item item) {\n                 print_block(s, meth.node.meth.body);\n             }\n             alt (_obj.dtor) {\n-                case (option::some[@ast::method](?dtor)) {\n+                case (some(?dtor)) {\n                     head(s, \"drop\");\n                     print_block(s, dtor.node.meth.body);\n                 }\n@@ -474,7 +483,7 @@ fn print_block(&ps s, ast::block blk) {\n \n     }\n     alt (blk.node.expr) {\n-        case (option::some[@ast::expr](?expr)) {\n+        case (some(?expr)) {\n             space(s.s);\n             print_expr(s, expr);\n             maybe_print_trailing_comment(s, expr.span);\n@@ -493,8 +502,31 @@ fn print_block(&ps s, ast::block blk) {\n     }\n }\n \n+fn next_lit(&ps s) -> option::t[lexer::lit] {\n+    alt (s.literals) {\n+        case (some(?lits)) {\n+            if (s.cur_lit < vec::len(lits)) {\n+                ret some(lits.(s.cur_lit));\n+            } else {ret none[lexer::lit];}\n+        }\n+        case (_) {ret none[lexer::lit];}\n+    }\n+}\n+\n fn print_literal(&ps s, &@ast::lit lit) {\n     maybe_print_comment(s, lit.span.lo);\n+\n+    alt (next_lit(s)) {\n+        case (some(?lt)) {\n+            if (lt.pos == lit.span.lo) {\n+                word(s.s, lt.lit);\n+                s.cur_lit += 1u;\n+                ret;\n+            }\n+        }\n+        case (_) {}\n+    }\n+\n     alt (lit.node) {\n         case (ast::lit_str(?st)) {print_string(s, st);}\n         case (ast::lit_char(?ch)) {\n@@ -504,8 +536,8 @@ fn print_literal(&ps s, &@ast::lit lit) {\n         case (ast::lit_int(?val)) {\n             word(s.s, common::istr(val));\n         }\n-        case (ast::lit_uint(?val)) { // FIXME clipping? uistr?\n-            word(s.s, common::istr(val as int) + \"u\");\n+        case (ast::lit_uint(?val)) {\n+            word(s.s, common::uistr(val) + \"u\");\n         }\n         case (ast::lit_float(?fstr)) {\n             word(s.s, fstr);\n@@ -580,7 +612,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             auto gs = get_span;\n             commasep_cmnt[ast::field](s, consistent, fields, f, gs);\n             alt (wth) {\n-                case (option::some[@ast::expr](?expr)) {\n+                case (some(?expr)) {\n                     if (vec::len[ast::field](fields) > 0u) {space(s.s);}\n                     ibox(s, indent_unit);\n                     word_space(s, \"with\");\n@@ -605,7 +637,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         case (ast::expr_bind(?func,?args,_)) {\n             fn print_opt(&ps s, &option::t[@ast::expr] expr) {\n                 alt (expr) {\n-                    case (option::some[@ast::expr](?expr)) {\n+                    case (some(?expr)) {\n                         print_expr(s, expr);\n                     }\n                     case (_) {word(s.s, \"_\");}\n@@ -655,7 +687,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             print_block(s, block);\n             fn do_else(&ps s, option::t[@ast::expr] els) {\n                 alt (els) {\n-                    case (option::some[@ast::expr](?_else)) {\n+                    case (some(?_else)) {\n                         alt (_else.node) {\n                             // \"another else-if\"\n                             case (ast::expr_if(?i,?t,?e,_)) {\n@@ -807,7 +839,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         case (ast::expr_ret(?result,_)) {\n             word(s.s, \"ret\");\n             alt (result) {\n-                case (option::some[@ast::expr](?expr)) {\n+                case (some(?expr)) {\n                     word(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n@@ -817,7 +849,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         case (ast::expr_put(?result,_)) {\n             word(s.s, \"put\");\n             alt (result) {\n-                case (option::some[@ast::expr](?expr)) {\n+                case (some(?expr)) {\n                     word(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n@@ -902,7 +934,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n             space(s.s);\n             ibox(s, indent_unit);\n             alt (loc.ty) {\n-                case (option::some[@ast::ty](?ty)) {\n+                case (some(?ty)) {\n                     word_nbsp(s, \"let\");\n                     print_type(s, *ty);\n                     space(s.s);\n@@ -924,7 +956,7 @@ fn print_decl(&ps s, &@ast::decl decl) {\n             }\n             word(s.s, loc.ident);\n             alt (loc.init) {\n-                case (option::some[ast::initializer](?init)) {\n+                case (some(?init)) {\n                     space(s.s);\n                     alt (init.op) {\n                         case (ast::init_assign) {\n@@ -1176,7 +1208,7 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n     if (proto == ast::proto_fn) {word(s.s, \"fn\");}\n     else {word(s.s, \"iter\");}\n     alt (id) {\n-        case (option::some[str](?id)) {space(s.s); word(s.s, id);}\n+        case (some(?id)) {space(s.s); word(s.s, id);}\n         case (_) {}\n     }\n     popen(s);\n@@ -1207,19 +1239,19 @@ fn print_ty_fn(&ps s, &ast::proto proto, &option::t[str] id,\n \n fn next_comment(&ps s) -> option::t[lexer::cmnt] {\n     alt (s.comments) {\n-        case (option::some[vec[lexer::cmnt]](?cmnts)) {\n-            if (s.cur_cmnt < vec::len[lexer::cmnt](cmnts)) {\n-                ret option::some[lexer::cmnt](cmnts.(s.cur_cmnt));\n-            } else {ret option::none[lexer::cmnt];}\n+        case (some(?cmnts)) {\n+            if (s.cur_cmnt < vec::len(cmnts)) {\n+                ret some(cmnts.(s.cur_cmnt));\n+            } else {ret none[lexer::cmnt];}\n         }\n-        case (_) {ret option::none[lexer::cmnt];}\n+        case (_) {ret none[lexer::cmnt];}\n     }\n }\n \n fn maybe_print_comment(&ps s, uint pos) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (option::some[lexer::cmnt](?cmnt)) {\n+            case (some(?cmnt)) {\n                 if (cmnt.pos < pos) {\n                     print_comment(s, cmnt);\n                     s.cur_cmnt += 1u;\n@@ -1233,13 +1265,13 @@ fn maybe_print_comment(&ps s, uint pos) {\n fn maybe_print_trailing_comment(&ps s, common::span span) {\n     auto cm;\n     alt (s.cm) {\n-        case (option::some[codemap](?ccm)) {\n+        case (some(?ccm)) {\n             cm = ccm;\n         }\n         case (_) { ret; }\n     }\n     alt (next_comment(s)) {\n-        case (option::some[lexer::cmnt](?cmnt)) {\n+        case (some(?cmnt)) {\n             if (cmnt.style != lexer::trailing) { ret; }\n \n             auto span_line = codemap::lookup_pos(cm, span.hi);\n@@ -1258,7 +1290,7 @@ fn maybe_print_trailing_comment(&ps s, common::span span) {\n fn print_remaining_comments(&ps s) {\n     while (true) {\n         alt (next_comment(s)) {\n-            case (option::some[lexer::cmnt](?cmnt)) {\n+            case (some(?cmnt)) {\n                 print_comment(s, cmnt);\n                 s.cur_cmnt += 1u;\n             }"}]}