{"sha": "d4e3570db4c007089035b833cc20c7fc2f8cb32f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZTM1NzBkYjRjMDA3MDg5MDM1YjgzM2NjMjBjN2ZjMmY4Y2IzMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-01T19:31:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-01T19:31:01Z"}, "message": "Auto merge of #80641 - Danue1:patch-1, r=oli-obk\n\nAdd visitors for checking #[inline]\n\nFor #80564", "tree": {"sha": "495a190075ead782ebbd728cce0ee7e651e6904a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495a190075ead782ebbd728cce0ee7e651e6904a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4e3570db4c007089035b833cc20c7fc2f8cb32f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e3570db4c007089035b833cc20c7fc2f8cb32f", "html_url": "https://github.com/rust-lang/rust/commit/d4e3570db4c007089035b833cc20c7fc2f8cb32f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4e3570db4c007089035b833cc20c7fc2f8cb32f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b85d722050d61b40ae9746b3bac54ab55b1056", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b85d722050d61b40ae9746b3bac54ab55b1056", "html_url": "https://github.com/rust-lang/rust/commit/02b85d722050d61b40ae9746b3bac54ab55b1056"}, {"sha": "838f487fc5a276eacb11d58d60b0f79358f9919f", "url": "https://api.github.com/repos/rust-lang/rust/commits/838f487fc5a276eacb11d58d60b0f79358f9919f", "html_url": "https://github.com/rust-lang/rust/commit/838f487fc5a276eacb11d58d60b0f79358f9919f"}], "stats": {"total": 400, "additions": 344, "deletions": 56}, "files": [{"sha": "6dbcfb963ee0eccdd55b2998a4b7719ad14a2d69", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -38,19 +38,22 @@ pub enum Target {\n     Enum,\n     Variant,\n     Struct,\n+    Field,\n     Union,\n     Trait,\n     TraitAlias,\n     Impl,\n     Expression,\n     Statement,\n+    Arm,\n     AssocConst,\n     Method(MethodKind),\n     AssocTy,\n     ForeignFn,\n     ForeignStatic,\n     ForeignTy,\n     GenericParam(GenericParamKind),\n+    MacroDef,\n }\n \n impl Display for Target {\n@@ -73,12 +76,14 @@ impl Display for Target {\n                 Target::Enum => \"enum\",\n                 Target::Variant => \"enum variant\",\n                 Target::Struct => \"struct\",\n+                Target::Field => \"struct field\",\n                 Target::Union => \"union\",\n                 Target::Trait => \"trait\",\n                 Target::TraitAlias => \"trait alias\",\n                 Target::Impl => \"item\",\n                 Target::Expression => \"expression\",\n                 Target::Statement => \"statement\",\n+                Target::Arm => \"match arm\",\n                 Target::AssocConst => \"associated const\",\n                 Target::Method(_) => \"method\",\n                 Target::AssocTy => \"associated type\",\n@@ -90,6 +95,7 @@ impl Display for Target {\n                     GenericParamKind::Lifetime => \"lifetime parameter\",\n                     GenericParamKind::Const => \"const parameter\",\n                 },\n+                Target::MacroDef => \"macro def\",\n             }\n         )\n     }"}, {"sha": "412d5b5082be30daf1ec17f6eb403e6feb3d1a56", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, Definitions};\n use rustc_hir::intravisit;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n@@ -494,6 +495,15 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn visit_exported_macros_in_krate<V>(&self, visitor: &mut V)\n+    where\n+        V: Visitor<'hir>,\n+    {\n+        for id in self.krate().exported_macros {\n+            visitor.visit_macro_def(self.expect_macro_def(id.hir_id));\n+        }\n+    }\n+\n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     pub fn get(&self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n@@ -802,6 +812,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn expect_macro_def(&self, id: HirId) -> &'hir MacroDef<'hir> {\n+        match self.find(id) {\n+            Some(Node::MacroDef(macro_def)) => macro_def,\n+            _ => bug!(\"expected macro def, found {}\", self.node_to_string(id)),\n+        }\n+    }\n+\n     pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             Some(Node::Expr(expr)) => expr,\n@@ -821,6 +838,7 @@ impl<'hir> Map<'hir> {\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { kind: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name(self.get_parent_item(id)),\n+            Node::MacroDef(md) => md.ident.name,\n             _ => return None,\n         })\n     }"}, {"sha": "0e3a722e082f262683ca5b28b9de1951ea5751e6", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 263, "deletions": 45, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -70,27 +70,27 @@ impl CheckAttrVisitor<'tcx> {\n             is_valid &= if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(hir_id, attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::non_exhaustive) {\n-                self.check_non_exhaustive(attr, span, target)\n+                self.check_non_exhaustive(hir_id, attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::marker) {\n-                self.check_marker(attr, span, target)\n+                self.check_marker(hir_id, attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::target_feature) {\n                 self.check_target_feature(hir_id, attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::track_caller) {\n-                self.check_track_caller(&attr.span, attrs, span, target)\n+                self.check_track_caller(hir_id, &attr.span, attrs, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 self.check_doc_attrs(attr, hir_id, target)\n             } else if self.tcx.sess.check_name(attr, sym::no_link) {\n-                self.check_no_link(&attr, span, target)\n+                self.check_no_link(hir_id, &attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::export_name) {\n-                self.check_export_name(&attr, span, target)\n+                self.check_export_name(hir_id, &attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::rustc_args_required_const) {\n                 self.check_rustc_args_required_const(&attr, span, target, item)\n             } else if self.tcx.sess.check_name(attr, sym::allow_internal_unstable) {\n-                self.check_allow_internal_unstable(&attr, span, target, &attrs)\n+                self.check_allow_internal_unstable(hir_id, &attr, span, target, &attrs)\n             } else if self.tcx.sess.check_name(attr, sym::rustc_allow_const_fn_unstable) {\n                 self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::naked) {\n-                self.check_naked(attr, span, target)\n+                self.check_naked(hir_id, attr, span, target)\n             } else {\n                 // lint-only checks\n                 if self.tcx.sess.check_name(attr, sym::cold) {\n@@ -118,6 +118,41 @@ impl CheckAttrVisitor<'tcx> {\n         self.check_used(attrs, target);\n     }\n \n+    fn inline_attr_str_error_with_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n+        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+            lint.build(&format!(\n+                \"`#[{}]` is ignored on struct fields, match arms and macro defs\",\n+                sym,\n+            ))\n+            .warn(\n+                \"this was previously accepted by the compiler but is \\\n+                 being phased out; it will become a hard error in \\\n+                 a future release!\",\n+            )\n+            .note(\n+                \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n+                 for more information\",\n+            )\n+            .emit();\n+        });\n+    }\n+\n+    fn inline_attr_str_error_without_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n+        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+            lint.build(&format!(\"`#[{}]` is ignored on struct fields and match arms\", sym))\n+                .warn(\n+                    \"this was previously accepted by the compiler but is \\\n+                 being phased out; it will become a hard error in \\\n+                 a future release!\",\n+                )\n+                .note(\n+                    \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n+                 for more information\",\n+                )\n+                .emit();\n+        });\n+    }\n+\n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n     fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n@@ -150,6 +185,11 @@ impl CheckAttrVisitor<'tcx> {\n                 });\n                 true\n             }\n+            // FIXME(#80564): Same for fields, arms, and macro defs\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"inline\");\n+                true\n+            }\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n@@ -165,10 +205,18 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if `#[naked]` is applied to a function definition.\n-    fn check_naked(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_naked(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"naked\");\n+                true\n+            }\n             _ => {\n                 self.tcx\n                     .sess\n@@ -186,6 +234,7 @@ impl CheckAttrVisitor<'tcx> {\n     /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n     fn check_track_caller(\n         &self,\n+        hir_id: HirId,\n         attr_span: &Span,\n         attrs: &'hir [Attribute],\n         span: &Span,\n@@ -203,6 +252,16 @@ impl CheckAttrVisitor<'tcx> {\n                 false\n             }\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[track_caller]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                for attr in attrs {\n+                    self.inline_attr_str_error_with_macro_def(hir_id, attr, \"track_caller\");\n+                }\n+                true\n+            }\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n@@ -218,9 +277,23 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_non_exhaustive(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_non_exhaustive(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+    ) -> bool {\n         match target {\n             Target::Struct | Target::Enum | Target::Variant => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[non_exhaustive]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"non_exhaustive\");\n+                true\n+            }\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n@@ -236,9 +309,17 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_marker(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_marker(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n             Target::Trait => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[marker]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"marker\");\n+                true\n+            }\n             _ => {\n                 self.tcx\n                     .sess\n@@ -276,6 +357,14 @@ impl CheckAttrVisitor<'tcx> {\n                 });\n                 true\n             }\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[target_feature]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"target_feature\");\n+                true\n+            }\n             _ => {\n                 self.tcx\n                     .sess\n@@ -464,6 +553,13 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_cold(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => {}\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[cold]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"cold\");\n+            }\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions and some crates used\n                 // this, so only emit a warning.\n@@ -485,6 +581,13 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_link_name(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {\n             Target::ForeignFn | Target::ForeignStatic => {}\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[link_name]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"link_name\");\n+            }\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions/statics and some crates\n                 // used this, so only emit a warning.\n@@ -517,23 +620,49 @@ impl CheckAttrVisitor<'tcx> {\n     }\n \n     /// Checks if `#[no_link]` is applied to an `extern crate`. Returns `true` if valid.\n-    fn check_no_link(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n-        if target == Target::ExternCrate {\n-            true\n-        } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to an `extern crate` item\")\n-                .span_label(*span, \"not an `extern crate` item\")\n-                .emit();\n-            false\n+    fn check_no_link(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::ExternCrate => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[no_link]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"no_link\");\n+                true\n+            }\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        \"attribute should be applied to an `extern crate` item\",\n+                    )\n+                    .span_label(*span, \"not an `extern crate` item\")\n+                    .emit();\n+                false\n+            }\n         }\n     }\n \n     /// Checks if `#[export_name]` is applied to a function or static. Returns `true` if valid.\n-    fn check_export_name(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+    fn check_export_name(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+    ) -> bool {\n         match target {\n             Target::Static | Target::Fn | Target::Method(..) => true,\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[export_name]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"export_name\");\n+                true\n+            }\n             _ => {\n                 self.tcx\n                     .sess\n@@ -625,6 +754,13 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_link_section(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {\n             Target::Static | Target::Fn | Target::Method(..) => {}\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[link_section]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"link_section\");\n+            }\n             _ => {\n                 // FIXME: #[link_section] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n@@ -646,6 +782,13 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_no_mangle(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) {\n         match target {\n             Target::Static | Target::Fn | Target::Method(..) => {}\n+            // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n+            // `#[no_mangle]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"no_mangle\");\n+            }\n             _ => {\n                 // FIXME: #[no_mangle] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n@@ -828,27 +971,46 @@ impl CheckAttrVisitor<'tcx> {\n     /// (Allows proc_macro functions)\n     fn check_allow_internal_unstable(\n         &self,\n+        hir_id: HirId,\n         attr: &Attribute,\n         span: &Span,\n         target: Target,\n         attrs: &[Attribute],\n     ) -> bool {\n         debug!(\"Checking target: {:?}\", target);\n-        if target == Target::Fn {\n-            for attr in attrs {\n-                if self.tcx.sess.is_proc_macro_attr(attr) {\n-                    debug!(\"Is proc macro attr\");\n-                    return true;\n+        match target {\n+            Target::Fn => {\n+                for attr in attrs {\n+                    if self.tcx.sess.is_proc_macro_attr(attr) {\n+                        debug!(\"Is proc macro attr\");\n+                        return true;\n+                    }\n                 }\n+                debug!(\"Is not proc macro attr\");\n+                false\n+            }\n+            Target::MacroDef => true,\n+            // FIXME(#80564): We permit struct fields and match arms to have an\n+            // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm => {\n+                self.inline_attr_str_error_without_macro_def(\n+                    hir_id,\n+                    attr,\n+                    \"allow_internal_unstable\",\n+                );\n+                true\n+            }\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n+                    .span_label(*span, \"not a macro\")\n+                    .emit();\n+                false\n             }\n-            debug!(\"Is not proc macro attr\");\n         }\n-        self.tcx\n-            .sess\n-            .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n-            .span_label(*span, \"not a macro\")\n-            .emit();\n-        false\n     }\n \n     /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros.\n@@ -860,17 +1022,29 @@ impl CheckAttrVisitor<'tcx> {\n         span: &Span,\n         target: Target,\n     ) -> bool {\n-        if let Target::Fn | Target::Method(_) = target {\n-            if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id)) {\n-                return true;\n+        match target {\n+            Target::Fn | Target::Method(_)\n+                if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id)) =>\n+            {\n+                true\n+            }\n+            // FIXME(#80564): We permit struct fields and match arms to have an\n+            // `#[allow_internal_unstable]` attribute with just a lint, because we previously\n+            // erroneously allowed it and some crates used it accidentally, to to be compatible\n+            // with crates depending on them, we can't throw an error here.\n+            Target::Field | Target::Arm | Target::MacroDef => {\n+                self.inline_attr_str_error_with_macro_def(hir_id, attr, \"allow_internal_unstable\");\n+                true\n+            }\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n+                    .span_label(*span, \"not a `const fn`\")\n+                    .emit();\n+                false\n             }\n         }\n-        self.tcx\n-            .sess\n-            .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n-            .span_label(*span, \"not a `const fn`\")\n-            .emit();\n-        false\n     }\n }\n \n@@ -911,6 +1085,33 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n+    fn visit_struct_field(&mut self, struct_field: &'tcx hir::StructField<'tcx>) {\n+        self.check_attributes(\n+            struct_field.hir_id,\n+            &struct_field.attrs,\n+            &struct_field.span,\n+            Target::Field,\n+            None,\n+        );\n+        intravisit::walk_struct_field(self, struct_field);\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n+        self.check_attributes(arm.hir_id, &arm.attrs, &arm.span, Target::Arm, None);\n+        intravisit::walk_arm(self, arm);\n+    }\n+\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n+        self.check_attributes(\n+            macro_def.hir_id,\n+            &macro_def.attrs,\n+            &macro_def.span,\n+            Target::MacroDef,\n+            None,\n+        );\n+        intravisit::walk_macro_def(self, macro_def);\n+    }\n+\n     fn visit_foreign_item(&mut self, f_item: &'tcx ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(\n@@ -999,11 +1200,28 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n     }\n }\n \n+fn check_invalid_macro_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n+    for attr in attrs {\n+        if tcx.sess.check_name(attr, sym::inline) {\n+            struct_span_err!(\n+                tcx.sess,\n+                attr.span,\n+                E0518,\n+                \"attribute should be applied to function or closure\",\n+            )\n+            .span_label(attr.span, \"not a function or closure\")\n+            .emit();\n+        }\n+    }\n+}\n+\n fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir()\n-        .visit_item_likes_in_module(module_def_id, &mut CheckAttrVisitor { tcx }.as_deep_visitor());\n+    let check_attr_visitor = &mut CheckAttrVisitor { tcx };\n+    tcx.hir().visit_item_likes_in_module(module_def_id, &mut check_attr_visitor.as_deep_visitor());\n+    tcx.hir().visit_exported_macros_in_krate(check_attr_visitor);\n+    check_invalid_macro_level_attr(tcx, tcx.hir().krate().non_exported_macro_attrs);\n     if module_def_id.is_top_level_module() {\n-        CheckAttrVisitor { tcx }.check_attributes(\n+        check_attr_visitor.check_attributes(\n             CRATE_HIR_ID,\n             tcx.hir().krate_attrs(),\n             &DUMMY_SP,"}, {"sha": "674c12454cdaa66d2318b36a109f23b5c1971402", "filename": "src/test/ui/attr-usage-inline.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fattr-usage-inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fattr-usage-inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattr-usage-inline.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -6,4 +6,20 @@ fn f() {}\n #[inline] //~ ERROR: attribute should be applied to function or closure\n struct S;\n \n+struct I {\n+    #[inline]\n+    i: u8,\n+}\n+\n+#[macro_export]\n+#[inline]\n+macro_rules! m_e {\n+    () => {};\n+}\n+\n+#[inline] //~ ERROR: attribute should be applied to function or closure\n+macro_rules! m {\n+    () => {};\n+}\n+\n fn main() {}"}, {"sha": "22a0bf47e202676fdd3d2ea849096268cd24870d", "filename": "src/test/ui/attr-usage-inline.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fattr-usage-inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fattr-usage-inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattr-usage-inline.stderr?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -6,6 +6,12 @@ LL | #[inline]\n LL | struct S;\n    | --------- not a function or closure\n \n-error: aborting due to previous error\n+error[E0518]: attribute should be applied to function or closure\n+  --> $DIR/attr-usage-inline.rs:20:1\n+   |\n+LL | #[inline]\n+   | ^^^^^^^^^ not a function or closure\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0518`."}, {"sha": "b8987d3e13c654c837a797925825773593ff6872", "filename": "src/test/ui/internal/internal-unstable.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -1,10 +1,17 @@\n // aux-build:internal_unstable.rs\n \n #![feature(allow_internal_unstable)]\n+#[allow(dead_code)]\n \n #[macro_use]\n extern crate internal_unstable;\n \n+struct Baz {\n+    #[allow_internal_unstable]\n+    //^ WARN `#[allow_internal_unstable]` is ignored on struct fields and match arms\n+    baz: u8,\n+}\n+\n macro_rules! foo {\n     ($e: expr, $f: expr) => {{\n         $e;\n@@ -40,4 +47,10 @@ fn main() {\n     println!(\"{:?}\", internal_unstable::unstable()); //~ ERROR use of unstable\n \n     bar!(internal_unstable::unstable()); //~ ERROR use of unstable\n+\n+    match true {\n+        #[allow_internal_unstable]\n+        //^ WARN `#[allow_internal_unstable]` is ignored on struct fields and match arms\n+        _ => {}\n+    }\n }"}, {"sha": "a92ca4957b573314aefeb3ef6d6a0efdc0475c94", "filename": "src/test/ui/internal/internal-unstable.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable.stderr?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -1,37 +1,37 @@\n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:34:25\n+  --> $DIR/internal-unstable.rs:41:25\n    |\n LL |     pass_through_allow!(internal_unstable::unstable());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:36:27\n+  --> $DIR/internal-unstable.rs:43:27\n    |\n LL |     pass_through_noallow!(internal_unstable::unstable());\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:40:22\n+  --> $DIR/internal-unstable.rs:47:22\n    |\n LL |     println!(\"{:?}\", internal_unstable::unstable());\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:42:10\n+  --> $DIR/internal-unstable.rs:49:10\n    |\n LL |     bar!(internal_unstable::unstable());\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(function)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'function'\n-  --> $DIR/internal-unstable.rs:12:9\n+  --> $DIR/internal-unstable.rs:19:9\n    |\n LL |         internal_unstable::unstable();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a6e9ed14ff13e7fd4ddc9d6c2d56101a5e994ac0", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -21,7 +21,9 @@ fn non_macro_expanded_location<#[repr(C)] T>() {\n     //~^ ERROR `repr` is ambiguous\n     //~| ERROR attribute should be applied to a struct, enum, or union\n     match 0u8 {\n-        #[repr(C)] //~ ERROR `repr` is ambiguous\n+        #[repr(C)]\n+        //~^ ERROR `repr` is ambiguous\n+        //~| ERROR attribute should be applied to a struct, enum, or union\n         _ => {}\n     }\n }"}, {"sha": "31959248a68c275694aff1256355a3cba888b006", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4e3570db4c007089035b833cc20c7fc2f8cb32f/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=d4e3570db4c007089035b833cc20c7fc2f8cb32f", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find value `NonExistent` in this scope\n-  --> $DIR/ambiguous-builtin-attrs.rs:32:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:34:5\n    |\n LL |     NonExistent;\n    |     ^^^^^^^^^^^ not found in this scope\n@@ -61,14 +61,14 @@ LL | use builtin_attrs::*;\n    = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n error[E0659]: `allow` is ambiguous (built-in attribute vs any other name)\n-  --> $DIR/ambiguous-builtin-attrs.rs:36:3\n+  --> $DIR/ambiguous-builtin-attrs.rs:38:3\n    |\n LL | #[allow(unused)]\n    |   ^^^^^ ambiguous name\n    |\n    = note: `allow` could refer to a built-in attribute\n note: `allow` could also refer to the built-in attribute imported here\n-  --> $DIR/ambiguous-builtin-attrs.rs:35:5\n+  --> $DIR/ambiguous-builtin-attrs.rs:37:5\n    |\n LL | use deny as allow;\n    |     ^^^^^^^^^^^^^\n@@ -94,7 +94,16 @@ error[E0517]: attribute should be applied to a struct, enum, or union\n LL | fn non_macro_expanded_location<#[repr(C)] T>() {\n    |                                       ^   - not a struct, enum, or union\n \n-error: aborting due to 8 previous errors\n+error[E0517]: attribute should be applied to a struct, enum, or union\n+  --> $DIR/ambiguous-builtin-attrs.rs:24:16\n+   |\n+LL |         #[repr(C)]\n+   |                ^\n+...\n+LL |         _ => {}\n+   |         ------- not a struct, enum, or union\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0425, E0517, E0659.\n For more information about an error, try `rustc --explain E0425`."}]}