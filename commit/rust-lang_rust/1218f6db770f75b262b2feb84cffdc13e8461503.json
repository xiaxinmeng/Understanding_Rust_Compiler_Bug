{"sha": "1218f6db770f75b262b2feb84cffdc13e8461503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMThmNmRiNzcwZjc1YjI2MmIyZmViODRjZmZkYzEzZTg0NjE1MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-15T03:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-15T03:01:32Z"}, "message": "auto merge of #12887 : huonw/rust/danger-guide, r=alexcrichton\n\ndocs: begin a \"low-level & unsafe code\" guide.\r\n\r\nThis aims to cover the basics of writing safe unsafe code. At the moment\r\nit is just designed to be a better place for the `asm!()` docs than the\r\ndetailed release notes wiki page, and I took the time to write up some\r\nother things.\r\n\r\nMore examples are needed, especially of things that can subtly go wrong;\r\nand vast areas of `unsafe`-ty aren't covered, e.g. `static mut`s and\r\nthread-safety in general.", "tree": {"sha": "32c449f5806175d3fbe76eb6a6ef5b18417f867d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32c449f5806175d3fbe76eb6a6ef5b18417f867d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1218f6db770f75b262b2feb84cffdc13e8461503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1218f6db770f75b262b2feb84cffdc13e8461503", "html_url": "https://github.com/rust-lang/rust/commit/1218f6db770f75b262b2feb84cffdc13e8461503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1218f6db770f75b262b2feb84cffdc13e8461503/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58fb492f9c827ee824de8f3767ff102cafb1ca88", "url": "https://api.github.com/repos/rust-lang/rust/commits/58fb492f9c827ee824de8f3767ff102cafb1ca88", "html_url": "https://github.com/rust-lang/rust/commit/58fb492f9c827ee824de8f3767ff102cafb1ca88"}, {"sha": "3d6c28acd0bfd4a7533169ac523a623177b1cfe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6c28acd0bfd4a7533169ac523a623177b1cfe7", "html_url": "https://github.com/rust-lang/rust/commit/3d6c28acd0bfd4a7533169ac523a623177b1cfe7"}], "stats": {"total": 689, "additions": 609, "deletions": 80}, "files": [{"sha": "0c23bbbe7c2d5bd93be3483581e5b17d860b5ed3", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1218f6db770f75b262b2feb84cffdc13e8461503/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1218f6db770f75b262b2feb84cffdc13e8461503/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=1218f6db770f75b262b2feb84cffdc13e8461503", "patch": "@@ -29,7 +29,8 @@\n DOCS := index tutorial guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n \tguide-runtime complement-bugreport complement-cheatsheet \\\n-\tcomplement-lang-faq complement-project-faq rust rustdoc\n+\tcomplement-lang-faq complement-project-faq rust rustdoc \\\n+\tguide-unsafe\n \n PDF_DOCS := tutorial rust\n "}, {"sha": "f043d95b4735083e7ab7457c1a17c1556c6f598f", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=1218f6db770f75b262b2feb84cffdc13e8461503", "patch": "@@ -170,85 +170,6 @@ Foreign libraries often hand off ownership of resources to the calling code.\n When this occurs, we must use Rust's destructors to provide safety and guarantee\n the release of these resources (especially in the case of failure).\n \n-As an example, we give a reimplementation of owned boxes by wrapping `malloc`\n-and `free`:\n-\n-~~~~\n-use std::cast;\n-use std::libc::{c_void, size_t, malloc, free};\n-use std::mem;\n-use std::ptr;\n-\n-// Define a wrapper around the handle returned by the foreign code.\n-// Unique<T> has the same semantics as ~T\n-pub struct Unique<T> {\n-    // It contains a single raw, mutable pointer to the object in question.\n-    priv ptr: *mut T\n-}\n-\n-// Implement methods for creating and using the values in the box.\n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction, and can contain managed (GC) boxes).\n-// This is because, as implemented, the garbage collector would not know\n-// about any shared boxes stored in the malloc'd region of memory.\n-impl<T: Send> Unique<T> {\n-    pub fn new(value: T) -> Unique<T> {\n-        unsafe {\n-            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n-            assert!(!ptr.is_null());\n-            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n-            // move_val_init moves a value into this memory without\n-            // attempting to drop the original value.\n-            mem::move_val_init(&mut *ptr, value);\n-            Unique{ptr: ptr}\n-        }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&*x` with ~T\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        unsafe { cast::copy_lifetime(self, &*self.ptr) }\n-    }\n-\n-    // the 'r lifetime results in the same semantics as `&mut *x` with ~T\n-    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n-        unsafe { cast::copy_mut_lifetime(self, &mut *self.ptr) }\n-    }\n-}\n-\n-// The key ingredient for safety, we associate a destructor with\n-// Unique<T>, making the struct manage the raw pointer: when the\n-// struct goes out of scope, it will automatically free the raw pointer.\n-// NB: This is an unsafe destructor, because rustc will not normally\n-// allow destructors to be associated with parametrized types, due to\n-// bad interaction with managed boxes. (With the Send restriction,\n-// we don't have this problem.)\n-#[unsafe_destructor]\n-impl<T: Send> Drop for Unique<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let x = mem::uninit(); // dummy value to swap in\n-            // We need to move the object out of the box, so that\n-            // the destructor is called (at the end of this scope.)\n-            ptr::replace(self.ptr, x);\n-            free(self.ptr as *mut c_void)\n-        }\n-    }\n-}\n-\n-// A comparison between the built-in ~ and this reimplementation\n-fn main() {\n-    {\n-        let mut x = ~5;\n-        *x = 10;\n-    } // `x` is freed here\n-\n-    {\n-        let mut y = Unique::new(5);\n-        *y.borrow_mut() = 10;\n-    } // `y` is freed here\n-}\n-~~~~\n-\n # Callbacks from C code to Rust functions\n \n Some external libraries require the usage of callbacks to report back their"}, {"sha": "b085fe21fac4b80d2fa10a97462049b698f513c5", "filename": "src/doc/guide-unsafe.md", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=1218f6db770f75b262b2feb84cffdc13e8461503", "patch": "@@ -0,0 +1,606 @@\n+% Writing Safe Unsafe and Low-Level Code\n+\n+# Introduction\n+\n+Rust aims to provide safe abstractions over the low-level details of\n+the CPU and operating system, but sometimes one is forced to drop down\n+and write code at that level (those abstractions have to be created\n+somehow). This guide aims to provide an overview of the dangers and\n+power one gets with Rust's unsafe subset.\n+\n+Rust provides an escape hatch in the form of the `unsafe { ... }`\n+block which allows the programmer to dodge some of the compilers\n+checks and do a wide range of operations, such as:\n+\n+- dereferencing [raw pointers](#raw-pointers)\n+- calling a function via FFI ([covered by the FFI guide](guide-ffi.html))\n+- casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n+- [inline assembly](#inline-assembly)\n+\n+Note that an `unsafe` block does not relax the rules about lifetimes\n+of `&` and the freezing of borrowed data, it just allows the use of\n+additional techniques for skirting the compiler's watchful eye. Any\n+use of `unsafe` is the programmer saying \"I know more than you\" to the\n+compiler, and, as such, the programmer should be very sure that they\n+actually do know more about why that piece of code is valid.\n+\n+In general, one should try to minimize the amount of unsafe code in a\n+code base; preferably by using the bare minimum `unsafe` blocks to\n+build safe interfaces.\n+\n+> **Note**: the low-level details of the Rust language are still in\n+> flux, and there is no guarantee of stability or backwards\n+> compatibility. In particular, there may be changes that do not cause\n+> compilation errors, but do cause semantic changes (such as invoking\n+> undefined behaviour). As such, extreme care is required.\n+\n+# Pointers\n+\n+## References\n+\n+One of Rust's biggest goals as a language is ensuring memory safety,\n+achieved in part via [the lifetime system](guide-lifetimes.html) which\n+every `&` references has associated with it. This system is how the\n+compiler can guarantee that every `&` reference is always valid, and,\n+for example, never pointing to freed memory.\n+\n+These restrictions on `&` have huge advantages. However, there's no\n+free lunch club. For example, `&` isn't a valid replacement for C's\n+pointers, and so cannot be used for FFI, in general. Additionally,\n+both immutable (`&`) and mutable (`&mut`) references have some\n+aliasing and freezing guarantees, required for memory safety.\n+\n+In particular, if you have an `&T` reference, then the `T` must not be\n+modified through that reference or any other reference. There are some\n+standard library types, e.g. `Cell` and `RefCell`, that provide inner\n+mutability by replacing compile time guarantees with dynamic checks at\n+runtime.\n+\n+An `&mut` reference has a stronger requirement: when a object has an\n+`&mut T` pointing into it, then that `&mut` reference must be the only\n+such usable path to that object in the whole program. That is, an\n+`&mut` cannot alias with any other references.\n+\n+Using `unsafe` code to incorrectly circumvent and violate these\n+restrictions is undefined behaviour. For example, the following\n+creates two aliasing `&mut` pointers, and is invalid.\n+\n+```\n+use std::cast;\n+let mut x: u8 = 1;\n+\n+let ref_1: &mut u8 = &mut x;\n+let ref_2: &mut u8 = unsafe { cast::transmute_mut_region(ref_1) };\n+\n+// oops, ref_1 and ref_2 point to the same piece of data (x) and are\n+// both usable\n+*ref_1 = 10;\n+*ref_2 = 20;\n+```\n+\n+## Raw pointers\n+\n+Rust offers two additional pointer types \"raw pointers\", written as\n+`*T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n+respectively; indeed, one of their most common uses is for FFI,\n+interfacing with external C libraries.\n+\n+Raw pointers have much fewer guarantees than other pointer types\n+offered by the Rust language and libraries. For example, they\n+\n+- are not guaranteed to point to valid memory and are not even\n+  guaranteed to be non-null (unlike both `~` and `&`);\n+- do not have any automatic clean-up, unlike `~`, and so require\n+  manual resource management;\n+- are plain-old-data, that is, they don't move ownership, again unlike\n+  `~`, hence the Rust compiler cannot protect against bugs like\n+  use-after-free;\n+- are considered sendable (if their contents is considered sendable),\n+  so the compiler offers no assistance with ensuring their use is\n+  thread-safe; for example, one can concurrently access a `*mut int`\n+  from two threads without synchronization.\n+- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n+  reason about dangling pointers; and\n+- have no guarantees about aliasing or mutability other than mutation\n+  not being allowed directly through a `*T`.\n+\n+Fortunately, they come with a redeeming feature: the weaker guarantees\n+mean weaker restrictions. The missing restrictions make raw pointers\n+appropriate as a building block for (carefully!) implementing things\n+like smart pointers and vectors inside libraries. For example, `*`\n+pointers are allowed to alias, allowing them to be used to write\n+shared-ownership types like reference counted and garbage collected\n+pointers, and even thread-safe shared memory types (`Rc` and the `Arc`\n+types are both implemented entirely in Rust).\n+\n+There are two things that you are required to be careful about\n+(i.e. require an `unsafe { ... }` block) with raw pointers:\n+\n+- dereferencing: they can have any value: so possible results include\n+  a crash, a read of uninitialised memory, a use-after-free, or\n+  reading data as normal (and one hopes happens).\n+- pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or\n+  `.offset` method): this intrinsic uses so-called \"in-bounds\"\n+  arithmetic, that is, it is only defined behaviour if the result is\n+  inside (or one-byte-past-the-end) of the object from which the\n+  original pointer came.\n+\n+The latter assumption allows the compiler to optimize more\n+effectively. As can be seen, actually *creating* a raw pointer is not\n+unsafe, and neither is converting to an integer.\n+\n+### References and raw pointers\n+\n+At runtime, a raw pointer `*` and a reference pointing to the same\n+piece of data have an identical representation. In fact, an `&T`\n+reference will implicitly coerce to an `*T` raw pointer in safe code\n+and similarly for the `mut` variants (both coercions can be performed\n+explicitly with, respectively, `value as *T` and `value as *mut T`).\n+\n+Going the opposite direction, from `*` to a reference `&`, is not\n+safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n+`*T` has to be a valid to a valid instance of type `T`. Furthermore,\n+the resulting pointer must satisfy the aliasing and mutability laws of\n+references. The compiler assumes these properties are true for any\n+references, no matter how they are created, and so any conversion from\n+raw pointers is asserting that they hold. The programmer *must*\n+guarantee this.\n+\n+The recommended method for the conversion is\n+\n+```\n+let i: u32 = 1;\n+// explicit cast\n+let p_imm: *u32 = &i as *u32;\n+let mut m: u32 = 2;\n+// implicit coercion\n+let p_mut: *mut u32 = &mut m;\n+\n+unsafe {\n+    let ref_imm: &u32 = &*p_imm;\n+    let ref_mut: &mut u32 = &mut *p_mut;\n+}\n+```\n+\n+The `&*x` dereferencing style is preferred to using a `transmute`.\n+The latter is far more powerful than necessary, and the more\n+restricted operation is harder to use incorrectly; for example, it\n+requires that `x` is a pointer (unlike `transmute`).\n+\n+\n+\n+## Making the unsafe safe(r)\n+\n+There are various ways to expose a safe interface around some unsafe\n+code:\n+\n+- store pointers privately (i.e. not in public fields of public\n+  structs), so that you can see and control all reads and writes to\n+  the pointer in one place.\n+- use `assert!()` a lot: once you've thrown away the protection of the\n+  compiler & type-system via `unsafe { ... }` you're left with just\n+  your wits and your `assert!()`s, any bug is potentially exploitable.\n+- implement the `Drop` for resource clean-up via a destructor, and use\n+  RAII (Resource Acquisition Is Initialization). This reduces the need\n+  for any manual memory management by users, and automatically ensures\n+  that clean-up is always run, even when the task fails.\n+- ensure that any data stored behind a raw pointer is destroyed at the\n+  appropriate time.\n+\n+As an example, we give a reimplementation of owned boxes by wrapping\n+`malloc` and `free`. Rust's move semantics and lifetimes mean this\n+reimplementation is as safe as the built-in `~` type.\n+\n+```\n+use std::libc::{c_void, size_t, malloc, free};\n+use std::mem;\n+use std::ptr;\n+\n+// Define a wrapper around the handle returned by the foreign code.\n+// Unique<T> has the same semantics as ~T\n+pub struct Unique<T> {\n+    // It contains a single raw, mutable pointer to the object in question.\n+    priv ptr: *mut T\n+}\n+\n+// Implement methods for creating and using the values in the box.\n+// NB: For simplicity and correctness, we require that T has kind Send\n+// (owned boxes relax this restriction, and can contain managed (GC) boxes).\n+// This is because, as implemented, the garbage collector would not know\n+// about any shared boxes stored in the malloc'd region of memory.\n+impl<T: Send> Unique<T> {\n+    pub fn new(value: T) -> Unique<T> {\n+        unsafe {\n+            let ptr = malloc(std::mem::size_of::<T>() as size_t) as *mut T;\n+            // we *need* valid pointer.\n+            assert!(!ptr.is_null());\n+            // `*ptr` is uninitialized, and `*ptr = value` would attempt to destroy it\n+            // move_val_init moves a value into this memory without\n+            // attempting to drop the original value.\n+            mem::move_val_init(&mut *ptr, value);\n+            Unique{ptr: ptr}\n+        }\n+    }\n+\n+    // the 'r lifetime results in the same semantics as `&*x` with ~T\n+    pub fn borrow<'r>(&'r self) -> &'r T {\n+        // By construction, self.ptr is valid\n+        unsafe { &*self.ptr }\n+    }\n+\n+    // the 'r lifetime results in the same semantics as `&mut *x` with ~T\n+    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {\n+        unsafe { &mut*self.ptr }\n+    }\n+}\n+\n+// A key ingredient for safety, we associate a destructor with\n+// Unique<T>, making the struct manage the raw pointer: when the\n+// struct goes out of scope, it will automatically free the raw pointer.\n+// NB: This is an unsafe destructor, because rustc will not normally\n+// allow destructors to be associated with parametrized types, due to\n+// bad interaction with managed boxes. (With the Send restriction,\n+// we don't have this problem.)\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Unique<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+\n+            // Copy the object out from the pointer onto the stack,\n+            // where it is covered by normal Rust destructor semantics\n+            // and cleans itself up, if necessary\n+            ptr::read(self.ptr as *T);\n+\n+            // clean-up our allocation\n+            free(self.ptr as *mut c_void)\n+        }\n+    }\n+}\n+\n+// A comparison between the built-in ~ and this reimplementation\n+fn main() {\n+    {\n+        let mut x = ~5;\n+        *x = 10;\n+    } // `x` is freed here\n+\n+    {\n+        let mut y = Unique::new(5);\n+        *y.borrow_mut() = 10;\n+    } // `y` is freed here\n+}\n+```\n+\n+Notably, the only way to construct a `Unique` is via the `new`\n+function, and this function ensures that the internal pointer is valid\n+and hidden in the private field. The two `borrow` methods are safe\n+because the compiler statically guarantees that objects are never used\n+before creation or after destruction (unless you use some `unsafe`\n+code...).\n+\n+# Inline assembly\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `asm!` macro. The syntax roughly matches\n+that of GCC & Clang:\n+\n+```ignore\n+asm!(assembly template\n+   : output operands\n+   : input operands\n+   : clobbers\n+   : options\n+   );\n+```\n+\n+Any use of `asm` is feature gated (requires `#[feature(asm)];` on the\n+crate to allow) and of course requires an `unsafe` block.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but all\n+> platforms are supported.\n+\n+## Assembly template\n+\n+The `assembly template` is the only required parameter and must be a\n+literal string (i.e `\"\"`)\n+\n+```\n+#[feature(asm)];\n+\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+fn foo() {\n+    unsafe {\n+        asm!(\"NOP\");\n+    }\n+}\n+\n+// other platforms\n+#[cfg(not(target_arch = \"x86\"),\n+      not(target_arch = \"x86_64\"))]\n+fn foo() { /* ... */ }\n+\n+fn main() {\n+    // ...\n+    foo();\n+    // ...\n+}\n+```\n+\n+(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n+\n+Output operands, input operands, clobbers and options are all optional\n+but you must add the right number of `:` if you skip them:\n+\n+```\n+# #[feature(asm)];\n+# #[cfg(target_arch = \"x86\")] #[cfg(target_arch = \"x86_64\")]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\"\n+    :\n+    :\n+    : \"eax\"\n+   );\n+# } }\n+```\n+\n+Whitespace also doesn't matter:\n+\n+```\n+# #[feature(asm)];\n+# #[cfg(target_arch = \"x86\")] #[cfg(target_arch = \"x86_64\")]\n+# fn main() { unsafe {\n+asm!(\"xor %eax, %eax\" ::: \"eax\");\n+# } }\n+```\n+\n+## Operands\n+\n+Input and output operands follow the same format: `:\n+\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n+expressions must be mutable lvalues:\n+\n+```\n+# #[feature(asm)];\n+# #[cfg(target_arch = \"x86\")] #[cfg(target_arch = \"x86_64\")]\n+fn add(a: int, b: int) -> int {\n+    let mut c = 0;\n+    unsafe {\n+        asm!(\"add $2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a), \"r\"(b)\n+             );\n+    }\n+    c\n+}\n+# #[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n+# fn add(a: int, b: int) -> int { a + b }\n+\n+fn main() {\n+    assert_eq!(add(3, 14159), 14162)\n+}\n+```\n+\n+## Clobbers\n+\n+Some instructions modify registers which might otherwise have held\n+different values so we use the clobbers list to indicate to the\n+compiler not to assume any values loaded into those registers will\n+stay valid.\n+\n+```\n+# #[feature(asm)];\n+# #[cfg(target_arch = \"x86\")] #[cfg(target_arch = \"x86_64\")]\n+# fn main() { unsafe {\n+// Put the value 0x200 in eax\n+asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+# } }\n+```\n+\n+Input and output registers need not be listed since that information\n+is already communicated by the given constraints. Otherwise, any other\n+registers used either implicitly or explicitly should be listed.\n+\n+If the assembly changes the condition code register `cc` should be\n+specified as one of the clobbers. Similarly, if the assembly modifies\n+memory, `memory` should also be specified.\n+\n+## Options\n+\n+The last section, `options` is specific to Rust. The format is comma\n+separated literal strings (i.e `:\"foo\", \"bar\", \"baz\"`). It's used to\n+specify some extra info about the inline assembly:\n+\n+Current valid options are:\n+\n+1. **volatile** - specifying this is analogous to `__asm__ __volatile__ (...)` in gcc/clang.\n+2. **alignstack** - certain instructions expect the stack to be\n+   aligned a certain way (i.e SSE) and specifying this indicates to\n+   the compiler to insert its usual stack alignment code\n+3. **intel** - use intel syntax instead of the default AT&T.\n+\n+# Avoiding the standard library\n+\n+By default, `std` is linked to every Rust crate. In some contexts,\n+this is undesirable, and can be avoided with the `#[no_std];`\n+attribute attached to the crate.\n+\n+```ignore\n+# // FIXME #12903: linking failures due to no_std\n+// the minimal library\n+#[crate_type=\"lib\"];\n+#[no_std];\n+\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+Obviously there's more to life than just libraries: one can use\n+`#[no_std]` with an executable, controlling the entry point is\n+possible in two ways: the `#[start]` attribute, or overriding the\n+default shim for the C `main` function with your own.\n+\n+The function marked `#[start]` is passed the command line parameters\n+in the same format as a C:\n+\n+```ignore\n+# // FIXME #12903: linking failures due to no_std\n+#[no_std];\n+\n+extern \"rust-intrinsic\" { fn abort() -> !; }\n+#[no_mangle] pub extern fn rust_stack_exhausted() {\n+    unsafe { abort() }\n+}\n+\n+#[start]\n+fn start(_argc: int, _argv: **u8) -> int {\n+    0\n+}\n+\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+To override the compiler-inserted `main` shim, one has to disable it\n+with `#[no_main];` and then create the appropriate symbol with the\n+correct ABI and the correct name, which requires overriding the\n+compiler's name mangling too:\n+\n+```ignore\n+# // FIXME #12903: linking failures due to no_std\n+#[no_std];\n+#[no_main];\n+\n+extern \"rust-intrinsic\" { fn abort() -> !; }\n+#[no_mangle] pub extern fn rust_stack_exhausted() {\n+    unsafe { abort() }\n+}\n+\n+#[no_mangle] // ensure that this symbol is called `main` in the output\n+extern \"C\" fn main(_argc: int, _argv: **u8) -> int {\n+    0\n+}\n+\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+\n+Unfortunately the Rust compiler assumes that symbols with certain\n+names exist; and these have to be defined (or linked in). This is the\n+purpose of the `rust_stack_exhausted`: it is called when a function\n+detects that it will overflow its stack. The example above uses the\n+`abort` intrinsic which ensures that execution halts.\n+\n+# Interacting with the compiler internals\n+\n+> **Note**: this section is specific to the `rustc` compiler; these\n+> parts of the language may never be full specified and so details may\n+> differ wildly between implementations (and even versions of `rustc`\n+> itself).\n+>\n+> Furthermore, this is just an overview; the best form of\n+> documentation for specific instances of these features are their\n+> definitions and uses in `std`.\n+\n+The Rust language currently has two orthogonal mechanisms for allowing\n+libraries to interact directly with the compiler and vice versa:\n+\n+- intrinsics, functions built directly into the compiler providing\n+  very basic low-level functionality,\n+- lang-items, special functions, types and traits in libraries marked\n+  with specific `#[lang]` attributes\n+\n+## Intrinsics\n+\n+These are imported as if they were FFI functions, with the special\n+`rust-intrinsic` ABI. For example, if one was in a freestanding\n+context, but wished to be able to `transmute` between types, and\n+perform efficient pointer arithmetic, one would import those functions\n+via a declaration like\n+\n+```\n+extern \"rust-intrinsic\" {\n+    fn transmute<T, U>(x: T) -> U;\n+\n+    fn offset<T>(dst: *T, offset: int) -> *T;\n+}\n+```\n+\n+As with any other FFI functions, these are always `unsafe` to call.\n+\n+## Lang items\n+\n+The `rustc` compiler has certain pluggable operations, that is,\n+functionality that isn't hard-coded into the language, but is\n+implemented in libraries, with a special marker to tell the compiler\n+it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n+various different values of `...`, i.e. various different \"lang\n+items\".\n+\n+For example, `~` pointers require two lang items, one for allocation\n+and one for deallocation. A freestanding program that uses the `~`\n+sugar for dynamic allocations via `malloc` and `free`:\n+\n+```ignore\n+# // FIXME #12903: linking failures due to no_std\n+#[no_std];\n+\n+#[allow(ctypes)] // `uint` == `size_t` on Rust's platforms\n+extern {\n+    fn malloc(size: uint) -> *mut u8;\n+    fn free(ptr: *mut u8);\n+\n+    fn abort() -> !;\n+}\n+\n+#[no_mangle] pub extern fn rust_stack_exhausted() {\n+    unsafe { abort() }\n+}\n+\n+#[lang=\"exchange_malloc\"]\n+unsafe fn allocate(size: uint) -> *mut u8 {\n+    let p = malloc(size);\n+\n+    // malloc failed\n+    if p as uint == 0 {\n+        abort();\n+    }\n+\n+    p\n+}\n+#[lang=\"exchange_free\"]\n+unsafe fn deallocate(ptr: *mut u8) {\n+    free(ptr)\n+}\n+\n+#[start]\n+fn main(_argc: int, _argv: **u8) -> int {\n+    let _x = ~1;\n+\n+    0\n+}\n+\n+# // fn main() {} tricked you, rustdoc!\n+```\n+\n+Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n+return a valid pointer, and so needs to do the check\n+internally.\n+\n+Other features provided by lang items include:\n+\n+- overloadable operators via traits: the traits corresponding to the\n+  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n+  marked with lang items; those specific four are `eq`, `ord`,\n+  `deref`, and `add` respectively.\n+- stack unwinding and general failure; the `eh_personality`, `fail_`\n+  and `fail_bounds_checks` lang items.\n+- the traits in `std::kinds` used to indicate types that satisfy\n+  various kinds; lang items `send`, `freeze` and `pod`.\n+- the marker types and variance indicators found in\n+  `std::kinds::markers`; lang items `covariant_type`,\n+  `contravariant_lifetime`, `no_freeze_bound`, etc.\n+\n+Lang items are loaded lazily by the compiler; e.g. if one never uses\n+`~` then there is no need to define functions for `exchange_malloc`\n+and `exchange_free`. `rustc` will emit an error when an item is needed\n+but not found in the current crate or any that it depends on."}, {"sha": "4f0aeec8eb900a143c7fd74b28f5be68537bc3af", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/1218f6db770f75b262b2feb84cffdc13e8461503/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=1218f6db770f75b262b2feb84cffdc13e8461503", "patch": "@@ -17,6 +17,7 @@ li {list-style-type: none; }\n * [Containers and Iterators](guide-container.html)\n * [Tasks and Communication](guide-tasks.html)\n * [Foreign Function Interface](guide-ffi.html)\n+* [Writing Safe Unsafe and Low-Level Code](guide-unsafe.html)\n * [Macros](guide-macros.html)\n * [Testing](guide-testing.html)\n * [Rust's Runtime](guide-runtime.html)"}]}