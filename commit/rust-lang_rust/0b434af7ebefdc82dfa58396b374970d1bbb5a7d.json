{"sha": "0b434af7ebefdc82dfa58396b374970d1bbb5a7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNDM0YWY3ZWJlZmRjODJkZmE1ODM5NmIzNzQ5NzBkMWJiYjVhN2Q=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-10-04T00:52:04Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-10-04T02:25:21Z"}, "message": "A run through the tutorial, small changes", "tree": {"sha": "11565dd8b4a3002e1835bfa5d5f57c7e7733b6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11565dd8b4a3002e1835bfa5d5f57c7e7733b6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b434af7ebefdc82dfa58396b374970d1bbb5a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b434af7ebefdc82dfa58396b374970d1bbb5a7d", "html_url": "https://github.com/rust-lang/rust/commit/0b434af7ebefdc82dfa58396b374970d1bbb5a7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b434af7ebefdc82dfa58396b374970d1bbb5a7d/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a", "html_url": "https://github.com/rust-lang/rust/commit/3ccf6f5932d8223fd6c5cbf7c6ac429ca9e8912a"}], "stats": {"total": 100, "additions": 58, "deletions": 42}, "files": [{"sha": "a9a86262d972f2eb9826c772992a31bffd45e5c4", "filename": "doc/tutorial.md", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0b434af7ebefdc82dfa58396b374970d1bbb5a7d/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b434af7ebefdc82dfa58396b374970d1bbb5a7d/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0b434af7ebefdc82dfa58396b374970d1bbb5a7d", "patch": "@@ -152,9 +152,9 @@ example, by changing `io::println` to some nonexistent function), and\n then compile it, you'll see an error message like this:\n \n ~~~~ {.notrust}\n-hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n-hello.rs:2     io::print_it(\"hello? yes, this is rust\");\n-               ^~~~~~~~~~~~\n+hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns\n+hello.rs:2     io::print_with_unicorns(\"hello? yes, this is rust\");\n+               ^~~~~~~~~~~~~~~~~~~~~~~\n ~~~~\n \n In its simplest form, a Rust program is a `.rs` file with some types\n@@ -178,9 +178,11 @@ included in that directory. In particular, if you are running emacs\n 24, then using emacs's internal package manager to install `rust-mode`\n is the easiest way to keep it up to date. There is also a package for\n Sublime Text 2, available both [standalone][sublime] and through\n-[Sublime Package Control][sublime-pkg].\n+[Sublime Package Control][sublime-pkg], and support for Kate\n+under `src/etc/kate`.\n \n-Other editors are not provided for yet. If you end up writing a Rust\n+There is ctags support via `src/etc/ctags.rust`, but many other\n+tools and editors are not provided for yet. If you end up writing a Rust\n mode for your favorite editor, let us know so that we can link to it.\n \n [sublime]: http://github.com/dbp/sublime-rust\n@@ -191,7 +193,7 @@ mode for your favorite editor, let us know so that we can link to it.\n Assuming you've programmed in any C-family language (C++, Java,\n JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged\n in blocks delineated by curly braces; there are control structures\n-for branching and looping, like the familiar `if` and `when`; function\n+for branching and looping, like the familiar `if` and `while`; function\n calls are written `myfunc(arg1, arg2)`; operators are written the same\n and mostly have the same precedence as in C; comments are again like C.\n \n@@ -227,13 +229,14 @@ while count < 10 {\n }\n ~~~~\n \n-Although Rust can almost always infer the types of local variables, it\n-can help readability to specify a variable's type by following it with\n-a colon, then the type name. \n+Although Rust can almost always infer the types of local variables, you\n+can specify a variable's type by following it with a colon, then the type\n+name. \n \n ~~~~\n-let my_favorite_value: float = 57.8;\n-let my_favorite_value: int = my_favorite_value as int;\n+let monster_size: float = 57.8;\n+let imaginary_size = monster_size * 10;\n+let monster_size: int = 50;\n ~~~~\n \n Local variables may shadow earlier declarations, as in the previous\n@@ -248,14 +251,14 @@ underscores where they help readability, while writing types in camel case.\n \n ~~~\n let my_variable = 100;\n-type MyType = int; // built-in types though are _not_ camel case\n+type MyType = int;     // some built-in types are _not_ camel case\n ~~~\n \n ## Expression syntax\n \n Though it isn't apparent in all code, there is a fundamental\n-difference between Rust's syntax and its predecessors in this family\n-of languages. Many constructs that are statements in C are expressions\n+difference between Rust's syntax and predecessors like C.\n+Many constructs that are statements in C are expressions\n in Rust, allowing code to be more concise. For example, you might\n write a piece of code like this:\n \n@@ -275,24 +278,25 @@ But, in Rust, you don't have to repeat the name `price`:\n \n ~~~~\n # let item = \"salad\";\n-let price = if item == \"salad\" {\n-    3.50\n-} else if item == \"muffin\" {\n-    2.25\n-} else {\n-    2.00\n-};\n+let price =\n+    if item == \"salad\" {\n+        3.50\n+    } else if item == \"muffin\" {\n+        2.25\n+    } else {\n+        2.00\n+    };\n ~~~~\n \n Both pieces of code are exactly equivalent\u2014they assign a value to\n-`price` depending on the condition that holds. Note that the\n-semicolons are omitted from the blocks in the second snippet. This is\n+`price` depending on the condition that holds. Note that there\n+are not semicolons in the blocks of the second snippet. This is\n important; the lack of a semicolon after the last statement in a\n braced block gives the whole block the value of that last expression.\n \n Put another way, the semicolon in Rust *ignores the value of an expression*.\n Thus, if the branches of the `if` had looked like `{ 4; }`, the above example\n-would simply assign nil (void) to `price`. But without the semicolon, each\n+would simply assign `()` (nil or void) to `price`. But without the semicolon, each\n branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n@@ -346,8 +350,7 @@ if x {\n let y = if x { foo() } else { bar() };\n ~~~\n \n-This may sound a bit intricate, but it is super-useful, and it will\n-grow on you (hopefully).\n+This may sound a intricate, but it is super-useful and will grow on you.\n \n ## Types\n \n@@ -365,7 +368,8 @@ The basic types include the usual boolean, integral, and floating point types.\n ------------------------- -----------------------------------------------\n \n These can be combined in composite types, which will be described in\n-more detail later on (the `T`s here stand for any other type):\n+more detail later on (the `T`s here stand for any other type,\n+while N should be a literal number):\n \n ------------------------- -----------------------------------------------\n `[T * N]`                 Vector (like an array in other languages) with N elements\n@@ -392,7 +396,7 @@ the type `fn() -> bool` or the function declaration `fn foo() -> bool\n optionally write `-> ()`, but usually the return annotation is simply\n left off, as in `fn main() { ... }`.\n \n-Types can be given names with `type` declarations:\n+Types can be given names or aliases with `type` declarations:\n \n ~~~~\n type MonsterSize = uint;\n@@ -401,9 +405,25 @@ type MonsterSize = uint;\n This will provide a synonym, `MonsterSize`, for unsigned integers. It will not\n actually create a new, incompatible type\u2014`MonsterSize` and `uint` can be used\n interchangeably, and using one where the other is expected is not a type\n-error. Read about [single-variant enums](#single_variant_enum)\n-further on if you need to create a type name that's not just a\n-synonym.\n+error.\n+\n+To create data types which are not synonyms, `struct` and `enum`\n+can be used. They're described in more detail below, but they look like this:\n+\n+~~~~\n+enum HidingPlaces {\n+   Closet(uint),\n+   UnderTheBed(uint)\n+}\n+\n+struct HeroicBabysitter {\n+   bedtime_stories: uint,\n+   sharpened_stakes: uint\n+}\n+\n+struct BabysitterSize(uint);  // a single-variant struct\n+enum MonsterSize = uint;      // a single-variant enum\n+~~~~\n \n ## Literals\n \n@@ -435,7 +455,7 @@ The nil literal is written just like the type: `()`. The keywords\n \n Character literals are written between single quotes, as in `'x'`. Just as in\n C, Rust understands a number of character escapes, using the backslash\n-character, `\\n`, `\\r`, and `\\t` being the most common. String literals,\n+character, such as `\\n`, `\\r`, and `\\t`. String literals,\n written between double quotes, allow the same escape sequences. Rust strings\n may contain newlines.\n \n@@ -466,8 +486,8 @@ assert y == 4u;\n \n The main difference with C is that `++` and `--` are missing, and that\n the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n-comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n-more likely to be what you expect (unless you are a C veteran).\n+means `x & (2 > 0)`, but in Rust, it means `(x & 2) > 0`, which is\n+more likely what a novice expects.\n \n ## Syntax extensions\n \n@@ -485,7 +505,7 @@ don't match the types of the arguments.\n ~~~~\n # let mystery_object = ();\n \n-io::println(fmt!(\"%s is %d\", \"the answer\", 43));\n+io::println(fmt!(\"%s is %d\", \"the answer\", 42));\n \n // %? will conveniently print any type\n io::println(fmt!(\"what is this thing: %?\", mystery_object));\n@@ -556,18 +576,14 @@ underscore (`_`) is a wildcard pattern that matches everything.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n-convenient to use a block expression for a case, in which case the\n+convenient to use a block expression for each case, in which case the\n commas are optional.\n \n ~~~\n # let my_number = 1;\n match my_number {\n-  0 => {\n-    io::println(\"zero\")\n-  }\n-  _ => {\n-    io::println(\"something else\")\n-  }\n+  0 => { io::println(\"zero\") }\n+  _ => { io::println(\"something else\") }\n }\n ~~~\n "}]}