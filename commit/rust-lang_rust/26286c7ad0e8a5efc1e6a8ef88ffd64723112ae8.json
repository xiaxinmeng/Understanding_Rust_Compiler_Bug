{"sha": "26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2Mjg2YzdhZDBlOGE1ZWZjMWU2YThlZjg4ZmZkNjQ3MjMxMTJhZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-22T10:30:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-22T10:30:51Z"}, "message": "Auto merge of #66931 - cjgillot:hirene-preamble, r=eddyb\n\nAllocate HIR on an arena 1/4\n\nThis PR is the first in a series of 4, aiming at allocating the HIR on an arena, as a memory optimisation.\n\n1. This first PR lays the groundwork and migrates some low-hanging fruits.\n2. The second PR will migrate `hir::Expr`, `hir::Pat` and related.\n3. The third PR will migrate `hir::Ty` and related.\n4. The final PR will be dedicated to eventual cleanups.\n\nIn order to make the transition as gradual as possible, some lowering routines receive `Box`-allocated data and move it into the arena. This is a bit wasteful, but hopefully temporary.\nNonetheless, special care should be taken to avoid double arena allocations.\n\nWork mentored by @Zoxc.", "tree": {"sha": "668b015ec0e7bca6659317aeab23ce2fe5f7e2c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/668b015ec0e7bca6659317aeab23ce2fe5f7e2c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "html_url": "https://github.com/rust-lang/rust/commit/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3982d3514efbb65b3efac6bb006b3fa496d16663", "url": "https://api.github.com/repos/rust-lang/rust/commits/3982d3514efbb65b3efac6bb006b3fa496d16663", "html_url": "https://github.com/rust-lang/rust/commit/3982d3514efbb65b3efac6bb006b3fa496d16663"}, {"sha": "baa49b2343b852d4bd4151f7c42e36a3351d0981", "url": "https://api.github.com/repos/rust-lang/rust/commits/baa49b2343b852d4bd4151f7c42e36a3351d0981", "html_url": "https://github.com/rust-lang/rust/commit/baa49b2343b852d4bd4151f7c42e36a3351d0981"}], "stats": {"total": 1637, "additions": 856, "deletions": 781}, "files": [{"sha": "3695607ff3c60fd0a86487b78202edc3e52f37e8", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -93,7 +93,6 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n-            [few] hir_forest: rustc::hir::map::Forest,\n             [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n                 syntax::symbol::Symbol,\n                 rustc::hir::def_id::DefId,\n@@ -123,6 +122,21 @@ macro_rules! arena_types {\n             [few] crate_variances: rustc::ty::CrateVariancesMap<'tcx>,\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n             [] upvars: rustc_data_structures::fx::FxIndexMap<rustc::hir::HirId, rustc::hir::Upvar>,\n+\n+            // HIR types\n+            [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [] attribute: syntax::ast::Attribute,\n+            [few] global_asm: rustc::hir::GlobalAsm,\n+            [] fn_decl: rustc::hir::FnDecl,\n+            [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n+            [] impl_item_ref: rustc::hir::ImplItemRef,\n+            [few] macro_def: rustc::hir::MacroDef<$tcx>,\n+            [] param: rustc::hir::Param,\n+            [] path: rustc::hir::Path,\n+            [] struct_field: rustc::hir::StructField<$tcx>,\n+            [] trait_item_ref: rustc::hir::TraitItemRef,\n+            [] ty: rustc::hir::Ty,\n+            [] variant: rustc::hir::Variant<$tcx>,\n         ], $tcx);\n     )\n }"}, {"sha": "9e95cba7fcbfcbe0195ab8a174ee24f321ce770e", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -4,7 +4,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::hir::{self, HirId, HirVec, Attribute, Item, ItemKind, TraitItem, TraitItemKind};\n+use crate::hir::{self, HirId, Attribute, Item, ItemKind, TraitItem, TraitItemKind};\n use crate::hir::DUMMY_HIR_ID;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -86,7 +86,7 @@ impl Display for Target {\n }\n \n impl Target {\n-    pub(crate) fn from_item(item: &Item) -> Target {\n+    pub(crate) fn from_item(item: &Item<'_>) -> Target {\n         match item.kind {\n             ItemKind::ExternCrate(..) => Target::ExternCrate,\n             ItemKind::Use(..) => Target::Use,\n@@ -107,7 +107,7 @@ impl Target {\n         }\n     }\n \n-    fn from_trait_item(trait_item: &TraitItem) -> Target {\n+    fn from_trait_item(trait_item: &TraitItem<'_>) -> Target {\n         match trait_item.kind {\n             TraitItemKind::Const(..) => Target::AssocConst,\n             TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -120,15 +120,15 @@ impl Target {\n         }\n     }\n \n-    fn from_foreign_item(foreign_item: &hir::ForeignItem) -> Target {\n+    fn from_foreign_item(foreign_item: &hir::ForeignItem<'_>) -> Target {\n         match foreign_item.kind {\n             hir::ForeignItemKind::Fn(..) => Target::ForeignFn,\n             hir::ForeignItemKind::Static(..) => Target::ForeignStatic,\n             hir::ForeignItemKind::Type => Target::ForeignTy,\n         }\n     }\n \n-    fn from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem) -> Target {\n+    fn from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>) -> Target {\n         match impl_item.kind {\n             hir::ImplItemKind::Const(..) => Target::AssocConst,\n             hir::ImplItemKind::Method(..) => {\n@@ -158,10 +158,10 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_attributes(\n         &self,\n         hir_id: HirId,\n-        attrs: &HirVec<Attribute>,\n+        attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n-        item: Option<&Item>,\n+        item: Option<&Item<'_>>,\n     ) {\n         let mut is_valid = true;\n         for attr in attrs {\n@@ -241,7 +241,7 @@ impl CheckAttrVisitor<'tcx> {\n     fn check_track_caller(\n         &self,\n         attr_span: &Span,\n-        attrs: &HirVec<Attribute>,\n+        attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n     ) -> bool {\n@@ -332,10 +332,10 @@ impl CheckAttrVisitor<'tcx> {\n     /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(\n         &self,\n-        attrs: &HirVec<Attribute>,\n+        attrs: &'hir [Attribute],\n         span: &Span,\n         target: Target,\n-        item: Option<&Item>,\n+        item: Option<&Item<'_>>,\n     ) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```\n@@ -477,7 +477,7 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn check_used(&self, attrs: &HirVec<Attribute>, target: Target) {\n+    fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n         for attr in attrs {\n             if attr.check_name(sym::used) && target != Target::Static {\n                 self.tcx.sess\n@@ -492,25 +492,25 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx Item) {\n+    fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let target = Target::from_item(item);\n-        self.check_attributes(item.hir_id, &item.attrs, &item.span, target, Some(item));\n+        self.check_attributes(item.hir_id, item.attrs, &item.span, target, Some(item));\n         intravisit::walk_item(self, item)\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n         let target = Target::from_trait_item(trait_item);\n         self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n-    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem<'tcx>) {\n         let target = Target::from_foreign_item(f_item);\n         self.check_attributes(f_item.hir_id, &f_item.attrs, &f_item.span, target, None);\n         intravisit::walk_foreign_item(self, f_item)\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let target = Target::from_impl_item(self.tcx, impl_item);\n         self.check_attributes(impl_item.hir_id, &impl_item.attrs, &impl_item.span, target, None);\n         intravisit::walk_impl_item(self, impl_item)\n@@ -527,9 +527,9 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     }\n }\n \n-fn is_c_like_enum(item: &Item) -> bool {\n+fn is_c_like_enum(item: &Item<'_>) -> bool {\n     if let ItemKind::Enum(ref def, _) = item.kind {\n-        for variant in &def.variants {\n+        for variant in def.variants {\n             match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n                 _ => return false,"}, {"sha": "d4e89c5f047d2887845e937ac9314cc88b500354", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -340,7 +340,7 @@ impl CtorKind {\n         }\n     }\n \n-    pub fn from_hir(vdata: &hir::VariantData) -> CtorKind {\n+    pub fn from_hir(vdata: &hir::VariantData<'_>) -> CtorKind {\n         match *vdata {\n             hir::VariantData::Tuple(..) => CtorKind::Fn,\n             hir::VariantData::Unit(..) => CtorKind::Const,"}, {"sha": "26e287037f72cdd84bfc5ce73bf8f7ff163ad864", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -218,11 +218,11 @@ pub trait Visitor<'v>: Sized {\n \n     /// Visits the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n-    fn visit_item(&mut self, i: &'v Item) {\n+    fn visit_item(&mut self, i: &'v Item<'v>) {\n         walk_item(self, i)\n     }\n \n-    fn visit_body(&mut self, b: &'v Body) {\n+    fn visit_body(&mut self, b: &'v Body<'v>) {\n         walk_body(self, b);\n     }\n \n@@ -247,10 +247,10 @@ pub trait Visitor<'v>: Sized {\n     fn visit_ident(&mut self, ident: Ident) {\n         walk_ident(self, ident)\n     }\n-    fn visit_mod(&mut self, m: &'v Mod, _s: Span, n: HirId) {\n+    fn visit_mod(&mut self, m: &'v Mod<'v>, _s: Span, n: HirId) {\n         walk_mod(self, m, n)\n     }\n-    fn visit_foreign_item(&mut self, i: &'v ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'v ForeignItem<'v>) {\n         walk_foreign_item(self, i)\n     }\n     fn visit_local(&mut self, l: &'v Local) {\n@@ -295,13 +295,13 @@ pub trait Visitor<'v>: Sized {\n     fn visit_use(&mut self, path: &'v Path, hir_id: HirId) {\n         walk_use(self, path, hir_id)\n     }\n-    fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'v TraitItem<'v>) {\n         walk_trait_item(self, ti)\n     }\n     fn visit_trait_item_ref(&mut self, ii: &'v TraitItemRef) {\n         walk_trait_item_ref(self, ii)\n     }\n-    fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v ImplItem<'v>) {\n         walk_impl_item(self, ii)\n     }\n     fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n@@ -317,24 +317,24 @@ pub trait Visitor<'v>: Sized {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(&mut self,\n-                          s: &'v VariantData,\n+                          s: &'v VariantData<'v>,\n                           _: Name,\n                           _: &'v Generics,\n                           _parent_id: HirId,\n                           _: Span) {\n         walk_struct_def(self, s)\n     }\n-    fn visit_struct_field(&mut self, s: &'v StructField) {\n+    fn visit_struct_field(&mut self, s: &'v StructField<'v>) {\n         walk_struct_field(self, s)\n     }\n     fn visit_enum_def(&mut self,\n-                      enum_definition: &'v EnumDef,\n+                      enum_definition: &'v EnumDef<'v>,\n                       generics: &'v Generics,\n                       item_id: HirId,\n                       _: Span) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant, g: &'v Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'v Variant<'v>, g: &'v Generics, item_id: HirId) {\n         walk_variant(self, v, g, item_id)\n     }\n     fn visit_label(&mut self, label: &'v Label) {\n@@ -367,7 +367,7 @@ pub trait Visitor<'v>: Sized {\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {\n     }\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n         walk_macro_def(self, macro_def)\n     }\n     fn visit_vis(&mut self, vis: &'v Visibility) {\n@@ -382,27 +382,27 @@ pub trait Visitor<'v>: Sized {\n }\n \n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n-pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n+pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_HIR_ID);\n-    walk_list!(visitor, visit_attribute, &krate.attrs);\n-    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n+    walk_list!(visitor, visit_attribute, krate.attrs);\n+    walk_list!(visitor, visit_macro_def, krate.exported_macros);\n }\n \n-pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n+pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef<'v>) {\n     visitor.visit_id(macro_def.hir_id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n-    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n+    walk_list!(visitor, visit_attribute, macro_def.attrs);\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id: HirId) {\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n     visitor.visit_id(mod_hir_id);\n-    for &item_id in &module.item_ids {\n+    for &item_id in module.item_ids {\n         visitor.visit_nested_item(item_id);\n     }\n }\n \n-pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    walk_list!(visitor, visit_param, &body.params);\n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n+    walk_list!(visitor, visit_param, body.params);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -462,7 +462,7 @@ pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n     walk_list!(visitor, visit_attribute, &param.attrs);\n }\n \n-pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n+pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n     match item.kind {\n@@ -498,7 +498,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemKind::ForeignMod(ref foreign_module) => {\n             visitor.visit_id(item.hir_id);\n-            walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n+            walk_list!(visitor, visit_foreign_item, foreign_module.items);\n         }\n         ItemKind::GlobalAsm(_) => {\n             visitor.visit_id(item.hir_id);\n@@ -527,7 +527,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             ref generics,\n             ref opt_trait_reference,\n             ref typ,\n-            ref impl_item_refs\n+            impl_item_refs\n         ) => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n@@ -542,7 +542,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_variant_data(struct_definition, item.ident.name, generics, item.hir_id,\n                                        item.span);\n         }\n-        ItemKind::Trait(.., ref generics, ref bounds, ref trait_item_refs) => {\n+        ItemKind::Trait(.., ref generics, ref bounds, trait_item_refs) => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n@@ -554,7 +554,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n-    walk_list!(visitor, visit_attribute, &item.attrs);\n+    walk_list!(visitor, visit_attribute, item.attrs);\n }\n \n pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -565,19 +565,19 @@ pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                         enum_definition: &'v EnumDef,\n+                                         enum_definition: &'v EnumDef<'v>,\n                                          generics: &'v Generics,\n                                          item_id: HirId) {\n     visitor.visit_id(item_id);\n     walk_list!(visitor,\n                visit_variant,\n-               &enum_definition.variants,\n+               enum_definition.variants,\n                generics,\n                item_id);\n }\n \n pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                        variant: &'v Variant,\n+                                        variant: &'v Variant<'v>,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n     visitor.visit_ident(variant.ident);\n@@ -588,7 +588,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                parent_item_id,\n                                variant.span);\n     walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.attrs);\n+    walk_list!(visitor, visit_attribute, variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n@@ -735,13 +735,13 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     }\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem) {\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n     visitor.visit_id(foreign_item.hir_id);\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n     match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, ref param_names, ref generics) => {\n+        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n             for &param_name in param_names {\n@@ -752,7 +752,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n         ForeignItemKind::Type => (),\n     }\n \n-    walk_list!(visitor, visit_attribute, &foreign_item.attrs);\n+    walk_list!(visitor, visit_attribute, foreign_item.attrs);\n }\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound) {\n@@ -849,9 +849,9 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n     visitor.visit_nested_body(body_id)\n }\n \n-pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n+pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     visitor.visit_ident(trait_item.ident);\n-    walk_list!(visitor, visit_attribute, &trait_item.attrs);\n+    walk_list!(visitor, visit_attribute, trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.kind {\n         TraitItemKind::Const(ref ty, default) => {\n@@ -893,14 +893,14 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n     visitor.visit_defaultness(defaultness);\n }\n \n-pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n+pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n         hir_id: _,\n         ident,\n         ref vis,\n         ref defaultness,\n-        ref attrs,\n+        attrs,\n         ref generics,\n         ref kind,\n         span: _,\n@@ -948,19 +948,22 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_defaultness(defaultness);\n }\n \n-pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n+pub fn walk_struct_def<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    struct_definition: &'v VariantData<'v>,\n+) {\n     if let Some(ctor_hir_id) = struct_definition.ctor_hir_id() {\n         visitor.visit_id(ctor_hir_id);\n     }\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n }\n \n-pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n+pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField<'v>) {\n     visitor.visit_id(struct_field.hir_id);\n     visitor.visit_vis(&struct_field.vis);\n     visitor.visit_ident(struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n-    walk_list!(visitor, visit_attribute, &struct_field.attrs);\n+    walk_list!(visitor, visit_attribute, struct_field.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {"}, {"sha": "30b41ea4acb3b206b4b7b8ccfdd644d2867256a5", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -45,9 +45,9 @@ use super::intravisit::Visitor;\n /// existing `fn visit_nested` methods to see where changes are\n /// needed.\n pub trait ItemLikeVisitor<'hir> {\n-    fn visit_item(&mut self, item: &'hir Item);\n-    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem);\n-    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem);\n+    fn visit_item(&mut self, item: &'hir Item<'hir>);\n+    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem<'hir>);\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem<'hir>);\n }\n \n pub struct DeepVisitor<'v, V> {\n@@ -65,24 +65,24 @@ impl<'v, 'hir, V> DeepVisitor<'v, V>\n impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n     where V: Visitor<'hir>\n {\n-    fn visit_item(&mut self, item: &'hir Item) {\n+    fn visit_item(&mut self, item: &'hir Item<'hir>) {\n         self.visitor.visit_item(item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'hir TraitItem<'hir>) {\n         self.visitor.visit_trait_item(trait_item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem<'hir>) {\n         self.visitor.visit_impl_item(impl_item);\n     }\n }\n \n /// A parallel variant of `ItemLikeVisitor`.\n pub trait ParItemLikeVisitor<'hir> {\n-    fn visit_item(&self, item: &'hir Item);\n-    fn visit_trait_item(&self, trait_item: &'hir TraitItem);\n-    fn visit_impl_item(&self, impl_item: &'hir ImplItem);\n+    fn visit_item(&self, item: &'hir Item<'hir>);\n+    fn visit_trait_item(&self, trait_item: &'hir TraitItem<'hir>);\n+    fn visit_impl_item(&self, impl_item: &'hir ImplItem<'hir>);\n }\n \n pub trait IntoVisitor<'hir> {\n@@ -95,15 +95,15 @@ pub struct ParDeepVisitor<V>(pub V);\n impl<'hir, V> ParItemLikeVisitor<'hir> for ParDeepVisitor<V>\n     where V: IntoVisitor<'hir>\n {\n-    fn visit_item(&self, item: &'hir Item) {\n+    fn visit_item(&self, item: &'hir Item<'hir>) {\n         self.0.into_visitor().visit_item(item);\n     }\n \n-    fn visit_trait_item(&self, trait_item: &'hir TraitItem) {\n+    fn visit_trait_item(&self, trait_item: &'hir TraitItem<'hir>) {\n         self.0.into_visitor().visit_trait_item(trait_item);\n     }\n \n-    fn visit_impl_item(&self, impl_item: &'hir ImplItem) {\n+    fn visit_impl_item(&self, impl_item: &'hir ImplItem<'hir>) {\n         self.0.into_visitor().visit_impl_item(impl_item);\n     }\n }"}, {"sha": "83869951ea2a15afe36876aae620f6520955200f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -35,6 +35,7 @@\n mod expr;\n mod item;\n \n+use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n@@ -77,7 +78,7 @@ use rustc_error_codes::*;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n-pub struct LoweringContext<'a> {\n+pub struct LoweringContext<'a, 'hir: 'a> {\n     crate_root: Option<Symbol>,\n \n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n@@ -90,13 +91,16 @@ pub struct LoweringContext<'a> {\n     /// librustc is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n+    /// Used to allocate HIR nodes\n+    arena: &'hir Arena<'hir>,\n+\n     /// The items being lowered are collected here.\n-    items: BTreeMap<hir::HirId, hir::Item>,\n+    items: BTreeMap<hir::HirId, hir::Item<'hir>>,\n \n-    trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n-    impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n-    bodies: BTreeMap<hir::BodyId, hir::Body>,\n-    exported_macros: Vec<hir::MacroDef>,\n+    trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem<'hir>>,\n+    impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem<'hir>>,\n+    bodies: BTreeMap<hir::BodyId, hir::Body<'hir>>,\n+    exported_macros: Vec<hir::MacroDef<'hir>>,\n     non_exported_macro_attrs: Vec<ast::Attribute>,\n \n     trait_impls: BTreeMap<DefId, Vec<hir::HirId>>,\n@@ -240,13 +244,14 @@ impl<'a> ImplTraitContext<'a> {\n     }\n }\n \n-pub fn lower_crate(\n-    sess: &Session,\n-    dep_graph: &DepGraph,\n-    krate: &Crate,\n-    resolver: &mut dyn Resolver,\n+pub fn lower_crate<'a, 'hir>(\n+    sess: &'a Session,\n+    dep_graph: &'a DepGraph,\n+    krate: &'a Crate,\n+    resolver: &'a mut dyn Resolver,\n     nt_to_tokenstream: NtToTokenstream,\n-) -> hir::Crate {\n+    arena: &'hir Arena<'hir>,\n+) -> hir::Crate<'hir> {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n     // incr. comp. yet.\n@@ -259,6 +264,7 @@ pub fn lower_crate(\n         sess,\n         resolver,\n         nt_to_tokenstream,\n+        arena,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -382,19 +388,19 @@ impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     }\n }\n \n-impl<'a> LoweringContext<'a> {\n-    fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    fn lower_crate(mut self, c: &Crate) -> hir::Crate<'hir> {\n         /// Full-crate AST visitor that inserts into a fresh\n         /// `LoweringContext` any information that may be\n         /// needed from arbitrary locations in the crate,\n         /// e.g., the number of lifetime generic parameters\n         /// declared for every type and trait definition.\n-        struct MiscCollector<'tcx, 'interner> {\n-            lctx: &'tcx mut LoweringContext<'interner>,\n+        struct MiscCollector<'tcx, 'lowering, 'hir> {\n+            lctx: &'tcx mut LoweringContext<'lowering, 'hir>,\n             hir_id_owner: Option<NodeId>,\n         }\n \n-        impl MiscCollector<'_, '_> {\n+        impl MiscCollector<'_, '_, '_> {\n             fn allocate_use_tree_hir_id_counters(\n                 &mut self,\n                 tree: &UseTree,\n@@ -434,7 +440,7 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n+        impl<'tcx, 'lowering, 'hir> Visitor<'tcx> for MiscCollector<'tcx, 'lowering, 'hir> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n                 if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n                     // Doesn't generate a HIR node\n@@ -537,7 +543,7 @@ impl<'a> LoweringContext<'a> {\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.module);\n-        let attrs = self.lower_attrs(&c.attrs);\n+        let attrs = self.arena.alloc_from_iter(self.lower_attrs(&c.attrs).into_iter());\n         let body_ids = body_ids(&self.bodies);\n \n         self.resolver\n@@ -548,8 +554,8 @@ impl<'a> LoweringContext<'a> {\n             module,\n             attrs,\n             span: c.span,\n-            exported_macros: hir::HirVec::from(self.exported_macros),\n-            non_exported_macro_attrs: hir::HirVec::from(self.non_exported_macro_attrs),\n+            exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n+            non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n@@ -560,7 +566,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn insert_item(&mut self, item: hir::Item) {\n+    fn insert_item(&mut self, item: hir::Item<'hir>) {\n         let id = item.hir_id;\n         // FIXME: Use `debug_asset-rt`.\n         assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n@@ -750,7 +756,7 @@ impl<'a> LoweringContext<'a> {\n         f: F,\n     ) -> (Vec<hir::GenericParam>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> (Vec<hir::GenericParam>, T),\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> (Vec<hir::GenericParam>, T),\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n@@ -867,7 +873,7 @@ impl<'a> LoweringContext<'a> {\n     // for them.\n     fn with_in_scope_lifetime_defs<T, F>(&mut self, params: &[GenericParam], f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, 'hir>) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n@@ -896,7 +902,7 @@ impl<'a> LoweringContext<'a> {\n         f: F,\n     ) -> (hir::Generics, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_>, &mut Vec<hir::GenericParam>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam>) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) = self.with_in_scope_lifetime_defs(\n             &generics.params,\n@@ -945,7 +951,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn with_dyn_type_scope<T, F>(&mut self, in_scope: bool, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n@@ -959,7 +965,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn with_new_scopes<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n@@ -983,15 +989,14 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_attrs_extendable(&mut self, attrs: &[Attribute]) -> Vec<Attribute> {\n-        attrs\n-            .iter()\n-            .map(|a| self.lower_attr(a))\n-            .collect()\n+    fn lower_attrs_arena(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n+        self.arena.alloc_from_iter(\n+            attrs.iter().map(|a| self.lower_attr(a))\n+        )\n     }\n \n     fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n-        self.lower_attrs_extendable(attrs).into()\n+        attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into()\n     }\n \n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n@@ -1446,7 +1451,7 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         fn_def_id: Option<DefId>,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n+        lower_bounds: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n         debug!(\n             \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n@@ -1563,8 +1568,8 @@ impl<'a> LoweringContext<'a> {\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n-        struct ImplTraitLifetimeCollector<'r, 'a> {\n-            context: &'r mut LoweringContext<'a>,\n+        struct ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n+            context: &'r mut LoweringContext<'a, 'hir>,\n             parent: DefIndex,\n             opaque_ty_id: NodeId,\n             collect_elided_lifetimes: bool,\n@@ -1574,7 +1579,9 @@ impl<'a> LoweringContext<'a> {\n             output_lifetime_params: Vec<hir::GenericParam>,\n         }\n \n-        impl<'r, 'a, 'v> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a> {\n+        impl<'r, 'a, 'v, 'hir> hir::intravisit::Visitor<'v>\n+        for ImplTraitLifetimeCollector<'r, 'a, 'hir>\n+        {\n             fn nested_visit_map<'this>(\n                 &'this mut self,\n             ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n@@ -2757,8 +2764,9 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                let lower_sub = |this: &mut Self| sub.as_ref().map(|x| this.lower_pat(x));\n-                self.lower_pat_ident(p, binding_mode, ident, lower_sub)\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                node\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n             PatKind::TupleStruct(ref path, ref pats) => {\n@@ -3422,7 +3430,7 @@ impl<'a> LoweringContext<'a> {\n     }\n }\n \n-fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n+fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId> {\n     // Sorting by span ensures that we get things in order within a\n     // file, and also puts the files in a sensible order.\n     let mut body_ids: Vec<_> = bodies.keys().cloned().collect();"}, {"sha": "08b00ce69addbb08463a03998f32e04dc4cc5b31", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -13,7 +13,7 @@ use syntax::symbol::{sym, Symbol};\n \n use rustc_error_codes::*;\n \n-impl LoweringContext<'_> {\n+impl LoweringContext<'_, '_> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n         exprs.iter().map(|x| self.lower_expr(x)).collect()\n     }\n@@ -473,7 +473,7 @@ impl LoweringContext<'_> {\n         ret_ty: Option<AstP<Ty>>,\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n-        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(ty),\n@@ -909,7 +909,7 @@ impl LoweringContext<'_> {\n \n     fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     {\n         let len = self.catch_scopes.len();\n         self.catch_scopes.push(catch_id);\n@@ -928,7 +928,7 @@ impl LoweringContext<'_> {\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     {\n         // We're no longer in the base loop's condition; we're in another loop.\n         let was_in_loop_condition = self.is_in_loop_condition;\n@@ -953,7 +953,7 @@ impl LoweringContext<'_> {\n \n     fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = true;"}, {"sha": "4492845acb808280a72831e5987aa4d05550b11f", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 126, "deletions": 100, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -5,7 +5,7 @@ use super::ImplTraitTypeIdVisitor;\n use super::AnonymousLifetimeMode;\n use super::ParamMode;\n \n-use crate::hir::{self, HirVec};\n+use crate::hir;\n use crate::hir::ptr::P;\n use crate::hir::def_id::DefId;\n use crate::hir::def::{Res, DefKind};\n@@ -24,11 +24,11 @@ use syntax_pos::Span;\n \n use rustc_error_codes::*;\n \n-pub(super) struct ItemLowerer<'tcx, 'interner> {\n-    pub(super) lctx: &'tcx mut LoweringContext<'interner>,\n+pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n+    pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n \n-impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n+impl<'a, 'lowering, 'hir> ItemLowerer<'a, 'lowering, 'hir> {\n     fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n     where\n         F: FnOnce(&mut Self),\n@@ -44,8 +44,8 @@ impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n     }\n }\n \n-impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n-    fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n+impl<'a, 'lowering, 'hir> Visitor<'a> for ItemLowerer<'a, 'lowering, 'hir> {\n+    fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n         let hir_id = self.lctx.lower_node_id(n);\n \n         self.lctx.modules.insert(hir_id, hir::ModuleItems {\n@@ -60,7 +60,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         self.lctx.current_module = old;\n     }\n \n-    fn visit_item(&mut self, item: &'tcx Item) {\n+    fn visit_item(&mut self, item: &'a Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             lctx.without_in_scope_lifetime_defs(|lctx| {\n@@ -85,7 +85,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, item: &'tcx AssocItem) {\n+    fn visit_trait_item(&mut self, item: &'a AssocItem) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_trait_item(item);\n             let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n@@ -96,7 +96,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         visit::walk_trait_item(self, item);\n     }\n \n-    fn visit_impl_item(&mut self, item: &'tcx AssocItem) {\n+    fn visit_impl_item(&mut self, item: &'a AssocItem) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_impl_item(item);\n             let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n@@ -107,7 +107,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n     }\n }\n \n-impl LoweringContext<'_> {\n+impl<'hir> LoweringContext<'_, 'hir> {\n     // Same as the method above, but accepts `hir::GenericParam`s\n     // instead of `ast::GenericParam`s.\n     // This should only be used with generics that have already had their\n@@ -116,7 +116,7 @@ impl LoweringContext<'_> {\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n         parent_hir_id: hir::HirId,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n@@ -144,7 +144,7 @@ impl LoweringContext<'_> {\n     // from their surrounding environment.\n     fn without_in_scope_lifetime_defs<T>(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n         let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n \n@@ -161,10 +161,12 @@ impl LoweringContext<'_> {\n         res\n     }\n \n-    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n+    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod<'hir> {\n         hir::Mod {\n             inner: m.inner,\n-            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n+            item_ids: self.arena.alloc_from_iter(\n+                m.items.iter().flat_map(|x| self.lower_item_id(x))\n+            ),\n         }\n     }\n \n@@ -225,10 +227,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs(&i.attrs);\n+        let attrs = self.lower_attrs_arena(&i.attrs);\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n@@ -244,12 +246,12 @@ impl LoweringContext<'_> {\n                     legacy: def.legacy,\n                 });\n             } else {\n-                self.non_exported_macro_attrs.extend(attrs.into_iter());\n+                self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n             }\n             return None;\n         }\n \n-        let kind = self.lower_item_kind(i.span, i.id, &mut ident, &attrs, &mut vis, &i.kind);\n+        let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n \n         Some(hir::Item {\n             hir_id: self.lower_node_id(i.id),\n@@ -266,10 +268,10 @@ impl LoweringContext<'_> {\n         span: Span,\n         id: NodeId,\n         ident: &mut Ident,\n-        attrs: &hir::HirVec<Attribute>,\n+        attrs: &'hir [Attribute],\n         vis: &mut hir::Visibility,\n         i: &ItemKind,\n-    ) -> hir::ItemKind {\n+    ) -> hir::ItemKind<'hir> {\n         match *i {\n             ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n@@ -282,29 +284,31 @@ impl LoweringContext<'_> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n+                let ty = self.lower_ty(\n+                    t,\n+                    if self.sess.features_untracked().impl_trait_in_bindings {\n+                        ImplTraitContext::OpaqueTy(None)\n+                    } else {\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                    }\n+                );\n                 hir::ItemKind::Static(\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(None)\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        }\n-                    ),\n+                    self.arena.alloc(ty.into_inner()),\n                     m,\n                     self.lower_const_body(span, Some(e)),\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n+                let ty = self.lower_ty(\n+                    t,\n+                    if self.sess.features_untracked().impl_trait_in_bindings {\n+                        ImplTraitContext::OpaqueTy(None)\n+                    } else {\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                    }\n+                );\n                 hir::ItemKind::Const(\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(None)\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        }\n-                    ),\n+                    self.arena.alloc(ty.into_inner()),\n                     self.lower_const_body(span, Some(e))\n                 )\n             }\n@@ -346,7 +350,7 @@ impl LoweringContext<'_> {\n                 None => {\n                     let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                     let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n-                    hir::ItemKind::TyAlias(ty, generics)\n+                    hir::ItemKind::TyAlias(self.arena.alloc(ty.into_inner()), generics)\n                 },\n                 Some(bounds) => {\n                     let ty = hir::OpaqueTy {\n@@ -361,11 +365,12 @@ impl LoweringContext<'_> {\n             ItemKind::Enum(ref enum_definition, ref generics) => {\n                 hir::ItemKind::Enum(\n                     hir::EnumDef {\n-                        variants: enum_definition\n+                        variants: self.arena.alloc_from_iter(\n+                            enum_definition\n                             .variants\n                             .iter()\n                             .map(|x| self.lower_variant(x))\n-                            .collect(),\n+                        ),\n                     },\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n@@ -434,10 +439,11 @@ impl LoweringContext<'_> {\n                 let new_impl_items = self.with_in_scope_lifetime_defs(\n                     &ast_generics.params,\n                     |this| {\n-                        impl_items\n-                            .iter()\n-                            .map(|item| this.lower_impl_item_ref(item))\n-                            .collect()\n+                        this.arena.alloc_from_iter(\n+                            impl_items\n+                                .iter()\n+                                .map(|item| this.lower_impl_item_ref(item))\n+                        )\n                     },\n                 );\n \n@@ -447,16 +453,16 @@ impl LoweringContext<'_> {\n                     self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n                     trait_ref,\n-                    lowered_ty,\n+                    self.arena.alloc(lowered_ty.into_inner()),\n                     new_impl_items,\n                 )\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n                 let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n-                let items = items\n+                let items = self.arena.alloc_from_iter(items\n                     .iter()\n                     .map(|item| self.lower_trait_item_ref(item))\n-                    .collect();\n+                );\n                 hir::ItemKind::Trait(\n                     is_auto,\n                     unsafety,\n@@ -484,8 +490,8 @@ impl LoweringContext<'_> {\n         id: NodeId,\n         vis: &mut hir::Visibility,\n         ident: &mut Ident,\n-        attrs: &hir::HirVec<Attribute>,\n-    ) -> hir::ItemKind {\n+        attrs: &'hir [Attribute],\n+    ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n         debug!(\"lower_use_tree: vis = {:?}\", vis);\n \n@@ -540,14 +546,14 @@ impl LoweringContext<'_> {\n                         let res = this.lower_res(res);\n                         let path =\n                             this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n-                        let kind = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n+                        let kind = hir::ItemKind::Use(this.arena.alloc(path), hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(\n                             hir::Item {\n                                 hir_id: new_id,\n                                 ident,\n-                                attrs: attrs.into_iter().cloned().collect(),\n+                                attrs,\n                                 kind,\n                                 vis,\n                                 span,\n@@ -556,11 +562,12 @@ impl LoweringContext<'_> {\n                     });\n                 }\n \n-                let path = P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n+                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None);\n+                let path = self.arena.alloc(path);\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n-                let path = P(self.lower_path(\n+                let path = self.arena.alloc(self.lower_path(\n                     id,\n                     &Path {\n                         segments,\n@@ -631,7 +638,7 @@ impl LoweringContext<'_> {\n                             hir::Item {\n                                 hir_id: new_hir_id,\n                                 ident,\n-                                attrs: attrs.into_iter().cloned().collect(),\n+                                attrs,\n                                 kind,\n                                 vis,\n                                 span: use_tree.span,\n@@ -663,7 +670,8 @@ impl LoweringContext<'_> {\n \n                 let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n                 let res = self.lower_res(res);\n-                let path = P(self.lower_path_extra(res, &prefix, ParamMode::Explicit, None));\n+                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit, None);\n+                let path = self.arena.alloc(path);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -703,12 +711,12 @@ impl LoweringContext<'_> {\n         respan(vis.span, vis_kind)\n     }\n \n-    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n         let def_id = self.resolver.definitions().local_def_id(i.id);\n         hir::ForeignItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n+            attrs: self.lower_attrs_arena(&i.attrs),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(ref fdec, ref generics) => {\n                     let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n@@ -723,12 +731,14 @@ impl LoweringContext<'_> {\n                             )\n                         },\n                     );\n+                    let fn_dec = self.arena.alloc(fn_dec.into_inner());\n+                    let fn_args = self.arena.alloc_from_iter(fn_args.into_iter());\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n-                    hir::ForeignItemKind::Static(\n-                        self.lower_ty(t, ImplTraitContext::disallowed()), m)\n+                    let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n+                    hir::ForeignItemKind::Static(self.arena.alloc(ty.into_inner()), m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n@@ -738,23 +748,22 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n+    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod<'hir> {\n         hir::ForeignMod {\n             abi: fm.abi.map_or(abi::Abi::C, |abi| self.lower_abi(abi)),\n-            items: fm.items\n+            items: self.arena.alloc_from_iter(fm.items\n                 .iter()\n-                .map(|x| self.lower_foreign_item(x))\n-                .collect(),\n+                .map(|x| self.lower_foreign_item(x))),\n         }\n     }\n \n-    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n-        P(hir::GlobalAsm { asm: ga.asm })\n+    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> &'hir hir::GlobalAsm {\n+        self.arena.alloc(hir::GlobalAsm { asm: ga.asm })\n     }\n \n-    fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n+    fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n         hir::Variant {\n-            attrs: self.lower_attrs(&v.attrs),\n+            attrs: self.lower_attrs_arena(&v.attrs),\n             data: self.lower_variant_data(&v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n             id: self.lower_node_id(v.id),\n@@ -763,19 +772,22 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n+    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData<'hir> {\n         match *vdata {\n             VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n-                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n+                self.arena.alloc_from_iter(\n+                    fields.iter().enumerate().map(|f| self.lower_struct_field(f))\n+                ),\n                 recovered,\n             ),\n             VariantData::Tuple(ref fields, id) => {\n                 hir::VariantData::Tuple(\n-                    fields\n+                    self.arena.alloc_from_iter(\n+                        fields\n                         .iter()\n                         .enumerate()\n                         .map(|f| self.lower_struct_field(f))\n-                        .collect(),\n+                    ),\n                     self.lower_node_id(id),\n                 )\n             },\n@@ -785,7 +797,7 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n+    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField<'hir> {\n         let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n@@ -794,9 +806,10 @@ impl LoweringContext<'_> {\n                 ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n                 ImplTraitContext::disallowed()\n             );\n-            P(t)\n+            self.arena.alloc(t)\n         } else {\n-            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n+            let t = self.lower_ty(&f.ty, ImplTraitContext::disallowed());\n+            self.arena.alloc(t.into_inner())\n         };\n         hir::StructField {\n             span: f.span,\n@@ -808,23 +821,25 @@ impl LoweringContext<'_> {\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty,\n-            attrs: self.lower_attrs(&f.attrs),\n+            attrs: self.lower_attrs_arena(&f.attrs),\n         }\n     }\n \n-    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem {\n+    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::TraitItemKind::Const(\n-                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+            AssocItemKind::Const(ref ty, ref default) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                let ty = self.arena.alloc(ty.into_inner());\n+                (generics, hir::TraitItemKind::Const(\n+                    ty,\n                     default\n                         .as_ref()\n                         .map(|x| self.lower_const_body(i.span, Some(x))),\n-                ),\n-            ),\n+                ))\n+            },\n             AssocItemKind::Fn(ref sig, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n@@ -848,12 +863,13 @@ impl LoweringContext<'_> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(ref bounds, ref default) => {\n+                let ty = default.as_ref().map(|x| -> &'hir hir::Ty { self.arena.alloc(\n+                        self.lower_ty(x, ImplTraitContext::disallowed()).into_inner())\n+                });\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n-                    default\n-                        .as_ref()\n-                        .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n+                    ty,\n                 );\n \n                 (generics, kind)\n@@ -864,7 +880,7 @@ impl LoweringContext<'_> {\n         hir::TraitItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n+            attrs: self.lower_attrs_arena(&i.attrs),\n             generics,\n             kind,\n             span: i.span,\n@@ -901,17 +917,19 @@ impl LoweringContext<'_> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n-    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem {\n+    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref expr) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::ImplItemKind::Const(\n-                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+            AssocItemKind::Const(ref ty, ref expr) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                let ty = self.arena.alloc(ty.into_inner());\n+                (generics, hir::ImplItemKind::Const(\n+                    ty,\n                     self.lower_const_body(i.span, expr.as_deref()),\n-                ),\n-            ),\n+                ))\n+            },\n             AssocItemKind::Fn(ref sig, ref body) => {\n                 self.current_item = Some(i.span);\n                 let body_id = self.lower_maybe_async_body(\n@@ -935,11 +953,13 @@ impl LoweringContext<'_> {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = match ty {\n                     None => {\n-                        hir::ImplItemKind::TyAlias(P(self.ty(i.span, hir::TyKind::Err)))\n+                        let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n+                        hir::ImplItemKind::TyAlias(ty)\n                     }\n                     Some(ty) => match ty.kind.opaque_top_hack() {\n                         None => {\n                             let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                            let ty = self.arena.alloc(ty.into_inner());\n                             hir::ImplItemKind::TyAlias(ty)\n                         }\n                         Some(bs) => {\n@@ -956,7 +976,7 @@ impl LoweringContext<'_> {\n         hir::ImplItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n+            attrs: self.lower_attrs_arena(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -1042,7 +1062,7 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, params: &'hir [hir::Param], value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n             params,\n@@ -1055,7 +1075,7 @@ impl LoweringContext<'_> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Param>, hir::Expr),\n+        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param], hir::Expr),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n         let (parameters, result) = f(self);\n@@ -1076,10 +1096,12 @@ impl LoweringContext<'_> {\n     pub(super) fn lower_fn_body(\n         &mut self,\n         decl: &FnDecl,\n-        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+        body: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::Expr,\n     ) -> hir::BodyId {\n         self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_param(x)).collect(),\n+            this.arena.alloc_from_iter(\n+                decl.inputs.iter().map(|x| this.lower_param(x))\n+            ),\n             body(this),\n         ))\n     }\n@@ -1101,7 +1123,7 @@ impl LoweringContext<'_> {\n     }\n \n     pub(super) fn lower_const_body(&mut self, span: Span, expr: Option<&Expr>) -> hir::BodyId {\n-        self.lower_body(|this| (hir_vec![], match expr {\n+        self.lower_body(|this| (&[], match expr {\n             Some(expr) => this.lower_expr(expr),\n             None => this.expr_err(span),\n         }))\n@@ -1289,7 +1311,11 @@ impl LoweringContext<'_> {\n                     );\n                     this.expr_block(P(body), AttrVec::new())\n                 });\n-            (HirVec::from(parameters), this.expr(body_span, async_expr, AttrVec::new()))\n+\n+            (\n+                this.arena.alloc_from_iter(parameters),\n+                this.expr(body_span, async_expr, AttrVec::new()),\n+            )\n         })\n     }\n "}, {"sha": "ab04a8a10aa2f7d508484cea14ec1cd74ae61e58", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -35,7 +35,7 @@ pub struct FnLikeNode<'a> { node: Node<'a> }\n /// corresponds to some FnLikeNode.\n trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n-impl MaybeFnLike for ast::Item {\n+impl MaybeFnLike for ast::Item<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n             ast::ItemKind::Fn(..) => true,\n@@ -44,7 +44,7 @@ impl MaybeFnLike for ast::Item {\n     }\n }\n \n-impl MaybeFnLike for ast::ImplItem {\n+impl MaybeFnLike for ast::ImplItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n             ast::ImplItemKind::Method(..) => true,\n@@ -53,7 +53,7 @@ impl MaybeFnLike for ast::ImplItem {\n     }\n }\n \n-impl MaybeFnLike for ast::TraitItem {\n+impl MaybeFnLike for ast::TraitItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n             ast::TraitItemKind::Method(_, ast::TraitMethod::Provided(_)) => true,"}, {"sha": "faf2a0c7010e725d480b37537c4c4c87683f66cf", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n-    krate: &'hir Crate,\n+    krate: &'hir Crate<'hir>,\n \n     /// Source map\n     source_map: &'a SourceMap,\n@@ -99,7 +99,7 @@ where\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(sess: &'a Session,\n-                       krate: &'hir Crate,\n+                       krate: &'hir Crate<'hir>,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n                        hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n@@ -367,7 +367,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_item(&mut self, i: &'hir Item) {\n+    fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(self.hir_to_node_id[&i.hir_id]).unwrap());\n@@ -385,7 +385,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem<'hir>) {\n         self.insert(foreign_item.span, foreign_item.hir_id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.hir_id, |this| {\n@@ -398,7 +398,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         intravisit::walk_generic_param(self, param);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(self.hir_to_node_id[&ti.hir_id]).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n@@ -410,7 +410,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(self.hir_to_node_id[&ii.hir_id]).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n@@ -530,7 +530,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         }\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'hir MacroDef<'hir>) {\n         let node_id = self.hir_to_node_id[&macro_def.hir_id];\n         let def_index = self.definitions.opt_def_index(node_id).unwrap();\n \n@@ -539,7 +539,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics, item_id: HirId) {\n         self.insert(v.span, v.id, Node::Variant(v));\n         self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n@@ -550,7 +550,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_struct_field(&mut self, field: &'hir StructField) {\n+    fn visit_struct_field(&mut self, field: &'hir StructField<'hir>) {\n         self.insert(field.span, field.hir_id, Node::Field(field));\n         self.with_parent(field.hir_id, |this| {\n             intravisit::walk_struct_field(this, field);"}, {"sha": "0a06473ed30a99e3e89d2dd4ac610c8ceaa30c79", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -53,17 +53,17 @@ impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n }\n \n impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n-    fn visit_item(&mut self, i: &'hir hir::Item) {\n+    fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.hir_id, |this| intravisit::walk_item(this, i));\n     }\n \n-    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n+    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.hir_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n-    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.hir_id, |this| intravisit::walk_impl_item(this, i));\n     }"}, {"sha": "71addc123b8eb329d28a806a1119a77e31a71111", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -153,28 +153,28 @@ impl<'hir> Entry<'hir> {\n }\n \n /// Stores a crate and any number of inlined items from other crates.\n-pub struct Forest {\n-    krate: Crate,\n+pub struct Forest<'hir> {\n+    krate: Crate<'hir>,\n     pub dep_graph: DepGraph,\n }\n \n-impl Forest {\n-    pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n+impl Forest<'hir> {\n+    pub fn new(krate: Crate<'hir>, dep_graph: &DepGraph) -> Forest<'hir> {\n         Forest {\n             krate,\n             dep_graph: dep_graph.clone(),\n         }\n     }\n \n-    pub fn krate(&self) -> &Crate {\n+    pub fn krate(&self) -> &Crate<'hir> {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n \n     /// This is used internally in the dependency tracking system.\n     /// Use the `krate` method to ensure your dependency on the\n     /// crate is tracked.\n-    pub fn untracked_krate(&self) -> &Crate {\n+    pub fn untracked_krate(&self) -> &Crate<'hir> {\n         &self.krate\n     }\n }\n@@ -189,7 +189,7 @@ pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Opt\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n-    pub forest: &'hir Forest,\n+    pub forest: &'hir Forest<'hir>,\n \n     /// Same as the dep_graph in forest, just available with one fewer\n     /// deref. This is a gratuitous micro-optimization.\n@@ -439,27 +439,27 @@ impl<'hir> Map<'hir> {\n         self.lookup(id).cloned()\n     }\n \n-    pub fn krate(&self) -> &'hir Crate {\n+    pub fn krate(&self) -> &'hir Crate<'hir> {\n         self.forest.krate()\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n+    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n+    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.impl_item(id)\n     }\n \n-    pub fn body(&self, id: BodyId) -> &'hir Body {\n+    pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.read(id.hir_id);\n \n         // N.B., intentionally bypass `self.forest.krate()` so that we\n@@ -580,7 +580,7 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n@@ -959,28 +959,28 @@ impl<'hir> Map<'hir> {\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n-    pub fn expect_item(&self, id: HirId) -> &'hir Item {\n+    pub fn expect_item(&self, id: HirId) -> &'hir Item<'hir> {\n         match self.find(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n+    pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem<'hir> {\n         match self.find(id) {\n             Some(Node::ImplItem(item)) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n+    pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem<'hir> {\n         match self.find(id) {\n             Some(Node::TraitItem(item)) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData {\n+    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData<'hir> {\n         match self.find(id) {\n             Some(Node::Item(i)) => {\n                 match i.kind {\n@@ -995,14 +995,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n+    pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n+    pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem<'hir> {\n         match self.find(id) {\n             Some(Node::ForeignItem(item)) => item,\n             _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n@@ -1213,7 +1213,7 @@ impl<'a> NodesMatchingSuffix<'a> {\n                 id = parent;\n             }\n \n-            fn item_is_mod(item: &Item) -> bool {\n+            fn item_is_mod(item: &Item<'_>) -> bool {\n                 match item.kind {\n                     ItemKind::Mod(_) => true,\n                     _ => false,\n@@ -1248,16 +1248,16 @@ trait Named {\n \n impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n \n-impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for Variant { fn name(&self) -> Name { self.ident.name } }\n-impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n-impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Item<'_> { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ForeignItem<'_> { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant<'_> { fn name(&self) -> Name { self.ident.name } }\n+impl Named for StructField<'_> { fn name(&self) -> Name { self.ident.name } }\n+impl Named for TraitItem<'_> { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ImplItem<'_> { fn name(&self) -> Name { self.ident.name } }\n \n pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n-                       forest: &'hir Forest,\n+                       forest: &'hir Forest<'hir>,\n                        definitions: Definitions)\n                        -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");"}, {"sha": "ff6801a85c7e1d28bcd6dcc59452855dd8c9c507", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 87, "deletions": 85, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -742,25 +742,25 @@ pub struct ModuleItems {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct Crate {\n-    pub module: Mod,\n-    pub attrs: HirVec<Attribute>,\n+pub struct Crate<'hir> {\n+    pub module: Mod<'hir>,\n+    pub attrs: &'hir [Attribute],\n     pub span: Span,\n-    pub exported_macros: HirVec<MacroDef>,\n+    pub exported_macros: &'hir [MacroDef<'hir>],\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n-    pub non_exported_macro_attrs: HirVec<Attribute>,\n+    pub non_exported_macro_attrs: &'hir [Attribute],\n \n     // N.B., we use a `BTreeMap` here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n-    pub items: BTreeMap<HirId, Item>,\n+    pub items: BTreeMap<HirId, Item<'hir>>,\n \n-    pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n-    pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n-    pub bodies: BTreeMap<BodyId, Body>,\n+    pub trait_items: BTreeMap<TraitItemId, TraitItem<'hir>>,\n+    pub impl_items: BTreeMap<ImplItemId, ImplItem<'hir>>,\n+    pub bodies: BTreeMap<BodyId, Body<'hir>>,\n     pub trait_impls: BTreeMap<DefId, Vec<HirId>>,\n \n     /// A list of the body ids written out in the order in which they\n@@ -774,19 +774,25 @@ pub struct Crate {\n     pub modules: BTreeMap<HirId, ModuleItems>,\n }\n \n-impl Crate {\n-    pub fn item(&self, id: HirId) -> &Item {\n+impl Crate<'hir> {\n+    pub fn item(&self, id: HirId) -> &Item<'hir> {\n         &self.items[&id]\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &TraitItem {\n+    pub fn trait_item(&self, id: TraitItemId) -> &TraitItem<'hir> {\n         &self.trait_items[&id]\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem {\n+    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem<'hir> {\n         &self.impl_items[&id]\n     }\n \n+    pub fn body(&self, id: BodyId) -> &Body<'hir> {\n+        &self.bodies[&id]\n+    }\n+}\n+\n+impl Crate<'_> {\n     /// Visits all items in the crate in some deterministic (but\n     /// unspecified) order. If you just need to process every item,\n     /// but don't care about nesting, this method is the best choice.\n@@ -829,20 +835,16 @@ impl Crate {\n             });\n         });\n     }\n-\n-    pub fn body(&self, id: BodyId) -> &Body {\n-        &self.bodies[&id]\n-    }\n }\n \n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct MacroDef {\n+pub struct MacroDef<'hir> {\n     pub name: Name,\n     pub vis: Visibility,\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n     pub span: Span,\n     pub body: TokenStream,\n@@ -1351,13 +1353,13 @@ pub struct BodyId {\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct Body {\n-    pub params: HirVec<Param>,\n+pub struct Body<'hir> {\n+    pub params: &'hir [Param],\n     pub value: Expr,\n     pub generator_kind: Option<GeneratorKind>,\n }\n \n-impl Body {\n+impl Body<'hir> {\n     pub fn id(&self) -> BodyId {\n         BodyId {\n             hir_id: self.value.hir_id,\n@@ -1895,12 +1897,12 @@ pub struct TraitItemId {\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct TraitItem {\n+pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     pub generics: Generics,\n-    pub kind: TraitItemKind,\n+    pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n \n@@ -1916,14 +1918,14 @@ pub enum TraitMethod {\n \n /// Represents a trait method or associated constant or type\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TraitItemKind {\n+pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n-    Const(P<Ty>, Option<BodyId>),\n+    Const(&'hir Ty, Option<BodyId>),\n     /// A method with an optional body.\n     Method(FnSig, TraitMethod),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type.\n-    Type(GenericBounds, Option<P<Ty>>),\n+    Type(GenericBounds, Option<&'hir Ty>),\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1936,27 +1938,27 @@ pub struct ImplItemId {\n \n /// Represents anything within an `impl` block.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct ImplItem {\n+pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     pub generics: Generics,\n-    pub kind: ImplItemKind,\n+    pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n }\n \n /// Represents various kinds of content within an `impl`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ImplItemKind {\n+pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n-    Const(P<Ty>, BodyId),\n+    Const(&'hir Ty, BodyId),\n     /// A method implementation with the given signature and body.\n     Method(FnSig, BodyId),\n     /// An associated type.\n-    TyAlias(P<Ty>),\n+    TyAlias(&'hir Ty),\n     /// An associated `type = impl Trait`.\n     OpaqueTy(GenericBounds),\n }\n@@ -2241,18 +2243,18 @@ impl FunctionRetTy {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct Mod {\n+pub struct Mod<'hir> {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub item_ids: HirVec<ItemId>,\n+    pub item_ids: &'hir [ItemId],\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ForeignMod {\n+pub struct ForeignMod<'hir> {\n     pub abi: Abi,\n-    pub items: HirVec<ForeignItem>,\n+    pub items: &'hir [ForeignItem<'hir>],\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2261,21 +2263,21 @@ pub struct GlobalAsm {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct EnumDef {\n-    pub variants: HirVec<Variant>,\n+pub struct EnumDef<'hir> {\n+    pub variants: &'hir [Variant<'hir>],\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Variant {\n+pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     /// Attributes of the variant.\n-    pub attrs: HirVec<Attribute>,\n+    pub attrs: &'hir [Attribute],\n     /// Id of the variant (not the constructor, see `VariantData::ctor_hir_id()`).\n     pub id: HirId,\n     /// Fields and constructor id of the variant.\n-    pub data: VariantData,\n+    pub data: VariantData<'hir>,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n     /// Span\n@@ -2375,17 +2377,17 @@ impl VisibilityKind {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct StructField {\n+pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub vis: Visibility,\n     pub hir_id: HirId,\n-    pub ty: P<Ty>,\n-    pub attrs: HirVec<Attribute>,\n+    pub ty: &'hir Ty,\n+    pub attrs: &'hir [Attribute],\n }\n \n-impl StructField {\n+impl StructField<'_> {\n     // Still necessary in couple of places\n     pub fn is_positional(&self) -> bool {\n         let first = self.ident.as_str().as_bytes()[0];\n@@ -2395,24 +2397,24 @@ impl StructField {\n \n /// Fields and constructor IDs of enum variants and structs.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum VariantData {\n+pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n     /// E.g., `Bar { .. }` as in `enum Foo { Bar { .. } }`.\n-    Struct(HirVec<StructField>, /* recovered */ bool),\n+    Struct(&'hir [StructField<'hir>], /* recovered */ bool),\n     /// A tuple variant.\n     ///\n     /// E.g., `Bar(..)` as in `enum Foo { Bar(..) }`.\n-    Tuple(HirVec<StructField>, HirId),\n+    Tuple(&'hir [StructField<'hir>], HirId),\n     /// A unit variant.\n     ///\n     /// E.g., `Bar = ..` as in `enum Foo { Bar = .. }`.\n     Unit(HirId),\n }\n \n-impl VariantData {\n+impl VariantData<'hir> {\n     /// Return the fields of this variant.\n-    pub fn fields(&self) -> &[StructField] {\n+    pub fn fields(&self) -> &'hir [StructField<'hir>] {\n         match *self {\n             VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => fields,\n             _ => &[],\n@@ -2440,11 +2442,11 @@ pub struct ItemId {\n ///\n /// The name might be a dummy name in case of anonymous items\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub struct Item {\n+pub struct Item<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n-    pub attrs: HirVec<Attribute>,\n-    pub kind: ItemKind,\n+    pub attrs: &'hir [Attribute],\n+    pub kind: ItemKind<'hir>,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -2467,7 +2469,7 @@ impl FnHeader {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ItemKind {\n+pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n@@ -2478,32 +2480,32 @@ pub enum ItemKind {\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n-    Use(P<Path>, UseKind),\n+    Use(&'hir Path, UseKind),\n \n     /// A `static` item.\n-    Static(P<Ty>, Mutability, BodyId),\n+    Static(&'hir Ty, Mutability, BodyId),\n     /// A `const` item.\n-    Const(P<Ty>, BodyId),\n+    Const(&'hir Ty, BodyId),\n     /// A function declaration.\n     Fn(FnSig, Generics, BodyId),\n     /// A module.\n-    Mod(Mod),\n+    Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n-    ForeignMod(ForeignMod),\n+    ForeignMod(ForeignMod<'hir>),\n     /// Module-level inline assembly (from `global_asm!`).\n-    GlobalAsm(P<GlobalAsm>),\n+    GlobalAsm(&'hir GlobalAsm),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n-    TyAlias(P<Ty>, Generics),\n+    TyAlias(&'hir Ty, Generics),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     OpaqueTy(OpaqueTy),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n-    Enum(EnumDef, Generics),\n+    Enum(EnumDef<'hir>, Generics),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n-    Struct(VariantData, Generics),\n+    Struct(VariantData<'hir>, Generics),\n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n-    Union(VariantData, Generics),\n+    Union(VariantData<'hir>, Generics),\n     /// A trait definition.\n-    Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n+    Trait(IsAuto, Unsafety, Generics, GenericBounds, &'hir [TraitItemRef]),\n     /// A trait alias.\n     TraitAlias(Generics, GenericBounds),\n \n@@ -2513,11 +2515,11 @@ pub enum ItemKind {\n          Defaultness,\n          Generics,\n          Option<TraitRef>, // (optional) trait this impl implements\n-         P<Ty>, // self\n-         HirVec<ImplItemRef>),\n+         &'hir Ty, // self\n+         &'hir [ImplItemRef]),\n }\n \n-impl ItemKind {\n+impl ItemKind<'_> {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n             ItemKind::ExternCrate(..) => \"extern crate\",\n@@ -2605,28 +2607,28 @@ pub enum AssocItemKind {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ForeignItem {\n+pub struct ForeignItem<'hir> {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub attrs: HirVec<Attribute>,\n-    pub kind: ForeignItemKind,\n+    pub attrs: &'hir [Attribute],\n+    pub kind: ForeignItemKind<'hir>,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub vis: Visibility,\n }\n \n /// An item within an `extern` block.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum ForeignItemKind {\n+pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n-    Fn(P<FnDecl>, HirVec<Ident>, Generics),\n+    Fn(&'hir FnDecl, &'hir [Ident], Generics),\n     /// A foreign static item (`static ext: u8`).\n-    Static(P<Ty>, Mutability),\n+    Static(&'hir Ty, Mutability),\n     /// A foreign type.\n     Type,\n }\n \n-impl ForeignItemKind {\n+impl ForeignItemKind<'hir> {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n             ForeignItemKind::Fn(..) => \"foreign function\",\n@@ -2785,12 +2787,12 @@ impl CodegenFnAttrs {\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n     Param(&'hir Param),\n-    Item(&'hir Item),\n-    ForeignItem(&'hir ForeignItem),\n-    TraitItem(&'hir TraitItem),\n-    ImplItem(&'hir ImplItem),\n-    Variant(&'hir Variant),\n-    Field(&'hir StructField),\n+    Item(&'hir Item<'hir>),\n+    ForeignItem(&'hir ForeignItem<'hir>),\n+    TraitItem(&'hir TraitItem<'hir>),\n+    ImplItem(&'hir ImplItem<'hir>),\n+    Variant(&'hir Variant<'hir>),\n+    Field(&'hir StructField<'hir>),\n     AnonConst(&'hir AnonConst),\n     Expr(&'hir Expr),\n     Stmt(&'hir Stmt),\n@@ -2802,11 +2804,11 @@ pub enum Node<'hir> {\n     Arm(&'hir Arm),\n     Block(&'hir Block),\n     Local(&'hir Local),\n-    MacroDef(&'hir MacroDef),\n+    MacroDef(&'hir MacroDef<'hir>),\n \n     /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants\n     /// with synthesized constructors.\n-    Ctor(&'hir VariantData),\n+    Ctor(&'hir VariantData<'hir>),\n \n     Lifetime(&'hir Lifetime),\n     GenericParam(&'hir GenericParam),"}, {"sha": "85747cadbd717db12e9e357f5846f3dfcd52bd9a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -21,7 +21,7 @@ use std::vec;\n pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block),\n-    Item(&'a hir::Item),\n+    Item(&'a hir::Item<'a>),\n     SubItem(hir::HirId),\n     Expr(&'a hir::Expr),\n     Pat(&'a hir::Pat),\n@@ -43,7 +43,7 @@ pub trait PpAnn {\n     }\n     fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) {\n     }\n-    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item> {\n+    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item<'_>> {\n         None\n     }\n }\n@@ -52,8 +52,8 @@ pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n-impl PpAnn for hir::Crate {\n-    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item> {\n+impl PpAnn for hir::Crate<'a> {\n+    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item<'_>> {\n         Some(self.item(item))\n     }\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n@@ -107,7 +107,7 @@ pub const INDENT_UNIT: usize = 4;\n /// it can scan the input text for comments to copy forward.\n pub fn print_crate<'a>(cm: &'a SourceMap,\n                        sess: &ParseSess,\n-                       krate: &hir::Crate,\n+                       krate: &hir::Crate<'_>,\n                        filename: FileName,\n                        input: String,\n                        ann: &'a dyn PpAnn) -> String {\n@@ -259,19 +259,19 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) {\n+    pub fn print_mod(&mut self, _mod: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n         self.print_inner_attributes(attrs);\n-        for &item_id in &_mod.item_ids {\n+        for &item_id in _mod.item_ids {\n             self.ann.nested(self, Nested::Item(item_id));\n         }\n     }\n \n     pub fn print_foreign_mod(&mut self,\n-                             nmod: &hir::ForeignMod,\n+                             nmod: &hir::ForeignMod<'_>,\n                              attrs: &[ast::Attribute])\n                              {\n         self.print_inner_attributes(attrs);\n-        for item in &nmod.items {\n+        for item in nmod.items {\n             self.print_foreign_item(item);\n         }\n     }\n@@ -361,7 +361,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    pub fn print_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n@@ -445,7 +445,7 @@ impl<'a> State<'a> {\n \n     fn print_item_type(\n         &mut self,\n-        item: &hir::Item,\n+        item: &hir::Item<'_>,\n         generics: &hir::Generics,\n         inner: impl Fn(&mut Self),\n     ) {\n@@ -462,7 +462,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Pretty-print an item\n-    pub fn print_item(&mut self, item: &hir::Item) {\n+    pub fn print_item(&mut self, item: &hir::Item<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n@@ -601,7 +601,7 @@ impl<'a> State<'a> {\n                           ref generics,\n                           ref opt_trait,\n                           ref ty,\n-                          ref impl_items) => {\n+                          impl_items) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n@@ -634,7 +634,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref trait_items) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, trait_items) => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_is_auto(is_auto);\n@@ -708,7 +708,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_enum_def(&mut self,\n-                          enum_definition: &hir::EnumDef,\n+                          enum_definition: &hir::EnumDef<'_>,\n                           generics: &hir::Generics,\n                           name: ast::Name,\n                           span: syntax_pos::Span,\n@@ -723,7 +723,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_variants(&mut self,\n-                          variants: &[hir::Variant],\n+                          variants: &[hir::Variant<'_>],\n                           span: syntax_pos::Span)\n                           {\n         self.bopen();\n@@ -770,7 +770,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_struct(&mut self,\n-                        struct_def: &hir::VariantData,\n+                        struct_def: &hir::VariantData<'_>,\n                         generics: &hir::Generics,\n                         name: ast::Name,\n                         span: syntax_pos::Span,\n@@ -819,7 +819,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_variant(&mut self, v: &hir::Variant) {\n+    pub fn print_variant(&mut self, v: &hir::Variant<'_>) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n@@ -846,7 +846,7 @@ impl<'a> State<'a> {\n                       body_id)\n     }\n \n-    pub fn print_trait_item(&mut self, ti: &hir::TraitItem) {\n+    pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n         self.ann.pre(self, AnnNode::SubItem(ti.hir_id));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n@@ -882,7 +882,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n     }\n \n-    pub fn print_impl_item(&mut self, ii: &hir::ImplItem) {\n+    pub fn print_impl_item(&mut self, ii: &hir::ImplItem<'_>) {\n         self.ann.pre(self, AnnNode::SubItem(ii.hir_id));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ii.span.lo());"}, {"sha": "af5e167faa8b783f4fbb8e7b4c5127ccf71e1cb6", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -56,12 +56,12 @@ pub enum NodeIdHashingMode {\n /// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n-struct BodyResolver<'tcx>(&'tcx hir::Crate);\n+struct BodyResolver<'tcx>(&'tcx hir::Crate<'tcx>);\n \n impl<'tcx> BodyResolver<'tcx> {\n     /// Returns a reference to the `hir::Body` with the given `BodyId`.\n     /// **Does not do any tracking**; use carefully.\n-    fn body(self, id: hir::BodyId) -> &'tcx hir::Body {\n+    fn body(self, id: hir::BodyId) -> &'tcx hir::Body<'tcx> {\n         self.0.body(id)\n     }\n }\n@@ -72,7 +72,7 @@ impl<'a> StableHashingContext<'a> {\n     /// leaking data out of the tracking system.\n     #[inline]\n     pub fn new(sess: &'a Session,\n-               krate: &'a hir::Crate,\n+               krate: &'a hir::Crate<'a>,\n                definitions: &'a Definitions,\n                cstore: &'a dyn CrateStore)\n                -> Self {"}, {"sha": "1f96f4c65ef6912a1a7f1c33c275c87b83a57031", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -150,7 +150,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::TraitItem {\n             hir_id: _,\n@@ -172,7 +172,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n }\n \n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::ImplItem {\n             hir_id: _,\n@@ -218,7 +218,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Mod {\n             inner: ref inner_span,\n@@ -245,7 +245,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Item<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Item {\n             ident,\n@@ -266,7 +266,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Body<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let hir::Body {\n             params,"}, {"sha": "052f33dc2a65f79878607a38c595e2931230aa1f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -252,7 +252,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn item_scope_tag(item: &hir::Item) -> &'static str {\n+    fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n         match item.kind {\n             hir::ItemKind::Impl(..) => \"impl\",\n             hir::ItemKind::Struct(..) => \"struct\",\n@@ -264,14 +264,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n+    fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n         match item.kind {\n             hir::TraitItemKind::Method(..) => \"method body\",\n             hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n         }\n     }\n \n-    fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n+    fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n         match item.kind {\n             hir::ImplItemKind::Method(..) => \"method body\",\n             hir::ImplItemKind::Const(..)"}, {"sha": "378d6d78d320388f88fe66a103966db31699236c", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -83,8 +83,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         intravisit::walk_local(self, local);\n     }\n \n-    fn visit_body(&mut self, body: &'tcx Body) {\n-        for param in &body.params {\n+    fn visit_body(&mut self, body: &'tcx Body<'tcx>) {\n+        for param in body.params {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n                 self.node_matches_type(param.hir_id),\n@@ -113,7 +113,7 @@ fn closure_return_type_suggestion(\n     span: Span,\n     err: &mut DiagnosticBuilder<'_>,\n     output: &FunctionRetTy,\n-    body: &Body,\n+    body: &Body<'_>,\n     descr: &str,\n     name: &str,\n     ret: &str,"}, {"sha": "b7d013063438dba7c3cdb37fdc10e9f97b8c8fe7", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -883,7 +883,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n         self.context.param_env = old_param_env;\n     }\n \n-    fn process_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n+    fn process_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n         lint_callback!(self, check_mod, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n         lint_callback!(self, check_mod_post, m, s, n);\n@@ -924,13 +924,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n         });\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n         lint_callback!(self, check_body, body);\n         hir_visit::walk_body(self, body);\n         lint_callback!(self, check_body_post, body);\n     }\n \n-    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = it.kind.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n@@ -943,7 +943,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.generics = generics;\n     }\n \n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n@@ -990,7 +990,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &'tcx hir::VariantData,\n+                        s: &'tcx hir::VariantData<'tcx>,\n                         _: ast::Name,\n                         _: &'tcx hir::Generics,\n                         _: hir::HirId,\n@@ -1000,15 +1000,15 @@ for LateContextAndPass<'a, 'tcx, T> {\n         lint_callback!(self, check_struct_def_post, s);\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n         self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n             lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n+                     v: &'tcx hir::Variant<'tcx>,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n@@ -1027,7 +1027,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n         lint_callback!(self, check_name, sp, name);\n     }\n \n-    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n         if !self.context.only_module {\n             self.process_mod(m, s, n);\n         }\n@@ -1072,7 +1072,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n@@ -1085,7 +1085,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.generics = generics;\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {"}, {"sha": "3d6015ecfbff6f5daba0ffd668bc6db6d39eceb0", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -87,17 +87,17 @@ macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n             fn check_param(a: &$hir hir::Param);\n-            fn check_body(a: &$hir hir::Body);\n-            fn check_body_post(a: &$hir hir::Body);\n+            fn check_body(a: &$hir hir::Body<$hir>);\n+            fn check_body_post(a: &$hir hir::Body<$hir>);\n             fn check_name(a: Span, b: ast::Name);\n-            fn check_crate(a: &$hir hir::Crate);\n-            fn check_crate_post(a: &$hir hir::Crate);\n-            fn check_mod(a: &$hir hir::Mod, b: Span, c: hir::HirId);\n-            fn check_mod_post(a: &$hir hir::Mod, b: Span, c: hir::HirId);\n-            fn check_foreign_item(a: &$hir hir::ForeignItem);\n-            fn check_foreign_item_post(a: &$hir hir::ForeignItem);\n-            fn check_item(a: &$hir hir::Item);\n-            fn check_item_post(a: &$hir hir::Item);\n+            fn check_crate(a: &$hir hir::Crate<$hir>);\n+            fn check_crate_post(a: &$hir hir::Crate<$hir>);\n+            fn check_mod(a: &$hir hir::Mod<$hir>, b: Span, c: hir::HirId);\n+            fn check_mod_post(a: &$hir hir::Mod<$hir>, b: Span, c: hir::HirId);\n+            fn check_foreign_item(a: &$hir hir::ForeignItem<$hir>);\n+            fn check_foreign_item_post(a: &$hir hir::ForeignItem<$hir>);\n+            fn check_item(a: &$hir hir::Item<$hir>);\n+            fn check_item_post(a: &$hir hir::Item<$hir>);\n             fn check_local(a: &$hir hir::Local);\n             fn check_block(a: &$hir hir::Block);\n             fn check_block_post(a: &$hir hir::Block);\n@@ -114,25 +114,25 @@ macro_rules! late_lint_methods {\n             fn check_fn(\n                 a: hir::intravisit::FnKind<$hir>,\n                 b: &$hir hir::FnDecl,\n-                c: &$hir hir::Body,\n+                c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId);\n             fn check_fn_post(\n                 a: hir::intravisit::FnKind<$hir>,\n                 b: &$hir hir::FnDecl,\n-                c: &$hir hir::Body,\n+                c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId\n             );\n-            fn check_trait_item(a: &$hir hir::TraitItem);\n-            fn check_trait_item_post(a: &$hir hir::TraitItem);\n-            fn check_impl_item(a: &$hir hir::ImplItem);\n-            fn check_impl_item_post(a: &$hir hir::ImplItem);\n-            fn check_struct_def(a: &$hir hir::VariantData);\n-            fn check_struct_def_post(a: &$hir hir::VariantData);\n-            fn check_struct_field(a: &$hir hir::StructField);\n-            fn check_variant(a: &$hir hir::Variant);\n-            fn check_variant_post(a: &$hir hir::Variant);\n+            fn check_trait_item(a: &$hir hir::TraitItem<$hir>);\n+            fn check_trait_item_post(a: &$hir hir::TraitItem<$hir>);\n+            fn check_impl_item(a: &$hir hir::ImplItem<$hir>);\n+            fn check_impl_item_post(a: &$hir hir::ImplItem<$hir>);\n+            fn check_struct_def(a: &$hir hir::VariantData<$hir>);\n+            fn check_struct_def_post(a: &$hir hir::VariantData<$hir>);\n+            fn check_struct_field(a: &$hir hir::StructField<$hir>);\n+            fn check_variant(a: &$hir hir::Variant<$hir>);\n+            fn check_variant_post(a: &$hir hir::Variant<$hir>);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n             fn check_path(a: &$hir hir::Path, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n@@ -562,7 +562,7 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n \n     let push = builder.levels.push(&krate.attrs, &store);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n-    for macro_def in &krate.exported_macros {\n+    for macro_def in krate.exported_macros {\n        builder.levels.register_id(macro_def.hir_id);\n     }\n     intravisit::walk_crate(&mut builder, krate);\n@@ -604,13 +604,13 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         });\n     }\n \n-    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n@@ -622,14 +622,14 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n         self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n \n     fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n+                     v: &'tcx hir::Variant<'tcx>,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |builder| {\n@@ -649,13 +649,13 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });"}, {"sha": "96faf567463bff321259c1e531b3ce403f8adaed", "filename": "src/librustc/middle/diagnostic_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -25,15 +25,15 @@ struct DiagnosticItemCollector<'tcx> {\n }\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         self.observe_item(&item.attrs, item.hir_id);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         self.observe_item(&trait_item.attrs, trait_item.hir_id);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         self.observe_item(&impl_item.attrs, impl_item.hir_id);\n     }\n }"}, {"sha": "d87eec05866142eb2c9fe7a65c6d4373d02d65c1", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -113,7 +113,7 @@ struct LanguageItemCollector<'tcx> {\n }\n \n impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let Some((value, span)) = extract(&item.attrs) {\n             let actual_target = Target::from_item(item);\n             match self.item_refs.get(&*value.as_str()).cloned() {\n@@ -151,11 +151,11 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n         // At present, lang items are always items, not trait items.\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n         // At present, lang items are always items, not impl items.\n     }\n }"}, {"sha": "c38ab525ce4558382a601c43182d6b985ce17b0c", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -157,7 +157,7 @@ impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n pub fn collect(tcx: TyCtxt<'_>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     let krate = tcx.hir().krate();\n-    for attr in &krate.non_exported_macro_attrs {\n+    for attr in krate.non_exported_macro_attrs {\n         collector.visit_attribute(attr);\n     }\n     intravisit::walk_crate(&mut collector, krate);"}, {"sha": "6746df6c7ded183ba931fb189217ea9a7f523812", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -27,7 +27,7 @@ use crate::hir::intravisit;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n@@ -47,7 +47,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item, attrs: CodegenFnAt\n \n fn method_might_be_inlined(\n     tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItem,\n+    impl_item: &hir::ImplItem<'_>,\n     impl_src: DefId,\n ) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n@@ -349,7 +349,7 @@ struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n@@ -387,9 +387,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {}\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n         // processed in visit_item above\n     }\n }"}, {"sha": "c5d5bc58112257cdf8e17fb66ad7cb31bb04812c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -715,7 +715,7 @@ impl<'tcx> ScopeTree {\n     pub fn yield_in_scope_for_expr(&self,\n                                    scope: Scope,\n                                    expr_hir_id: hir::HirId,\n-                                   body: &'tcx hir::Body) -> Option<Span> {\n+                                   body: &'tcx hir::Body<'tcx>) -> Option<Span> {\n         self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n             let mut visitor = ExprLocatorVisitor {\n                 hir_id: expr_hir_id,\n@@ -1362,7 +1362,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_block(self, b);\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n         let body_id = body.id();\n         let owner_id = self.tcx.hir().body_owner(body_id);\n \n@@ -1387,7 +1387,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n-        for param in &body.params {\n+        for param in body.params {\n             self.visit_pat(&param.pat);\n         }\n "}, {"sha": "4b838d040596b98b00d279c2479a43b055904248", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -421,7 +421,7 @@ fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n /// In traits, there is an implicit `Self` type parameter which comes before the generics.\n /// We have to account for this when computing the index of the other generic parameters.\n /// This function returns whether there is such an implicit parameter defined on the given item.\n-fn sub_items_have_self_param(node: &hir::ItemKind) -> bool {\n+fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n     match *node {\n         hir::ItemKind::Trait(..) |\n         hir::ItemKind::TraitAlias(..) => true,\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 self.visit_early_late(None, &sig.decl, generics, |this| {\n@@ -536,7 +536,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n             Method(ref sig, _) => {\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n             Method(ref sig, _) => {\n@@ -1167,7 +1167,7 @@ fn signal_shadowing_problem(tcx: TyCtxt<'_>, name: ast::Name, orig: Original, sh\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n+fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     struct GatherLabels<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         scope: ScopeRef<'a>,"}, {"sha": "e1838b13fefb908e0a246847e33da23b522ab343", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, i: &'tcx Item) {\n+    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n         match i.kind {\n@@ -283,13 +283,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         self.annotate(ti.hir_id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let kind = if self.in_trait_impl {\n             AnnotationKind::Prohibited\n         } else {\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n         self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required,\n             |v| {\n                 if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n@@ -312,19 +312,19 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             })\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n         self.annotate(s.hir_id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(i.hir_id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         self.annotate(md.hir_id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n@@ -354,7 +354,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, i: &'tcx Item) {\n+    fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n         match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n@@ -368,12 +368,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_item(self, i)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n         intravisit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().local_def_id(\n             self.tcx.hir().get_parent_item(ii.hir_id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n@@ -382,22 +382,22 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n         self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField<'tcx>) {\n         self.check_missing_stability(s.hir_id, s.span, \"field\");\n         intravisit::walk_struct_field(self, s);\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         self.check_missing_stability(md.hir_id, md.span, \"macro\");\n     }\n }\n@@ -816,7 +816,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n@@ -834,7 +834,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // For implementations of traits, check the stability of each item\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n-            hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(ref t), _, impl_item_refs) => {\n                 if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);"}, {"sha": "2acea7c5b685968de2ec64027d4a4313bc0a69b0", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n         if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n             self.register(lang_item, i.span);\n         }"}, {"sha": "8af98c6117e55b29047914f1866ccaac2a2665d6", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -50,7 +50,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     body_id: hir::HirId,\n     trait_ref: &ty::TraitRef<'tcx>,\n     span: Span,\n-    item: Option<&'tcx hir::Item>,\n+    item: Option<&'tcx hir::Item<'tcx>>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n@@ -111,7 +111,7 @@ struct WfPredicates<'a, 'tcx> {\n     body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n-    item: Option<&'tcx hir::Item>,\n+    item: Option<&'tcx hir::Item<'tcx>>,\n }\n \n /// Controls whether we \"elaborate\" supertraits and so forth on the WF"}, {"sha": "e1750887ac43e95ae625dcdea8db007a7df43e2e", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -232,7 +232,7 @@ impl CodegenCx<'ll, 'tcx> {\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n-                    ref attrs, span, kind: hir::ItemKind::Static(..), ..\n+                    attrs, span, kind: hir::ItemKind::Static(..), ..\n                 }) => {\n                     let sym_str = sym.as_str();\n                     if let Some(g) = self.get_declared_value(&sym_str) {\n@@ -256,7 +256,7 @@ impl CodegenCx<'ll, 'tcx> {\n                     ref attrs, span, kind: hir::ForeignItemKind::Static(..), ..\n                 }) => {\n                     let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), attrs)\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), &**attrs)\n                 }\n \n                 item => bug!(\"get_static: expected static, found {:?}\", item)"}, {"sha": "893aea16fd2b94e216edfa7c76971994c520c67b", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -57,15 +57,15 @@ impl SymbolNamesTest<'tcx> {\n }\n \n impl hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         self.process_attrs(item.hir_id);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         self.process_attrs(trait_item.hir_id);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         self.process_attrs(impl_item.hir_id);\n     }\n }"}, {"sha": "97e4cf7212447ed418fd2a6f6268583ed08419c5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -73,7 +73,7 @@ where\n }\n fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n where\n-    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n+    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate<'_>) -> A,\n {\n     match *ppmode {\n         PpmNormal => {"}, {"sha": "44b610e487bee28e5326f0281993f8d9b9314c8e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -162,22 +162,22 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n         self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }"}, {"sha": "8b692d84b11f3168e942b9b440f5e7c40facb469", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -47,7 +47,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n             available_cgus\n         };\n \n-        for attr in &tcx.hir().krate().attrs {\n+        for attr in tcx.hir().krate().attrs {\n             ams.check_attr(attr);\n         }\n     })"}, {"sha": "7c9ed24f53b02b2331c1d59440e09c9db8ca6d49", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -532,15 +532,15 @@ impl DirtyCleanVisitor<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         self.check_item(item.hir_id, item.span);\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem<'_>) {\n         self.check_item(item.hir_id, item.span);\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem<'_>) {\n         self.check_item(item.hir_id, item.span);\n     }\n }"}, {"sha": "e1c4c86d9d6aa4ff41bc3e9c77c1847f058e58e7", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -446,17 +446,18 @@ fn configure_and_expand_inner<'a>(\n     Ok((krate, resolver))\n }\n \n-pub fn lower_to_hir(\n-    sess: &Session,\n+pub fn lower_to_hir<'res, 'tcx>(\n+    sess: &'tcx Session,\n     lint_store: &lint::LintStore,\n-    resolver: &mut Resolver<'_>,\n-    dep_graph: &DepGraph,\n-    krate: &ast::Crate,\n-) -> Result<hir::map::Forest> {\n+    resolver: &'res mut Resolver<'_>,\n+    dep_graph: &'res DepGraph,\n+    krate: &'res ast::Crate,\n+    arena: &'tcx Arena<'tcx>,\n+) -> Result<hir::map::Forest<'tcx>> {\n     // Lower AST to HIR.\n     let hir_forest = time(sess, \"lowering AST -> HIR\", || {\n         let nt_to_tokenstream = rustc_parse::nt_to_tokenstream;\n-        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream);\n+        let hir_crate = lower_crate(sess, &dep_graph, &krate, resolver, nt_to_tokenstream, arena);\n \n         if sess.opts.debugging_opts.hir_stats {\n             hir_stats::print_hir_stats(&hir_crate);\n@@ -738,7 +739,7 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<lint::LintStore>,\n-    hir_forest: &'tcx hir::map::Forest,\n+    hir_forest: &'tcx hir::map::Forest<'tcx>,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,"}, {"sha": "e3def1756267c48feb491be06a0bb3b5d3abe7ed", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -24,16 +24,16 @@ struct Finder {\n }\n \n impl<'v> ItemLikeVisitor<'v> for Finder {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }\n "}, {"sha": "d6de9d5f4e43cc3854110b4abd3908a718c16168", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -82,7 +82,7 @@ pub struct Queries<'tcx> {\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>,\n+    lower_to_hir: Query<(&'tcx hir::map::Forest<'tcx>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -216,7 +216,7 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn lower_to_hir(\n         &'tcx self,\n-    ) -> Result<&Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>> {\n+    ) -> Result<&Query<(&'tcx hir::map::Forest<'tcx>, Steal<ResolverOutputs>)>> {\n         self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n@@ -229,7 +229,8 @@ impl<'tcx> Queries<'tcx> {\n                     lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n-                    &krate\n+                    &krate,\n+                    &self.arena,\n                 )\n             })?;\n             let hir = self.arena.alloc(hir);"}, {"sha": "de541ef5af3e33c2b43e1a63564f42d63e541d95", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -117,7 +117,7 @@ impl BoxPointers {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(..) |\n             hir::ItemKind::TyAlias(..) |\n@@ -387,10 +387,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext<'_, '_>, krate: &hir::Crate<'_>) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n \n-        for macro_def in &krate.exported_macros {\n+        for macro_def in krate.exported_macros {\n             let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n             if !has_doc {\n                 cx.span_lint(MISSING_DOCS,\n@@ -400,14 +400,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         let desc = match it.kind {\n             hir::ItemKind::Fn(..) => \"a function\",\n             hir::ItemKind::Mod(..) => \"a module\",\n             hir::ItemKind::Enum(..) => \"an enum\",\n             hir::ItemKind::Struct(..) => \"a struct\",\n             hir::ItemKind::Union(..) => \"a union\",\n-            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.hir_id);\n@@ -419,7 +419,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemKind::TyAlias(..) => \"a type alias\",\n-            hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(ref trait_ref), _, impl_item_refs) => {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem<'_>) {\n         if self.private_traits.contains(&trait_item.hir_id) {\n             return;\n         }\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n         if method_context(cx, impl_item.hir_id) == MethodLateContext::TraitImpl {\n             return;\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx,\n                                           Some(sf.hir_id),\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant) {\n+    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant<'_>) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.id),\n                                       &v.attrs,\n@@ -510,7 +510,7 @@ declare_lint! {\n declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n@@ -568,7 +568,7 @@ pub struct MissingDebugImplementations {\n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n@@ -824,7 +824,7 @@ declare_lint! {\n declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GENERIC_ITEMS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n@@ -1001,20 +1001,24 @@ impl UnreachablePub {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n     }\n \n-    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, foreign_item: &hir::ForeignItem) {\n+    fn check_foreign_item(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        foreign_item: &hir::ForeignItem<'tcx>,\n+    ) {\n         self.perform_lint(cx, \"item\", foreign_item.hir_id, &foreign_item.vis,\n                           foreign_item.span, true);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField<'_>) {\n         self.perform_lint(cx, \"field\", field.hir_id, &field.vis, field.span, false);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem<'_>) {\n         self.perform_lint(cx, \"item\", impl_item.hir_id, &impl_item.vis, impl_item.span, false);\n     }\n }\n@@ -1083,7 +1087,7 @@ impl TypeAliasBounds {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         let (ty, type_alias_generics) = match item.kind {\n             hir::ItemKind::TyAlias(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n@@ -1159,7 +1163,7 @@ fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id);\n@@ -1188,7 +1192,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n-        item: &'tcx hir::Item,\n+        item: &'tcx hir::Item<'tcx>,\n     ) {\n         use rustc::ty::fold::TypeFoldable;\n         use rustc::ty::Predicate::*;\n@@ -1347,7 +1351,7 @@ impl UnnameableTestItems {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         if self.items_nameable {\n             if let hir::ItemKind::Mod(..) = it.kind {}\n             else {\n@@ -1366,7 +1370,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n     }\n \n-    fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         if !self.items_nameable && self.boundary == it.hir_id {\n             self.items_nameable = true;\n         }\n@@ -1625,7 +1629,7 @@ impl ExplicitOutlivesRequirements {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n-    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'_>) {\n         use rustc::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;"}, {"sha": "bd2cbee2c348c52f05e0cda9a2798d7bb9550705", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -246,7 +246,13 @@ impl NonSnakeCase {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n-    fn check_mod(&mut self, cx: &LateContext<'_, '_>, _: &'tcx hir::Mod, _: Span, id: hir::HirId) {\n+    fn check_mod(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        _: &'tcx hir::Mod<'tcx>,\n+        _: Span,\n+        id: hir::HirId,\n+    ) {\n         if id != hir::CRATE_HIR_ID {\n             return;\n         }\n@@ -298,7 +304,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         cx: &LateContext<'_, '_>,\n         fk: FnKind<'_>,\n         _: &hir::FnDecl,\n-        _: &hir::Body,\n+        _: &hir::Body<'_>,\n         _: Span,\n         id: hir::HirId,\n     ) {\n@@ -325,13 +331,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Mod(_) = it.kind {\n             self.check_snake_case(cx, \"module\", &it.ident);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = &item.kind {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n@@ -349,7 +355,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_struct_def(\n         &mut self,\n         cx: &LateContext<'_, '_>,\n-        s: &hir::VariantData,\n+        s: &hir::VariantData<'_>,\n     ) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.ident);\n@@ -386,7 +392,7 @@ impl NonUpperCaseGlobals {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n@@ -398,13 +404,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, ti: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, ti: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Const(..) = ti.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ti.ident);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, ii: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, ii: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Const(..) = ii.kind {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ii.ident);\n         }"}, {"sha": "f1cd2037edd7a03043c036d140a56e41e78bcf6b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -1009,7 +1009,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n-    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem<'_>) {\n         let mut vis = ImproperCTypesVisitor { cx };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n         if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n-    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let item_def_id = cx.tcx.hir().local_def_id(it.hir_id);\n             let t = cx.tcx.type_of(item_def_id);"}, {"sha": "2311e0422f65d6d5d381976e5a57434548a15710", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -18,7 +18,7 @@ struct Collector<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n-    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n@@ -33,6 +33,6 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         });\n     }\n \n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n }"}, {"sha": "10dfc3c72e5cf3e7797bb087400e4ebaba25e245", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -26,7 +26,7 @@ struct Collector {\n }\n \n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n-    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n@@ -45,8 +45,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n impl Collector {"}, {"sha": "6ab2027177424c05140fc29182723ea71f248712", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -36,7 +36,7 @@ struct Collector<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n-    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n@@ -129,8 +129,8 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n-    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem<'tcx>) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n impl Collector<'tcx> {"}, {"sha": "cfe5ea65fca5bae088c377e35a10864baf29bd11", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -342,7 +342,7 @@ impl<'tcx> EncodeContext<'tcx> {\n         let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n         self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.module, &krate.attrs, &vis);\n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n-        for macro_def in &krate.exported_macros {\n+        for macro_def in krate.exported_macros {\n             self.visit_macro_def(macro_def);\n         }\n     }\n@@ -682,7 +682,7 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_mod(\n         &mut self,\n         id: hir::HirId,\n-        md: &hir::Mod,\n+        md: &hir::Mod<'_>,\n         attrs: &[ast::Attribute],\n         vis: &hir::Visibility,\n     ) {\n@@ -727,7 +727,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- EntryKind::Field);\n         record!(self.per_def.visibility[def_id] <- field.vis);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- &variant_data.fields()[field_index].attrs);\n+        record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -864,7 +864,7 @@ impl EncodeContext<'tcx> {\n         });\n         record!(self.per_def.visibility[def_id] <- trait_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -945,7 +945,7 @@ impl EncodeContext<'tcx> {\n         });\n         record!(self.per_def.visibility[def_id] <- impl_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- &ast_item.attrs);\n+        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1048,7 +1048,7 @@ impl EncodeContext<'tcx> {\n         self.lazy(rendered_const)\n     }\n \n-    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item) {\n+    fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n@@ -1160,7 +1160,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <-\n             ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n         record!(self.per_def.span[def_id] <- item.span);\n-        record!(self.per_def.attributes[def_id] <- &item.attrs);\n+        record!(self.per_def.attributes[def_id] <- item.attrs);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n             hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n@@ -1271,7 +1271,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     /// Serialize the text of exported macros\n-    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) {\n+    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         use syntax::print::pprust;\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n         record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(MacroDef {\n@@ -1280,7 +1280,7 @@ impl EncodeContext<'tcx> {\n         })));\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- macro_def.span);\n-        record!(self.per_def.attributes[def_id] <- &macro_def.attrs);\n+        record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1525,7 +1525,7 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_foreign_item(\n         &mut self,\n         def_id: DefId,\n-        nitem: &hir::ForeignItem,\n+        nitem: &hir::ForeignItem<'_>,\n     )  {\n         let tcx = self.tcx;\n \n@@ -1551,7 +1551,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <-\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n         record!(self.per_def.span[def_id] <- nitem.span);\n-        record!(self.per_def.attributes[def_id] <- &nitem.attrs);\n+        record!(self.per_def.attributes[def_id] <- nitem.attrs);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1580,7 +1580,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(c.hir_id);\n         self.encode_info_for_anon_const(def_id);\n     }\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n@@ -1590,7 +1590,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         }\n         self.encode_addl_info_for_item(item);\n     }\n-    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.tcx.hir().local_def_id(ni.hir_id);\n         self.encode_info_for_foreign_item(def_id, ni);\n@@ -1599,7 +1599,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n         self.encode_info_for_macro_def(macro_def);\n     }\n }\n@@ -1649,7 +1649,7 @@ impl EncodeContext<'tcx> {\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n+    fn encode_addl_info_for_item(&mut self, item: &hir::Item<'_>) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         match item.kind {\n             hir::ItemKind::Static(..) |\n@@ -1713,7 +1713,7 @@ struct ImplVisitor<'tcx> {\n }\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Impl(..) = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n@@ -1725,9 +1725,9 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n+    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem<'v>) {}\n \n-    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem<'v>) {\n         // handled in `visit_item` above\n     }\n }"}, {"sha": "6b6a58102fa8297a26c226b5de1763762174dfe5", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -552,7 +552,7 @@ fn construct_fn<'a, 'tcx, A>(\n     abi: Abi,\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n-    body: &'tcx hir::Body,\n+    body: &'tcx hir::Body<'tcx>,\n ) -> Body<'tcx>\n where\n     A: Iterator<Item=ArgInfo<'tcx>>"}, {"sha": "4ebf41fb9d21f1d022ed26d40b7e6ac1bede7800", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -76,10 +76,10 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         self.check_patterns(false, &loc.pat);\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n         intravisit::walk_body(self, body);\n \n-        for param in &body.params {\n+        for param in body.params {\n             self.check_irrefutable(&param.pat, \"function argument\", None);\n             self.check_patterns(false, &param.pat);\n         }"}, {"sha": "83a4f224aa257a33fcbb872c6ec71f6b07679fed", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -987,7 +987,7 @@ struct RootCollector<'a, 'tcx> {\n }\n \n impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n+    fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n         match item.kind {\n             hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::Use(..) |\n@@ -1059,12 +1059,12 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'v hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _: &'v hir::TraitItem<'v>) {\n         // Even if there's a default body with no explicit generics,\n         // it's still generic over some `Self: Trait`, so not a root.\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n         match ii.kind {\n             hir::ImplItemKind::Method(hir::FnSig { .. }, _) => {\n                 let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n@@ -1145,7 +1145,7 @@ fn item_requires_monomorphization(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n fn create_mono_items_for_default_impls<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &'tcx hir::Item,\n+    item: &'tcx hir::Item<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     match item.kind {"}, {"sha": "350df5750470ff21c932a03a6d34bb0a4d75a739", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -74,7 +74,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n     }\n     impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n         fn visit_variant_data(&mut self,\n-                              v: &'tcx hir::VariantData,\n+                              v: &'tcx hir::VariantData<'tcx>,\n                               _: ast::Name,\n                               _: &'tcx hir::Generics,\n                               _: hir::HirId,"}, {"sha": "6b5b5c823e8b402cedb04a26ce2b501aa8307d17", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -75,7 +75,7 @@ enum ConstKind {\n }\n \n impl ConstKind {\n-    fn for_body(body: &hir::Body, hir_map: &Map<'_>) -> Option<Self> {\n+    fn for_body(body: &hir::Body<'_>, hir_map: &Map<'_>) -> Option<Self> {\n         let is_const_fn = |id| hir_map.fn_sig_by_hir_id(id).unwrap().header.is_const();\n \n         let owner = hir_map.body_owner(body.id());\n@@ -215,7 +215,7 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n         self.recurse_into(kind, |this| hir::intravisit::walk_anon_const(this, anon));\n     }\n \n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n         let kind = ConstKind::for_body(body, self.tcx.hir());\n         self.recurse_into(kind, |this| hir::intravisit::walk_body(this, body));\n     }"}, {"sha": "3edd010f3115c7e53c77bcd281b9e19a940e09a1", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         self.tables = old_tables;\n     }\n \n-    fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n+    fn visit_variant_data(&mut self, def: &'tcx hir::VariantData<'tcx>, _: ast::Name,\n                           _: &hir::Generics, _: hir::HirId, _: syntax_pos::Span) {\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -355,14 +355,14 @@ fn has_allow_dead_code_or_lang_attr(\n //     * Implementation of a trait method\n struct LifeSeeder<'k, 'tcx> {\n     worklist: Vec<hir::HirId>,\n-    krate: &'k hir::Crate,\n+    krate: &'k hir::Crate<'k>,\n     tcx: TyCtxt<'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n     struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n                                                                item.hir_id,\n                                                                &item.attrs);\n@@ -375,13 +375,13 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n                 }\n \n-                for variant in &enum_def.variants {\n+                for variant in enum_def.variants {\n                     if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n                         self.struct_constructors.insert(ctor_hir_id, variant.id);\n                     }\n                 }\n             }\n-            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.kind {\n@@ -397,7 +397,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref opt_trait, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref opt_trait, _, impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n@@ -417,19 +417,19 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _item: &hir::TraitItem<'_>) {\n         // ignore: we are handling this in `visit_item` above\n     }\n \n-    fn visit_impl_item(&mut self, _item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _item: &hir::ImplItem<'_>) {\n         // ignore: we are handling this in `visit_item` above\n     }\n }\n \n fn create_and_seed_worklist<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n-    krate: &hir::Crate,\n+    krate: &hir::Crate<'_>,\n ) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n@@ -457,7 +457,7 @@ fn create_and_seed_worklist<'tcx>(\n fn find_live<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n-    krate: &hir::Crate,\n+    krate: &hir::Crate<'_>,\n ) -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n@@ -481,7 +481,7 @@ struct DeadVisitor<'tcx> {\n }\n \n impl DeadVisitor<'tcx> {\n-    fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n+    fn should_warn_about_item(&mut self, item: &hir::Item<'_>) -> bool {\n         let should_warn = match item.kind {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n@@ -495,22 +495,22 @@ impl DeadVisitor<'tcx> {\n         should_warn && !self.symbol_is_live(item.hir_id)\n     }\n \n-    fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n+    fn should_warn_about_field(&mut self, field: &hir::StructField<'_>) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n         !field.is_positional()\n             && !self.symbol_is_live(field.hir_id)\n             && !field_type.is_phantom_data()\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &hir::Variant) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::Variant<'_>) -> bool {\n         !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.id,\n                                                  &variant.attrs)\n     }\n \n-    fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n+    fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem<'_>) -> bool {\n         !self.symbol_is_live(fi.hir_id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id, &fi.attrs)\n     }\n@@ -567,7 +567,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if self.should_warn_about_item(item) {\n             // For most items, we want to highlight its identifier\n             let span = match item.kind {\n@@ -610,7 +610,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     }\n \n     fn visit_variant(&mut self,\n-                     variant: &'tcx hir::Variant,\n+                     variant: &'tcx hir::Variant<'tcx>,\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n         if self.should_warn_about_variant(&variant) {\n@@ -621,22 +621,22 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem<'tcx>) {\n         if self.should_warn_about_foreign_item(fi) {\n             self.warn_dead_code(fi.hir_id, fi.span, fi.ident.name,\n                                 fi.kind.descriptive_variant(), \"used\");\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, field: &'tcx hir::StructField<'tcx>) {\n         if self.should_warn_about_field(&field) {\n             self.warn_dead_code(field.hir_id, field.span, field.ident.name, \"field\", \"read\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         match impl_item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n@@ -662,7 +662,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     }\n \n     // Overwrite so that we don't warn the trait item itself.\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         match trait_item.kind {\n             hir::TraitItemKind::Const(_, Some(body_id)) |\n             hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body_id)) => {"}, {"sha": "77ee6ce8513c1f9e0771cf5206b07b2753056c96", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -33,18 +33,18 @@ struct EntryContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx Item) {\n+    fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let def_id = self.map.local_def_id(item.hir_id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem<'tcx>) {\n         // Entry fn is never a trait item.\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem<'tcx>) {\n         // Entry fn is never a trait item.\n     }\n }\n@@ -81,7 +81,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n \n // Beware, this is duplicated in `libsyntax/entry.rs`, so make sure to keep\n // them in sync.\n-fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n+fn entry_point_type(item: &Item<'_>, at_root: bool) -> EntryPointType {\n     match item.kind {\n         ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, sym::start) {\n@@ -104,7 +104,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n }\n \n \n-fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n+fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     match entry_point_type(item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {"}, {"sha": "776c1aff111814148b7297713cde4cd5dd838ab2", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -23,12 +23,12 @@ struct NodeData {\n }\n \n struct StatCollector<'k> {\n-    krate: Option<&'k hir::Crate>,\n+    krate: Option<&'k hir::Crate<'k>>,\n     data: FxHashMap<&'static str, NodeData>,\n     seen: FxHashSet<Id>,\n }\n \n-pub fn print_hir_stats(krate: &hir::Crate) {\n+pub fn print_hir_stats(krate: &hir::Crate<'_>) {\n     let mut collector = StatCollector {\n         krate: Some(krate),\n         data: FxHashMap::default(),\n@@ -123,17 +123,17 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.visit_body(nested_body)\n     }\n \n-    fn visit_item(&mut self, i: &'v hir::Item) {\n+    fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n         self.record(\"Item\", Id::Node(i.hir_id), i);\n         hir_visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: hir::HirId) {\n+    fn visit_mod(&mut self, m: &'v hir::Mod<'v>, _s: Span, n: hir::HirId) {\n         self.record(\"Mod\", Id::None, m);\n         hir_visit::walk_mod(self, m, n)\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem<'v>) {\n         self.record(\"ForeignItem\", Id::Node(i.hir_id), i);\n         hir_visit::walk_foreign_item(self, i)\n     }\n@@ -188,12 +188,12 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_where_predicate(self, predicate)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'v hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'v hir::TraitItem<'v>) {\n         self.record(\"TraitItem\", Id::Node(ti.hir_id), ti);\n         hir_visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n         self.record(\"ImplItem\", Id::Node(ii.hir_id), ii);\n         hir_visit::walk_impl_item(self, ii)\n     }\n@@ -203,13 +203,13 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_param_bound(self, bounds)\n     }\n \n-    fn visit_struct_field(&mut self, s: &'v hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'v hir::StructField<'v>) {\n         self.record(\"StructField\", Id::Node(s.hir_id), s);\n         hir_visit::walk_struct_field(self, s)\n     }\n \n     fn visit_variant(&mut self,\n-                     v: &'v hir::Variant,\n+                     v: &'v hir::Variant<'v>,\n                      g: &'v hir::Generics,\n                      item_id: hir::HirId) {\n         self.record(\"Variant\", Id::None, v);\n@@ -247,7 +247,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef<'v>) {\n         self.record(\"MacroDef\", Id::Node(macro_def.hir_id), macro_def);\n         hir_visit::walk_macro_def(self, macro_def)\n     }"}, {"sha": "d7872f80d260a1fcd4091d5dad45f548affa1ef5", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -28,7 +28,7 @@ struct VarianceTest<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         if let ItemKind::TyAlias(..) = item.kind {\n@@ -40,12 +40,12 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n impl VarianceTest<'tcx> {\n-    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item, attr: &Attribute) {\n+    fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item<'tcx>, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n         let ty = self.tcx.type_of(item_def_id);"}, {"sha": "f18ecb90fc1d033aa8d42e9bea1fe82d2bfa0671", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -371,7 +371,7 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n-    for param in &body.params {\n+    for param in body.params {\n         let is_shorthand = match param.pat.kind {\n             rustc::hir::PatKind::Struct(..) => true,\n             _ => false,\n@@ -1463,8 +1463,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         }\n     }\n \n-    fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for p in &body.params {\n+    fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n+        for p in body.params {\n             self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n                 if self.live_on_entry(ln, var).is_none() {\n                     self.report_dead_assign(hir_id, spans, var, true);"}, {"sha": "8ceef5a4b76098aa969ddd075d5aaa8735a1ba55", "filename": "src/librustc_plugin_impl/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -14,18 +14,18 @@ struct RegistrarFinder {\n }\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }\n "}, {"sha": "83f2fe7e023179dd8fe39567884db4cb54eb5753", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -510,7 +510,7 @@ impl EmbargoVisitor<'tcx> {\n     fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n         let module = self.tcx.hir().get_module(module_def_id).0;\n-        for item_id in &module.item_ids {\n+        for item_id in module.item_ids {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n             if let Some(def_kind) = self.tcx.def_kind(item_def_id) {\n@@ -652,7 +652,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n             hir::ItemKind::Impl(..) =>\n                 Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels),\n@@ -675,7 +675,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         // Update levels of nested things.\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n-                for variant in &def.variants {\n+                for variant in def.variants {\n                     let variant_level = self.update(variant.id, item_level);\n                     if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n                         self.update(ctor_hir_id, item_level);\n@@ -685,14 +685,14 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.hir_id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     self.update(trait_item_ref.id.hir_id, item_level);\n                 }\n@@ -708,7 +708,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n+                for foreign_item in foreign_mod.items {\n                     if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.hir_id, item_level);\n                     }\n@@ -756,7 +756,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates().ty();\n                 }\n             }\n-            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n \n@@ -779,7 +779,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             // Visit everything except for private impl items.\n-            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n \n@@ -798,7 +798,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n-                for variant in &def.variants {\n+                for variant in def.variants {\n                     let variant_level = self.get(variant.id);\n                     if variant_level.is_some() {\n                         for field in variant.data.fields() {\n@@ -812,7 +812,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n+                for foreign_item in foreign_mod.items {\n                     let foreign_item_level = self.get(foreign_item.hir_id);\n                     if foreign_item_level.is_some() {\n                         self.reach(foreign_item.hir_id, foreign_item_level)\n@@ -849,7 +849,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: hir::HirId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, _sp: Span, id: hir::HirId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n@@ -870,7 +870,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         intravisit::walk_mod(self, m, id);\n     }\n \n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         if attr::find_transparency(&md.attrs, md.legacy).0 != Transparency::Opaque {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return\n@@ -992,7 +992,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: hir::HirId) {\n+    fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n         // for each module in `privacy_access_levels`\n     }\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let orig_current_item = mem::replace(&mut self.current_item, item.hir_id);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1013,14 +1013,14 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_mod(&mut self, _m: &'tcx hir::Mod, _s: Span, _n: hir::HirId) {\n+    fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n         // for each module in `privacy_access_levels`\n     }\n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Check types in item interfaces.\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let orig_current_item = mem::replace(&mut self.current_item,\n             self.tcx.hir().local_def_id(item.hir_id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n@@ -1295,14 +1295,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.current_item = orig_current_item;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n@@ -1416,7 +1416,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         match item.kind {\n             // Contents of a private mod can be re-exported, so we need\n             // to check internals.\n@@ -1441,7 +1441,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e., we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // `impl [... for] Public<...>`, but not `impl [... for]\n@@ -1621,7 +1621,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         if self.access_levels.is_reachable(item.hir_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n@@ -1637,7 +1637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n+                     v: &'tcx hir::Variant<'tcx>,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         if self.access_levels.is_reachable(v.id) {\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n         if s.vis.node.is_pub() || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n@@ -1849,7 +1849,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n \n@@ -1872,7 +1872,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 // it's not a part of interface, so we skip it.\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n             }\n-            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., trait_item_refs) => {\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n@@ -1890,15 +1890,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemKind::Enum(ref def, _) => {\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n-                for variant in &def.variants {\n+                for variant in def.variants {\n                     for field in variant.data.fields() {\n                         self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n+                for foreign_item in foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.hir_id, tcx);\n                     self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n@@ -1917,7 +1917,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n                 let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {"}, {"sha": "0e839d35b99c0307565befa6e4cf1b7140e79e0d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -614,9 +614,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Node::TraitRef(tr) => tr.path.res,\n \n             Node::Item(&hir::Item {\n-                kind: hir::ItemKind::Use(ref path, _),\n+                kind: hir::ItemKind::Use(path, _),\n                 ..\n-            }) |\n+            }) => path.res,\n             Node::Visibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.res,\n "}, {"sha": "9e2860946425cf0e2ea77cf3a4c02a5f03bed4e1", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -669,22 +669,22 @@ impl Visitor<'tcx> for ClauseDumper<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         self.process_attrs(item.hir_id, &item.attrs);\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n         self.process_attrs(s.hir_id, &s.attrs);\n         intravisit::walk_struct_field(self, s);\n     }"}, {"sha": "46b9a8d7f912a7a6782ecd682097f67963684cfb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -63,7 +63,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr,\n         opt_kind: Option<ty::ClosureKind>,\n         decl: &'tcx hir::FnDecl,\n-        body: &'tcx hir::Body,\n+        body: &'tcx hir::Body<'tcx>,\n         gen: Option<hir::Movability>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n \n@@ -392,7 +392,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         let expr_map_node = self.tcx.hir().get_if_local(expr_def_id).unwrap();\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         expected_sigs: &ClosureSignatures<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         // Get the signature S that the user gave.\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let astconv: &dyn AstConv<'_> = self;\n \n@@ -788,7 +788,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn closure_sigs(\n         &self,\n         expr_def_id: DefId,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         let liberated_sig = self.tcx()"}, {"sha": "d6661a7ec6aa73128c124528a08681cba4a55804", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -17,7 +17,7 @@ use std::iter;\n \n fn equate_intrinsic_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    it: &hir::ForeignItem,\n+    it: &hir::ForeignItem<'_>,\n     n_tps: usize,\n     abi: Abi,\n     safety: hir::Unsafety,\n@@ -83,7 +83,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n \n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n+pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n@@ -399,7 +399,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| {\n         let name = Symbol::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)"}, {"sha": "e2b77c01e24d00443f68d62f13e721e52f8b0673", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -1002,7 +1002,7 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n     }\n \n     impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n-        fn visit_item(&mut self, i: &'v hir::Item) {\n+        fn visit_item(&mut self, i: &'v hir::Item<'v>) {\n             match i.kind {\n                 hir::ItemKind::Trait(..) |\n                 hir::ItemKind::TraitAlias(..) => {\n@@ -1013,9 +1013,9 @@ fn compute_all_traits(tcx: TyCtxt<'_>) -> Vec<DefId> {\n             }\n         }\n \n-        fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {}\n+        fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n \n-        fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {}\n+        fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {}\n     }\n \n     tcx.hir().krate().visit_all_item_likes(&mut Visitor {\n@@ -1076,7 +1076,7 @@ struct UsePlacementFinder<'tcx> {\n impl UsePlacementFinder<'tcx> {\n     fn check(\n         tcx: TyCtxt<'tcx>,\n-        krate: &'tcx hir::Crate,\n+        krate: &'tcx hir::Crate<'tcx>,\n         target_module: hir::HirId,\n     ) -> (Option<Span>, bool) {\n         let mut finder = UsePlacementFinder {\n@@ -1093,7 +1093,7 @@ impl UsePlacementFinder<'tcx> {\n impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n     fn visit_mod(\n         &mut self,\n-        module: &'tcx hir::Mod,\n+        module: &'tcx hir::Mod<'tcx>,\n         _: Span,\n         hir_id: hir::HirId,\n     ) {\n@@ -1105,7 +1105,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n             return;\n         }\n         // Find a `use` statement.\n-        for item_id in &module.item_ids {\n+        for item_id in module.item_ids {\n             let item = self.tcx.hir().expect_item(item_id.id);\n             match item.kind {\n                 hir::ItemKind::Use(..) => {\n@@ -1127,7 +1127,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n                             self.span = Some(item.span.shrink_to_lo());\n                         } else {\n                             // Find the first attribute on the item.\n-                            for attr in &item.attrs {\n+                            for attr in item.attrs {\n                                 if self.span.map_or(true, |span| attr.span < span) {\n                                     self.span = Some(attr.span.shrink_to_lo());\n                                 }"}, {"sha": "5895b8d25d3d6f0c7303bc240bf87d12a1224eea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -751,11 +751,11 @@ struct CheckItemTypesVisitor<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n-    fn visit_item(&mut self, i: &'tcx hir::Item) {\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         check_item_type(self.tcx, i);\n     }\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) { }\n }\n \n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n@@ -1260,7 +1260,7 @@ fn check_fn<'a, 'tcx>(\n     fn_sig: ty::FnSig<'tcx>,\n     decl: &'tcx hir::FnDecl,\n     fn_id: hir::HirId,\n-    body: &'tcx hir::Body,\n+    body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n     let mut fn_sig = fn_sig.clone();\n@@ -1327,7 +1327,7 @@ fn check_fn<'a, 'tcx>(\n     for (param_ty, param) in\n         fn_sig.inputs().iter().copied()\n             .chain(maybe_va_list)\n-            .zip(&body.params)\n+            .zip(body.params)\n     {\n         // Check the pattern.\n         fcx.check_pat_top(&param.pat, param_ty, None);\n@@ -1696,7 +1696,7 @@ fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n     }\n }\n \n-pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n+pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n@@ -1766,15 +1766,15 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item) {\n             check_abi(tcx, it.span, m.abi);\n \n             if m.abi == Abi::RustIntrinsic {\n-                for item in &m.items {\n+                for item in m.items {\n                     intrinsic::check_intrinsic_type(tcx, item);\n                 }\n             } else if m.abi == Abi::PlatformIntrinsic {\n-                for item in &m.items {\n+                for item in m.items {\n                     intrinsic::check_platform_intrinsic_type(tcx, item);\n                 }\n             } else {\n-                for item in &m.items {\n+                for item in m.items {\n                     let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -1857,15 +1857,15 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     }\n }\n \n-fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item) {\n+fn check_on_unimplemented(tcx: TyCtxt<'_>, trait_def_id: DefId, item: &hir::Item<'_>) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n fn report_forbidden_specialization(\n     tcx: TyCtxt<'_>,\n-    impl_item: &hir::ImplItem,\n+    impl_item: &hir::ImplItem<'_>,\n     parent_impl: DefId,\n ) {\n     let mut err = struct_span_err!(\n@@ -1895,7 +1895,7 @@ fn check_specialization_validity<'tcx>(\n     trait_def: &ty::TraitDef,\n     trait_item: &ty::AssocItem,\n     impl_id: DefId,\n-    impl_item: &hir::ImplItem,\n+    impl_item: &hir::ImplItem<'_>,\n ) {\n     let kind = match impl_item.kind {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n@@ -2444,7 +2444,12 @@ fn check_transparent(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], id: hir::HirId) {\n+pub fn check_enum<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    vs: &'tcx [hir::Variant<'tcx>],\n+    id: hir::HirId,\n+) {\n     let def_id = tcx.hir().local_def_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -2481,12 +2486,12 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n \n     if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n         let is_unit =\n-            |var: &hir::Variant| match var.data {\n+            |var: &hir::Variant<'_>| match var.data {\n                 hir::VariantData::Unit(..) => true,\n                 _ => false\n             };\n \n-        let has_disr = |var: &hir::Variant| var.disr_expr.is_some();\n+        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n         let has_non_units = vs.iter().any(|var| !is_unit(var));\n         let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n         let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n@@ -4708,7 +4713,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(Node::ForeignItem(hir::ForeignItem {\n                     kind: hir::ForeignItemKind::Fn(_, idents, _),\n                     ..\n-                })) |\n+                })) => sugg_call = idents.iter()\n+                        .map(|ident| if ident.name != kw::SelfLower {\n+                            ident.to_string()\n+                        } else {\n+                            \"_\".to_string()\n+                        }).collect::<Vec<_>>()\n+                        .join(\", \"),\n                 Some(Node::TraitItem(hir::TraitItem {\n                     kind: hir::TraitItemKind::Method(.., hir::TraitMethod::Required(idents)),\n                     .."}, {"sha": "396ff5ce5189cf76308694dad69b7530191a5a9f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -106,7 +106,7 @@ macro_rules! ignore_err {\n // PUBLIC ENTRY POINTS\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn regionck_expr(&self, body: &'tcx hir::Body) {\n+    pub fn regionck_expr(&self, body: &'tcx hir::Body<'tcx>) {\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let id = body.value.hir_id;\n         let mut rcx = RegionCtxt::new(\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'tcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'tcx hir::Body<'tcx>) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn visit_fn_body(\n         &mut self,\n         id: hir::HirId, // the id of the fn itself\n-        body: &'tcx hir::Body,\n+        body: &'tcx hir::Body<'tcx>,\n         span: Span,\n     ) {\n         // When we enter a function, we can derive"}, {"sha": "2788aa6b83ef04d1c86a20f7b423ad9cdf5bd1e1", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -46,7 +46,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn closure_analyze(&self, body: &'tcx hir::Body) {\n+    pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n         InferBorrowKindVisitor { fcx: self }.visit_body(body);\n \n         // it's our job to process these.\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_hir_id: hir::HirId,\n         span: Span,\n-        body: &hir::Body,\n+        body: &hir::Body<'_>,\n         capture_clause: hir::CaptureBy,\n     ) {\n "}, {"sha": "e974b070dbd5bfc111ef1e00b5fb0214c1e90a9a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -235,7 +235,7 @@ fn check_associated_item(\n     })\n }\n \n-fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item) -> CheckWfFcxBuilder<'tcx> {\n+fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<'tcx> {\n     for_id(tcx, item.hir_id, item.span)\n }\n \n@@ -252,7 +252,7 @@ fn for_id(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) -> CheckWfFcxBuilder<'_>\n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n fn check_type_defn<'tcx, F>(\n     tcx: TyCtxt<'tcx>,\n-    item: &hir::Item,\n+    item: &hir::Item<'tcx>,\n     all_sized: bool,\n     mut lookup_fields: F,\n ) where\n@@ -325,7 +325,7 @@ fn check_type_defn<'tcx, F>(\n     });\n }\n \n-fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item) {\n+fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     debug!(\"check_trait: {:?}\", item.hir_id);\n \n     let trait_def_id = tcx.hir().local_def_id(item.hir_id);\n@@ -348,7 +348,7 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item) {\n     });\n }\n \n-fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item) {\n+fn check_item_fn(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n         let def_id = fcx.tcx.hir().local_def_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n@@ -396,7 +396,7 @@ fn check_item_type(\n \n fn check_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &'tcx hir::Item,\n+    item: &'tcx hir::Item<'tcx>,\n     ast_self_ty: &hir::Ty,\n     ast_trait_ref: &Option<hir::TraitRef>,\n ) {\n@@ -977,7 +977,7 @@ fn receiver_is_implemented(\n \n fn check_variances_for_type_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &hir::Item,\n+    item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics,\n ) {\n     let item_def_id = tcx.hir().local_def_id(item.hir_id);\n@@ -1081,19 +1081,19 @@ impl CheckTypeWellFormedVisitor<'tcx> {\n }\n \n impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n-    fn visit_item(&self, i: &'tcx hir::Item) {\n+    fn visit_item(&self, i: &'tcx hir::Item<'tcx>) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n     }\n \n-    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n     }\n \n-    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n         let def_id = self.tcx.hir().local_def_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);\n@@ -1113,7 +1113,7 @@ struct AdtField<'tcx> {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n+    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n         let fields = struct_def.fields().iter().map(|field| {\n             let field_ty = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n             let field_ty = self.normalize_associated_types_in(field.span,\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         AdtVariant { fields }\n     }\n \n-    fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n+    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n         enum_def.variants.iter()\n             .map(|variant| self.non_enum_variant(&variant.data))\n             .collect()"}, {"sha": "a32c98068da5a443e7c09b991a96390406f5f494", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -32,7 +32,9 @@ use std::mem;\n // resolve_type_vars_in_body, which creates a new TypeTables which\n // doesn't contain any inference types.\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self, body: &'tcx hir::Body) -> &'tcx ty::TypeckTables<'tcx> {\n+    pub fn resolve_type_vars_in_body(&self, body: &'tcx hir::Body<'tcx>)\n+        -> &'tcx ty::TypeckTables<'tcx>\n+    {\n         let item_id = self.tcx.hir().body_owner(body.id());\n         let item_def_id = self.tcx.hir().local_def_id(item_id);\n \n@@ -41,7 +43,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let rustc_dump_user_substs = self.tcx.has_attr(item_def_id, sym::rustc_dump_user_substs);\n \n         let mut wbcx = WritebackCx::new(self, body, rustc_dump_user_substs);\n-        for param in &body.params {\n+        for param in body.params {\n             wbcx.visit_node_id(param.pat.span, param.hir_id);\n         }\n         // Type only exists for constants and statics, not functions.\n@@ -102,15 +104,15 @@ struct WritebackCx<'cx, 'tcx> {\n \n     tables: ty::TypeckTables<'tcx>,\n \n-    body: &'tcx hir::Body,\n+    body: &'tcx hir::Body<'tcx>,\n \n     rustc_dump_user_substs: bool,\n }\n \n impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn new(\n         fcx: &'cx FnCtxt<'cx, 'tcx>,\n-        body: &'tcx hir::Body,\n+        body: &'tcx hir::Body<'tcx>,\n         rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id;\n@@ -265,7 +267,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n         match e.kind {\n             hir::ExprKind::Closure(_, _, body, _, _) => {\n                 let body = self.fcx.tcx.hir().body(body);\n-                for param in &body.params {\n+                for param in body.params {\n                     self.visit_node_id(e.span, param.hir_id);\n                 }\n \n@@ -698,14 +700,14 @@ struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,\n-    body: &'tcx hir::Body,\n+    body: &'tcx hir::Body<'tcx>,\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     fn new(\n         fcx: &'cx FnCtxt<'cx, 'tcx>,\n         span: &'cx dyn Locatable,\n-        body: &'tcx hir::Body,\n+        body: &'tcx hir::Body<'tcx>,\n     ) -> Resolver<'cx, 'tcx> {\n         Resolver {\n             tcx: fcx.tcx,"}, {"sha": "7377c4df9790730e44a614efac123e81ecb2a202", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -29,7 +29,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n }\n \n impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n@@ -38,10 +38,10 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }\n \n@@ -217,7 +217,7 @@ struct ExternCrateToLint {\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n             let extern_crate_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             self.crates_to_lint.push(\n@@ -231,9 +231,9 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }"}, {"sha": "16fe6d529a417664879066ae97cdb692b6b4f9c6", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -50,7 +50,7 @@ struct InherentCollect<'tcx> {\n }\n \n impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let ty = match item.kind {\n             hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n             _ => return\n@@ -254,15 +254,15 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }\n \n impl InherentCollect<'tcx> {\n-    fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n+    fn check_def_id(&mut self, item: &hir::Item<'_>, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and"}, {"sha": "1acbf0795a6b660bbe4fa80abb36e6c175ea5fea", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -85,7 +85,7 @@ impl InherentOverlapChecker<'tcx> {\n }\n \n impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n+    fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n         match item.kind {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n@@ -98,9 +98,9 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'v>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'v>) {\n     }\n }"}, {"sha": "109609f5d49753e35334562a65c3a8cab5174b6b", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -23,7 +23,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// apply to a specific impl, so just return after reporting one\n     /// to prevent inundating the user with a bunch of similar error\n     /// reports.\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., generics, Some(tr), impl_ty, _) = &item.kind {\n@@ -218,9 +218,9 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }"}, {"sha": "324ac0a0f355880fa687c9ce49523643e5af0b09", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -18,7 +18,7 @@ struct UnsafetyChecker<'tcx> {\n \n impl UnsafetyChecker<'tcx> {\n     fn check_unsafety_coherence(&mut self,\n-                                item: &'v hir::Item,\n+                                item: &'v hir::Item<'v>,\n                                 impl_generics: Option<&hir::Generics>,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity)\n@@ -72,15 +72,15 @@ impl UnsafetyChecker<'tcx> {\n }\n \n impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n+    fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n         if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.kind {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n     }\n }"}, {"sha": "8d93d0b4c701a8a25160f32cfdb24de205bad867", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -111,7 +111,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         convert_item(self.tcx, item.hir_id);\n         intravisit::walk_item(self, item);\n     }\n@@ -145,12 +145,12 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         convert_trait_item(self.tcx, trait_item.hir_id);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         convert_impl_item(self.tcx, impl_item.hir_id);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n@@ -426,7 +426,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-            for item in &foreign_mod.items {\n+            for item in foreign_mod.items {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n                 tcx.generics_of(def_id);\n                 tcx.type_of(def_id);\n@@ -538,7 +538,7 @@ fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n fn convert_enum_variant_types(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n-    variants: &[hir::Variant]\n+    variants: &[hir::Variant<'_>]\n ) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n@@ -593,7 +593,7 @@ fn convert_variant(\n     ctor_did: Option<DefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n-    def: &hir::VariantData,\n+    def: &hir::VariantData<'_>,\n     adt_kind: ty::AdtKind,\n     parent_did: DefId,\n ) -> ty::VariantDef {\n@@ -1702,7 +1702,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n-        fn visit_item(&mut self, it: &'tcx Item) {\n+        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n@@ -1711,7 +1711,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 intravisit::walk_item(self, it);\n             }\n         }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n+        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n@@ -1720,7 +1720,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n+        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             self.check(def_id);\n@@ -2061,8 +2061,6 @@ fn explicit_predicates_of(\n \n     const NO_GENERICS: &hir::Generics = &hir::Generics::empty();\n \n-    let empty_trait_items = HirVec::new();\n-\n     let mut predicates = UniquePredicates::new();\n \n     let ast_generics = match node {\n@@ -2107,12 +2105,12 @@ fn explicit_predicates_of(\n                 | ItemKind::Struct(_, ref generics)\n                 | ItemKind::Union(_, ref generics) => generics,\n \n-                ItemKind::Trait(_, _, ref generics, .., ref items) => {\n+                ItemKind::Trait(_, _, ref generics, .., items) => {\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n                 ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), &empty_trait_items));\n+                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), &[]));\n                     generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {"}, {"sha": "7e67d30db18435b49000b22655849ce2ef0a548c", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -131,10 +131,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn consume_body(&mut self, body: &hir::Body) {\n+    pub fn consume_body(&mut self, body: &hir::Body<'_>) {\n         debug!(\"consume_body(body={:?})\", body);\n \n-        for param in &body.params {\n+        for param in body.params {\n             let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);\n "}, {"sha": "7bcc5386445ec35ca20e53e964b668d89d939d79", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -79,7 +79,7 @@ struct ImplWfCheck<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.kind {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n             enforce_impl_params_are_constrained(self.tcx,\n@@ -89,9 +89,9 @@ impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) { }\n+    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem<'tcx>) { }\n \n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem<'tcx>) { }\n }\n \n fn enforce_impl_params_are_constrained("}, {"sha": "553c93e09582fededeb93dfa5c14ff1cb32aadd5", "filename": "src/librustc_typeck/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fnamespace.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -19,8 +19,8 @@ impl From<ty::AssocKind> for Namespace {\n     }\n }\n \n-impl<'a> From <&'a hir::ImplItemKind> for Namespace {\n-    fn from(impl_kind: &'a hir::ImplItemKind) -> Self {\n+impl<'a> From <&'a hir::ImplItemKind<'_>> for Namespace {\n+    fn from(impl_kind: &'a hir::ImplItemKind<'_>) -> Self {\n         match *impl_kind {\n             hir::ImplItemKind::OpaqueTy(..) |\n             hir::ImplItemKind::TyAlias(..) => Namespace::Type,"}, {"sha": "e3947a84989e769b2351173cbec39a8e13f5cc6c", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -51,7 +51,7 @@ pub struct InferVisitor<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let item_did = self.tcx.hir().local_def_id(item.hir_id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n@@ -113,9 +113,9 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) {}\n+    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem<'tcx>) {}\n \n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {}\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n fn insert_required_predicates_to_be_wf<'tcx>("}, {"sha": "081d0ff1e160033b476966be82f189d206c6000c", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -16,7 +16,7 @@ struct OutlivesTest<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_outlives\"\n@@ -33,6 +33,6 @@ impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {}\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) {}\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) {}\n }"}, {"sha": "64357cb4a3d058e312ed39329c81ddea47199360", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -67,7 +67,7 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         match item.kind {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n@@ -81,7 +81,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.visit_node_helper(item.hir_id);\n \n-                for variant in &enum_def.variants {\n+                for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n                         self.visit_node_helper(variant.data.ctor_hir_id().unwrap());\n                     }\n@@ -93,7 +93,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n+                for foreign_item in foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n                         self.visit_node_helper(foreign_item.hir_id);\n                     }\n@@ -104,13 +104,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Method(..) = trait_item.kind {\n             self.visit_node_helper(trait_item.hir_id);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Method(..) = impl_item.kind {\n             self.visit_node_helper(impl_item.hir_id);\n         }"}, {"sha": "95f361763e86de03ecbdb1127e6e0187aa3b3e02", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n         debug!(\"add_inferreds for item {}\",\n                self.tcx.hir().node_to_string(item.hir_id));\n \n@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.add_inferreds_for_item(item.hir_id);\n \n-                for variant in &enum_def.variants {\n+                for variant in enum_def.variants {\n                     if let hir::VariantData::Tuple(..) = variant.data {\n                         self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n                     }\n@@ -156,7 +156,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n             }\n \n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n+                for foreign_item in foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.kind {\n                         self.add_inferreds_for_item(foreign_item.hir_id);\n                     }\n@@ -167,13 +167,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem<'_>) {\n         if let hir::TraitItemKind::Method(..) = trait_item.kind {\n             self.add_inferreds_for_item(trait_item.hir_id);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Method(..) = impl_item.kind {\n             self.add_inferreds_for_item(impl_item.hir_id);\n         }"}, {"sha": "1233be43e09fa31bfbfc2c18475255192e9c9730", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -14,7 +14,7 @@ struct VarianceTest<'tcx> {\n }\n \n impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n         // For unit testing: check for a special \"rustc_variance\"\n@@ -29,6 +29,6 @@ impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem<'tcx>) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem<'tcx>) { }\n }"}, {"sha": "03fb0d9997822cb14f1c2318b673448bbace03d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -70,6 +70,12 @@ impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n     }\n }\n \n+impl<T: Clean<U>, U> Clean<U> for &T {\n+    fn clean(&self, cx: &DocContext<'_>) -> U {\n+        (**self).clean(cx)\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> U {\n         (**self).clean(cx)\n@@ -1081,7 +1087,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n     }\n }\n \n-impl Clean<Item> for hir::TraitItem {\n+impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n@@ -1122,7 +1128,7 @@ impl Clean<Item> for hir::TraitItem {\n     }\n }\n \n-impl Clean<Item> for hir::ImplItem {\n+impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n@@ -1738,7 +1744,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     }\n }\n \n-impl Clean<Item> for hir::StructField {\n+impl Clean<Item> for hir::StructField<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n \n@@ -1831,7 +1837,7 @@ impl Clean<Item> for doctree::Union<'_> {\n     }\n }\n \n-impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n+impl Clean<VariantStruct> for ::rustc::hir::VariantData<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n@@ -1918,7 +1924,7 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-impl Clean<VariantKind> for hir::VariantData {\n+impl Clean<VariantKind> for hir::VariantData<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantKind {\n         match self {\n             hir::VariantData::Struct(..) => VariantKind::Struct(self.clean(cx)),\n@@ -2387,12 +2393,6 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n-impl<'a> Clean<Stability> for &'a attr::Stability {\n-    fn clean(&self, dc: &DocContext<'_>) -> Stability {\n-        (**self).clean(dc)\n-    }\n-}\n-\n impl Clean<Deprecation> for attr::Deprecation {\n     fn clean(&self, _: &DocContext<'_>) -> Deprecation {\n         Deprecation {"}, {"sha": "ae62b743f9d8cdd37234e5123b5d64d105f83d88", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -9,7 +9,6 @@ use syntax_pos::{self, Span};\n \n use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n-use rustc::hir::ptr::P;\n \n pub struct Module<'hir> {\n     pub name: Option<Name>,\n@@ -90,7 +89,7 @@ pub struct Struct<'hir> {\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n     pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField],\n+    pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n@@ -101,7 +100,7 @@ pub struct Union<'hir> {\n     pub name: Name,\n     pub generics: &'hir hir::Generics,\n     pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField],\n+    pub fields: &'hir [hir::StructField<'hir>],\n     pub whence: Span,\n }\n \n@@ -119,7 +118,7 @@ pub struct Variant<'hir> {\n     pub name: Name,\n     pub id: hir::HirId,\n     pub attrs: &'hir [ast::Attribute],\n-    pub def: &'hir hir::VariantData,\n+    pub def: &'hir hir::VariantData<'hir>,\n     pub whence: Span,\n }\n \n@@ -136,7 +135,7 @@ pub struct Function<'hir> {\n }\n \n pub struct Typedef<'hir> {\n-    pub ty: &'hir P<hir::Ty>,\n+    pub ty: &'hir hir::Ty,\n     pub gen: &'hir hir::Generics,\n     pub name: Name,\n     pub id: hir::HirId,\n@@ -156,7 +155,7 @@ pub struct OpaqueTy<'hir> {\n \n #[derive(Debug)]\n pub struct Static<'hir> {\n-    pub type_: &'hir P<hir::Ty>,\n+    pub type_: &'hir hir::Ty,\n     pub mutability: hir::Mutability,\n     pub expr: hir::BodyId,\n     pub name: Name,\n@@ -167,7 +166,7 @@ pub struct Static<'hir> {\n }\n \n pub struct Constant<'hir> {\n-    pub type_: &'hir P<hir::Ty>,\n+    pub type_: &'hir hir::Ty,\n     pub expr: hir::BodyId,\n     pub name: Name,\n     pub attrs: &'hir [ast::Attribute],\n@@ -180,7 +179,7 @@ pub struct Trait<'hir> {\n     pub is_auto: hir::IsAuto,\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: Vec<&'hir hir::TraitItem>,\n+    pub items: Vec<&'hir hir::TraitItem<'hir>>,\n     pub generics: &'hir hir::Generics,\n     pub bounds: &'hir [hir::GenericBound],\n     pub attrs: &'hir [ast::Attribute],\n@@ -206,8 +205,8 @@ pub struct Impl<'hir> {\n     pub defaultness: hir::Defaultness,\n     pub generics: &'hir hir::Generics,\n     pub trait_: &'hir Option<hir::TraitRef>,\n-    pub for_: &'hir P<hir::Ty>,\n-    pub items: Vec<&'hir hir::ImplItem>,\n+    pub for_: &'hir hir::Ty,\n+    pub items: Vec<&'hir hir::ImplItem<'hir>>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n     pub vis: &'hir hir::Visibility,\n@@ -218,7 +217,7 @@ pub struct ForeignItem<'hir> {\n     pub vis: &'hir hir::Visibility,\n     pub id: hir::HirId,\n     pub name: Name,\n-    pub kind: &'hir hir::ForeignItemKind,\n+    pub kind: &'hir hir::ForeignItemKind<'hir>,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n }"}, {"sha": "897c00f276e9fdb705059372ca4b5ce7bfe4b435", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=26286c7ad0e8a5efc1e6a8ef88ffd64723112ae8", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub fn visit(mut self, krate: &'tcx hir::Crate) -> Module<'tcx> {\n         let mut module = self.visit_mod_contents(krate.span,\n-                                              &krate.attrs,\n+                                              krate.attrs,\n                                               &Spanned { span: syntax_pos::DUMMY_SP,\n                                                         node: hir::VisibilityKind::Public },\n                                               hir::CRATE_HIR_ID,\n@@ -213,9 +213,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_mod_contents(&mut self, span: Span, attrs: &'tcx hir::HirVec<ast::Attribute>,\n+    fn visit_mod_contents(&mut self, span: Span, attrs: &'tcx [ast::Attribute],\n                               vis: &'tcx hir::Visibility, id: hir::HirId,\n-                              m: &'tcx hir::Mod,\n+                              m: &'tcx hir::Mod<'tcx>,\n                               name: Option<ast::Name>) -> Module<'tcx> {\n         let mut om = Module::new(name, attrs, vis);\n         om.where_outer = span;\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n-        for i in &m.item_ids {\n+        for i in m.item_ids {\n             let item = self.cx.tcx.hir().expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n@@ -322,7 +322,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let ret = match tcx.hir().get(res_hir_id) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                for i in &m.item_ids {\n+                for i in m.item_ids {\n                     let i = self.cx.tcx.hir().expect_item(i.id);\n                     self.visit_item(i, None, om);\n                 }\n@@ -363,7 +363,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         match item.kind {\n             hir::ItemKind::ForeignMod(ref fm) => {\n-                for item in &fm.items {\n+                for item in fm.items {\n                     self.visit_foreign_item(item, None, om);\n                 }\n             }\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.unions.push(self.visit_union_data(item, ident.name, sd, gen)),\n             hir::ItemKind::Fn(ref sig, ref gen, body) =>\n                 self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body),\n-            hir::ItemKind::TyAlias(ref ty, ref gen) => {\n+            hir::ItemKind::TyAlias(ty, ref gen) => {\n                 let t = Typedef {\n                     ty,\n                     gen,\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.opaque_tys.push(t);\n             },\n-            hir::ItemKind::Static(ref type_, mutability, expr) => {\n+            hir::ItemKind::Static(type_, mutability, expr) => {\n                 let s = Static {\n                     type_,\n                     mutability,\n@@ -476,7 +476,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.statics.push(s);\n             },\n-            hir::ItemKind::Const(ref type_, expr) => {\n+            hir::ItemKind::Const(type_, expr) => {\n                 let s = Constant {\n                     type_,\n                     expr,\n@@ -524,7 +524,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                           defaultness,\n                           ref generics,\n                           ref trait_,\n-                          ref for_,\n+                          for_,\n                           ref item_ids) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located."}]}