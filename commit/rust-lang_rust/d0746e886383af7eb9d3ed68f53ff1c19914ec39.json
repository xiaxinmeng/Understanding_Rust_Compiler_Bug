{"sha": "d0746e886383af7eb9d3ed68f53ff1c19914ec39", "node_id": "C_kwDOAAsO6NoAKGQwNzQ2ZTg4NjM4M2FmN2ViOWQzZWQ2OGY1M2ZmMWMxOTkxNGVjMzk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-04T21:35:13Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-08T01:54:59Z"}, "message": "Simplify printing operator lang item paths in error message", "tree": {"sha": "ec057c8da1acf21dda98b189f55f44f1d499d2fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec057c8da1acf21dda98b189f55f44f1d499d2fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0746e886383af7eb9d3ed68f53ff1c19914ec39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0746e886383af7eb9d3ed68f53ff1c19914ec39", "html_url": "https://github.com/rust-lang/rust/commit/d0746e886383af7eb9d3ed68f53ff1c19914ec39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0746e886383af7eb9d3ed68f53ff1c19914ec39/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c9d3d2ee99d7350bd9625fc098a4297c9a3523", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c9d3d2ee99d7350bd9625fc098a4297c9a3523", "html_url": "https://github.com/rust-lang/rust/commit/00c9d3d2ee99d7350bd9625fc098a4297c9a3523"}], "stats": {"total": 259, "additions": 109, "deletions": 150}, "files": [{"sha": "c269a9a0c46cea3e59c814a66aeb343ea463721e", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 109, "deletions": 150, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/d0746e886383af7eb9d3ed68f53ff1c19914ec39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0746e886383af7eb9d3ed68f53ff1c19914ec39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=d0746e886383af7eb9d3ed68f53ff1c19914ec39", "patch": "@@ -11,6 +11,7 @@ use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n@@ -313,7 +314,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // error types are considered \"builtin\"\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n-                let (mut err, missing_trait, use_output) = match is_assign {\n+                let (_, item) = lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n+                let missing_trait =\n+                    item.map(|def_id| with_no_trimmed_paths!(self.tcx.def_path_str(def_id)));\n+                let (mut err, use_output) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -327,112 +331,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             lhs_expr.span,\n                             format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n                         );\n-                        let missing_trait = match op.node {\n-                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                            _ => None,\n-                        };\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, false)\n+                        (err, false)\n                     }\n                     IsAssign::No => {\n-                        let (message, missing_trait, use_output) = match op.node {\n-                            hir::BinOpKind::Add => (\n-                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\"),\n-                                Some(\"std::ops::Add\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Sub => (\n-                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\"),\n-                                Some(\"std::ops::Sub\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Mul => (\n-                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Mul\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Div => (\n-                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Div\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Rem => (\n-                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Rem\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitAnd => (\n-                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\"),\n-                                Some(\"std::ops::BitAnd\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitXor => (\n-                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\"),\n-                                Some(\"std::ops::BitXor\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitOr => (\n-                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\"),\n-                                Some(\"std::ops::BitOr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shl => (\n-                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\"),\n-                                Some(\"std::ops::Shl\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shr => (\n-                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\"),\n-                                Some(\"std::ops::Shr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialEq\"),\n-                                false,\n-                            ),\n-                            hir::BinOpKind::Lt\n-                            | hir::BinOpKind::Le\n-                            | hir::BinOpKind::Gt\n-                            | hir::BinOpKind::Ge => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialOrd\"),\n-                                false,\n-                            ),\n-                            _ => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                None,\n-                                false,\n+                        let message = match op.node {\n+                            hir::BinOpKind::Add => {\n+                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Sub => {\n+                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Mul => {\n+                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Div => {\n+                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Rem => {\n+                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitAnd => {\n+                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitXor => {\n+                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitOr => {\n+                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shl => {\n+                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shr => {\n+                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\")\n+                            }\n+                            _ => format!(\n+                                \"binary operation `{}` cannot be applied to type `{}`\",\n+                                op.node.as_str(),\n+                                lhs_ty\n                             ),\n                         };\n+                        let use_output = item.map_or(false, |def_id| {\n+                            self.tcx.associated_item_def_ids(def_id).iter().any(|item_def_id| {\n+                                self.tcx.opt_associated_item(*item_def_id).unwrap().name\n+                                    == sym::Output\n+                            })\n+                        });\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n                             err.span_label(lhs_expr.span, lhs_ty.to_string());\n                             err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, use_output)\n+                        (err, use_output)\n                     }\n                 };\n \n@@ -773,64 +725,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n-        let lang = self.tcx.lang_items();\n-\n         let span = match op {\n             Op::Binary(op, _) => op.span,\n             Op::Unary(_, span) => span,\n         };\n-        let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n-                hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n-                hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n-                hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n-                hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n-                hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n-                hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n-                hir::BinOpKind::Lt\n-                | hir::BinOpKind::Le\n-                | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt\n-                | hir::BinOpKind::Eq\n-                | hir::BinOpKind::Ne\n-                | hir::BinOpKind::And\n-                | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n-                }\n-            }\n-        } else if let Op::Binary(op, IsAssign::No) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n-                hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n-                hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n-                hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n-                hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n-                hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n-                hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n-                hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n-                hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n-                hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n-                hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n-                hir::BinOpKind::And | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"&& and || are not overloadable\")\n-                }\n-            }\n-        } else if let Op::Unary(hir::UnOp::Not, _) = op {\n-            (sym::not, lang.not_trait())\n-        } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n-            (sym::neg, lang.neg_trait())\n-        } else {\n-            bug!(\"lookup_op_method: op not supported: {:?}\", op)\n-        };\n+        let (opname, trait_did) = lang_item_for_op(self.tcx, op, span);\n \n         debug!(\n             \"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n@@ -891,6 +790,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+fn lang_item_for_op(\n+    tcx: TyCtxt<'_>,\n+    op: Op,\n+    span: Span,\n+) -> (rustc_span::Symbol, Option<hir::def_id::DefId>) {\n+    let lang = tcx.lang_items();\n+    if let Op::Binary(op, IsAssign::Yes) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n+            hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n+            hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n+            hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n+            hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n+            hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n+            hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n+            hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::And\n+            | hir::BinOpKind::Or => {\n+                span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n+            }\n+        }\n+    } else if let Op::Binary(op, IsAssign::No) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n+            hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n+            hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n+            hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n+            hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n+            hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n+            hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n+            hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n+            hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n+            hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n+            hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n+            hir::BinOpKind::And | hir::BinOpKind::Or => {\n+                span_bug!(span, \"&& and || are not overloadable\")\n+            }\n+        }\n+    } else if let Op::Unary(hir::UnOp::Not, _) = op {\n+        (sym::not, lang.not_trait())\n+    } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n+        (sym::neg, lang.neg_trait())\n+    } else {\n+        bug!(\"lookup_op_method: op not supported: {:?}\", op)\n+    }\n+}\n+\n // Binary operator categories. These categories summarize the behavior\n // with respect to the builtin operations supported.\n enum BinOpCategory {"}]}