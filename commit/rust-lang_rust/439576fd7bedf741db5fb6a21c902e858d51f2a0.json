{"sha": "439576fd7bedf741db5fb6a21c902e858d51f2a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOTU3NmZkN2JlZGY3NDFkYjVmYjZhMjFjOTAyZTg1OGQ1MWYyYTA=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-15T20:05:47Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-11-23T21:55:52Z"}, "message": "Make float::from_bits transmute (and update the documentation to reflect this).\n\nThe current implementation/documentation was made to avoid sNaN because of\npotential safety issues implied by old/bad LLVM documentation. These issues\naren't real, so we can just make the implementation transmute (as permitted\nby the existing documentation of this method).\n\nAlso the documentation didn't actually match the behaviour: it said we may\nchange sNaNs, but in fact we canonicalized *all* NaNs.\n\nAlso an example in the documentation was wrong: it said we *always* change\nsNaNs, when the documentation was explicitly written to indicate it was\nimplementation-defined.\n\nThis makes to_bits and from_bits perfectly roundtrip cross-platform, except\nfor one caveat: although the 2008 edition of IEEE-754 specifies how to\ninterpet the signaling bit, earlier editions didn't. This lead to some platforms\npicking the opposite interpretation, so all signaling NaNs on x86/ARM are quiet\non MIPS, and vice-versa.\n\nNaN-boxing is a fairly important optimization, while we don't even guarantee\nthat float operations properly preserve signalingness. As such, this seems like\nthe more natural strategy to take (as opposed to trying to mangle the signaling\nbit on a per-platform basis).\n\nThis implementation is also, of course, faster.", "tree": {"sha": "20e757796ce44c0ff3af226a2388e7f11e3123b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20e757796ce44c0ff3af226a2388e7f11e3123b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439576fd7bedf741db5fb6a21c902e858d51f2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439576fd7bedf741db5fb6a21c902e858d51f2a0", "html_url": "https://github.com/rust-lang/rust/commit/439576fd7bedf741db5fb6a21c902e858d51f2a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439576fd7bedf741db5fb6a21c902e858d51f2a0/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88a28ff6028cf197ed6b4185d8cd4887f05e3e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/88a28ff6028cf197ed6b4185d8cd4887f05e3e07", "html_url": "https://github.com/rust-lang/rust/commit/88a28ff6028cf197ed6b4185d8cd4887f05e3e07"}], "stats": {"total": 162, "additions": 86, "deletions": 76}, "files": [{"sha": "42182092ab1e41e831decd03968849b7a1984b47", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/439576fd7bedf741db5fb6a21c902e858d51f2a0/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439576fd7bedf741db5fb6a21c902e858d51f2a0/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=439576fd7bedf741db5fb6a21c902e858d51f2a0", "patch": "@@ -998,10 +998,13 @@ impl f32 {\n \n     /// Raw transmutation to `u32`.\n     ///\n-    /// Converts the `f32` into its raw memory representation,\n-    /// similar to the `transmute` function.\n+    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -1018,17 +1021,33 @@ impl f32 {\n \n     /// Raw transmutation from `u32`.\n     ///\n-    /// Converts the given `u32` containing the float's raw memory\n-    /// representation into the `f32` type, similar to the\n-    /// `transmute` function.\n+    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n+    ///\n+    /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// There is only one difference to a bare `transmute`:\n-    /// Due to the implications onto Rust's safety promises being\n-    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n-    /// is passed to the function, the implementation is allowed to\n-    /// return a quiet NaN instead.\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -1037,25 +1056,11 @@ impl f32 {\n     /// let v = f32::from_bits(0x41480000);\n     /// let difference = (v - 12.5).abs();\n     /// assert!(difference <= 1e-5);\n-    /// // Example for a signaling NaN value:\n-    /// let snan = 0x7F800001;\n-    /// assert_ne!(f32::from_bits(snan).to_bits(), snan);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn from_bits(mut v: u32) -> Self {\n-        const EXP_MASK: u32   = 0x7F800000;\n-        const FRACT_MASK: u32 = 0x007FFFFF;\n-        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // While IEEE 754-2008 specifies encodings for quiet NaNs\n-            // and signaling ones, certain MIPS and PA-RISC\n-            // CPUs treat signaling NaNs differently.\n-            // Therefore to be safe, we pass a known quiet NaN\n-            // if v is any kind of NaN.\n-            // The check above only assumes IEEE 754-1985 to be\n-            // valid.\n-            v = unsafe { ::mem::transmute(NAN) };\n-        }\n+    pub fn from_bits(v: u32) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { ::mem::transmute(v) }\n     }\n }\n@@ -1646,25 +1651,15 @@ mod tests {\n         assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n         assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n         assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n-    }\n-    #[test]\n-    fn test_snan_masking() {\n-        // NOTE: this test assumes that our current platform\n-        // implements IEEE 754-2008 that specifies the difference\n-        // in encoding of quiet and signaling NaNs.\n-        // If you are porting Rust to a platform that does not\n-        // implement IEEE 754-2008 (but e.g. IEEE 754-1985, which\n-        // only says that \"Signaling NaNs shall be reserved operands\"\n-        // but doesn't specify the actual setup), feel free to\n-        // cfg out this test.\n-        let snan: u32 = 0x7F801337;\n-        const QNAN_MASK: u32  = 0x00400000;\n-        let nan_masked_fl = f32::from_bits(snan);\n-        let nan_masked = nan_masked_fl.to_bits();\n-        // Ensure that signaling NaNs don't stay the same\n-        assert_ne!(nan_masked, snan);\n-        // Ensure that we have a quiet NaN\n-        assert_ne!(nan_masked & QNAN_MASK, 0);\n-        assert!(nan_masked_fl.is_nan());\n+\n+        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+        let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+        let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n+        assert!(f32::from_bits(masked_nan1).is_nan());\n+        assert!(f32::from_bits(masked_nan2).is_nan());\n+\n+        assert_eq!(f32::from_bits(masked_nan1).to_bits(), masked_nan1);\n+        assert_eq!(f32::from_bits(masked_nan2).to_bits(), masked_nan2);\n     }\n }"}, {"sha": "d3a6ed607885e8b1649817d970ada029f065b69e", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/439576fd7bedf741db5fb6a21c902e858d51f2a0/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439576fd7bedf741db5fb6a21c902e858d51f2a0/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=439576fd7bedf741db5fb6a21c902e858d51f2a0", "patch": "@@ -952,10 +952,13 @@ impl f64 {\n \n     /// Raw transmutation to `u64`.\n     ///\n-    /// Converts the `f64` into its raw memory representation,\n-    /// similar to the `transmute` function.\n+    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// See `from_bits` for some discussion of the portability of this operation\n+    /// (there are almost no issues).\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -972,17 +975,33 @@ impl f64 {\n \n     /// Raw transmutation from `u64`.\n     ///\n-    /// Converts the given `u64` containing the float's raw memory\n-    /// representation into the `f64` type, similar to the\n-    /// `transmute` function.\n+    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n+    /// It turns out this is incredibly portable, for two reasons:\n+    ///\n+    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * IEEE-754 very precisely specifies the bit layout of floats.\n+    ///\n+    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n+    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n+    /// (notably x86 and ARM) picked the interpretation that was ultimately\n+    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n+    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n+    ///\n+    /// Rather than trying to preserve signaling-ness cross-platform, this\n+    /// implementation favours preserving the exact bits. This means that\n+    /// any payloads encoded in NaNs will be preserved even if the result of\n+    /// this method is sent over the network from an x86 machine to a MIPS one.\n+    ///\n+    /// If the results of this method are only manipulated by the same\n+    /// architecture that produced them, then there is no portability concern.\n     ///\n-    /// There is only one difference to a bare `transmute`:\n-    /// Due to the implications onto Rust's safety promises being\n-    /// uncertain, if the representation of a signaling NaN \"sNaN\" float\n-    /// is passed to the function, the implementation is allowed to\n-    /// return a quiet NaN instead.\n+    /// If the input isn't NaN, then there is no portability concern.\n     ///\n-    /// Note that this function is distinct from casting.\n+    /// If you don't care about signalingness (very likely), then there is no\n+    /// portability concern.\n+    ///\n+    /// Note that this function is distinct from `as` casting, which attempts to\n+    /// preserve the *numeric* value, and not the bitwise value.\n     ///\n     /// # Examples\n     ///\n@@ -991,25 +1010,11 @@ impl f64 {\n     /// let v = f64::from_bits(0x4029000000000000);\n     /// let difference = (v - 12.5).abs();\n     /// assert!(difference <= 1e-5);\n-    /// // Example for a signaling NaN value:\n-    /// let snan = 0x7FF0000000000001;\n-    /// assert_ne!(f64::from_bits(snan).to_bits(), snan);\n     /// ```\n     #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n     #[inline]\n-    pub fn from_bits(mut v: u64) -> Self {\n-        const EXP_MASK: u64   = 0x7FF0000000000000;\n-        const FRACT_MASK: u64 = 0x000FFFFFFFFFFFFF;\n-        if v & EXP_MASK == EXP_MASK && v & FRACT_MASK != 0 {\n-            // While IEEE 754-2008 specifies encodings for quiet NaNs\n-            // and signaling ones, certain MIPS and PA-RISC\n-            // CPUs treat signaling NaNs differently.\n-            // Therefore to be safe, we pass a known quiet NaN\n-            // if v is any kind of NaN.\n-            // The check above only assumes IEEE 754-1985 to be\n-            // valid.\n-            v = unsafe { ::mem::transmute(NAN) };\n-        }\n+    pub fn from_bits(v: u64) -> Self {\n+        // It turns out the safety issues with sNaN were overblown! Hooray!\n         unsafe { ::mem::transmute(v) }\n     }\n }\n@@ -1596,5 +1601,15 @@ mod tests {\n         assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n         assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n         assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n+\n+        // Check that NaNs roundtrip their bits regardless of signalingness\n+        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+        let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+        let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+        assert!(f64::from_bits(masked_nan1).is_nan());\n+        assert!(f64::from_bits(masked_nan2).is_nan());\n+\n+        assert_eq!(f64::from_bits(masked_nan1).to_bits(), masked_nan1);\n+        assert_eq!(f64::from_bits(masked_nan2).to_bits(), masked_nan2);\n     }\n }"}]}