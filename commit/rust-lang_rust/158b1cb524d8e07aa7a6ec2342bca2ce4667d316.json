{"sha": "158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OGIxY2I1MjRkOGUwN2FhN2E2ZWMyMzQyYmNhMmNlNDY2N2QzMTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-23T13:49:53Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-23T14:12:49Z"}, "message": "Rename CrateModuleId", "tree": {"sha": "aec1b3e9ad54155e386db9cf5d2af8b8697e80aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aec1b3e9ad54155e386db9cf5d2af8b8697e80aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "html_url": "https://github.com/rust-lang/rust/commit/158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd5c2dc5bf9e9dee863bd79105b1782b654221f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd5c2dc5bf9e9dee863bd79105b1782b654221f7", "html_url": "https://github.com/rust-lang/rust/commit/dd5c2dc5bf9e9dee863bd79105b1782b654221f7"}], "stats": {"total": 108, "additions": 54, "deletions": 54}, "files": [{"sha": "2442fb6a527ab2e0f2646816317f91250a9966d6", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n     nameres::per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n-    ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalImportId,\n+    ContainerId, HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId,\n     LocalStructFieldId, Lookup, ModuleId, UnionId,\n };\n use hir_expand::{\n@@ -112,7 +112,7 @@ impl_froms!(\n pub use hir_def::{attr::Attrs, ModuleSource};\n \n impl Module {\n-    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n         Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n     }\n \n@@ -222,7 +222,7 @@ impl Module {\n         def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n-    fn with_module_id(self, module_id: CrateModuleId) -> Module {\n+    fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n }"}, {"sha": "2cfe68701d4ddd28b1b3824c6ad41c46c48c5e6f", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -106,14 +106,14 @@ impl_arena_id!(LocalImportId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,\n-    pub module_id: CrateModuleId,\n+    pub module_id: LocalModuleId,\n }\n \n /// An ID of a module, **local** to a specific crate\n // FIXME: rename to `LocalModuleId`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n+pub struct LocalModuleId(RawId);\n+impl_arena_id!(LocalModuleId);\n \n macro_rules! impl_intern_key {\n     ($name:ident) => {"}, {"sha": "d82356bbd8e395c3ea8fe3be525d39d8bc684c1b", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -74,7 +74,7 @@ use crate::{\n     db::DefDatabase,\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs},\n     path::Path,\n-    AstId, CrateModuleId, FunctionId, ImplId, LocalImportId, ModuleDefId, ModuleId, TraitId,\n+    AstId, FunctionId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -87,8 +87,8 @@ pub struct CrateDefMap {\n     /// a dependency (`std` or `core`).\n     prelude: Option<ModuleId>,\n     extern_prelude: FxHashMap<Name, ModuleDefId>,\n-    root: CrateModuleId,\n-    modules: Arena<CrateModuleId, ModuleData>,\n+    root: LocalModuleId,\n+    modules: Arena<LocalModuleId, ModuleData>,\n \n     /// Some macros are not well-behavior, which leads to infinite loop\n     /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n@@ -105,17 +105,17 @@ pub struct CrateDefMap {\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n-impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+impl std::ops::Index<LocalModuleId> for CrateDefMap {\n     type Output = ModuleData;\n-    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+    fn index(&self, id: LocalModuleId) -> &ModuleData {\n         &self.modules[id]\n     }\n }\n \n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ModuleData {\n-    pub parent: Option<CrateModuleId>,\n-    pub children: FxHashMap<Name, CrateModuleId>,\n+    pub parent: Option<LocalModuleId>,\n+    pub children: FxHashMap<Name, LocalModuleId>,\n     pub scope: ModuleScope,\n \n     //  FIXME: these can't be both null, we need a three-state enum here.\n@@ -225,7 +225,7 @@ impl CrateDefMap {\n         let def_map = {\n             let crate_graph = db.crate_graph();\n             let edition = crate_graph.edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,\n@@ -246,7 +246,7 @@ impl CrateDefMap {\n         self.krate\n     }\n \n-    pub fn root(&self) -> CrateModuleId {\n+    pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n \n@@ -261,7 +261,7 @@ impl CrateDefMap {\n     pub fn add_diagnostics(\n         &self,\n         db: &impl DefDatabase,\n-        module: CrateModuleId,\n+        module: LocalModuleId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n@@ -270,18 +270,18 @@ impl CrateDefMap {\n     pub fn resolve_path(\n         &self,\n         db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> (PerNs, Option<usize>) {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n \n-    pub fn modules(&self) -> impl Iterator<Item = CrateModuleId> + '_ {\n+    pub fn modules(&self) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules.iter().map(|(id, _data)| id)\n     }\n \n-    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = CrateModuleId> + '_ {\n+    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules\n             .iter()\n             .filter(move |(_id, data)| data.definition == Some(file_id))\n@@ -317,12 +317,12 @@ mod diagnostics {\n     use ra_db::RelativePathBuf;\n     use ra_syntax::{ast, AstPtr};\n \n-    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::CrateModuleId, AstId};\n+    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::LocalModuleId, AstId};\n \n     #[derive(Debug, PartialEq, Eq)]\n     pub(super) enum DefDiagnostic {\n         UnresolvedModule {\n-            module: CrateModuleId,\n+            module: LocalModuleId,\n             declaration: AstId<ast::Module>,\n             candidate: RelativePathBuf,\n         },\n@@ -332,7 +332,7 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &impl DefDatabase,\n-            target_module: CrateModuleId,\n+            target_module: LocalModuleId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {"}, {"sha": "5f7697f631eee0dc3182e214db7740f04f48e96f", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -19,9 +19,9 @@ use crate::{\n         per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, CrateModuleId, EnumId, EnumVariantId,\n-    FunctionLoc, ImplId, Intern, LocalImportId, LocationCtx, ModuleDefId, ModuleId, StaticId,\n-    StructId, StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n+    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, EnumId, EnumVariantId, FunctionLoc, ImplId,\n+    Intern, LocalImportId, LocalModuleId, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n+    StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -94,10 +94,10 @@ impl MacroStackMonitor {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, LocalImportId)>>,\n-    unresolved_imports: Vec<(CrateModuleId, LocalImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n-    mod_dirs: FxHashMap<CrateModuleId, ModDir>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n+    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n+    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n@@ -173,7 +173,7 @@ where\n     /// ```\n     fn define_macro(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         name: Name,\n         macro_: MacroDefId,\n         export: bool,\n@@ -200,15 +200,15 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, macro_: MacroDefId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n-        current_module_id: CrateModuleId,\n+        current_module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) {\n         log::debug!(\n@@ -235,7 +235,7 @@ where\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: CrateId) {\n+    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n             // `macro_use` only bring things into legacy scope.\n@@ -265,7 +265,7 @@ where\n \n     fn resolve_import(\n         &self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) -> (PerNs, ReachedFixedPoint) {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n@@ -291,7 +291,7 @@ where\n \n     fn record_resolved_import(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         def: PerNs,\n         import_id: LocalImportId,\n         import: &raw::ImportData,\n@@ -387,7 +387,7 @@ where\n \n     fn update(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n     ) {\n@@ -396,7 +396,7 @@ where\n \n     fn update_recursive(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n@@ -484,7 +484,7 @@ where\n \n     fn collect_macro_expansion(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         macro_call_id: MacroCallId,\n         macro_def_id: MacroDefId,\n     ) {\n@@ -522,7 +522,7 @@ where\n /// Walks a single module, populating defs, imports and macros\n struct ModCollector<'a, D> {\n     def_collector: D,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n     mod_dir: ModDir,\n@@ -647,7 +647,7 @@ where\n         name: Name,\n         declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n-    ) -> CrateModuleId {\n+    ) -> LocalModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n@@ -772,7 +772,7 @@ where\n         self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n     }\n \n-    fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n+    fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n         let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n         for (name, macro_) in macros {\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n@@ -827,7 +827,7 @@ mod tests {\n \n         let def_map = {\n             let edition = db.crate_graph().edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,"}, {"sha": "93b441f96d208b1778cc53e0c5d4a002a4fd8ab8", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     db::DefDatabase,\n     nameres::{per_ns::PerNs, CrateDefMap},\n     path::{Path, PathKind},\n-    AdtId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId,\n+    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -65,7 +65,7 @@ impl CrateDefMap {\n         &self,\n         db: &impl DefDatabase,\n         mode: ResolveMode,\n-        original_module: CrateModuleId,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n@@ -217,7 +217,7 @@ impl CrateDefMap {\n     fn resolve_name_in_module(\n         &self,\n         db: &impl DefDatabase,\n-        module: CrateModuleId,\n+        module: LocalModuleId,\n         name: &Name,\n     ) -> PerNs {\n         // Resolve in:"}, {"sha": "f0b86af7c17c45494f382aa400e21ef35c02c377", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -10,7 +10,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB, CrateModuleId};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n \n fn def_map(fixtute: &str) -> String {\n     let dm = compute_crate_def_map(fixtute);\n@@ -28,7 +28,7 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n     go(&mut buf, map, \"\\ncrate\", map.root());\n     return buf.trim().to_string();\n \n-    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n+    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n         *buf += path;\n         *buf += \"\\n\";\n "}, {"sha": "e11530062d2bd8904492510c16a1b23fbf0796c9", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -665,7 +665,7 @@ fn unresolved_module_diagnostics() {\n         @r###\"\n     [\n         UnresolvedModule {\n-            module: CrateModuleId(\n+            module: LocalModuleId(\n                 0,\n             ),\n             declaration: AstId {"}, {"sha": "e64face7ee24f121b8b3c75a5afd62efd927d636", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158b1cb524d8e07aa7a6ec2342bca2ce4667d316/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=158b1cb524d8e07aa7a6ec2342bca2ce4667d316", "patch": "@@ -16,9 +16,9 @@ use crate::{\n     generics::GenericParams,\n     nameres::{per_ns::PerNs, CrateDefMap},\n     path::{Path, PathKind},\n-    AdtId, AstItemDef, ConstId, ContainerId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n-    TypeAliasId,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -30,7 +30,7 @@ pub struct Resolver {\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n     crate_def_map: Arc<CrateDefMap>,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n }\n \n #[derive(Debug, Clone)]\n@@ -330,7 +330,7 @@ impl Resolver {\n         traits\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    fn module(&self) -> Option<(&CrateDefMap, LocalModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n@@ -466,7 +466,7 @@ impl Resolver {\n     fn push_module_scope(\n         self,\n         crate_def_map: Arc<CrateDefMap>,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n     ) -> Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }"}]}