{"sha": "2008732975de0f274719f44a6024bdefb01e5db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDg3MzI5NzVkZTBmMjc0NzE5ZjQ0YTYwMjRiZGVmYjAxZTVkYjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-27T16:39:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-27T16:39:41Z"}, "message": "Auto merge of #37983 - GuillaumeGomez:tcp_listener_doc, r=frewsxcv\n\nAdd examples for TcpListener struct\n\nr? @frewsxcv", "tree": {"sha": "a40c3d2b27ab43ed685afb8210be376d52bed171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a40c3d2b27ab43ed685afb8210be376d52bed171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2008732975de0f274719f44a6024bdefb01e5db6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2008732975de0f274719f44a6024bdefb01e5db6", "html_url": "https://github.com/rust-lang/rust/commit/2008732975de0f274719f44a6024bdefb01e5db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2008732975de0f274719f44a6024bdefb01e5db6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e17ba5ffcc72fc38722a56618be712ef3607013", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e17ba5ffcc72fc38722a56618be712ef3607013", "html_url": "https://github.com/rust-lang/rust/commit/0e17ba5ffcc72fc38722a56618be712ef3607013"}, {"sha": "f216f1fc5357a03044b4245f728ea61b355a9221", "url": "https://api.github.com/repos/rust-lang/rust/commits/f216f1fc5357a03044b4245f728ea61b355a9221", "html_url": "https://github.com/rust-lang/rust/commit/f216f1fc5357a03044b4245f728ea61b355a9221"}], "stats": {"total": 121, "additions": 118, "deletions": 3}, "files": [{"sha": "be9636a0a19a1bdc4c422e264443ae3e1f54fcd0", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2008732975de0f274719f44a6024bdefb01e5db6/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2008732975de0f274719f44a6024bdefb01e5db6/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=2008732975de0f274719f44a6024bdefb01e5db6", "patch": "@@ -474,12 +474,30 @@ impl TcpListener {\n     ///\n     /// The address type can be any implementor of `ToSocketAddrs` trait. See\n     /// its documentation for concrete examples.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// assert_eq!(listener.local_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n@@ -490,6 +508,15 @@ impl TcpListener {\n     /// The returned `TcpListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// let listener_clone = listener.try_clone().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<TcpListener> {\n         self.0.duplicate().map(TcpListener)\n@@ -500,6 +527,18 @@ impl TcpListener {\n     /// This function will block the calling thread until a new TCP connection\n     /// is established. When established, the corresponding `TcpStream` and the\n     /// remote peer's address will be returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// match listener.accept() {\n+    ///     Ok((_socket, addr)) => println!(\"new client: {:?}\", addr),\n+    ///     Err(e) => println!(\"couldn't get client: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         self.0.accept().map(|(a, b)| (TcpStream(a), b))\n@@ -508,8 +547,28 @@ impl TcpListener {\n     /// Returns an iterator over the connections being received on this\n     /// listener.\n     ///\n-    /// The returned iterator will never return `None` and will also not yield\n-    /// the peer's `SocketAddr` structure.\n+    /// The returned iterator will never return [`None`] and will also not yield\n+    /// the peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             println!(\"new client!\");\n+    ///         }\n+    ///         Err(e) => { /* connection failed */ }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn incoming(&self) -> Incoming {\n         Incoming { listener: self }\n@@ -519,16 +578,35 @@ impl TcpListener {\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n     /// from this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_ttl(100).expect(\"could not set TTL\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n         self.0.set_ttl(ttl)\n     }\n \n     /// Gets the value of the `IP_TTL` option for this socket.\n     ///\n-    /// For more information about this option, see [`set_ttl`][link].\n+    /// For more information about this option, see [`set_ttl()`][link].\n     ///\n     /// [link]: #method.set_ttl\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_ttl(100).expect(\"could not set TTL\");\n+    /// assert_eq!(listener.ttl().unwrap_or(0), 100);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -542,6 +620,15 @@ impl TcpListener {\n     ///\n     /// If this is set to `false` then the socket can be used to send and\n     /// receive packets from an IPv4-mapped IPv6 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n         self.0.set_only_v6(only_v6)\n@@ -552,6 +639,16 @@ impl TcpListener {\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n     /// [link]: #method.set_only_v6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n+    /// assert_eq!(listener.only_v6().unwrap_or(false), true);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -562,6 +659,15 @@ impl TcpListener {\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n     /// calls.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.take_error().expect(\"No error was expected\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -571,6 +677,15 @@ impl TcpListener {\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n     /// corresponds to calling ioctlsocket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)"}]}