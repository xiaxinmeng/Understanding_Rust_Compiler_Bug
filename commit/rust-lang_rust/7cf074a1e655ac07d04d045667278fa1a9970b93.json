{"sha": "7cf074a1e655ac07d04d045667278fa1a9970b93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZjA3NGExZTY1NWFjMDdkMDRkMDQ1NjY3Mjc4ZmExYTk5NzBiOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-16T20:48:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-16T20:48:40Z"}, "message": "Auto merge of #58899 - petrochenkov:derval2, r=estebank\n\nDo not accidentally treat multi-segment meta-items as single-segment\n\nFixes https://github.com/rust-lang/rust/issues/55168 and many other regressions from https://github.com/rust-lang/rust/pull/50030\n\nBasically, attributes like `#[any::prefix::foo]` were commonly interpreted as `#[foo]` due to `name()` successfully returning the last segment (this applies to nested things as well `#[attr(any::prefix::foo)]`).", "tree": {"sha": "d2509e198c34af3e41cce2dbde186635384a418a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2509e198c34af3e41cce2dbde186635384a418a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cf074a1e655ac07d04d045667278fa1a9970b93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf074a1e655ac07d04d045667278fa1a9970b93", "html_url": "https://github.com/rust-lang/rust/commit/7cf074a1e655ac07d04d045667278fa1a9970b93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cf074a1e655ac07d04d045667278fa1a9970b93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "html_url": "https://github.com/rust-lang/rust/commit/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff"}, {"sha": "2fd4cbb3f283b903f55444bb585d38a2539f4e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd4cbb3f283b903f55444bb585d38a2539f4e8d", "html_url": "https://github.com/rust-lang/rust/commit/2fd4cbb3f283b903f55444bb585d38a2539f4e8d"}], "stats": {"total": 1076, "additions": 565, "deletions": 511}, "files": [{"sha": "8602d159ba9603fd5ee7f5a9ca2d69d5d0daaecf", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| attr.name() == \"repr\")\n+            .filter(|attr| attr.check_name(\"repr\"))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -177,15 +177,15 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         let mut is_transparent = false;\n \n         for hint in &hints {\n-            let name = if let Some(name) = hint.name() {\n+            let name = if let Some(name) = hint.ident_str() {\n                 name\n             } else {\n                 // Invalid repr hint like repr(42). We don't check for unrecognized hints here\n                 // (libsyntax does that), so just ignore it.\n                 continue;\n             };\n \n-            let (article, allowed_targets) = match &*name.as_str() {\n+            let (article, allowed_targets) = match name {\n                 \"C\" | \"align\" => {\n                     is_c |= name == \"C\";\n                     if target != Target::Struct &&\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 _ => continue,\n             };\n             self.emit_repr_error(\n-                hint.span,\n+                hint.span(),\n                 item.span,\n                 &format!(\"attribute should be applied to {}\", allowed_targets),\n                 &format!(\"not {} {}\", article, allowed_targets),\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n         // Just point at all repr hints if there are any incompatibilities.\n         // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n-        let hint_spans = hints.iter().map(|hint| hint.span);\n+        let hint_spans = hints.iter().map(|hint| hint.span());\n \n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.name() == \"used\" && target != Target::Static {\n+            if attr.check_name(\"used\") && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "496ccc888b61ad032be79b1dd5104977058a8159", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -197,7 +197,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: SmallVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc && !hcx.is_ignored_attr(attr.name())\n+                !attr.is_sugared_doc &&\n+                !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n \n@@ -224,7 +225,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(!hcx.is_ignored_attr(self.name()));\n+        debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n         debug_assert!(!self.is_sugared_doc);\n \n         let ast::Attribute {\n@@ -359,15 +360,13 @@ fn hash_token<'a, 'gcx, W: StableHasherResult>(\n     }\n }\n \n-impl_stable_hash_for_spanned!(::syntax::ast::NestedMetaItemKind);\n-\n-impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n+impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItem {\n     MetaItem(meta_item),\n     Literal(lit)\n });\n \n impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n-    ident,\n+    path,\n     node,\n     span\n });"}, {"sha": "19e899ceb421f72497f406b1532d95c7a52810a3", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -194,7 +194,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute\")\n         };\n         for attr in attrs {\n-            let level = match Level::from_str(&attr.name().as_str()) {\n+            let level = match attr.ident_str().and_then(|name| Level::from_str(name)) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                 match item.node {\n                     ast::MetaItemKind::Word => {}  // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n-                        if item.ident == \"reason\" {\n+                        if item.path == \"reason\" {\n                             // found reason, reslice meta list to exclude it\n                             metas = &metas[0..metas.len()-1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n@@ -255,13 +255,13 @@ impl<'a> LintLevelsBuilder<'a> {\n             }\n \n             for li in metas {\n-                let word = match li.word() {\n-                    Some(word) => word,\n-                    None => {\n-                        let mut err = bad_attr(li.span);\n+                let meta_item = match li.meta_item() {\n+                    Some(meta_item) if meta_item.is_word() => meta_item,\n+                    _ => {\n+                        let mut err = bad_attr(li.span());\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n-                                if item.ident == \"reason\" {\n+                                if item.path == \"reason\" {\n                                     err.help(\"reason in lint attribute must come last\");\n                                 }\n                             }\n@@ -270,26 +270,27 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue;\n                     }\n                 };\n-                let tool_name = if let Some(lint_tool) = word.is_scoped() {\n-                    if !attr::is_known_lint_tool(lint_tool) {\n+                let tool_name = if meta_item.path.segments.len() > 1 {\n+                    let tool_ident = meta_item.path.segments[0].ident;\n+                    if !attr::is_known_lint_tool(tool_ident) {\n                         span_err!(\n                             sess,\n-                            lint_tool.span,\n+                            tool_ident.span,\n                             E0710,\n                             \"an unknown tool name found in scoped lint: `{}`\",\n-                            word.ident\n+                            meta_item.path\n                         );\n                         continue;\n                     }\n \n-                    Some(lint_tool.as_str())\n+                    Some(tool_ident.as_str())\n                 } else {\n                     None\n                 };\n-                let name = word.name();\n+                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n                 match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n-                        let src = LintSource::Node(name, li.span, reason);\n+                        let src = LintSource::Node(name, li.span(), reason);\n                         for id in ids {\n                             specs.insert(*id, (level, src));\n                         }\n@@ -300,7 +301,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                             Ok(ids) => {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n                                 let src = LintSource::Node(\n-                                    Symbol::intern(complete_name), li.span, reason\n+                                    Symbol::intern(complete_name), li.span(), reason\n                                 );\n                                 for id in ids {\n                                     specs.insert(*id, (level, src));\n@@ -322,18 +323,18 @@ impl<'a> LintLevelsBuilder<'a> {\n                                     lint,\n                                     lvl,\n                                     src,\n-                                    Some(li.span.into()),\n+                                    Some(li.span().into()),\n                                     &msg,\n                                 );\n                                 err.span_suggestion(\n-                                    li.span,\n+                                    li.span(),\n                                     \"change it to\",\n                                     new_lint_name.to_string(),\n                                     Applicability::MachineApplicable,\n                                 ).emit();\n \n                                 let src = LintSource::Node(\n-                                    Symbol::intern(&new_lint_name), li.span, reason\n+                                    Symbol::intern(&new_lint_name), li.span(), reason\n                                 );\n                                 for id in ids {\n                                     specs.insert(*id, (level, src));\n@@ -360,11 +361,11 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                               lint,\n                                                               level,\n                                                               src,\n-                                                              Some(li.span.into()),\n+                                                              Some(li.span().into()),\n                                                               &msg);\n                         if let Some(new_name) = renamed {\n                             err.span_suggestion(\n-                                li.span,\n+                                li.span(),\n                                 \"use the new name\",\n                                 new_name,\n                                 Applicability::MachineApplicable\n@@ -383,12 +384,12 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 lint,\n                                                 level,\n                                                 src,\n-                                                Some(li.span.into()),\n+                                                Some(li.span().into()),\n                                                 &msg);\n \n                         if let Some(suggestion) = suggestion {\n                             db.span_suggestion(\n-                                li.span,\n+                                li.span(),\n                                 \"did you mean\",\n                                 suggestion.to_string(),\n                                 Applicability::MachineApplicable,"}, {"sha": "b1ff66eb64fa69d420603a35d9ad1e47998d0131", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -724,7 +724,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs_by_hir_id(id);\n     for attr in attrs {\n-        if Level::from_str(&attr.name().as_str()).is_some() {\n+        if attr.ident_str().and_then(Level::from_str).is_some() {\n             return true;\n         }\n     }"}, {"sha": "237b00db575a968efc32df021ee078c244ef4cfc", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -65,9 +65,9 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                 for meta in metas {\n                     if let Some(mi) = meta.meta_item() {\n                         // Find the `feature = \"..\"` meta-item.\n-                        match (&*mi.name().as_str(), mi.value_str()) {\n-                            (\"feature\", val) => feature = val,\n-                            (\"since\", val) => since = val,\n+                        match (mi.ident_str(), mi.value_str()) {\n+                            (Some(\"feature\"), val) => feature = val,\n+                            (Some(\"since\"), val) => since = val,\n                             _ => {}\n                         }\n                     }"}, {"sha": "2664d6eaa28572c83c7d41403b813213029a792b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -194,11 +194,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = attr.name();\n-                if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n-                    attr::mark_used(attr);\n-                    self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n-                                                         outside of the standard library\");\n+                if let Some(tag) = attr.ident_str() {\n+                    if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n+                        attr::mark_used(attr);\n+                        self.tcx.sess.span_err(attr.span, \"stability attributes may not be used \\\n+                                                           outside of the standard library\");\n+                    }\n                 }\n             }\n "}, {"sha": "0ae7c10cf563022cb3c13c8f0c5e210756d4662f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1839,7 +1839,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n \n             match &mut parser.parse_meta_item() {\n                 Ok(meta_item) if parser.token == token::Eof => {\n-                    if meta_item.ident.segments.len() != 1 {\n+                    if meta_item.path.segments.len() != 1 {\n                         error!(\"argument key must be an identifier\");\n                     }\n                     match &meta_item.node {\n@@ -1850,7 +1850,8 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                             error!(\"argument value must be a string\");\n                         }\n                         MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                            return (meta_item.name(), meta_item.value_str());\n+                            let ident = meta_item.ident().expect(\"multi-segment cfg key\");\n+                            return (ident.name, meta_item.value_str());\n                         }\n                     }\n                 }"}, {"sha": "d0acaf674ae74f12b0b8b2afd32db4a53575b3b8", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             {\n                 if let Some(items) = item.meta_item_list() {\n                     if let Ok(subcommand) =\n-                        Self::parse(tcx, trait_def_id, &items, item.span, false)\n+                        Self::parse(tcx, trait_def_id, &items, item.span(), false)\n                     {\n                         subcommands.push(subcommand);\n                     } else {\n@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             }\n \n             // nothing found\n-            parse_error(tcx, item.span,\n+            parse_error(tcx, item.span(),\n                         \"this attribute must have a valid value\",\n                         \"expected value here\",\n                         Some(r#\"eg `#[rustc_on_unimplemented(message=\"foo\")]`\"#));\n@@ -177,10 +177,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(\n-                        c.name().as_str().to_string(),\n-                        c.value_str().map(|s| s.as_str().to_string())\n-                    ))\n+                    c.ident_str().map_or(false, |name| {\n+                        options.contains(&(\n+                            name.to_string(),\n+                            c.value_str().map(|s| s.as_str().to_string())\n+                        ))\n+                    })\n                 }) {\n                     debug!(\"evaluate: skipping {:?} due to condition\", command);\n                     continue"}, {"sha": "6d708b8d458ad56818b8e1b3ec56bc2da158ef77", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -683,7 +683,7 @@ impl RustcDefaultCalls {\n \n                     let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n+                            path: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "c964f4cb19b8b01fbda9db15c2ee5461494a096a", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -99,12 +99,12 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n-            match list_item.word() {\n-                Some(word) if value.is_none() =>\n-                    value = Some(word.name()),\n+            match list_item.ident() {\n+                Some(ident) if list_item.is_word() && value.is_none() =>\n+                    value = Some(ident.name),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n-                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),\n+                    span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item),\n             }\n         }\n         value"}, {"sha": "2c83501c86f523f8359add23cff00bed8209c457", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n                     return value;\n                 } else {\n                     self.tcx.sess.span_fatal(\n-                        item.span,\n+                        item.span(),\n                         &format!(\"associated value expected for `{}`\", name));\n                 }\n             }"}, {"sha": "5551cf6b3b604b970f1425a0e3ed7d5f8480479e", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -430,13 +430,13 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n             if DepNode::has_label_string(label) {\n                 if out.contains(label) {\n                     self.tcx.sess.span_fatal(\n-                        item.span,\n+                        item.span(),\n                         &format!(\"dep-node label `{}` is repeated\", label));\n                 }\n                 out.insert(label.to_string());\n             } else {\n                 self.tcx.sess.span_fatal(\n-                    item.span,\n+                    item.span(),\n                     &format!(\"dep-node label `{}` not recognized\", label));\n             }\n         }\n@@ -576,13 +576,13 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n-        let msg = if let Some(name) = item.name() {\n+        let msg = if let Some(name) = item.ident_str() {\n             format!(\"associated value expected for `{}`\", name)\n         } else {\n             \"expected an associated value\".to_string()\n         };\n \n-        tcx.sess.span_fatal(item.span, &msg);\n+        tcx.sess.span_fatal(item.span(), &msg);\n     }\n }\n "}, {"sha": "80c5eeeeac3458a9be447573ac90eb3f50483db8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -760,7 +760,7 @@ impl LintPass for DeprecatedAttr {\n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         for &&(n, _, _, ref g) in &self.depr_attrs {\n-            if attr.name() == n {\n+            if attr.ident_str() == Some(n) {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link, suggestion),\n                                              ref name,\n                                              ref reason,\n@@ -831,7 +831,7 @@ impl UnusedDocComment {\n \n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-            if attr.name() == \"doc\" {\n+            if attr.check_name(\"doc\") {\n                 let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n \n                 err.span_label("}, {"sha": "648cae30da6c8f14bbf93f01f612011ec75e0b9f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -267,19 +267,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             }\n         }\n \n-        let name = attr.name();\n+        let name = attr.ident_str();\n         if !attr::is_used(attr) {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = BUILTIN_ATTRIBUTES.iter()\n-                .find(|&&(builtin, ty, ..)| name == builtin && ty == AttributeType::CrateLevel)\n+                .find(|&&(builtin, ty, ..)| {\n+                    name == Some(builtin) && ty == AttributeType::CrateLevel\n+                })\n                 .is_some();\n \n             // Has a plugin registered this attribute as one that must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| name == &**x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| name == Some(x) && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "80786992cd95699eef98ee5d211ac52d577e177e", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                         k => {\n                             struct_span_err!(self.tcx.sess, m.span, E0458,\n                                       \"unknown kind: `{}`\", k)\n-                                .span_label(item.span, \"unknown kind\").emit();\n+                                .span_label(item.span(), \"unknown kind\").emit();\n                             cstore::NativeUnknown\n                         }\n                     };"}, {"sha": "af2cd8f979a11fa781ac566b8b2b04b417c11faf", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n                 } else {\n                     sess.span_err(\n                         item.span,\n-                        &format!(\"{} attribute requires a path\", item.ident));\n+                        &format!(\"{} attribute requires a path\", item.path));\n                     return None;\n                 }\n             }"}, {"sha": "373bcf7f0e2f3a4ab86479035bae7634c5d71d84", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -53,9 +53,7 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n                 // The `..` are the names of fields to dump.\n                 let meta_items = attr.meta_item_list().unwrap_or_default();\n                 for meta_item in meta_items {\n-                    let name = meta_item.word().map(|mi| mi.name().as_str());\n-                    let name = name.as_ref().map(|s| &s[..]).unwrap_or(\"\");\n-\n+                    let name = meta_item.ident_str().unwrap_or(\"\");\n                     match name {\n                         \"abi\" => {\n                             self.tcx\n@@ -88,7 +86,7 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n \n                         _ => {\n                             self.tcx.sess.span_err(\n-                                meta_item.span,\n+                                meta_item.span(),\n                                 &format!(\"unrecognized field name `{}`\", name),\n                             );\n                         }"}, {"sha": "bd11e0ce8023aa6dbb10c620943626f1f24c0981", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -56,10 +56,10 @@ pub fn load_plugins(sess: &Session,\n \n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n-                match plugin.name() {\n+                match plugin.ident_str() {\n                     Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, &name.as_str(), args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span(), name, args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "12b87b9c9aa18ab40f211c34599ddce50ae030fe", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -463,10 +463,9 @@ impl<'a> Resolver<'a> {\n                 if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-                        if let Some(ident) = trait_attr.name().map(Ident::with_empty_ctxt) {\n-                            let sp = trait_attr.span;\n+                        if let Some(ident) = trait_attr.ident() {\n                             let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n-                            self.define(parent, ident, MacroNS, (def, vis, sp, expansion));\n+                            self.define(parent, ident, MacroNS, (def, vis, ident.span, expansion));\n                         }\n                     }\n                 }\n@@ -812,14 +811,14 @@ impl<'a> Resolver<'a> {\n                             break;\n                         }\n                         MetaItemKind::List(nested_metas) => for nested_meta in nested_metas {\n-                            match nested_meta.word() {\n-                                Some(word) => single_imports.push((word.name(), word.span)),\n-                                None => ill_formed(nested_meta.span),\n+                            match nested_meta.ident() {\n+                                Some(ident) if nested_meta.is_word() => single_imports.push(ident),\n+                                _ => ill_formed(nested_meta.span()),\n                             }\n                         }\n                         MetaItemKind::NameValue(..) => ill_formed(meta.span),\n                     }\n-                    None => ill_formed(attr.span()),\n+                    None => ill_formed(attr.span),\n                 }\n             }\n         }\n@@ -850,23 +849,23 @@ impl<'a> Resolver<'a> {\n                 self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n-            for (name, span) in single_imports.iter().cloned() {\n-                let ident = Ident::with_empty_ctxt(name);\n+            for ident in single_imports.iter().cloned() {\n                 let result = self.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n                     None,\n                     false,\n-                    span,\n+                    ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(span);\n+                    let directive = macro_use_directive(ident.span);\n                     self.potentially_unused_imports.push(directive);\n                     let imported_binding = self.import(binding, directive);\n-                    self.legacy_import_macro(name, imported_binding, span, allow_shadowing);\n+                    self.legacy_import_macro(ident.name, imported_binding,\n+                                             ident.span, allow_shadowing);\n                 } else {\n-                    span_err!(self.session, span, E0469, \"imported macro not found\");\n+                    span_err!(self.session, ident.span, E0469, \"imported macro not found\");\n                 }\n             }\n         }"}, {"sha": "10e9613bf21a23497c42d6bd476856dad5d778a9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -2326,7 +2326,7 @@ fn from_target_feature(\n         if !item.check_name(\"enable\") {\n             let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n                        currently\";\n-            tcx.sess.span_err(item.span, &msg);\n+            tcx.sess.span_err(item.span(), &msg);\n             continue;\n         }\n \n@@ -2336,7 +2336,7 @@ fn from_target_feature(\n             None => {\n                 let msg = \"#[target_feature] attribute must be of the form \\\n                            #[target_feature(enable = \\\"..\\\")]\";\n-                tcx.sess.span_err(item.span, &msg);\n+                tcx.sess.span_err(item.span(), &msg);\n                 continue;\n             }\n         };\n@@ -2352,7 +2352,7 @@ fn from_target_feature(\n                          this target\",\n                         feature\n                     );\n-                    let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+                    let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n \n                     if feature.starts_with(\"+\") {\n                         let valid = whitelist.contains_key(&feature[1..]);\n@@ -2387,7 +2387,7 @@ fn from_target_feature(\n                 feature_gate::emit_feature_err(\n                     &tcx.sess.parse_sess,\n                     feature_gate.as_ref().unwrap(),\n-                    item.span,\n+                    item.span(),\n                     feature_gate::GateIssue::Language,\n                     &format!(\"the target feature `{}` is currently unstable\", feature),\n                 );\n@@ -2549,7 +2549,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 } else {\n                     span_err!(\n                         tcx.sess.diagnostic(),\n-                        items[0].span,\n+                        items[0].span(),\n                         E0535,\n                         \"invalid argument\"\n                     );\n@@ -2583,7 +2583,7 @@ fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> Codegen\n                 } else if list_contains_name(&items[..], \"speed\") {\n                     OptimizeAttr::Speed\n                 } else {\n-                    err(items[0].span, \"invalid argument\");\n+                    err(items[0].span(), \"invalid argument\");\n                     OptimizeAttr::None\n                 }\n             }"}, {"sha": "69445451503cc7404d7b5b2c1325e30569cdfa15", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -8,7 +8,7 @@ use std::fmt::{self, Write};\n use std::ops;\n \n use syntax::symbol::Symbol;\n-use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind, LitKind};\n+use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, LitKind};\n use syntax::parse::ParseSess;\n use syntax::feature_gate::Features;\n \n@@ -41,9 +41,9 @@ pub struct InvalidCfgError {\n impl Cfg {\n     /// Parses a `NestedMetaItem` into a `Cfg`.\n     fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n-        match nested_cfg.node {\n-            NestedMetaItemKind::MetaItem(ref cfg) => Cfg::parse(cfg),\n-            NestedMetaItemKind::Literal(ref lit) => Err(InvalidCfgError {\n+        match nested_cfg {\n+            NestedMetaItem::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItem::Literal(ref lit) => Err(InvalidCfgError {\n                 msg: \"unexpected literal\",\n                 span: lit.span,\n             }),\n@@ -58,7 +58,13 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.name();\n+        let name = match cfg.ident() {\n+            Some(ident) => ident.name,\n+            None => return Err(InvalidCfgError {\n+                msg: \"expected a single identifier\",\n+                span: cfg.span\n+            }),\n+        };\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {\n@@ -424,7 +430,7 @@ mod test {\n \n     fn dummy_meta_item_word(name: &str) -> MetaItem {\n         MetaItem {\n-            ident: Path::from_ident(Ident::from_str(name)),\n+            path: Path::from_ident(Ident::from_str(name)),\n             node: MetaItemKind::Word,\n             span: DUMMY_SP,\n         }\n@@ -433,12 +439,12 @@ mod test {\n     macro_rules! dummy_meta_item_list {\n         ($name:ident, [$($list:ident),* $(,)?]) => {\n             MetaItem {\n-                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                path: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec![\n                     $(\n-                        dummy_spanned(NestedMetaItemKind::MetaItem(\n+                        NestedMetaItem::MetaItem(\n                             dummy_meta_item_word(stringify!($list)),\n-                        )),\n+                        ),\n                     )*\n                 ]),\n                 span: DUMMY_SP,\n@@ -447,10 +453,10 @@ mod test {\n \n         ($name:ident, [$($list:expr),* $(,)?]) => {\n             MetaItem {\n-                ident: Path::from_ident(Ident::from_str(stringify!($name))),\n+                path: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec![\n                     $(\n-                        dummy_spanned(NestedMetaItemKind::MetaItem($list)),\n+                        NestedMetaItem::MetaItem($list),\n                     )*\n                 ]),\n                 span: DUMMY_SP,\n@@ -587,7 +593,7 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n             let mi = MetaItem {\n-                ident: Path::from_ident(Ident::from_str(\"all\")),\n+                path: Path::from_ident(Ident::from_str(\"all\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n                     Symbol::intern(\"done\"),\n                     StrStyle::Cooked,\n@@ -622,7 +628,7 @@ mod test {\n     fn test_parse_err() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                ident: Path::from_ident(Ident::from_str(\"foo\")),\n+                path: Path::from_ident(Ident::from_str(\"foo\")),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n                 span: DUMMY_SP,\n             };"}, {"sha": "3aea661f6bec5ef0d9d49c3da4e3348590e6a653", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -492,7 +492,7 @@ impl Item {\n \n     pub fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter()\n-            .any(|a| a.name().as_str() == \"non_exhaustive\")\n+            .any(|a| a.check_name(\"non_exhaustive\"))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -777,15 +777,15 @@ pub struct Attributes {\n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n     fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n-        use syntax::ast::NestedMetaItemKind::MetaItem;\n+        use syntax::ast::NestedMetaItem::MetaItem;\n \n         if let ast::MetaItemKind::List(ref nmis) = mi.node {\n             if nmis.len() == 1 {\n-                if let MetaItem(ref cfg_mi) = nmis[0].node {\n+                if let MetaItem(ref cfg_mi) = nmis[0] {\n                     if cfg_mi.check_name(\"cfg\") {\n                         if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n                             if cfg_nmis.len() == 1 {\n-                                if let MetaItem(ref content_mi) = cfg_nmis[0].node {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0] {\n                                     return Some(content_mi);\n                                 }\n                             }\n@@ -3683,7 +3683,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n+            a.check_name(\"doc\") && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"inline\"),\n                 None => false,\n             }\n@@ -3722,7 +3722,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n+            a.check_name(\"doc\") && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),\n                 None => false,"}, {"sha": "dca6458c701c589e022a3275f50cd6838f902cea", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -521,8 +521,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n                 let diag = ctxt.sess().diagnostic();\n \n-                let name = attr.name().map(|s| s.as_str());\n-                let name = name.as_ref().map(|s| &s[..]);\n+                let name = attr.ident_str();\n                 if attr.is_word() {\n                     if name == Some(\"no_default_passes\") {\n                         report_deprecated_attr(\"no_default_passes\", diag);"}, {"sha": "b3a816d17f56cf97b484e3a8590b893a6552b5bc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -562,8 +562,7 @@ pub fn run(mut krate: clean::Crate,\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n         for attr in attrs.lists(\"doc\") {\n-            let name = attr.name().map(|s| s.as_str());\n-            match (name.as_ref().map(|s| &s[..]), attr.value_str()) {\n+            match (attr.ident_str(), attr.value_str()) {\n                 (Some(\"html_favicon_url\"), Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n@@ -3714,19 +3713,19 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.name();\n+    let path = attr.path.to_string();\n \n     if attr.is_word() {\n-        Some(name.to_string())\n+        Some(path)\n     } else if let Some(v) = attr.value_str() {\n-        Some(format!(\"{} = {:?}\", name, v.as_str()))\n+        Some(format!(\"{} = {:?}\", path, v.as_str()))\n     } else if let Some(values) = attr.meta_item_list() {\n         let display: Vec<_> = values.iter().filter_map(|attr| {\n             attr.meta_item().and_then(|mi| render_attribute(mi))\n         }).collect();\n \n         if display.len() > 0 {\n-            Some(format!(\"{}({})\", name, display.join(\", \")))\n+            Some(format!(\"{}({})\", path, display.join(\", \")))\n         } else {\n             None\n         }\n@@ -3750,8 +3749,7 @@ fn render_attributes(w: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Resul\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name();\n-        if !ATTRIBUTE_WHITELIST.contains(&&*name.as_str()) {\n+        if !attr.ident_str().map_or(false, |name| ATTRIBUTE_WHITELIST.contains(&name)) {\n             continue;\n         }\n         if let Some(s) = render_attribute(&attr.meta().unwrap()) {"}, {"sha": "b4db121fb530ac3bddb5604bf72d32082098cc2a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -178,9 +178,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(kind) => {\n                 let name = if kind == MacroKind::Derive {\n                     item.attrs.lists(\"proc_macro_derive\")\n-                              .filter_map(|mi| mi.name())\n+                              .filter_map(|mi| mi.ident())\n                               .next()\n                               .expect(\"proc-macro derives require a name\")\n+                              .name\n                 } else {\n                     name\n                 };\n@@ -193,8 +194,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                     if let Some(list) = mi.meta_item_list() {\n                         for inner_mi in list {\n-                            if let Some(name) = inner_mi.name() {\n-                                helpers.push(name);\n+                            if let Some(ident) = inner_mi.ident() {\n+                                helpers.push(ident.name);\n                             }\n                         }\n                     }"}, {"sha": "1a0da73880cfcdc1178b32c832af43d09dc1b064", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -443,14 +443,11 @@ pub struct Crate {\n     pub span: Span,\n }\n \n-/// A spanned compile-time attribute list item.\n-pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n-\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum NestedMetaItemKind {\n+pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n     /// A literal.\n@@ -464,7 +461,7 @@ pub enum NestedMetaItemKind {\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MetaItem {\n-    pub ident: Path,\n+    pub path: Path,\n     pub node: MetaItemKind,\n     pub span: Span,\n }\n@@ -2207,7 +2204,7 @@ pub struct Item {\n impl Item {\n     /// Return the span that encompasses the attributes.\n     pub fn span_with_attributes(&self) -> Span {\n-        self.attrs.iter().fold(self.span, |acc, attr| acc.to(attr.span()))\n+        self.attrs.iter().fold(self.span, |acc, attr| acc.to(attr.span))\n     }\n }\n "}, {"sha": "cdfb83c6e56c8ca6f44caab293dd2af51ce5ca36", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use crate::ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n+use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -10,8 +10,8 @@ use syntax_pos::{symbol::Symbol, Span};\n use super::{mark_used, MetaItemKind};\n \n enum AttrError {\n-    MultipleItem(Name),\n-    UnknownMetaItem(Name, &'static [&'static str]),\n+    MultipleItem(String),\n+    UnknownMetaItem(String, &'static [&'static str]),\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n@@ -155,10 +155,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n     attrs.iter().any(|item| {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n-            list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n-                         .unwrap_or(false)\n-            })\n+            list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name))\n         }).unwrap_or(false)\n     })\n }\n@@ -206,7 +203,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.path.to_string()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -225,25 +222,25 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match mi.ident_str() {\n                                 $(\n-                                    stringify!($name)\n+                                    Some(stringify!($name))\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     let expected = &[ $( stringify!($name) ),+ ];\n                                     handle_errors(\n                                         sess,\n                                         mi.span,\n-                                        AttrError::UnknownMetaItem(mi.name(), expected),\n+                                        AttrError::UnknownMetaItem(mi.path.to_string(), expected),\n                                     );\n                                     continue 'outer\n                                 }\n                             }\n                         } else {\n                             handle_errors(\n                                 sess,\n-                                meta.span,\n+                                meta.span(),\n                                 AttrError::UnsupportedLiteral(\n                                     \"unsupported literal\",\n                                     false,\n@@ -255,7 +252,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                 }\n             }\n \n-            match &*meta.name().as_str() {\n+            match meta.ident_str().expect(\"not a stability level\") {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -274,11 +271,11 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingSince);\n+                            handle_errors(sess, attr.span, AttrError::MissingSince);\n                             continue\n                         }\n                         _ => {\n-                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n+                            span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\");\n                             continue\n                         }\n                     }\n@@ -294,13 +291,13 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     if let Some(feature) = feature {\n                         rustc_const_unstable = Some(feature);\n                     } else {\n-                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n+                        span_err!(diagnostic, attr.span, E0629, \"missing 'feature'\");\n                         continue\n                     }\n                 }\n                 \"unstable\" => {\n                     if stab.is_some() {\n-                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels);\n+                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n@@ -309,16 +306,16 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                            match mi.ident_str() {\n+                                Some(\"feature\") => if !get(mi, &mut feature) { continue 'outer },\n+                                Some(\"reason\") => if !get(mi, &mut reason) { continue 'outer },\n+                                Some(\"issue\") => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n-                                        meta.span,\n+                                        meta.span(),\n                                         AttrError::UnknownMetaItem(\n-                                            mi.name(),\n+                                            mi.path.to_string(),\n                                             &[\"feature\", \"reason\", \"issue\"]\n                                         ),\n                                     );\n@@ -328,7 +325,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                         } else {\n                             handle_errors(\n                                 sess,\n-                                meta.span,\n+                                meta.span(),\n                                 AttrError::UnsupportedLiteral(\n                                     \"unsupported literal\",\n                                     false,\n@@ -347,7 +344,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                                         if let Ok(issue) = issue.as_str().parse() {\n                                             issue\n                                         } else {\n-                                            span_err!(diagnostic, attr.span(), E0545,\n+                                            span_err!(diagnostic, attr.span, E0545,\n                                                       \"incorrect 'issue'\");\n                                             continue\n                                         }\n@@ -360,42 +357,44 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingFeature);\n+                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n+                            span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\");\n                             continue\n                         }\n                     }\n                 }\n                 \"stable\" => {\n                     if stab.is_some() {\n-                        handle_errors(sess, attr.span(), AttrError::MultipleStabilityLevels);\n+                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n                         break\n                     }\n \n                     let mut feature = None;\n                     let mut since = None;\n                     for meta in metas {\n-                        match &meta.node {\n-                            NestedMetaItemKind::MetaItem(mi) => {\n-                                match &*mi.name().as_str() {\n-                                    \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                    \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                        match meta {\n+                            NestedMetaItem::MetaItem(mi) => {\n+                                match mi.ident_str() {\n+                                    Some(\"feature\") =>\n+                                        if !get(mi, &mut feature) { continue 'outer },\n+                                    Some(\"since\") =>\n+                                        if !get(mi, &mut since) { continue 'outer },\n                                     _ => {\n                                         handle_errors(\n                                             sess,\n-                                            meta.span,\n+                                            meta.span(),\n                                             AttrError::UnknownMetaItem(\n-                                                mi.name(), &[\"since\", \"note\"],\n+                                                mi.path.to_string(), &[\"since\", \"note\"],\n                                             ),\n                                         );\n                                         continue 'outer\n                                     }\n                                 }\n                             },\n-                            NestedMetaItemKind::Literal(lit) => {\n+                            NestedMetaItem::Literal(lit) => {\n                                 handle_errors(\n                                     sess,\n                                     lit.span,\n@@ -422,11 +421,11 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                             })\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingFeature);\n+                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n                             continue\n                         }\n                         _ => {\n-                            handle_errors(sess, attr.span(), AttrError::MissingSince);\n+                            handle_errors(sess, attr.span, AttrError::MissingSince);\n                             continue\n                         }\n                     }\n@@ -483,8 +482,8 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n             gated_cfg.check_and_emit(sess, feats);\n         }\n         let error = |span, msg| { sess.span_diagnostic.span_err(span, msg); true };\n-        if cfg.ident.segments.len() != 1 {\n-            return error(cfg.ident.span, \"`cfg` predicate key must be an identifier\");\n+        if cfg.path.segments.len() != 1 {\n+            return error(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n         }\n         match &cfg.node {\n             MetaItemKind::List(..) => {\n@@ -502,7 +501,8 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                 true\n             }\n             MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                sess.config.contains(&(cfg.name(), cfg.value_str()))\n+                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+                sess.config.contains(&(ident.name, cfg.value_str()))\n             }\n         }\n     })\n@@ -520,7 +520,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n                 if !mi.is_meta_item() {\n                     handle_errors(\n                         sess,\n-                        mi.span,\n+                        mi.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"unsupported literal\",\n                             false\n@@ -532,23 +532,24 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.name().as_str() {\n-                \"any\" => mis.iter().any(|mi| {\n+            match cfg.ident_str() {\n+                Some(\"any\") => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"all\" => mis.iter().all(|mi| {\n+                Some(\"all\") => mis.iter().all(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"not\" => {\n+                Some(\"not\") => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n                     !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n                 },\n-                p => {\n-                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                _ => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537,\n+                              \"invalid predicate `{}`\", cfg.path);\n                     false\n                 }\n             }\n@@ -602,7 +603,9 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n             MetaItemKind::List(list) => {\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n-                        handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()));\n+                        handle_errors(\n+                            sess, meta.span, AttrError::MultipleItem(meta.path.to_string())\n+                        );\n                         return false\n                     }\n                     if let Some(v) = meta.value_str() {\n@@ -630,22 +633,23 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 let mut since = None;\n                 let mut note = None;\n                 for meta in list {\n-                    match &meta.node {\n-                        NestedMetaItemKind::MetaItem(mi) => {\n-                            match &*mi.name().as_str() {\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                    match meta {\n+                        NestedMetaItem::MetaItem(mi) => {\n+                            match mi.ident_str() {\n+                                Some(\"since\") => if !get(mi, &mut since) { continue 'outer },\n+                                Some(\"note\") => if !get(mi, &mut note) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n-                                        meta.span,\n-                                        AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                                        meta.span(),\n+                                        AttrError::UnknownMetaItem(mi.path.to_string(),\n+                                                                   &[\"since\", \"note\"]),\n                                     );\n                                     continue 'outer\n                                 }\n                             }\n                         }\n-                        NestedMetaItemKind::Literal(lit) => {\n+                        NestedMetaItem::Literal(lit) => {\n                             handle_errors(\n                                 sess,\n                                 lit.span,\n@@ -714,7 +718,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 if !item.is_meta_item() {\n                     handle_errors(\n                         sess,\n-                        item.span,\n+                        item.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"meta item in `repr` must be an identifier\",\n                             false,\n@@ -724,19 +728,13 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n \n                 let mut recognised = false;\n-                if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n-                    let hint = match word {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n-                        _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(ity)),\n-                            None => {\n-                                None\n-                            }\n-                        }\n+                if item.is_word() {\n+                    let hint = match item.ident_str() {\n+                        Some(\"C\") => Some(ReprC),\n+                        Some(\"packed\") => Some(ReprPacked(1)),\n+                        Some(\"simd\") => Some(ReprSimd),\n+                        Some(\"transparent\") => Some(ReprTransparent),\n+                        name => name.and_then(|name| int_type_of_word(name)).map(ReprInt),\n                     };\n \n                     if let Some(h) = hint {\n@@ -777,28 +775,28 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                         };\n                     }\n                     if let Some(literal_error) = literal_error {\n-                        span_err!(diagnostic, item.span, E0589,\n+                        span_err!(diagnostic, item.span(), E0589,\n                                   \"invalid `repr(align)` attribute: {}\", literal_error);\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.name() == \"align\" {\n+                        if meta_item.check_name(\"align\") {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n-                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n+                                let mut err = struct_span_err!(diagnostic, item.span(), E0693,\n                                     \"incorrect `repr(align)` attribute format\");\n                                 match value.node {\n                                     ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n                                         err.span_suggestion(\n-                                            item.span,\n+                                            item.span(),\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", int),\n                                             Applicability::MachineApplicable\n                                         );\n                                     }\n                                     ast::LitKind::Str(s, _) => {\n                                         err.span_suggestion(\n-                                            item.span,\n+                                            item.span(),\n                                             \"use parentheses instead\",\n                                             format!(\"align({})\", s),\n                                             Applicability::MachineApplicable\n@@ -813,7 +811,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n                 if !recognised {\n                     // Not a word we recognize\n-                    span_err!(diagnostic, item.span, E0552,\n+                    span_err!(diagnostic, item.span(), E0552,\n                               \"unrecognized representation hint\");\n                 }\n             }"}, {"sha": "1a8faa43fff7c1fc065312eb6935c09c1a652a4d", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 68, "deletions": 86, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -13,7 +13,7 @@ pub use StabilityLevel::*;\n \n use crate::ast;\n use crate::ast::{AttrId, Attribute, AttrStyle, Name, Ident, Path, PathSegment};\n-use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n+use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned, respan, dummy_spanned};\n@@ -64,36 +64,33 @@ pub fn is_known_lint_tool(m_item: Ident) -> bool {\n }\n \n impl NestedMetaItem {\n-    /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n+    /// Returns the MetaItem if self is a NestedMetaItem::MetaItem.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n-        match self.node {\n-            NestedMetaItemKind::MetaItem(ref item) => Some(item),\n+        match *self {\n+            NestedMetaItem::MetaItem(ref item) => Some(item),\n             _ => None\n         }\n     }\n \n-    /// Returns the Lit if self is a NestedMetaItemKind::Literal.\n+    /// Returns the Lit if self is a NestedMetaItem::Literal.\n     pub fn literal(&self) -> Option<&Lit> {\n-        match self.node {\n-            NestedMetaItemKind::Literal(ref lit) => Some(lit),\n+        match *self {\n+            NestedMetaItem::Literal(ref lit) => Some(lit),\n             _ => None\n         }\n     }\n \n-    /// Returns the Span for `self`.\n-    pub fn span(&self) -> Span {\n-        self.span\n-    }\n-\n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n     pub fn check_name(&self, name: &str) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n-    /// Returns the name of the meta item, e.g., `foo` in `#[foo]`,\n-    /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n-    pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+    /// For a single-segment meta-item returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        self.meta_item().and_then(|meta_item| meta_item.ident())\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -108,25 +105,14 @@ impl NestedMetaItem {\n             |meta_item| meta_item.meta_item_list().and_then(\n                 |meta_item_list| {\n                     if meta_item_list.len() == 1 {\n-                        let nested_item = &meta_item_list[0];\n-                        if nested_item.is_literal() {\n-                            Some((meta_item.name(), nested_item.literal().unwrap()))\n-                        } else {\n-                            None\n+                        if let Some(ident) = meta_item.ident() {\n+                            if let Some(lit) = meta_item_list[0].literal() {\n+                                return Some((ident.name, lit));\n+                            }\n                         }\n                     }\n-                    else {\n-                        None\n-                    }}))\n-    }\n-\n-    /// Returns a MetaItem if self is a MetaItem with Kind Word.\n-    pub fn word(&self) -> Option<&MetaItem> {\n-        self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n-            Some(meta_item)\n-        } else {\n-            None\n-        })\n+                    None\n+                }))\n     }\n \n     /// Gets a list of inner meta items from a list MetaItem type.\n@@ -146,7 +132,7 @@ impl NestedMetaItem {\n \n     /// Returns `true` if self is a MetaItem and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n-        self.word().is_some()\n+        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n     /// Returns `true` if self is a MetaItem and the meta item is a ValueString.\n@@ -160,10 +146,6 @@ impl NestedMetaItem {\n     }\n }\n \n-fn name_from_path(path: &Path) -> Name {\n-    path.segments.last().expect(\"empty path in attribute\").ident.name\n-}\n-\n impl Attribute {\n     /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n     /// attribute is marked as used.\n@@ -177,10 +159,16 @@ impl Attribute {\n         matches\n     }\n \n-    /// Returns the **last** segment of the name of this attribute.\n-    /// e.g., `foo` for `#[foo]`, `skip` for `#[rustfmt::skip]`.\n-    pub fn name(&self) -> Name {\n-        name_from_path(&self.path)\n+    /// For a single-segment attribute returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 {\n+            Some(self.path.segments[0].ident)\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -195,11 +183,7 @@ impl Attribute {\n     }\n \n     pub fn is_word(&self) -> bool {\n-        self.path.segments.len() == 1 && self.tokens.is_empty()\n-    }\n-\n-    pub fn span(&self) -> Span {\n-        self.span\n+        self.tokens.is_empty()\n     }\n \n     pub fn is_meta_item_list(&self) -> bool {\n@@ -213,8 +197,16 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> Name {\n-        name_from_path(&self.ident)\n+    /// For a single-segment meta-item returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 {\n+            Some(self.path.segments[0].ident)\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     // #[attribute(name = \"value\")]\n@@ -252,10 +244,8 @@ impl MetaItem {\n         }\n     }\n \n-    pub fn span(&self) -> Span { self.span }\n-\n     pub fn check_name(&self, name: &str) -> bool {\n-        self.name() == name\n+        self.path == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -265,22 +255,14 @@ impl MetaItem {\n     pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n     }\n-\n-    pub fn is_scoped(&self) -> Option<Ident> {\n-        if self.ident.segments.len() > 1 {\n-            Some(self.ident.segments[0].ident)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n impl Attribute {\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            ident: self.path.clone(),\n+            path: self.path.clone(),\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n                 if tokens.peek().is_some() {\n                     return None;\n@@ -326,7 +308,7 @@ impl Attribute {\n \n     pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n         Ok(MetaItem {\n-            ident: self.path.clone(),\n+            path: self.path.clone(),\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -364,19 +346,19 @@ pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem\n }\n \n pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n-    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n+    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::NameValue(value) }\n }\n \n pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { ident: Path::from_ident(ident), span, node: MetaItemKind::List(items) }\n+    MetaItem { path: Path::from_ident(ident), span, node: MetaItemKind::List(items) }\n }\n \n pub fn mk_word_item(ident: Ident) -> MetaItem {\n-    MetaItem { ident: Path::from_ident(ident), span: ident.span, node: MetaItemKind::Word }\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, node: MetaItemKind::Word }\n }\n \n pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n-    respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n+    NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -400,7 +382,7 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: item.ident,\n+        path: item.path,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -417,7 +399,7 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: item.ident,\n+        path: item.path,\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -468,7 +450,7 @@ impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n         let mut idents = vec![];\n         let mut last_pos = BytePos(0 as u32);\n-        for (i, segment) in self.ident.segments.iter().enumerate() {\n+        for (i, segment) in self.path.segments.iter().enumerate() {\n             let is_first = i == 0;\n             if !is_first {\n                 let mod_sep_span = Span::new(last_pos,\n@@ -488,7 +470,7 @@ impl MetaItem {\n         where I: Iterator<Item = TokenTree>,\n     {\n         // FIXME: Share code with `parse_path`.\n-        let ident = match tokens.next() {\n+        let path = match tokens.next() {\n             Some(TokenTree::Token(span, token @ Token::Ident(..))) |\n             Some(TokenTree::Token(span, token @ Token::ModSep)) => 'arm: {\n                 let mut segments = if let Token::Ident(ident, _) = token {\n@@ -529,11 +511,11 @@ impl MetaItem {\n         let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n-            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(ident.span.hi()),\n-            _ => ident.span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n+            _ => path.span.hi(),\n         };\n-        let span = ident.span.with_hi(hi);\n-        Some(MetaItem { ident, node, span })\n+        let span = path.span.with_hi(hi);\n+        Some(MetaItem { path, node, span })\n     }\n }\n \n@@ -552,7 +534,7 @@ impl MetaItemKind {\n                     if i > 0 {\n                         tokens.push(TokenTree::Token(span, Token::Comma).into());\n                     }\n-                    item.node.tokens().append_to_tree_and_joint_vec(&mut tokens);\n+                    item.tokens().append_to_tree_and_joint_vec(&mut tokens);\n                 }\n                 TokenTree::Delimited(\n                     DelimSpan::from_single(span),\n@@ -586,8 +568,8 @@ impl MetaItemKind {\n         let mut tokens = delimited.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n-            let item = NestedMetaItemKind::from_tokens(&mut tokens)?;\n-            result.push(respan(item.span(), item));\n+            let item = NestedMetaItem::from_tokens(&mut tokens)?;\n+            result.push(item);\n             match tokens.next() {\n                 None | Some(TokenTree::Token(_, Token::Comma)) => {}\n                 _ => return None,\n@@ -597,32 +579,32 @@ impl MetaItemKind {\n     }\n }\n \n-impl NestedMetaItemKind {\n-    fn span(&self) -> Span {\n+impl NestedMetaItem {\n+    pub fn span(&self) -> Span {\n         match *self {\n-            NestedMetaItemKind::MetaItem(ref item) => item.span,\n-            NestedMetaItemKind::Literal(ref lit) => lit.span,\n+            NestedMetaItem::MetaItem(ref item) => item.span,\n+            NestedMetaItem::Literal(ref lit) => lit.span,\n         }\n     }\n \n     fn tokens(&self) -> TokenStream {\n         match *self {\n-            NestedMetaItemKind::MetaItem(ref item) => item.tokens(),\n-            NestedMetaItemKind::Literal(ref lit) => lit.tokens(),\n+            NestedMetaItem::MetaItem(ref item) => item.tokens(),\n+            NestedMetaItem::Literal(ref lit) => lit.tokens(),\n         }\n     }\n \n-    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItemKind>\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n             if let Some(node) = LitKind::from_token(token) {\n                 tokens.next();\n-                return Some(NestedMetaItemKind::Literal(respan(span, node)));\n+                return Some(NestedMetaItem::Literal(respan(span, node)));\n             }\n         }\n \n-        MetaItem::from_tokens(tokens).map(NestedMetaItemKind::MetaItem)\n+        MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n "}, {"sha": "c300ffc2d61b9259f4adb9e77ef5d45bcb263f0f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -181,13 +181,13 @@ impl<'a> StripUnconfigured<'a> {\n             if nested_meta_items.is_empty() {\n                 return error(meta_item.span, \"`cfg` predicate is not specified\", \"\");\n             } else if nested_meta_items.len() > 1 {\n-                return error(nested_meta_items.last().unwrap().span,\n+                return error(nested_meta_items.last().unwrap().span(),\n                              \"multiple `cfg` predicates are specified\", \"\");\n             }\n \n             match nested_meta_items[0].meta_item() {\n                 Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n-                None => error(nested_meta_items[0].span,\n+                None => error(nested_meta_items[0].span(),\n                               \"`cfg` predicate key cannot be a literal\", \"\"),\n             }\n         })"}, {"sha": "82358679c0e824281559710d016b9a29b12db51d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -601,7 +601,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 res\n             }\n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n-                self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n+                self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n             }\n@@ -822,7 +822,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n \n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n-                self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n+                self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n@@ -929,7 +929,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    ident: Path::from_ident(keywords::Invalid.ident()),\n+                    path: Path::from_ident(keywords::Invalid.ident()),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -1520,23 +1520,23 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                             self.cx.source_map().new_source_file(filename.into(), src);\n \n                             let include_info = vec![\n-                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n                                         Ident::from_str(\"file\"),\n                                         dummy_spanned(file),\n                                     ),\n-                                )),\n-                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                ),\n+                                ast::NestedMetaItem::MetaItem(\n                                     attr::mk_name_value_item_str(\n                                         Ident::from_str(\"contents\"),\n                                         dummy_spanned(src_interned),\n                                     ),\n-                                )),\n+                                ),\n                             ];\n \n                             let include_ident = Ident::from_str(\"include\");\n                             let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n-                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(item)));\n+                            items.push(ast::NestedMetaItem::MetaItem(item));\n                         }\n                         Err(e) => {\n                             let lit = it\n@@ -1569,7 +1569,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     }\n                 } else {\n                     let mut err = self.cx.struct_span_err(\n-                        it.span,\n+                        it.span(),\n                         &format!(\"expected path to external documentation\"),\n                     );\n \n@@ -1590,7 +1590,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     };\n \n                     err.span_suggestion(\n-                        it.span,\n+                        it.span(),\n                         \"provide a file path with `=`\",\n                         format!(\"include = \\\"{}\\\"\", path),\n                         applicability,"}, {"sha": "12912044e4e3dfe93c6787674cc47ba66dca24fa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -380,9 +380,14 @@ pub fn compile(\n             .map(|attr| attr\n                 .meta_item_list()\n                 .map(|list| list.iter()\n-                    .map(|it| it.name().unwrap_or_else(|| sess.span_diagnostic.span_bug(\n-                        it.span, \"allow internal unstable expects feature names\",\n-                    )))\n+                    .filter_map(|it| {\n+                        let name = it.ident().map(|ident| ident.name);\n+                        if name.is_none() {\n+                            sess.span_diagnostic.span_err(it.span(),\n+                                \"allow internal unstable expects feature names\")\n+                        }\n+                        name\n+                    })\n                     .collect::<Vec<Symbol>>().into()\n                 )\n                 .unwrap_or_else(|| {"}, {"sha": "9beaabb0cd58ba857fc6b3175427568826aa10f9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1289,9 +1289,8 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name().as_str();\n         GATED_CFGS.iter()\n-                  .position(|info| info.0 == name)\n+                  .position(|info| cfg.check_name(info.0))\n                   .map(|idx| {\n                       GatedCfg {\n                           span: cfg.span,\n@@ -1342,16 +1341,16 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = attr.name().as_str();\n+        let name = attr.ident_str();\n         for &(n, ty, _template, ref gateage) in BUILTIN_ATTRIBUTES {\n-            if name == n {\n+            if name == Some(n) {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n                     if !attr.span.allows_unstable(name) {\n                         gate_feature_fn!(\n                             self, has_feature, attr.span, name, desc, GateStrength::Hard\n                         );\n                     }\n-                } else if name == \"doc\" {\n+                } else if n == \"doc\" {\n                     if let Some(content) = attr.meta_item_list() {\n                         if content.iter().any(|c| c.check_name(\"include\")) {\n                             gate_feature!(self, external_doc, attr.span,\n@@ -1374,7 +1373,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !attr::is_known(attr) {\n-            if name.starts_with(\"rustc_\") {\n+            if name.map_or(false, |name| name.starts_with(\"rustc_\")) {\n                 let msg = \"unless otherwise specified, attributes with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\";\n                 gate_feature!(self, rustc_attrs, attr.span, msg);\n@@ -2055,15 +2054,14 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         };\n \n         for mi in list {\n-            let name = if let Some(word) = mi.word() {\n-                word.name()\n-            } else {\n-                continue\n+            let name = match mi.ident_str() {\n+                Some(name) if mi.is_word() => name,\n+                _ => continue,\n             };\n \n-            if incomplete_features.iter().any(|f| *f == name.as_str()) {\n+            if incomplete_features.iter().any(|f| *f == name) {\n                 span_handler.struct_span_warn(\n-                    mi.span,\n+                    mi.span(),\n                     &format!(\n                         \"the feature `{}` is incomplete and may cause the compiler to crash\",\n                         name\n@@ -2101,18 +2099,19 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         };\n \n         for mi in list {\n-            let name = if let Some(word) = mi.word() {\n-                word.name()\n-            } else {\n-                span_err!(span_handler, mi.span, E0556,\n-                          \"malformed feature, expected just one word\");\n-                continue\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                _ => {\n+                    span_err!(span_handler, mi.span(), E0556,\n+                            \"malformed feature, expected just one word\");\n+                    continue\n+                }\n             };\n \n             if let Some(edition) = edition_enabled_features.get(&name) {\n                 struct_span_warn!(\n                     span_handler,\n-                    mi.span,\n+                    mi.span(),\n                     E0705,\n                     \"the feature `{}` is included in the Rust {} edition\",\n                     name,\n@@ -2129,32 +2128,32 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n                 if let Some(allowed) = allow_features.as_ref() {\n                     if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n-                        span_err!(span_handler, mi.span, E0725,\n+                        span_err!(span_handler, mi.span(), E0725,\n                                   \"the feature `{}` is not in the list of allowed features\",\n                                   name);\n                         continue;\n                     }\n                 }\n \n-                set(&mut features, mi.span);\n-                features.declared_lang_features.push((name, mi.span, None));\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n                 continue\n             }\n \n             let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n             let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n             if let Some((.., reason)) = removed.or(stable_removed) {\n-                feature_removed(span_handler, mi.span, *reason);\n+                feature_removed(span_handler, mi.span(), *reason);\n                 continue\n             }\n \n             if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n                 let since = Some(Symbol::intern(since));\n-                features.declared_lang_features.push((name, mi.span, since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n                 continue\n             }\n \n-            features.declared_lib_features.push((name, mi.span));\n+            features.declared_lib_features.push((name, mi.span()));\n         }\n     }\n "}, {"sha": "462346df7d76d4a66255eb1bbb75cde7ac4a8d9c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -539,16 +539,14 @@ pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n-    let Spanned { node, span } = li;\n-    match node {\n-        NestedMetaItemKind::MetaItem(mi) => vis.visit_meta_item(mi),\n-        NestedMetaItemKind::Literal(_lit) => {}\n+    match li {\n+        NestedMetaItem::MetaItem(mi) => vis.visit_meta_item(mi),\n+        NestedMetaItem::Literal(_lit) => {}\n     }\n-    vis.visit_span(span);\n }\n \n pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n-    let MetaItem { ident: _, node, span } = mi;\n+    let MetaItem { path: _, node, span } = mi;\n     match node {\n         MetaItemKind::Word => {}\n         MetaItemKind::List(mis) => visit_vec(mis, |mi| vis.visit_meta_list_item(mi)),\n@@ -1340,4 +1338,3 @@ mod tests {\n         })\n     }\n }\n-"}, {"sha": "4211268f33efef7ac0b24fa8701efc5327f06c82", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,6 +1,5 @@\n use crate::attr;\n use crate::ast;\n-use crate::source_map::respan;\n use crate::parse::{SeqSep, PResult};\n use crate::parse::token::{self, Nonterminal, DelimToken};\n use crate::parse::parser::{Parser, TokenType, PathStyle};\n@@ -149,7 +148,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (meta.ident, meta.node.tokens(meta.span))\n+            (meta.path, meta.node.tokens(meta.span))\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n             let tokens = if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n@@ -250,10 +249,10 @@ impl<'a> Parser<'a> {\n         }\n \n         let lo = self.span;\n-        let ident = self.parse_path(PathStyle::Mod)?;\n+        let path = self.parse_path(PathStyle::Mod)?;\n         let node = self.parse_meta_item_kind()?;\n         let span = lo.to(self.prev_span);\n-        Ok(ast::MetaItem { ident, node, span })\n+        Ok(ast::MetaItem { path, node, span })\n     }\n \n     crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n@@ -268,18 +267,16 @@ impl<'a> Parser<'a> {\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        let lo = self.span;\n-\n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => {\n-                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::Literal(lit)))\n+                return Ok(ast::NestedMetaItem::Literal(lit))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n-                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::MetaItem(mi)))\n+                return Ok(ast::NestedMetaItem::MetaItem(mi))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }"}, {"sha": "bcd53dbfeb2c5de9a865a4770085dc99e4c93bf0", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Ident};\n use crate::source_map::{SourceMap, FilePathMapping};\n use crate::parse::{token, ParseSess};\n-use crate::symbol::{Symbol, keywords};\n+use crate::symbol::Symbol;\n \n use errors::{Applicability, FatalError, Diagnostic, DiagnosticBuilder};\n use syntax_pos::{BytePos, CharPos, Pos, Span, NO_EXPANSION};\n@@ -1249,15 +1249,11 @@ impl<'a> StringReader<'a> {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n                     let ident = self.mk_ident(string);\n \n-                    if is_raw_ident && (ident.is_path_segment_keyword() ||\n-                                        ident.name == keywords::Underscore.name()) {\n-                        self.fatal_span_(raw_start, self.pos,\n-                            &format!(\"`r#{}` is not currently supported.\", ident.name)\n-                        ).raise();\n-                    }\n-\n                     if is_raw_ident {\n                         let span = self.mk_sp(raw_start, self.pos);\n+                        if !ident.can_be_raw() {\n+                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", ident));\n+                        }\n                         self.sess.raw_identifier_spans.borrow_mut().push(span);\n                     }\n "}, {"sha": "aa70c54a1ef8aacc9132ec6387aaa3bc2896eb2c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -895,9 +895,7 @@ impl<'a> Parser<'a> {\n                                            &format!(\"expected identifier, found {}\",\n                                                     self.this_token_descr()));\n         if let token::Ident(ident, false) = &self.token {\n-            if ident.is_reserved() && !ident.is_path_segment_keyword() &&\n-                ident.name != keywords::Underscore.name()\n-            {\n+            if ident.is_raw_guess() {\n                 err.span_suggestion(\n                     self.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n@@ -2335,7 +2333,7 @@ impl<'a> Parser<'a> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref meta) => match meta.node {\n-                    ast::MetaItemKind::Word => Some(meta.ident.clone()),\n+                    ast::MetaItemKind::Word => Some(meta.path.clone()),\n                     _ => None,\n                 },\n                 _ => None,"}, {"sha": "e04e127ccf15a8e800eef58068452b5170b3768a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -768,11 +768,11 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_meta_list_item(&mut self, item: &ast::NestedMetaItem) -> io::Result<()> {\n-        match item.node {\n-            ast::NestedMetaItemKind::MetaItem(ref mi) => {\n+        match item {\n+            ast::NestedMetaItem::MetaItem(ref mi) => {\n                 self.print_meta_item(mi)\n             },\n-            ast::NestedMetaItemKind::Literal(ref lit) => {\n+            ast::NestedMetaItem::Literal(ref lit) => {\n                 self.print_literal(lit)\n             }\n         }\n@@ -781,15 +781,15 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n-            ast::MetaItemKind::Word => self.print_attribute_path(&item.ident)?,\n+            ast::MetaItemKind::Word => self.print_attribute_path(&item.path)?,\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.print_attribute_path(&item.ident)?;\n+                self.print_attribute_path(&item.path)?;\n                 self.writer().space()?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.print_attribute_path(&item.ident)?;\n+                self.print_attribute_path(&item.path)?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],"}, {"sha": "6f03c5854036c4e99c18429647a678e420bc2b10", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -435,9 +435,12 @@ fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path\n     let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n     test_attr.meta_item_list().map(|meta_list| {\n         if meta_list.len() != 1 {\n-            sd.span_fatal(test_attr.span(),\n+            sd.span_fatal(test_attr.span,\n                 \"#![test_runner(..)] accepts exactly 1 argument\").raise()\n         }\n-        meta_list[0].word().as_ref().unwrap().ident.clone()\n+        match meta_list[0].meta_item() {\n+            Some(meta_item) if meta_item.is_word() => meta_item.path.clone(),\n+            _ => sd.span_fatal(test_attr.span, \"`test_runner` argument must be a path\").raise()\n+        }\n     })\n }"}, {"sha": "e73110717e97968209e3b82eb5ab1ceeddd68328", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -17,9 +17,11 @@ struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        if self.0.contains(&attr.name()) {\n-            mark_used(attr);\n-            mark_known(attr);\n+        if let Some(ident) = attr.ident() {\n+            if self.0.contains(&ident.name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n         }\n     }\n "}, {"sha": "2bb98c1bf625cfb9363b7d86dab8513b98e5da6a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -463,12 +463,9 @@ impl<'a> TraitDef<'a> {\n                 let mut attrs = newitem.attrs.clone();\n                 attrs.extend(item.attrs\n                     .iter()\n-                    .filter(|a| {\n-                        match &*a.name().as_str() {\n-                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n-                            _ => false,\n-                        }\n-                    })\n+                    .filter(|a| a.ident_str().map_or(false, |name| {\n+                        [\"allow\", \"warn\", \"deny\", \"forbid\", \"stable\", \"unstable\"].contains(&name)\n+                    }))\n                     .cloned());\n                 push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))\n             }"}, {"sha": "d5f37aff222ef4e70dac2eec9b130392a2b3a160", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -109,52 +109,67 @@ impl<'a> CollectProcMacros<'a> {\n             None => return,\n         };\n         if list.len() != 1 && list.len() != 2 {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(attr.span,\n                                   \"attribute must have either one or two arguments\");\n             return\n         }\n-        let trait_attr = &list[0];\n-        let attributes_attr = list.get(1);\n-        let trait_name = match trait_attr.name() {\n-            Some(name) => name,\n+        let trait_attr = match list[0].meta_item() {\n+            Some(meta_item) => meta_item,\n             _ => {\n-                self.handler.span_err(trait_attr.span(), \"not a meta item\");\n+                self.handler.span_err(list[0].span(), \"not a meta item\");\n+                return\n+            }\n+        };\n+        let trait_ident = match trait_attr.ident() {\n+            Some(trait_ident) if trait_attr.is_word() => trait_ident,\n+            _ => {\n+                self.handler.span_err(trait_attr.span, \"must only be one word\");\n                 return\n             }\n         };\n-        if !trait_attr.is_word() {\n-            self.handler.span_err(trait_attr.span(), \"must only be one word\");\n-        }\n \n-        if deriving::is_builtin_trait(trait_name) {\n-            self.handler.span_err(trait_attr.span(),\n-                                  \"cannot override a built-in #[derive] mode\");\n+        if !trait_ident.can_be_raw() {\n+            self.handler.span_err(trait_attr.span,\n+                                  &format!(\"`{}` cannot be a name of derive macro\", trait_ident));\n+        }\n+        if deriving::is_builtin_trait(trait_ident.name) {\n+            self.handler.span_err(trait_attr.span,\n+                                  \"cannot override a built-in derive macro\");\n         }\n \n+        let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n             if !attr.check_name(\"attributes\") {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list().unwrap_or_else(|| {\n                 self.handler.span_err(attr.span(),\n-                                      \"attribute must be of form: \\\n-                                       `attributes(foo, bar)`\");\n+                                      \"attribute must be of form: `attributes(foo, bar)`\");\n                 &[]\n             }).into_iter().filter_map(|attr| {\n-                let name = match attr.name() {\n-                    Some(name) => name,\n+                let attr = match attr.meta_item() {\n+                    Some(meta_item) => meta_item,\n                     _ => {\n                         self.handler.span_err(attr.span(), \"not a meta item\");\n                         return None;\n-                    },\n+                    }\n                 };\n \n-                if !attr.is_word() {\n-                    self.handler.span_err(attr.span(), \"must only be one word\");\n-                    return None;\n+                let ident = match attr.ident() {\n+                    Some(ident) if attr.is_word() => ident,\n+                    _ => {\n+                        self.handler.span_err(attr.span, \"must only be one word\");\n+                        return None;\n+                    }\n+                };\n+                if !ident.can_be_raw() {\n+                    self.handler.span_err(\n+                        attr.span,\n+                        &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n+                    );\n                 }\n \n-                Some(name)\n+                Some(ident.name)\n             }).collect()\n         } else {\n             Vec::new()\n@@ -163,7 +178,7 @@ impl<'a> CollectProcMacros<'a> {\n         if self.in_root && item.vis.node.is_pub() {\n             self.derives.push(ProcMacroDerive {\n                 span: item.span,\n-                trait_name,\n+                trait_name: trait_ident.name,\n                 function_name: item.ident,\n                 attrs: proc_attrs,\n             });\n@@ -247,8 +262,8 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n                                 to the same function\", attr.path, prev_attr.path)\n                     };\n \n-                    self.handler.struct_span_err(attr.span(), &msg)\n-                        .span_note(prev_attr.span(), \"Previous attribute here\")\n+                    self.handler.struct_span_err(attr.span, &msg)\n+                        .span_note(prev_attr.span, \"Previous attribute here\")\n                         .emit();\n \n                     return;\n@@ -273,7 +288,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             let msg = format!(\"the `#[{}]` attribute may only be used on bare functions\",\n                               attr.path);\n \n-            self.handler.span_err(attr.span(), &msg);\n+            self.handler.span_err(attr.span, &msg);\n             return;\n         }\n \n@@ -285,7 +300,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             let msg = format!(\"the `#[{}]` attribute is only usable with crates of the \\\n                               `proc-macro` crate type\", attr.path);\n \n-            self.handler.span_err(attr.span(), &msg);\n+            self.handler.span_err(attr.span, &msg);\n             return;\n         }\n "}, {"sha": "c0a9dfe6189defc20309b9047b50aae0e795d405", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -340,12 +340,8 @@ impl Ident {\n         if !Self::is_valid(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        if is_raw {\n-            let normalized_sym = Symbol::intern(string);\n-            if normalized_sym == keywords::Underscore.name() ||\n-               ast::Ident::with_empty_ctxt(normalized_sym).is_path_segment_keyword() {\n-                panic!(\"`{:?}` is not a valid raw identifier\", string)\n-            }\n+        if is_raw && !ast::Ident::from_str(string).can_be_raw() {\n+            panic!(\"`{}` cannot be a raw identifier\", string);\n         }\n         Ident { sym, is_raw, span }\n     }"}, {"sha": "0dbcb7ce0b7e21a351324b7c35a742d7a75dea61", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -227,7 +227,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n                         .and_then(|mi| mi.value_str());\n                     if list.len() != 1 || msg.is_none() {\n                         sd.struct_span_warn(\n-                            attr.span(),\n+                            attr.span,\n                             \"argument must be of the form: \\\n                              `expected = \\\"error message\\\"`\"\n                         ).note(\"Errors in this attribute were erroneously \\"}, {"sha": "e8d215a562e2c36a05b0a2d903bffbdf3d324822", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -484,11 +484,16 @@ impl Ident {\n         self.name == keywords::DollarCrate.name()\n     }\n \n-    // We see this identifier in a normal identifier position, like variable name or a type.\n-    // How was it written originally? Did it use the raw form? Let's try to guess.\n-    pub fn is_raw_guess(self) -> bool {\n+    /// This identifier can be a raw identifier.\n+    pub fn can_be_raw(self) -> bool {\n         self.name != keywords::Invalid.name() && self.name != keywords::Underscore.name() &&\n-        self.is_reserved() && !self.is_path_segment_keyword()\n+        !self.is_path_segment_keyword()\n+    }\n+\n+    /// We see this identifier in a normal identifier position, like variable name or a type.\n+    /// How was it written originally? Did it use the raw form? Let's try to guess.\n+    pub fn is_raw_guess(self) -> bool {\n+        self.can_be_raw() && self.is_reserved()\n     }\n }\n "}, {"sha": "123a11b6f8543174a54aef3020fa584800182fec", "filename": "src/test/ui/parser/raw/raw-literal-self.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,3 +1,4 @@\n-fn self_test(r#self: u32) {\n-    //~^ ERROR `r#self` is not currently supported.\n+fn main() {\n+    let r#self;\n+    //~^ ERROR `self` cannot be a raw identifier\n }"}, {"sha": "9a330fcdf2aae3375ed338214f513316917256c6", "filename": "src/test/ui/parser/raw/raw-literal-self.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-self.stderr?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,8 +1,8 @@\n-error: `r#self` is not currently supported.\n-  --> $DIR/raw-literal-self.rs:1:14\n+error: `self` cannot be a raw identifier\n+  --> $DIR/raw-literal-self.rs:2:9\n    |\n-LL | fn self_test(r#self: u32) {\n-   |              ^^^^^^\n+LL |     let r#self;\n+   |         ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6d15f1e7f0afdda43b0934c3b3daf319ea67f109", "filename": "src/test/ui/parser/raw/raw-literal-underscore.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,3 +1,4 @@\n-fn underscore_test(r#_: u32) {\n-    //~^ ERROR `r#_` is not currently supported.\n+fn main() {\n+    let r#_;\n+    //~^ ERROR `_` cannot be a raw identifier\n }"}, {"sha": "d96b14f55a39b2da20fc5b330e734aa032a81c49", "filename": "src/test/ui/parser/raw/raw-literal-underscore.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw%2Fraw-literal-underscore.stderr?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,8 +1,8 @@\n-error: `r#_` is not currently supported.\n-  --> $DIR/raw-literal-underscore.rs:1:20\n+error: `_` cannot be a raw identifier\n+  --> $DIR/raw-literal-underscore.rs:2:9\n    |\n-LL | fn underscore_test(r#_: u32) {\n-   |                    ^^^\n+LL |     let r#_;\n+   |         ^^^\n \n error: aborting due to previous error\n "}, {"sha": "ac7d0b4c2b6c98efd97c76ed659c0a7e2ef2f39e", "filename": "src/test/ui/proc-macro/attribute.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -4,53 +4,73 @@\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;\n+use proc_macro::*;\n \n #[proc_macro_derive]\n //~^ ERROR: attribute must be of the form\n-pub fn foo1(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+pub fn foo1(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive = \"foo\"]\n+#[proc_macro_derive = \"\"]\n //~^ ERROR: attribute must be of the form\n-pub fn foo2(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n-\n-#[proc_macro_derive(\n-    a = \"b\"\n-)]\n-//~^^ ERROR: must only be one word\n-pub fn foo3(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n-\n-#[proc_macro_derive(b, c, d)]\n+pub fn foo2(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d3, a, b)]\n+//~^ ERROR: attribute must have either one or two arguments\n+pub fn foo3(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d4, attributes(a), b)]\n //~^ ERROR: attribute must have either one or two arguments\n-pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+pub fn foo4(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(\"a\")]\n+//~^ ERROR: not a meta item\n+pub fn foo5(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive(d(e))]\n+#[proc_macro_derive(d6 = \"\")]\n //~^ ERROR: must only be one word\n-pub fn foo5(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+pub fn foo6(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive(f, attributes(g = \"h\"))]\n+#[proc_macro_derive(m::d7)]\n //~^ ERROR: must only be one word\n-pub fn foo6(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+pub fn foo7(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive(i, attributes(j(k)))]\n+#[proc_macro_derive(d8(a))]\n //~^ ERROR: must only be one word\n-pub fn foo7(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+pub fn foo8(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive(l, attributes(m), n)]\n-//~^ ERROR: attribute must have either one or two arguments\n-pub fn foo8(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n-    input\n-}\n+#[proc_macro_derive(self)]\n+//~^ ERROR: `self` cannot be a name of derive macro\n+pub fn foo9(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(PartialEq)]\n+//~^ ERROR: cannot override a built-in derive macro\n+pub fn foo10(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d11, a)]\n+//~^ ERROR: second argument must be `attributes`\n+//~| ERROR: attribute must be of form: `attributes(foo, bar)`\n+pub fn foo11(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d12, attributes)]\n+//~^ ERROR: attribute must be of form: `attributes(foo, bar)`\n+pub fn foo12(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d13, attributes(\"a\"))]\n+//~^ ERROR: not a meta item\n+pub fn foo13(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d14, attributes(a = \"\"))]\n+//~^ ERROR: must only be one word\n+pub fn foo14(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d15, attributes(m::a))]\n+//~^ ERROR: must only be one word\n+pub fn foo15(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d16, attributes(a(b)))]\n+//~^ ERROR: must only be one word\n+pub fn foo16(input: TokenStream) -> TokenStream { input }\n+\n+#[proc_macro_derive(d17, attributes(self))]\n+//~^ ERROR: `self` cannot be a name of derive helper attribute\n+pub fn foo17(input: TokenStream) -> TokenStream { input }"}, {"sha": "cc17d383569fccb65da126312076c01e70aa13cf", "filename": "src/test/ui/proc-macro/attribute.stderr", "status": "modified", "additions": 84, "deletions": 24, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -1,50 +1,110 @@\n-error: must only be one word\n-  --> $DIR/attribute.rs:21:5\n+error: attribute must have either one or two arguments\n+  --> $DIR/attribute.rs:17:1\n    |\n-LL |     a = \"b\"\n-   |     ^^^^^^^\n+LL | #[proc_macro_derive(d3, a, b)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: attribute must have either one or two arguments\n-  --> $DIR/attribute.rs:28:1\n+  --> $DIR/attribute.rs:21:1\n+   |\n+LL | #[proc_macro_derive(d4, attributes(a), b)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: not a meta item\n+  --> $DIR/attribute.rs:25:21\n+   |\n+LL | #[proc_macro_derive(\"a\")]\n+   |                     ^^^\n+\n+error: must only be one word\n+  --> $DIR/attribute.rs:29:21\n    |\n-LL | #[proc_macro_derive(b, c, d)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[proc_macro_derive(d6 = \"\")]\n+   |                     ^^^^^^^\n \n error: must only be one word\n-  --> $DIR/attribute.rs:34:21\n+  --> $DIR/attribute.rs:33:21\n    |\n-LL | #[proc_macro_derive(d(e))]\n+LL | #[proc_macro_derive(m::d7)]\n+   |                     ^^^^^\n+\n+error: must only be one word\n+  --> $DIR/attribute.rs:37:21\n+   |\n+LL | #[proc_macro_derive(d8(a))]\n+   |                     ^^^^^\n+\n+error: `self` cannot be a name of derive macro\n+  --> $DIR/attribute.rs:41:21\n+   |\n+LL | #[proc_macro_derive(self)]\n    |                     ^^^^\n \n+error: cannot override a built-in derive macro\n+  --> $DIR/attribute.rs:45:21\n+   |\n+LL | #[proc_macro_derive(PartialEq)]\n+   |                     ^^^^^^^^^\n+\n+error: second argument must be `attributes`\n+  --> $DIR/attribute.rs:49:26\n+   |\n+LL | #[proc_macro_derive(d11, a)]\n+   |                          ^\n+\n+error: attribute must be of form: `attributes(foo, bar)`\n+  --> $DIR/attribute.rs:49:26\n+   |\n+LL | #[proc_macro_derive(d11, a)]\n+   |                          ^\n+\n+error: attribute must be of form: `attributes(foo, bar)`\n+  --> $DIR/attribute.rs:54:26\n+   |\n+LL | #[proc_macro_derive(d12, attributes)]\n+   |                          ^^^^^^^^^^\n+\n+error: not a meta item\n+  --> $DIR/attribute.rs:58:37\n+   |\n+LL | #[proc_macro_derive(d13, attributes(\"a\"))]\n+   |                                     ^^^\n+\n error: must only be one word\n-  --> $DIR/attribute.rs:40:35\n+  --> $DIR/attribute.rs:62:37\n    |\n-LL | #[proc_macro_derive(f, attributes(g = \"h\"))]\n-   |                                   ^^^^^^^\n+LL | #[proc_macro_derive(d14, attributes(a = \"\"))]\n+   |                                     ^^^^^^\n \n error: must only be one word\n-  --> $DIR/attribute.rs:46:35\n+  --> $DIR/attribute.rs:66:37\n    |\n-LL | #[proc_macro_derive(i, attributes(j(k)))]\n-   |                                   ^^^^\n+LL | #[proc_macro_derive(d15, attributes(m::a))]\n+   |                                     ^^^^\n \n-error: attribute must have either one or two arguments\n-  --> $DIR/attribute.rs:52:1\n+error: must only be one word\n+  --> $DIR/attribute.rs:70:37\n+   |\n+LL | #[proc_macro_derive(d16, attributes(a(b)))]\n+   |                                     ^^^^\n+\n+error: `self` cannot be a name of derive helper attribute\n+  --> $DIR/attribute.rs:74:37\n    |\n-LL | #[proc_macro_derive(l, attributes(m), n)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[proc_macro_derive(d17, attributes(self))]\n+   |                                     ^^^^\n \n error: attribute must be of the form `#[proc_macro_derive(TraitName, /*opt*/ attributes(name1, name2, ...))]`\n-  --> $DIR/attribute.rs:8:1\n+  --> $DIR/attribute.rs:9:1\n    |\n LL | #[proc_macro_derive]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: attribute must be of the form `#[proc_macro_derive(TraitName, /*opt*/ attributes(name1, name2, ...))]`\n-  --> $DIR/attribute.rs:14:1\n+  --> $DIR/attribute.rs:13:1\n    |\n-LL | #[proc_macro_derive = \"foo\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[proc_macro_derive = \"\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 18 previous errors\n "}, {"sha": "24371f3a2a6dbc3620ff4e9eb10d32e7f8d8ecbd", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cf074a1e655ac07d04d045667278fa1a9970b93/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr?ref=7cf074a1e655ac07d04d045667278fa1a9970b93", "patch": "@@ -4,7 +4,7 @@ error: proc macro panicked\n LL | invalid_raw_ident!();\n    | ^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: message: `\"self\"` is not a valid raw identifier\n+   = help: message: `self` cannot be a raw identifier\n \n error: aborting due to previous error\n "}, {"sha": "afcc0ebc3464c15e2060e78695443242d2bfb881", "filename": "src/test/ui/proc-macro/shadow-builtin.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.rs?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,14 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(PartialEq)]\n-//~^ ERROR: cannot override a built-in #[derive] mode\n-pub fn foo(input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "668579509dc3bcb3795469acfc1a2aeaafb5c700", "filename": "src/test/ui/proc-macro/shadow-builtin.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fshadow-builtin.stderr?ref=2c8bbf50db0ef90a33f986ba8fc2e1fe129197ff", "patch": "@@ -1,8 +0,0 @@\n-error: cannot override a built-in #[derive] mode\n-  --> $DIR/shadow-builtin.rs:10:21\n-   |\n-LL | #[proc_macro_derive(PartialEq)]\n-   |                     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}]}