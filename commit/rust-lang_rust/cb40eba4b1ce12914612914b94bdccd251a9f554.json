{"sha": "cb40eba4b1ce12914612914b94bdccd251a9f554", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDBlYmE0YjFjZTEyOTE0NjEyOTE0Yjk0YmRjY2QyNTFhOWY1NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-03T18:41:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-03T18:41:34Z"}, "message": "auto merge of #11946 : alexcrichton/rust/no-io-error, r=brson\n\nTurns out this was a little more far-reaching than I thought it was.\r\n\r\nThe first commit is the crux of this stack of commits. The `io::io_error` condition is completely removed and the `read` and `write` methods are altered to return `IoResult<T>`. This turned out to be an incredibly far-reaching change!\r\n\r\nOverall, I'm very happy with how this turned out (in addition with the `unused_must_use` lint). I had to almost rewrite the pretty printer in `libsyntax` as well as the the formatting in `librustdoc` (as one would expect). These two modules do *tons* of I/O, and I believe that it's definitely improved.\r\n\r\nThis pull request also introduces the `if_ok!()` macro for returning-early from something that returns a result. I made quite liberal use of this in mostly the pretty printer and html renderer, and I found its usage generally quite pleasant and convenient to have. I didn't really feel like adding any other macro while I was using it, and I figured that pretty printing could be nicer, but it's nowhere near horrid today.\r\n\r\nThis may be a controversial issue closing, but I'm going to say it.\r\n\r\nCloses #6163", "tree": {"sha": "5cb922f942920dc7d6b0f3606e9cd914360b2707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cb922f942920dc7d6b0f3606e9cd914360b2707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb40eba4b1ce12914612914b94bdccd251a9f554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb40eba4b1ce12914612914b94bdccd251a9f554", "html_url": "https://github.com/rust-lang/rust/commit/cb40eba4b1ce12914612914b94bdccd251a9f554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb40eba4b1ce12914612914b94bdccd251a9f554/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be4fc638092bf896c5c6c0672136b83b71e491ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/be4fc638092bf896c5c6c0672136b83b71e491ee", "html_url": "https://github.com/rust-lang/rust/commit/be4fc638092bf896c5c6c0672136b83b71e491ee"}, {"sha": "c765a8e7ad314651b92ff860cda0159c79dbec6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c765a8e7ad314651b92ff860cda0159c79dbec6e", "html_url": "https://github.com/rust-lang/rust/commit/c765a8e7ad314651b92ff860cda0159c79dbec6e"}], "stats": {"total": 8605, "additions": 4359, "deletions": 4246}, "files": [{"sha": "8896b44f060080e6df809be8ef14cb19ea35898a", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -234,7 +234,13 @@ pub fn run_tests(config: &config) {\n     // For context, see #8904\n     io::test::raise_fd_limit();\n     let res = test::run_tests_console(&opts, tests);\n-    if !res { fail!(\"Some tests failed\"); }\n+    match res {\n+        Ok(true) => {}\n+        Ok(false) => fail!(\"Some tests failed\"),\n+        Err(e) => {\n+            println!(\"I/O failure during tests: {}\", e);\n+        }\n+    }\n }\n \n pub fn test_opts(config: &config) -> test::TestOpts {\n@@ -255,7 +261,7 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from {}\",\n            config.src_base.display());\n     let mut tests = ~[];\n-    let dirs = fs::readdir(&config.src_base);\n+    let dirs = fs::readdir(&config.src_base).unwrap();\n     for file in dirs.iter() {\n         let file = file.clone();\n         debug!(\"inspecting file {}\", file.display());"}, {"sha": "019803a9337796d87b7a12ccf9f64f63dfce4a37", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -58,9 +58,9 @@ pub fn run(lib_path: &str,\n     });\n \n     match opt_process {\n-        Some(ref mut process) => {\n+        Ok(ref mut process) => {\n             for input in input.iter() {\n-                process.input().write(input.as_bytes());\n+                process.input().write(input.as_bytes()).unwrap();\n             }\n             let run::ProcessOutput { status, output, error } = process.finish_with_output();\n \n@@ -70,7 +70,7 @@ pub fn run(lib_path: &str,\n                 err: str::from_utf8_owned(error).unwrap()\n             })\n         },\n-        None => None\n+        Err(..) => None\n     }\n }\n \n@@ -90,13 +90,13 @@ pub fn run_background(lib_path: &str,\n     });\n \n     match opt_process {\n-        Some(mut process) => {\n+        Ok(mut process) => {\n             for input in input.iter() {\n-                process.input().write(input.as_bytes());\n+                process.input().write(input.as_bytes()).unwrap();\n             }\n \n             Some(process)\n         },\n-        None => None\n+        Err(..) => None\n     }\n }"}, {"sha": "0503790ae943c964002a3d906e96ff1d14929654", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -153,7 +153,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let src = File::open(testfile).read_to_end();\n+    let src = File::open(testfile).read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n     let mut srcs = ~[src];\n \n@@ -175,7 +175,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            let s = File::open(&filepath).read_to_end();\n+            let s = File::open(&filepath).read_to_end().unwrap();\n             str::from_utf8_owned(s).unwrap()\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n@@ -318,8 +318,10 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n                 let result = task::try(proc() {\n-                    tcp::TcpStream::connect(\n-                        SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 5039 });\n+                    tcp::TcpStream::connect(SocketAddr {\n+                        ip: Ipv4Addr(127, 0, 0, 1),\n+                        port: 5039,\n+                    }).unwrap();\n                 });\n                 if result.is_err() {\n                     continue;\n@@ -361,7 +363,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                                stdout: out,\n                                stderr: err,\n                                cmdline: cmdline};\n-            process.force_destroy();\n+            process.force_destroy().unwrap();\n         }\n \n         _=> {\n@@ -727,7 +729,7 @@ fn compose_and_run_compiler(\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    fs::mkdir(path, io::UserRWX);\n+    fs::mkdir(path, io::UserRWX).unwrap();\n }\n \n fn compose_and_run(config: &config, testfile: &Path,\n@@ -852,7 +854,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    File::create(&outfile).write(out.as_bytes());\n+    File::create(&outfile).write(out.as_bytes()).unwrap();\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -1003,7 +1005,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tdir = aux_output_dir_name(config, testfile);\n \n-    let dirs = fs::readdir(&tdir);\n+    let dirs = fs::readdir(&tdir).unwrap();\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1099,7 +1101,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = File::open(&p.with_extension(\"ll\")).read_to_end();\n+    let x = File::open(&p.with_extension(\"ll\")).read_to_end().unwrap();\n     let x = str::from_utf8_owned(x).unwrap();\n     x.lines().len()\n }"}, {"sha": "5b7494c06187913732e6d3339445ea1e81d66824", "filename": "src/doc/guide-conditions.md", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fdoc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fdoc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-conditions.md?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -47,15 +47,15 @@ An example program that does this task reads like this:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -71,7 +71,6 @@ fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n \n     // Path takes a generic by-value, rather than by reference\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n     let mut reader = BufferedReader::new(File::open(&path));\n \n@@ -245,15 +244,15 @@ and trapping its exit status using `task::try`:\n use std::io::{BufferedReader, File};\n use std::task;\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -277,7 +276,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -347,15 +345,15 @@ but similarly clear as the version that used `fail!` in the logic where the erro\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -374,7 +372,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -415,15 +412,15 @@ and replaces bad input lines with the pair `(-1,-1)`:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -447,7 +444,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -489,15 +485,15 @@ Changing the condition's return type from `(int,int)` to `Option<(int,int)>` wil\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{IoResult, File};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -522,7 +518,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -573,15 +568,15 @@ This can be encoded in the handler API by introducing a helper type: `enum Malfo\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -615,7 +610,6 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));\n@@ -696,15 +690,15 @@ a second condition and a helper function will suffice:\n # #[allow(unused_imports)];\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n-#     use std::io::File;\n+#     use std::io::{File, IoResult};\n #     use std::io::MemReader;\n #     use std::io::BufferedReader;\n #     static s : &'static [u8] = bytes!(\"1 2\\n\\\n #                                        34 56\\n\\\n #                                        789 123\\n\\\n #                                        45 67\\n\\\n #                                        \");\n-#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#     pub fn new(_inner: IoResult<File>) -> BufferedReader<MemReader> {\n #           BufferedReader::new(MemReader::new(s.to_owned()))\n #     }\n # }\n@@ -752,7 +746,6 @@ fn parse_int(x: &str) -> int {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-#    let _g = std::io::ignore_io_error();\n     let path = Path::new(&\"foo.txt\");\n \n     let mut reader = BufferedReader::new(File::open(&path));"}, {"sha": "457c0b683ac688212754ac1a7f8ce9e2a9ca2635", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -69,6 +69,7 @@ def scrub(b):\n use run_pass_stage2::*;\n use std::io;\n use std::io::Writer;\n+#[allow(warnings)]\n fn main() {\n     let mut out = io::stdout();\n \"\"\""}, {"sha": "9615bdc2ad731e5c7fbd804d8070fa6e2763b8fd", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -637,7 +637,7 @@ mod tests {\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.access(|one| {\n                 assert_eq!(*one, 2);\n             })\n@@ -668,7 +668,7 @@ mod tests {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = MutexArc::new(1i);\n         let arc2 = arc.clone();\n-        task::try::<()>(proc() {\n+        let _ = task::try::<()>(proc() {\n             struct Unwinder {\n                 i: MutexArc<int>\n             }\n@@ -687,7 +687,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n@@ -701,7 +701,7 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n@@ -714,7 +714,7 @@ mod tests {\n     fn test_rw_arc_poison_dw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.write_downgrade(|mut write_mode| {\n                 write_mode.write(|one| {\n                     assert_eq!(*one, 2);\n@@ -729,7 +729,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n@@ -742,7 +742,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n@@ -755,7 +755,7 @@ mod tests {\n     fn test_rw_arc_no_poison_dr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             arc2.write_downgrade(|write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 read_mode.read(|one| {\n@@ -800,7 +800,7 @@ mod tests {\n \n         // Wait for children to pass their asserts\n         for r in children.mut_iter() {\n-            r.recv();\n+            let _ = r.recv();\n         }\n \n         // Wait for writer to finish\n@@ -814,7 +814,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = RWArc::new(1i);\n         let arc2 = arc.clone();\n-        task::try::<()>(proc() {\n+        let _ = task::try::<()>(proc() {\n             struct Unwinder {\n                 i: RWArc<int>\n             }"}, {"sha": "556032af1ac8465f027879414875dc22eb92ba9a", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -359,7 +359,7 @@ mod test {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_base64(STANDARD);\n         bh.iter(|| {\n-            b.from_base64();\n+            b.from_base64().unwrap();\n         });\n         bh.bytes = b.len() as u64;\n     }"}, {"sha": "1900313ab6c8e7d11bc3b98728680a5e66241417", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -12,6 +12,10 @@\n \n use std::str;\n \n+macro_rules! if_ok( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n+) )\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -595,9 +599,15 @@ pub mod writer {\n \n     // ebml writing\n     pub struct Encoder<'a> {\n-        // FIXME(#5665): this should take a trait object\n+        // FIXME(#5665): this should take a trait object. Note that if you\n+        //               delete this comment you should consider removing the\n+        //               unwrap()'s below of the results of the calls to\n+        //               write(). We're guaranteed that writing into a MemWriter\n+        //               won't fail, but this is not true for all I/O streams in\n+        //               general.\n         writer: &'a mut MemWriter,\n         priv size_positions: ~[uint],\n+        last_error: io::IoResult<()>,\n     }\n \n     fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n@@ -609,7 +619,7 @@ pub mod writer {\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n             _ => fail!(\"vint to write too big: {}\", n)\n-        };\n+        }.unwrap()\n     }\n \n     fn write_vuint(w: &mut MemWriter, n: uint) {\n@@ -624,7 +634,8 @@ pub mod writer {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n-            size_positions: size_positions\n+            size_positions: size_positions,\n+            last_error: Ok(()),\n         }\n     }\n \n@@ -635,6 +646,7 @@ pub mod writer {\n             Encoder {\n                 writer: cast::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n+                last_error: Ok(()),\n             }\n         }\n \n@@ -645,18 +657,18 @@ pub mod writer {\n             write_vuint(self.writer, tag_id);\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(self.writer.tell() as uint);\n+            self.size_positions.push(if_ok!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            self.writer.write(zeroes);\n+            if_ok!(self.writer.write(zeroes));\n         }\n \n         pub fn end_tag(&mut self) {\n             let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.tell();\n-            self.writer.seek(last_size_pos as i64, io::SeekSet);\n+            let cur_pos = if_ok!(self.writer.tell());\n+            if_ok!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n             let size = (cur_pos as uint - last_size_pos - 4);\n             write_sized_vuint(self.writer, size, 4u);\n-            self.writer.seek(cur_pos as i64, io::SeekSet);\n+            if_ok!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n             debug!(\"End tag (size = {})\", size);\n         }\n@@ -670,7 +682,7 @@ pub mod writer {\n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n             write_vuint(self.writer, b.len());\n-            self.writer.write(b);\n+            self.writer.write(b).unwrap();\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n@@ -723,12 +735,12 @@ pub mod writer {\n \n         pub fn wr_bytes(&mut self, b: &[u8]) {\n             debug!(\"Write {} bytes\", b.len());\n-            self.writer.write(b);\n+            self.writer.write(b).unwrap();\n         }\n \n         pub fn wr_str(&mut self, s: &str) {\n             debug!(\"Write str: {}\", s);\n-            self.writer.write(s.as_bytes());\n+            self.writer.write(s.as_bytes()).unwrap();\n         }\n     }\n "}, {"sha": "d4e1ae123378e9c97a4a70d5453a6443da8d4b6d", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -201,7 +201,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_hex();\n         bh.iter(|| {\n-            b.from_hex();\n+            b.from_hex().unwrap();\n         });\n         bh.bytes = b.len() as u64;\n     }"}, {"sha": "ef8e0999521b85567e0d9e148436973893752510", "filename": "src/libextra/json.rs", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -234,6 +234,10 @@ use serialize::Encodable;\n use serialize;\n use treemap::TreeMap;\n \n+macro_rules! if_ok( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n+) )\n+\n /// Represents a json value\n #[deriving(Clone, Eq)]\n pub enum Json {\n@@ -260,6 +264,14 @@ pub struct Error {\n     priv msg: ~str,\n }\n \n+fn io_error_to_error(io: io::IoError) -> Error {\n+    Error {\n+        line: 0,\n+        col: 0,\n+        msg: format!(\"io error: {}\", io)\n+    }\n+}\n+\n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     for c in s.chars() {\n@@ -289,13 +301,14 @@ fn spaces(n: uint) -> ~str {\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     priv wr: &'a mut io::Writer,\n+    priv error: io::IoResult<()>,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr }\n+        Encoder { wr: wr, error: Ok(()) }\n     }\n \n     /// Encode the specified struct into a json [u8]\n@@ -317,7 +330,7 @@ impl<'a> Encoder<'a> {\n }\n \n impl<'a> serialize::Encoder for Encoder<'a> {\n-    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")) }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -333,20 +346,20 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            write!(self.wr, \"true\");\n+            if_ok!(write!(self.wr, \"true\"));\n         } else {\n-            write!(self.wr, \"false\");\n+            if_ok!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) {\n-        write!(self.wr, \"{}\", escape_str(v))\n+        if_ok!(write!(self.wr, \"{}\", escape_str(v)))\n     }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n@@ -360,19 +373,19 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n-            write!(self.wr, \"\\\\{\\\"variant\\\":\");\n-            write!(self.wr, \"{}\", escape_str(name));\n-            write!(self.wr, \",\\\"fields\\\":[\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n+            if_ok!(write!(self.wr, \",\\\"fields\\\":[\"));\n             f(self);\n-            write!(self.wr, \"]\\\\}\");\n+            if_ok!(write!(self.wr, \"]\\\\}\"));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\");\n+            if_ok!(write!(self.wr, \",\"));\n         }\n         f(self);\n     }\n@@ -393,17 +406,17 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, r\"\\{\");\n+        if_ok!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        write!(self.wr, r\"\\}\");\n+        if_ok!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: |&mut Encoder<'a>|) {\n-        if idx != 0 { write!(self.wr, \",\") }\n-        write!(self.wr, \"{}:\", escape_str(name));\n+        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n+        if_ok!(write!(self.wr, \"{}:\", escape_str(name)));\n         f(self);\n     }\n \n@@ -429,31 +442,31 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n \n     fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, \"[\");\n+        if_ok!(write!(self.wr, \"[\"));\n         f(self);\n-        write!(self.wr, \"]\");\n+        if_ok!(write!(self.wr, \"]\"));\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\");\n+            if_ok!(write!(self.wr, \",\"));\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, r\"\\{\");\n+        if_ok!(write!(self.wr, r\"\\{\"));\n         f(self);\n-        write!(self.wr, r\"\\}\");\n+        if_ok!(write!(self.wr, r\"\\}\"));\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        if idx != 0 { write!(self.wr, \",\") }\n+        if idx != 0 { if_ok!(write!(self.wr, \",\")) }\n         f(self)\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-        write!(self.wr, \":\");\n+        if_ok!(write!(self.wr, \":\"));\n         f(self)\n     }\n }\n@@ -463,6 +476,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n pub struct PrettyEncoder<'a> {\n     priv wr: &'a mut io::Writer,\n     priv indent: uint,\n+    priv error: io::IoResult<()>,\n }\n \n impl<'a> PrettyEncoder<'a> {\n@@ -471,12 +485,13 @@ impl<'a> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n+            error: Ok(())\n         }\n     }\n }\n \n impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n+    fn emit_nil(&mut self) { if_ok!(write!(self.wr, \"null\")); }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -492,19 +507,21 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            write!(self.wr, \"true\");\n+            if_ok!(write!(self.wr, \"true\"));\n         } else {\n-            write!(self.wr, \"false\");\n+            if_ok!(write!(self.wr, \"false\"));\n         }\n     }\n \n     fn emit_f64(&mut self, v: f64) {\n-        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+        if_ok!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n     }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n+    fn emit_str(&mut self, v: &str) {\n+        if_ok!(write!(self.wr, \"{}\", escape_str(v)));\n+    }\n \n     fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n         f(self)\n@@ -516,23 +533,24 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          cnt: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if cnt == 0 {\n-            write!(self.wr, \"{}\", escape_str(name));\n+            if_ok!(write!(self.wr, \"{}\", escape_str(name)));\n         } else {\n             self.indent += 2;\n-            write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent), escape_str(name));\n+            if_ok!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+                          escape_str(name)));\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: |&mut PrettyEncoder<'a>|) {\n         if idx != 0 {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n@@ -557,13 +575,13 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                    len: uint,\n                    f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"\\\\{\\\\}\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            write!(self.wr, \"\\\\{\");\n+            if_ok!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n@@ -572,11 +590,11 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n                          idx: uint,\n                          f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name));\n+        if_ok!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n         f(self);\n     }\n \n@@ -605,50 +623,50 @@ impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n \n     fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"[]\");\n+            if_ok!(write!(self.wr, \"[]\"));\n         } else {\n-            write!(self.wr, \"[\");\n+            if_ok!(write!(self.wr, \"[\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self)\n     }\n \n     fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n-            write!(self.wr, \"\\\\{\\\\}\");\n+            if_ok!(write!(self.wr, \"\\\\{\\\\}\"));\n         } else {\n-            write!(self.wr, \"\\\\{\");\n+            if_ok!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n             f(self);\n             self.indent -= 2;\n-            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n+            if_ok!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n         }\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n-            write!(self.wr, \"\\n\");\n+            if_ok!(write!(self.wr, \"\\n\"));\n         } else {\n-            write!(self.wr, \",\\n\");\n+            if_ok!(write!(self.wr, \",\\n\"));\n         }\n-        write!(self.wr, \"{}\", spaces(self.indent));\n+        if_ok!(write!(self.wr, \"{}\", spaces(self.indent)));\n         f(self);\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        write!(self.wr, \": \");\n+        if_ok!(write!(self.wr, \": \"));\n         f(self);\n     }\n }\n@@ -668,22 +686,24 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) {\n+    pub fn to_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n         let mut encoder = Encoder::new(wr);\n-        self.encode(&mut encoder)\n+        self.encode(&mut encoder);\n+        encoder.error\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) {\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n         let mut encoder = PrettyEncoder::new(wr);\n-        self.encode(&mut encoder)\n+        self.encode(&mut encoder);\n+        encoder.error\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n-        self.to_pretty_writer(&mut s as &mut io::Writer);\n+        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }\n@@ -1067,7 +1087,14 @@ impl<T : Iterator<char>> Parser<T> {\n \n /// Decodes a json value from an `&mut io::Reader`\n pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8_owned(rdr.read_to_end()).unwrap();\n+    let contents = match rdr.read_to_end() {\n+        Ok(c) => c,\n+        Err(e) => return Err(io_error_to_error(e))\n+    };\n+    let s = match str::from_utf8_owned(contents) {\n+        Some(s) => s,\n+        None => return Err(Error { line: 0, col: 0, msg: ~\"contents not utf-8\" })\n+    };\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n@@ -1540,7 +1567,7 @@ impl to_str::ToStr for Json {\n     /// Encodes a json value into a string\n     fn to_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n-        self.to_writer(&mut s as &mut io::Writer);\n+        self.to_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n }"}, {"sha": "358dca5e5ac4767c21413faf1a9c283f501c7ae8", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -34,6 +34,11 @@ Rust extras are part of the standard Rust distribution.\n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n // Utility modules\n \n pub mod c_vec;"}, {"sha": "8752020f564e0389b3f04da60b634fa395a8c898", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -322,14 +322,15 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n+pub fn write_5_number_summary(w: &mut io::Writer,\n+                              s: &Summary) -> io::IoResult<()> {\n     let (q1,q2,q3) = s.quartiles;\n     write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n                      s.min,\n                      q1,\n                      q2,\n                      q3,\n-                     s.max);\n+                     s.max)\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n@@ -344,7 +345,8 @@ pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n ///   10 |        [--****#******----------]          | 40\n /// ~~~~\n \n-pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n+pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n+                     width_hint: uint) -> io::IoResult<()> {\n \n     let (q1,q2,q3) = s.quartiles;\n \n@@ -374,48 +376,49 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n     let range_width = width_hint - overhead_width;;\n     let char_step = range / (range_width as f64);\n \n-    write!(w, \"{} |\", lostr);\n+    if_ok!(write!(w, \"{} |\", lostr));\n \n     let mut c = 0;\n     let mut v = lo;\n \n     while c < range_width && v < s.min {\n-        write!(w, \" \");\n+        if_ok!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, \"[\");\n+    if_ok!(write!(w, \"[\"));\n     c += 1;\n     while c < range_width && v < q1 {\n-        write!(w, \"-\");\n+        if_ok!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n-        write!(w, \"*\");\n+        if_ok!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, r\"\\#\");\n+    if_ok!(write!(w, r\"\\#\"));\n     c += 1;\n     while c < range_width && v < q3 {\n-        write!(w, \"*\");\n+        if_ok!(write!(w, \"*\"));\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n-        write!(w, \"-\");\n+        if_ok!(write!(w, \"-\"));\n         v += char_step;\n         c += 1;\n     }\n-    write!(w, \"]\");\n+    if_ok!(write!(w, \"]\"));\n     while c < range_width {\n-        write!(w, \" \");\n+        if_ok!(write!(w, \" \"));\n         v += char_step;\n         c += 1;\n     }\n \n-    write!(w, \"| {}\", histr);\n+    if_ok!(write!(w, \"| {}\", histr));\n+    Ok(())\n }\n \n /// Returns a HashMap with the number of occurrences of every element in the\n@@ -453,11 +456,11 @@ mod tests {\n \n         let mut w = io::stdout();\n         let w = &mut w as &mut io::Writer;\n-        write!(w, \"\\n\");\n-        write_5_number_summary(w, &summ2);\n-        write!(w, \"\\n\");\n-        write_boxplot(w, &summ2, 50);\n-        write!(w, \"\\n\");\n+        (write!(w, \"\\n\")).unwrap();\n+        write_5_number_summary(w, &summ2).unwrap();\n+        (write!(w, \"\\n\")).unwrap();\n+        write_boxplot(w, &summ2, 50).unwrap();\n+        (write!(w, \"\\n\")).unwrap();\n \n         assert_eq!(summ.sum, summ2.sum);\n         assert_eq!(summ.min, summ2.min);\n@@ -1000,7 +1003,7 @@ mod tests {\n         fn t(s: &Summary, expected: ~str) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n-            write_boxplot(&mut m as &mut io::Writer, s, 30);\n+            write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n             let out = str::from_utf8_owned(m.unwrap()).unwrap();\n             assert_eq!(out, expected);\n         }"}, {"sha": "0a29fd189822985de3759572e57d1f35ec77c0fa", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -959,7 +959,7 @@ mod tests {\n     fn test_mutex_cond_no_waiter() {\n         let m = Mutex::new();\n         let m2 = m.clone();\n-        task::try(proc() {\n+        let _ = task::try(proc() {\n             m.lock_cond(|_x| { })\n         });\n         m2.lock_cond(|cond| {"}, {"sha": "5948f356a651d6c0384c691dded84ae711261daf", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -38,7 +38,7 @@ impl TempDir {\n         let mut r = rand::rng();\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n-            match io::result(|| fs::mkdir(&p, io::UserRWX)) {\n+            match fs::mkdir(&p, io::UserRWX) {\n                 Err(..) => {}\n                 Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n@@ -73,7 +73,8 @@ impl Drop for TempDir {\n     fn drop(&mut self) {\n         for path in self.path.iter() {\n             if path.exists() {\n-                fs::rmdir_recursive(path);\n+                // FIXME: is failing the right thing to do?\n+                fs::rmdir_recursive(path).unwrap();\n             }\n         }\n     }"}, {"sha": "c4d27b25b5503587b4d16e5339d1d725e2501061", "filename": "src/libextra/test.rs", "status": "modified", "additions": 117, "deletions": 94, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -163,7 +163,11 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n             Some(Err(msg)) => fail!(\"{}\", msg),\n             None => return\n         };\n-    if !run_tests_console(&opts, tests) { fail!(\"Some tests failed\"); }\n+    match run_tests_console(&opts, tests) {\n+        Ok(true) => {}\n+        Ok(false) => fail!(\"Some tests failed\"),\n+        Err(e) => fail!(\"io error when running tests: {}\", e),\n+    }\n }\n \n // A variant optimized for invocation with a static test vector.\n@@ -359,16 +363,17 @@ struct ConsoleTestState<T> {\n }\n \n impl<T: Writer> ConsoleTestState<T> {\n-    pub fn new(opts: &TestOpts, _: Option<T>) -> ConsoleTestState<StdWriter> {\n+    pub fn new(opts: &TestOpts,\n+               _: Option<T>) -> io::IoResult<ConsoleTestState<StdWriter>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => File::create(path),\n+            Some(ref path) => Some(if_ok!(File::create(path))),\n             None => None\n         };\n         let out = match term::Terminal::new(io::stdout()) {\n             Err(_) => Raw(io::stdout()),\n             Ok(t) => Pretty(t)\n         };\n-        ConsoleTestState {\n+        Ok(ConsoleTestState {\n             out: out,\n             log_out: log_out,\n             use_color: use_color(),\n@@ -380,100 +385,103 @@ impl<T: Writer> ConsoleTestState<T> {\n             metrics: MetricMap::new(),\n             failures: ~[],\n             max_name_len: 0u,\n-        }\n+        })\n     }\n \n-    pub fn write_ok(&mut self) {\n-        self.write_pretty(\"ok\", term::color::GREEN);\n+    pub fn write_ok(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"ok\", term::color::GREEN)\n     }\n \n-    pub fn write_failed(&mut self) {\n-        self.write_pretty(\"FAILED\", term::color::RED);\n+    pub fn write_failed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"FAILED\", term::color::RED)\n     }\n \n-    pub fn write_ignored(&mut self) {\n-        self.write_pretty(\"ignored\", term::color::YELLOW);\n+    pub fn write_ignored(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"ignored\", term::color::YELLOW)\n     }\n \n-    pub fn write_metric(&mut self) {\n-        self.write_pretty(\"metric\", term::color::CYAN);\n+    pub fn write_metric(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"metric\", term::color::CYAN)\n     }\n \n-    pub fn write_bench(&mut self) {\n-        self.write_pretty(\"bench\", term::color::CYAN);\n+    pub fn write_bench(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n-    pub fn write_added(&mut self) {\n-        self.write_pretty(\"added\", term::color::GREEN);\n+    pub fn write_added(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"added\", term::color::GREEN)\n     }\n \n-    pub fn write_improved(&mut self) {\n-        self.write_pretty(\"improved\", term::color::GREEN);\n+    pub fn write_improved(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"improved\", term::color::GREEN)\n     }\n \n-    pub fn write_removed(&mut self) {\n-        self.write_pretty(\"removed\", term::color::YELLOW);\n+    pub fn write_removed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"removed\", term::color::YELLOW)\n     }\n \n-    pub fn write_regressed(&mut self) {\n-        self.write_pretty(\"regressed\", term::color::RED);\n+    pub fn write_regressed(&mut self) -> io::IoResult<()> {\n+        self.write_pretty(\"regressed\", term::color::RED)\n     }\n \n     pub fn write_pretty(&mut self,\n                         word: &str,\n-                        color: term::color::Color) {\n+                        color: term::color::Color) -> io::IoResult<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n-                    term.fg(color);\n+                    if_ok!(term.fg(color));\n                 }\n-                term.write(word.as_bytes());\n+                if_ok!(term.write(word.as_bytes()));\n                 if self.use_color {\n-                    term.reset();\n+                    if_ok!(term.reset());\n                 }\n+                Ok(())\n             }\n             Raw(ref mut stdout) => stdout.write(word.as_bytes())\n         }\n     }\n \n-    pub fn write_plain(&mut self, s: &str) {\n+    pub fn write_plain(&mut self, s: &str) -> io::IoResult<()> {\n         match self.out {\n             Pretty(ref mut term) => term.write(s.as_bytes()),\n             Raw(ref mut stdout) => stdout.write(s.as_bytes())\n         }\n     }\n \n-    pub fn write_run_start(&mut self, len: uint) {\n+    pub fn write_run_start(&mut self, len: uint) -> io::IoResult<()> {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun));\n+        self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n-    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) {\n+    pub fn write_test_start(&mut self, test: &TestDesc,\n+                            align: NamePadding) -> io::IoResult<()> {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.write_plain(format!(\"test {} ... \", name));\n+        self.write_plain(format!(\"test {} ... \", name))\n     }\n \n-    pub fn write_result(&mut self, result: &TestResult) {\n-        match *result {\n+    pub fn write_result(&mut self, result: &TestResult) -> io::IoResult<()> {\n+        if_ok!(match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n-                self.write_metric();\n-                self.write_plain(format!(\": {}\", fmt_metrics(mm)));\n+                if_ok!(self.write_metric());\n+                self.write_plain(format!(\": {}\", fmt_metrics(mm)))\n             }\n             TrBench(ref bs) => {\n-                self.write_bench();\n-                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)));\n+                if_ok!(self.write_bench());\n+                self.write_plain(format!(\": {}\", fmt_bench_samples(bs)))\n             }\n-        }\n-        self.write_plain(\"\\n\");\n+        });\n+        self.write_plain(\"\\n\")\n     }\n \n-    pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) {\n+    pub fn write_log(&mut self, test: &TestDesc,\n+                     result: &TestResult) -> io::IoResult<()> {\n         match self.log_out {\n-            None => (),\n+            None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n                         TrOk => ~\"ok\",\n@@ -482,24 +490,25 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.to_str());\n-                o.write(s.as_bytes());\n+                o.write(s.as_bytes())\n             }\n         }\n     }\n \n-    pub fn write_failures(&mut self) {\n-        self.write_plain(\"\\nfailures:\\n\");\n+    pub fn write_failures(&mut self) -> io::IoResult<()> {\n+        if_ok!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = ~[];\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         failures.sort();\n         for name in failures.iter() {\n-            self.write_plain(format!(\"    {}\\n\", name.to_str()));\n+            if_ok!(self.write_plain(format!(\"    {}\\n\", name.to_str())));\n         }\n+        Ok(())\n     }\n \n-    pub fn write_metric_diff(&mut self, diff: &MetricDiff) {\n+    pub fn write_metric_diff(&mut self, diff: &MetricDiff) -> io::IoResult<()> {\n         let mut noise = 0;\n         let mut improved = 0;\n         let mut regressed = 0;\n@@ -511,77 +520,82 @@ impl<T: Writer> ConsoleTestState<T> {\n                 LikelyNoise => noise += 1,\n                 MetricAdded => {\n                     added += 1;\n-                    self.write_added();\n-                    self.write_plain(format!(\": {}\\n\", *k));\n+                    if_ok!(self.write_added());\n+                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n-                    self.write_removed();\n-                    self.write_plain(format!(\": {}\\n\", *k));\n+                    if_ok!(self.write_removed());\n+                    if_ok!(self.write_plain(format!(\": {}\\n\", *k)));\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    self.write_plain(format!(\": {}\", *k));\n-                    self.write_improved();\n-                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n+                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n+                    if_ok!(self.write_improved());\n+                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    self.write_plain(format!(\": {}\", *k));\n-                    self.write_regressed();\n-                    self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64));\n+                    if_ok!(self.write_plain(format!(\": {}\", *k)));\n+                    if_ok!(self.write_regressed());\n+                    if_ok!(self.write_plain(format!(\" by {:.2f}%\\n\", pct as f64)));\n                 }\n             }\n         }\n-        self.write_plain(format!(\"result of ratchet: {} matrics added, {} removed, \\\n-                                  {} improved, {} regressed, {} noise\\n\",\n-                                 added, removed, improved, regressed, noise));\n+        if_ok!(self.write_plain(format!(\"result of ratchet: {} matrics added, \\\n+                                        {} removed, {} improved, {} regressed, \\\n+                                        {} noise\\n\",\n+                                       added, removed, improved, regressed,\n+                                       noise)));\n         if regressed == 0 {\n-            self.write_plain(\"updated ratchet file\\n\");\n+            if_ok!(self.write_plain(\"updated ratchet file\\n\"));\n         } else {\n-            self.write_plain(\"left ratchet file untouched\\n\");\n+            if_ok!(self.write_plain(\"left ratchet file untouched\\n\"));\n         }\n+        Ok(())\n     }\n \n     pub fn write_run_finish(&mut self,\n                             ratchet_metrics: &Option<Path>,\n-                            ratchet_pct: Option<f64>) -> bool {\n+                            ratchet_pct: Option<f64>) -> io::IoResult<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\", pth.display()));\n+                if_ok!(self.write_plain(format!(\"\\nusing metrics ratcher: {}\\n\",\n+                                        pth.display())));\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                        self.write_plain(format!(\"with noise-tolerance forced to: {}%\\n\",\n-                                                 pct))\n+                        if_ok!(self.write_plain(format!(\"with noise-tolerance \\\n+                                                         forced to: {}%\\n\",\n+                                                        pct)))\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n-                self.write_metric_diff(&diff);\n+                if_ok!(self.write_metric_diff(&diff));\n                 ok\n             }\n         };\n \n         let test_success = self.failed == 0u;\n         if !test_success {\n-            self.write_failures();\n+            if_ok!(self.write_failures());\n         }\n \n         let success = ratchet_success && test_success;\n \n-        self.write_plain(\"\\ntest result: \");\n+        if_ok!(self.write_plain(\"\\ntest result: \"));\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n-            self.write_ok();\n+            if_ok!(self.write_ok());\n         } else {\n-            self.write_failed();\n+            if_ok!(self.write_failed());\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed, self.failed, self.ignored, self.measured);\n-        self.write_plain(s);\n-        return success;\n+        if_ok!(self.write_plain(s));\n+        return Ok(success);\n     }\n }\n \n@@ -611,15 +625,16 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n-                         tests: ~[TestDescAndFn]) -> bool {\n-    fn callback<T: Writer>(event: &TestEvent, st: &mut ConsoleTestState<T>) {\n+                         tests: ~[TestDescAndFn]) -> io::IoResult<bool> {\n+    fn callback<T: Writer>(event: &TestEvent,\n+                           st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n         debug!(\"callback(event={:?})\", event);\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result) => {\n-                st.write_log(&test, &result);\n-                st.write_result(&result);\n+                if_ok!(st.write_log(&test, &result));\n+                if_ok!(st.write_result(&result));\n                 match result {\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n@@ -643,10 +658,11 @@ pub fn run_tests_console(opts: &TestOpts,\n                         st.failures.push(test);\n                     }\n                 }\n+                Ok(())\n             }\n         }\n     }\n-    let mut st = ConsoleTestState::new(opts, None::<StdWriter>);\n+    let mut st = if_ok!(ConsoleTestState::new(opts, None::<StdWriter>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0u,\n@@ -661,12 +677,13 @@ pub fn run_tests_console(opts: &TestOpts,\n         },\n         None => {}\n     }\n-    run_tests(opts, tests, |x| callback(&x, &mut st));\n+    if_ok!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n     match opts.save_metrics {\n         None => (),\n         Some(ref pth) => {\n-            st.metrics.save(pth);\n-            st.write_plain(format!(\"\\nmetrics saved to: {}\", pth.display()));\n+            if_ok!(st.metrics.save(pth));\n+            if_ok!(st.write_plain(format!(\"\\nmetrics saved to: {}\",\n+                                          pth.display())));\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n@@ -703,7 +720,7 @@ fn should_sort_failures_before_printing_them() {\n         failures: ~[test_b, test_a]\n     };\n \n-    st.write_failures();\n+    st.write_failures().unwrap();\n     let s = match st.out {\n         Raw(ref m) => str::from_utf8(m.get_ref()).unwrap(),\n         Pretty(_) => unreachable!()\n@@ -728,11 +745,11 @@ pub type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: |e: TestEvent|) {\n+             callback: |e: TestEvent| -> io::IoResult<()>) -> io::IoResult<()> {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n-    callback(TeFiltered(filtered_descs));\n+    if_ok!(callback(TeFiltered(filtered_descs)));\n \n     let (filtered_tests, filtered_benchs_and_metrics) =\n         filtered_tests.partition(|e| {\n@@ -760,28 +777,29 @@ fn run_tests(opts: &TestOpts,\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(test.desc.clone(), test.testfn.padding()));\n+                if_ok!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n             }\n             run_test(!opts.run_tests, test, ch.clone());\n             pending += 1;\n         }\n \n         let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(desc.clone(), PadNone));\n+            if_ok!(callback(TeWait(desc.clone(), PadNone)));\n         }\n-        callback(TeResult(desc, result));\n+        if_ok!(callback(TeResult(desc, result)));\n         pending -= 1;\n     }\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n-        callback(TeWait(b.desc.clone(), b.testfn.padding()));\n+        if_ok!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n-        callback(TeResult(test, result));\n+        if_ok!(callback(TeResult(test, result)));\n     }\n+    Ok(())\n }\n \n fn get_concurrency() -> uint {\n@@ -943,17 +961,22 @@ impl MetricMap {\n     }\n \n     /// Load MetricDiff from a file.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will fail if the path does not exist or the path does not\n+    /// contain a valid metric map.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(p.exists());\n-        let mut f = File::open(p);\n+        let mut f = File::open(p).unwrap();\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n         let mut decoder = json::Decoder::new(value);\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n-    pub fn save(&self, p: &Path) {\n-        let mut file = File::create(p);\n+    pub fn save(&self, p: &Path) -> io::IoResult<()> {\n+        let mut file = if_ok!(File::create(p));\n         let MetricMap(ref map) = *self;\n         map.to_json().to_pretty_writer(&mut file)\n     }\n@@ -1060,7 +1083,7 @@ impl MetricMap {\n \n         if ok {\n             debug!(\"rewriting file '{:?}' with updated metrics\", p);\n-            self.save(p);\n+            self.save(p).unwrap();\n         }\n         return (diff, ok)\n     }\n@@ -1462,7 +1485,7 @@ mod tests {\n         m2.insert_metric(\"runtime\", 1100.0, 2.0);\n         m2.insert_metric(\"throughput\", 50.0, 2.0);\n \n-        m1.save(&pth);\n+        m1.save(&pth).unwrap();\n \n         // Ask for a ratchet that should fail to advance.\n         let (diff1, ok1) = m2.ratchet(&pth, None);"}, {"sha": "0a122ad58bd33a3a728d91fc2cd914e9762dcfcc", "filename": "src/libextra/time.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -766,14 +766,14 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut buf = [0];\n         let c = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break\n         };\n         match c {\n             '%' => {\n                 let ch = match rdr.read(buf) {\n-                    Some(..) => buf[0] as char,\n-                    None => break\n+                    Ok(..) => buf[0] as char,\n+                    Err(..) => break\n                 };\n                 match parse_type(s, pos, ch, &mut tm) {\n                     Ok(next) => pos = next,\n@@ -787,7 +787,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    if pos == len && rdr.tell() as uint == format.len() {\n+    if pos == len && rdr.tell().unwrap() == format.len() as u64 {\n         Ok(Tm {\n             tm_sec: tm.tm_sec,\n             tm_min: tm.tm_min,\n@@ -1017,12 +1017,12 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     loop {\n         let mut b = [0];\n         let ch = match rdr.read(b) {\n-            Some(..) => b[0],\n-            None => break,\n+            Ok(..) => b[0],\n+            Err(..) => break,\n         };\n         match ch as char {\n             '%' => {\n-                rdr.read(b);\n+                rdr.read(b).unwrap();\n                 let s = parse_type(b[0] as char, tm);\n                 buf.push_all(s.as_bytes());\n             }"}, {"sha": "6138c5416f2b456bb5448c5d2a30617a005e50c7", "filename": "src/libextra/url.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -102,8 +102,8 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            None => break,\n-            Some(..) => buf[0] as char,\n+            Err(..) => break,\n+            Ok(..) => buf[0] as char,\n         };\n \n         match ch {\n@@ -166,14 +166,14 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            None => break,\n-            Some(..) => buf[0] as char\n+            Err(..) => break,\n+            Ok(..) => buf[0] as char\n         };\n         match ch {\n           '%' => {\n             let mut bytes = [0, 0];\n             match rdr.read(bytes) {\n-                Some(2) => {}\n+                Ok(2) => {}\n                 _ => fail!() // FIXME: malformed url?\n             }\n             let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n@@ -228,8 +228,8 @@ fn encode_plus(s: &str) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         match ch {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n@@ -282,8 +282,8 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         match ch {\n             '&' | ';' => {\n@@ -307,7 +307,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                     '%' => {\n                         let mut bytes = [0, 0];\n                         match rdr.read(bytes) {\n-                            Some(2) => {}\n+                            Ok(2) => {}\n                             _ => fail!() // FIXME: malformed?\n                         }\n                         uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n@@ -347,12 +347,12 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(..) => buf[0] as char,\n-            None => break,\n+            Ok(..) => buf[0] as char,\n+            Err(..) => break,\n         };\n         if ch == c {\n             // found a match, adjust markers\n-            index = (rdr.tell() as uint) - 1;\n+            index = (rdr.tell().unwrap() as uint) - 1;\n             mat = 1;\n             break;\n         }"}, {"sha": "29d3066b2f5901a1113254b880322f356309a6a0", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -821,7 +821,7 @@ mod bench {\n     pub fn parse_str(bh: &mut BenchHarness) {\n         let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n         bh.iter(|| {\n-            Uuid::parse_string(s);\n+            Uuid::parse_string(s).unwrap();\n         })\n     }\n }"}, {"sha": "4d8e7e50dcfd50f93092585387de5a6a61dd4754", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -172,20 +172,19 @@ impl Database {\n     }\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n-    fn save(&self) {\n+    fn save(&self) -> io::IoResult<()> {\n         let mut f = File::create(&self.db_filename);\n-        self.db_cache.to_json().to_pretty_writer(&mut f);\n+        self.db_cache.to_json().to_pretty_writer(&mut f)\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n         assert!(self.db_filename.exists());\n-        match io::result(|| File::open(&self.db_filename)) {\n+        match File::open(&self.db_filename) {\n             Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n                             self.db_filename.display(),\n-                            e.desc),\n-            Ok(r) => {\n-                let mut stream = r.unwrap();\n+                            e),\n+            Ok(mut stream) => {\n                 match json::from_reader(&mut stream) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n@@ -203,7 +202,8 @@ impl Database {\n impl Drop for Database {\n     fn drop(&mut self) {\n         if self.db_dirty {\n-            self.save();\n+            // FIXME: is failing the right thing to do here\n+            self.save().unwrap();\n         }\n     }\n }\n@@ -473,13 +473,13 @@ fn test() {\n     fn make_path(filename: ~str) -> Path {\n         let pth = os::self_exe_path().expect(\"workcache::test failed\").with_filename(filename);\n         if pth.exists() {\n-            fs::unlink(&pth);\n+            fs::unlink(&pth).unwrap();\n         }\n         return pth;\n     }\n \n     let pth = make_path(~\"foo.c\");\n-    File::create(&pth).write(bytes!(\"int main() { return 0; }\"));\n+    File::create(&pth).write(bytes!(\"int main() { return 0; }\")).unwrap();\n \n     let db_path = make_path(~\"db.json\");\n \n@@ -491,7 +491,8 @@ fn test() {\n         let subcx = cx.clone();\n         let pth = pth.clone();\n \n-        let file_content = from_utf8_owned(File::open(&pth).read_to_end()).unwrap();\n+        let contents = File::open(&pth).read_to_end().unwrap();\n+        let file_content = from_utf8_owned(contents).unwrap();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n@@ -500,7 +501,7 @@ fn test() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             run::process_status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n                                         ~\"-o\",\n-                                        out.as_str().unwrap().to_owned()]);\n+                                        out.as_str().unwrap().to_owned()]).unwrap();\n \n             let _proof_of_concept = subcx.prep(\"subfn\");\n             // Could run sub-rules inside here."}, {"sha": "c6ecb7697da4e9db4ed186f555759ce8aa74967e", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -29,7 +29,6 @@\n #[license = \"MIT/ASL2\"];\n \n use std::{os, path};\n-use std::io;\n use std::io::fs;\n use std::path::is_sep;\n \n@@ -153,7 +152,7 @@ impl Iterator<Path> for Paths {\n }\n \n fn list_dir_sorted(path: &Path) -> ~[Path] {\n-    match io::result(|| fs::readdir(path)) {\n+    match fs::readdir(path) {\n         Ok(mut children) => {\n             children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n             children"}, {"sha": "ef2c77fc8e25f4b1c7671cc8f2ab9eb389f7ef82", "filename": "src/libgreen/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -56,16 +56,17 @@ pub fn dumb_println(args: &fmt::Arguments) {\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) {\n+        fn write(&mut self, data: &[u8]) -> io::IoResult<()> {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n                             data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n+            Ok(()) // just ignore the result\n         }\n     }\n     let mut w = Stderr;\n-    fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "868586b36911e431ac6b83d227a5cbc9da7f857f", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -23,7 +23,7 @@ static mut TASK_COUNT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n static mut TASK_LOCK: Mutex = MUTEX_INIT;\n \n pub fn increment() {\n-    unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst); }\n+    let _ = unsafe { TASK_COUNT.fetch_add(1, atomics::SeqCst) };\n }\n \n pub fn decrement() {"}, {"sha": "cc5b0770d4d2056daf6d0ad7875e5093f22c692a", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -111,17 +111,14 @@ impl FileDesc {\n }\n \n impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.inner_read(buf) { Ok(n) => Some(n), Err(..) => None }\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.inner_read(buf)\n     }\n }\n \n impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.inner_write(buf) {\n-            Ok(()) => {}\n-            Err(e) => { io::io_error::cond.raise(e); }\n-        }\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.inner_write(buf)\n     }\n }\n \n@@ -425,7 +422,7 @@ impl rtio::RtioFileStream for CFile {\n \n impl Drop for CFile {\n     fn drop(&mut self) {\n-        unsafe { libc::fclose(self.file); }\n+        unsafe { let _ = libc::fclose(self.file); }\n     }\n }\n \n@@ -515,7 +512,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                     paths.push(Path::new(cstr));\n                     entry_ptr = readdir(dir_ptr);\n                 }\n-                closedir(dir_ptr);\n+                assert_eq!(closedir(dir_ptr), 0);\n                 Ok(paths)\n             } else {\n                 Err(super::last_error())\n@@ -564,7 +561,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                         }\n                         more_files = FindNextFileW(find_handle, wfd_ptr as HANDLE);\n                     }\n-                    FindClose(find_handle);\n+                    assert!(FindClose(find_handle) != 0);\n                     free(wfd_ptr as *mut c_void);\n                     Ok(paths)\n                 } else {\n@@ -686,7 +683,9 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n                                   ptr::mut_null())\n             })\n         };\n-        if handle == ptr::mut_null() { return Err(super::last_error()) }\n+        if handle as int == libc::INVALID_HANDLE_VALUE as int {\n+            return Err(super::last_error())\n+        }\n         let ret = fill_utf16_buf_and_decode(|buf, sz| {\n             unsafe {\n                 libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n@@ -697,7 +696,7 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n             Some(s) => Ok(Path::new(s)),\n             None => Err(super::last_error()),\n         };\n-        unsafe { libc::CloseHandle(handle) };\n+        assert!(unsafe { libc::CloseHandle(handle) } != 0);\n         return ret;\n \n     }\n@@ -935,7 +934,7 @@ mod tests {\n             let mut reader = FileDesc::new(input, true);\n             let mut writer = FileDesc::new(out, true);\n \n-            writer.inner_write(bytes!(\"test\"));\n+            writer.inner_write(bytes!(\"test\")).unwrap();\n             let mut buf = [0u8, ..4];\n             match reader.inner_read(buf) {\n                 Ok(4) => {\n@@ -960,9 +959,9 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\"));\n+            file.write(bytes!(\"test\")).unwrap();\n             let mut buf = [0u8, ..4];\n-            file.seek(0, io::SeekSet);\n+            let _ = file.seek(0, io::SeekSet).unwrap();\n             match file.read(buf) {\n                 Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);"}, {"sha": "ac68b1523d7d995153b4af43be0183f6cbcc1d77", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -112,8 +112,8 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n     }\n }\n \n-#[cfg(windows)] unsafe fn close(sock: sock_t) { libc::closesocket(sock); }\n-#[cfg(unix)]    unsafe fn close(sock: sock_t) { libc::close(sock); }\n+#[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n+#[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n \n fn sockname(fd: sock_t,\n             f: extern \"system\" unsafe fn(sock_t, *mut libc::sockaddr,"}, {"sha": "2a061c5f9b204fe565c8a7088dfd861adeca2973", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -102,9 +102,9 @@ impl Process {\n                                    cwd.as_ref(), in_fd, out_fd, err_fd);\n \n         unsafe {\n-            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n+            for pipe in in_pipe.iter() { let _ = libc::close(pipe.input); }\n+            for pipe in out_pipe.iter() { let _ = libc::close(pipe.out); }\n+            for pipe in err_pipe.iter() { let _ = libc::close(pipe.out); }\n         }\n \n         match res {\n@@ -149,9 +149,8 @@ impl rtio::RtioProcess for Process {\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n             match signal {\n                 io::process::PleaseExitSignal | io::process::MustDieSignal => {\n-                    libc::funcs::extra::kernel32::TerminateProcess(\n-                        cast::transmute(pid), 1);\n-                    Ok(())\n+                    let ret = libc::TerminateProcess(pid as libc::HANDLE, 1);\n+                    super::mkerr_winbool(ret)\n                 }\n                 _ => Err(io::IoError {\n                     kind: io::OtherIoError,\n@@ -163,8 +162,8 @@ impl rtio::RtioProcess for Process {\n \n         #[cfg(not(windows))]\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            Ok(())\n+            let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+            super::mkerr_libc(r)\n         }\n     }\n }\n@@ -255,9 +254,9 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             })\n         });\n \n-        CloseHandle(si.hStdInput);\n-        CloseHandle(si.hStdOutput);\n-        CloseHandle(si.hStdError);\n+        assert!(CloseHandle(si.hStdInput) != 0);\n+        assert!(CloseHandle(si.hStdOutput) != 0);\n+        assert!(CloseHandle(si.hStdError) != 0);\n \n         match create_err {\n             Some(err) => return Err(err),\n@@ -269,7 +268,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         // able to close it later. We don't close the process handle however\n         // because std::we want the process id to stay valid at least until the\n         // calling code closes the process handle.\n-        CloseHandle(pi.hThread);\n+        assert!(CloseHandle(pi.hThread) != 0);\n \n         Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n@@ -445,24 +444,24 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         rustrt::rust_unset_sigprocmask();\n \n         if in_fd == -1 {\n-            libc::close(libc::STDIN_FILENO);\n+            let _ = libc::close(libc::STDIN_FILENO);\n         } else if retry(|| dup2(in_fd, 0)) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n         if out_fd == -1 {\n-            libc::close(libc::STDOUT_FILENO);\n+            let _ = libc::close(libc::STDOUT_FILENO);\n         } else if retry(|| dup2(out_fd, 1)) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n         if err_fd == -1 {\n-            libc::close(libc::STDERR_FILENO);\n+            let _ = libc::close(libc::STDERR_FILENO);\n         } else if retry(|| dup2(err_fd, 2)) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n         for fd in range(3, getdtablesize()).rev() {\n             if fd != output.fd() {\n-                close(fd as c_int);\n+                let _ = close(fd as c_int);\n             }\n         }\n \n@@ -478,7 +477,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             }\n         });\n         with_argv(prog, args, |argv| {\n-            execvp(*argv, argv);\n+            let _ = execvp(*argv, argv);\n             let errno = os::errno();\n             let bytes = [\n                 (errno << 24) as u8,\n@@ -576,9 +575,9 @@ fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n \n #[cfg(windows)]\n fn free_handle(handle: *()) {\n-    unsafe {\n-        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n-    }\n+    assert!(unsafe {\n+        libc::CloseHandle(cast::transmute(handle)) != 0\n+    })\n }\n \n #[cfg(unix)]\n@@ -629,15 +628,15 @@ fn waitpid(pid: pid_t) -> p::ProcessExit {\n             loop {\n                 let mut status = 0;\n                 if GetExitCodeProcess(process, &mut status) == FALSE {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     fail!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n                 }\n                 if status != STILL_ACTIVE {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     return p::ExitStatus(status as int);\n                 }\n                 if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n-                    CloseHandle(process);\n+                    assert!(CloseHandle(process) != 0);\n                     fail!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n                 }\n             }"}, {"sha": "7311be46e8bd244b1dd206d763529537067b8b8c", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -126,11 +126,11 @@ mod imp {\n     }\n \n     pub fn signal(handle: HANDLE) {\n-        unsafe { SetEvent(handle); }\n+        assert!(unsafe { SetEvent(handle) != 0 });\n     }\n \n     pub fn close(handle: HANDLE) {\n-        unsafe { CloseHandle(handle); }\n+        assert!(unsafe { CloseHandle(handle) != 0 });\n     }\n \n     extern \"system\" {"}, {"sha": "cda239329dcc07ca571da85b1fa1bfe25a7771a7", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -187,7 +187,7 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                fd.inner_read(buf).unwrap();\n+                assert_eq!(fd.inner_read(buf).unwrap(), 1);\n             }\n \n             -1 if os::errno() == libc::EINTR as int => {}\n@@ -216,7 +216,8 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+        // FIXME: this can fail because of EINTR, what do do?\n+        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n     }\n \n     fn inner(&mut self) -> ~Inner {"}, {"sha": "7c22e90bbffe23518551129b36e8e7b676e2dca6", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -96,15 +96,15 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n             if fd == input {\n                 let mut buf = [0, ..1];\n                 // drain the input file descriptor of its input\n-                FileDesc::new(fd, false).inner_read(buf).unwrap();\n+                let _ = FileDesc::new(fd, false).inner_read(buf).unwrap();\n                 incoming = true;\n             } else {\n                 let mut bits = [0, ..8];\n                 // drain the timerfd of how many times its fired\n                 //\n                 // FIXME: should this perform a send() this number of\n                 //      times?\n-                FileDesc::new(fd, false).inner_read(bits).unwrap();\n+                let _ = FileDesc::new(fd, false).inner_read(bits).unwrap();\n                 let remove = {\n                     match map.find(&fd).expect(\"fd unregistered\") {\n                         &(ref c, oneshot) => !c.try_send(()) || oneshot\n@@ -166,7 +166,8 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+        // FIXME: this can fail because of EINTR, what do do?\n+        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n     }\n \n     fn remove(&mut self) {"}, {"sha": "6b472d2f46d59621baf84139e3fe62dc54e53cfd", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -62,8 +62,8 @@ fn helper(input: libc::HANDLE, messages: Port<Req>) {\n                         c.send(());\n                         match objs.iter().position(|&o| o == obj) {\n                             Some(i) => {\n-                                objs.remove(i);\n-                                chans.remove(i - 1);\n+                                drop(objs.remove(i));\n+                                drop(chans.remove(i - 1));\n                             }\n                             None => {}\n                         }\n@@ -83,8 +83,8 @@ fn helper(input: libc::HANDLE, messages: Port<Req>) {\n                 }\n             };\n             if remove {\n-                objs.remove(idx as uint);\n-                chans.remove(idx as uint - 1);\n+                drop(objs.remove(idx as uint));\n+                drop(chans.remove(idx as uint - 1));\n             }\n         }\n     }\n@@ -133,7 +133,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE); }\n+        let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n     fn oneshot(&mut self, msecs: u64) -> Port<()> {\n@@ -173,7 +173,7 @@ impl rtio::RtioTimer for Timer {\n impl Drop for Timer {\n     fn drop(&mut self) {\n         self.remove();\n-        unsafe { libc::CloseHandle(self.obj); }\n+        assert!(unsafe { libc::CloseHandle(self.obj) != 0 });\n     }\n }\n "}, {"sha": "1e4317af397588f86084594d6048bccaf0377e70", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -21,6 +21,7 @@\n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n+#[deny(unused_result, unused_must_use)];\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n@@ -61,9 +62,10 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);\n-    task::new((my_stack_bottom, my_stack_top)).run(|| {\n+    let t = task::new((my_stack_bottom, my_stack_top)).run(|| {\n         exit_code = Some(run(main.take_unwrap()));\n     });\n+    drop(t);\n     unsafe { rt::cleanup(); }\n     // If the exit code wasn't set, then the task block must have failed.\n     return exit_code.unwrap_or(rt::DEFAULT_ERROR_CODE);"}, {"sha": "0def5cb4053386a7c04323c6137ec2c7918c9455", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -103,7 +103,8 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n         let mut f = Some(f);\n         let mut task = task;\n         task.put_runtime(ops as ~rt::Runtime);\n-        task.run(|| { f.take_unwrap()() });\n+        let t = task.run(|| { f.take_unwrap()() });\n+        drop(t);\n         bookkeeping::decrement();\n     })\n }"}, {"sha": "18aef17b9eb77031b3ff9cdfe745b236c98b1643", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -17,6 +17,7 @@ use lib::llvm::{ArchiveRef, llvm};\n \n use std::cast;\n use std::io::fs;\n+use std::io;\n use std::libc;\n use std::os;\n use std::run::{ProcessOptions, Process, ProcessOutput};\n@@ -50,9 +51,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         Some(p) => { debug!(\"inside {}\", p.display()); }\n         None => {}\n     }\n-    let mut opt_prog = Process::new(ar, args.as_slice(), opts);\n-    match opt_prog {\n-        Some(ref mut prog) => {\n+    match Process::new(ar, args.as_slice(), opts) {\n+        Ok(mut prog) => {\n             let o = prog.finish_with_output();\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n@@ -63,8 +63,8 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n             }\n             o\n         },\n-        None => {\n-            sess.err(format!(\"could not exec `{}`\", ar));\n+        Err(e) => {\n+            sess.err(format!(\"could not exec `{}`: {}\", ar, e));\n             sess.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -94,32 +94,33 @@ impl Archive {\n             let archive = os::make_absolute(&self.dst);\n             run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n                                                       &Path::new(file)]);\n-            fs::File::open(&loc.path().join(file)).read_to_end()\n+            fs::File::open(&loc.path().join(file)).read_to_end().unwrap()\n         } else {\n             run_ar(self.sess, \"p\", None, [&self.dst, &Path::new(file)]).output\n         }\n     }\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) {\n+    pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = self.find_library(name);\n-        self.add_archive(&location, name, []);\n+        self.add_archive(&location, name, [])\n     }\n \n     /// Adds all of the contents of the rlib at the specified path to this\n     /// archive.\n     ///\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool) {\n+    pub fn add_rlib(&mut self, rlib: &Path, name: &str,\n+                    lto: bool) -> io::IoResult<()> {\n         let object = format!(\"{}.o\", name);\n         let bytecode = format!(\"{}.bc\", name);\n         let mut ignore = ~[METADATA_FILENAME, bytecode.as_slice()];\n         if lto {\n             ignore.push(object.as_slice());\n         }\n-        self.add_archive(rlib, name, ignore);\n+        self.add_archive(rlib, name, ignore)\n     }\n \n     /// Adds an arbitrary file to this archive\n@@ -144,7 +145,8 @@ impl Archive {\n         str::from_utf8(output.output).unwrap().lines().map(|s| s.to_owned()).collect()\n     }\n \n-    fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {\n+    fn add_archive(&mut self, archive: &Path, name: &str,\n+                   skip: &[&str]) -> io::IoResult<()> {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory\n@@ -159,7 +161,7 @@ impl Archive {\n         // We skip any files explicitly desired for skipping, and we also skip\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n-        let files = fs::readdir(loc.path());\n+        let files = if_ok!(fs::readdir(loc.path()));\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n@@ -168,14 +170,15 @@ impl Archive {\n \n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n-            fs::rename(file, &new_filename);\n+            if_ok!(fs::rename(file, &new_filename));\n             inputs.push(new_filename);\n         }\n \n         // Finally, add all the renamed files to this archive\n         let mut args = ~[&self.dst];\n         args.extend(&mut inputs.iter());\n         run_ar(self.sess, \"r\", None, args.as_slice());\n+        Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {"}, {"sha": "4d6576fed3462290ffb48d805706638239a7a1c2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -100,7 +100,6 @@ pub mod write {\n     use util::common::time;\n \n     use std::c_str::ToCStr;\n-    use std::io;\n     use std::libc::{c_uint, c_int};\n     use std::path::Path;\n     use std::run;\n@@ -297,21 +296,17 @@ pub mod write {\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        let opt_prog = {\n-            let _guard = io::ignore_io_error();\n-            run::process_output(cc, args)\n-        };\n-        match opt_prog {\n-            Some(prog) => {\n+        match run::process_output(cc, args) {\n+            Ok(prog) => {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n                     sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n                     sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                     sess.abort_if_errors();\n                 }\n             },\n-            None => {\n-                sess.err(format!(\"could not exec the linker `{}`\", cc));\n+            Err(e) => {\n+                sess.err(format!(\"could not exec the linker `{}`: {}\", cc, e));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -768,6 +763,15 @@ fn get_system_tool(sess: Session, tool: &str) -> ~str {\n     }\n }\n \n+fn remove(sess: Session, path: &Path) {\n+    match fs::unlink(path) {\n+        Ok(..) => {}\n+        Err(e) => {\n+            sess.err(format!(\"failed to remove {}: {}\", path.display(), e));\n+        }\n+    }\n+}\n+\n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub fn link_binary(sess: Session,\n@@ -785,17 +789,15 @@ pub fn link_binary(sess: Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.save_temps {\n-        fs::unlink(obj_filename);\n-        fs::unlink(&obj_filename.with_extension(\"metadata.o\"));\n+        remove(sess, obj_filename);\n+        remove(sess, &obj_filename.with_extension(\"metadata.o\"));\n     }\n \n     out_filenames\n }\n \n fn is_writeable(p: &Path) -> bool {\n-    use std::io;\n-\n-    match io::result(|| p.stat()) {\n+    match p.stat() {\n         Err(..) => true,\n         Ok(m) => m.perm & io::UserWrite == io::UserWrite\n     }\n@@ -884,7 +886,7 @@ fn link_rlib(sess: Session,\n     for &(ref l, kind) in used_libraries.get().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                a.add_native_library(l.as_slice());\n+                a.add_native_library(l.as_slice()).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -919,16 +921,23 @@ fn link_rlib(sess: Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            fs::File::create(&metadata).write(trans.metadata);\n+            match fs::File::create(&metadata).write(trans.metadata) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    sess.err(format!(\"failed to write {}: {}\",\n+                                     metadata.display(), e));\n+                    sess.abort_if_errors();\n+                }\n+            }\n             a.add_file(&metadata, false);\n-            fs::unlink(&metadata);\n+            remove(sess, &metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.\n             let bc = obj_filename.with_extension(\"bc\");\n             a.add_file(&bc, false);\n             if !sess.opts.save_temps {\n-                fs::unlink(&bc);\n+                remove(sess, &bc);\n             }\n \n             // After adding all files to the archive, we need to update the\n@@ -959,7 +968,7 @@ fn link_rlib(sess: Session,\n // metadata file).\n fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n     let mut a = link_rlib(sess, None, obj_filename, out_filename);\n-    a.add_native_library(\"morestack\");\n+    a.add_native_library(\"morestack\").unwrap();\n \n     let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n     for &(cnum, ref path) in crates.iter() {\n@@ -970,7 +979,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n                 continue\n             }\n         };\n-        a.add_rlib(&p, name, sess.lto());\n+        a.add_rlib(&p, name, sess.lto()).unwrap();\n         let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n@@ -1004,23 +1013,19 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let opt_prog = {\n-        let _guard = io::ignore_io_error();\n-        time(sess.time_passes(), \"running linker\", (), |()|\n-             run::process_output(cc_prog, cc_args))\n-    };\n-\n-    match opt_prog {\n-        Some(prog) => {\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n+                    run::process_output(cc_prog, cc_args));\n+    match prog {\n+        Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n                 sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n                 sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n-        None => {\n-            sess.err(format!(\"could not exec the linker `{}`\", cc_prog));\n+        Err(e) => {\n+            sess.err(format!(\"could not exec the linker `{}`: {}\", cc_prog, e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1030,8 +1035,14 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // the symbols\n     if sess.targ_cfg.os == abi::OsMacos && sess.opts.debuginfo {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        run::process_status(\"dsymutil\",\n-                            [out_filename.as_str().unwrap().to_owned()]);\n+        match run::process_status(\"dsymutil\",\n+                                  [out_filename.as_str().unwrap().to_owned()]) {\n+            Ok(..) => {}\n+            Err(e) => {\n+                sess.err(format!(\"failed to run dsymutil: {}\", e));\n+                sess.abort_if_errors();\n+            }\n+        }\n     }\n }\n \n@@ -1225,7 +1236,16 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n                     time(sess.time_passes(), format!(\"altering {}.rlib\", name),\n                          (), |()| {\n                         let dst = tmpdir.join(cratepath.filename().unwrap());\n-                        fs::copy(&cratepath, &dst);\n+                        match fs::copy(&cratepath, &dst) {\n+                            Ok(..) => {}\n+                            Err(e) => {\n+                                sess.err(format!(\"failed to copy {} to {}: {}\",\n+                                                 cratepath.display(),\n+                                                 dst.display(),\n+                                                 e));\n+                                sess.abort_if_errors();\n+                            }\n+                        }\n                         let dst_str = dst.as_str().unwrap().to_owned();\n                         let mut archive = Archive::open(sess, dst);\n                         archive.remove_file(format!(\"{}.o\", name));"}, {"sha": "a61c297956d78aedaac0c01d468d0c96c6e5b923", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -399,7 +399,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         // Remove assembly source, unless --save-temps was specified\n         if !sess.opts.save_temps {\n-            fs::unlink(&asm_filename);\n+            fs::unlink(&asm_filename).unwrap();\n         }\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n@@ -455,33 +455,39 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n     return false;\n }\n \n-fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames, crate: &ast::Crate)\n+fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames,\n+                  crate: &ast::Crate) -> io::IoResult<()>\n {\n     let lm = link::build_link_meta(sess, crate.attrs, &outputs.obj_filename,\n-                                       &mut ::util::sha2::Sha256::new());\n+                                   &mut ::util::sha2::Sha256::new());\n \n     let sess_outputs = sess.outputs.borrow();\n     let out_filenames = sess_outputs.get().iter()\n-        .map(|&output| link::filename_for_input(&sess, output, &lm, &outputs.out_filename))\n+        .map(|&output| link::filename_for_input(&sess, output, &lm,\n+                                                &outputs.out_filename))\n         .to_owned_vec();\n \n-    // Write out dependency rules to the dep-info file if requested with --dep-info\n+    // Write out dependency rules to the dep-info file if requested with\n+    // --dep-info\n     let deps_filename = match sess.opts.write_dependency_info {\n         // Use filename from --dep-file argument if given\n         (true, Some(ref filename)) => filename.clone(),\n-        // Use default filename: crate source filename with extension replaced by \".d\"\n+        // Use default filename: crate source filename with extension replaced\n+        // by \".d\"\n         (true, None) => match *input {\n             FileInput(ref input_path) => {\n-                let filestem = input_path.filestem().expect(\"input file must have stem\");\n-                let filename = out_filenames[0].dir_path().join(filestem).with_extension(\"d\");\n-                filename\n+                let filestem = input_path.filestem().expect(\"input file must \\\n+                                                             have stem\");\n+                let filename = out_filenames[0].dir_path().join(filestem);\n+                filename.with_extension(\"d\")\n             },\n             StrInput(..) => {\n-                sess.warn(\"can not write --dep-info without a filename when compiling stdin.\");\n-                return;\n+                sess.warn(\"can not write --dep-info without a filename \\\n+                           when compiling stdin.\");\n+                return Ok(());\n             },\n         },\n-        _ => return,\n+        _ => return Ok(()),\n     };\n \n     // Build a list of files used to compile the output and\n@@ -499,11 +505,12 @@ fn write_out_deps(sess: Session, input: &Input, outputs: &OutputFilenames, crate\n              })\n              .collect()\n     };\n-    let mut file = io::File::create(&deps_filename);\n+    let mut file = if_ok!(io::File::create(&deps_filename));\n     for path in out_filenames.iter() {\n-        write!(&mut file as &mut Writer,\n-               \"{}: {}\\n\\n\", path.display(), files.connect(\" \"));\n+        if_ok!(write!(&mut file as &mut Writer,\n+                      \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));\n     }\n+    Ok(())\n }\n \n pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n@@ -521,7 +528,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n         let outputs = build_output_filenames(input, outdir, output,\n                                              expanded_crate.attrs, sess);\n \n-        write_out_deps(sess, input, outputs, &expanded_crate);\n+        write_out_deps(sess, input, outputs, &expanded_crate).unwrap();\n \n         if stop_after_phase_2(sess) { return; }\n \n@@ -541,32 +548,33 @@ struct IdentifiedAnnotation {\n }\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(s, _) => pprust::popen(s),\n-            _ => ()\n+            _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) {\n+    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeItem(s, item) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, item.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, item.id.to_str()));\n             }\n             pprust::NodeBlock(s, blk) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, ~\"block \" + blk.id.to_str()));\n             }\n             pprust::NodeExpr(s, expr) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, expr.id.to_str());\n-                pprust::pclose(s);\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, expr.id.to_str()));\n+                if_ok!(pprust::pclose(s));\n             }\n             pprust::NodePat(s, pat) => {\n-                pp::space(&mut s.s);\n-                pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pprust::synth_comment(s, ~\"pat \" + pat.id.to_str()));\n             }\n         }\n+        Ok(())\n     }\n }\n \n@@ -575,24 +583,26 @@ struct TypedAnnotation {\n }\n \n impl pprust::PpAnn for TypedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(s, _) => pprust::popen(s),\n-            _ => ()\n+            _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) {\n+    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         let tcx = self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(s, expr) => {\n-                pp::space(&mut s.s);\n-                pp::word(&mut s.s, \"as\");\n-                pp::space(&mut s.s);\n-                pp::word(&mut s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n-                pprust::pclose(s);\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pp::word(&mut s.s, \"as\"));\n+                if_ok!(pp::space(&mut s.s));\n+                if_ok!(pp::word(&mut s.s,\n+                                ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n+                if_ok!(pprust::pclose(s));\n             }\n             _ => ()\n         }\n+        Ok(())\n     }\n }\n \n@@ -638,7 +648,7 @@ pub fn pretty_print_input(sess: Session,\n                         &mut rdr,\n                         ~stdout as ~io::Writer,\n                         annotation,\n-                        is_expanded);\n+                        is_expanded).unwrap();\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {\n@@ -1167,10 +1177,11 @@ pub fn early_error(emitter: &diagnostic::Emitter, msg: &str) -> ! {\n     fail!(diagnostic::FatalError);\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: &mut io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path,\n+                     out: &mut io::Writer) -> io::IoResult<()> {\n     metadata::loader::list_file_metadata(\n         token::get_ident_interner(),\n-        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n+        session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)\n }\n \n #[cfg(test)]"}, {"sha": "c5f7d61c224a58c52c977baec351398ed2e8e9b5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -54,6 +54,11 @@ use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n use syntax::parse;\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod middle {\n     pub mod trans;\n     pub mod ty;\n@@ -236,8 +241,8 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if ifile == \"-\" {\n-            let src =\n-                str::from_utf8_owned(io::stdin().read_to_end()).unwrap();\n+            let contents = io::stdin().read_to_end().unwrap();\n+            let src = str::from_utf8_owned(contents).unwrap();\n             (d::StrInput(src), None)\n         } else {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n@@ -267,7 +272,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n           d::FileInput(ref ifile) => {\n             let mut stdout = io::stdout();\n             d::list_metadata(sess, &(*ifile),\n-                                  &mut stdout as &mut io::Writer);\n+                             &mut stdout as &mut io::Writer).unwrap();\n           }\n           d::StrInput(_) => {\n             d::early_error(demitter, \"can not list metadata for stdin\");"}, {"sha": "8ba98e84dfa50b85ab894df6d6e00ed92731581e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -1111,15 +1111,15 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n }\n \n fn list_crate_attributes(intr: @IdentInterner, md: ebml::Doc, hash: &str,\n-                         out: &mut io::Writer) {\n-    write!(out, \"=Crate Attributes ({})=\\n\", hash);\n+                         out: &mut io::Writer) -> io::IoResult<()> {\n+    if_ok!(write!(out, \"=Crate Attributes ({})=\\n\", hash));\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr));\n+        if_ok!(write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n-    write!(out, \"\\n\\n\");\n+    write!(out, \"\\n\\n\")\n }\n \n pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n@@ -1154,21 +1154,22 @@ pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: &[u8], out: &mut io::Writer) {\n-    write!(out, \"=External Dependencies=\\n\");\n+fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n+    if_ok!(write!(out, \"=External Dependencies=\\n\"));\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n         let string = token::get_ident(dep.name.name);\n-        write!(out,\n-               \"{} {}-{}-{}\\n\",\n-               dep.cnum,\n-               string.get(),\n-               dep.hash,\n-               dep.vers);\n+        if_ok!(write!(out,\n+                      \"{} {}-{}-{}\\n\",\n+                      dep.cnum,\n+                      string.get(),\n+                      dep.hash,\n+                      dep.vers));\n     }\n \n-    write!(out, \"\\n\");\n+    if_ok!(write!(out, \"\\n\"));\n+    Ok(())\n }\n \n pub fn get_crate_hash(data: &[u8]) -> ~str {\n@@ -1186,11 +1187,11 @@ pub fn get_crate_vers(data: &[u8]) -> ~str {\n }\n \n pub fn list_crate_metadata(intr: @IdentInterner, bytes: &[u8],\n-                           out: &mut io::Writer) {\n+                           out: &mut io::Writer) -> io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, hash, out);\n-    list_crate_deps(bytes, out);\n+    if_ok!(list_crate_attributes(intr, md, hash, out));\n+    list_crate_deps(bytes, out)\n }\n \n // Translates a def_id from an external crate to a def_id for the current"}, {"sha": "d56d211b713ee9c3ce82acd392d3a591833cd1ae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -10,6 +10,7 @@\n \n // Metadata encoding\n \n+#[allow(unused_must_use)]; // everything is just a MemWriter, can't fail\n \n use metadata::common::*;\n use metadata::cstore;\n@@ -350,7 +351,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             let mut index = index.borrow_mut();\n             index.get().push(entry {\n                 val: variant.node.id as i64,\n-                pos: ebml_w.writer.tell(),\n+                pos: ebml_w.writer.tell().unwrap(),\n             });\n         }\n         ebml_w.start_tag(tag_items_data_item);\n@@ -668,10 +669,10 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     // Encode the base self type.\n     match explicit_self {\n-        SelfStatic => ebml_w.writer.write(&[ 's' as u8 ]),\n-        SelfValue  => ebml_w.writer.write(&[ 'v' as u8 ]),\n-        SelfBox    => ebml_w.writer.write(&[ '@' as u8 ]),\n-        SelfUniq   => ebml_w.writer.write(&[ '~' as u8 ]),\n+        SelfStatic => { ebml_w.writer.write(&[ 's' as u8 ]); }\n+        SelfValue  => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n+        SelfBox    => { ebml_w.writer.write(&[ '@' as u8 ]); }\n+        SelfUniq   => { ebml_w.writer.write(&[ '~' as u8 ]); }\n         SelfRegion(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&['&' as u8]);\n@@ -684,8 +685,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n     fn encode_mutability(ebml_w: &writer::Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            MutImmutable => ebml_w.writer.write(&[ 'i' as u8 ]),\n-            MutMutable => ebml_w.writer.write(&[ 'm' as u8 ]),\n+            MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }\n+            MutMutable => { ebml_w.writer.write(&[ 'm' as u8 ]); }\n         }\n     }\n }\n@@ -726,12 +727,12 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         };\n \n         let id = field.node.id;\n-        index.push(entry {val: id as i64, pos: ebml_w.writer.tell()});\n+        index.push(entry {val: id as i64, pos: ebml_w.writer.tell().unwrap()});\n         {\n             let mut global_index = global_index.borrow_mut();\n             global_index.get().push(entry {\n                 val: id as i64,\n-                pos: ebml_w.writer.tell(),\n+                pos: ebml_w.writer.tell().unwrap(),\n             });\n         }\n         ebml_w.start_tag(tag_items_data_item);\n@@ -758,7 +759,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: ctor_id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -921,7 +922,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: item.id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n     let add_to_index: || = || add_to_index(item, ebml_w, index);\n@@ -1157,7 +1158,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 let mut index = index.borrow_mut();\n                 index.get().push(entry {\n                     val: m.def_id.node as i64,\n-                    pos: ebml_w.writer.tell(),\n+                    pos: ebml_w.writer.tell().unwrap(),\n                 });\n             }\n             encode_info_for_method(ecx,\n@@ -1219,7 +1220,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 let mut index = index.borrow_mut();\n                 index.get().push(entry {\n                     val: method_def_id.node as i64,\n-                    pos: ebml_w.writer.tell(),\n+                    pos: ebml_w.writer.tell().unwrap(),\n                 });\n             }\n \n@@ -1294,7 +1295,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: nitem.id as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n \n@@ -1418,7 +1419,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n             val: CRATE_NODE_ID as i64,\n-            pos: ebml_w.writer.tell(),\n+            pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n     encode_info_for_mod(ecx,\n@@ -1478,7 +1479,7 @@ fn encode_index<T:'static>(\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket in buckets.iter() {\n-        bucket_locs.push(ebml_w.writer.tell());\n+        bucket_locs.push(ebml_w.writer.tell().unwrap());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for elt in (**bucket).iter() {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -1895,58 +1896,58 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, crate: &Crate)\n \n     encode_hash(&mut ebml_w, ecx.link_meta.crate_hash);\n \n-    let mut i = ebml_w.writer.tell();\n+    let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, crate);\n     encode_attributes(&mut ebml_w, crate_attrs);\n-    ecx.stats.attr_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_crate_deps(&ecx, &mut ebml_w, ecx.cstore);\n-    ecx.stats.dep_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.dep_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the language items.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_lang_items(&ecx, &mut ebml_w);\n-    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.lang_item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the native libraries used\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_native_libraries(&ecx, &mut ebml_w);\n-    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.native_lib_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the macro registrar function\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_macro_registrar_fn(&ecx, &mut ebml_w);\n-    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.macro_registrar_fn_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode macro definitions\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_macro_defs(&ecx, crate, &mut ebml_w);\n-    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.macro_defs_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_impls(&ecx, crate, &mut ebml_w);\n-    ecx.stats.impl_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.impl_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode miscellaneous info.\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     encode_misc_info(&ecx, crate, &mut ebml_w);\n-    ecx.stats.misc_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.misc_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     let items_index = encode_info_for_items(&ecx, &mut ebml_w, crate);\n-    ecx.stats.item_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.item_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n-    i = ebml_w.writer.tell();\n+    i = ebml_w.writer.tell().unwrap();\n     let items_buckets = create_index(items_index);\n     encode_index(&mut ebml_w, items_buckets, write_i64);\n-    ecx.stats.index_bytes.set(ebml_w.writer.tell() - i);\n+    ecx.stats.index_bytes.set(ebml_w.writer.tell().unwrap() - i);\n     ebml_w.end_tag();\n \n-    ecx.stats.total_bytes.set(ebml_w.writer.tell());\n+    ecx.stats.total_bytes.set(ebml_w.writer.tell().unwrap());\n \n     if tcx.sess.meta_stats() {\n         for e in ebml_w.writer.get_ref().iter() {"}, {"sha": "7e04a36ee2e0878854b1aac29d95394a1bea5e96", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,7 +11,6 @@\n use std::cell::RefCell;\n use std::option;\n use std::os;\n-use std::io;\n use std::io::fs;\n use std::hashmap::HashSet;\n \n@@ -93,7 +92,7 @@ impl FileSearch {\n     pub fn search(&self, pick: pick) {\n         self.for_each_lib_search_path(|lib_search_path| {\n             debug!(\"searching {}\", lib_search_path.display());\n-            match io::result(|| fs::readdir(lib_search_path)) {\n+            match fs::readdir(lib_search_path) {\n                 Ok(files) => {\n                     let mut rslt = FileDoesntMatch;\n                     let is_rlib = |p: & &Path| {\n@@ -163,16 +162,16 @@ pub fn get_or_default_sysroot() -> Path {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<Path>) -> Option<Path> {\n         path.and_then(|mut path|\n-            match io::io_error::cond.trap(|_| ()).inside(|| fs::readlink(&path)) {\n-                Some(canon) => {\n+            match fs::readlink(&path) {\n+                Ok(canon) => {\n                     if canon.is_absolute() {\n                         Some(canon)\n                     } else {\n                         path.pop();\n                         Some(path.join(canon))\n                     }\n                 },\n-                None => Some(path),\n+                Err(..) => Some(path),\n             })\n     }\n "}, {"sha": "abcd650ced13152712cbe2a1a2c73b675c1a619e", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -381,13 +381,13 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(intr: @IdentInterner,\n                           os: Os,\n                           path: &Path,\n-                          out: &mut io::Writer) {\n+                          out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr,\n                                                           bytes.as_slice(),\n                                                           out),\n       option::None => {\n-        write!(out, \"could not find metadata in {}.\\n\", path.display())\n+          write!(out, \"could not find metadata in {}.\\n\", path.display())\n       }\n     }\n }"}, {"sha": "913c5dac46039c687b80599a47f8a57f25f34769", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -10,6 +10,8 @@\n \n // Type encoding\n \n+#[allow(unused_must_use)]; // as with encoding, everything is a no-fail MemWriter\n+\n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::io;\n@@ -92,9 +94,9 @@ pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n                   None => {}\n               }\n           }\n-          let pos = w.tell();\n+          let pos = w.tell().unwrap();\n           enc_sty(w, cx, &ty::get(t).sty);\n-          let end = w.tell();\n+          let end = w.tell().unwrap();\n           let len = end - pos;\n           fn estimate_sz(u: u64) -> u64 {\n               let mut n = u;"}, {"sha": "78221d2adb34191176b6228661d3e9d9e68cb6b9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -88,7 +88,7 @@ struct LoopScope<'a> {\n }\n \n impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n-    fn pre(&self, node: pprust::AnnNode) {\n+    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         let (ps, id) = match node {\n             pprust::NodeExpr(ps, expr) => (ps, expr.id),\n             pprust::NodeBlock(ps, blk) => (ps, blk.id),\n@@ -117,9 +117,10 @@ impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n \n             let comment_str = format!(\"id {}: {}{}{}\",\n                                       id, entry_str, gens_str, kills_str);\n-            pprust::synth_comment(ps, comment_str);\n-            pp::space(&mut ps.s);\n+            if_ok!(pprust::synth_comment(ps, comment_str));\n+            if_ok!(pp::space(&mut ps.s));\n         }\n+        Ok(())\n     }\n }\n \n@@ -347,18 +348,20 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n             let this = @(*self).clone();\n-            this.pretty_print_to(~io::stderr() as ~io::Writer, blk);\n+            this.pretty_print_to(~io::stderr() as ~io::Writer, blk).unwrap();\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: ~io::Writer, blk: &ast::Block) {\n+    fn pretty_print_to(@self, wr: ~io::Writer,\n+                       blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self.tcx.sess.intr(),\n                                                     self as @pprust::PpAnn);\n-        pprust::cbox(&mut ps, pprust::indent_unit);\n-        pprust::ibox(&mut ps, 0u);\n-        pprust::print_block(&mut ps, blk);\n-        pp::eof(&mut ps.s);\n+        if_ok!(pprust::cbox(&mut ps, pprust::indent_unit));\n+        if_ok!(pprust::ibox(&mut ps, 0u));\n+        if_ok!(pprust::print_block(&mut ps, blk));\n+        if_ok!(pp::eof(&mut ps.s));\n+        Ok(())\n     }\n }\n "}, {"sha": "26e4a11ae49a203844ee49d5ce2ee1c31394636e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -736,14 +736,15 @@ impl Liveness {\n     pub fn write_vars(&self,\n                       wr: &mut io::Writer,\n                       ln: LiveNode,\n-                      test: |uint| -> LiveNode) {\n+                      test: |uint| -> LiveNode) -> io::IoResult<()> {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars.get()) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                write!(wr, \" {}\", Variable(var_idx).to_str());\n+                if_ok!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n             }\n         }\n+        Ok(())\n     }\n \n     pub fn find_loop_scope(&self,\n@@ -781,6 +782,7 @@ impl Liveness {\n         *loop_scope.get().last().unwrap()\n     }\n \n+    #[allow(unused_must_use)]\n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n         let mut wr = io::MemWriter::new();\n         {"}, {"sha": "82850dffa2b14db89aa6a487f1c53a3b895871a0", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -20,7 +20,7 @@ use std::fmt;\n pub struct Escape<'a>(&'a str);\n \n impl<'a> fmt::Show for Escape<'a> {\n-    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let Escape(s) = *s;\n@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    fmt.buf.write(pile_o_bits.slice(last, i).as_bytes());\n+                    if_ok!(fmt.buf.write(pile_o_bits.slice(last, i).as_bytes()));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,16 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    fmt.buf.write(s.as_bytes());\n+                    if_ok!(fmt.buf.write(s.as_bytes()));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            fmt.buf.write(pile_o_bits.slice_from(last).as_bytes());\n+            if_ok!(fmt.buf.write(pile_o_bits.slice_from(last).as_bytes()));\n         }\n+        Ok(())\n     }\n }"}, {"sha": "92d15fbcd672d13081152e5824278db3a8db2b76", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 123, "deletions": 88, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -48,99 +48,119 @@ impl PuritySpace {\n }\n \n impl fmt::Show for clean::Generics {\n-    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) {\n-        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return }\n-        f.buf.write(\"&lt;\".as_bytes());\n+    fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) -> fmt::Result {\n+        if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return Ok(()) }\n+        if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n \n         for (i, life) in g.lifetimes.iter().enumerate() {\n-            if i > 0 { f.buf.write(\", \".as_bytes()); }\n-            write!(f.buf, \"{}\", *life);\n+            if i > 0 {\n+                if_ok!(f.buf.write(\", \".as_bytes()));\n+            }\n+            if_ok!(write!(f.buf, \"{}\", *life));\n         }\n \n         if g.type_params.len() > 0 {\n-            if g.lifetimes.len() > 0 { f.buf.write(\", \".as_bytes()); }\n+            if g.lifetimes.len() > 0 {\n+                if_ok!(f.buf.write(\", \".as_bytes()));\n+            }\n \n             for (i, tp) in g.type_params.iter().enumerate() {\n-                if i > 0 { f.buf.write(\", \".as_bytes()) }\n-                f.buf.write(tp.name.as_bytes());\n+                if i > 0 {\n+                    if_ok!(f.buf.write(\", \".as_bytes()))\n+                }\n+                if_ok!(f.buf.write(tp.name.as_bytes()));\n \n                 if tp.bounds.len() > 0 {\n-                    f.buf.write(\": \".as_bytes());\n+                    if_ok!(f.buf.write(\": \".as_bytes()));\n                     for (i, bound) in tp.bounds.iter().enumerate() {\n-                        if i > 0 { f.buf.write(\" + \".as_bytes()); }\n-                        write!(f.buf, \"{}\", *bound);\n+                        if i > 0 {\n+                            if_ok!(f.buf.write(\" + \".as_bytes()));\n+                        }\n+                        if_ok!(write!(f.buf, \"{}\", *bound));\n                     }\n                 }\n             }\n         }\n-        f.buf.write(\"&gt;\".as_bytes());\n+        if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n+        Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n-    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) {\n-        f.buf.write(\"'\".as_bytes());\n-        f.buf.write(l.get_ref().as_bytes());\n+    fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(f.buf.write(\"'\".as_bytes()));\n+        if_ok!(f.buf.write(l.get_ref().as_bytes()));\n+        Ok(())\n     }\n }\n \n impl fmt::Show for clean::TyParamBound {\n-    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) {\n+    fn fmt(bound: &clean::TyParamBound, f: &mut fmt::Formatter) -> fmt::Result {\n         match *bound {\n             clean::RegionBound => {\n                 f.buf.write(\"'static\".as_bytes())\n             }\n             clean::TraitBound(ref ty) => {\n-                write!(f.buf, \"{}\", *ty);\n+                write!(f.buf, \"{}\", *ty)\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::Path {\n-    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) {\n-        if path.global { f.buf.write(\"::\".as_bytes()) }\n+    fn fmt(path: &clean::Path, f: &mut fmt::Formatter) -> fmt::Result {\n+        if path.global {\n+            if_ok!(f.buf.write(\"::\".as_bytes()))\n+        }\n         for (i, seg) in path.segments.iter().enumerate() {\n-            if i > 0 { f.buf.write(\"::\".as_bytes()) }\n-            f.buf.write(seg.name.as_bytes());\n+            if i > 0 {\n+                if_ok!(f.buf.write(\"::\".as_bytes()))\n+            }\n+            if_ok!(f.buf.write(seg.name.as_bytes()));\n \n             if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n-                f.buf.write(\"&lt;\".as_bytes());\n+                if_ok!(f.buf.write(\"&lt;\".as_bytes()));\n                 let mut comma = false;\n                 for lifetime in seg.lifetimes.iter() {\n-                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    if comma {\n+                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                    }\n                     comma = true;\n-                    write!(f.buf, \"{}\", *lifetime);\n+                    if_ok!(write!(f.buf, \"{}\", *lifetime));\n                 }\n                 for ty in seg.types.iter() {\n-                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    if comma {\n+                        if_ok!(f.buf.write(\", \".as_bytes()));\n+                    }\n                     comma = true;\n-                    write!(f.buf, \"{}\", *ty);\n+                    if_ok!(write!(f.buf, \"{}\", *ty));\n                 }\n-                f.buf.write(\"&gt;\".as_bytes());\n+                if_ok!(f.buf.write(\"&gt;\".as_bytes()));\n             }\n         }\n+        Ok(())\n     }\n }\n \n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n-                 print_all: bool) {\n+                 print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n         |_cache, loc| { Some(\"../\".repeat(loc.len())) },\n         |cache| {\n             match cache.paths.find(&id) {\n                 None => None,\n                 Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n             }\n-        });\n+        })\n }\n \n /// Used when rendering an `ExternalPath` structure. Like `resolved_path` this\n /// will invoke `path` with proper linking-style arguments.\n fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n-                 fqn: &[~str], kind: clean::TypeKind, crate: ast::CrateNum) {\n+                 fqn: &[~str], kind: clean::TypeKind,\n+                 crate: ast::CrateNum) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n             match *cache.extern_locations.get(&crate) {\n@@ -161,7 +181,9 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         root: |&render::Cache, &[~str]| -> Option<~str>,\n-        info: |&render::Cache| -> Option<(~[~str], &'static str)>) {\n+        info: |&render::Cache| -> Option<(~[~str], &'static str)>)\n+    -> fmt::Result\n+{\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last().unwrap();\n@@ -200,20 +222,20 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         let mut root = root;\n                         for seg in path.segments.slice_to(amt).iter() {\n                             if \"super\" == seg.name || \"self\" == seg.name {\n-                                write!(w, \"{}::\", seg.name);\n+                                if_ok!(write!(w, \"{}::\", seg.name));\n                             } else {\n                                 root.push_str(seg.name);\n                                 root.push_str(\"/\");\n-                                write!(w, \"<a class='mod'\n-                                              href='{}index.html'>{}</a>::\",\n-                                       root,\n-                                       seg.name);\n+                                if_ok!(write!(w, \"<a class='mod'\n+                                                    href='{}index.html'>{}</a>::\",\n+                                              root,\n+                                              seg.name));\n                             }\n                         }\n                     }\n                     None => {\n                         for seg in path.segments.slice_to(amt).iter() {\n-                            write!(w, \"{}::\", seg.name);\n+                            if_ok!(write!(w, \"{}::\", seg.name));\n                         }\n                     }\n                 }\n@@ -241,51 +263,57 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                         }\n                     }\n \n-                    write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                           shortty, url, fqp.connect(\"::\"), last.name);\n+                    if_ok!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                                  shortty, url, fqp.connect(\"::\"), last.name));\n                 }\n \n                 _ => {\n-                    write!(w, \"{}\", last.name);\n+                    if_ok!(write!(w, \"{}\", last.name));\n                 }\n             }\n-            write!(w, \"{}\", generics);\n+            if_ok!(write!(w, \"{}\", generics));\n+            Ok(())\n         })\n     })\n }\n \n /// Helper to render type parameters\n-fn typarams(w: &mut io::Writer, typarams: &Option<~[clean::TyParamBound]>) {\n+fn typarams(w: &mut io::Writer,\n+            typarams: &Option<~[clean::TyParamBound]>) -> fmt::Result {\n     match *typarams {\n         Some(ref params) => {\n-            write!(w, \"&lt;\");\n+            if_ok!(write!(w, \"&lt;\"));\n             for (i, param) in params.iter().enumerate() {\n-                if i > 0 { write!(w, \", \"); }\n-                write!(w, \"{}\", *param);\n+                if i > 0 {\n+                    if_ok!(write!(w, \", \"));\n+                }\n+                if_ok!(write!(w, \"{}\", *param));\n             }\n-            write!(w, \"&gt;\");\n+            if_ok!(write!(w, \"&gt;\"));\n+            Ok(())\n         }\n-        None => {}\n+        None => Ok(())\n     }\n }\n \n impl fmt::Show for clean::Type {\n-    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) {\n+    fn fmt(g: &clean::Type, f: &mut fmt::Formatter) -> fmt::Result {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n                     let m = cache.unwrap().get();\n-                    f.buf.write(m.typarams.get(&id).as_bytes());\n+                    f.buf.write(m.typarams.get(&id).as_bytes())\n                 })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n-                resolved_path(f.buf, id, path, false);\n-                typarams(f.buf, tp);\n+                if_ok!(resolved_path(f.buf, id, path, false));\n+                typarams(f.buf, tp)\n             }\n             clean::ExternalPath{path: ref path, typarams: ref tp,\n                                 fqn: ref fqn, kind, crate} => {\n-                external_path(f.buf, path, false, fqn.as_slice(), kind, crate);\n-                typarams(f.buf, tp);\n+                if_ok!(external_path(f.buf, path, false, fqn.as_slice(), kind,\n+                                     crate))\n+                typarams(f.buf, tp)\n             }\n             clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n@@ -306,7 +334,7 @@ impl fmt::Show for clean::Type {\n                     ast::TyBool => \"bool\",\n                     ast::TyChar => \"char\",\n                 };\n-                f.buf.write(s.as_bytes());\n+                f.buf.write(s.as_bytes())\n             }\n             clean::Closure(ref decl) => {\n                 let region = match decl.region {\n@@ -322,7 +350,7 @@ impl fmt::Show for clean::Type {\n                            ast::ManagedSigil => format!(\"@{}fn({})\", region, decl.decl.inputs),\n                        },\n                        arrow = match decl.decl.output { clean::Unit => \"no\", _ => \"yes\" },\n-                       ret = decl.decl.output);\n+                       ret = decl.decl.output)\n                 // FIXME: where are bounds and lifetimes printed?!\n             }\n             clean::BareFunction(ref decl) => {\n@@ -333,19 +361,21 @@ impl fmt::Show for clean::Type {\n                            ref s => \" \" + *s + \" \",\n                        },\n                        decl.generics,\n-                       decl.decl);\n+                       decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                f.buf.write(\"(\".as_bytes());\n+                if_ok!(f.buf.write(\"(\".as_bytes()));\n                 for (i, typ) in typs.iter().enumerate() {\n-                    if i > 0 { f.buf.write(\", \".as_bytes()) }\n-                    write!(f.buf, \"{}\", *typ);\n+                    if i > 0 {\n+                        if_ok!(f.buf.write(\", \".as_bytes()))\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", *typ));\n                 }\n-                f.buf.write(\")\".as_bytes());\n+                f.buf.write(\")\".as_bytes())\n             }\n             clean::Vector(ref t) => write!(f.buf, \"[{}]\", **t),\n             clean::FixedVector(ref t, ref s) => {\n-                write!(f.buf, \"[{}, ..{}]\", **t, *s);\n+                write!(f.buf, \"[{}, ..{}]\", **t, *s)\n             }\n             clean::String => f.buf.write(\"str\".as_bytes()),\n             clean::Bool => f.buf.write(\"bool\".as_bytes()),\n@@ -368,23 +398,23 @@ impl fmt::Show for clean::Type {\n                            clean::Mutable => \"mut \",\n                            clean::Immutable => \"\",\n                        },\n-                       **ty);\n+                       **ty)\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::FnDecl {\n-    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) {\n+    fn fmt(d: &clean::FnDecl, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = d.inputs,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output);\n+               ret = d.output)\n     }\n }\n \n impl fmt::Show for ~[clean::Argument] {\n-    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) {\n+    fn fmt(inputs: &~[clean::Argument], f: &mut fmt::Formatter) -> fmt::Result {\n         let mut args = ~\"\";\n         for (i, input) in inputs.iter().enumerate() {\n             if i > 0 { args.push_str(\", \"); }\n@@ -393,12 +423,12 @@ impl fmt::Show for ~[clean::Argument] {\n             }\n             args.push_str(format!(\"{}\", input.type_));\n         }\n-        f.buf.write(args.as_bytes());\n+        f.buf.write(args.as_bytes())\n     }\n }\n \n impl<'a> fmt::Show for Method<'a> {\n-    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) {\n+    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *m;\n         let mut args = ~\"\";\n         match *selfty {\n@@ -429,74 +459,79 @@ impl<'a> fmt::Show for Method<'a> {\n         write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n-               ret = d.output);\n+               ret = d.output)\n     }\n }\n \n impl fmt::Show for VisSpace {\n-    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) {\n+    fn fmt(v: &VisSpace, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.get() {\n-            Some(ast::Public) => { write!(f.buf, \"pub \"); }\n-            Some(ast::Private) => { write!(f.buf, \"priv \"); }\n-            Some(ast::Inherited) | None => {}\n+            Some(ast::Public) => write!(f.buf, \"pub \"),\n+            Some(ast::Private) => write!(f.buf, \"priv \"),\n+            Some(ast::Inherited) | None => Ok(())\n         }\n     }\n }\n \n impl fmt::Show for PuritySpace {\n-    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) {\n+    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) -> fmt::Result {\n         match p.get() {\n             ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n             ast::ExternFn => write!(f.buf, \"extern \"),\n-            ast::ImpureFn => {}\n+            ast::ImpureFn => Ok(())\n         }\n     }\n }\n \n impl fmt::Show for clean::ViewPath {\n-    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) -> fmt::Result {\n         match *v {\n             clean::SimpleImport(ref name, ref src) => {\n                 if *name == src.path.segments.last().unwrap().name {\n-                    write!(f.buf, \"use {};\", *src);\n+                    write!(f.buf, \"use {};\", *src)\n                 } else {\n-                    write!(f.buf, \"use {} = {};\", *name, *src);\n+                    write!(f.buf, \"use {} = {};\", *name, *src)\n                 }\n             }\n             clean::GlobImport(ref src) => {\n-                write!(f.buf, \"use {}::*;\", *src);\n+                write!(f.buf, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                write!(f.buf, \"use {}::\\\\{\", *src);\n+                if_ok!(write!(f.buf, \"use {}::\\\\{\", *src));\n                 for (i, n) in names.iter().enumerate() {\n-                    if i > 0 { write!(f.buf, \", \"); }\n-                    write!(f.buf, \"{}\", *n);\n+                    if i > 0 {\n+                        if_ok!(write!(f.buf, \", \"));\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", *n));\n                 }\n-                write!(f.buf, \"\\\\};\");\n+                write!(f.buf, \"\\\\};\")\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::ImportSource {\n-    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.did {\n             // FIXME: shouldn't be restricted to just local imports\n             Some(did) if ast_util::is_local(did) => {\n-                resolved_path(f.buf, did.node, &v.path, true);\n+                resolved_path(f.buf, did.node, &v.path, true)\n             }\n             _ => {\n                 for (i, seg) in v.path.segments.iter().enumerate() {\n-                    if i > 0 { write!(f.buf, \"::\") }\n-                    write!(f.buf, \"{}\", seg.name);\n+                    if i > 0 {\n+                        if_ok!(write!(f.buf, \"::\"))\n+                    }\n+                    if_ok!(write!(f.buf, \"{}\", seg.name));\n                 }\n+                Ok(())\n             }\n         }\n     }\n }\n \n impl fmt::Show for clean::ViewListIdent {\n-    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n+    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) -> fmt::Result {\n         match v.source {\n             // FIXME: shouldn't be limited to just local imports\n             Some(did) if ast_util::is_local(did) => {\n@@ -508,7 +543,7 @@ impl fmt::Show for clean::ViewListIdent {\n                         types: ~[],\n                     }]\n                 };\n-                resolved_path(f.buf, did.node, &path, false);\n+                resolved_path(f.buf, did.node, &path, false)\n             }\n             _ => write!(f.buf, \"{}\", v.name),\n         }"}, {"sha": "db7c882ab4203a0e5e60be2881c039a05edfaae8", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -26,6 +26,7 @@ pub struct Page<'a> {\n \n pub fn render<T: fmt::Show, S: fmt::Show>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n+    -> fmt::Result\n {\n     write!(dst,\n \"<!DOCTYPE html>\n@@ -121,7 +122,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n     favicon   = nonestr(layout.favicon),\n     sidebar   = *sidebar,\n     crate     = layout.crate,\n-    );\n+    )\n }\n \n fn nonestr<'a>(s: &'a str) -> &'a str {"}, {"sha": "c2203a352c53f5202fcd8f5b053c800437f0acac", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -109,7 +109,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-pub fn render(w: &mut io::Writer, s: &str) {\n+pub fn render(w: &mut io::Writer, s: &str) -> fmt::Result {\n     extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n         unsafe {\n             let my_opaque: &my_opaque = cast::transmute(opaque);\n@@ -159,11 +159,12 @@ pub fn render(w: &mut io::Writer, s: &str) {\n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n-        vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n-            w.write(buf);\n+        let ret = vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n+            w.write(buf)\n         });\n \n         bufrelease(ob);\n+        ret\n     }\n }\n \n@@ -210,10 +211,10 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n }\n \n impl<'a> fmt::Show for Markdown<'a> {\n-    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *md;\n         // This is actually common enough to special-case\n-        if md.len() == 0 { return; }\n-        render(fmt.buf, md.as_slice());\n+        if md.len() == 0 { return Ok(()) }\n+        render(fmt.buf, md.as_slice())\n     }\n }"}, {"sha": "65696528a6fa1cab4ae0603a410dcfeb165a169d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 342, "deletions": 310, "changes": 652, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -195,7 +195,7 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut crate: clean::Crate, dst: Path) {\n+pub fn run(mut crate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: ~[],\n@@ -208,7 +208,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         },\n         include_sources: true,\n     };\n-    mkdir(&cx.dst);\n+    if_ok!(mkdir(&cx.dst));\n \n     match crate.module.as_ref().map(|m| m.doc_list().unwrap_or(&[])) {\n         Some(attrs) => {\n@@ -248,47 +248,55 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n \n     // Add all the static files\n     let mut dst = cx.dst.join(crate.name.as_slice());\n-    mkdir(&dst);\n-    write(dst.join(\"jquery.js\"), include_str!(\"static/jquery-2.0.3.min.js\"));\n-    write(dst.join(\"main.js\"), include_str!(\"static/main.js\"));\n-    write(dst.join(\"main.css\"), include_str!(\"static/main.css\"));\n-    write(dst.join(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n+    if_ok!(mkdir(&dst));\n+    if_ok!(write(dst.join(\"jquery.js\"),\n+                 include_str!(\"static/jquery-2.0.3.min.js\")));\n+    if_ok!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n+    if_ok!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n+    if_ok!(write(dst.join(\"normalize.css\"),\n+                 include_str!(\"static/normalize.css\")));\n \n     // Publish the search index\n     {\n         dst.push(\"search-index.js\");\n         let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n         let w = &mut w as &mut Writer;\n-        write!(w, \"var searchIndex = [\");\n+        if_ok!(write!(w, \"var searchIndex = [\"));\n         for (i, item) in cache.search_index.iter().enumerate() {\n-            if i > 0 { write!(w, \",\"); }\n-            write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n-                   item.ty, item.name, item.path,\n-                   item.desc.to_json().to_str())\n+            if i > 0 {\n+                if_ok!(write!(w, \",\"));\n+            }\n+            if_ok!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n+                          item.ty, item.name, item.path,\n+                          item.desc.to_json().to_str()));\n             match item.parent {\n-                Some(id) => { write!(w, \",parent:'{}'\", id); }\n+                Some(id) => {\n+                    if_ok!(write!(w, \",parent:'{}'\", id));\n+                }\n                 None => {}\n             }\n-            write!(w, \"\\\\}\");\n+            if_ok!(write!(w, \"\\\\}\"));\n         }\n-        write!(w, \"];\");\n-        write!(w, \"var allPaths = \\\\{\");\n+        if_ok!(write!(w, \"];\"));\n+        if_ok!(write!(w, \"var allPaths = \\\\{\"));\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n-            if i > 0 { write!(w, \",\"); }\n-            write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                   id, short, *fqp.last().unwrap());\n+            if i > 0 {\n+                if_ok!(write!(w, \",\"));\n+            }\n+            if_ok!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+                          id, short, *fqp.last().unwrap()));\n         }\n-        write!(w, \"\\\\};\");\n-        w.flush();\n+        if_ok!(write!(w, \"\\\\};\"));\n+        if_ok!(w.flush());\n     }\n \n     // Render all source files (this may turn into a giant no-op)\n     {\n         info!(\"emitting source files\");\n         let dst = cx.dst.join(\"src\");\n-        mkdir(&dst);\n+        if_ok!(mkdir(&dst));\n         let dst = dst.join(crate.name.as_slice());\n-        mkdir(&dst);\n+        if_ok!(mkdir(&dst));\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n@@ -302,27 +310,23 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     }\n \n     // And finally render the whole crate's documentation\n-    cx.crate(crate, cache);\n+    cx.crate(crate, cache)\n }\n \n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n-fn write(dst: Path, contents: &str) {\n-    File::create(&dst).write(contents.as_bytes());\n+fn write(dst: Path, contents: &str) -> io::IoResult<()> {\n+    File::create(&dst).write(contents.as_bytes())\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n-fn mkdir(path: &Path) {\n-    io::io_error::cond.trap(|err| {\n-        error!(\"Couldn't create directory `{}`: {}\",\n-                path.display(), err.desc);\n-        fail!()\n-    }).inside(|| {\n-        if !path.is_dir() {\n-            fs::mkdir(path, io::UserRWX);\n-        }\n-    })\n+fn mkdir(path: &Path) -> io::IoResult<()> {\n+    if !path.exists() {\n+        fs::mkdir(path, io::UserRWX)\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n@@ -387,15 +391,17 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx.include_sources = self.emit_source(item.source.filename);\n+            self.cx.include_sources = match self.emit_source(item.source.filename) {\n+                Ok(()) => true,\n+                Err(e) => {\n+                    println!(\"warning: source code was requested to be rendered, \\\n+                              but processing `{}` had an error: {}\",\n+                             item.source.filename, e);\n+                    println!(\"         skipping rendering of source code\");\n+                    false\n+                }\n+            };\n             self.seen.insert(item.source.filename.clone());\n-\n-            if !self.cx.include_sources {\n-                println!(\"warning: source code was requested to be rendered, \\\n-                          but `{}` is a missing source file.\",\n-                         item.source.filename);\n-                println!(\"         skipping rendering of source code\");\n-            }\n         }\n \n         self.fold_item_recur(item)\n@@ -404,54 +410,42 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &str) -> bool {\n+    fn emit_source(&mut self, filename: &str) -> io::IoResult<()> {\n         let p = Path::new(filename);\n \n-        // Read the contents of the file\n-        let mut contents = ~[];\n-        {\n-            let mut buf = [0, ..1024];\n-            // If we couldn't open this file, then just returns because it\n-            // probably means that it's some standard library macro thing and we\n-            // can't have the source to it anyway.\n-            let mut r = match io::result(|| File::open(&p)) {\n-                Ok(r) => r,\n-                // eew macro hacks\n-                Err(..) => return filename == \"<std-macros>\"\n-            };\n-\n-            // read everything\n-            loop {\n-                match r.read(buf) {\n-                    Some(n) => contents.push_all(buf.slice_to(n)),\n-                    None => break\n-                }\n-            }\n-        }\n+        // If we couldn't open this file, then just returns because it\n+        // probably means that it's some standard library macro thing and we\n+        // can't have the source to it anyway.\n+        let contents = match File::open(&p).read_to_end() {\n+            Ok(r) => r,\n+            // eew macro hacks\n+            Err(..) if filename == \"<std-macros>\" => return Ok(()),\n+            Err(e) => return Err(e)\n+        };\n         let contents = str::from_utf8_owned(contents).unwrap();\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n         clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n-            mkdir(&cur);\n+            mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n         });\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n-        let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n+        let mut w = BufferedWriter::new(if_ok!(File::create(&cur)));\n \n         let title = cur.filename_display().with_str(|s| format!(\"{} -- source\", s));\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n             root_path: root_path,\n         };\n-        layout::render(&mut w as &mut Writer, &self.cx.layout,\n-                       &page, &(\"\"), &Source(contents.as_slice()));\n-        w.flush();\n-        return true;\n+        if_ok!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n+                              &page, &(\"\"), &Source(contents.as_slice())));\n+        if_ok!(w.flush());\n+        return Ok(());\n     }\n }\n \n@@ -665,7 +659,7 @@ impl Context {\n \n         info!(\"Recursing into {}\", self.dst.display());\n \n-        mkdir(&self.dst);\n+        mkdir(&self.dst).unwrap();\n         let ret = f(self);\n \n         info!(\"Recursed; leaving {}\", self.dst.display());\n@@ -683,10 +677,10 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn crate(self, mut crate: clean::Crate, cache: Cache) {\n+    fn crate(self, mut crate: clean::Crate, cache: Cache) -> io::IoResult<()> {\n         let mut item = match crate.module.take() {\n             Some(i) => i,\n-            None => return\n+            None => return Ok(())\n         };\n         item.name = Some(crate.name);\n \n@@ -696,22 +690,24 @@ impl Context {\n         let mut work = ~[(self, item)];\n         loop {\n             match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n+                Some((mut cx, item)) => if_ok!(cx.item(item, |cx, item| {\n                     work.push((cx.clone(), item));\n-                }),\n+                })),\n                 None => break,\n             }\n         }\n+        Ok(())\n     }\n \n     /// Non-parellelized version of rendering an item. This will take the input\n     /// item, render its contents, and then invoke the specified closure with\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item(&mut self, item: clean::Item, f: |&mut Context, clean::Item|) {\n+    fn item(&mut self, item: clean::Item,\n+            f: |&mut Context, clean::Item|) -> io::IoResult<()> {\n         fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n-                  pushname: bool) {\n+                  pushname: bool) -> io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n@@ -733,10 +729,10 @@ impl Context {\n             // of the pain by using a buffered writer instead of invoking the\n             // write sycall all the time.\n             let mut writer = BufferedWriter::new(w);\n-            layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n-                           &Sidebar{ cx: cx, item: it },\n-                           &Item{ cx: cx, item: it });\n-            writer.flush();\n+            if_ok!(layout::render(&mut writer as &mut Writer, &cx.layout, &page,\n+                                  &Sidebar{ cx: cx, item: it },\n+                                  &Item{ cx: cx, item: it }));\n+            writer.flush()\n         }\n \n         match item.inner {\n@@ -748,7 +744,8 @@ impl Context {\n                 self.recurse(name, |this| {\n                     let item = item.take_unwrap();\n                     let dst = this.dst.join(\"index.html\");\n-                    render(File::create(&dst).unwrap(), this, &item, false);\n+                    let dst = if_ok!(File::create(&dst));\n+                    if_ok!(render(dst, this, &item, false));\n \n                     let m = match item.inner {\n                         clean::ModuleItem(m) => m,\n@@ -758,17 +755,19 @@ impl Context {\n                     for item in m.items.move_iter() {\n                         f(this,item);\n                     }\n+                    Ok(())\n                 })\n             }\n \n             // Things which don't have names (like impls) don't get special\n             // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.join(item_path(&item));\n-                render(File::create(&dst).unwrap(), self, &item, true);\n+                let dst = if_ok!(File::create(&dst));\n+                render(dst, self, &item, true)\n             }\n \n-            _ => {}\n+            _ => Ok(())\n         }\n     }\n }\n@@ -802,16 +801,16 @@ impl<'a> Item<'a> {\n }\n \n impl<'a> fmt::Show for Item<'a> {\n-    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match attr::find_stability(it.item.attrs.iter()) {\n             Some(ref stability) => {\n-                write!(fmt.buf,\n+                if_ok!(write!(fmt.buf,\n                        \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n                        lvl = stability.level.to_str(),\n                        reason = match stability.text {\n                            Some(ref s) => (*s).clone(),\n                            None => InternedString::new(\"\"),\n-                       });\n+                       }));\n             }\n             None => {}\n         }\n@@ -826,23 +825,24 @@ impl<'a> fmt::Show for Item<'a> {\n             } else {\n                 format!(\"{}-{}\", it.item.source.loline, it.item.source.hiline)\n             };\n-            write!(fmt.buf,\n-                   \"<a class='source'\n-                       href='{root}src/{crate}/{path}.html\\\\#{href}'>[src]</a>\",\n-                   root = it.cx.root_path,\n-                   crate = it.cx.layout.crate,\n-                   path = path.connect(\"/\"),\n-                   href = href);\n+            if_ok!(write!(fmt.buf,\n+                          \"<a class='source'\n+                              href='{root}src/{crate}/{path}.html\\\\#{href}'>\\\n+                              [src]</a>\",\n+                          root = it.cx.root_path,\n+                          crate = it.cx.layout.crate,\n+                          path = path.connect(\"/\"),\n+                          href = href));\n         }\n \n         // Write the breadcrumb trail header for the top\n-        write!(fmt.buf, \"<h1 class='fqn'>\");\n+        if_ok!(write!(fmt.buf, \"<h1 class='fqn'>\"));\n         match it.item.inner {\n-            clean::ModuleItem(..) => write!(fmt.buf, \"Module \"),\n-            clean::FunctionItem(..) => write!(fmt.buf, \"Function \"),\n-            clean::TraitItem(..) => write!(fmt.buf, \"Trait \"),\n-            clean::StructItem(..) => write!(fmt.buf, \"Struct \"),\n-            clean::EnumItem(..) => write!(fmt.buf, \"Enum \"),\n+            clean::ModuleItem(..) => if_ok!(write!(fmt.buf, \"Module \")),\n+            clean::FunctionItem(..) => if_ok!(write!(fmt.buf, \"Function \")),\n+            clean::TraitItem(..) => if_ok!(write!(fmt.buf, \"Trait \")),\n+            clean::StructItem(..) => if_ok!(write!(fmt.buf, \"Struct \")),\n+            clean::EnumItem(..) => if_ok!(write!(fmt.buf, \"Enum \")),\n             _ => {}\n         }\n         let cur = it.cx.current.as_slice();\n@@ -852,11 +852,11 @@ impl<'a> fmt::Show for Item<'a> {\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n-            write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n-                   trail, component.as_slice());\n+            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>::\",\n+                          trail, component.as_slice()));\n         }\n-        write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n-               shortty(it.item), it.item.name.get_ref().as_slice());\n+        if_ok!(write!(fmt.buf, \"<a class='{}' href=''>{}</a></h1>\",\n+                      shortty(it.item), it.item.name.get_ref().as_slice()));\n \n         match it.item.inner {\n             clean::ModuleItem(ref m) => item_module(fmt.buf, it.cx,\n@@ -867,7 +867,7 @@ impl<'a> fmt::Show for Item<'a> {\n             clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n-            _ => {}\n+            _ => Ok(())\n         }\n     }\n }\n@@ -903,18 +903,19 @@ fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     }\n }\n \n-fn document(w: &mut Writer, item: &clean::Item) {\n+fn document(w: &mut Writer, item: &clean::Item) -> fmt::Result {\n     match item.doc_value() {\n         Some(s) => {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n+            if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n         }\n         None => {}\n     }\n+    Ok(())\n }\n \n fn item_module(w: &mut Writer, cx: &Context,\n-               item: &clean::Item, items: &[clean::Item]) {\n-    document(w, item);\n+               item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n+    if_ok!(document(w, item));\n     debug!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n@@ -965,10 +966,10 @@ fn item_module(w: &mut Writer, cx: &Context,\n         let myty = shortty(myitem);\n         if myty != curty {\n             if curty != \"\" {\n-                write!(w, \"</table>\");\n+                if_ok!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n-            write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n+            if_ok!(write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n                 clean::ModuleItem(..)          => \"Modules\",\n                 clean::StructItem(..)          => \"Structs\",\n                 clean::EnumItem(..)            => \"Enums\",\n@@ -984,24 +985,26 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 clean::VariantItem(..)         => \"Variants\",\n                 clean::ForeignFunctionItem(..) => \"Foreign Functions\",\n                 clean::ForeignStaticItem(..)   => \"Foreign Statics\",\n-            });\n+            }));\n         }\n \n         match myitem.inner {\n             clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n                 struct Initializer<'a>(&'a str);\n                 impl<'a> fmt::Show for Initializer<'a> {\n-                    fn fmt(s: &Initializer<'a>, f: &mut fmt::Formatter) {\n+                    fn fmt(s: &Initializer<'a>,\n+                           f: &mut fmt::Formatter) -> fmt::Result {\n                         let Initializer(s) = *s;\n-                        if s.len() == 0 { return; }\n-                        write!(f.buf, \"<code> = </code>\");\n+                        if s.len() == 0 { return Ok(()); }\n+                        if_ok!(write!(f.buf, \"<code> = </code>\"));\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n-                        write!(f.buf, \"<{tag}>{}</{tag}>\",\n-                               s.as_slice(), tag=tag);\n+                        if_ok!(write!(f.buf, \"<{tag}>{}</{tag}>\",\n+                                      s.as_slice(), tag=tag));\n+                        Ok(())\n                     }\n                 }\n \n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <tr>\n                         <td><code>{}static {}: {}</code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n@@ -1011,27 +1014,27 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 *myitem.name.get_ref(),\n                 s.type_,\n                 Initializer(s.expr),\n-                Markdown(blank(myitem.doc_value())));\n+                Markdown(blank(myitem.doc_value()))));\n             }\n \n             clean::ViewItemItem(ref item) => {\n                 match item.inner {\n                     clean::ExternMod(ref name, ref src, _) => {\n-                        write!(w, \"<tr><td><code>extern mod {}\",\n-                               name.as_slice());\n+                        if_ok!(write!(w, \"<tr><td><code>extern mod {}\",\n+                                      name.as_slice()));\n                         match *src {\n-                            Some(ref src) => write!(w, \" = \\\"{}\\\"\",\n-                                                    src.as_slice()),\n+                            Some(ref src) => if_ok!(write!(w, \" = \\\"{}\\\"\",\n+                                                           src.as_slice())),\n                             None => {}\n                         }\n-                        write!(w, \";</code></td></tr>\");\n+                        if_ok!(write!(w, \";</code></td></tr>\"));\n                     }\n \n                     clean::Import(ref imports) => {\n                         for import in imports.iter() {\n-                            write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                                   VisSpace(myitem.visibility),\n-                                   *import);\n+                            if_ok!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                                          VisSpace(myitem.visibility),\n+                                          *import));\n                         }\n                     }\n                 }\n@@ -1040,7 +1043,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <tr>\n                         <td><a class='{class}' href='{href}'\n                                title='{title}'>{}</a></td>\n@@ -1051,24 +1054,26 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem));\n+                title = full_path(cx, myitem)));\n             }\n         }\n     }\n-    write!(w, \"</table>\");\n+    write!(w, \"</table>\")\n }\n \n-fn item_function(w: &mut Writer, it: &clean::Item, f: &clean::Function) {\n-    write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n+fn item_function(w: &mut Writer, it: &clean::Item,\n+                 f: &clean::Function) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n            purity = PuritySpace(f.purity),\n            name = it.name.get_ref().as_slice(),\n            generics = f.generics,\n-           decl = f.decl);\n-    document(w, it);\n+           decl = f.decl));\n+    document(w, it)\n }\n \n-fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Writer, it: &clean::Item,\n+              t: &clean::Trait) -> fmt::Result {\n     let mut parents = ~\"\";\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n@@ -1079,99 +1084,102 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n \n     // Output the trait definition\n-    write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n-           VisSpace(it.visibility),\n-           it.name.get_ref().as_slice(),\n-           t.generics,\n-           parents);\n+    if_ok!(write!(w, \"<pre class='trait'>{}trait {}{}{} \",\n+                  VisSpace(it.visibility),\n+                  it.name.get_ref().as_slice(),\n+                  t.generics,\n+                  parents));\n     let required = t.methods.iter().filter(|m| m.is_req()).to_owned_vec();\n     let provided = t.methods.iter().filter(|m| !m.is_req()).to_owned_vec();\n \n     if t.methods.len() == 0 {\n-        write!(w, \"\\\\{ \\\\}\");\n+        if_ok!(write!(w, \"\\\\{ \\\\}\"));\n     } else {\n-        write!(w, \"\\\\{\\n\");\n+        if_ok!(write!(w, \"\\\\{\\n\"));\n         for m in required.iter() {\n-            write!(w, \"    \");\n-            render_method(w, m.item(), true);\n-            write!(w, \";\\n\");\n+            if_ok!(write!(w, \"    \"));\n+            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n-            w.write(\"\\n\".as_bytes());\n+            if_ok!(w.write(\"\\n\".as_bytes()));\n         }\n         for m in provided.iter() {\n-            write!(w, \"    \");\n-            render_method(w, m.item(), true);\n-            write!(w, \" \\\\{ ... \\\\}\\n\");\n+            if_ok!(write!(w, \"    \"));\n+            if_ok!(render_method(w, m.item(), true));\n+            if_ok!(write!(w, \" \\\\{ ... \\\\}\\n\"));\n         }\n-        write!(w, \"\\\\}\");\n+        if_ok!(write!(w, \"\\\\}\"));\n     }\n-    write!(w, \"</pre>\");\n+    if_ok!(write!(w, \"</pre>\"));\n \n     // Trait documentation\n-    document(w, it);\n-\n-    fn meth(w: &mut Writer, m: &clean::TraitMethod) {\n-        write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n-               shortty(m.item()),\n-               *m.item().name.get_ref());\n-        render_method(w, m.item(), false);\n-        write!(w, \"</code></h3>\");\n-        document(w, m.item());\n+    if_ok!(document(w, it));\n+\n+    fn meth(w: &mut Writer, m: &clean::TraitMethod) -> fmt::Result {\n+        if_ok!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n+                      shortty(m.item()),\n+                      *m.item().name.get_ref()));\n+        if_ok!(render_method(w, m.item(), false));\n+        if_ok!(write!(w, \"</code></h3>\"));\n+        if_ok!(document(w, m.item()));\n+        Ok(())\n     }\n \n     // Output the documentation for each function individually\n     if required.len() > 0 {\n-        write!(w, \"\n+        if_ok!(write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n-        \");\n+        \"));\n         for m in required.iter() {\n-            meth(w, *m);\n+            if_ok!(meth(w, *m));\n         }\n-        write!(w, \"</div>\");\n+        if_ok!(write!(w, \"</div>\"));\n     }\n     if provided.len() > 0 {\n-        write!(w, \"\n+        if_ok!(write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n-        \");\n+        \"));\n         for m in provided.iter() {\n-            meth(w, *m);\n+            if_ok!(meth(w, *m));\n         }\n-        write!(w, \"</div>\");\n+        if_ok!(write!(w, \"</div>\"));\n     }\n \n     local_data::get(cache_key, |cache| {\n         let cache = cache.unwrap().get();\n         match cache.implementors.find(&it.id) {\n             Some(implementors) => {\n-                write!(w, \"\n+                if_ok!(write!(w, \"\n                     <h2 id='implementors'>Implementors</h2>\n                     <ul class='item-list'>\n-                \");\n+                \"));\n                 for i in implementors.iter() {\n                     match *i {\n                         PathType(ref ty) => {\n-                            write!(w, \"<li><code>{}</code></li>\", *ty);\n+                            if_ok!(write!(w, \"<li><code>{}</code></li>\", *ty));\n                         }\n                         OtherType(ref generics, ref trait_, ref for_) => {\n-                            write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                   *generics, *trait_, *for_);\n+                            if_ok!(write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                                          *generics, *trait_, *for_));\n                         }\n                     }\n                 }\n-                write!(w, \"</ul>\");\n+                if_ok!(write!(w, \"</ul>\"));\n             }\n             None => {}\n         }\n+        Ok(())\n     })\n }\n \n-fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n+fn render_method(w: &mut Writer, meth: &clean::Item,\n+                 withlink: bool) -> fmt::Result {\n     fn fun(w: &mut Writer, it: &clean::Item, purity: ast::Purity,\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n-           withlink: bool) {\n+           withlink: bool) -> fmt::Result {\n         write!(w, \"{}fn {withlink, select,\n                             true{<a href='\\\\#{ty}.{name}'\n                                     class='fnname'>{name}</a>}\n@@ -1185,118 +1193,125 @@ fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n                name = it.name.get_ref().as_slice(),\n                generics = *g,\n                decl = Method(selfty, d),\n-               withlink = if withlink {\"true\"} else {\"false\"});\n+               withlink = if withlink {\"true\"} else {\"false\"})\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink);\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n         }\n         clean::MethodItem(ref m) => {\n-            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink);\n+            fun(w, meth, m.purity, &m.generics, &m.self_, &m.decl, withlink)\n         }\n         _ => unreachable!()\n     }\n }\n \n-fn item_struct(w: &mut Writer, it: &clean::Item, s: &clean::Struct) {\n-    write!(w, \"<pre class='struct'>\");\n-    render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n-                  s.fields_stripped, \"\", true);\n-    write!(w, \"</pre>\");\n+fn item_struct(w: &mut Writer, it: &clean::Item,\n+               s: &clean::Struct) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='struct'>\"));\n+    if_ok!(render_struct(w, it, Some(&s.generics), s.struct_type, s.fields,\n+                         s.fields_stripped, \"\", true));\n+    if_ok!(write!(w, \"</pre>\"));\n \n-    document(w, it);\n+    if_ok!(document(w, it));\n     match s.struct_type {\n         doctree::Plain if s.fields.len() > 0 => {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\");\n+            if_ok!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in s.fields.iter() {\n-                write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                <code>{name}</code></td><td>\",\n-                       name = field.name.get_ref().as_slice());\n-                document(w, field);\n-                write!(w, \"</td></tr>\");\n+                if_ok!(write!(w, \"<tr><td id='structfield.{name}'>\\\n+                                  <code>{name}</code></td><td>\",\n+                              name = field.name.get_ref().as_slice()));\n+                if_ok!(document(w, field));\n+                if_ok!(write!(w, \"</td></tr>\"));\n             }\n-            write!(w, \"</table>\");\n+            if_ok!(write!(w, \"</table>\"));\n         }\n         _ => {}\n     }\n-    render_methods(w, it);\n+    render_methods(w, it)\n }\n \n-fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) {\n-    write!(w, \"<pre class='enum'>{}enum {}{}\",\n-           VisSpace(it.visibility),\n-           it.name.get_ref().as_slice(),\n-           e.generics);\n+fn item_enum(w: &mut Writer, it: &clean::Item, e: &clean::Enum) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='enum'>{}enum {}{}\",\n+                  VisSpace(it.visibility),\n+                  it.name.get_ref().as_slice(),\n+                  e.generics));\n     if e.variants.len() == 0 && !e.variants_stripped {\n-        write!(w, \" \\\\{\\\\}\");\n+        if_ok!(write!(w, \" \\\\{\\\\}\"));\n     } else {\n-        write!(w, \" \\\\{\\n\");\n+        if_ok!(write!(w, \" \\\\{\\n\"));\n         for v in e.variants.iter() {\n-            write!(w, \"    \");\n+            if_ok!(write!(w, \"    \"));\n             let name = v.name.get_ref().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => write!(w, \"{}\", name),\n+                        clean::CLikeVariant => if_ok!(write!(w, \"{}\", name)),\n                         clean::TupleVariant(ref tys) => {\n-                            write!(w, \"{}(\", name);\n+                            if_ok!(write!(w, \"{}(\", name));\n                             for (i, ty) in tys.iter().enumerate() {\n-                                if i > 0 { write!(w, \", \") }\n-                                write!(w, \"{}\", *ty);\n+                                if i > 0 {\n+                                    if_ok!(write!(w, \", \"))\n+                                }\n+                                if_ok!(write!(w, \"{}\", *ty));\n                             }\n-                            write!(w, \")\");\n+                            if_ok!(write!(w, \")\"));\n                         }\n                         clean::StructVariant(ref s) => {\n-                            render_struct(w, v, None, s.struct_type, s.fields,\n-                                          s.fields_stripped, \"    \", false);\n+                            if_ok!(render_struct(w, v, None, s.struct_type,\n+                                                 s.fields, s.fields_stripped,\n+                                                 \"    \", false));\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n-            write!(w, \",\\n\");\n+            if_ok!(write!(w, \",\\n\"));\n         }\n \n         if e.variants_stripped {\n-            write!(w, \"    // some variants omitted\\n\");\n+            if_ok!(write!(w, \"    // some variants omitted\\n\"));\n         }\n-        write!(w, \"\\\\}\");\n+        if_ok!(write!(w, \"\\\\}\"));\n     }\n-    write!(w, \"</pre>\");\n+    if_ok!(write!(w, \"</pre>\"));\n \n-    document(w, it);\n+    if_ok!(document(w, it));\n     if e.variants.len() > 0 {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\");\n+        if_ok!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in e.variants.iter() {\n-            write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n-                   name = variant.name.get_ref().as_slice());\n-            document(w, variant);\n+            if_ok!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+                          name = variant.name.get_ref().as_slice()));\n+            if_ok!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n                         clean::StructVariant(ref s) => {\n-                            write!(w, \"<h3 class='fields'>Fields</h3>\\n<table>\");\n+                            if_ok!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                                              <table>\"));\n                             for field in s.fields.iter() {\n-                                write!(w, \"<tr><td id='variant.{v}.field.{f}'>\\\n-                                           <code>{f}</code></td><td>\",\n-                                       v = variant.name.get_ref().as_slice(),\n-                                       f = field.name.get_ref().as_slice());\n-                                document(w, field);\n-                                write!(w, \"</td></tr>\");\n+                                if_ok!(write!(w, \"<tr><td \\\n+                                                  id='variant.{v}.field.{f}'>\\\n+                                                  <code>{f}</code></td><td>\",\n+                                              v = variant.name.get_ref().as_slice(),\n+                                              f = field.name.get_ref().as_slice()));\n+                                if_ok!(document(w, field));\n+                                if_ok!(write!(w, \"</td></tr>\"));\n                             }\n-                            write!(w, \"</table>\");\n+                            if_ok!(write!(w, \"</table>\"));\n                         }\n                         _ => ()\n                     }\n                 }\n                 _ => ()\n             }\n-            write!(w, \"</td></tr>\");\n+            if_ok!(write!(w, \"</td></tr>\"));\n         }\n-        write!(w, \"</table>\");\n+        if_ok!(write!(w, \"</table>\"));\n \n     }\n-    render_methods(w, it);\n+    if_ok!(render_methods(w, it));\n+    Ok(())\n }\n \n fn render_struct(w: &mut Writer, it: &clean::Item,\n@@ -1305,54 +1320,59 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n                  fields: &[clean::Item],\n                  fields_stripped: bool,\n                  tab: &str,\n-                 structhead: bool) {\n-    write!(w, \"{}{}{}\",\n-           VisSpace(it.visibility),\n-           if structhead {\"struct \"} else {\"\"},\n-           it.name.get_ref().as_slice());\n+                 structhead: bool) -> fmt::Result {\n+    if_ok!(write!(w, \"{}{}{}\",\n+                  VisSpace(it.visibility),\n+                  if structhead {\"struct \"} else {\"\"},\n+                  it.name.get_ref().as_slice()));\n     match g {\n-        Some(g) => write!(w, \"{}\", *g),\n+        Some(g) => if_ok!(write!(w, \"{}\", *g)),\n         None => {}\n     }\n     match ty {\n         doctree::Plain => {\n-            write!(w, \" \\\\{\\n{}\", tab);\n+            if_ok!(write!(w, \" \\\\{\\n{}\", tab));\n             for field in fields.iter() {\n                 match field.inner {\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"    {}{}: {},\\n{}\",\n-                               VisSpace(field.visibility),\n-                               field.name.get_ref().as_slice(),\n-                               ty.type_,\n-                               tab);\n+                        if_ok!(write!(w, \"    {}{}: {},\\n{}\",\n+                                      VisSpace(field.visibility),\n+                                      field.name.get_ref().as_slice(),\n+                                      ty.type_,\n+                                      tab));\n                     }\n                     _ => unreachable!()\n                 }\n             }\n \n             if fields_stripped {\n-                write!(w, \"    // some fields omitted\\n{}\", tab);\n+                if_ok!(write!(w, \"    // some fields omitted\\n{}\", tab));\n             }\n-            write!(w, \"\\\\}\");\n+            if_ok!(write!(w, \"\\\\}\"));\n         }\n         doctree::Tuple | doctree::Newtype => {\n-            write!(w, \"(\");\n+            if_ok!(write!(w, \"(\"));\n             for (i, field) in fields.iter().enumerate() {\n-                if i > 0 { write!(w, \", \") }\n+                if i > 0 {\n+                    if_ok!(write!(w, \", \"));\n+                }\n                 match field.inner {\n                     clean::StructFieldItem(ref field) => {\n-                        write!(w, \"{}\", field.type_);\n+                        if_ok!(write!(w, \"{}\", field.type_));\n                     }\n                     _ => unreachable!()\n                 }\n             }\n-            write!(w, \");\");\n+            if_ok!(write!(w, \");\"));\n+        }\n+        doctree::Unit => {\n+            if_ok!(write!(w, \";\"));\n         }\n-        doctree::Unit => { write!(w, \";\"); }\n     }\n+    Ok(())\n }\n \n-fn render_methods(w: &mut Writer, it: &clean::Item) {\n+fn render_methods(w: &mut Writer, it: &clean::Item) -> fmt::Result {\n     local_data::get(cache_key, |cache| {\n         let c = cache.unwrap().get();\n         match c.impls.find(&it.id) {\n@@ -1367,62 +1387,64 @@ fn render_methods(w: &mut Writer, it: &clean::Item) {\n                 let traits = traits.to_owned_vec();\n \n                 if non_trait.len() > 0 {\n-                    write!(w, \"<h2 id='methods'>Methods</h2>\");\n+                    if_ok!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                     for &(ref i, ref dox) in non_trait.move_iter() {\n-                        render_impl(w, i, dox);\n+                        if_ok!(render_impl(w, i, dox));\n                     }\n                 }\n                 if traits.len() > 0 {\n-                    write!(w, \"<h2 id='implementations'>Trait \\\n-                               Implementations</h2>\");\n+                    if_ok!(write!(w, \"<h2 id='implementations'>Trait \\\n+                                      Implementations</h2>\"));\n                     for &(ref i, ref dox) in traits.move_iter() {\n-                        render_impl(w, i, dox);\n+                        if_ok!(render_impl(w, i, dox));\n                     }\n                 }\n             }\n             None => {}\n         }\n+        Ok(())\n     })\n }\n \n-fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n-    write!(w, \"<h3 class='impl'><code>impl{} \", i.generics);\n+fn render_impl(w: &mut Writer, i: &clean::Impl,\n+               dox: &Option<~str>) -> fmt::Result {\n+    if_ok!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n-            write!(w, \"{} for \", *ty);\n+            if_ok!(write!(w, \"{} for \", *ty));\n             match *ty {\n                 clean::ResolvedPath { id, .. } => Some(id),\n                 _ => None,\n             }\n         }\n         None => None\n     };\n-    write!(w, \"{}</code></h3>\", i.for_);\n+    if_ok!(write!(w, \"{}</code></h3>\", i.for_));\n     match *dox {\n         Some(ref dox) => {\n-            write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(dox.as_slice()));\n+            if_ok!(write!(w, \"<div class='docblock'>{}</div>\",\n+                          Markdown(dox.as_slice())));\n         }\n         None => {}\n     }\n \n-    fn docmeth(w: &mut Writer, item: &clean::Item) -> bool {\n-        write!(w, \"<h4 id='method.{}' class='method'><code>\",\n-               *item.name.get_ref());\n-        render_method(w, item, false);\n-        write!(w, \"</code></h4>\\n\");\n+    fn docmeth(w: &mut Writer, item: &clean::Item) -> io::IoResult<bool> {\n+        if_ok!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n+                      *item.name.get_ref()));\n+        if_ok!(render_method(w, item, false));\n+        if_ok!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n             Some(s) => {\n-                write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n-                true\n+                if_ok!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n+                Ok(true)\n             }\n-            None => false\n+            None => Ok(false)\n         }\n     }\n \n-    write!(w, \"<div class='methods'>\");\n+    if_ok!(write!(w, \"<div class='methods'>\"));\n     for meth in i.methods.iter() {\n-        if docmeth(w, meth) {\n+        if if_ok!(docmeth(w, meth)) {\n             continue\n         }\n \n@@ -1431,7 +1453,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             None => continue,\n             Some(id) => id,\n         };\n-        local_data::get(cache_key, |cache| {\n+        if_ok!(local_data::get(cache_key, |cache| {\n             let cache = cache.unwrap().get();\n             match cache.traits.find(&trait_id) {\n                 Some(t) => {\n@@ -1440,9 +1462,9 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                         Some(method) => {\n                             match method.item().doc_value() {\n                                 Some(s) => {\n-                                    write!(w,\n-                                           \"<div class='docblock'>{}</div>\",\n-                                           Markdown(s));\n+                                    if_ok!(write!(w,\n+                                                  \"<div class='docblock'>{}</div>\",\n+                                                  Markdown(s)));\n                                 }\n                                 None => {}\n                             }\n@@ -1452,15 +1474,16 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                 }\n                 None => {}\n             }\n-        })\n+            Ok(())\n+        }))\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            local_data::get(cache_key, |cache| {\n+            if_ok!(local_data::get(cache_key, |cache| {\n                 let cache = cache.unwrap().get();\n                 match cache.traits.find(&id) {\n                     Some(t) => {\n@@ -1471,50 +1494,56 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                                 None => {}\n                             }\n \n-                            docmeth(w, method.item());\n+                            if_ok!(docmeth(w, method.item()));\n                         }\n                     }\n                     None => {}\n                 }\n-            })\n+                Ok(())\n+            }))\n         }\n     }\n-    write!(w, \"</div>\");\n+    if_ok!(write!(w, \"</div>\"));\n+    Ok(())\n }\n \n-fn item_typedef(w: &mut Writer, it: &clean::Item, t: &clean::Typedef) {\n-    write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n-           it.name.get_ref().as_slice(),\n-           t.generics,\n-           t.type_);\n+fn item_typedef(w: &mut Writer, it: &clean::Item,\n+                t: &clean::Typedef) -> fmt::Result {\n+    if_ok!(write!(w, \"<pre class='typedef'>type {}{} = {};</pre>\",\n+                  it.name.get_ref().as_slice(),\n+                  t.generics,\n+                  t.type_));\n \n-    document(w, it);\n+    document(w, it)\n }\n \n impl<'a> fmt::Show for Sidebar<'a> {\n-    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = s.cx;\n         let it = s.item;\n-        write!(fmt.buf, \"<p class='location'>\");\n+        if_ok!(write!(fmt.buf, \"<p class='location'>\"));\n         let len = cx.current.len() - if it.is_mod() {1} else {0};\n         for (i, name) in cx.current.iter().take(len).enumerate() {\n-            if i > 0 { write!(fmt.buf, \"&\\\\#8203;::\") }\n-            write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n-                   cx.root_path.slice_to((cx.current.len() - i - 1) * 3), *name);\n+            if i > 0 {\n+                if_ok!(write!(fmt.buf, \"&\\\\#8203;::\"));\n+            }\n+            if_ok!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n+                          cx.root_path.slice_to((cx.current.len() - i - 1) * 3),\n+                          *name));\n         }\n-        write!(fmt.buf, \"</p>\");\n+        if_ok!(write!(fmt.buf, \"</p>\"));\n \n         fn block(w: &mut Writer, short: &str, longty: &str,\n-                 cur: &clean::Item, cx: &Context) {\n+                 cur: &clean::Item, cx: &Context) -> fmt::Result {\n             let items = match cx.sidebar.find_equiv(&short) {\n                 Some(items) => items.as_slice(),\n-                None => return\n+                None => return Ok(())\n             };\n-            write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty);\n+            if_ok!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let class = if cur.name.get_ref() == item &&\n                                short == shortty(cur) { \"current\" } else { \"\" };\n-                write!(w, \"<a class='{ty} {class}' href='{curty, select,\n+                if_ok!(write!(w, \"<a class='{ty} {class}' href='{curty, select,\n                                 mod{../}\n                                 other{}\n                            }{tysel, select,\n@@ -1525,16 +1554,18 @@ impl<'a> fmt::Show for Sidebar<'a> {\n                        tysel = short,\n                        class = class,\n                        curty = shortty(cur),\n-                       name = item.as_slice());\n+                       name = item.as_slice()));\n             }\n-            write!(w, \"</div>\");\n+            if_ok!(write!(w, \"</div>\"));\n+            Ok(())\n         }\n \n-        block(fmt.buf, \"mod\", \"Modules\", it, cx);\n-        block(fmt.buf, \"struct\", \"Structs\", it, cx);\n-        block(fmt.buf, \"enum\", \"Enums\", it, cx);\n-        block(fmt.buf, \"trait\", \"Traits\", it, cx);\n-        block(fmt.buf, \"fn\", \"Functions\", it, cx);\n+        if_ok!(block(fmt.buf, \"mod\", \"Modules\", it, cx));\n+        if_ok!(block(fmt.buf, \"struct\", \"Structs\", it, cx));\n+        if_ok!(block(fmt.buf, \"enum\", \"Enums\", it, cx));\n+        if_ok!(block(fmt.buf, \"trait\", \"Traits\", it, cx));\n+        if_ok!(block(fmt.buf, \"fn\", \"Functions\", it, cx));\n+        Ok(())\n     }\n }\n \n@@ -1557,7 +1588,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n }\n \n impl<'a> fmt::Show for Source<'a> {\n-    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) {\n+    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *s;\n         let lines = s.lines().len();\n         let mut cols = 0;\n@@ -1566,13 +1597,14 @@ impl<'a> fmt::Show for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        write!(fmt.buf, \"<pre class='line-numbers'>\");\n+        if_ok!(write!(fmt.buf, \"<pre class='line-numbers'>\"));\n         for i in range(1, lines + 1) {\n-            write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols);\n+            if_ok!(write!(fmt.buf, \"<span id='{0:u}'>{0:1$u}</span>\\n\", i, cols));\n         }\n-        write!(fmt.buf, \"</pre>\");\n-        write!(fmt.buf, \"<pre class='rust'>\");\n-        write!(fmt.buf, \"{}\", Escape(s.as_slice()));\n-        write!(fmt.buf, \"</pre>\");\n+        if_ok!(write!(fmt.buf, \"</pre>\"));\n+        if_ok!(write!(fmt.buf, \"<pre class='rust'>\"));\n+        if_ok!(write!(fmt.buf, \"{}\", Escape(s.as_slice())));\n+        if_ok!(write!(fmt.buf, \"</pre>\"));\n+        Ok(())\n     }\n }"}, {"sha": "fe989279e7147dd13286e0cd41009c59f1f9c3b3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -162,10 +162,16 @@ pub fn main_args(args: &[~str]) -> int {\n     let output = matches.opt_str(\"o\").map(|s| Path::new(s));\n     match matches.opt_str(\"w\") {\n         Some(~\"html\") | None => {\n-            html::render::run(crate, output.unwrap_or(Path::new(\"doc\")))\n+            match html::render::run(crate, output.unwrap_or(Path::new(\"doc\"))) {\n+                Ok(()) => {}\n+                Err(e) => fail!(\"failed to generate documentation: {}\", e),\n+            }\n         }\n         Some(~\"json\") => {\n-            json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\")))\n+            match json_output(crate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n+                Ok(()) => {}\n+                Err(e) => fail!(\"failed to write json: {}\", e),\n+            }\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -276,8 +282,8 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n     let mut input = match File::open(&Path::new(input)) {\n-        Some(f) => f,\n-        None => return Err(format!(\"couldn't open {} for reading\", input)),\n+        Ok(f) => f,\n+        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n     };\n     match json::from_reader(&mut input) {\n         Err(s) => Err(s.to_str()),\n@@ -312,7 +318,8 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n \n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n-fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n+fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson],\n+               dst: Path) -> io::IoResult<()> {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },\n@@ -340,6 +347,7 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     json.insert(~\"crate\", crate_json);\n     json.insert(~\"plugins\", json::Object(plugins_json));\n \n-    let mut file = File::create(&dst).unwrap();\n-    json::Object(json).to_writer(&mut file);\n+    let mut file = if_ok!(File::create(&dst));\n+    if_ok!(json::Object(json).to_writer(&mut file));\n+    Ok(())\n }"}, {"sha": "9e3b217f69f68953c5b4ac755ddb3fa420ebfa27", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -127,8 +127,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     let exe = outdir.path().join(\"rust_out\");\n     let out = run::process_output(exe.as_str().unwrap(), []);\n     match out {\n-        None => fail!(\"couldn't run the test\"),\n-        Some(out) => {\n+        Err(e) => fail!(\"couldn't run the test: {}\", e),\n+        Ok(out) => {\n             if !out.status.success() {\n                 fail!(\"test executable failed:\\n{}\",\n                       str::from_utf8(out.error));"}, {"sha": "2cef2664c2fc41caf59cb6a69ce6d7b624117e88", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -140,9 +140,9 @@ impl FsRequest {\n             let mut paths = ~[];\n             let path = CString::new(path.with_ref(|p| p), false);\n             let parent = Path::new(path);\n-            c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n-                                      Some(req.get_result() as uint),\n-                                      |rel| {\n+            let _ = c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n+                                              Some(req.get_result() as uint),\n+                                              |rel| {\n                 let p = rel.as_bytes();\n                 paths.push(parent.join(p.slice_to(rel.len())));\n             });\n@@ -378,7 +378,8 @@ impl Drop for FileWatcher {\n             rtio::CloseAsynchronously => {\n                 unsafe {\n                     let req = uvll::malloc_req(uvll::UV_FS);\n-                    uvll::uv_fs_close(self.loop_.handle, req, self.fd, close_cb);\n+                    assert_eq!(uvll::uv_fs_close(self.loop_.handle, req,\n+                                                 self.fd, close_cb), 0);\n                 }\n \n                 extern fn close_cb(req: *uvll::uv_fs_t) {"}, {"sha": "a2f3457a9430cc2be528b0c3904e41853763225c", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -176,7 +176,7 @@ mod test {\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n-            port.recv();\n+            drop(port.recv());\n         });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n@@ -197,7 +197,7 @@ mod test {\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n             chan.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n-            listener.sendto([1, 2, 3, 4], addr2);\n+            listener.sendto([1, 2, 3, 4], addr2).unwrap();\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {"}, {"sha": "dafd3dbe1bc9694367ca43ede8104d022365c27a", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -52,7 +52,7 @@ impl IdleWatcher {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 let f: ~proc() = cast::transmute(data);\n                 (*f)();\n-                uvll::uv_idle_stop(handle);\n+                assert_eq!(uvll::uv_idle_stop(handle), 0);\n                 uvll::uv_close(handle, close_cb);\n             }\n         }\n@@ -122,7 +122,7 @@ mod test {\n                     }\n                 }\n             };\n-            task.wake().map(|t| t.reawaken(true));\n+            let _ = task.wake().map(|t| t.reawaken(true));\n         }\n     }\n "}, {"sha": "f945c0972ca39b738e3a68c5ce075d640cc09d41", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -40,6 +40,7 @@ via `close` and `delete` methods.\n #[crate_type = \"dylib\"];\n \n #[feature(macro_rules)];\n+#[deny(unused_result, unused_must_use)];\n \n #[cfg(test)] extern mod green;\n \n@@ -207,7 +208,7 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n \n fn wakeup(slot: &mut Option<BlockedTask>) {\n     assert!(slot.is_some());\n-    slot.take_unwrap().wake().map(|t| t.reawaken(true));\n+    let _ = slot.take_unwrap().wake().map(|t| t.reawaken(true));\n }\n \n pub struct Request {\n@@ -276,7 +277,7 @@ impl Loop {\n     pub fn wrap(handle: *uvll::uv_loop_t) -> Loop { Loop { handle: handle } }\n \n     pub fn run(&mut self) {\n-        unsafe { uvll::uv_run(self.handle, uvll::RUN_DEFAULT) };\n+        assert_eq!(unsafe { uvll::uv_run(self.handle, uvll::RUN_DEFAULT) }, 0);\n     }\n \n     pub fn close(&mut self) {"}, {"sha": "75b68e3a52885ac55c85814c282f8e104a2e7679", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -33,14 +33,15 @@ pub fn dumb_println(args: &fmt::Arguments) {\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) {\n-            unsafe {\n+        fn write(&mut self, data: &[u8]) -> io::IoResult<()> {\n+            let _ = unsafe {\n                 libc::write(libc::STDERR_FILENO,\n                             data.as_ptr() as *libc::c_void,\n-                            data.len() as libc::size_t);\n-            }\n+                            data.len() as libc::size_t)\n+            };\n+            Ok(()) // just ignore the errors\n         }\n     }\n     let mut w = Stderr;\n-    fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }"}, {"sha": "5461fc6272d3514c9c754ab4e0a01ce12c37cf20", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -953,11 +953,11 @@ mod test {\n         spawn(proc() {\n             let port2 = port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             port2.recv();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             port2.recv();\n         });\n \n@@ -1008,7 +1008,7 @@ mod test {\n         while stream.is_err() {\n             stream = TcpWatcher::connect(local_loop(), addr);\n         }\n-        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+        stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n     }\n \n     #[should_fail] #[test]\n@@ -1028,7 +1028,7 @@ mod test {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n             chan.send(());\n-            w.accept();\n+            drop(w.accept().unwrap());\n         });\n         port.recv();\n         let _w = TcpWatcher::connect(local_loop(), addr).unwrap();"}, {"sha": "a021a13e2d98d67aa31cf6c42bfc362fe60455f4", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -306,7 +306,7 @@ mod tests {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n             chan.send(());\n-            p.accept();\n+            drop(p.accept().unwrap());\n         });\n         port.recv();\n         let _c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();"}, {"sha": "0e1c4225caa930e6f5074e92db9b904833d76c5c", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -67,7 +67,7 @@ extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n     loop {\n         match state.consumer.pop() {\n             mpsc::Data(Task(task)) => {\n-                task.wake().map(|t| t.reawaken(true));\n+                let _ = task.wake().map(|t| t.reawaken(true));\n             }\n             mpsc::Data(Increment) => unsafe {\n                 if state.refcnt == 0 {"}, {"sha": "2fcc61be79bdfd636b7535a6fae243202b800f51", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -86,7 +86,7 @@ mod test {\n                                          chan);\n \n         spawn(proc() {\n-            port.try_recv();\n+            let _ = port.recv_opt();\n         });\n \n         // when we drop the SignalWatcher we're going to destroy the channel,"}, {"sha": "792414238fdaad4d8f594ec8ea034f069c20bf6a", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -138,11 +138,11 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n \n     match timer.action.take_unwrap() {\n         WakeTask(task) => {\n-            task.wake().map(|t| t.reawaken(true));\n+            let _ = task.wake().map(|t| t.reawaken(true));\n         }\n-        SendOnce(chan) => { chan.try_send(()); }\n+        SendOnce(chan) => { let _ = chan.try_send(()); }\n         SendMany(chan, id) => {\n-            chan.try_send(());\n+            let _ = chan.try_send(());\n \n             // Note that the above operation could have performed some form of\n             // scheduling. This means that the timer may have decided to insert\n@@ -246,7 +246,7 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            let _ = timer_port.recv_opt();\n         });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -260,10 +260,10 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            let _ = timer_port.recv_opt();\n         });\n \n-        timer.oneshot(1);\n+        drop(timer.oneshot(1));\n     }\n     #[test]\n     fn reset_doesnt_switch_tasks2() {\n@@ -272,7 +272,7 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            let _ = timer_port.recv_opt();\n         });\n \n         timer.sleep(1);\n@@ -299,7 +299,7 @@ mod test {\n     #[test]\n     fn receiver_goes_away_oneshot() {\n         let mut timer1 = TimerWatcher::new(local_loop());\n-        timer1.oneshot(1);\n+        drop(timer1.oneshot(1));\n         let mut timer2 = TimerWatcher::new(local_loop());\n         // while sleeping, the prevous timer should fire and not have its\n         // callback do something terrible.\n@@ -309,7 +309,7 @@ mod test {\n     #[test]\n     fn receiver_goes_away_period() {\n         let mut timer1 = TimerWatcher::new(local_loop());\n-        timer1.period(1);\n+        drop(timer1.period(1));\n         let mut timer2 = TimerWatcher::new(local_loop());\n         // while sleeping, the prevous timer should fire and not have its\n         // callback do something terrible."}, {"sha": "8a8ef4a41ec4e758b2a66f535aeb9b220ebaaece", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -71,7 +71,7 @@ impl Drop for UvEventLoop {\n         // after the loop has been closed because during the closing of the loop\n         // the handle is required to be used apparently.\n         let handle = self.uvio.handle_pool.get_ref().handle();\n-        self.uvio.handle_pool.take();\n+        drop(self.uvio.handle_pool.take());\n         self.uvio.loop_.close();\n         unsafe { uvll::free_handle(handle) }\n     }"}, {"sha": "bccebeaa79f6b9fb12f2d01f2096b50159b7960e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -1252,7 +1252,7 @@ mod test {\n             spawn(proc() {\n                 let _p = port;\n             });\n-            task::try(proc() {\n+            let _ = task::try(proc() {\n                 chan.send(1);\n             });\n         }"}, {"sha": "06737e22007e4672680ee62f502357072770fa03", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -163,9 +163,10 @@ method of the signature:\n \n ```rust\n # use std;\n+# mod fmt { pub type Result = (); }\n # struct T;\n # trait SomeName<T> {\n-fn fmt(value: &T, f: &mut std::fmt::Formatter);\n+fn fmt(value: &T, f: &mut std::fmt::Formatter) -> fmt::Result;\n # }\n ```\n \n@@ -174,7 +175,14 @@ emit output into the `f.buf` stream. It is up to each format trait\n implementation to correctly adhere to the requested formatting parameters. The\n values of these parameters will be listed in the fields of the `Formatter`\n struct. In order to help with this, the `Formatter` struct also provides some\n-helper methods. An example of implementing the formatting traits would look\n+helper methods.\n+\n+Additionally, the return value of this function is `fmt::Result` which is a\n+typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n+implementations should ensure that they return errors from `write!` correctly\n+(propagating errors upward).\n+\n+An example of implementing the formatting traits would look\n like:\n \n ```rust\n@@ -187,7 +195,7 @@ struct Vector2D {\n }\n \n impl fmt::Show for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n         // The `f.buf` value is of the type `&mut io::Writer`, which is what th\n         // write! macro is expecting. Note that this formatting ignores the\n         // various flags provided to format strings.\n@@ -198,7 +206,7 @@ impl fmt::Show for Vector2D {\n // Different traits allow different forms of output of a type. The meaning of\n // this format is to print the magnitude of a vector.\n impl fmt::Binary for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n         let magnitude = (obj.x * obj.x + obj.y * obj.y) as f64;\n         let magnitude = magnitude.sqrt();\n \n@@ -207,7 +215,7 @@ impl fmt::Binary for Vector2D {\n         // for details, and the function `pad` can be used to pad strings.\n         let decimals = f.precision.unwrap_or(3);\n         let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(string.as_bytes(), \"\", true);\n+        f.pad_integral(string.as_bytes(), \"\", true)\n     }\n }\n \n@@ -242,6 +250,7 @@ strings and instead directly write the output. Under the hood, this function is\n actually invoking the `write` function defined in this module. Example usage is:\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io;\n \n let mut w = io::MemWriter::new();\n@@ -468,39 +477,32 @@ will look like `\"\\\\{\"`.\n \n */\n \n-#[cfg(not(stage0))]\n-use prelude::*;\n-\n use cast;\n use char::Char;\n+use container::Container;\n use io::MemWriter;\n use io;\n-use str;\n+use iter::{Iterator, range};\n+use num::Signed;\n+use option::{Option,Some,None};\n use repr;\n+use result::{Ok, Err};\n+use str::StrSlice;\n+use str;\n use util;\n+use vec::ImmutableVector;\n use vec;\n \n // NOTE this is just because the `prelude::*` import above includes\n // default::Default, so the reexport doesn't work.\n #[cfg(stage0)]\n pub use Default = fmt::Show; // export required for `format!()` etc.\n \n-#[cfg(stage0)]\n-use container::Container;\n-#[cfg(stage0)]\n-use iter::{Iterator, range};\n-#[cfg(stage0)]\n-use option::{Option,Some,None};\n-#[cfg(stage0)]\n-use vec::ImmutableVector;\n-#[cfg(stage0)]\n-use str::StrSlice;\n-#[cfg(stage0)]\n-use num::Signed;\n-\n pub mod parse;\n pub mod rt;\n \n+pub type Result = io::IoResult<()>;\n+\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n@@ -527,7 +529,7 @@ pub struct Formatter<'a> {\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n pub struct Argument<'a> {\n-    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n+    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter) -> Result,\n     priv value: &'a util::Void,\n }\n \n@@ -561,50 +563,50 @@ pub struct Arguments<'a> {\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n #[allow(missing_doc)]\n-pub trait Show { fn fmt(&Self, &mut Formatter); }\n+pub trait Show { fn fmt(&Self, &mut Formatter) -> Result; }\n \n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Bool { fn fmt(&Self, &mut Formatter); }\n+pub trait Bool { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `c` character\n #[allow(missing_doc)]\n-pub trait Char { fn fmt(&Self, &mut Formatter); }\n+pub trait Char { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `i` and `d` characters\n #[allow(missing_doc)]\n-pub trait Signed { fn fmt(&Self, &mut Formatter); }\n+pub trait Signed { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `u` character\n #[allow(missing_doc)]\n-pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n+pub trait Unsigned { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `o` character\n #[allow(missing_doc)]\n-pub trait Octal { fn fmt(&Self, &mut Formatter); }\n+pub trait Octal { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Binary { fn fmt(&Self, &mut Formatter); }\n+pub trait Binary { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `x` character\n #[allow(missing_doc)]\n-pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n+pub trait LowerHex { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `X` character\n #[allow(missing_doc)]\n-pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n+pub trait UpperHex { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `s` character\n #[allow(missing_doc)]\n-pub trait String { fn fmt(&Self, &mut Formatter); }\n+pub trait String { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `?` character\n #[allow(missing_doc)]\n-pub trait Poly { fn fmt(&Self, &mut Formatter); }\n+pub trait Poly { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `p` character\n #[allow(missing_doc)]\n-pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+pub trait Pointer { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `f` character\n #[allow(missing_doc)]\n-pub trait Float { fn fmt(&Self, &mut Formatter); }\n+pub trait Float { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `e` character\n #[allow(missing_doc)]\n-pub trait LowerExp { fn fmt(&Self, &mut Formatter); }\n+pub trait LowerExp { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `E` character\n #[allow(missing_doc)]\n-pub trait UpperExp { fn fmt(&Self, &mut Formatter); }\n+pub trait UpperExp { fn fmt(&Self, &mut Formatter) -> Result; }\n \n // FIXME #11938 - UFCS would make us able call the above methods\n // directly Show::show(x, fmt).\n@@ -617,7 +619,7 @@ macro_rules! uniform_fn_call_workaround {\n     ($( $name: ident, $trait_: ident; )*) => {\n         $(\n             #[doc(hidden)]\n-            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) {\n+            pub fn $name<T: $trait_>(x: &T, fmt: &mut Formatter) -> Result {\n                 $trait_::fmt(x, fmt)\n             }\n             )*\n@@ -653,21 +655,22 @@ uniform_fn_call_workaround! {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::fmt;\n /// use std::io;\n ///\n /// let w = &mut io::stdout() as &mut io::Writer;\n-/// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n+/// format_args!(|args| { fmt::write(w, args); }, \"Hello, {}!\", \"world\");\n /// ```\n-pub fn write(output: &mut io::Writer, args: &Arguments) {\n+pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {\n     unsafe { write_unsafe(output, args.fmt, args.args) }\n }\n \n /// The `writeln` function takes the same arguments as `write`, except that it\n /// will also write a newline (`\\n`) character at the end of the format string.\n-pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-    output.write(['\\n' as u8]);\n+pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result {\n+    let first = unsafe { write_unsafe(output, args.fmt, args.args) };\n+    first.and_then(|()| output.write(['\\n' as u8]))\n }\n \n /// The `write_unsafe` function takes an output stream, a precompiled format\n@@ -692,7 +695,7 @@ pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n /// format string.\n pub unsafe fn write_unsafe(output: &mut io::Writer,\n                            fmt: &[rt::Piece],\n-                           args: &[Argument]) {\n+                           args: &[Argument]) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -704,8 +707,9 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n         curarg: args.iter(),\n     };\n     for piece in fmt.iter() {\n-        formatter.run(piece, None);\n+        if_ok!(formatter.run(piece, None));\n     }\n+    Ok(())\n }\n \n /// The format function takes a precompiled format string and a list of\n@@ -752,7 +756,7 @@ pub fn format(args: &Arguments) -> ~str {\n /// format string.\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args);\n+    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n     return str::from_utf8_owned(output.unwrap()).unwrap();\n }\n \n@@ -762,10 +766,10 @@ impl<'a> Formatter<'a> {\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n \n-    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n+    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result {\n         match *piece {\n-            rt::String(s) => { self.buf.write(s.as_bytes()); }\n-            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n+            rt::String(s) => self.buf.write(s.as_bytes()),\n+            rt::CurrentArgument(()) => self.buf.write(cur.unwrap().as_bytes()),\n             rt::Argument(ref arg) => {\n                 // Fill in the format parameters into the formatter\n                 self.fill = arg.format.fill;\n@@ -782,8 +786,8 @@ impl<'a> Formatter<'a> {\n \n                 // Then actually do some printing\n                 match arg.method {\n-                    None => { (value.formatter)(value.value, self); }\n-                    Some(ref method) => { self.execute(*method, value); }\n+                    None => (value.formatter)(value.value, self),\n+                    Some(ref method) => self.execute(*method, value)\n                 }\n             }\n         }\n@@ -804,7 +808,7 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    fn execute(&mut self, method: &rt::Method, arg: Argument) {\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n         match *method {\n             // Pluralization is selection upon a numeric value specified as the\n             // parameter.\n@@ -847,7 +851,7 @@ impl<'a> Formatter<'a> {\n                     }\n                 }\n \n-                self.runplural(value, *default);\n+                self.runplural(value, *default)\n             }\n \n             // Select is just a matching against the string specified.\n@@ -860,24 +864,26 @@ impl<'a> Formatter<'a> {\n                 for s in selectors.iter() {\n                     if s.selector == value {\n                         for piece in s.result.iter() {\n-                            self.run(piece, Some(value));\n+                            if_ok!(self.run(piece, Some(value)));\n                         }\n-                        return;\n+                        return Ok(());\n                     }\n                 }\n                 for piece in default.iter() {\n-                    self.run(piece, Some(value));\n+                    if_ok!(self.run(piece, Some(value)));\n                 }\n+                Ok(())\n             }\n         }\n     }\n \n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n         ::uint::to_str_bytes(value, 10, |buf| {\n             let valuestr = str::from_utf8(buf).unwrap();\n             for piece in pieces.iter() {\n-                self.run(piece, Some(valuestr));\n+                if_ok!(self.run(piece, Some(valuestr)));\n             }\n+            Ok(())\n         })\n     }\n \n@@ -899,7 +905,7 @@ impl<'a> Formatter<'a> {\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n     pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n-                        positive: bool) {\n+                        positive: bool) -> Result {\n         use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut actual_len = s.len();\n@@ -916,32 +922,32 @@ impl<'a> Formatter<'a> {\n         let sign = |this: &mut Formatter| {\n             if !signprinted {\n                 if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    this.buf.write(['+' as u8]);\n+                    if_ok!(this.buf.write(['+' as u8]));\n                 } else if !positive {\n-                    this.buf.write(['-' as u8]);\n+                    if_ok!(this.buf.write(['-' as u8]));\n                 }\n                 if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    this.buf.write(alternate_prefix.as_bytes());\n+                    if_ok!(this.buf.write(alternate_prefix.as_bytes()));\n                 }\n                 signprinted = true;\n             }\n+            Ok(())\n         };\n \n         let emit = |this: &mut Formatter| {\n-            sign(this);\n-            this.buf.write(s);\n+            sign(this).and_then(|()| this.buf.write(s))\n         };\n \n         match self.width {\n-            None => { emit(self) }\n-            Some(min) if actual_len >= min => { emit(self) }\n+            None => emit(self),\n+            Some(min) if actual_len >= min => emit(self),\n             Some(min) => {\n                 if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n                     self.fill = '0';\n-                    sign(self);\n+                    if_ok!(sign(self));\n                 }\n                 self.with_padding(min - actual_len, parse::AlignRight, |me| {\n-                    emit(me);\n+                    emit(me)\n                 })\n             }\n         }\n@@ -958,11 +964,10 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    pub fn pad(&mut self, s: &str) {\n+    pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n-            self.buf.write(s.as_bytes());\n-            return\n+            return self.buf.write(s.as_bytes());\n         }\n         // The `precision` field can be interpreted as a `max-width` for the\n         // string being formatted\n@@ -974,8 +979,7 @@ impl<'a> Formatter<'a> {\n                 let char_len = s.char_len();\n                 if char_len >= max {\n                     let nchars = ::cmp::min(max, char_len);\n-                    self.buf.write(s.slice_chars(0, nchars).as_bytes());\n-                    return\n+                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n                 }\n             }\n             None => {}\n@@ -985,7 +989,7 @@ impl<'a> Formatter<'a> {\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n-            None => { self.buf.write(s.as_bytes()) }\n+            None => self.buf.write(s.as_bytes()),\n \n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n@@ -997,7 +1001,7 @@ impl<'a> Formatter<'a> {\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes());\n+                    me.buf.write(s.as_bytes())\n                 })\n             }\n         }\n@@ -1006,29 +1010,30 @@ impl<'a> Formatter<'a> {\n     fn with_padding(&mut self,\n                     padding: uint,\n                     default: parse::Alignment,\n-                    f: |&mut Formatter|) {\n+                    f: |&mut Formatter| -> Result) -> Result {\n         let align = match self.align {\n             parse::AlignUnknown => default,\n             parse::AlignLeft | parse::AlignRight => self.align\n         };\n         if align == parse::AlignLeft {\n-            f(self);\n+            if_ok!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n         let len = self.fill.encode_utf8(fill);\n         for _ in range(0, padding) {\n-            self.buf.write(fill.slice_to(len));\n+            if_ok!(self.buf.write(fill.slice_to(len)));\n         }\n         if align == parse::AlignRight {\n-            f(self);\n+            if_ok!(f(self));\n         }\n+        Ok(())\n     }\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n         Argument {\n@@ -1055,66 +1060,66 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n // Implementations of the core formatting traits\n \n impl Bool for bool {\n-    fn fmt(b: &bool, f: &mut Formatter) {\n-        String::fmt(&(if *b {\"true\"} else {\"false\"}), f);\n+    fn fmt(b: &bool, f: &mut Formatter) -> Result {\n+        String::fmt(&(if *b {\"true\"} else {\"false\"}), f)\n     }\n }\n \n impl<'a, T: str::Str> String for T {\n-    fn fmt(s: &T, f: &mut Formatter) {\n-        f.pad(s.as_slice());\n+    fn fmt(s: &T, f: &mut Formatter) -> Result {\n+        f.pad(s.as_slice())\n     }\n }\n \n impl Char for char {\n-    fn fmt(c: &char, f: &mut Formatter) {\n+    fn fmt(c: &char, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n         let amt = c.encode_utf8(utf8);\n         let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n-        String::fmt(&s, f);\n+        String::fmt(&s, f)\n     }\n }\n \n macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n+        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n             ::$into::to_str_bytes(*c as $into, $base, |buf| {\n-                f.pad_integral(buf, $prefix, true);\n+                f.pad_integral(buf, $prefix, true)\n             })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n+        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n             ::$into::to_str_bytes(*c as $into, 16, |buf| {\n-                upperhex(buf, f);\n+                upperhex(buf, f)\n             })\n         }\n     }\n })\n // Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n // when inlined into the above macro...\n #[doc(hidden)]\n-pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n+pub fn upperhex(buf: &[u8], f: &mut Formatter) -> Result {\n     let mut local = [0u8, ..16];\n     for i in ::iter::range(0, buf.len()) {\n         local[i] = match buf[i] as char {\n             'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n             c => c as u8,\n         }\n     }\n-    f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n+    f.pad_integral(local.slice_to(buf.len()), \"0x\", true)\n }\n \n macro_rules! integer(($signed:ident, $unsigned:ident) => {\n     // Signed is special because it actuall emits the negative sign,\n     // nothing else should do that, however.\n     impl Signed for $signed {\n-        fn fmt(c: &$signed, f: &mut Formatter) {\n+        fn fmt(c: &$signed, f: &mut Formatter) -> Result {\n             ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *c >= 0);\n+                f.pad_integral(buf, \"\", *c >= 0)\n             })\n         }\n     }\n@@ -1138,75 +1143,77 @@ integer!(i64, u64)\n \n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exact(f.abs(), i),\n                 None => ::$ty::to_str_digits(f.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n \n     impl LowerExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, false),\n                 None => ::$ty::to_str_exp_digits(f.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n \n     impl UpperExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, true),\n                 None => ::$ty::to_str_exp_digits(f.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n })\n floating!(f32)\n floating!(f64)\n \n impl<T> Poly for T {\n-    fn fmt(t: &T, f: &mut Formatter) {\n+    fn fmt(t: &T, f: &mut Formatter) -> Result {\n         match (f.width, f.precision) {\n             (None, None) => {\n-                repr::write_repr(f.buf, t);\n+                repr::write_repr(f.buf, t)\n             }\n \n             // If we have a specified width for formatting, then we have to make\n             // this allocation of a new string\n             _ => {\n                 let s = repr::repr_to_str(t);\n-                f.pad(s);\n+                f.pad(s)\n             }\n         }\n     }\n }\n \n impl<T> Pointer for *T {\n-    fn fmt(t: &*T, f: &mut Formatter) {\n+    fn fmt(t: &*T, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n         ::uint::to_str_bytes(*t as uint, 16, |buf| {\n-            f.pad_integral(buf, \"0x\", true);\n+            f.pad_integral(buf, \"0x\", true)\n         })\n     }\n }\n impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) { Pointer::fmt(&(*t as *T), f) }\n+    fn fmt(t: &*mut T, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*t as *T), f)\n+    }\n }\n \n // Implementation of Show for various core types\n \n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl<'a> Show for $ty {\n-        fn fmt(me: &$ty, f: &mut Formatter) {\n+        fn fmt(me: &$ty, f: &mut Formatter) -> Result {\n             $other::fmt(me, f)\n         }\n     }\n@@ -1229,10 +1236,10 @@ delegate!(f32 to Float)\n delegate!(f64 to Float)\n \n impl<T> Show for *T {\n-    fn fmt(me: &*T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+    fn fmt(me: &*T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n }\n impl<T> Show for *mut T {\n-    fn fmt(me: &*mut T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+    fn fmt(me: &*mut T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "4163d1e0c96e8d94cffbdba914bd0c731e0b6482", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -27,13 +27,14 @@\n #[allow(missing_doc)];\n \n use container::Container;\n+use io::{Writer, IoResult};\n use iter::Iterator;\n+use num::ToStrRadix;\n use option::{Some, None};\n-use io::Writer;\n+use result::Ok;\n use str::OwnedStr;\n use to_bytes::IterBytes;\n use vec::ImmutableVector;\n-use num::ToStrRadix;\n \n // Alias `SipState` to `State`.\n pub use State = hash::SipState;\n@@ -164,7 +165,7 @@ macro_rules! compress (\n impl Writer for SipState {\n     // Methods for io::writer\n     #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n+    fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n         let length = msg.len();\n         self.length += length;\n \n@@ -180,7 +181,7 @@ impl Writer for SipState {\n                     t += 1;\n                 }\n                 self.ntail += length;\n-                return;\n+                return Ok(())\n             }\n \n             let mut t = 0;\n@@ -222,17 +223,14 @@ impl Writer for SipState {\n             t += 1\n         }\n         self.ntail = left;\n-    }\n-\n-    fn flush(&mut self) {\n-        // No-op\n+        Ok(())\n     }\n }\n \n impl Streaming for SipState {\n     #[inline]\n     fn input(&mut self, buf: &[u8]) {\n-        self.write(buf);\n+        self.write(buf).unwrap();\n     }\n \n     #[inline]"}, {"sha": "256f9d325f3edd92e8c9126ff8d55d945e00d25d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 102, "deletions": 92, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,10 +11,11 @@\n //! Buffering wrappers for I/O traits\n \n use container::Container;\n-use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE};\n+use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use num;\n-use option::{Option, Some, None};\n+use option::{Some, None};\n+use result::{Ok, Err};\n use vec::{OwnedVector, ImmutableVector, MutableVector};\n use vec;\n \n@@ -30,14 +31,13 @@ use vec;\n /// ```rust\n /// use std::io::{BufferedReader, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut reader = BufferedReader::new(file);\n ///\n /// let mut buf = [0, ..100];\n /// match reader.read(buf) {\n-///     Some(nread) => println!(\"Read {} bytes\", nread),\n-///     None => println!(\"At the end of the file!\")\n+///     Ok(nread) => println!(\"Read {} bytes\", nread),\n+///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n pub struct BufferedReader<R> {\n@@ -86,17 +86,12 @@ impl<R: Reader> BufferedReader<R> {\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] {\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            match self.inner.read(self.buf) {\n-                Some(cap) => {\n-                    self.pos = 0;\n-                    self.cap = cap;\n-                }\n-                None => { self.eof = true; }\n-            }\n+            self.cap = if_ok!(self.inner.read(self.buf));\n+            self.pos = 0;\n         }\n-        return self.buf.slice(self.pos, self.cap);\n+        Ok(self.buf.slice(self.pos, self.cap))\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -106,18 +101,15 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n-            let available = self.fill();\n+            let available = if_ok!(self.fill());\n             let nread = num::min(available.len(), buf.len());\n             vec::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n-        if nread == 0 && buf.len() != 0 && self.eof {\n-            return None;\n-        }\n-        Some(nread)\n+        Ok(nread)\n     }\n }\n \n@@ -128,9 +120,9 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::{BufferedWriter, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut writer = BufferedWriter::new(file);\n ///\n@@ -161,10 +153,13 @@ impl<W: Writer> BufferedWriter<W> {\n         BufferedWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    fn flush_buf(&mut self) {\n+    fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            self.inner.write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n+            ret\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -178,29 +173,30 @@ impl<W: Writer> BufferedWriter<W> {\n     ///\n     /// The buffer is flushed before returning the writer.\n     pub fn unwrap(mut self) -> W {\n-        self.flush_buf();\n+        // FIXME: is failing the right thing to do if flushing fails?\n+        self.flush_buf().unwrap();\n         self.inner\n     }\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos + buf.len() > self.buf.len() {\n-            self.flush_buf();\n+            if_ok!(self.flush_buf());\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.write(buf);\n+            self.inner.write(buf)\n         } else {\n             let dst = self.buf.mut_slice_from(self.pos);\n             vec::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n+            Ok(())\n         }\n     }\n \n-    fn flush(&mut self) {\n-        self.flush_buf();\n-        self.inner.flush();\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.flush_buf().and_then(|()| self.inner.flush())\n     }\n }\n \n@@ -234,18 +230,19 @@ impl<W: Writer> LineBufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == '\\n' as u8) {\n             Some(i) => {\n-                self.inner.write(buf.slice_to(i + 1));\n-                self.inner.flush();\n-                self.inner.write(buf.slice_from(i + 1));\n+                if_ok!(self.inner.write(buf.slice_to(i + 1)));\n+                if_ok!(self.inner.flush());\n+                if_ok!(self.inner.write(buf.slice_from(i + 1)));\n+                Ok(())\n             }\n             None => self.inner.write(buf),\n         }\n     }\n \n-    fn flush(&mut self) { self.inner.flush() }\n+    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n \n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n@@ -258,7 +255,9 @@ impl<W> InternalBufferedWriter<W> {\n }\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.get_mut_ref().inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.get_mut_ref().inner.read(buf)\n+    }\n }\n \n /// Wraps a Stream and buffers input and output to and from it\n@@ -268,9 +267,9 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::{BufferedStream, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut stream = BufferedStream::new(file);\n ///\n@@ -279,8 +278,8 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// let mut buf = [0, ..100];\n /// match stream.read(buf) {\n-///     Some(nread) => println!(\"Read {} bytes\", nread),\n-///     None => println!(\"At the end of the stream!\")\n+///     Ok(nread) => println!(\"Read {} bytes\", nread),\n+///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n pub struct BufferedStream<S> {\n@@ -326,17 +325,23 @@ impl<S: Stream> BufferedStream<S> {\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.inner.fill() }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n \n impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.read(buf)\n+    }\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) { self.inner.inner.get_mut_ref().write(buf) }\n-    fn flush(&mut self) { self.inner.inner.get_mut_ref().flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.inner.inner.get_mut_ref().write(buf)\n+    }\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.inner.inner.get_mut_ref().flush()\n+    }\n }\n \n #[cfg(test)]\n@@ -354,13 +359,13 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::EndOfFile))\n         }\n     }\n \n     impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) { }\n+        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n     }\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -369,8 +374,11 @@ mod test {\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            self.lengths.shift()\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            match self.lengths.shift() {\n+                Some(i) => Ok(i),\n+                None => Err(io::standard_error(io::EndOfFile))\n+            }\n         }\n     }\n \n@@ -381,68 +389,68 @@ mod test {\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(2), nread);\n+        assert_eq!(Ok(2), nread);\n         assert_eq!([0, 1, 0], buf);\n \n         let mut buf = [0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([2], buf);\n \n         let mut buf = [0, 0, 0];\n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([3, 0, 0], buf);\n \n         let nread = reader.read(buf);\n-        assert_eq!(Some(1), nread);\n+        assert_eq!(Ok(1), nread);\n         assert_eq!([4, 0, 0], buf);\n \n-        assert_eq!(None, reader.read(buf));\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_buffered_writer() {\n         let inner = MemWriter::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n-        writer.write([0, 1]);\n+        writer.write([0, 1]).unwrap();\n         assert_eq!([], writer.get_ref().get_ref());\n \n-        writer.write([2]);\n+        writer.write([2]).unwrap();\n         assert_eq!([0, 1], writer.get_ref().get_ref());\n \n-        writer.write([3]);\n+        writer.write([3]).unwrap();\n         assert_eq!([0, 1], writer.get_ref().get_ref());\n \n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n-        writer.write([4]);\n-        writer.write([5]);\n+        writer.write([4]).unwrap();\n+        writer.write([5]).unwrap();\n         assert_eq!([0, 1, 2, 3], writer.get_ref().get_ref());\n \n-        writer.write([6]);\n+        writer.write([6]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5],\n                    writer.get_ref().get_ref());\n \n-        writer.write([7, 8]);\n+        writer.write([7, 8]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6],\n                    writer.get_ref().get_ref());\n \n-        writer.write([9, 10, 11]);\n+        writer.write([9, 10, 11]).unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n \n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n                    writer.get_ref().get_ref());\n     }\n \n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n-        w.write([0, 1]);\n+        w.write([0, 1]).unwrap();\n         assert_eq!([], w.get_ref().get_ref());\n         let w = w.unwrap();\n         assert_eq!([0, 1], w.get_ref());\n@@ -455,47 +463,49 @@ mod test {\n         struct S;\n \n         impl io::Writer for S {\n-            fn write(&mut self, _: &[u8]) {}\n+            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n         }\n \n         impl io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> Option<uint> { None }\n+            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+                Err(io::standard_error(io::EndOfFile))\n+            }\n         }\n \n         let mut stream = BufferedStream::new(S);\n         let mut buf = [];\n-        stream.read(buf);\n-        stream.write(buf);\n-        stream.flush();\n+        assert!(stream.read(buf).is_err());\n+        stream.write(buf).unwrap();\n+        stream.flush().unwrap();\n     }\n \n     #[test]\n     fn test_read_until() {\n         let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n         let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Some(~[0]));\n-        assert_eq!(reader.read_until(2), Some(~[1, 2]));\n-        assert_eq!(reader.read_until(1), Some(~[1]));\n-        assert_eq!(reader.read_until(8), Some(~[0]));\n-        assert_eq!(reader.read_until(9), None);\n+        assert_eq!(reader.read_until(0), Ok(~[0]));\n+        assert_eq!(reader.read_until(2), Ok(~[1, 2]));\n+        assert_eq!(reader.read_until(1), Ok(~[1]));\n+        assert_eq!(reader.read_until(8), Ok(~[0]));\n+        assert!(reader.read_until(9).is_err());\n     }\n \n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n-        writer.write([0]);\n+        writer.write([0]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), []);\n-        writer.write([1]);\n+        writer.write([1]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), []);\n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(), [0, 1]);\n-        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]);\n+        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n-        writer.flush();\n+        writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n-        writer.write([3, '\\n' as u8]);\n+        writer.write([3, '\\n' as u8]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n             [0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n     }\n@@ -504,10 +514,10 @@ mod test {\n     fn test_read_line() {\n         let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Some(~\"a\\n\"));\n-        assert_eq!(reader.read_line(), Some(~\"b\\n\"));\n-        assert_eq!(reader.read_line(), Some(~\"c\"));\n-        assert_eq!(reader.read_line(), None);\n+        assert_eq!(reader.read_line(), Ok(~\"a\\n\"));\n+        assert_eq!(reader.read_line(), Ok(~\"b\\n\"));\n+        assert_eq!(reader.read_line(), Ok(~\"c\"));\n+        assert!(reader.read_line().is_err());\n     }\n \n     #[test]\n@@ -526,20 +536,20 @@ mod test {\n         let inner = ShortReader{lengths: ~[0, 1, 2, 0, 1, 0]};\n         let mut reader = BufferedReader::new(inner);\n         let mut buf = [0, 0];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.read(buf), Some(2));\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.read(buf), None);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(buf), Ok(2));\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n         let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n-        assert_eq!(reader.read_char(), Some('\u00df'));\n+        assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[bench]"}, {"sha": "6ed588ac69fd42266c02ea72a1dd69d229e4f9be", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -14,7 +14,7 @@ use comm::{Port, Chan};\n use cmp;\n use io;\n use option::{None, Option, Some};\n-use super::{Reader, Writer};\n+use super::{Reader, Writer, IoResult};\n use vec::{bytes, CloneableVector, MutableVector, ImmutableVector};\n \n /// Allows reading from a port.\n@@ -49,7 +49,7 @@ impl PortReader {\n }\n \n impl Reader for PortReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut num_read = 0;\n         loop {\n             match self.buf {\n@@ -71,10 +71,9 @@ impl Reader for PortReader {\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n-            io::io_error::cond.raise(io::standard_error(io::EndOfFile));\n-            None\n+            Err(io::standard_error(io::EndOfFile))\n         } else {\n-            Some(num_read)\n+            Ok(num_read)\n         }\n     }\n }\n@@ -98,13 +97,15 @@ impl ChanWriter {\n }\n \n impl Writer for ChanWriter {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if !self.chan.try_send(buf.to_owned()) {\n-            io::io_error::cond.raise(io::IoError {\n+            Err(io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n                 detail: None\n-            });\n+            })\n+        } else {\n+            Ok(())\n         }\n     }\n }\n@@ -132,55 +133,44 @@ mod test {\n         let mut buf = ~[0u8, ..3];\n \n \n-        assert_eq!(Some(0), reader.read([]));\n+        assert_eq!(Ok(0), reader.read([]));\n \n-        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(buf));\n         assert_eq!(~[1,2,3], buf);\n \n-        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(buf));\n         assert_eq!(~[4,5,6], buf);\n \n-        assert_eq!(Some(2), reader.read(buf));\n+        assert_eq!(Ok(2), reader.read(buf));\n         assert_eq!(~[7,8,6], buf);\n \n-        let mut err = None;\n-        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n-            err = Some(k)\n-        }).inside(|| {\n-            reader.read(buf)\n-        });\n-        assert_eq!(Some(io::EndOfFile), err);\n-        assert_eq!(None, result);\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n         assert_eq!(~[7,8,6], buf);\n \n         // Ensure it continues to fail in the same way.\n-        err = None;\n-        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n-            err = Some(k)\n-        }).inside(|| {\n-            reader.read(buf)\n-        });\n-        assert_eq!(Some(io::EndOfFile), err);\n-        assert_eq!(None, result);\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n         assert_eq!(~[7,8,6], buf);\n     }\n \n     #[test]\n     fn test_chan_writer() {\n         let (port, chan) = Chan::new();\n         let mut writer = ChanWriter::new(chan);\n-        writer.write_be_u32(42);\n+        writer.write_be_u32(42).unwrap();\n \n         let wanted = ~[0u8, 0u8, 0u8, 42u8];\n         let got = task::try(proc() { port.recv() }).unwrap();\n         assert_eq!(wanted, got);\n \n-        let mut err = None;\n-        io::io_error::cond.trap(|io::IoError { kind, .. } | {\n-            err = Some(kind)\n-        }).inside(|| {\n-            writer.write_u8(1)\n-        });\n-        assert_eq!(Some(io::BrokenPipe), err);\n+        match writer.write_u8(1) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::BrokenPipe),\n+        }\n     }\n }"}, {"sha": "49d51cbb26fc87f5ba9b35db090f49eafae2bccb", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 49, "deletions": 85, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -46,7 +46,7 @@ impl<'r, R: Reader> Bytes<'r, R> {\n impl<'r, R: Reader> Iterator<u8> for Bytes<'r, R> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n-        self.reader.read_byte()\n+        self.reader.read_byte().ok()\n     }\n }\n \n@@ -125,41 +125,39 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n #[cfg(test)]\n mod test {\n-    use unstable::finally::Finally;\n     use prelude::*;\n+    use io;\n     use io::{MemReader, MemWriter};\n-    use io::{io_error, placeholder_error};\n \n     struct InitialZeroByteReader {\n         count: int,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n-                Some(0)\n+                Ok(0)\n             } else {\n                 buf[0] = 10;\n-                Some(1)\n+                Ok(1)\n             }\n         }\n     }\n \n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n-            io_error::cond.raise(placeholder_error());\n-            None\n+        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+            Err(io::standard_error(io::InvalidInput))\n         }\n     }\n \n@@ -168,16 +166,16 @@ mod test {\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 buf[1] = 11;\n-                Some(2)\n+                Ok(2)\n             } else {\n                 buf[0] = 12;\n                 buf[1] = 13;\n-                Some(2)\n+                Ok(2)\n             }\n         }\n     }\n@@ -187,14 +185,13 @@ mod test {\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n-                Some(1)\n+                Ok(1)\n             } else {\n-                io_error::cond.raise(placeholder_error());\n-                None\n+                Err(io::standard_error(io::InvalidInput))\n             }\n         }\n     }\n@@ -204,19 +201,19 @@ mod test {\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 buf[1] = 11;\n-                Some(2)\n+                Ok(2)\n             } else if self.count == 1 {\n                 self.count = 2;\n                 buf[0] = 12;\n                 buf[1] = 13;\n-                Some(2)\n+                Ok(2)\n             } else {\n-                None\n+                Err(io::standard_error(io::EndOfFile))\n             }\n         }\n     }\n@@ -225,7 +222,7 @@ mod test {\n     fn read_byte() {\n         let mut reader = MemReader::new(~[10]);\n         let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n+        assert!(byte == Ok(10));\n     }\n \n     #[test]\n@@ -234,24 +231,21 @@ mod test {\n             count: 0,\n         };\n         let byte = reader.read_byte();\n-        assert!(byte == Some(10));\n+        assert!(byte == Ok(10));\n     }\n \n     #[test]\n     fn read_byte_eof() {\n         let mut reader = EofReader;\n         let byte = reader.read_byte();\n-        assert!(byte == None);\n+        assert!(byte.is_err());\n     }\n \n     #[test]\n     fn read_byte_error() {\n         let mut reader = ErroringReader;\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            let byte = reader.read_byte();\n-            assert!(byte == None);\n-        });\n+        let byte = reader.read_byte();\n+        assert!(byte.is_err());\n     }\n \n     #[test]\n@@ -267,23 +261,21 @@ mod test {\n     fn bytes_eof() {\n         let mut reader = EofReader;\n         let byte = reader.bytes().next();\n-        assert!(byte == None);\n+        assert!(byte.is_none());\n     }\n \n     #[test]\n     fn bytes_error() {\n         let mut reader = ErroringReader;\n         let mut it = reader.bytes();\n-        io_error::cond.trap(|_| ()).inside(|| {\n-            let byte = it.next();\n-            assert!(byte == None);\n-        })\n+        let byte = it.next();\n+        assert!(byte.is_none());\n     }\n \n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let bytes = reader.read_bytes(4);\n+        let bytes = reader.read_bytes(4).unwrap();\n         assert!(bytes == ~[10, 11, 12, 13]);\n     }\n \n@@ -292,24 +284,21 @@ mod test {\n         let mut reader = PartialReader {\n             count: 0,\n         };\n-        let bytes = reader.read_bytes(4);\n+        let bytes = reader.read_bytes(4).unwrap();\n         assert!(bytes == ~[10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn read_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            assert!(reader.read_bytes(4) == ~[10, 11]);\n-        })\n+        assert!(reader.read_bytes(4).is_err());\n     }\n \n     #[test]\n     fn push_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n         let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n+        reader.push_bytes(&mut buf, 4).unwrap();\n         assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n     }\n \n@@ -319,19 +308,16 @@ mod test {\n             count: 0,\n         };\n         let mut buf = ~[8, 9];\n-        reader.push_bytes(&mut buf, 4);\n+        reader.push_bytes(&mut buf, 4).unwrap();\n         assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn push_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n         let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| {\n-        }).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-            assert!(buf == ~[8, 9, 10, 11]);\n-        })\n+        assert!(reader.push_bytes(&mut buf, 4).is_err());\n+        assert!(buf == ~[8, 9, 10, 11]);\n     }\n \n     #[test]\n@@ -340,38 +326,16 @@ mod test {\n             count: 0,\n         };\n         let mut buf = ~[8, 9];\n-        io_error::cond.trap(|_| { } ).inside(|| {\n-            reader.push_bytes(&mut buf, 4);\n-        });\n+        assert!(reader.push_bytes(&mut buf, 4).is_err());\n         assert!(buf == ~[8, 9, 10]);\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[ignore] // borrow issues with RefCell\n-    fn push_bytes_fail_reset_len() {\n-        // push_bytes unsafely sets the vector length. This is testing that\n-        // upon failure the length is reset correctly.\n-        let _reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        // FIXME (#7049): Figure out some other way to do this.\n-        //let buf = RefCell::new(~[8, 9]);\n-        (|| {\n-            //reader.push_bytes(buf.borrow_mut().get(), 4);\n-        }).finally(|| {\n-            // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n-            // FIXME: #7049 This fails because buf is still borrowed\n-            //rtassert!(buf.borrow().get() == ~[8, 9, 10]);\n-        })\n-    }\n-\n     #[test]\n     fn read_to_end() {\n         let mut reader = ThreeChunkReader {\n             count: 0,\n         };\n-        let buf = reader.read_to_end();\n+        let buf = reader.read_to_end().unwrap();\n         assert!(buf == ~[10, 11, 12, 13]);\n     }\n \n@@ -381,7 +345,7 @@ mod test {\n         let mut reader = ThreeChunkReader {\n             count: 0,\n         };\n-        let buf = reader.read_to_end();\n+        let buf = reader.read_to_end().unwrap();\n         assert!(buf == ~[10, 11]);\n     }\n \n@@ -391,12 +355,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_le_u64(*i);\n+            writer.write_le_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n-            assert!(reader.read_le_u64() == *i);\n+            assert!(reader.read_le_u64().unwrap() == *i);\n         }\n     }\n \n@@ -407,12 +371,12 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n-            writer.write_be_u64(*i);\n+            writer.write_be_u64(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in uints.iter() {\n-            assert!(reader.read_be_u64() == *i);\n+            assert!(reader.read_be_u64().unwrap() == *i);\n         }\n     }\n \n@@ -422,14 +386,14 @@ mod test {\n \n         let mut writer = MemWriter::new();\n         for i in ints.iter() {\n-            writer.write_be_i32(*i);\n+            writer.write_be_i32(*i).unwrap();\n         }\n \n         let mut reader = MemReader::new(writer.unwrap());\n         for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4) == *i as i64);\n+            assert!(reader.read_be_int_n(4).unwrap() == *i as i64);\n         }\n     }\n \n@@ -439,10 +403,10 @@ mod test {\n         let buf = ~[0x41, 0x02, 0x00, 0x00];\n \n         let mut writer = MemWriter::new();\n-        writer.write(buf);\n+        writer.write(buf).unwrap();\n \n         let mut reader = MemReader::new(writer.unwrap());\n-        let f = reader.read_be_f32();\n+        let f = reader.read_be_f32().unwrap();\n         assert!(f == 8.1250);\n     }\n \n@@ -451,12 +415,12 @@ mod test {\n         let f:f32 = 8.1250;\n \n         let mut writer = MemWriter::new();\n-        writer.write_be_f32(f);\n-        writer.write_le_f32(f);\n+        writer.write_be_f32(f).unwrap();\n+        writer.write_le_f32(f).unwrap();\n \n         let mut reader = MemReader::new(writer.unwrap());\n-        assert!(reader.read_be_f32() == 8.1250);\n-        assert!(reader.read_le_f32() == 8.1250);\n+        assert!(reader.read_be_f32().unwrap() == 8.1250);\n+        assert!(reader.read_le_f32().unwrap() == 8.1250);\n     }\n \n     #[test]"}, {"sha": "ef1b1a56ec0e0091a00ff580e8d634a5e8080c92", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 357, "deletions": 412, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -14,11 +14,11 @@ This module provides a set of functions and traits for working\n with regular files & directories on a filesystem.\n \n At the top-level of the module are a set of freestanding functions, associated\n-with various filesystem operations. They all operate on a `Path` object.\n+with various filesystem operations. They all operate on `Path` objects.\n \n All operations in this module, including those as part of `File` et al\n-block the task during execution. Most will raise `std::io::io_error`\n-conditions in the event of failure.\n+block the task during execution. In the event of failure, all functions/methods\n+will return an `IoResult` type with an `Err` value.\n \n Also included in this module is an implementation block on the `Path` object\n defined in `std::path::Path`. The impl adds useful methods about inspecting the\n@@ -27,21 +27,25 @@ particular bits of it, etc.\n \n # Example\n \n-    use std::io::{File, fs};\n+```rust\n+# #[allow(unused_must_use)];\n+use std::io::{File, fs};\n \n-    let path = Path::new(\"foo.txt\");\n+let path = Path::new(\"foo.txt\");\n \n-    // create the file, whether it exists or not\n-    let mut file = File::create(&path);\n-    file.write(bytes!(\"foobar\"));\n+// create the file, whether it exists or not\n+let mut file = File::create(&path);\n+file.write(bytes!(\"foobar\"));\n+# drop(file);\n \n-    // open the file in read-only mode\n-    let mut file = File::open(&path);\n-    file.read_to_end();\n+// open the file in read-only mode\n+let mut file = File::open(&path);\n+file.read_to_end();\n \n-    println!(\"{}\", path.stat().size);\n-    fs::symlink(&path, &Path::new(\"bar.txt\"));\n-    fs::unlink(&path);\n+println!(\"{}\", path.stat().unwrap().size);\n+# drop(file);\n+fs::unlink(&path);\n+```\n \n */\n \n@@ -50,7 +54,7 @@ use clone::Clone;\n use iter::Iterator;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n-            FileMode, FileAccess, FileStat, io_error, FilePermission};\n+            FileMode, FileAccess, FileStat, IoResult, FilePermission};\n use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n@@ -64,11 +68,12 @@ use vec::{OwnedVector, ImmutableVector};\n /// Can be constructed via `File::open()`, `File::create()`, and\n /// `File::open_mode()`.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This type will raise an io_error condition if operations are attempted against\n-/// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `File::open_mode()`.\n+/// This type will return errors as an `IoResult<T>` if operations are\n+/// attempted against it for which its underlying file descriptor was not\n+/// configured at creation time, via the `FileAccess` parameter to\n+/// `File::open_mode()`.\n pub struct File {\n     priv fd: ~RtioFileStream,\n     priv path: Path,\n@@ -81,22 +86,19 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::{File, io_error, Open, ReadWrite};\n+    /// ```rust,should_fail\n+    /// use std::io::{File, Open, ReadWrite};\n     ///\n-    ///     let p = Path::new(\"/some/file/path.txt\");\n+    /// let p = Path::new(\"/some/file/path.txt\");\n     ///\n-    ///     io_error::cond.trap(|_| {\n-    ///         // hoo-boy...\n-    ///     }).inside(|| {\n-    ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n-    ///             Some(s) => s,\n-    ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n-    ///         };\n-    ///         // do some stuff with that file\n+    /// let file = match File::open_mode(&p, Open, ReadWrite) {\n+    ///     Ok(f) => f,\n+    ///     Err(e) => fail!(\"file error: {}\", e),\n+    /// };\n+    /// // do some stuff with that file\n     ///\n-    ///         // the file will be closed at the end of this block\n-    ///     })\n-    ///     // ..\n+    /// // the file will be closed at the end of this block\n+    /// ```\n     ///\n     /// `FileMode` and `FileAccess` provide information about the permissions\n     /// context in which a given stream is created. More information about them\n@@ -106,20 +108,20 @@ impl File {\n     ///\n     /// Note that, with this function, a `File` is returned regardless of the\n     /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-    /// `File` opened as `Read` will raise an `io_error` condition at runtime).\n+    /// `File` opened as `Read` will return an error at runtime).\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n-    /// This function will raise an `io_error` condition under a number of\n-    /// different circumstances, to include but not limited to:\n+    /// This function will return an error under a number of different\n+    /// circumstances, to include but not limited to:\n     ///\n     /// * Opening a file that does not exist with `Read` access.\n     /// * Attempting to open a file with a `FileAccess` that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n-                     access: FileAccess) -> Option<File> {\n+                     access: FileAccess) -> IoResult<File> {\n         LocalIo::maybe_raise(|io| {\n             io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n                 File {\n@@ -139,10 +141,12 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::File;\n+    /// ```rust\n+    /// use std::io::File;\n     ///\n-    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n-    pub fn open(path: &Path) -> Option<File> {\n+    /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n+    /// ```\n+    pub fn open(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Open, Read)\n     }\n \n@@ -154,11 +158,16 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::File;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::io::File;\n     ///\n-    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n-    ///     f.write(bytes!(\"This is a sample file\"));\n-    pub fn create(path: &Path) -> Option<File> {\n+    /// let mut f = File::create(&Path::new(\"foo.txt\"));\n+    /// f.write(bytes!(\"This is a sample file\"));\n+    /// # drop(f);\n+    /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n+    /// ```\n+    pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n     }\n \n@@ -170,24 +179,16 @@ impl File {\n     /// Synchronizes all modifications to this file to its permanent storage\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn fsync(&mut self) {\n-        let _ = self.fd.fsync().map_err(|e| io_error::cond.raise(e));\n+    pub fn fsync(&mut self) -> IoResult<()> {\n+        self.fd.fsync()\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n-    pub fn datasync(&mut self) {\n-        let _ = self.fd.datasync().map_err(|e| io_error::cond.raise(e));\n+    pub fn datasync(&mut self) -> IoResult<()> {\n+        self.fd.datasync()\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -198,12 +199,8 @@ impl File {\n     /// be shrunk. If it is greater than the current file's size, then the file\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n-    ///\n-    /// # Errors\n-    ///\n-    /// On error, this function will raise on the `io_error` condition.\n-    pub fn truncate(&mut self, size: i64) {\n-        let _ = self.fd.truncate(size).map_err(|e| io_error::cond.raise(e));\n+    pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n+        self.fd.truncate(size)\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -219,24 +216,25 @@ impl File {\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     fs::unlink(&p);\n-///     // if we made it here without failing, then the\n-///     // unlink operation was successful\n+/// let p = Path::new(\"/some/file/path.txt\");\n+/// fs::unlink(&p);\n+/// ```\n ///\n /// Note that, just because an unlink call was successful, it is not\n /// guaranteed that a file is immediately deleted (e.g. depending on\n /// platform, other open file descriptors may prevent immediate removal)\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise an `io_error` condition if the path points to a\n-/// directory, the user lacks permissions to remove the file, or if some\n-/// other filesystem-level error occurs.\n-pub fn unlink(path: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()));\n+/// This function will return an error if the path points to a directory, the\n+/// user lacks permissions to remove the file, or if some other filesystem-level\n+/// error occurs.\n+pub fn unlink(path: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -249,80 +247,59 @@ pub fn unlink(path: &Path) {\n ///\n /// # Example\n ///\n-///     use std::io;\n-///     use std::io::fs;\n+/// ```rust\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     match io::result(|| fs::stat(&p)) {\n-///         Ok(stat) => { /* ... */ }\n-///         Err(e) => { /* handle error */ }\n-///     }\n+/// let p = Path::new(\"/some/file/path.txt\");\n+/// match fs::stat(&p) {\n+///     Ok(stat) => { /* ... */ }\n+///     Err(e) => { /* handle error */ }\n+/// }\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks the\n-/// requisite permissions to perform a `stat` call on the given path or if\n-/// there is no entry in the filesystem at the provided path.\n-pub fn stat(path: &Path) -> FileStat {\n+/// This call will return an error if the user lacks the requisite permissions\n+/// to perform a `stat` call on the given path or if there is no entry in the\n+/// filesystem at the provided path.\n+pub fn stat(path: &Path) -> IoResult<FileStat> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_stat(&path.to_c_str())\n-    }).unwrap_or_else(dummystat)\n-}\n-\n-fn dummystat() -> FileStat {\n-    FileStat {\n-        path: Path::new(\"\"),\n-        size: 0,\n-        kind: io::TypeFile,\n-        perm: 0,\n-        created: 0,\n-        modified: 0,\n-        accessed: 0,\n-        unstable: io::UnstableFileStat {\n-            device: 0,\n-            inode: 0,\n-            rdev: 0,\n-            nlink: 0,\n-            uid: 0,\n-            gid: 0,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n+    })\n }\n \n /// Perform the same operation as the `stat` function, except that this\n /// function does not traverse through symlinks. This will return\n /// information about the symlink file instead of the file that it points\n /// to.\n ///\n-/// # Errors\n+/// # Error\n ///\n /// See `stat`\n-pub fn lstat(path: &Path) -> FileStat {\n+pub fn lstat(path: &Path) -> IoResult<FileStat> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_lstat(&path.to_c_str())\n-    }).unwrap_or_else(dummystat)\n+    })\n }\n \n /// Rename a file or directory to a new name.\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n-///     // Oh boy, nothing was raised!\n+/// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n-pub fn rename(from: &Path, to: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n+/// Will return an error if the provided `path` doesn't exist, the process lacks\n+/// permissions to view the contents, or if some other intermittent I/O error\n+/// occurs.\n+pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()))\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -333,15 +310,17 @@ pub fn rename(from: &Path, to: &Path) {\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n-///     // Oh boy, nothing was raised!\n+/// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition is the following situations, but is\n-/// not limited to just these cases:\n+/// Will return an error in the following situations, but is not limited to\n+/// just these cases:\n ///\n /// * The `from` path is not a file\n /// * The `from` file does not exist\n@@ -351,165 +330,167 @@ pub fn rename(from: &Path, to: &Path) {\n /// Note that this copy is not atomic in that once the destination is\n /// ensured to not exist, there is nothing preventing the destination from\n /// being created and then destroyed by this operation.\n-pub fn copy(from: &Path, to: &Path) {\n+pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     if !from.is_file() {\n-        return io_error::cond.raise(IoError {\n+        return Err(IoError {\n             kind: io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n             detail: None,\n-        });\n+        })\n     }\n \n-    let mut reader = match File::open(from) { Some(f) => f, None => return };\n-    let mut writer = match File::create(to) { Some(f) => f, None => return };\n+    let mut reader = if_ok!(File::open(from));\n+    let mut writer = if_ok!(File::create(to));\n     let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n \n     loop {\n-        match reader.read(buf) {\n-            Some(amt) => writer.write(buf.slice_to(amt)),\n-            None => break\n-        }\n+        let amt = match reader.read(buf) {\n+            Ok(n) => n,\n+            Err(ref e) if e.kind == io::EndOfFile => { break }\n+            Err(e) => return Err(e)\n+        };\n+        if_ok!(writer.write(buf.slice_to(amt)));\n     }\n \n-    chmod(to, from.stat().perm)\n+    chmod(to, if_ok!(from.stat()).perm)\n }\n \n /// Changes the permission mode bits found on a file or a directory. This\n /// function takes a mask from the `io` module\n ///\n /// # Example\n ///\n-///     use std::io;\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io;\n+/// use std::io::fs;\n ///\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n-///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n-///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+/// fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n+/// fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// If this function encounters an I/O error, it will raise on the `io_error`\n-/// condition. Some possible error situations are not having the permission to\n+/// If this function encounters an I/O error, it will return an `Err` value.\n+/// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n-pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n+pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n-pub fn chown(path: &Path, uid: int, gid: int) {\n-    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n+pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n-pub fn link(src: &Path, dst: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n-pub fn symlink(src: &Path, dst: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition on failure. Failure\n-/// conditions include reading a file that does not exist or reading a file\n-/// which is not a symlink.\n-pub fn readlink(path: &Path) -> Option<Path> {\n+/// This function will return an error on failure. Failure conditions include\n+/// reading a file that does not exist or reading a file which is not a symlink.\n+pub fn readlink(path: &Path) -> IoResult<Path> {\n     LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n ///\n /// # Example\n ///\n-///     use std::libc::S_IRWXU;\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io;\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::mkdir(&p, S_IRWXU as int);\n-///     // If we got here, our directory exists! Hooray!\n+/// let p = Path::new(\"/some/dir\");\n+/// fs::mkdir(&p, io::UserRWX);\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to make a new directory at the provided path, or if the directory already\n-/// exists.\n-pub fn mkdir(path: &Path, mode: FilePermission) {\n-    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n+/// This call will return an error if the user lacks permissions to make a new\n+/// directory at the provided path, or if the directory already exists.\n+pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode))\n }\n \n /// Remove an existing, empty directory\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::rmdir(&p);\n-///     // good riddance, you mean ol' directory\n+/// let p = Path::new(\"/some/dir\");\n+/// fs::rmdir(&p);\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to remove the directory at the provided path, or if the directory isn't\n-/// empty.\n-pub fn rmdir(path: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()));\n+/// This call will return an error if the user lacks permissions to remove the\n+/// directory at the provided path, or if the directory isn't empty.\n+pub fn rmdir(path: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n-///\n-///     // one possible implementation of fs::walk_dir only visiting files\n-///     fn visit_dirs(dir: &Path, cb: |&Path|) {\n-///         if dir.is_dir() {\n-///             let contents = fs::readdir(dir).unwrap();\n-///             for entry in contents.iter() {\n-///                 if entry.is_dir() { visit_dirs(entry, cb); }\n-///                 else { cb(entry); }\n+/// ```rust\n+/// use std::io;\n+/// use std::io::fs;\n+///\n+/// // one possible implementation of fs::walk_dir only visiting files\n+/// fn visit_dirs(dir: &Path, cb: |&Path|) -> io::IoResult<()> {\n+///     if dir.is_dir() {\n+///         let contents = if_ok!(fs::readdir(dir));\n+///         for entry in contents.iter() {\n+///             if entry.is_dir() {\n+///                 if_ok!(visit_dirs(entry, |p| cb(p)));\n+///             } else {\n+///                 cb(entry);\n ///             }\n ///         }\n-///         else { fail!(\"nope\"); }\n+///         Ok(())\n+///     } else {\n+///         Err(io::standard_error(io::InvalidInput))\n ///     }\n+/// }\n+/// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n-pub fn readdir(path: &Path) -> ~[Path] {\n+/// Will return an error if the provided `from` doesn't exist, the process lacks\n+/// permissions to view the contents or if the `path` points at a non-directory\n+/// file\n+pub fn readdir(path: &Path) -> IoResult<~[Path]> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_readdir(&path.to_c_str(), 0)\n-    }).unwrap_or_else(|| ~[])\n+    })\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in a top-down order.\n-pub fn walk_dir(path: &Path) -> Directories {\n-    Directories { stack: readdir(path) }\n+pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n+    Ok(Directories { stack: if_ok!(readdir(path)) })\n }\n \n /// An iterator which walks over a directory\n@@ -522,7 +503,10 @@ impl Iterator<Path> for Directories {\n         match self.stack.shift() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    self.stack.push_all_move(readdir(&path));\n+                    match readdir(&path) {\n+                        Ok(dirs) => { self.stack.push_all_move(dirs); }\n+                        Err(..) => {}\n+                    }\n                 }\n                 Some(path)\n             }\n@@ -534,112 +518,83 @@ impl Iterator<Path> for Directories {\n /// Recursively create a directory and all of its parent components if they\n /// are missing.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens, see `fs::mkdir` for more information about error conditions\n-/// and performance.\n-pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n+/// This function will return an `Err` value if an error happens, see\n+/// `fs::mkdir` for more information about error conditions and performance.\n+pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     // tjc: if directory exists but with different permissions,\n     // should we return false?\n     if path.is_dir() {\n-        return\n+        return Ok(())\n     }\n     if path.filename().is_some() {\n-        mkdir_recursive(&path.dir_path(), mode);\n+        if_ok!(mkdir_recursive(&path.dir_path(), mode));\n     }\n     mkdir(path, mode)\n }\n \n /// Removes a directory at this path, after removing all its contents. Use\n /// carefully!\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens. See `file::unlink` and `fs::readdir` for possible error\n-/// conditions.\n-pub fn rmdir_recursive(path: &Path) {\n-    let children = readdir(path);\n+/// This function will return an `Err` value if an error happens. See\n+/// `file::unlink` and `fs::readdir` for possible error conditions.\n+pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n+    let children = if_ok!(readdir(path));\n     for child in children.iter() {\n         if child.is_dir() {\n-            rmdir_recursive(child);\n+            if_ok!(rmdir_recursive(child));\n         } else {\n-            unlink(child);\n+            if_ok!(unlink(child));\n         }\n     }\n     // Directory should now be empty\n-    rmdir(path);\n+    rmdir(path)\n }\n \n /// Changes the timestamps for a file's last modification and access time.\n /// The file at the path specified will have its last access time set to\n /// `atime` and its modification time set to `mtime`. The times specified should\n /// be in milliseconds.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens.\n // FIXME(#10301) these arguments should not be u64\n-pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n+pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime))\n }\n \n impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         match self.fd.read(buf) {\n             Ok(read) => {\n                 self.last_nread = read;\n                 match read {\n-                    0 => None,\n-                    _ => Some(read as uint)\n+                    0 => Err(io::standard_error(io::EndOfFile)),\n+                    _ => Ok(read as uint)\n                 }\n             },\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != io::EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n+            Err(e) => Err(e),\n         }\n     }\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.fd.write(buf) {\n-            Ok(()) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.fd.write(buf) }\n }\n \n impl Seek for File {\n-    fn tell(&self) -> u64 {\n-        let res = self.fd.tell();\n-        match res {\n-            Ok(cursor) => cursor,\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return -1;\n-            }\n-        }\n+    fn tell(&self) -> IoResult<u64> {\n+        self.fd.tell()\n     }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n-                ()\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n+                Ok(())\n             }\n+            Err(e) => Err(e),\n         }\n     }\n }\n@@ -650,29 +605,29 @@ impl path::Path {\n     /// Consult the `file::stat` documentation for more info.\n     ///\n     /// This call preserves identical runtime/error semantics with `file::stat`.\n-    pub fn stat(&self) -> FileStat { stat(self) }\n+    pub fn stat(&self) -> IoResult<FileStat> { stat(self) }\n \n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. This will return true if the path points to either a\n     /// directory or a file.\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn exists(&self) -> bool {\n-        io::result(|| self.stat()).is_ok()\n+        self.stat().is_ok()\n     }\n \n     /// Whether the underlying implementation (be it a file path, or something\n     /// else) points at a \"regular file\" on the FS. Will return false for paths\n     /// to non-existent locations or directories or other non-regular files\n     /// (named pipes, etc).\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn is_file(&self) -> bool {\n-        match io::result(|| self.stat()) {\n+        match self.stat() {\n             Ok(s) => s.kind == io::TypeFile,\n             Err(..) => false\n         }\n@@ -683,11 +638,11 @@ impl path::Path {\n     /// Will return false for paths to non-existent locations or if the item is\n     /// not a directory (eg files, named pipes, links, etc)\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn is_dir(&self) -> bool {\n-        match io::result(|| self.stat()) {\n+        match self.stat() {\n             Ok(s) => s.kind == io::TypeDirectory,\n             Err(..) => false\n         }\n@@ -698,8 +653,7 @@ impl path::Path {\n #[allow(unused_imports)]\n mod test {\n     use prelude::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-             ReadWrite};\n+    use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite};\n     use io;\n     use str;\n     use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n@@ -729,15 +683,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            io::fs::rmdir_recursive(p);\n+            io::fs::rmdir_recursive(p).unwrap();\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        io::fs::mkdir(&ret, io::UserRWX);\n+        io::fs::mkdir(&ret, io::UserRWX).unwrap();\n         TempDir(ret)\n     }\n \n@@ -747,7 +701,7 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n         {\n             let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            write_stream.write(message.as_bytes());\n+            write_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n@@ -758,30 +712,20 @@ mod test {\n             };\n             assert_eq!(read_str, message.to_owned());\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| {\n-            let result = File::open_mode(filename, Open, Read);\n-            assert!(result.is_none());\n-        });\n-        assert!(called);\n+        let result = File::open_mode(filename, Open, Read);\n+        assert!(result.is_err());\n     })\n \n     iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-        let mut called = false;\n-        io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| unlink(filename));\n-        assert!(called);\n+        assert!(unlink(filename).is_err());\n     })\n \n     iotest!(fn file_test_io_non_positional_read() {\n@@ -791,20 +735,20 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n+            rw_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n                 let read_buf = read_mem.mut_slice(0, 4);\n-                read_stream.read(read_buf);\n+                read_stream.read(read_buf).unwrap();\n             }\n             {\n                 let read_buf = read_mem.mut_slice(4, 8);\n-                read_stream.read(read_buf);\n+                read_stream.read(read_buf).unwrap();\n             }\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n     })\n@@ -819,16 +763,16 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(message.as_bytes());\n+            rw_stream.write(message.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.seek(set_cursor as i64, SeekSet);\n-            tell_pos_pre_read = read_stream.tell();\n-            read_stream.read(read_mem);\n-            tell_pos_post_read = read_stream.tell();\n+            read_stream.seek(set_cursor as i64, SeekSet).unwrap();\n+            tell_pos_pre_read = read_stream.tell().unwrap();\n+            read_stream.read(read_mem).unwrap();\n+            tell_pos_post_read = read_stream.tell().unwrap();\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n@@ -845,15 +789,15 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n-            rw_stream.seek(seek_idx as i64, SeekSet);\n-            rw_stream.write(overwrite_msg.as_bytes());\n+            rw_stream.write(initial_msg.as_bytes()).unwrap();\n+            rw_stream.seek(seek_idx as i64, SeekSet).unwrap();\n+            rw_stream.write(overwrite_msg.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            read_stream.read(read_mem);\n+            read_stream.read(read_mem).unwrap();\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str == final_msg.to_owned());\n     })\n@@ -869,24 +813,24 @@ mod test {\n         let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n         {\n             let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            rw_stream.write(initial_msg.as_bytes());\n+            rw_stream.write(initial_msg.as_bytes()).unwrap();\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n \n-            read_stream.seek(-4, SeekEnd);\n-            read_stream.read(read_mem);\n+            read_stream.seek(-4, SeekEnd).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n \n-            read_stream.seek(-9, SeekCur);\n-            read_stream.read(read_mem);\n+            read_stream.seek(-9, SeekCur).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n \n-            read_stream.seek(0, SeekSet);\n-            read_stream.read(read_mem);\n+            read_stream.seek(0, SeekSet).unwrap();\n+            read_stream.read(read_mem).unwrap();\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_file() {\n@@ -895,83 +839,83 @@ mod test {\n         {\n             let mut fs = File::open_mode(filename, Open, ReadWrite);\n             let msg = \"hw\";\n-            fs.write(msg.as_bytes());\n+            fs.write(msg.as_bytes()).unwrap();\n         }\n-        let stat_res = stat(filename);\n+        let stat_res = stat(filename).unwrap();\n         assert_eq!(stat_res.kind, io::TypeFile);\n-        unlink(filename);\n+        unlink(filename).unwrap();\n     })\n \n     iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        mkdir(filename, io::UserRWX);\n-        let stat_res = filename.stat();\n+        mkdir(filename, io::UserRWX).unwrap();\n+        let stat_res = filename.stat().unwrap();\n         assert!(stat_res.kind == io::TypeDirectory);\n-        rmdir(filename);\n+        rmdir(filename).unwrap();\n     })\n \n     iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         assert!(dir.is_file() == false);\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n     })\n \n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        File::create(file).write(bytes!(\"foo\"));\n+        File::create(file).write(bytes!(\"foo\")).unwrap();\n         assert!(file.exists());\n-        unlink(file);\n+        unlink(file).unwrap();\n         assert!(!file.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n         assert!(!dir.exists());\n     })\n \n     iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        mkdir(dir, io::UserRWX);\n+        mkdir(dir, io::UserRWX).unwrap();\n         let prefix = \"foo\";\n         for n in range(0,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = File::create(&f);\n+            let mut w = File::create(&f).unwrap();\n             let msg_str = (prefix + n.to_str().to_owned()).to_owned();\n             let msg = msg_str.as_bytes();\n-            w.write(msg);\n+            w.write(msg).unwrap();\n         }\n-        let files = readdir(dir);\n+        let files = readdir(dir).unwrap();\n         let mut mem = [0u8, .. 4];\n         for f in files.iter() {\n             {\n                 let n = f.filestem_str();\n-                File::open(f).read(mem);\n+                File::open(f).read(mem).unwrap();\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n                     Some(n) => prefix+n\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n             }\n-            unlink(f);\n+            unlink(f).unwrap();\n         }\n-        rmdir(dir);\n+        rmdir(dir).unwrap();\n     })\n \n     iotest!(fn recursive_mkdir_slash() {\n-        mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n+        mkdir_recursive(&Path::new(\"/\"), io::UserRWX).unwrap();\n     })\n \n     iotest!(fn unicode_path_is_dir() {\n@@ -982,12 +926,12 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        mkdir(&dirpath, io::UserRWX);\n+        mkdir(&dirpath, io::UserRWX).unwrap();\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n         filepath.push(\"unicode-file-\\uac00\\u4e00\\u30fc\\u4f60\\u597d.rs\");\n-        File::create(&filepath); // ignore return; touch only\n+        File::create(&filepath).unwrap(); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n     })\n@@ -999,15 +943,15 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        mkdir(&unicode, io::UserRWX);\n+        mkdir(&unicode, io::UserRWX).unwrap();\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n \n     iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n-        match io::result(|| copy(&from, &to)) {\n+        match copy(&from, &to) {\n             Ok(..) => fail!(),\n             Err(..) => {\n                 assert!(!from.exists());\n@@ -1021,20 +965,20 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(bytes!(\"hello\"));\n-        copy(&input, &out);\n-        let contents = File::open(&out).read_to_end();\n+        File::create(&input).write(bytes!(\"hello\")).unwrap();\n+        copy(&input, &out).unwrap();\n+        let contents = File::open(&out).read_to_end().unwrap();\n         assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n \n-        assert_eq!(input.stat().perm, out.stat().perm);\n+        assert_eq!(input.stat().unwrap().perm, out.stat().unwrap().perm);\n     })\n \n     iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        File::create(&out);\n-        match io::result(|| copy(&out, tmpdir.path())) {\n+        File::create(&out).unwrap();\n+        match copy(&out, tmpdir.path()) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n     })\n@@ -1044,19 +988,19 @@ mod test {\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n \n-        File::create(&input).write(\"foo\".as_bytes());\n-        File::create(&output).write(\"bar\".as_bytes());\n-        copy(&input, &output);\n+        File::create(&input).write(\"foo\".as_bytes()).unwrap();\n+        File::create(&output).write(\"bar\".as_bytes()).unwrap();\n+        copy(&input, &output).unwrap();\n \n-        assert_eq!(File::open(&output).read_to_end(),\n+        assert_eq!(File::open(&output).read_to_end().unwrap(),\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n     iotest!(fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        match io::result(|| copy(tmpdir.path(), &out)) {\n+        match copy(tmpdir.path(), &out) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n@@ -1067,13 +1011,13 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input);\n-        chmod(&input, io::UserRead);\n-        copy(&input, &out);\n-        assert!(out.stat().perm & io::UserWrite == 0);\n+        File::create(&input).unwrap();\n+        chmod(&input, io::UserRead).unwrap();\n+        copy(&input, &out).unwrap();\n+        assert!(out.stat().unwrap().perm & io::UserWrite == 0);\n \n-        chmod(&input, io::UserFile);\n-        chmod(&out, io::UserFile);\n+        chmod(&input, io::UserFile).unwrap();\n+        chmod(&out, io::UserFile).unwrap();\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1082,26 +1026,27 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes());\n-        symlink(&input, &out);\n+        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n+        symlink(&input, &out).unwrap();\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeSymlink);\n+            assert_eq!(lstat(&out).unwrap().kind, io::TypeSymlink);\n         }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n+        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+                   (bytes!(\"foobar\")).to_owned());\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n     iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n-        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n+        symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")).unwrap();\n         assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n     })\n \n     iotest!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n-        match io::result(|| readlink(tmpdir.path())) {\n+        match readlink(tmpdir.path()) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n@@ -1112,22 +1057,23 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        File::create(&input).write(\"foobar\".as_bytes());\n-        link(&input, &out);\n+        File::create(&input).write(\"foobar\".as_bytes()).unwrap();\n+        link(&input, &out).unwrap();\n         if cfg!(not(windows)) {\n-            assert_eq!(lstat(&out).kind, io::TypeFile);\n-            assert_eq!(stat(&out).unstable.nlink, 2);\n+            assert_eq!(lstat(&out).unwrap().kind, io::TypeFile);\n+            assert_eq!(stat(&out).unwrap().unstable.nlink, 2);\n         }\n-        assert_eq!(stat(&out).size, stat(&input).size);\n-        assert_eq!(File::open(&out).read_to_end(), (bytes!(\"foobar\")).to_owned());\n+        assert_eq!(stat(&out).unwrap().size, stat(&input).unwrap().size);\n+        assert_eq!(File::open(&out).read_to_end().unwrap(),\n+                   (bytes!(\"foobar\")).to_owned());\n \n         // can't link to yourself\n-        match io::result(|| link(&input, &input)) {\n+        match link(&input, &input) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n         // can't link to something that doesn't exist\n-        match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n+        match link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n@@ -1137,29 +1083,29 @@ mod test {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n-        File::create(&file);\n-        assert!(stat(&file).perm & io::UserWrite == io::UserWrite);\n-        chmod(&file, io::UserRead);\n-        assert!(stat(&file).perm & io::UserWrite == 0);\n+        File::create(&file).unwrap();\n+        assert!(stat(&file).unwrap().perm & io::UserWrite == io::UserWrite);\n+        chmod(&file, io::UserRead).unwrap();\n+        assert!(stat(&file).unwrap().perm & io::UserWrite == 0);\n \n-        match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n+        match chmod(&tmpdir.join(\"foo\"), io::UserRWX) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n \n-        chmod(&file, io::UserFile);\n+        chmod(&file, io::UserFile).unwrap();\n     })\n \n     iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.fsync();\n-        file.datasync();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n-        file.datasync();\n+        file.fsync().unwrap();\n+        file.datasync().unwrap();\n+        file.write(bytes!(\"foo\")).unwrap();\n+        file.fsync().unwrap();\n+        file.datasync().unwrap();\n         drop(file);\n     })\n \n@@ -1168,37 +1114,36 @@ mod test {\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = File::open_mode(&path, io::Open, io::ReadWrite).unwrap();\n-        file.write(bytes!(\"foo\"));\n-        file.fsync();\n+        file.write(bytes!(\"foo\")).unwrap();\n+        file.fsync().unwrap();\n \n         // Do some simple things with truncation\n-        assert_eq!(stat(&path).size, 3);\n-        file.truncate(10);\n-        assert_eq!(stat(&path).size, 10);\n-        file.write(bytes!(\"bar\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 10);\n-        assert_eq!(File::open(&path).read_to_end(),\n+        assert_eq!(stat(&path).unwrap().size, 3);\n+        file.truncate(10).unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 10);\n+        file.write(bytes!(\"bar\")).unwrap();\n+        file.fsync().unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 10);\n+        assert_eq!(File::open(&path).read_to_end().unwrap(),\n                    (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n-        file.truncate(2);\n-        assert_eq!(stat(&path).size, 2);\n-        file.write(bytes!(\"wut\"));\n-        file.fsync();\n-        assert_eq!(stat(&path).size, 9);\n-        assert_eq!(File::open(&path).read_to_end(),\n+        file.truncate(2).unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 2);\n+        file.write(bytes!(\"wut\")).unwrap();\n+        file.fsync().unwrap();\n+        assert_eq!(stat(&path).unwrap().size, 9);\n+        assert_eq!(File::open(&path).read_to_end().unwrap(),\n                    (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n         drop(file);\n     })\n \n     iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n-        match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n-                                            io::Read)) {\n+        match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n@@ -1208,46 +1153,46 @@ mod test {\n         File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write).unwrap();\n         File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite).unwrap();\n \n-        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes());\n+        File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()).unwrap();\n         File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read).unwrap();\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n                                         io::Read).unwrap();\n-            match io::result(|| f.write(\"wut\".as_bytes())) {\n+            match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => fail!(), Err(..) => {}\n             }\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Append,\n                                         io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n+            f.write(\"bar\".as_bytes()).unwrap();\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 6);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 6);\n         {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n                                         io::Write).unwrap();\n-            f.write(\"bar\".as_bytes());\n+            f.write(\"bar\".as_bytes()).unwrap();\n         }\n-        assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n+        assert_eq!(stat(&tmpdir.join(\"h\")).unwrap().size, 3);\n     })\n \n     #[test]\n     fn utime() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n-        File::create(&path);\n+        File::create(&path).unwrap();\n \n-        change_file_times(&path, 1000, 2000);\n-        assert_eq!(path.stat().accessed, 1000);\n-        assert_eq!(path.stat().modified, 2000);\n+        change_file_times(&path, 1000, 2000).unwrap();\n+        assert_eq!(path.stat().unwrap().accessed, 1000);\n+        assert_eq!(path.stat().unwrap().modified, 2000);\n     }\n \n     #[test]\n     fn utime_noexist() {\n         let tmpdir = tmpdir();\n \n-        match io::result(|| change_file_times(&tmpdir.join(\"a\"), 100, 200)) {\n+        match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }"}, {"sha": "395ece17eded6b94a53c7b9e78b81bfb76d8883f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 115, "deletions": 107, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -13,9 +13,10 @@\n use cmp::max;\n use cmp::min;\n use container::Container;\n-use option::{Option, Some, None};\n-use super::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, io_error,\n-            OtherIoError};\n+use option::None;\n+use result::{Err, Ok};\n+use io;\n+use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use vec;\n use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n \n@@ -24,6 +25,7 @@ use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::MemWriter;\n ///\n /// let mut w = MemWriter::new();\n@@ -59,7 +61,7 @@ impl MemWriter {\n }\n \n impl Writer for MemWriter {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // Make sure the internal buffer is as least as big as where we\n         // currently are\n         let difference = self.pos as i64 - self.buf.len() as i64;\n@@ -86,14 +88,15 @@ impl Writer for MemWriter {\n \n         // Bump us forward\n         self.pos += buf.len();\n+        Ok(())\n     }\n }\n \n // FIXME(#10432)\n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         // compute offset as signed and clamp to prevent overflow\n         let offset = match style {\n             SeekSet => { 0 }\n@@ -102,6 +105,7 @@ impl Seek for MemWriter {\n         } as i64;\n \n         self.pos = max(0, offset+pos) as uint;\n+        Ok(())\n     }\n }\n \n@@ -110,11 +114,12 @@ impl Seek for MemWriter {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::MemReader;\n ///\n /// let mut r = MemReader::new(~[0, 1, 2]);\n ///\n-/// assert_eq!(r.read_to_end(), ~[0, 1, 2]);\n+/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2]);\n /// ```\n pub struct MemReader {\n     priv buf: ~[u8],\n@@ -148,8 +153,8 @@ impl MemReader {\n }\n \n impl Reader for MemReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        if self.eof() { return None }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -161,28 +166,31 @@ impl Reader for MemReader {\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n \n-        return Some(write_len);\n+        return Ok(write_len);\n     }\n }\n \n impl Seek for MemReader {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n }\n \n impl Buffer for MemReader {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        Ok(self.buf.slice_from(self.pos))\n+    }\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n /// Writes to a fixed-size byte slice\n ///\n-/// If a write will not fit in the buffer, it raises the `io_error`\n-/// condition and does not write any data.\n+/// If a write will not fit in the buffer, it returns an error and does not\n+/// write any data.\n ///\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::BufWriter;\n ///\n /// let mut buf = [0, ..4];\n@@ -207,28 +215,28 @@ impl<'a> BufWriter<'a> {\n }\n \n impl<'a> Writer for BufWriter<'a> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // raises a condition if the entire write does not fit in the buffer\n         let max_size = self.buf.len();\n         if self.pos >= max_size || (self.pos + buf.len()) > max_size {\n-            io_error::cond.raise(IoError {\n-                kind: OtherIoError,\n+            return Err(IoError {\n+                kind: io::OtherIoError,\n                 desc: \"Trying to write past end of buffer\",\n                 detail: None\n-            });\n-            return;\n+            })\n         }\n \n         vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n         self.pos += buf.len();\n+        Ok(())\n     }\n }\n \n // FIXME(#10432)\n impl<'a> Seek for BufWriter<'a> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         // compute offset as signed and clamp to prevent overflow\n         let offset = match style {\n             SeekSet => { 0 }\n@@ -237,6 +245,7 @@ impl<'a> Seek for BufWriter<'a> {\n         } as i64;\n \n         self.pos = max(0, offset+pos) as uint;\n+        Ok(())\n     }\n }\n \n@@ -246,12 +255,13 @@ impl<'a> Seek for BufWriter<'a> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::BufReader;\n ///\n /// let mut buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(buf);\n ///\n-/// assert_eq!(r.read_to_end(), ~[0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2, 3]);\n /// ```\n pub struct BufReader<'a> {\n     priv buf: &'a [u8],\n@@ -274,8 +284,8 @@ impl<'a> BufReader<'a> {\n }\n \n impl<'a> Reader for BufReader<'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        if self.eof() { return None }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -287,18 +297,19 @@ impl<'a> Reader for BufReader<'a> {\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n \n-        return Some(write_len);\n+        return Ok(write_len);\n      }\n }\n \n impl<'a> Seek for BufReader<'a> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n }\n \n impl<'a> Buffer for BufReader<'a> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        Ok(self.buf.slice_from(self.pos))\n+    }\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n@@ -307,33 +318,34 @@ mod test {\n     use prelude::*;\n     use super::*;\n     use io::*;\n+    use io;\n \n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([0]);\n-        assert_eq!(writer.tell(), 1);\n-        writer.write([1, 2, 3]);\n-        writer.write([4, 5, 6, 7]);\n-        assert_eq!(writer.tell(), 8);\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([0]).unwrap();\n+        assert_eq!(writer.tell(), Ok(1));\n+        writer.write([1, 2, 3]).unwrap();\n+        writer.write([4, 5, 6, 7]).unwrap();\n+        assert_eq!(writer.tell(), Ok(8));\n         assert_eq!(writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7]);\n \n-        writer.seek(0, SeekSet);\n-        assert_eq!(writer.tell(), 0);\n-        writer.write([3, 4]);\n+        writer.seek(0, SeekSet).unwrap();\n+        assert_eq!(writer.tell(), Ok(0));\n+        writer.write([3, 4]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 3, 4, 5, 6, 7]);\n \n-        writer.seek(1, SeekCur);\n-        writer.write([0, 1]);\n+        writer.seek(1, SeekCur).unwrap();\n+        writer.write([0, 1]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 7]);\n \n-        writer.seek(-1, SeekEnd);\n-        writer.write([1, 2]);\n+        writer.seek(-1, SeekEnd).unwrap();\n+        writer.write([1, 2]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2]);\n \n-        writer.seek(1, SeekEnd);\n-        writer.write([1]);\n+        writer.seek(1, SeekEnd).unwrap();\n+        writer.write([1]).unwrap();\n         assert_eq!(writer.get_ref(), [3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1]);\n     }\n \n@@ -342,12 +354,12 @@ mod test {\n         let mut buf = [0 as u8, ..8];\n         {\n             let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([0]);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([1, 2, 3]);\n-            writer.write([4, 5, 6, 7]);\n-            assert_eq!(writer.tell(), 8);\n+            assert_eq!(writer.tell(), Ok(0));\n+            writer.write([0]).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n+            writer.write([1, 2, 3]).unwrap();\n+            writer.write([4, 5, 6, 7]).unwrap();\n+            assert_eq!(writer.tell(), Ok(8));\n         }\n         assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7]);\n     }\n@@ -357,24 +369,24 @@ mod test {\n         let mut buf = [0 as u8, ..8];\n         {\n             let mut writer = BufWriter::new(buf);\n-            assert_eq!(writer.tell(), 0);\n-            writer.write([1]);\n-            assert_eq!(writer.tell(), 1);\n+            assert_eq!(writer.tell(), Ok(0));\n+            writer.write([1]).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n \n-            writer.seek(2, SeekSet);\n-            assert_eq!(writer.tell(), 2);\n-            writer.write([2]);\n-            assert_eq!(writer.tell(), 3);\n+            writer.seek(2, SeekSet).unwrap();\n+            assert_eq!(writer.tell(), Ok(2));\n+            writer.write([2]).unwrap();\n+            assert_eq!(writer.tell(), Ok(3));\n \n-            writer.seek(-2, SeekCur);\n-            assert_eq!(writer.tell(), 1);\n-            writer.write([3]);\n-            assert_eq!(writer.tell(), 2);\n+            writer.seek(-2, SeekCur).unwrap();\n+            assert_eq!(writer.tell(), Ok(1));\n+            writer.write([3]).unwrap();\n+            assert_eq!(writer.tell(), Ok(2));\n \n-            writer.seek(-1, SeekEnd);\n-            assert_eq!(writer.tell(), 7);\n-            writer.write([4]);\n-            assert_eq!(writer.tell(), 8);\n+            writer.seek(-1, SeekEnd).unwrap();\n+            assert_eq!(writer.tell(), Ok(7));\n+            writer.write([4]).unwrap();\n+            assert_eq!(writer.tell(), Ok(8));\n \n         }\n         assert_eq!(buf, [1, 3, 2, 0, 0, 0, 0, 4]);\n@@ -384,100 +396,96 @@ mod test {\n     fn test_buf_writer_error() {\n         let mut buf = [0 as u8, ..2];\n         let mut writer = BufWriter::new(buf);\n-        writer.write([0]);\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, OtherIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.write([0, 0]);\n-        });\n-        assert!(called);\n+        writer.write([0]).unwrap();\n+\n+        match writer.write([0, 0]) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::OtherIoError),\n+        }\n     }\n \n     #[test]\n     fn test_mem_reader() {\n         let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.tell(), Ok(1));\n         assert_eq!(buf, [0]);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n+        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.tell(), Ok(5));\n         assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n+        assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert_eq!(reader.read(buf), None);\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_buf_reader() {\n         let in_buf = ~[0, 1, 2, 3, 4, 5, 6, 7];\n         let mut reader = BufReader::new(in_buf);\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Some(0));\n-        assert_eq!(reader.tell(), 0);\n+        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Some(1));\n-        assert_eq!(reader.tell(), 1);\n+        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.tell(), Ok(1));\n         assert_eq!(buf, [0]);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Some(4));\n-        assert_eq!(reader.tell(), 5);\n+        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.tell(), Ok(5));\n         assert_eq!(buf, [1, 2, 3, 4]);\n-        assert_eq!(reader.read(buf), Some(3));\n+        assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), [5, 6, 7]);\n-        assert_eq!(reader.read(buf), None);\n+        assert!(reader.read(buf).is_err());\n     }\n \n     #[test]\n     fn test_read_char() {\n         let b = bytes!(\"Vi\u1ec7t\");\n         let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), Some('V'));\n-        assert_eq!(r.read_char(), Some('i'));\n-        assert_eq!(r.read_char(), Some('\u1ec7'));\n-        assert_eq!(r.read_char(), Some('t'));\n-        assert_eq!(r.read_char(), None);\n+        assert_eq!(r.read_char(), Ok('V'));\n+        assert_eq!(r.read_char(), Ok('i'));\n+        assert_eq!(r.read_char(), Ok('\u1ec7'));\n+        assert_eq!(r.read_char(), Ok('t'));\n+        assert!(r.read_char().is_err());\n     }\n \n     #[test]\n     fn test_read_bad_char() {\n         let b = bytes!(0x80);\n         let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), None);\n+        assert!(r.read_char().is_err());\n     }\n \n     #[test]\n     fn test_write_strings() {\n         let mut writer = MemWriter::new();\n-        writer.write_str(\"testing\");\n-        writer.write_line(\"testing\");\n-        writer.write_str(\"testing\");\n+        writer.write_str(\"testing\").unwrap();\n+        writer.write_line(\"testing\").unwrap();\n+        writer.write_str(\"testing\").unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str(), ~\"testingtesting\\ntesting\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"testingtesting\\ntesting\");\n     }\n \n     #[test]\n     fn test_write_char() {\n         let mut writer = MemWriter::new();\n-        writer.write_char('a');\n-        writer.write_char('\\n');\n-        writer.write_char('\u1ec7');\n+        writer.write_char('a').unwrap();\n+        writer.write_char('\\n').unwrap();\n+        writer.write_char('\u1ec7').unwrap();\n         let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_str(), ~\"a\\n\u1ec7\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"a\\n\u1ec7\");\n     }\n \n     #[test]\n     fn test_read_whole_string_bad() {\n         let buf = [0xff];\n         let mut r = BufReader::new(buf);\n-        match result(|| r.read_to_str()) {\n+        match r.read_to_str() {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }"}, {"sha": "7690c88478fdeac333ef453f610cf093e9952a4f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 337, "deletions": 395, "changes": 732, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -29,7 +29,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::stdin;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let mut stdin = BufferedReader::new(stdin());\n     for line in stdin.lines() {\n         print!(\"{}\", line);\n@@ -41,16 +40,15 @@ Some examples of obvious things you might want to do\n     ```rust\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n     ```\n \n * Write a line to a file\n \n     ```rust\n+    # #[allow(unused_must_use)];\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let mut file = File::create(&Path::new(\"message.txt\"));\n     file.write(bytes!(\"hello, file!\\n\"));\n     # drop(file);\n@@ -63,7 +61,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     for line in file.lines() {\n@@ -77,7 +74,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     let lines: ~[~str] = file.lines().collect();\n@@ -88,10 +84,10 @@ Some examples of obvious things you might want to do\n   `write_str` and `write_line` methods.\n \n     ```rust,should_fail\n+    # #[allow(unused_must_use)];\n     use std::io::net::ip::SocketAddr;\n     use std::io::net::tcp::TcpStream;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n     let mut socket = TcpStream::connect(addr).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n@@ -168,72 +164,51 @@ asynchronous request completes.\n # Error Handling\n \n I/O is an area where nearly every operation can result in unexpected\n-errors. It should allow errors to be handled efficiently.\n-It needs to be convenient to use I/O when you don't care\n-about dealing with specific errors.\n+errors. Errors should be painfully visible when they happen, and handling them\n+should be easy to work with. It should be convenient to handle specific I/O\n+errors, and it should also be convenient to not deal with I/O errors.\n \n Rust's I/O employs a combination of techniques to reduce boilerplate\n while still providing feedback about errors. The basic strategy:\n \n-* Errors are fatal by default, resulting in task failure\n-* Errors raise the `io_error` condition which provides an opportunity to inspect\n-  an IoError object containing details.\n-* Return values must have a sensible null or zero value which is returned\n-  if a condition is handled successfully. This may be an `Option`, an empty\n-  vector, or other designated error value.\n-* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n-  so that nullable values do not have to be 'unwrapped' before use.\n+* All I/O operations return `IoResult<T>` which is equivalent to\n+  `Result<T, IoError>`. The core `Result` type is defined in the `std::result`\n+  module.\n+* If the `Result` type goes unused, then the compiler will by default emit a\n+  warning about the unused result.\n+* Common traits are implemented for `IoResult`, e.g.\n+  `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n+  to be 'unwrapped' before use.\n \n These features combine in the API to allow for expressions like\n `File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"))`\n without having to worry about whether \"diary.txt\" exists or whether\n the write succeeds. As written, if either `new` or `write_line`\n-encounters an error the task will fail.\n+encounters an error then the result of the entire expression will\n+be an error.\n \n If you wanted to handle the error though you might write:\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io::File;\n-use std::io::{IoError, io_error};\n \n-let mut error = None;\n-io_error::cond.trap(|e: IoError| {\n-    error = Some(e);\n-}).inside(|| {\n-    File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"));\n-});\n-\n-if error.is_some() {\n-    println!(\"failed to write my diary\");\n+match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n+    Ok(()) => { /* succeeded */ }\n+    Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n+\n # ::std::io::fs::unlink(&Path::new(\"diary.txt\"));\n ```\n \n-FIXME: Need better condition handling syntax\n-\n-In this case the condition handler will have the opportunity to\n-inspect the IoError raised by either the call to `new` or the call to\n-`write_line`, but then execution will continue.\n-\n-So what actually happens if `new` encounters an error? To understand\n-that it's important to know that what `new` returns is not a `File`\n-but an `Option<File>`.  If the file does not open, and the condition\n-is handled, then `new` will simply return `None`. Because there is an\n-implementation of `Writer` (the trait required ultimately required for\n-types to implement `write_line`) there is no need to inspect or unwrap\n-the `Option<File>` and we simply call `write_line` on it.  If `new`\n-returned a `None` then the followup call to `write_line` will also\n-raise an error.\n-\n-## Concerns about this strategy\n-\n-This structure will encourage a programming style that is prone\n-to errors similar to null pointer dereferences.\n-In particular code written to ignore errors and expect conditions to be unhandled\n-will start passing around null or zero objects when wrapped in a condition handler.\n-\n-* FIXME: How should we use condition handlers that return values?\n-* FIXME: Should EOF raise default conditions when EOF is not an error?\n+So what actually happens if `create` encounters an error?\n+It's important to know that what `new` returns is not a `File`\n+but an `IoResult<File>`.  If the file does not open, then `new` will simply\n+return `Err(..)`. Because there is an implementation of `Writer` (the trait\n+required ultimately required for types to implement `write_line`) there is no\n+need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n+on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n+will also return an error.\n \n # Issues with i/o scheduler affinity, work stealing, task pinning\n \n@@ -287,18 +262,19 @@ Out of scope\n */\n \n #[allow(missing_doc)];\n+#[deny(unused_must_use)];\n \n use cast;\n use char::Char;\n-use condition::Guard;\n use container::Container;\n+use fmt;\n use int;\n use iter::Iterator;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n-use str;\n use str::{StrSlice, OwnedStr};\n+use str;\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n@@ -347,8 +323,8 @@ mod mem;\n /// Non-blocking access to stdin, stdout, stderr\n pub mod stdio;\n \n-/// Implementations for Option\n-mod option;\n+/// Implementations for Result\n+mod result;\n \n /// Extension traits\n pub mod extensions;\n@@ -373,17 +349,30 @@ mod comm_adapters;\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n+pub type IoResult<T> = Result<T, IoError>;\n+\n /// The type passed to I/O condition handlers to indicate error\n ///\n /// # FIXME\n ///\n /// Is something like this sufficient? It's kind of archaic\n+#[deriving(Eq, Clone)]\n pub struct IoError {\n     kind: IoErrorKind,\n     desc: &'static str,\n     detail: Option<~str>\n }\n \n+impl fmt::Show for IoError {\n+    fn fmt(err: &IoError, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(fmt.buf.write_str(err.desc));\n+        match err.detail {\n+            Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n impl ToStr for IoError {\n     fn to_str(&self) -> ~str {\n@@ -398,9 +387,8 @@ impl ToStr for IoError {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Clone)]\n pub enum IoErrorKind {\n-    PreviousIoError,\n     OtherIoError,\n     EndOfFile,\n     FileNotFound,\n@@ -424,7 +412,6 @@ pub enum IoErrorKind {\n impl ToStr for IoErrorKind {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            PreviousIoError => ~\"PreviousIoError\",\n             OtherIoError => ~\"OtherIoError\",\n             EndOfFile => ~\"EndOfFile\",\n             FileNotFound => ~\"FileNotFound\",\n@@ -446,184 +433,130 @@ impl ToStr for IoErrorKind {\n     }\n }\n \n-// FIXME: Can't put doc comments on macros\n-// Raised by `I/O` operations on error.\n-condition! {\n-    pub io_error: IoError -> ();\n-}\n-\n-/// Helper for wrapper calls where you want to\n-/// ignore any io_errors that might be raised\n-pub fn ignore_io_error() -> Guard<'static,IoError,()> {\n-    io_error::cond.trap(|_| {\n-        // just swallow the error.. downstream users\n-        // who can make a decision based on a None result\n-        // won't care\n-    }).guard()\n-}\n-\n-/// Helper for catching an I/O error and wrapping it in a Result object. The\n-/// return result will be the last I/O error that happened or the result of the\n-/// closure if no error occurred.\n-pub fn result<T>(cb: || -> T) -> Result<T, IoError> {\n-    let mut err = None;\n-    let ret = io_error::cond.trap(|e| {\n-        if err.is_none() {\n-            err = Some(e);\n-        }\n-    }).inside(cb);\n-    match err {\n-        Some(e) => Err(e),\n-        None => Ok(ret),\n-    }\n-}\n-\n pub trait Reader {\n \n-    // Only two methods which need to get implemented for this trait\n+    // Only method which need to get implemented for this trait\n \n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n     /// Returns the number of bytes read. The number of bytes read my\n-    /// be less than the number requested, even 0. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n+    /// be less than the number requested, even 0. Returns `Err` on EOF.\n     ///\n-    /// Raises the `io_error` condition on error. If the condition\n-    /// is handled then no guarantee is made about the number of bytes\n-    /// read and the contents of `buf`. If the condition is handled\n-    /// returns `None` (FIXME see below).\n+    /// # Error\n     ///\n-    /// # FIXME\n-    ///\n-    /// * Should raise_default error on eof?\n-    /// * If the condition is handled it should still return the bytes read,\n-    ///   in which case there's no need to return Option - but then you *have*\n-    ///   to install a handler to detect eof.\n-    ///\n-    /// This doesn't take a `len` argument like the old `read`.\n-    /// Will people often need to slice their vectors to call this\n-    /// and will that be annoying?\n-    /// Is it actually possible for 0 bytes to be read successfully?\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n+    /// If an error occurs during this I/O operation, then it is returned as\n+    /// `Err(IoError)`. Note that end-of-file is considered an error, and can be\n+    /// inspected for in the error's `kind` field. Also note that reading 0\n+    /// bytes is not considered an error in all circumstances\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n \n     // Convenient helper methods based on the above methods\n \n-    /// Reads a single byte. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method. Returns\n-    /// `None` if the condition is handled.\n-    fn read_byte(&mut self) -> Option<u8> {\n+    /// Reads a single byte. Returns `Err` on EOF.\n+    fn read_byte(&mut self) -> IoResult<u8> {\n         let mut buf = [0];\n-        match self.read(buf) {\n-            Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n-                self.read_byte()\n+        loop {\n+            match self.read(buf) {\n+                Ok(0) => {\n+                    debug!(\"read 0 bytes. trying again\");\n+                }\n+                Ok(1) => return Ok(buf[0]),\n+                Ok(_) => unreachable!(),\n+                Err(e) => return Err(e)\n             }\n-            Some(1) => Some(buf[0]),\n-            Some(_) => unreachable!(),\n-            None => None\n         }\n     }\n \n     /// Reads `len` bytes and appends them to a vector.\n     ///\n     /// May push fewer than the requested number of bytes on error\n-    /// or EOF. Returns true on success, false on EOF or error.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n-    /// than the requested number of bytes.\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n-        unsafe {\n-            let start_len = buf.len();\n-            let mut total_read = 0;\n-\n-            buf.reserve_additional(len);\n-            buf.set_len(start_len + len);\n-\n-            (|| {\n-                while total_read < len {\n-                    let len = buf.len();\n-                    let slice = buf.mut_slice(start_len + total_read, len);\n-                    match self.read(slice) {\n-                        Some(nread) => {\n-                            total_read += nread;\n-                        }\n-                        None => {\n-                            io_error::cond.raise(standard_error(EndOfFile));\n-                            break;\n-                        }\n+    /// or EOF. If `Ok(())` is returned, then all of the requested bytes were\n+    /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n+    /// read (an error was encountered), and the error is returned.\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+        let start_len = buf.len();\n+        let mut total_read = 0;\n+\n+        buf.reserve_additional(len);\n+        unsafe { buf.set_len(start_len + len); }\n+\n+        (|| {\n+            while total_read < len {\n+                let len = buf.len();\n+                let slice = buf.mut_slice(start_len + total_read, len);\n+                match self.read(slice) {\n+                    Ok(nread) => {\n+                        total_read += nread;\n                     }\n+                    Err(e) => return Err(e)\n                 }\n-            }).finally(|| buf.set_len(start_len + total_read))\n-        }\n+            }\n+            Ok(())\n+        }).finally(|| unsafe { buf.set_len(start_len + total_read) })\n     }\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then the returned vector may\n-    /// contain less than the requested number of bytes.\n-    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+    /// Fails with the same conditions as `read`. Additionally returns error on\n+    /// on EOF. Note that if an error is returned, then some number of bytes may\n+    /// have already been consumed from the underlying reader, and they are lost\n+    /// (not returned as part of the error). If this is unacceptable, then it is\n+    /// recommended to use the `push_bytes` or `read` methods.\n+    fn read_bytes(&mut self, len: uint) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(len);\n-        self.push_bytes(&mut buf, len);\n-        return buf;\n+        match self.push_bytes(&mut buf, len) {\n+            Ok(()) => Ok(buf),\n+            Err(e) => Err(e),\n+        }\n     }\n \n     /// Reads all remaining bytes from the stream.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises the same conditions as the `read` method except for\n-    /// `EndOfFile` which is swallowed.\n-    fn read_to_end(&mut self) -> ~[u8] {\n+    /// Returns any non-EOF error immediately. Previously read bytes are\n+    /// discarded when an error is returned.\n+    ///\n+    /// When EOF is encountered, all bytes read up to that point are returned.\n+    fn read_to_end(&mut self) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n-        let mut keep_reading = true;\n-        io_error::cond.trap(|e| {\n-            if e.kind == EndOfFile {\n-                keep_reading = false;\n-            } else {\n-                io_error::cond.raise(e)\n-            }\n-        }).inside(|| {\n-            while keep_reading {\n-                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n+        loop {\n+            match self.push_bytes(&mut buf, DEFAULT_BUF_SIZE) {\n+                Ok(()) => {}\n+                Err(ref e) if e.kind == EndOfFile => break,\n+                Err(e) => return Err(e)\n             }\n-        });\n-        return buf;\n+        }\n+        return Ok(buf);\n     }\n \n     /// Reads all of the remaining bytes of this stream, interpreting them as a\n     /// UTF-8 encoded stream. The corresponding string is returned.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise all the same conditions as the `read` method,\n-    /// along with raising a condition if the input is not valid UTF-8.\n-    fn read_to_str(&mut self) -> ~str {\n-        match str::from_utf8_owned(self.read_to_end()) {\n-            Some(s) => s,\n-            None => {\n-                io_error::cond.raise(standard_error(InvalidInput));\n-                ~\"\"\n+    /// This function returns all of the same errors as `read_to_end` with an\n+    /// additional error if the reader's contents are not a valid sequence of\n+    /// UTF-8 bytes.\n+    fn read_to_str(&mut self) -> IoResult<~str> {\n+        self.read_to_end().and_then(|s| {\n+            match str::from_utf8_owned(s) {\n+                Some(s) => Ok(s),\n+                None => Err(standard_error(InvalidInput)),\n             }\n-        }\n+        })\n     }\n \n     /// Create an iterator that reads a single byte on\n     /// each iteration, until EOF.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises the same conditions as the `read` method, for\n-    /// each call to its `.next()` method.\n-    /// Ends the iteration if the condition is handled.\n+    /// The iterator protocol causes all specifics about errors encountered to\n+    /// be swallowed. All errors will be signified by returning `None` from the\n+    /// iterator. If this is undesirable, it is recommended to use the\n+    /// `read_byte` method.\n     fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n         extensions::Bytes::new(self)\n     }\n@@ -633,225 +566,219 @@ pub trait Reader {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut pos = 0;\n         let mut i = nbytes;\n         while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n+            val += (if_ok!(self.read_u8()) as u64) << pos;\n             pos += 8;\n             i -= 1;\n         }\n-        val\n+        Ok(val)\n     }\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+        self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n+            val += (if_ok!(self.read_u8()) as u64) << i * 8;\n         }\n-        val\n+        Ok(val)\n     }\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+        self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_uint(&mut self) -> uint {\n-        self.read_le_uint_n(uint::BYTES) as uint\n+    fn read_le_uint(&mut self) -> IoResult<uint> {\n+        self.read_le_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_int(&mut self) -> int {\n-        self.read_le_int_n(int::BYTES) as int\n+    fn read_le_int(&mut self) -> IoResult<int> {\n+        self.read_le_int_n(int::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_uint(&mut self) -> uint {\n-        self.read_be_uint_n(uint::BYTES) as uint\n+    fn read_be_uint(&mut self) -> IoResult<uint> {\n+        self.read_be_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_int(&mut self) -> int {\n-        self.read_be_int_n(int::BYTES) as int\n+    fn read_be_int(&mut self) -> IoResult<int> {\n+        self.read_be_int_n(int::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> u64 {\n+    fn read_be_u64(&mut self) -> IoResult<u64> {\n         self.read_be_uint_n(8)\n     }\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n+    fn read_be_u32(&mut self) -> IoResult<u32> {\n+        self.read_be_uint_n(4).map(|i| i as u32)\n     }\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n+    fn read_be_u16(&mut self) -> IoResult<u16> {\n+        self.read_be_uint_n(2).map(|i| i as u16)\n     }\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> i64 {\n+    fn read_be_i64(&mut self) -> IoResult<i64> {\n         self.read_be_int_n(8)\n     }\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> i32 {\n-        self.read_be_int_n(4) as i32\n+    fn read_be_i32(&mut self) -> IoResult<i32> {\n+        self.read_be_int_n(4).map(|i| i as i32)\n     }\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> i16 {\n-        self.read_be_int_n(2) as i16\n+    fn read_be_i16(&mut self) -> IoResult<i16> {\n+        self.read_be_int_n(2).map(|i| i as i16)\n     }\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n-        }\n+    fn read_be_f64(&mut self) -> IoResult<f64> {\n+        self.read_be_u64().map(|i| unsafe {\n+            cast::transmute::<u64, f64>(i)\n+        })\n     }\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n-        }\n+    fn read_be_f32(&mut self) -> IoResult<f32> {\n+        self.read_be_u32().map(|i| unsafe {\n+            cast::transmute::<u32, f32>(i)\n+        })\n     }\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> u64 {\n+    fn read_le_u64(&mut self) -> IoResult<u64> {\n         self.read_le_uint_n(8)\n     }\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n+    fn read_le_u32(&mut self) -> IoResult<u32> {\n+        self.read_le_uint_n(4).map(|i| i as u32)\n     }\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n+    fn read_le_u16(&mut self) -> IoResult<u16> {\n+        self.read_le_uint_n(2).map(|i| i as u16)\n     }\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> i64 {\n+    fn read_le_i64(&mut self) -> IoResult<i64> {\n         self.read_le_int_n(8)\n     }\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> i32 {\n-        self.read_le_int_n(4) as i32\n+    fn read_le_i32(&mut self) -> IoResult<i32> {\n+        self.read_le_int_n(4).map(|i| i as i32)\n     }\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> i16 {\n-        self.read_le_int_n(2) as i16\n+    fn read_le_i16(&mut self) -> IoResult<i16> {\n+        self.read_le_int_n(2).map(|i| i as i16)\n     }\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n-        }\n+    fn read_le_f64(&mut self) -> IoResult<f64> {\n+        self.read_le_u64().map(|i| unsafe {\n+            cast::transmute::<u64, f64>(i)\n+        })\n     }\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n-        }\n+    fn read_le_f32(&mut self) -> IoResult<f32> {\n+        self.read_le_u32().map(|i| unsafe {\n+            cast::transmute::<u32, f32>(i)\n+        })\n     }\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> u8 {\n-        match self.read_byte() {\n-            Some(b) => b,\n-            None => 0\n-        }\n+    fn read_u8(&mut self) -> IoResult<u8> {\n+        self.read_byte()\n     }\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> i8 {\n-        match self.read_byte() {\n-            Some(b) => b as i8,\n-            None => 0\n-        }\n+    fn read_i8(&mut self) -> IoResult<i8> {\n+        self.read_byte().map(|i| i as i8)\n     }\n \n }\n \n impl Reader for ~Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n impl<'a> Reader for &'a mut Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n fn extend_sign(val: u64, nbytes: uint) -> i64 {\n@@ -860,28 +787,31 @@ fn extend_sign(val: u64, nbytes: uint) -> i64 {\n }\n \n pub trait Writer {\n-    /// Write the given buffer\n+    /// Write the entirety of a given buffer\n     ///\n-    /// # Failure\n+    /// # Errors\n     ///\n-    /// Raises the `io_error` condition on error\n-    fn write(&mut self, buf: &[u8]);\n+    /// If an error happens during the I/O operation, the error is returned as\n+    /// `Err`. Note that it is considered an error if the entire buffer could\n+    /// not be written, and if an error is returned then it is unknown how much\n+    /// data (if any) was actually written.\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n     ///\n     /// This is by default a no-op and implementers of the `Writer` trait should\n     /// decide whether their stream needs to be buffered or not.\n-    fn flush(&mut self) {}\n+    fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n     /// Write a rust string into this sink.\n     ///\n     /// The bytes written will be the UTF-8 encoded version of the input string.\n     /// If other encodings are desired, it is recommended to compose this stream\n     /// with another performing the conversion, or to use `write` with a\n     /// converted byte-array instead.\n-    fn write_str(&mut self, s: &str) {\n-        self.write(s.as_bytes());\n+    fn write_str(&mut self, s: &str) -> IoResult<()> {\n+        self.write(s.as_bytes())\n     }\n \n     /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n@@ -891,157 +821,156 @@ pub trait Writer {\n     ///\n     /// If other encodings or line ending flavors are desired, it is recommended\n     /// that the `write` method is used specifically instead.\n-    fn write_line(&mut self, s: &str) {\n-        self.write_str(s);\n-        self.write(['\\n' as u8]);\n+    fn write_line(&mut self, s: &str) -> IoResult<()> {\n+        self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n-    fn write_char(&mut self, c: char) {\n+    fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n         let n = c.encode_utf8(buf.as_mut_slice());\n-        self.write(buf.slice_to(n));\n+        self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&mut self, n: int) {\n+    fn write_int(&mut self, n: int) -> IoResult<()> {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&mut self, n: uint) {\n+    fn write_uint(&mut self, n: uint) -> IoResult<()> {\n         uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&mut self, n: uint) {\n+    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&mut self, n: int) {\n+    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&mut self, n: uint) {\n+    fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&mut self, n: int) {\n+    fn write_be_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&mut self, n: u64) {\n+    fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&mut self, n: u32) {\n+    fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&mut self, n: u16) {\n+    fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&mut self, n: i64) {\n+    fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&mut self, n: i32) {\n+    fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&mut self, n: i16) {\n+    fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&mut self, f: f64) {\n+    fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_be_u64(cast::transmute(f))\n         }\n     }\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&mut self, f: f32) {\n+    fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_be_u32(cast::transmute(f))\n         }\n     }\n \n     /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&mut self, n: u64) {\n+    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&mut self, n: u32) {\n+    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&mut self, n: u16) {\n+    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&mut self, n: i64) {\n+    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&mut self, n: i32) {\n+    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&mut self, n: i16) {\n+    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    fn write_le_f64(&mut self, f: f64) {\n+    fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_le_u64(cast::transmute(f))\n         }\n     }\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    fn write_le_f32(&mut self, f: f32) {\n+    fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_le_u32(cast::transmute(f))\n         }\n     }\n \n     /// Write a u8 (1 byte).\n-    fn write_u8(&mut self, n: u8) {\n+    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n         self.write([n])\n     }\n \n     /// Write a i8 (1 byte).\n-    fn write_i8(&mut self, n: i8) {\n+    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n }\n \n impl Writer for ~Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+    fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n impl<'a> Writer for &'a mut Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+    fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n pub trait Stream: Reader + Writer { }\n@@ -1057,18 +986,18 @@ impl<T: Reader + Writer> Stream for T {}\n /// an iteration, but continue to yield elements if iteration\n /// is attempted again.\n ///\n-/// # Failure\n+/// # Error\n ///\n-/// Raises the same conditions as the `read` method except for `EndOfFile`\n-/// which is swallowed.\n-/// Iteration yields `None` if the condition is handled.\n+/// This iterator will swallow all I/O errors, transforming `Err` values to\n+/// `None`. If errors need to be handled, it is recommended to use the\n+/// `read_line` method directly.\n pub struct Lines<'r, T> {\n     priv buffer: &'r mut T,\n }\n \n impl<'r, T: Buffer> Iterator<~str> for Lines<'r, T> {\n     fn next(&mut self) -> Option<~str> {\n-        self.buffer.read_line()\n+        self.buffer.read_line().ok()\n     }\n }\n \n@@ -1085,11 +1014,12 @@ pub trait Buffer: Reader {\n     /// consumed from this buffer returned to ensure that the bytes are never\n     /// returned twice.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n-    fn fill<'a>(&'a mut self) -> &'a [u8];\n+    /// This function will return an I/O error if the underlying reader was\n+    /// read, but returned an error. Note that it is not an error to return a\n+    /// 0-length buffer.\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `fill` or `read`.\n@@ -1103,108 +1033,117 @@ pub trait Buffer: Reader {\n     ///\n     /// ```rust\n     /// use std::io::{BufferedReader, stdin};\n-    /// # let _g = ::std::io::ignore_io_error();\n     ///\n     /// let mut reader = BufferedReader::new(stdin());\n     ///\n-    /// let input = reader.read_line().unwrap_or(~\"nothing\");\n+    /// let input = reader.read_line().ok().unwrap_or(~\"nothing\");\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Error\n+    ///\n+    /// This function has the same error semantics as `read_until`:\n+    ///\n+    /// * All non-EOF errors will be returned immediately\n+    /// * If an error is returned previously consumed bytes are lost\n+    /// * EOF is only returned if no bytes have been read\n+    /// * Reach EOF may mean that the delimiter is not present in the return\n+    ///   value\n     ///\n-    /// This function will raise on the `io_error` condition (except for\n-    /// `EndOfFile` which is swallowed) if a read error is encountered.\n-    /// The task will also fail if sequence of bytes leading up to\n-    /// the newline character are not valid UTF-8.\n-    fn read_line(&mut self) -> Option<~str> {\n-        self.read_until('\\n' as u8).map(|line| str::from_utf8_owned(line).unwrap())\n+    /// Additionally, this function can fail if the line of input read is not a\n+    /// valid UTF-8 sequence of bytes.\n+    fn read_line(&mut self) -> IoResult<~str> {\n+        self.read_until('\\n' as u8).and_then(|line|\n+            match str::from_utf8_owned(line) {\n+                Some(s) => Ok(s),\n+                None => Err(standard_error(InvalidInput)),\n+            }\n+        )\n     }\n \n     /// Create an iterator that reads a line on each iteration until EOF.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Iterator raises the same conditions as the `read` method\n-    /// except for `EndOfFile`.\n+    /// This iterator will transform all error values to `None`, discarding the\n+    /// cause of the error. If this is undesirable, it is recommended to call\n+    /// `read_line` directly.\n     fn lines<'r>(&'r mut self) -> Lines<'r, Self> {\n-        Lines {\n-            buffer: self,\n-        }\n+        Lines { buffer: self }\n     }\n \n     /// Reads a sequence of bytes leading up to a specified delimiter. Once the\n     /// specified byte is encountered, reading ceases and the bytes up to and\n     /// including the delimiter are returned.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered, except that `EndOfFile` is swallowed.\n-    fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n+    /// If any I/O error is encountered other than EOF, the error is immediately\n+    /// returned. Note that this may discard bytes which have already been read,\n+    /// and those bytes will *not* be returned. It is recommended to use other\n+    /// methods if this case is worrying.\n+    ///\n+    /// If EOF is encountered, then this function will return EOF if 0 bytes\n+    /// have been read, otherwise the pending byte buffer is returned. This\n+    /// is the reason that the byte buffer returned may not always contain the\n+    /// delimiter.\n+    fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> {\n         let mut res = ~[];\n \n-        io_error::cond.trap(|e| {\n-            if e.kind != EndOfFile {\n-                io_error::cond.raise(e);\n-            }\n-        }).inside(|| {\n-            let mut used;\n-            loop {\n-                {\n-                    let available = self.fill();\n-                    match available.iter().position(|&b| b == byte) {\n-                        Some(i) => {\n-                            res.push_all(available.slice_to(i + 1));\n-                            used = i + 1;\n-                            break\n-                        }\n-                        None => {\n-                            res.push_all(available);\n-                            used = available.len();\n-                        }\n+        let mut used;\n+        loop {\n+            {\n+                let available = match self.fill() {\n+                    Ok(n) => n,\n+                    Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n+                        used = 0;\n+                        break\n+                    }\n+                    Err(e) => return Err(e)\n+                };\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n                     }\n                 }\n-                if used == 0 {\n-                    break\n-                }\n-                self.consume(used);\n             }\n             self.consume(used);\n-        });\n-        return if res.len() == 0 {None} else {Some(res)};\n-\n+        }\n+        self.consume(used);\n+        Ok(res)\n     }\n \n     /// Reads the next utf8-encoded character from the underlying stream.\n     ///\n-    /// This will return `None` if the following sequence of bytes in the\n-    /// stream are not a valid utf8-sequence, or if an I/O error is encountered.\n-    ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n-    fn read_char(&mut self) -> Option<char> {\n-        let width = {\n-            let available = self.fill();\n-            if available.len() == 0 { return None } // read error\n-            str::utf8_char_width(available[0])\n-        };\n-        if width == 0 { return None } // not uf8\n-        let mut buf = [0, ..4];\n+    /// # Error\n+    ///\n+    /// If an I/O error occurs, or EOF, then this function will return `Err`.\n+    /// This function will also return error if the stream does not contain a\n+    /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n+    fn read_char(&mut self) -> IoResult<char> {\n+        let first_byte = if_ok!(self.read_byte());\n+        let width = str::utf8_char_width(first_byte);\n+        if width == 1 { return Ok(first_byte as char) }\n+        if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n+        let mut buf = [first_byte, 0, 0, 0];\n         {\n-            let mut start = 0;\n-            loop {\n-                match self.read(buf.mut_slice(start, width)) {\n-                    Some(n) if n == width - start => break,\n-                    Some(n) if n < width - start => { start += n; }\n-                    Some(..) | None => return None // read error\n+            let mut start = 1;\n+            while start < width {\n+                match if_ok!(self.read(buf.mut_slice(start, width))) {\n+                    n if n == width - start => break,\n+                    n if n < width - start => { start += n; }\n+                    _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n         match str::from_utf8(buf.slice_to(width)) {\n-            Some(s) => Some(s.char_at(0)),\n-            None => None\n+            Some(s) => Ok(s.char_at(0)),\n+            None => Err(standard_error(InvalidInput))\n         }\n     }\n }\n@@ -1222,7 +1161,7 @@ pub enum SeekStyle {\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     /// Return position of file cursor in the stream\n-    fn tell(&self) -> u64;\n+    fn tell(&self) -> IoResult<u64>;\n \n     /// Seek to an offset in a stream\n     ///\n@@ -1231,31 +1170,35 @@ pub trait Seek {\n     /// # FIXME\n     ///\n     /// * What is the behavior when seeking past the end of a stream?\n-    fn seek(&mut self, pos: i64, style: SeekStyle);\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n }\n \n-/// A listener is a value that can consume itself to start listening for connections.\n+/// A listener is a value that can consume itself to start listening for\n+/// connections.\n+///\n /// Doing so produces some sort of Acceptor.\n pub trait Listener<T, A: Acceptor<T>> {\n     /// Spin up the listener and start queuing incoming connections\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises `io_error` condition. If the condition is handled,\n-    /// then `listen` returns `None`.\n-    fn listen(self) -> Option<A>;\n+    /// Returns `Err` if this listener could not be bound to listen for\n+    /// connections. In all cases, this listener is consumed.\n+    fn listen(self) -> IoResult<A>;\n }\n \n /// An acceptor is a value that presents incoming connections\n pub trait Acceptor<T> {\n     /// Wait for and accept an incoming connection\n     ///\n-    /// # Failure\n-    /// Raise `io_error` condition. If the condition is handled,\n-    /// then `accept` returns `None`.\n-    fn accept(&mut self) -> Option<T>;\n+    /// # Error\n+    ///\n+    /// Returns `Err` if an I/O error is encountered.\n+    fn accept(&mut self) -> IoResult<T>;\n \n-    /// Create an iterator over incoming connection attempts\n+    /// Create an iterator over incoming connection attempts.\n+    ///\n+    /// Note that I/O errors will be yielded by the iterator itself.\n     fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n         IncomingConnections { inc: self }\n     }\n@@ -1264,23 +1207,22 @@ pub trait Acceptor<T> {\n /// An infinite iterator over incoming connection attempts.\n /// Calling `next` will block the task until a connection is attempted.\n ///\n-/// Since connection attempts can continue forever, this iterator always returns Some.\n-/// The Some contains another Option representing whether the connection attempt was succesful.\n-/// A successful connection will be wrapped in Some.\n-/// A failed connection is represented as a None and raises a condition.\n+/// Since connection attempts can continue forever, this iterator always returns\n+/// `Some`. The `Some` contains the `IoResult` representing whether the\n+/// connection attempt was succesful.  A successful connection will be wrapped\n+/// in `Ok`. A failed connection is represented as an `Err`.\n pub struct IncomingConnections<'a, A> {\n     priv inc: &'a mut A,\n }\n \n-impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingConnections<'a, A> {\n-    fn next(&mut self) -> Option<Option<T>> {\n+impl<'a, T, A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n+    fn next(&mut self) -> Option<IoResult<T>> {\n         Some(self.inc.accept())\n     }\n }\n \n pub fn standard_error(kind: IoErrorKind) -> IoError {\n     let desc = match kind {\n-        PreviousIoError => \"failing due to previous I/O error\",\n         EndOfFile => \"end of file\",\n         IoUnavailable => \"I/O is unavailable\",\n         InvalidInput => \"invalid input\",\n@@ -1314,7 +1256,7 @@ pub enum FileMode {\n }\n \n /// Access permissions with which the file should be opened. `File`s\n-/// opened with `Read` will raise an `io_error` condition if written to.\n+/// opened with `Read` will return an error if written to.\n pub enum FileAccess {\n     Read,\n     Write,"}, {"sha": "e9ffe97f1c356d6b41768ce74b95d465a0ff0b63", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -17,8 +17,9 @@ getaddrinfo()\n \n */\n \n-use option::{Option, Some, None};\n+use io::IoResult;\n use io::net::ip::{SocketAddr, IpAddr};\n+use option::{Option, Some, None};\n use rt::rtio::{IoFactory, LocalIo};\n use vec::ImmutableVector;\n \n@@ -69,11 +70,7 @@ pub struct Info {\n \n /// Easy name resolution. Given a hostname, returns the list of IP addresses for\n /// that hostname.\n-///\n-/// # Failure\n-///\n-/// On failure, this will raise on the `io_error` condition.\n-pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n     lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n }\n \n@@ -87,14 +84,10 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n /// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n ///          controls lookup\n ///\n-/// # Failure\n-///\n-/// On failure, this will raise on the `io_error` condition.\n-///\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n-          -> Option<~[Info]> {\n+          -> IoResult<~[Info]> {\n     LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n }\n \n@@ -115,6 +108,6 @@ mod test {\n     iotest!(fn issue_10663() {\n         // Something should happen here, but this certainly shouldn't cause\n         // everything to die. The actual outcome we don't care too much about.\n-        get_host_addresses(\"example.com\");\n+        get_host_addresses(\"example.com\").unwrap();\n     } #[ignore])\n }"}, {"sha": "a0bdc193d980c85ca3df046994a50452c98bfecd", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 99, "deletions": 175, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n-use io::{Reader, Writer, Listener, Acceptor};\n-use io::{io_error, EndOfFile};\n+use io::{Reader, Writer, Listener, Acceptor, IoResult};\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -25,91 +22,48 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n+    pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_connect(addr).map(TcpStream::new)\n         })\n     }\n \n-    pub fn peer_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.peer_name() {\n-            Ok(pn) => Some(pn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get peer name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.peer_name()\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.obj.read(buf) {\n-            Ok(read) => Some(read),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.obj.write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => io_error::cond.raise(ioerr),\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n pub struct TcpListener {\n     priv obj: ~RtioTcpListener\n }\n \n impl TcpListener {\n-    pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n         })\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n-    fn listen(self) -> Option<TcpAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Some(TcpAcceptor { obj: acceptor }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn listen(self) -> IoResult<TcpAcceptor> {\n+        self.obj.listen().map(|acceptor| TcpAcceptor { obj: acceptor })\n     }\n }\n \n@@ -118,14 +72,8 @@ pub struct TcpAcceptor {\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n-    fn accept(&mut self) -> Option<TcpStream> {\n-        match self.obj.accept() {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn accept(&mut self) -> IoResult<TcpStream> {\n+        self.obj.accept().map(TcpStream::new)\n     }\n }\n \n@@ -138,29 +86,19 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let listener = TcpListener::bind(addr);\n-            assert!(listener.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match TcpListener::bind(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn connect_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind, ConnectionRefused);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let stream = TcpStream::connect(addr);\n-            assert!(stream.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match TcpStream::connect(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, ConnectionRefused),\n+        }\n     })\n \n     iotest!(fn smoke_test_ip4() {\n@@ -170,14 +108,14 @@ mod test {\n         spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]);\n+            stream.write([99]).unwrap();\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf);\n+        stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n     })\n \n@@ -188,14 +126,14 @@ mod test {\n         spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]);\n+            stream.write([99]).unwrap();\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf);\n+        stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n     })\n \n@@ -214,7 +152,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n+        assert!(nread.is_err());\n     })\n \n     iotest!(fn read_eof_ip6() {\n@@ -232,7 +170,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n+        assert!(nread.is_err());\n     })\n \n     iotest!(fn read_eof_twice_ip4() {\n@@ -250,17 +188,15 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n-        io_error::cond.trap(|e| {\n-            if cfg!(windows) {\n-                assert_eq!(e.kind, NotConnected);\n-            } else {\n-                fail!();\n+        assert!(nread.is_err());\n+\n+        match stream.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(ref e) => {\n+                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n+                        \"unknown kind: {:?}\", e.kind);\n             }\n-        }).inside(|| {\n-            let nread = stream.read(buf);\n-            assert!(nread.is_none());\n-        })\n+        }\n     })\n \n     iotest!(fn read_eof_twice_ip6() {\n@@ -278,17 +214,15 @@ mod test {\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n-        assert!(nread.is_none());\n-        io_error::cond.trap(|e| {\n-            if cfg!(windows) {\n-                assert_eq!(e.kind, NotConnected);\n-            } else {\n-                fail!();\n+        assert!(nread.is_err());\n+\n+        match stream.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(ref e) => {\n+                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n+                        \"unknown kind: {:?}\", e.kind);\n             }\n-        }).inside(|| {\n-            let nread = stream.read(buf);\n-            assert!(nread.is_none());\n-        })\n+        }\n     })\n \n     iotest!(fn write_close_ip4() {\n@@ -306,19 +240,16 @@ mod test {\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n-            let mut stop = false;\n-            io_error::cond.trap(|e| {\n-                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                //     on windows\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {:?}\", e);\n-                stop = true;\n-            }).inside(|| {\n-                stream.write(buf);\n-            });\n-            if stop { break }\n+            match stream.write(buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind == ConnectionReset ||\n+                            e.kind == BrokenPipe ||\n+                            e.kind == ConnectionAborted,\n+                            \"unknown error: {:?}\", e);\n+                    break;\n+                }\n+            }\n         }\n     })\n \n@@ -337,19 +268,16 @@ mod test {\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n-            let mut stop = false;\n-            io_error::cond.trap(|e| {\n-                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                //     on windows\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {:?}\", e);\n-                stop = true;\n-            }).inside(|| {\n-                stream.write(buf);\n-            });\n-            if stop { break }\n+            match stream.write(buf) {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    assert!(e.kind == ConnectionReset ||\n+                            e.kind == BrokenPipe ||\n+                            e.kind == ConnectionAborted,\n+                            \"unknown error: {:?}\", e);\n+                    break;\n+                }\n+            }\n         }\n     })\n \n@@ -362,15 +290,15 @@ mod test {\n             port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             }\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf);\n+            stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     })\n@@ -384,15 +312,15 @@ mod test {\n             port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             }\n         });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf);\n+            stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     })\n@@ -410,7 +338,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -429,7 +357,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]);\n+                stream.write([i as u8]).unwrap();\n             });\n         }\n     })\n@@ -447,7 +375,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -466,7 +394,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]);\n+                stream.write([i as u8]).unwrap();\n             });\n         }\n     })\n@@ -484,7 +412,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -503,7 +431,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             });\n         }\n     })\n@@ -521,7 +449,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf);\n+                    stream.read(buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -540,7 +468,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]);\n+                stream.write([99]).unwrap();\n             });\n         }\n     })\n@@ -551,7 +479,7 @@ mod test {\n         // Make sure socket_name gives\n         // us the socket we binded to.\n         let so_name = listener.socket_name();\n-        assert!(so_name.is_some());\n+        assert!(so_name.is_ok());\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n@@ -561,20 +489,20 @@ mod test {\n         spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n-            acceptor.accept();\n+            acceptor.accept().unwrap();\n         });\n \n         port.recv();\n         let stream = TcpStream::connect(addr);\n \n-        assert!(stream.is_some());\n+        assert!(stream.is_ok());\n         let mut stream = stream.unwrap();\n \n         // Make sure peer_name gives us the\n         // address/port of the peer we've\n         // connected to.\n         let peer_name = stream.peer_name();\n-        assert!(peer_name.is_some());\n+        assert!(peer_name.is_ok());\n         assert_eq!(addr, peer_name.unwrap());\n     }\n \n@@ -593,37 +521,33 @@ mod test {\n         let addr = next_test_ip4();\n         let (p, c) = Chan::new();\n         spawn(proc() {\n-            let mut srv = TcpListener::bind(addr).listen();\n+            let mut srv = TcpListener::bind(addr).listen().unwrap();\n             c.send(());\n             let mut cl = srv.accept().unwrap();\n-            cl.write([10]);\n+            cl.write([10]).unwrap();\n             let mut b = [0];\n-            cl.read(b);\n+            cl.read(b).unwrap();\n             c.send(());\n         });\n \n         p.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n-        assert_eq!(c.read(b), Some(1));\n-        c.write([1]);\n+        assert_eq!(c.read(b), Ok(1));\n+        c.write([1]).unwrap();\n         p.recv();\n     })\n \n     iotest!(fn double_bind() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n-            called = true;\n-        }).inside(|| {\n-            let addr = next_test_ip4();\n-            let listener = TcpListener::bind(addr).unwrap().listen();\n-            assert!(listener.is_some());\n-            let listener2 = TcpListener::bind(addr).and_then(|l|\n-                                                    l.listen());\n-            assert!(listener2.is_none());\n-        });\n-        assert!(called);\n+        let addr = next_test_ip4();\n+        let listener = TcpListener::bind(addr).unwrap().listen();\n+        assert!(listener.is_ok());\n+        match TcpListener::bind(addr).listen() {\n+            Ok(..) => fail!(),\n+            Err(e) => {\n+                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n+            }\n+        }\n     })\n \n     iotest!(fn fast_rebind() {\n@@ -632,7 +556,7 @@ mod test {\n \n         spawn(proc() {\n             port.recv();\n-            let _stream = TcpStream::connect(addr);\n+            let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n             port.recv();\n         });\n@@ -641,7 +565,7 @@ mod test {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             {\n-                let _stream = acceptor.accept();\n+                let _stream = acceptor.accept().unwrap();\n                 // Close client\n                 chan.send(());\n             }"}, {"sha": "0ef62648afcb7934e2d1f29cd46db97168704be9", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 49, "deletions": 75, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -8,57 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n-use io::{Reader, Writer};\n-use io::{io_error, EndOfFile};\n+use io::{Reader, Writer, IoResult};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n pub struct UdpSocket {\n     priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n         LocalIo::maybe_raise(|io| {\n             io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n         })\n     }\n \n-    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n-        match self.obj.recvfrom(buf) {\n-            Ok((nread, src)) => Some((nread, src)),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                None\n-            }\n-        }\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+        self.obj.recvfrom(buf)\n     }\n \n-    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) {\n-        match self.obj.sendto(buf, dst) {\n-            Ok(_) => (),\n-            Err(ioerr) => io_error::cond.raise(ioerr),\n-        }\n+    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n+        self.obj.sendto(buf, dst)\n     }\n \n     pub fn connect(self, other: SocketAddr) -> UdpStream {\n         UdpStream { socket: self, connectedTo: other }\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n@@ -76,21 +55,21 @@ impl UdpStream {\n }\n \n impl Reader for UdpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let peer = self.connectedTo;\n         self.as_socket(|sock| {\n             match sock.recvfrom(buf) {\n-                Some((_nread, src)) if src != peer => Some(0),\n-                Some((nread, _src)) => Some(nread),\n-                None => None,\n+                Ok((_nread, src)) if src != peer => Ok(0),\n+                Ok((nread, _src)) => Ok(nread),\n+                Err(e) => Err(e),\n             }\n         })\n     }\n }\n \n impl Writer for UdpStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.as_socket(|sock| sock.sendto(buf, self.connectedTo));\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.as_socket(|sock| sock.sendto(buf, self.connectedTo))\n     }\n }\n \n@@ -101,16 +80,11 @@ mod test {\n \n     // FIXME #11530 this fails on android because tests are run as root\n     iotest!(fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind, PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-            let socket = UdpSocket::bind(addr);\n-            assert!(socket.is_none());\n-        });\n-        assert!(called);\n+        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+        match UdpSocket::bind(addr) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     } #[ignore(cfg(windows))] #[ignore(cfg(target_os = \"android\"))])\n \n     iotest!(fn socket_smoke_test_ip4() {\n@@ -121,29 +95,29 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(ref mut client) => {\n+                Ok(ref mut client) => {\n                     port.recv();\n-                    client.sendto([99], server_ip)\n+                    client.sendto([99], server_ip).unwrap()\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(ref mut server) => {\n+            Ok(ref mut server) => {\n                 chan.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n-                    Some((nread, src)) => {\n+                    Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n@@ -155,28 +129,28 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(ref mut client) => {\n+                Ok(ref mut client) => {\n                     port.recv();\n-                    client.sendto([99], server_ip)\n+                    client.sendto([99], server_ip).unwrap()\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(ref mut server) => {\n+            Ok(ref mut server) => {\n                 chan.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n-                    Some((nread, src)) => {\n+                    Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                         assert_eq!(src, client_ip);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n     })\n \n@@ -188,32 +162,32 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(client) => {\n+                Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n                     port.recv();\n-                    stream.write([99]);\n+                    stream.write([99]).unwrap();\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(server) => {\n+            Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n                 chan.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n-                    Some(nread) => {\n+                    Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n@@ -226,46 +200,46 @@ mod test {\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n-                Some(client) => {\n+                Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n                     port.recv();\n-                    stream.write([99]);\n+                    stream.write([99]).unwrap();\n                 }\n-                None => fail!()\n+                Err(..) => fail!()\n             }\n             chan2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n-            Some(server) => {\n+            Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n                 chan.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n-                    Some(nread) => {\n+                    Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    None => fail!()\n+                    Err(..) => fail!()\n                 }\n             }\n-            None => fail!()\n+            Err(..) => fail!()\n         }\n         port2.recv();\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n         let server = UdpSocket::bind(addr);\n \n-        assert!(server.is_some());\n+        assert!(server.is_ok());\n         let mut server = server.unwrap();\n \n         // Make sure socket_name gives\n         // us the socket we binded to.\n         let so_name = server.socket_name();\n-        assert!(so_name.is_some());\n+        assert!(so_name.is_ok());\n         assert_eq!(addr, so_name.unwrap());\n     }\n "}, {"sha": "ce95b987663f7be8f6675c10f621921ddfe0613c", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 50, "deletions": 78, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -28,7 +28,7 @@ use c_str::ToCStr;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n use io::pipe::PipeStream;\n-use io::{io_error, Listener, Acceptor, Reader, Writer};\n+use io::{Listener, Acceptor, Reader, Writer, IoResult};\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n@@ -45,32 +45,29 @@ impl UnixStream {\n     ///\n     /// The returned stream will be closed when the object falls out of scope.\n     ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if the connection\n-    /// could not be made.\n-    ///\n     /// # Example\n     ///\n-    ///     use std::io::net::unix::UnixStream;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::io::net::unix::UnixStream;\n     ///\n-    ///     let server = Path(\"path/to/my/socket\");\n-    ///     let mut stream = UnixStream::connect(&server);\n-    ///     stream.write([1, 2, 3]);\n-    ///\n-    pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n+    /// let server = Path::new(\"path/to/my/socket\");\n+    /// let mut stream = UnixStream::connect(&server);\n+    /// stream.write([1, 2, 3]);\n+    /// ```\n+    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_connect(&path.to_c_str()).map(UnixStream::new)\n         })\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n pub struct UnixListener {\n@@ -84,38 +81,29 @@ impl UnixListener {\n     ///\n     /// This listener will be closed when it falls out of scope.\n     ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if the specified\n-    /// path could not be bound.\n-    ///\n     /// # Example\n     ///\n-    ///     use std::io::net::unix::UnixListener;\n-    ///\n-    ///     let server = Path(\"path/to/my/socket\");\n-    ///     let mut stream = UnixListener::bind(&server);\n-    ///     for client in stream.incoming() {\n-    ///         let mut client = client;\n-    ///         client.write([1, 2, 3, 4]);\n-    ///     }\n+    /// ```\n+    /// use std::io::net::unix::UnixListener;\n+    /// use std::io::Listener;\n     ///\n-    pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n+    /// let server = Path::new(\"path/to/my/socket\");\n+    /// let mut stream = UnixListener::bind(&server);\n+    /// for client in stream.incoming() {\n+    ///     let mut client = client;\n+    ///     client.write([1, 2, 3, 4]);\n+    /// }\n+    /// ```\n+    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n         })\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Some(UnixAcceptor { obj: acceptor }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn listen(self) -> IoResult<UnixAcceptor> {\n+        self.obj.listen().map(|obj| UnixAcceptor { obj: obj })\n     }\n }\n \n@@ -124,14 +112,8 @@ pub struct UnixAcceptor {\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> {\n-        match self.obj.accept() {\n-            Ok(s) => Some(UnixStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn accept(&mut self) -> IoResult<UnixStream> {\n+        self.obj.accept().map(UnixStream::new)\n     }\n }\n \n@@ -159,48 +141,38 @@ mod tests {\n \n     #[test]\n     fn bind_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert!(e.kind == PermissionDenied);\n-            called = true;\n-        }).inside(|| {\n-            let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n-            assert!(listener.is_none());\n-        });\n-        assert!(called);\n+        match UnixListener::bind(&(\"path/to/nowhere\")) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, PermissionDenied),\n+        }\n     }\n \n     #[test]\n     fn connect_error() {\n-        let mut called = false;\n-        io_error::cond.trap(|e| {\n-            assert_eq!(e.kind,\n-                       if cfg!(windows) {OtherIoError} else {FileNotFound});\n-            called = true;\n-        }).inside(|| {\n-            let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n-            assert!(stream.is_none());\n-        });\n-        assert!(called);\n+        match UnixStream::connect(&(\"path/to/nowhere\")) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind,\n+                        if cfg!(windows) {OtherIoError} else {FileNotFound})\n+        }\n     }\n \n     #[test]\n     fn smoke() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            server.read(buf);\n+            server.read(buf).unwrap();\n             assert!(buf[0] == 99);\n         }, proc(mut client) {\n-            client.write([99]);\n+            client.write([99]).unwrap();\n         })\n     }\n \n     #[test]\n     fn read_eof() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            assert!(server.read(buf).is_none());\n-            assert!(server.read(buf).is_none());\n+            assert!(server.read(buf).is_err());\n+            assert!(server.read(buf).is_err());\n         }, proc(_client) {\n             // drop the client\n         })\n@@ -210,15 +182,15 @@ mod tests {\n     fn write_begone() {\n         smalltest(proc(mut server) {\n             let buf = [0];\n-            let mut stop = false;\n-            while !stop{\n-                io_error::cond.trap(|e| {\n-                    assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n-                            \"unknown error {:?}\", e);\n-                    stop = true;\n-                }).inside(|| {\n-                    server.write(buf);\n-                })\n+            loop {\n+                match server.write(buf) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n+                                \"unknown error {:?}\", e);\n+                        break;\n+                    }\n+                }\n             }\n         }, proc(_client) {\n             // drop the client\n@@ -236,7 +208,7 @@ mod tests {\n             port.recv();\n             for _ in range(0, times) {\n                 let mut stream = UnixStream::connect(&path2);\n-                stream.write([100]);\n+                stream.write([100]).unwrap();\n             }\n         });\n \n@@ -245,7 +217,7 @@ mod tests {\n         for _ in range(0, times) {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n-            client.read(buf);\n+            client.read(buf).unwrap();\n             assert_eq!(buf[0], 100);\n         }\n     }"}, {"sha": "e2eec652d9dedd4c3e6d493b0f43d81dcf8cd8d8", "filename": "src/libstd/io/option.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/be4fc638092bf896c5c6c0672136b83b71e491ee/src%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be4fc638092bf896c5c6c0672136b83b71e491ee/src%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Foption.rs?ref=be4fc638092bf896c5c6c0672136b83b71e491ee", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations of I/O traits for the Option type\n-//!\n-//! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `Option<File>` to be used\n-//! as a `Reader` without unwrapping the option first.\n-\n-use option::*;\n-use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle};\n-use super::{standard_error, PreviousIoError, io_error, IoError};\n-\n-fn prev_io_error() -> IoError {\n-    standard_error(PreviousIoError)\n-}\n-\n-impl<W: Writer> Writer for Option<W> {\n-    fn write(&mut self, buf: &[u8]) {\n-        match *self {\n-            Some(ref mut writer) => writer.write(buf),\n-            None => io_error::cond.raise(prev_io_error())\n-        }\n-    }\n-\n-    fn flush(&mut self) {\n-        match *self {\n-            Some(ref mut writer) => writer.flush(),\n-            None => io_error::cond.raise(prev_io_error())\n-        }\n-    }\n-}\n-\n-impl<R: Reader> Reader for Option<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match *self {\n-            Some(ref mut reader) => reader.read(buf),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-impl<S: Seek> Seek for Option<S> {\n-    fn tell(&self) -> u64 {\n-        match *self {\n-            Some(ref seeker) => seeker.tell(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                0\n-            }\n-        }\n-    }\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        match *self {\n-            Some(ref mut seeker) => seeker.seek(pos, style),\n-            None => io_error::cond.raise(prev_io_error())\n-        }\n-    }\n-}\n-\n-impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for Option<L> {\n-    fn listen(self) -> Option<A> {\n-        match self {\n-            Some(listener) => listener.listen(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n-    fn accept(&mut self) -> Option<T> {\n-        match *self {\n-            Some(ref mut acceptor) => acceptor.accept(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use super::super::mem::*;\n-    use super::super::{PreviousIoError, io_error};\n-\n-    #[test]\n-    fn test_option_writer() {\n-        let mut writer: Option<MemWriter> = Some(MemWriter::new());\n-        writer.write([0, 1, 2]);\n-        writer.flush();\n-        assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n-    }\n-\n-    #[test]\n-    fn test_option_writer_error() {\n-        let mut writer: Option<MemWriter> = None;\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.write([0, 0, 0]);\n-        });\n-        assert!(called);\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            writer.flush();\n-        });\n-        assert!(called);\n-    }\n-\n-    #[test]\n-    fn test_option_reader() {\n-        let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n-        let mut buf = [0, 0];\n-        reader.read(buf);\n-        assert_eq!(buf, [0, 1]);\n-    }\n-\n-    #[test]\n-    fn test_option_reader_error() {\n-        let mut reader: Option<MemReader> = None;\n-        let mut buf = [];\n-\n-        let mut called = false;\n-        io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, PreviousIoError);\n-            called = true;\n-        }).inside(|| {\n-            reader.read(buf);\n-        });\n-        assert!(called);\n-    }\n-}"}, {"sha": "ca85707149b92f212559d23a9907214e40ab56b8", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -14,7 +14,7 @@\n //! enough so that pipes can be created to child processes.\n \n use prelude::*;\n-use io::{io_error, EndOfFile};\n+use io::IoResult;\n use libc;\n use rt::rtio::{RtioPipe, LocalIo};\n \n@@ -32,17 +32,15 @@ impl PipeStream {\n     ///\n     /// # Example\n     ///\n-    ///     use std::libc;\n-    ///     use std::io::pipe;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::libc;\n+    /// use std::io::pipe::PipeStream;\n     ///\n-    ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(bytes!(\"Hello, stderr!\"));\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the pipe cannot be created, an error will be raised on the\n-    /// `io_error` condition.\n-    pub fn open(fd: libc::c_int) -> Option<PipeStream> {\n+    /// let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n+    /// pipe.write(bytes!(\"Hello, stderr!\"));\n+    /// ```\n+    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n         LocalIo::maybe_raise(|io| {\n             io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n         })\n@@ -54,29 +52,11 @@ impl PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.obj.read(buf) {\n-            Ok(read) => Some(read),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.obj.write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n #[cfg(test)]\n@@ -91,12 +71,12 @@ mod test {\n         let (p, c) = Chan::new();\n         spawn(proc() {\n             let mut out = out;\n-            out.write([10]);\n+            out.write([10]).unwrap();\n             p.recv(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0, ..10];\n-        input.read(buf);\n+        input.read(buf).unwrap();\n         c.send(());\n     })\n }"}, {"sha": "ccf3d4582def4d5bf566b0e4e7a92c7b9d12bc0a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -14,7 +14,7 @@ use prelude::*;\n \n use libc;\n use io;\n-use io::io_error;\n+use io::IoResult;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n use fmt;\n@@ -93,7 +93,7 @@ pub enum ProcessExit {\n \n impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) -> fmt::Result {\n         match *obj {\n             ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n             ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n@@ -118,7 +118,7 @@ impl ProcessExit {\n impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n-    pub fn new(config: ProcessConfig) -> Option<Process> {\n+    pub fn new(config: ProcessConfig) -> IoResult<Process> {\n         let mut config = Some(config);\n         LocalIo::maybe_raise(|io| {\n             io.spawn(config.take_unwrap()).map(|(p, io)| {\n@@ -141,14 +141,9 @@ impl Process {\n     /// Note that this is purely a wrapper around libuv's `uv_process_kill`\n     /// function.\n     ///\n-    /// If the signal delivery fails, then the `io_error` condition is raised on\n-    pub fn signal(&mut self, signal: int) {\n-        match self.handle.kill(signal) {\n-            Ok(()) => {}\n-            Err(err) => {\n-                io_error::cond.raise(err)\n-            }\n-        }\n+    /// If the signal delivery fails, the corresponding error is returned.\n+    pub fn signal(&mut self, signal: int) -> IoResult<()> {\n+        self.handle.kill(signal)\n     }\n \n     /// Wait for the child to exit completely, returning the status that it\n@@ -176,7 +171,6 @@ impl Drop for Process {\n mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n-    use str;\n \n     // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -190,7 +184,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().success());\n     })\n@@ -206,7 +200,7 @@ mod tests {\n             cwd: None,\n             io: io,\n         };\n-        match io::result(|| Process::new(args)) {\n+        match Process::new(args) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n@@ -224,7 +218,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().matches_exit_status(1));\n     })\n@@ -240,7 +234,7 @@ mod tests {\n             io: io,\n         };\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait() {\n             process::ExitSignal(1) => {},\n@@ -249,20 +243,12 @@ mod tests {\n     })\n \n     pub fn read_all(input: &mut Reader) -> ~str {\n-        let mut ret = ~\"\";\n-        let mut buf = [0, ..1024];\n-        loop {\n-            match input.read(buf) {\n-                None => { break }\n-                Some(n) => { ret.push_str(str::from_utf8(buf.slice_to(n)).unwrap()); }\n-            }\n-        }\n-        return ret;\n+        input.read_to_str().unwrap()\n     }\n \n     pub fn run_output(args: ProcessConfig) -> ~str {\n         let p = Process::new(args);\n-        assert!(p.is_some());\n+        assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.io[0].is_none());\n         assert!(p.io[1].is_some());\n@@ -312,8 +298,8 @@ mod tests {\n             cwd: None,\n             io: io,\n         };\n-        let mut p = Process::new(args).expect(\"didn't create a proces?!\");\n-        p.io[0].get_mut_ref().write(\"foobar\".as_bytes());\n+        let mut p = Process::new(args).unwrap();\n+        p.io[0].get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n         p.io[0] = None; // close stdin;\n         let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n         assert!(p.wait().success());"}, {"sha": "8e03cffd0fb24c1399b2aa364a571a7c24b2d2c0", "filename": "src/libstd/io/result.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of I/O traits for the IoResult type\n+//!\n+//! I/O constructors return option types to allow errors to be handled.\n+//! These implementations allow e.g. `IoResult<File>` to be used\n+//! as a `Reader` without unwrapping the result first.\n+\n+use clone::Clone;\n+use result::{Ok, Err};\n+use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n+\n+impl<W: Writer> Writer for IoResult<W> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        match *self {\n+            Ok(ref mut writer) => writer.write(buf),\n+            Err(ref e) => Err((*e).clone())\n+        }\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        match *self {\n+            Ok(ref mut writer) => writer.flush(),\n+            Err(ref e) => Err(e.clone()),\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for IoResult<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        match *self {\n+            Ok(ref mut reader) => reader.read(buf),\n+            Err(ref e) => Err(e.clone()),\n+        }\n+    }\n+}\n+\n+impl<S: Seek> Seek for IoResult<S> {\n+    fn tell(&self) -> IoResult<u64> {\n+        match *self {\n+            Ok(ref seeker) => seeker.tell(),\n+            Err(ref e) => Err(e.clone()),\n+        }\n+    }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        match *self {\n+            Ok(ref mut seeker) => seeker.seek(pos, style),\n+            Err(ref e) => Err(e.clone())\n+        }\n+    }\n+}\n+\n+impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for IoResult<L> {\n+    fn listen(self) -> IoResult<A> {\n+        match self {\n+            Ok(listener) => listener.listen(),\n+            Err(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n+    fn accept(&mut self) -> IoResult<T> {\n+        match *self {\n+            Ok(ref mut acceptor) => acceptor.accept(),\n+            Err(ref e) => Err(e.clone()),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::super::mem::*;\n+    use io;\n+\n+    #[test]\n+    fn test_option_writer() {\n+        let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n+        writer.write([0, 1, 2]).unwrap();\n+        writer.flush().unwrap();\n+        assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n+    }\n+\n+    #[test]\n+    fn test_option_writer_error() {\n+        let mut writer: io::IoResult<MemWriter> =\n+            Err(io::standard_error(io::EndOfFile));\n+\n+        match writer.write([0, 0, 0]) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n+        match writer.flush() {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_option_reader() {\n+        let mut reader: io::IoResult<MemReader> =\n+            Ok(MemReader::new(~[0, 1, 2, 3]));\n+        let mut buf = [0, 0];\n+        reader.read(buf).unwrap();\n+        assert_eq!(buf, [0, 1]);\n+    }\n+\n+    #[test]\n+    fn test_option_reader_error() {\n+        let mut reader: io::IoResult<MemReader> =\n+            Err(io::standard_error(io::EndOfFile));\n+        let mut buf = [];\n+\n+        match reader.read(buf) {\n+            Ok(..) => fail!(),\n+            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+        }\n+    }\n+}"}, {"sha": "75804c40c58061f5136f4d2580b83636ecfe8805", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -20,10 +20,11 @@ definitions for a number of signals.\n */\n \n use clone::Clone;\n+use result::{Ok, Err};\n use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n-use option::{Some, None};\n+use io;\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n \n #[repr(int)]\n@@ -112,23 +113,22 @@ impl Listener {\n     /// a signal, and a later call to `recv` will return the signal that was\n     /// received while no task was waiting on it.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n     /// If this function fails to register a signal handler, then an error will\n-    /// be raised on the `io_error` condition and the function will return\n-    /// false.\n-    pub fn register(&mut self, signum: Signum) -> bool {\n+    /// be returned.\n+    pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n         if self.handles.contains_key(&signum) {\n-            return true; // self is already listening to signum, so succeed\n+            return Ok(()); // self is already listening to signum, so succeed\n         }\n         match LocalIo::maybe_raise(|io| {\n             io.signal(signum, self.chan.clone())\n         }) {\n-            Some(handle) => {\n+            Ok(handle) => {\n                 self.handles.insert(signum, handle);\n-                true\n+                Ok(())\n             }\n-            None => false\n+            Err(e) => Err(e)\n         }\n     }\n \n@@ -159,7 +159,7 @@ mod test {\n     #[test] #[cfg(unix, not(target_os=\"android\"))] // FIXME(#10378)\n     fn test_io_signal_smoketest() {\n         let mut signal = Listener::new();\n-        signal.register(Interrupt);\n+        signal.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n         match signal.port.recv() {\n@@ -172,8 +172,8 @@ mod test {\n     fn test_io_signal_two_signal_one_signum() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n-        s1.register(Interrupt);\n-        s2.register(Interrupt);\n+        s1.register(Interrupt).unwrap();\n+        s2.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n         match s1.port.recv() {\n@@ -190,8 +190,8 @@ mod test {\n     fn test_io_signal_unregister() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n-        s1.register(Interrupt);\n-        s2.register(Interrupt);\n+        s1.register(Interrupt).unwrap();\n+        s2.register(Interrupt).unwrap();\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n@@ -203,15 +203,14 @@ mod test {\n     fn test_io_signal_invalid_signum() {\n         use io;\n         use super::User1;\n+        use result::{Ok, Err};\n         let mut s = Listener::new();\n         let mut called = false;\n-        io::io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| {\n-            if s.register(User1) {\n+        match s.register(User1) {\n+            Ok(..) => {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);\n             }\n-        });\n-        assert!(called);\n+            Err(..) => {}\n+        }\n     }\n }"}, {"sha": "937ad0783e9ab43b3725ba88c9494785f3621d03", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 39, "deletions": 56, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -18,6 +18,7 @@ about the stream or terminal that it is attached to.\n # Example\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io;\n \n let mut out = io::stdout();\n@@ -28,7 +29,7 @@ out.write(bytes!(\"Hello, world!\"));\n \n use container::Container;\n use fmt;\n-use io::{Reader, Writer, io_error, IoError, OtherIoError,\n+use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter};\n use libc;\n use option::{Option, Some, None};\n@@ -114,7 +115,8 @@ fn reset_helper(w: ~Writer,\n     match f(t.get(), w) {\n         Some(mut w) => {\n             drop(t);\n-            w.flush();\n+            // FIXME: is failing right here?\n+            w.flush().unwrap();\n             Some(w)\n         }\n         None => None\n@@ -155,9 +157,9 @@ pub fn set_stderr(stderr: ~Writer) -> Option<~Writer> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer|) {\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n     let task: Option<~Task> = Local::try_take();\n-    match task {\n+    let result = match task {\n         Some(mut task) => {\n             // Printing may run arbitrary code, so ensure that the task is in\n             // TLS to allow all std services. Note that this means a print while\n@@ -169,7 +171,7 @@ fn with_task_stdout(f: |&mut Writer|) {\n             if my_stdout.is_none() {\n                 my_stdout = Some(~LineBufferedWriter::new(stdout()) as ~Writer);\n             }\n-            f(*my_stdout.get_mut_ref());\n+            let ret = f(*my_stdout.get_mut_ref());\n \n             // Note that we need to be careful when putting the stdout handle\n             // back into the task. If the handle was set to `Some` while\n@@ -184,22 +186,29 @@ fn with_task_stdout(f: |&mut Writer|) {\n             let prev = util::replace(&mut t.get().stdout, my_stdout);\n             drop(t);\n             drop(prev);\n+            ret\n         }\n \n         None => {\n             struct Stdout;\n             impl Writer for Stdout {\n-                fn write(&mut self, data: &[u8]) {\n+                fn write(&mut self, data: &[u8]) -> IoResult<()> {\n                     unsafe {\n                         libc::write(libc::STDOUT_FILENO,\n                                     data.as_ptr() as *libc::c_void,\n                                     data.len() as libc::size_t);\n                     }\n+                    Ok(()) // just ignore the results\n                 }\n             }\n             let mut io = Stdout;\n-            f(&mut io as &mut Writer);\n+            f(&mut io as &mut Writer)\n         }\n+    };\n+\n+    match result {\n+        Ok(()) => {}\n+        Err(e) => fail!(\"failed printing to stdout: {}\", e),\n     }\n }\n \n@@ -226,8 +235,7 @@ pub fn print(s: &str) {\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes());\n-        io.write(['\\n' as u8]);\n+        io.write(s.as_bytes()).and_then(|()| io.write(['\\n' as u8]))\n     })\n }\n \n@@ -249,7 +257,7 @@ pub struct StdReader {\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let ret = match self.inner {\n             TTY(ref mut tty) => tty.read(buf),\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n@@ -260,15 +268,8 @@ impl Reader for StdReader {\n             // return an actual EOF error, but apparently for stdin it's a\n             // little different. Hence, here we convert a 0 length read to an\n             // end-of-file indicator so the caller knows to stop reading.\n-            Ok(0) => {\n-                io_error::cond.raise(standard_error(EndOfFile));\n-                None\n-            }\n-            Ok(amt) => Some(amt),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n+            Ok(0) => { Err(standard_error(EndOfFile)) }\n+            ret @ Ok(..) | ret @ Err(..) => ret,\n         }\n     }\n }\n@@ -283,55 +284,41 @@ impl StdWriter {\n     /// when the writer is attached to something like a terminal, this is used\n     /// to fetch the dimensions of the terminal.\n     ///\n-    /// If successful, returns Some((width, height)).\n+    /// If successful, returns `Ok((width, height))`.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if an error\n-    /// happens.\n-    pub fn winsize(&mut self) -> Option<(int, int)> {\n+    /// This function will return an error if the output stream is not actually\n+    /// connected to a TTY instance, or if querying the TTY instance fails.\n+    pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n-            TTY(ref mut tty) => {\n-                match tty.get_winsize() {\n-                    Ok(p) => Some(p),\n-                    Err(e) => {\n-                        io_error::cond.raise(e);\n-                        None\n-                    }\n-                }\n-            }\n+            TTY(ref mut tty) => tty.get_winsize(),\n             File(..) => {\n-                io_error::cond.raise(IoError {\n+                Err(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n                     detail: None,\n-                });\n-                None\n+                })\n             }\n         }\n     }\n \n     /// Controls whether this output stream is a \"raw stream\" or simply a normal\n     /// stream.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if an error\n-    /// happens.\n-    pub fn set_raw(&mut self, raw: bool) {\n+    /// This function will return an error if the output stream is not actually\n+    /// connected to a TTY instance, or if querying the TTY instance fails.\n+    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n-            TTY(ref mut tty) => {\n-                match tty.set_raw(raw) {\n-                    Ok(()) => {},\n-                    Err(e) => io_error::cond.raise(e),\n-                }\n-            }\n+            TTY(ref mut tty) => tty.set_raw(raw),\n             File(..) => {\n-                io_error::cond.raise(IoError {\n+                Err(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n                     detail: None,\n-                });\n+                })\n             }\n         }\n     }\n@@ -346,14 +333,10 @@ impl StdWriter {\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, buf: &[u8]) {\n-        let ret = match self.inner {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        match self.inner {\n             TTY(ref mut tty) => tty.write(buf),\n             File(ref mut file) => file.write(buf),\n-        };\n-        match ret {\n-            Ok(()) => {}\n-            Err(e) => io_error::cond.raise(e)\n         }\n     }\n }\n@@ -376,7 +359,7 @@ mod tests {\n             set_stdout(~w as ~Writer);\n             println!(\"hello!\");\n         });\n-        assert_eq!(r.read_to_str(), ~\"hello!\\n\");\n+        assert_eq!(r.read_to_str().unwrap(), ~\"hello!\\n\");\n     })\n \n     iotest!(fn capture_stderr() {\n@@ -388,7 +371,7 @@ mod tests {\n             set_stderr(~w as ~Writer);\n             fail!(\"my special message\");\n         });\n-        let s = r.read_to_str();\n+        let s = r.read_to_str().unwrap();\n         assert!(s.contains(\"my special message\"));\n     })\n }"}, {"sha": "692aaa7afd05ed8fc992d14f1ef5a9c3c306cb8e", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -39,16 +39,17 @@ loop {\n */\n \n use comm::Port;\n-use option::Option;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n+use io::IoResult;\n \n pub struct Timer {\n     priv obj: ~RtioTimer\n }\n \n /// Sleep the current task for `msecs` milliseconds.\n pub fn sleep(msecs: u64) {\n-    let mut timer = Timer::new().expect(\"timer::sleep: could not create a Timer\");\n+    let timer = Timer::new();\n+    let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n \n     timer.sleep(msecs)\n }\n@@ -57,7 +58,7 @@ impl Timer {\n     /// Creates a new timer which can be used to put the current task to sleep\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n-    pub fn new() -> Option<Timer> {\n+    pub fn new() -> IoResult<Timer> {\n         LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n     }\n "}, {"sha": "c4d92b36ecfa60fca8b76463aeb55f4af0c6070f", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 55, "deletions": 40, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -7,8 +7,10 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use prelude::*;\n use cmp;\n+use io;\n use vec::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n@@ -25,9 +27,9 @@ impl<'a, R: Reader> LimitReader<'a, R> {\n }\n \n impl<'a, R: Reader> Reader for LimitReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         if self.limit == 0 {\n-            return None;\n+            return Err(io::standard_error(io::EndOfFile));\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n@@ -43,17 +45,17 @@ pub struct NullWriter;\n \n impl Writer for NullWriter {\n     #[inline]\n-    fn write(&mut self, _buf: &[u8]) { }\n+    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n pub struct ZeroReader;\n \n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         buf.set_memory(0);\n-        Some(buf.len())\n+        Ok(buf.len())\n     }\n }\n \n@@ -62,8 +64,8 @@ pub struct NullReader;\n \n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n-        None\n+    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> {\n+        Err(io::standard_error(io::EndOfFile))\n     }\n }\n \n@@ -81,17 +83,21 @@ impl MultiWriter {\n \n impl Writer for MultiWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            writer.write(buf);\n+            ret = ret.and(writer.write(buf));\n         }\n+        return ret;\n     }\n \n     #[inline]\n-    fn flush(&mut self) {\n+    fn flush(&mut self) -> io::IoResult<()> {\n+        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            writer.flush();\n+            ret = ret.and(writer.flush());\n         }\n+        return ret;\n     }\n }\n \n@@ -111,20 +117,25 @@ impl<R: Reader, I: Iterator<R>> ChainedReader<I, R> {\n }\n \n impl<R: Reader, I: Iterator<R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         loop {\n-            match self.cur_reader {\n+            let err = match self.cur_reader {\n                 Some(ref mut r) => {\n                     match r.read(buf) {\n-                        Some(len) => return Some(len),\n-                        None => {}\n+                        Ok(len) => return Ok(len),\n+                        Err(ref e) if e.kind == io::EndOfFile => None,\n+                        Err(e) => Some(e),\n                     }\n                 }\n                 None => break\n+            };\n+            self.cur_reader = self.readers.next();\n+            match err {\n+                Some(e) => return Err(e),\n+                None => {}\n             }\n-            self.cur_reader = self.readers.next()\n         }\n-        None\n+        Err(io::standard_error(io::EndOfFile))\n     }\n }\n \n@@ -150,27 +161,29 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n }\n \n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.reader.read(buf).map(|len| {\n-            self.writer.write(buf.slice_to(len));\n-            len\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.reader.read(buf).and_then(|len| {\n+            self.writer.write(buf.slice_to(len)).map(|()| len)\n         })\n     }\n }\n \n /// Copies all data from a `Reader` to a `Writer`.\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) {\n+pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     let mut buf = [0, ..super::DEFAULT_BUF_SIZE];\n     loop {\n-        match r.read(buf) {\n-            Some(len) => w.write(buf.slice_to(len)),\n-            None => break\n-        }\n+        let len = match r.read(buf) {\n+            Ok(len) => len,\n+            Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n+            Err(e) => return Err(e),\n+        };\n+        if_ok!(w.write(buf.slice_to(len)));\n     }\n }\n \n #[cfg(test)]\n mod test {\n+    use io;\n     use io::{MemReader, MemWriter};\n     use super::*;\n     use prelude::*;\n@@ -180,7 +193,7 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(&mut r, 4);\n-            assert_eq!(~[0, 1, 2], r.read_to_end());\n+            assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n         }\n     }\n \n@@ -189,32 +202,32 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(&mut r, 2);\n-            assert_eq!(~[0, 1], r.read_to_end());\n+            assert_eq!(~[0, 1], r.read_to_end().unwrap());\n         }\n-        assert_eq!(~[2], r.read_to_end());\n+        assert_eq!(~[2], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n         let buf = ~[0, 0, 0];\n-        s.write(buf);\n-        s.flush();\n+        s.write(buf).unwrap();\n+        s.flush().unwrap();\n     }\n \n     #[test]\n     fn test_zero_reader() {\n         let mut s = ZeroReader;\n         let mut buf = ~[1, 2, 3];\n-        assert_eq!(s.read(buf), Some(3));\n+        assert_eq!(s.read(buf), Ok(3));\n         assert_eq!(~[0, 0, 0], buf);\n     }\n \n     #[test]\n     fn test_null_reader() {\n         let mut r = NullReader;\n         let mut buf = ~[0];\n-        assert_eq!(r.read(buf), None);\n+        assert!(r.read(buf).is_err());\n     }\n \n     #[test]\n@@ -224,21 +237,23 @@ mod test {\n \n         struct TestWriter;\n         impl Writer for TestWriter {\n-            fn write(&mut self, _buf: &[u8]) {\n+            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> {\n                 unsafe { writes += 1 }\n+                Ok(())\n             }\n \n-            fn flush(&mut self) {\n+            fn flush(&mut self) -> io::IoResult<()> {\n                 unsafe { flushes += 1 }\n+                Ok(())\n             }\n         }\n \n         let mut multi = MultiWriter::new(~[~TestWriter as ~Writer,\n                                            ~TestWriter as ~Writer]);\n-        multi.write([1, 2, 3]);\n+        multi.write([1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n-        multi.flush();\n+        multi.flush().unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(2, unsafe { flushes });\n     }\n@@ -248,14 +263,14 @@ mod test {\n         let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n                    MemReader::new(~[2, 3])];\n         let mut r = ChainedReader::new(rs.move_iter());\n-        assert_eq!(~[0, 1, 2, 3], r.read_to_end());\n+        assert_eq!(~[0, 1, 2, 3], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n                                    MemWriter::new());\n-        assert_eq!(~[0, 1, 2], r.read_to_end());\n+        assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n         assert_eq!(~[0, 1, 2], w.unwrap());\n     }\n@@ -264,7 +279,7 @@ mod test {\n     fn test_copy() {\n         let mut r = MemReader::new(~[0, 1, 2, 3, 4]);\n         let mut w = MemWriter::new();\n-        copy(&mut r, &mut w);\n+        copy(&mut r, &mut w).unwrap();\n         assert_eq!(~[0, 1, 2, 3, 4], w.unwrap());\n     }\n }"}, {"sha": "c5e66ffc7be10bbd067abb0b6068a078c5b705e3", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -102,6 +102,7 @@ use io::Writer;\n use ops::Drop;\n use option::{Some, None, Option};\n use prelude::drop;\n+use result::{Ok, Err};\n use rt::local::Local;\n use rt::task::Task;\n use util;\n@@ -131,13 +132,19 @@ struct DefaultLogger {\n impl Logger for DefaultLogger {\n     // by default, just ignore the level\n     fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n-        fmt::writeln(&mut self.handle, args);\n+        match fmt::writeln(&mut self.handle, args) {\n+            Err(e) => fail!(\"failed to log: {}\", e),\n+            Ok(()) => {}\n+        }\n     }\n }\n \n impl Drop for DefaultLogger {\n     fn drop(&mut self) {\n-        self.handle.flush();\n+        match self.handle.flush() {\n+            Err(e) => fail!(\"failed to flush a logger: {}\", e),\n+            Ok(()) => {}\n+        }\n     }\n }\n "}, {"sha": "b31ae92d7421da08271cc11a09e6cb5f5aca69d1", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -197,3 +197,8 @@ macro_rules! local_data_key (\n         pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n     )\n )\n+\n+#[macro_export]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)"}, {"sha": "19478e3dbb3c8ed99e5faa8177d6634f1ff95be8", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -382,7 +382,7 @@ impl<T: Default> Option<T> {\n \n impl<T: fmt::Show> fmt::Show for Option<T> {\n     #[inline]\n-    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) {\n+    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) -> fmt::Result {\n         match *s {\n             Some(ref t) => write!(f.buf, \"Some({})\", *t),\n             None        => write!(f.buf, \"None\")"}, {"sha": "541db01f1484f351b6855fb22905ae13515df288", "filename": "src/libstd/os.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -372,9 +372,9 @@ pub fn self_exe_name() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         use std::io;\n \n-        match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n-            Ok(Some(path)) => Some(path.as_vec().to_owned()),\n-            Ok(None) | Err(..) => None\n+        match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n+            Ok(path) => Some(path.as_vec().to_owned()),\n+            Err(..) => None\n         }\n     }\n \n@@ -929,7 +929,7 @@ pub enum MapError {\n }\n \n impl fmt::Show for MapError {\n-    fn fmt(val: &MapError, out: &mut fmt::Formatter) {\n+    fn fmt(val: &MapError, out: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *val {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n             ErrInvalidFd => \"Invalid fd\",\n@@ -944,23 +944,19 @@ impl fmt::Show for MapError {\n             ErrAlreadyExists => \"File mapping for specified file already exists\",\n             ErrZeroLength => \"Zero-length mapping not allowed\",\n             ErrUnknown(code) => {\n-                write!(out.buf, \"Unknown error = {}\", code);\n-                return\n+                return write!(out.buf, \"Unknown error = {}\", code)\n             },\n             ErrVirtualAlloc(code) => {\n-                write!(out.buf, \"VirtualAlloc failure = {}\", code);\n-                return\n+                return write!(out.buf, \"VirtualAlloc failure = {}\", code)\n             },\n             ErrCreateFileMappingW(code) => {\n-                format!(\"CreateFileMappingW failure = {}\", code);\n-                return\n+                return write!(out.buf, \"CreateFileMappingW failure = {}\", code)\n             },\n             ErrMapViewOfFile(code) => {\n-                write!(out.buf, \"MapViewOfFile failure = {}\", code);\n-                return\n+                return write!(out.buf, \"MapViewOfFile failure = {}\", code)\n             }\n         };\n-        write!(out.buf, \"{}\", str);\n+        write!(out.buf, \"{}\", str)\n     }\n }\n \n@@ -1496,7 +1492,6 @@ mod tests {\n         use result::{Ok, Err};\n         use os::*;\n         use libc::*;\n-        use io;\n         use io::fs;\n \n         #[cfg(unix)]\n@@ -1540,9 +1535,9 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n+        drop(chunk);\n \n-        let _guard = io::ignore_io_error();\n-        fs::unlink(&path);\n+        fs::unlink(&path).unwrap();\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "4aa4a3feab1be045e8bcc5abe52a1e0e6a833319", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -533,7 +533,7 @@ pub struct Display<'a, P> {\n }\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n-    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) {\n+    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Result {\n         d.with_str(|s| f.pad(s))\n     }\n }"}, {"sha": "e9068c6b0c8a54c66690b64e6f4982e7f8e71c3d", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -62,7 +62,7 @@ impl OSRng {\n     pub fn new() -> OSRng {\n         use path::Path;\n         let reader = File::open(&Path::new(\"/dev/urandom\"));\n-        let reader = reader.expect(\"Error opening /dev/urandom\");\n+        let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n \n         OSRng { inner: reader_rng }"}, {"sha": "621d70970f02f8de9202f66f7dff383591ca508c", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,7 +11,7 @@\n //! A wrapper around any Reader to treat it as an RNG.\n \n use container::Container;\n-use option::{Some, None};\n+use result::{Ok, Err};\n use io::Reader;\n \n use rand::Rng;\n@@ -49,26 +49,26 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         // platform just involves blitting the bytes into the memory\n         // of the u32, similarly for BE on BE; avoiding byteswapping.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u32()\n+            self.reader.read_le_u32().unwrap()\n         } else {\n-            self.reader.read_be_u32()\n+            self.reader.read_be_u32().unwrap()\n         }\n     }\n     fn next_u64(&mut self) -> u64 {\n         // see above for explanation.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u64()\n+            self.reader.read_le_u64().unwrap()\n         } else {\n-            self.reader.read_be_u64()\n+            self.reader.read_be_u64().unwrap()\n         }\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {\n         if v.len() == 0 { return }\n         match self.reader.read(v) {\n-            Some(n) if n == v.len() => return,\n-            Some(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n-                              read {} out of {} bytes.\", n, v.len()),\n-            None => fail!(\"ReaderRng.fill_bytes reached eof.\")\n+            Ok(n) if n == v.len() => return,\n+            Ok(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n+                            read {} out of {} bytes.\", n, v.len()),\n+            Err(e) => fail!(\"ReaderRng.fill_bytes error: {}\", e)\n         }\n     }\n }"}, {"sha": "44ee5de7ac34cc3c1018960eb15dbe1f7faecc97", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -66,6 +66,8 @@ impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     pub fn bump_past<T>(&mut self) {\n         self.bump(mem::size_of::<T>());\n     }\n+\n+    pub fn unwrap(self) -> V { self.inner }\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait"}, {"sha": "f71649602b23144cbb0f4d17ad34469bf625f971", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -21,48 +21,57 @@ use char;\n use container::Container;\n use io;\n use iter::Iterator;\n-use option::{Some, None};\n+use option::{Some, None, Option};\n use ptr;\n use reflect;\n use reflect::{MovePtr, align};\n+use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n use vec::OwnedVector;\n use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use unstable::raw;\n \n+macro_rules! if_ok( ($me:expr, $e:expr) => (\n+    match $e {\n+        Ok(()) => {},\n+        Err(e) => { $me.last_err = Some(e); return false; }\n+    }\n+) )\n+\n /// Representations\n \n trait Repr {\n-    fn write_repr(&self, writer: &mut io::Writer);\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;\n }\n \n impl Repr for () {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n-        writer.write(\"()\".as_bytes());\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n+        writer.write(\"()\".as_bytes())\n     }\n }\n \n impl Repr for bool {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = if *self { \"true\" } else { \"false\" };\n         writer.write(s.as_bytes())\n     }\n }\n \n impl Repr for int {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         ::int::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits);\n+            writer.write(bits)\n         })\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         ::$ty::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits);\n-            writer.write(bytes!($suffix));\n+            writer.write(bits).and_then(|()| {\n+                writer.write(bytes!($suffix))\n+            })\n         })\n     }\n }))\n@@ -78,10 +87,11 @@ int_repr!(u32, \"u32\")\n int_repr!(u64, \"u64\")\n \n macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = self.to_str();\n-        writer.write(s.as_bytes());\n-        writer.write(bytes!($suffix));\n+        writer.write(s.as_bytes()).and_then(|()| {\n+            writer.write(bytes!($suffix))\n+        })\n     }\n }))\n \n@@ -100,7 +110,8 @@ pub struct ReprVisitor<'a> {\n     priv ptr: *u8,\n     priv ptr_stk: ~[*u8],\n     priv var_stk: ~[VariantState],\n-    priv writer: &'a mut io::Writer\n+    priv writer: &'a mut io::Writer,\n+    priv last_err: Option<io::IoError>,\n }\n \n pub fn ReprVisitor<'a>(ptr: *u8,\n@@ -110,6 +121,7 @@ pub fn ReprVisitor<'a>(ptr: *u8,\n         ptr_stk: ~[],\n         var_stk: ~[],\n         writer: writer,\n+        last_err: None,\n     }\n }\n \n@@ -130,11 +142,10 @@ impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n-    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T|) -> bool {\n+    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n-            f(self, transmute::<*u8,&T>(self.ptr));\n+            f(self, transmute::<*u8,&T>(self.ptr))\n         }\n-        true\n     }\n \n     #[inline]\n@@ -152,43 +163,53 @@ impl<'a> ReprVisitor<'a> {\n                 ptr_stk: ~[],\n                 var_stk: ~[],\n                 writer: ::cast::transmute_copy(&self.writer),\n+                last_err: None,\n             };\n             let mut v = reflect::MovePtrAdaptor(u);\n             // Obviously this should not be a thing, but blame #8401 for now\n             visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            true\n+            match v.unwrap().last_err {\n+                Some(e) => {\n+                    self.last_err = Some(e);\n+                    false\n+                }\n+                None => true,\n+            }\n         }\n     }\n \n     #[inline]\n     pub fn write<T:Repr>(&mut self) -> bool {\n         self.get(|this, v:&T| {\n-            v.write_repr(unsafe { ::cast::transmute_copy(&this.writer) });\n+            if_ok!(this, v.write_repr(this.writer));\n+            true\n         })\n     }\n \n-    pub fn write_escaped_slice(&mut self, slice: &str) {\n-        self.writer.write(['\"' as u8]);\n+    pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n+        if_ok!(self, self.writer.write(['\"' as u8]));\n         for ch in slice.chars() {\n-            self.write_escaped_char(ch, true);\n+            if !self.write_escaped_char(ch, true) { return false }\n         }\n-        self.writer.write(['\"' as u8]);\n+        if_ok!(self, self.writer.write(['\"' as u8]));\n+        true\n     }\n \n-    pub fn write_mut_qualifier(&mut self, mtbl: uint) {\n+    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n         if mtbl == 0 {\n-            self.writer.write(\"mut \".as_bytes());\n+            if_ok!(self, self.writer.write(\"mut \".as_bytes()));\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n             fail!(\"invalid mutability value\");\n         }\n+        true\n     }\n \n     pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        self.writer.write(['[' as u8]);\n+        if_ok!(self, self.writer.write(['[' as u8]));\n         let mut first = true;\n         let mut left = len;\n         // unit structs have 0 size, and don't loop forever.\n@@ -197,22 +218,22 @@ impl<'a> ReprVisitor<'a> {\n             if first {\n                 first = false;\n             } else {\n-                self.writer.write(\", \".as_bytes());\n+                if_ok!(self, self.writer.write(\", \".as_bytes()));\n             }\n             self.visit_ptr_inner(p as *u8, inner);\n             p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n-        self.writer.write([']' as u8]);\n+        if_ok!(self, self.writer.write([']' as u8]));\n         true\n     }\n \n     pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n         self.write_vec_range(ptr::to_unsafe_ptr(&v.data), v.fill, inner)\n     }\n \n-    fn write_escaped_char(&mut self, ch: char, is_str: bool) {\n-        match ch {\n+    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n+        if_ok!(self, match ch {\n             '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n             '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n             '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n@@ -234,16 +255,18 @@ impl<'a> ReprVisitor<'a> {\n             '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n             _ => {\n                 char::escape_unicode(ch, |c| {\n-                    self.writer.write([c as u8]);\n-                })\n+                    let _ = self.writer.write([c as u8]);\n+                });\n+                Ok(())\n             }\n-        }\n+        });\n+        return true;\n     }\n }\n \n impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_bot(&mut self) -> bool {\n-        self.writer.write(\"!\".as_bytes());\n+        if_ok!(self, self.writer.write(\"!\".as_bytes()));\n         true\n     }\n     fn visit_nil(&mut self) -> bool { self.write::<()>() }\n@@ -265,9 +288,10 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_char(&mut self) -> bool {\n         self.get::<char>(|this, &ch| {\n-            this.writer.write(['\\'' as u8]);\n-            this.write_escaped_char(ch, false);\n-            this.writer.write(['\\'' as u8]);\n+            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            if !this.write_escaped_char(ch, false) { return false }\n+            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            true\n         })\n     }\n \n@@ -277,8 +301,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_estr_uniq(&mut self) -> bool {\n         self.get::<~str>(|this, s| {\n-            this.writer.write(['~' as u8]);\n-            this.write_escaped_slice(*s);\n+            if_ok!(this, this.writer.write(['~' as u8]));\n+            this.write_escaped_slice(*s)\n         })\n     }\n \n@@ -291,34 +315,35 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _align: uint) -> bool { fail!(); }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['@' as u8]);\n+        if_ok!(self, self.writer.write(['@' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n-            this.visit_ptr_inner(p, inner);\n+            this.visit_ptr_inner(p, inner)\n         })\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['~' as u8]);\n+        if_ok!(self, self.writer.write(['~' as u8]));\n         self.get::<*u8>(|this, b| {\n-            this.visit_ptr_inner(*b, inner);\n+            this.visit_ptr_inner(*b, inner)\n         })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n         self.get::<*u8>(|this, p| {\n-            write!(this.writer, \"({} as *\", *p);\n+            if_ok!(this, write!(this.writer, \"({} as *\", *p));\n             this.write_mut_qualifier(mtbl);\n-            this.writer.write(\"())\".as_bytes());\n+            if_ok!(this, this.writer.write(\"())\".as_bytes()));\n+            true\n         })\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['&' as u8]);\n+        if_ok!(self, self.writer.write(['&' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<*u8>(|this, p| {\n-            this.visit_ptr_inner(*p, inner);\n+            this.visit_ptr_inner(*p, inner)\n         })\n     }\n \n@@ -327,76 +352,76 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Vec<()>>(|this, b| {\n-            this.write_unboxed_vec_repr(mtbl, b, inner);\n+            this.write_unboxed_vec_repr(mtbl, b, inner)\n         })\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            this.writer.write(['@' as u8]);\n+            if_ok!(this, this.writer.write(['@' as u8]));\n             this.write_mut_qualifier(mtbl);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+            this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n         })\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Vec<()>>(|this, b| {\n-            this.writer.write(['~' as u8]);\n-            this.write_unboxed_vec_repr(mtbl, *b, inner);\n+            if_ok!(this, this.writer.write(['~' as u8]));\n+            this.write_unboxed_vec_repr(mtbl, *b, inner)\n         })\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n-            this.writer.write(['&' as u8]);\n+            if_ok!(this, this.writer.write(['&' as u8]));\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n             };\n-            this.write_vec_range(s.data, s.len * size, inner);\n+            this.write_vec_range(s.data, s.len * size, inner)\n         })\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n-            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n+            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner)\n         })\n     }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['{' as u8]);\n+        if_ok!(self, self.writer.write(['{' as u8]));\n         true\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.write_mut_qualifier(mtbl);\n-        self.writer.write(name.as_bytes());\n-        self.writer.write(\": \".as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n+        if_ok!(self, self.writer.write(\": \".as_bytes()));\n         self.visit_inner(inner);\n         true\n     }\n \n     fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['}' as u8]);\n+        if_ok!(self, self.writer.write(['}' as u8]));\n         true\n     }\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          _sz: uint, _align: uint) -> bool {\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         if n_fields != 0 {\n             if named_fields {\n-                self.writer.write(['{' as u8]);\n+                if_ok!(self, self.writer.write(['{' as u8]));\n             } else {\n-                self.writer.write(['(' as u8]);\n+                if_ok!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -405,11 +430,11 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n                          _mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         if named {\n-            self.writer.write(name.as_bytes());\n-            self.writer.write(\": \".as_bytes());\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n+            if_ok!(self, self.writer.write(\": \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -419,23 +444,23 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                          _sz: uint, _align: uint) -> bool {\n         if n_fields != 0 {\n             if named_fields {\n-                self.writer.write(['}' as u8]);\n+                if_ok!(self, self.writer.write(['}' as u8]));\n             } else {\n-                self.writer.write([')' as u8]);\n+                if_ok!(self, self.writer.write([')' as u8]));\n             }\n         }\n         true\n     }\n \n     fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['(' as u8]);\n+        if_ok!(self, self.writer.write(['(' as u8]));\n         true\n     }\n \n     fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -444,9 +469,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         if _n_fields == 1 {\n-            self.writer.write([',' as u8]);\n+            if_ok!(self, self.writer.write([',' as u8]));\n         }\n-        self.writer.write([')' as u8]);\n+        if_ok!(self, self.writer.write([')' as u8]));\n         true\n     }\n \n@@ -482,9 +507,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         }\n \n         if write {\n-            self.writer.write(name.as_bytes());\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n             if n_fields > 0 {\n-                self.writer.write(['(' as u8]);\n+                if_ok!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -498,7 +523,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n-                    self.writer.write(\", \".as_bytes());\n+                    if_ok!(self, self.writer.write(\", \".as_bytes()));\n                 }\n                 if ! self.visit_inner(inner) {\n                     return false;\n@@ -516,7 +541,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n-                    self.writer.write([')' as u8]);\n+                    if_ok!(self, self.writer.write([')' as u8]));\n                 }\n             }\n             _ => ()\n@@ -538,28 +563,29 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool {\n-        self.writer.write(\"fn(\".as_bytes());\n+        if_ok!(self, self.writer.write(\"fn(\".as_bytes()));\n         true\n     }\n \n     fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         let name = unsafe { (*inner).name };\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n \n-    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n+                       inner: *TyDesc) -> bool {\n         if variadic {\n-            self.writer.write(\", ...\".as_bytes());\n+            if_ok!(self, self.writer.write(\", ...\".as_bytes()));\n         }\n-        self.writer.write(\")\".as_bytes());\n+        if_ok!(self, self.writer.write(\")\".as_bytes()));\n         let name = unsafe { (*inner).name };\n         if name != \"()\" {\n-            self.writer.write(\" -> \".as_bytes());\n-            self.writer.write(name.as_bytes());\n+            if_ok!(self, self.writer.write(\" -> \".as_bytes()));\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n         }\n         true\n     }\n@@ -569,7 +595,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n \n@@ -582,13 +608,17 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n-pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n+pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor(u);\n         visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n+        match v.unwrap().last_err {\n+            Some(e) => Err(e),\n+            None => Ok(()),\n+        }\n     }\n }\n \n@@ -597,7 +627,7 @@ pub fn repr_to_str<T>(t: &T) -> ~str {\n     use io;\n \n     let mut result = io::MemWriter::new();\n-    write_repr(&mut result as &mut io::Writer, t);\n+    write_repr(&mut result as &mut io::Writer, t).unwrap();\n     str::from_utf8_owned(result.unwrap()).unwrap()\n }\n \n@@ -615,7 +645,7 @@ fn test_repr() {\n \n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n-        write_repr(&mut m as &mut io::Writer, t);\n+        write_repr(&mut m as &mut io::Writer, t).unwrap();\n         let s = str::from_utf8_owned(m.unwrap()).unwrap();\n         assert_eq!(s.as_slice(), e);\n     }"}, {"sha": "846bba7533fed755ceee6972b440d672dee5ff26", "filename": "src/libstd/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -208,7 +208,7 @@ impl<T, E> Result<T, E> {\n \n impl<T: fmt::Show, E: fmt::Show> fmt::Show for Result<T, E> {\n     #[inline]\n-    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) {\n+    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) -> fmt::Result {\n         match *s {\n             Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n             Err(ref e) => write!(f.buf, \"Err({})\", *e)"}, {"sha": "35b1e21df067731e6e93b5f97affca2685673710", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -16,13 +16,13 @@ use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n use path::Path;\n-use result::{Result, Ok, Err};\n+use result::{Result, Err};\n use rt::task::Task;\n use rt::local::Local;\n \n use ai = io::net::addrinfo;\n use io;\n-use io::IoError;\n+use io::{IoError, IoResult};\n use io::net::ip::{IpAddr, SocketAddr};\n use io::process::{ProcessConfig, ProcessExit};\n use io::signal::Signum;\n@@ -116,23 +116,12 @@ impl<'a> LocalIo<'a> {\n         return ret;\n     }\n \n-    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>)\n-        -> Option<T>\n+    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n+        -> IoResult<T>\n     {\n         match LocalIo::borrow() {\n-            None => {\n-                io::io_error::cond.raise(io::standard_error(io::IoUnavailable));\n-                None\n-            }\n-            Some(mut io) => {\n-                match f(io.get()) {\n-                    Ok(t) => Some(t),\n-                    Err(ioerr) => {\n-                        io::io_error::cond.raise(ioerr);\n-                        None\n-                    }\n-                }\n-            }\n+            None => Err(io::standard_error(io::IoUnavailable)),\n+            Some(mut io) => f(io.get()),\n         }\n     }\n "}, {"sha": "515eb93001af2e56a1d957948fd6e69879cae4b4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -119,15 +119,16 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n+                #[allow(unused_must_use)]\n                 fn close_outputs() {\n                     let mut task = Local::borrow(None::<Task>);\n                     let logger = task.get().logger.take();\n                     let stderr = task.get().stderr.take();\n                     let stdout = task.get().stdout.take();\n                     drop(task);\n                     drop(logger); // loggers are responsible for flushing\n-                    match stdout { Some(mut w) => w.flush(), None => {} }\n-                    match stderr { Some(mut w) => w.flush(), None => {} }\n+                    match stdout { Some(mut w) => { w.flush(); }, None => {} }\n+                    match stderr { Some(mut w) => { w.flush(); }, None => {} }\n                 }\n \n                 // First, flush/destroy the user stdout/logger because these"}, {"sha": "9aece13b84ca1cf1b8ae4ee8cdc46f764144cfe2", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -464,9 +464,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             match task.stderr.take() {\n                 Some(mut stderr) => {\n                     Local::put(task);\n-                    format_args!(|args| ::fmt::writeln(stderr, args),\n-                                 \"task '{}' failed at '{}', {}:{}\",\n-                                 n, msg_s, file, line);\n+                    // FIXME: what to do when the task printing fails?\n+                    let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n+                                            \"task '{}' failed at '{}', {}:{}\",\n+                                            n, msg_s, file, line);\n                     task = Local::take();\n \n                     match util::replace(&mut task.stderr, Some(stderr)) {"}, {"sha": "69e240f30bcf026af4a40d3e98a85f800ac6f815", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,10 +11,12 @@\n use container::Container;\n use fmt;\n use from_str::FromStr;\n+use io::IoResult;\n use iter::Iterator;\n use libc;\n use option::{Some, None, Option};\n use os;\n+use result::Ok;\n use str::StrSlice;\n use unstable::running_on_valgrind;\n use vec::ImmutableVector;\n@@ -73,16 +75,17 @@ pub fn dumb_println(args: &fmt::Arguments) {\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) {\n+        fn write(&mut self, data: &[u8]) -> IoResult<()> {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n                             data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n+            Ok(()) // yes, we're lying\n         }\n     }\n     let mut w = Stderr;\n-    fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "04e42b3eedfc5d5020cbb1a430b4dca7c9c990ff", "filename": "src/libstd/run.rs", "status": "modified", "additions": 49, "deletions": 71, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,6 +11,7 @@\n //! Utilities for spawning and managing processes\n \n #[allow(missing_doc)];\n+#[deny(unused_must_use)];\n \n use comm::SharedChan;\n use io::Reader;\n@@ -119,7 +120,8 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Option<Process> {\n+    pub fn new(prog: &str, args: &[~str],\n+               options: ProcessOptions) -> io::IoResult<Process> {\n         let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n         let env = env.as_ref().map(|a| a.as_slice());\n         let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n@@ -138,10 +140,7 @@ impl Process {\n             cwd: cwd,\n             io: rtio,\n         };\n-        match process::Process::new(rtconfig) {\n-            Some(inner) => Some(Process { inner: inner }),\n-            None => None\n-        }\n+        process::Process::new(rtconfig).map(|p| Process { inner: p })\n     }\n \n     /// Returns the unique id of the process\n@@ -224,19 +223,17 @@ impl Process {\n         let ch_clone = ch.clone();\n \n         spawn(proc() {\n-            let _guard = io::ignore_io_error();\n             let mut error = error;\n             match error {\n                 Some(ref mut e) => ch.send((2, e.read_to_end())),\n-                None => ch.send((2, ~[]))\n+                None => ch.send((2, Ok(~[])))\n             }\n         });\n         spawn(proc() {\n-            let _guard = io::ignore_io_error();\n             let mut output = output;\n             match output {\n                 Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n-                None => ch_clone.send((1, ~[]))\n+                None => ch_clone.send((1, Ok(~[])))\n             }\n         });\n \n@@ -251,8 +248,8 @@ impl Process {\n         };\n \n         return ProcessOutput {status: status,\n-                              output: outs,\n-                              error: errs};\n+                              output: outs.ok().unwrap_or(~[]),\n+                              error: errs.ok().unwrap_or(~[]) };\n     }\n \n     /**\n@@ -262,9 +259,10 @@ impl Process {\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) {\n-        self.inner.signal(io::process::PleaseExitSignal);\n+    pub fn destroy(&mut self) -> io::IoResult<()> {\n+        let ret = self.inner.signal(io::process::PleaseExitSignal);\n         self.finish();\n+        return ret;\n     }\n \n     /**\n@@ -274,9 +272,12 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) {\n-        self.inner.signal(io::process::MustDieSignal);\n+    pub fn force_destroy(&mut self) -> io::IoResult<()> {\n+        // This should never fail because we own the process\n+        let ret = self.inner.signal(io::process::MustDieSignal);\n         self.finish();\n+        return ret;\n+\n     }\n }\n \n@@ -293,18 +294,14 @@ impl Process {\n  *\n  * The process's exit code, or None if the child process could not be started\n  */\n-pub fn process_status(prog: &str, args: &[~str]) -> Option<ProcessExit> {\n-    let mut opt_prog = Process::new(prog, args, ProcessOptions {\n+pub fn process_status(prog: &str, args: &[~str]) -> io::IoResult<ProcessExit> {\n+    Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n         in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n         out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n         err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n-    });\n-    match opt_prog {\n-        Some(ref mut prog) => Some(prog.finish()),\n-        None => None\n-    }\n+    }).map(|mut p| p.finish())\n }\n \n /**\n@@ -320,12 +317,10 @@ pub fn process_status(prog: &str, args: &[~str]) -> Option<ProcessExit> {\n  * The process's stdout/stderr output and exit code, or None if the child process could not be\n  * started.\n  */\n-pub fn process_output(prog: &str, args: &[~str]) -> Option<ProcessOutput> {\n-    let mut opt_prog = Process::new(prog, args, ProcessOptions::new());\n-    match opt_prog {\n-        Some(ref mut prog) => Some(prog.finish_with_output()),\n-        None => None\n-    }\n+pub fn process_output(prog: &str, args: &[~str]) -> io::IoResult<ProcessOutput> {\n+    Process::new(prog, args, ProcessOptions::new()).map(|mut p| {\n+        p.finish_with_output()\n+    })\n }\n \n #[cfg(test)]\n@@ -337,41 +332,33 @@ mod tests {\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::pipe::PipeStream;\n-    use io::{io_error, FileNotFound};\n+    use io::{FileNotFound};\n     use libc::c_int;\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_status() {\n-        let mut status = run::process_status(\"false\", []).expect(\"failed to exec `false`\");\n+        let mut status = run::process_status(\"false\", []).unwrap();\n         assert!(status.matches_exit_status(1));\n \n-        status = run::process_status(\"true\", []).expect(\"failed to exec `true`\");\n+        status = run::process_status(\"true\", []).unwrap();\n         assert!(status.success());\n     }\n \n     #[test]\n     fn test_process_output_fail_to_start() {\n-        // If the executable does not exist, then the io_error condition should be raised with\n-        // IoErrorKind FileNotFound.\n-\n-        let mut trapped_io_error = false;\n-        let opt_outp = io_error::cond.trap(|e| {\n-            trapped_io_error = true;\n-            assert_eq!(e.kind, FileNotFound);\n-        }).inside(|| -> Option<run::ProcessOutput> {\n-            run::process_output(\"/no-binary-by-this-name-should-exist\", [])\n-        });\n-        assert!(trapped_io_error);\n-        assert!(opt_outp.is_none());\n+        match run::process_output(\"/no-binary-by-this-name-should-exist\", []) {\n+            Err(e) => assert_eq!(e.kind, FileNotFound),\n+            Ok(..) => fail!()\n+        }\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_output_output() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"echo\", [~\"hello\"]).expect(\"failed to exec `echo`\");\n+             = run::process_output(\"echo\", [~\"hello\"]).unwrap();\n         let output_str = str::from_utf8_owned(output).unwrap();\n \n         assert!(status.success());\n@@ -387,7 +374,7 @@ mod tests {\n     fn test_process_output_error() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"mkdir\", [~\".\"]).expect(\"failed to exec `mkdir`\");\n+             = run::process_output(\"mkdir\", [~\".\"]).unwrap();\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, ~[]);\n@@ -408,7 +395,7 @@ mod tests {\n             in_fd: Some(pipe_in.input),\n             out_fd: Some(pipe_out.out),\n             err_fd: Some(pipe_err.out)\n-        }).expect(\"failed to exec `cat`\");\n+        }).unwrap();\n \n         os::close(pipe_in.input as int);\n         os::close(pipe_out.out as int);\n@@ -426,35 +413,26 @@ mod tests {\n \n     fn writeclose(fd: c_int, s: &str) {\n         let mut writer = PipeStream::open(fd);\n-        writer.write(s.as_bytes());\n+        writer.write(s.as_bytes()).unwrap();\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n-        let mut res = ~[];\n-        let mut reader = PipeStream::open(fd);\n-        let mut buf = [0, ..1024];\n-        loop {\n-            match reader.read(buf) {\n-                Some(n) => { res.push_all(buf.slice_to(n)); }\n-                None => break\n-            }\n-        }\n-        str::from_utf8_owned(res).unwrap()\n+        PipeStream::open(fd).read_to_str().unwrap()\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_once() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .expect(\"failed to exec `false`\");\n+            .unwrap();\n         assert!(prog.finish().matches_exit_status(1));\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_twice() {\n         let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .expect(\"failed to exec `false`\");\n+            .unwrap();\n         assert!(prog.finish().matches_exit_status(1));\n         assert!(prog.finish().matches_exit_status(1));\n     }\n@@ -464,7 +442,7 @@ mod tests {\n     fn test_finish_with_output_once() {\n \n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .expect(\"failed to exec `echo`\");\n+            .unwrap();\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n         let output_str = str::from_utf8_owned(output).unwrap();\n@@ -482,7 +460,7 @@ mod tests {\n     fn test_finish_with_output_twice() {\n \n         let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .expect(\"failed to exec `echo`\");\n+            .unwrap();\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n@@ -511,22 +489,22 @@ mod tests {\n         run::Process::new(\"pwd\", [], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `pwd`\")\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `/system/bin/sh`\")\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to run `cmd`\")\n+        }).unwrap()\n     }\n \n     #[test]\n@@ -537,8 +515,8 @@ mod tests {\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat();\n-        let child_stat = child_dir.stat();\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n@@ -554,8 +532,8 @@ mod tests {\n         let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n         let child_dir = Path::new(output.trim());\n \n-        let parent_stat = parent_dir.stat();\n-        let child_stat = child_dir.stat();\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n@@ -566,22 +544,22 @@ mod tests {\n         run::Process::new(\"env\", [], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `env`\")\n+        }).unwrap()\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to exec `/system/bin/sh`\")\n+        }).unwrap()\n     }\n \n     #[cfg(windows)]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        }).expect(\"failed to run `cmd`\")\n+        }).unwrap()\n     }\n \n     #[test]"}, {"sha": "5fa0c6431ab5caa5c7e31f55fd904368a5809660", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -541,7 +541,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     avoid_copying_the_body(|f| {\n-        try(proc() {\n+        let _ = try(proc() {\n             f()\n         });\n     })"}, {"sha": "c8bd1907c5c0e59f7a18983db5b78fb989010c1e", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -349,7 +349,7 @@ impl<A:IterBytes> ToBytes for A {\n \n         let mut m = ::io::MemWriter::new();\n         self.iter_bytes(lsb0, |bytes| {\n-            m.write(bytes);\n+            m.write(bytes).unwrap();\n             true\n         });\n         m.unwrap()"}, {"sha": "c2fa168a47825bad0857474df67ffbea25a2448e", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -200,7 +200,7 @@ mod tests {\n             // accesses will also fail.\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n-            task::try(proc() {\n+            let _ = task::try(proc() {\n                 x2.with(|one| assert_eq!(*one, 2))\n             });\n             x.with(|one| assert_eq!(*one, 1));"}, {"sha": "5b3b436a6fc5a71813d230249a3d4b03b40637c0", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -189,58 +189,61 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n-    local_data_key!(tls_terminal: ~Option<term::Terminal<StdWriter>>)\n+fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n+    local_data_key!(tls_terminal: Option<term::Terminal<StdWriter>>)\n+\n \n     fn is_stderr_screen() -> bool {\n         use std::libc;\n         unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n     }\n-    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str, c: term::attr::Attr) {\n-        term.attr(c);\n-        term.write(s.as_bytes());\n-        term.reset();\n+    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str,\n+                               c: term::attr::Attr) -> io::IoResult<()> {\n+        if_ok!(term.attr(c));\n+        if_ok!(term.write(s.as_bytes()));\n+        if_ok!(term.reset());\n+        Ok(())\n     }\n \n     if is_stderr_screen() {\n         local_data::get_mut(tls_terminal, |term| {\n             match term {\n                 Some(term) => {\n-                    match **term {\n+                    match *term {\n                         Some(ref mut term) => write_pretty(term, msg, color),\n                         None => io::stderr().write(msg.as_bytes())\n                     }\n                 }\n                 None => {\n-                    let t = ~match term::Terminal::new(io::stderr()) {\n+                    let (t, ret) = match term::Terminal::new(io::stderr()) {\n                         Ok(mut term) => {\n-                            write_pretty(&mut term, msg, color);\n-                            Some(term)\n+                            let r = write_pretty(&mut term, msg, color);\n+                            (Some(term), r)\n                         }\n                         Err(_) => {\n-                            io::stderr().write(msg.as_bytes());\n-                            None\n+                            (None, io::stderr().write(msg.as_bytes()))\n                         }\n                     };\n                     local_data::set(tls_terminal, t);\n+                    ret\n                 }\n             }\n-        });\n+        })\n     } else {\n-        io::stderr().write(msg.as_bytes());\n+        io::stderr().write(msg.as_bytes())\n     }\n }\n \n-fn print_diagnostic(topic: &str, lvl: Level, msg: &str) {\n-    let mut stderr = io::stderr();\n-\n+fn print_diagnostic(topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n     if !topic.is_empty() {\n-        write!(&mut stderr as &mut io::Writer, \"{} \", topic);\n+        let mut stderr = io::stderr();\n+        if_ok!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n     }\n \n-    print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n-                       term::attr::ForegroundColor(lvl.color()));\n-    print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold);\n+    if_ok!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n+                              term::attr::ForegroundColor(lvl.color())));\n+    if_ok!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n+    Ok(())\n }\n \n pub struct DefaultEmitter;\n@@ -250,20 +253,28 @@ impl Emitter for DefaultEmitter {\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: Level) {\n-        match cmsp {\n+        let error = match cmsp {\n             Some((cm, sp)) => emit(cm, sp, msg, lvl, false),\n             None => print_diagnostic(\"\", lvl, msg),\n+        };\n+\n+        match error {\n+            Ok(()) => {}\n+            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n \n     fn custom_emit(&self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level) {\n-        emit(cm, sp, msg, lvl, true);\n+        match emit(cm, sp, msg, lvl, true) {\n+            Ok(()) => {}\n+            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n+        }\n     }\n }\n \n fn emit(cm: &codemap::CodeMap, sp: Span,\n-        msg: &str, lvl: Level, custom: bool) {\n+        msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let ss = cm.span_to_str(sp);\n     let lines = cm.span_to_lines(sp);\n     if custom {\n@@ -272,19 +283,19 @@ fn emit(cm: &codemap::CodeMap, sp: Span,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n-        print_diagnostic(ses, lvl, msg);\n-        custom_highlight_lines(cm, sp, lvl, lines);\n+        if_ok!(print_diagnostic(ses, lvl, msg));\n+        if_ok!(custom_highlight_lines(cm, sp, lvl, lines));\n     } else {\n-        print_diagnostic(ss, lvl, msg);\n-        highlight_lines(cm, sp, lvl, lines);\n+        if_ok!(print_diagnostic(ss, lvl, msg));\n+        if_ok!(highlight_lines(cm, sp, lvl, lines));\n     }\n-    print_macro_backtrace(cm, sp);\n+    print_macro_backtrace(cm, sp)\n }\n \n fn highlight_lines(cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: &codemap::FileLines) {\n+                   lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n@@ -297,12 +308,13 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        write!(err, \"{}:{} {}\\n\", fm.name, *line + 1, fm.get_line(*line as int));\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n+                      fm.get_line(*line as int)));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        write!(err, \"{0:1$}...\\n\", \"\", s.len());\n+        if_ok!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n@@ -334,16 +346,18 @@ fn highlight_lines(cm: &codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        write!(err, \"{}\", s);\n+        if_ok!(write!(err, \"{}\", s));\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) { s.push_char('~'); }\n         }\n-        print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n+        if_ok!(print_maybe_styled(s + \"\\n\",\n+                                  term::attr::ForegroundColor(lvl.color())));\n     }\n+    Ok(())\n }\n \n // Here are the differences between this and the normal `highlight_lines`:\n@@ -355,23 +369,23 @@ fn highlight_lines(cm: &codemap::CodeMap,\n fn custom_highlight_lines(cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: &codemap::FileLines) {\n+                          lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n-        write!(err, \"{}:{} {}\\n\", fm.name,\n-               lines[0] + 1, fm.get_line(lines[0] as int));\n-        write!(err, \"...\\n\");\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                      lines[0] + 1, fm.get_line(lines[0] as int)));\n+        if_ok!(write!(err, \"...\\n\"));\n         let last_line = lines[lines.len()-1];\n-        write!(err, \"{}:{} {}\\n\", fm.name,\n-               last_line + 1, fm.get_line(last_line as int));\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                      last_line + 1, fm.get_line(last_line as int)));\n     } else {\n         for line in lines.iter() {\n-            write!(err, \"{}:{} {}\\n\", fm.name,\n-                   *line + 1, fm.get_line(*line as int));\n+            if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                          *line + 1, fm.get_line(*line as int)));\n         }\n     }\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n@@ -381,22 +395,24 @@ fn custom_highlight_lines(cm: &codemap::CodeMap,\n     let mut s = ~\"\";\n     for _ in range(0, skip) { s.push_char(' '); }\n     s.push_char('^');\n-    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n+    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n }\n \n-fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n+fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        print_diagnostic(ss, Note,\n-                         format!(\"in expansion of {}{}{}\", pre, ei.callee.name, post));\n+        if_ok!(print_diagnostic(ss, Note,\n+                                format!(\"in expansion of {}{}{}\", pre,\n+                                        ei.callee.name, post)));\n         let ss = cm.span_to_str(ei.call_site);\n-        print_diagnostic(ss, Note, \"expansion site\");\n-        print_macro_backtrace(cm, ei.call_site);\n+        if_ok!(print_diagnostic(ss, Note, \"expansion site\"));\n+        if_ok!(print_macro_backtrace(cm, ei.call_site));\n     }\n+    Ok(())\n }\n \n pub fn expect<T:Clone>(diag: @SpanHandler, opt: Option<T>, msg: || -> ~str)"}, {"sha": "ae93c235ad23c9fbe0dd65db92a5052cd0df21ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -957,14 +957,13 @@ mod test {\n     use ast_util;\n     use codemap;\n     use codemap::Spanned;\n-    use fold;\n     use fold::*;\n     use ext::base::{CrateLoader, MacroCrate};\n     use parse;\n     use parse::token::{fresh_mark, gensym, intern};\n     use parse::token;\n     use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n-    use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n+    use util::parser_testing::{string_to_pat, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n@@ -1253,14 +1252,14 @@ mod test {\n                     let varref_name = mtwt_resolve(varref.segments[0].identifier);\n                     let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n                                                     invalid_name);\n-                    if (!(varref_name==binding_name)){\n+                    if !(varref_name==binding_name) {\n                         println!(\"uh oh, should match but doesn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert_eq!(varref_name,binding_name);\n-                    if (bound_ident_check) {\n+                    if bound_ident_check {\n                         // we're checking bound-identifier=?, and the marks\n                         // should be the same, too:\n                         assert_eq!(varref_marks,binding_marks.clone());\n@@ -1269,7 +1268,7 @@ mod test {\n                     let fail = (varref.segments.len() == 1)\n                         && (mtwt_resolve(varref.segments[0].identifier) == binding_name);\n                     // temp debugging:\n-                    if (fail) {\n+                    if fail {\n                         println!(\"failure on test {}\",test_idx);\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");"}, {"sha": "52010b39a544697bdfc7325a8f8e5058e3b9e493", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -20,7 +20,6 @@ use parse::token::get_ident_interner;\n use parse::token;\n use print::pprust;\n \n-use std::io;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -109,9 +108,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => return MacResult::dummy_expr()\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    let bytes = match io::result(|| File::open(&file).read_to_end()) {\n+    let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             return MacResult::dummy_expr();\n         }\n         Ok(bytes) => bytes,\n@@ -141,9 +140,9 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => return MacResult::dummy_expr()\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    match io::result(|| File::open(&file).read_to_end()) {\n+    match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             return MacResult::dummy_expr();\n         }\n         Ok(bytes) => {"}, {"sha": "297ec6acf51052d9008ba418ab63e82aacca4bb9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -861,15 +861,17 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt>\n \n #[cfg(test)]\n mod test {\n+    use std::io;\n     use ast;\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use parse::token;\n     use print::pprust;\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::State, crate: &ast::Crate) {\n-        pprust::print_mod(s, &crate.module, crate.attrs);\n+    fn fake_print_crate(s: &mut pprust::State,\n+                        crate: &ast::Crate) -> io::IoResult<()> {\n+        pprust::print_mod(s, &crate.module, crate.attrs)\n     }\n \n     // change every identifier to \"zz\""}, {"sha": "e2aa9e3b3ee671a7a54eb025d3c367775e85d81b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -33,6 +33,11 @@ This API is completely unstable and subject to change.\n extern mod extra;\n extern mod term;\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod util {\n     pub mod interner;\n     #[cfg(test)]"}, {"sha": "f65bc3ad7a3511bc4e296ba76e805bac6ced47c0", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -350,7 +350,8 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[Comment], ~[Literal]) {\n-    let src = str::from_utf8_owned(srdr.read_to_end()).unwrap();\n+    let src = srdr.read_to_end().unwrap();\n+    let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "328f0e7f22187ca7d678e85df3d0ff1f945a8ced", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -19,7 +19,6 @@ use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n-use std::io;\n use std::io::File;\n use std::str;\n \n@@ -232,10 +231,10 @@ pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let bytes = match io::result(|| File::open(path).read_to_end()) {\n+    let bytes = match File::open(path).read_to_end() {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+            err(format!(\"couldn't read {}: {}\", path.display(), e));\n             unreachable!()\n         }\n     };"}, {"sha": "f1dd844fc7c68fe47a07b4ae96ba3400fd01bb31", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -588,8 +588,8 @@ impl BytesContainer for InternedString {\n }\n \n impl fmt::Show for InternedString {\n-    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n-        write!(f.buf, \"{}\", obj.string.as_slice());\n+    fn fmt(obj: &InternedString, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, \"{}\", obj.string.as_slice())\n     }\n }\n "}, {"sha": "f69522617232131fcdb5495ed731ba654d94f476", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -292,16 +292,17 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, t: Token) {\n+    pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match t {\n           Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 let left = self.token[self.left].clone();\n-                self.advance_left(left, self.size[self.left]);\n+                if_ok!(self.advance_left(left, self.size[self.left]));\n             }\n             self.indent(0);\n+            Ok(())\n           }\n           Begin(b) => {\n             if self.scan_stack_empty {\n@@ -315,17 +316,19 @@ impl Printer {\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n+            Ok(())\n           }\n           End => {\n             if self.scan_stack_empty {\n                 debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n-                self.print(t, 0);\n+                self.print(t, 0)\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n                 self.scan_push(self.right);\n+                Ok(())\n             }\n           }\n           Break(b) => {\n@@ -342,25 +345,26 @@ impl Printer {\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n+            Ok(())\n           }\n           String(ref s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n                        *s, self.left, self.right);\n-                self.print(t.clone(), len);\n+                self.print(t.clone(), len)\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n                        *s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t.clone();\n                 self.size[self.right] = len;\n                 self.right_total += len;\n-                self.check_stream();\n+                self.check_stream()\n             }\n           }\n         }\n     }\n-    pub fn check_stream(&mut self) {\n+    pub fn check_stream(&mut self) -> io::IoResult<()> {\n         debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -373,9 +377,12 @@ impl Printer {\n                 }\n             }\n             let left = self.token[self.left].clone();\n-            self.advance_left(left, self.size[self.left]);\n-            if self.left != self.right { self.check_stream(); }\n+            if_ok!(self.advance_left(left, self.size[self.left]));\n+            if self.left != self.right {\n+                if_ok!(self.check_stream());\n+            }\n         }\n+        Ok(())\n     }\n     pub fn scan_push(&mut self, x: uint) {\n         debug!(\"scan_push {}\", x);\n@@ -413,11 +420,11 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self, x: Token, L: int) {\n+    pub fn advance_left(&mut self, x: Token, L: int) -> io::IoResult<()> {\n         debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n-            self.print(x.clone(), L);\n+            let ret = self.print(x.clone(), L);\n             match x {\n               Break(b) => self.left_total += b.blank_space,\n               String(_, len) => {\n@@ -429,8 +436,11 @@ impl Printer {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n                 let left = self.token[self.left].clone();\n-                self.advance_left(left, self.size[self.left]);\n+                if_ok!(self.advance_left(left, self.size[self.left]));\n             }\n+            ret\n+        } else {\n+            Ok(())\n         }\n     }\n     pub fn check_stack(&mut self, k: int) {\n@@ -456,11 +466,12 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_newline(&mut self, amount: int) {\n+    pub fn print_newline(&mut self, amount: int) -> io::IoResult<()> {\n         debug!(\"NEWLINE {}\", amount);\n-        write!(self.out, \"\\n\");\n+        let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n+        return ret;\n     }\n     pub fn indent(&mut self, amount: int) {\n         debug!(\"INDENT {}\", amount);\n@@ -478,14 +489,14 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) {\n+    pub fn print_str(&mut self, s: &str) -> io::IoResult<()> {\n         while self.pending_indentation > 0 {\n-            write!(self.out, \" \");\n+            if_ok!(write!(self.out, \" \"));\n             self.pending_indentation -= 1;\n         }\n-        write!(self.out, \"{}\", s);\n+        write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, L: int) {\n+    pub fn print(&mut self, x: Token, L: int) -> io::IoResult<()> {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), L,\n                self.space);\n         debug!(\"{}\", buf_str(self.token.clone(),\n@@ -509,12 +520,14 @@ impl Printer {\n                     pbreak: Fits\n                 });\n             }\n+            Ok(())\n           }\n           End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop().unwrap();\n+            Ok(())\n           }\n           Break(b) => {\n             let top = self.get_top();\n@@ -523,24 +536,28 @@ impl Printer {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n+                Ok(())\n               }\n               Broken(Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n-                self.print_newline(top.offset + b.offset);\n+                let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n+                ret\n               }\n               Broken(Inconsistent) => {\n                 if L > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n-                    self.print_newline(top.offset + b.offset);\n+                    let ret = self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n+                    ret\n                 } else {\n                     debug!(\"print Break({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n+                    Ok(())\n                 }\n               }\n             }\n@@ -550,7 +567,7 @@ impl Printer {\n             assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n-            self.print_str(s);\n+            self.print_str(s)\n           }\n           Eof => {\n             // Eof should never get here.\n@@ -563,47 +580,59 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) {\n+pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n     p.pretty_print(Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n-    }));\n+    }))\n }\n \n-pub fn ibox(p: &mut Printer, indent: uint) { rbox(p, indent, Inconsistent); }\n+pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+    rbox(p, indent, Inconsistent)\n+}\n \n-pub fn cbox(p: &mut Printer, indent: uint) { rbox(p, indent, Consistent); }\n+pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+    rbox(p, indent, Consistent)\n+}\n \n-pub fn break_offset(p: &mut Printer, n: uint, off: int) {\n+pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n     p.pretty_print(Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n-    }));\n+    }))\n }\n \n-pub fn end(p: &mut Printer) { p.pretty_print(End); }\n+pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n \n-pub fn eof(p: &mut Printer) { p.pretty_print(Eof); }\n+pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n \n-pub fn word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int));\n+pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int))\n }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), SIZE_INFINITY));\n+pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), SIZE_INFINITY))\n }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) {\n-    p.pretty_print(String(/* bad */ wrd.to_str(), 0));\n+pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+    p.pretty_print(String(/* bad */ wrd.to_str(), 0))\n }\n \n-pub fn spaces(p: &mut Printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n+    break_offset(p, n, 0)\n+}\n \n-pub fn zerobreak(p: &mut Printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, 0u)\n+}\n \n-pub fn space(p: &mut Printer) { spaces(p, 1u); }\n+pub fn space(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, 1u)\n+}\n \n-pub fn hardbreak(p: &mut Printer) { spaces(p, SIZE_INFINITY as uint); }\n+pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, SIZE_INFINITY as uint)\n+}\n \n pub fn hardbreak_tok_offset(off: int) -> Token {\n     Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})"}, {"sha": "e291583d121d7ff00daae27dd204441055cb6c9f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1149, "deletions": 990, "changes": 2139, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554"}, {"sha": "aa22f47221bfa629044aad5135bcb1e28775b20f", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -101,30 +101,30 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n     let mut idx_a = 0;\n     let mut idx_b = 0;\n     loop {\n-        if (idx_a == a.len() && idx_b == b.len()) {\n+        if idx_a == a.len() && idx_b == b.len() {\n             return true;\n         }\n-        else if (idx_a == a.len()) {return false;}\n-        else if (idx_b == b.len()) {\n+        else if idx_a == a.len() {return false;}\n+        else if idx_b == b.len() {\n             // maybe the stuff left in a is all ws?\n-            if (is_whitespace(a.char_at(idx_a))) {\n-                return (scan_for_non_ws_or_end(a,idx_a) == a.len());\n+            if is_whitespace(a.char_at(idx_a)) {\n+                return scan_for_non_ws_or_end(a,idx_a) == a.len();\n             } else {\n                 return false;\n             }\n         }\n         // ws in both given and pattern:\n-        else if (is_whitespace(a.char_at(idx_a))\n-           && is_whitespace(b.char_at(idx_b))) {\n+        else if is_whitespace(a.char_at(idx_a))\n+           && is_whitespace(b.char_at(idx_b)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n             idx_b = scan_for_non_ws_or_end(b,idx_b);\n         }\n         // ws in given only:\n-        else if (is_whitespace(a.char_at(idx_a))) {\n+        else if is_whitespace(a.char_at(idx_a)) {\n             idx_a = scan_for_non_ws_or_end(a,idx_a);\n         }\n         // *don't* silently eat ws in expected only.\n-        else if (a.char_at(idx_a) == b.char_at(idx_b)) {\n+        else if a.char_at(idx_a) == b.char_at(idx_b) {\n             idx_a += 1;\n             idx_b += 1;\n         }"}, {"sha": "c4481a1a07f0153e14160ca94189019fb86a8cc0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -19,15 +19,21 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n+#[feature(macro_rules)];\n #[deny(non_camel_case_types)];\n #[allow(missing_doc)];\n \n use std::os;\n+use std::io;\n use terminfo::TermInfo;\n use terminfo::searcher::open;\n use terminfo::parser::compiled::{parse, msys_terminfo};\n use terminfo::parm::{expand, Number, Variables};\n \n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod terminfo;\n \n // FIXME (#2807): Windows support.\n@@ -141,45 +147,48 @@ impl<T: Writer> Terminal<T> {\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n-    /// Returns true if the color was set, false otherwise.\n-    pub fn fg(&mut self, color: color::Color) -> bool {\n+    /// Returns Ok(true) if the color was set, Ok(false) otherwise, and Err(e)\n+    /// if there was an I/O error\n+    pub fn fg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.unwrap());\n-                return true\n+                if_ok!(self.out.write(s.unwrap()));\n+                return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n             }\n         }\n-        false\n+        Ok(false)\n     }\n     /// Sets the background color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n-    /// Returns true if the color was set, false otherwise.\n-    pub fn bg(&mut self, color: color::Color) -> bool {\n+    /// Returns Ok(true) if the color was set, Ok(false) otherwise, and Err(e)\n+    /// if there was an I/O error\n+    pub fn bg(&mut self, color: color::Color) -> io::IoResult<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                self.out.write(s.unwrap());\n-                return true\n+                if_ok!(self.out.write(s.unwrap()));\n+                return Ok(true)\n             } else {\n                 warn!(\"{}\", s.unwrap_err());\n             }\n         }\n-        false\n+        Ok(false)\n     }\n \n     /// Sets the given terminal attribute, if supported.\n-    /// Returns true if the attribute was supported, false otherwise.\n-    pub fn attr(&mut self, attr: attr::Attr) -> bool {\n+    /// Returns Ok(true) if the attribute was supported, Ok(false) otherwise,\n+    /// and Err(e) if there was an I/O error.\n+    pub fn attr(&mut self, attr: attr::Attr) -> io::IoResult<bool> {\n         match attr {\n             attr::ForegroundColor(c) => self.fg(c),\n             attr::BackgroundColor(c) => self.bg(c),\n@@ -189,13 +198,13 @@ impl<T: Writer> Terminal<T> {\n                 if parm.is_some() {\n                     let s = expand(*parm.unwrap(), [], &mut Variables::new());\n                     if s.is_ok() {\n-                        self.out.write(s.unwrap());\n-                        return true\n+                        if_ok!(self.out.write(s.unwrap()));\n+                        return Ok(true)\n                     } else {\n                         warn!(\"{}\", s.unwrap_err());\n                     }\n                 }\n-                false\n+                Ok(false)\n             }\n         }\n     }\n@@ -214,7 +223,7 @@ impl<T: Writer> Terminal<T> {\n     }\n \n     /// Resets all terminal attributes and color to the default.\n-    pub fn reset(&mut self) {\n+    pub fn reset(&mut self) -> io::IoResult<()> {\n         let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n@@ -228,14 +237,15 @@ impl<T: Writer> Terminal<T> {\n             expand(*op, [], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            self.out.write(s.unwrap());\n+            return self.out.write(s.unwrap())\n         } else if self.num_colors > 0 {\n             warn!(\"{}\", s.unwrap_err());\n         } else {\n             // if we support attributes but not color, it would be nice to still warn!()\n             // but it's not worth testing all known attributes just for this.\n             debug!(\"{}\", s.unwrap_err());\n         }\n+        Ok(())\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n@@ -252,11 +262,11 @@ impl<T: Writer> Terminal<T> {\n }\n \n impl<T: Writer> Writer for Terminal<T> {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.out.write(buf);\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        self.out.write(buf)\n     }\n \n-    fn flush(&mut self) {\n-        self.out.flush();\n+    fn flush(&mut self) -> io::IoResult<()> {\n+        self.out.flush()\n     }\n }"}, {"sha": "31f12bd45e69243093c7862336940c436ebfaaca", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -162,6 +162,10 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader,\n              longnames: bool) -> Result<~TermInfo, ~str> {\n+    macro_rules! if_ok( ($e:expr) => (\n+        match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n+    ) )\n+\n     let bnames;\n     let snames;\n     let nnames;\n@@ -177,17 +181,17 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // Check magic number\n-    let magic = file.read_le_u16();\n+    let magic = if_ok!(file.read_le_u16());\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = file.read_le_i16() as int;\n-    let bools_bytes          = file.read_le_i16() as int;\n-    let numbers_count        = file.read_le_i16() as int;\n-    let string_offsets_count = file.read_le_i16() as int;\n-    let string_table_bytes   = file.read_le_i16() as int;\n+    let names_bytes          = if_ok!(file.read_le_i16()) as int;\n+    let bools_bytes          = if_ok!(file.read_le_i16()) as int;\n+    let numbers_count        = if_ok!(file.read_le_i16()) as int;\n+    let string_offsets_count = if_ok!(file.read_le_i16()) as int;\n+    let string_table_bytes   = if_ok!(file.read_le_i16()) as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -216,18 +220,21 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // don't read NUL\n-    let names_str = str::from_utf8_owned(file.read_bytes(names_bytes as uint - 1)).unwrap();\n+    let bytes = if_ok!(file.read_bytes(names_bytes as uint - 1));\n+    let names_str = match str::from_utf8_owned(bytes) {\n+        Some(s) => s, None => return Err(~\"input not utf-8\"),\n+    };\n \n     let term_names: ~[~str] = names_str.split('|').map(|s| s.to_owned()).collect();\n \n-    file.read_byte(); // consume NUL\n+    if_ok!(file.read_byte()); // consume NUL\n \n     debug!(\"term names: {:?}\", term_names);\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n-            let b = file.read_byte().unwrap();\n+            let b = if_ok!(file.read_byte());\n             if b < 0 {\n                 error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n@@ -242,13 +249,13 @@ pub fn parse(file: &mut io::Reader,\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n         debug!(\"adjusting for padding between bools and numbers\");\n-        file.read_byte(); // compensate for padding\n+        if_ok!(file.read_byte()); // compensate for padding\n     }\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = file.read_le_u16();\n+            let n = if_ok!(file.read_le_u16());\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -263,12 +270,12 @@ pub fn parse(file: &mut io::Reader,\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(file.read_le_u16());\n+            string_offsets.push(if_ok!(file.read_le_u16()));\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);\n \n-        let string_table = file.read_bytes(string_table_bytes as uint);\n+        let string_table = if_ok!(file.read_bytes(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n             error!(\"EOF reading string table after {} bytes, wanted {}\", string_table.len(),"}, {"sha": "5b536d9aafa9129e630e68a7c60adbc5f52d2afc", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -77,8 +77,8 @@ pub fn open(term: &str) -> Result<File, ~str> {\n     match get_dbpath_for_term(term) {\n         Some(x) => {\n             match File::open(x) {\n-                Some(file) => Ok(file),\n-                None => Err(~\"error opening file\"),\n+                Ok(file) => Ok(file),\n+                Err(e) => Err(format!(\"error opening file: {}\", e)),\n             }\n         }\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n@@ -106,7 +106,7 @@ fn test_get_dbpath_for_term() {\n #[test]\n #[ignore(reason = \"see test_get_dbpath_for_term\")]\n fn test_open() {\n-    open(\"screen\");\n+    open(\"screen\").unwrap();\n     let t = open(\"nonexistent terminal that hopefully does not exist\");\n     assert!(t.is_err());\n }"}, {"sha": "6f4a4c43b03956aba8b7d17bd9faa9cb1d6b876e", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::io;\n use std::io::BufferedWriter;\n \n struct DummyWriter;\n impl Writer for DummyWriter {\n-    fn write(&mut self, _: &[u8]) {}\n+    fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n }\n \n static ITER: int = 50;"}, {"sha": "771e545ece88cc0a50139e7eb6d04690b91d7844", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -36,11 +36,12 @@ fn make_complements() -> [u8, ..256] {\n \n fn main() {\n     let complements = make_complements();\n-    let mut data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let data = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         File::open(&Path::new(\"shootout-k-nucleotide.data\")).read_to_end()\n     } else {\n         stdin().read_to_end()\n     };\n+    let mut data = data.unwrap();\n \n     for seq in data.mut_split(|c| *c == '>' as u8) {\n         // skip header and last \\n"}, {"sha": "17cd8db9d39197671021097b75b8b1e00c03618c", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -43,5 +43,5 @@ fn main() {\n         debug!(\"debug\");\n         info!(\"info\");\n     });\n-    assert_eq!(r.read_to_str(), ~\"info\\n\");\n+    assert_eq!(r.read_to_str().unwrap(), ~\"info\\n\");\n }"}, {"sha": "f3ddc002333ddb765a4bd00016397c408eee01e9", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -27,8 +27,7 @@ fn test_destroy_once() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new())\n-        .expect(format!(\"failed to exec `{}`\", PROG));\n+    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new()).unwrap();\n     p.destroy(); // this shouldn't crash (and nor should the destructor)\n }\n \n@@ -39,12 +38,12 @@ fn test_destroy_twice() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new())\n-        .expect(format!(\"failed to exec `{}`\", PROG));\n+    let mut p = match run::Process::new(PROG, [], run::ProcessOptions::new()) {\n+        Ok(p) => p,\n+        Err(e) => fail!(\"wut: {}\", e),\n+    };\n     p.destroy(); // this shouldnt crash...\n-    io::io_error::cond.trap(|_| {}).inside(|| {\n-        p.destroy(); // ...and nor should this (and nor should the destructor)\n-    })\n+    p.destroy(); // ...and nor should this (and nor should the destructor)\n }\n \n fn test_destroy_actually_kills(force: bool) {\n@@ -61,14 +60,14 @@ fn test_destroy_actually_kills(force: bool) {\n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()])\n-            .expect(\"failed to exec `ps`\");\n+            .unwrap();\n         str::from_utf8_owned(output).unwrap().contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n         let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()])\n-            .expect(\"failed to exec `/system/bin/ps`\");\n+            .unwrap();\n         str::from_utf8_owned(output).unwrap().contains(~\"root\")\n     }\n \n@@ -93,7 +92,7 @@ fn test_destroy_actually_kills(force: bool) {\n \n     // this process will stay alive indefinitely trying to read from stdin\n     let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new())\n-        .expect(format!(\"failed to exec `{}`\", BLOCK_COMMAND));\n+        .unwrap();\n \n     assert!(process_exists(p.get_id()));\n "}, {"sha": "b66446b0cfe438aa75beed8fc3d5a25ab1002edd", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -12,6 +12,7 @@\n \n #[feature(macro_rules)];\n #[deny(warnings)];\n+#[allow(unused_must_use)];\n \n use std::fmt;\n use std::io::MemWriter;\n@@ -22,10 +23,14 @@ struct A;\n struct B;\n \n impl fmt::Signed for A {\n-    fn fmt(_: &A, f: &mut fmt::Formatter) { f.buf.write(\"aloha\".as_bytes()); }\n+    fn fmt(_: &A, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.buf.write(\"aloha\".as_bytes())\n+    }\n }\n impl fmt::Signed for B {\n-    fn fmt(_: &B, f: &mut fmt::Formatter) { f.buf.write(\"adios\".as_bytes()); }\n+    fn fmt(_: &B, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.buf.write(\"adios\".as_bytes())\n+    }\n }\n \n macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n@@ -286,9 +291,9 @@ fn test_format_args() {\n     let mut buf = MemWriter::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { fmt::write(w, args) }, \"{}\", 1);\n-        format_args!(|args| { fmt::write(w, args) }, \"test\");\n-        format_args!(|args| { fmt::write(w, args) }, \"{test}\", test=3);\n+        format_args!(|args| { fmt::write(w, args); }, \"{}\", 1);\n+        format_args!(|args| { fmt::write(w, args); }, \"test\");\n+        format_args!(|args| { fmt::write(w, args); }, \"{test}\", test=3);\n     }\n     let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n     t!(s, \"1test3\");"}, {"sha": "0884db633264e4401654312e3958714226aaf958", "filename": "src/test/run-pass/issue-8398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8398.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -11,7 +11,7 @@\n use std::io;\n \n fn foo(a: &mut io::Writer) {\n-    a.write([])\n+    a.write([]).unwrap();\n }\n \n pub fn main(){}"}, {"sha": "dccdc8ae3ba21652fca1950a6927eeca17f3cb71", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -17,10 +17,11 @@ use std::fmt;\n struct Foo(Cell<int>);\n \n impl fmt::Show for Foo {\n-    fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) {\n+    fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Foo(ref f) = *f;\n         assert!(f.get() == 0);\n         f.set(1);\n+        Ok(())\n     }\n }\n "}, {"sha": "0e8ca4d99428b7f46546ccab6c997639e1ee8696", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -19,8 +19,7 @@ pub fn main() {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {\n-        let status = run::process_status(args[0], [~\"signal\"])\n-            .expect(\"failed to exec `signal`\");\n+        let status = run::process_status(args[0], [~\"signal\"]).unwrap();\n         // Windows does not have signal, so we get exit status 0xC0000028 (STATUS_BAD_STACK).\n         match status {\n             process::ExitSignal(_) if cfg!(unix) => {},"}, {"sha": "7f04da0734d8fa59c555f39a5094b89cb48e6e29", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb40eba4b1ce12914612914b94bdccd251a9f554/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=cb40eba4b1ce12914612914b94bdccd251a9f554", "patch": "@@ -21,8 +21,8 @@ pub fn main() {\n \n     {\n         match File::create(&path) {\n-            None => unreachable!(),\n-            Some(f) => {\n+            Err(..) => unreachable!(),\n+            Ok(f) => {\n                 let mut f = f;\n                 for _ in range(0u, 1000) {\n                     f.write([0]);\n@@ -32,5 +32,5 @@ pub fn main() {\n     }\n \n     assert!(path.exists());\n-    assert_eq!(path.stat().size, 1000);\n+    assert_eq!(path.stat().unwrap().size, 1000);\n }"}]}