{"sha": "ca6461c1431dbe043a80fc98f69912b955692d16", "node_id": "C_kwDOAAsO6NoAKGNhNjQ2MWMxNDMxZGJlMDQzYTgwZmM5OGY2OTkxMmI5NTU2OTJkMTY", "commit": {"author": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-20T12:29:32Z"}, "committer": {"name": "Luna Razzaghipour", "email": "lunarazzaghipour@gmail.com", "date": "2023-05-20T12:29:32Z"}, "message": "Add proof-of-concept QoS implementation", "tree": {"sha": "a9df77f050bd723ca41d296437c6b0221f98f9d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9df77f050bd723ca41d296437c6b0221f98f9d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca6461c1431dbe043a80fc98f69912b955692d16", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAAGgAAAATZWNkc2Etc2hhMi1uaXN0cDI1NgAAAAhuaXN0cDI1NgAAAE\nEEtPEPU+w9oQ90uLBc4R0g0O7C/w+fcT4a+R4nvkvJXioSPGOafBHNQJufyTj3tLLeNtO4\n1H9ztJfn/DlLu2mXigAAAANnaXQAAAAAAAAABnNoYTUxMgAAAGQAAAATZWNkc2Etc2hhMi\n1uaXN0cDI1NgAAAEkAAAAgJMFtbM89xij0EWqddOFogXqRX1wDWRIBRS7TiyIUdnYAAAAh\nALeALMJFF90Jpfn5F6AL3HPw/BARjAEExcz8ucBoPNx6\n-----END SSH SIGNATURE-----", "payload": "tree a9df77f050bd723ca41d296437c6b0221f98f9d4\nparent bb78059be4d090571bd70de57831f84eee5be678\nauthor Luna Razzaghipour <lunarazzaghipour@gmail.com> 1684585772 +1000\ncommitter Luna Razzaghipour <lunarazzaghipour@gmail.com> 1684585772 +1000\n\nAdd proof-of-concept QoS implementation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6461c1431dbe043a80fc98f69912b955692d16", "html_url": "https://github.com/rust-lang/rust/commit/ca6461c1431dbe043a80fc98f69912b955692d16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca6461c1431dbe043a80fc98f69912b955692d16/comments", "author": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lunacookies", "id": 31783266, "node_id": "MDQ6VXNlcjMxNzgzMjY2", "avatar_url": "https://avatars.githubusercontent.com/u/31783266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lunacookies", "html_url": "https://github.com/lunacookies", "followers_url": "https://api.github.com/users/lunacookies/followers", "following_url": "https://api.github.com/users/lunacookies/following{/other_user}", "gists_url": "https://api.github.com/users/lunacookies/gists{/gist_id}", "starred_url": "https://api.github.com/users/lunacookies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lunacookies/subscriptions", "organizations_url": "https://api.github.com/users/lunacookies/orgs", "repos_url": "https://api.github.com/users/lunacookies/repos", "events_url": "https://api.github.com/users/lunacookies/events{/privacy}", "received_events_url": "https://api.github.com/users/lunacookies/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb78059be4d090571bd70de57831f84eee5be678", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb78059be4d090571bd70de57831f84eee5be678", "html_url": "https://github.com/rust-lang/rust/commit/bb78059be4d090571bd70de57831f84eee5be678"}], "stats": {"total": 277, "additions": 254, "deletions": 23}, "files": [{"sha": "e7ae42a2d9b8afee440763d2f6c195b89c06c646", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -408,7 +408,6 @@ dependencies = [\n  \"cargo_metadata\",\n  \"command-group\",\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"paths\",\n  \"rustc-hash\",\n  \"serde\",\n@@ -1278,6 +1277,7 @@ dependencies = [\n  \"paths\",\n  \"proc-macro-api\",\n  \"proc-macro-test\",\n+ \"stdx\",\n  \"tt\",\n ]\n \n@@ -1493,7 +1493,6 @@ dependencies = [\n  \"ide-db\",\n  \"ide-ssr\",\n  \"itertools\",\n- \"jod-thread\",\n  \"lsp-server\",\n  \"lsp-types\",\n  \"mbe\",\n@@ -1712,6 +1711,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"always-assert\",\n  \"backtrace\",\n+ \"jod-thread\",\n  \"libc\",\n  \"miow\",\n  \"winapi\",\n@@ -2123,9 +2123,9 @@ name = \"vfs-notify\"\n version = \"0.0.0\"\n dependencies = [\n  \"crossbeam-channel\",\n- \"jod-thread\",\n  \"notify\",\n  \"paths\",\n+ \"stdx\",\n  \"tracing\",\n  \"vfs\",\n  \"walkdir\","}, {"sha": "3f6671b1c43dd96f40c000fb244f247299c68bb6", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -18,7 +18,6 @@ cargo_metadata = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n serde_json.workspace = true\n serde.workspace = true\n-jod-thread = \"0.1.2\"\n command-group = \"2.0.1\"\n \n # local deps"}, {"sha": "a4aa346a1cb8afd0cf90349f38e69bf1b5cadd32", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -77,7 +77,7 @@ impl fmt::Display for FlycheckConfig {\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<StateChange>,\n-    _thread: jod_thread::JoinHandle,\n+    _thread: stdx::thread::JoinHandle,\n     id: usize,\n }\n \n@@ -90,7 +90,7 @@ impl FlycheckHandle {\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n         let (sender, receiver) = unbounded::<StateChange>();\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n@@ -395,7 +395,7 @@ struct CargoHandle {\n     /// The handle to the actual cargo process. As we cannot cancel directly from with\n     /// a read syscall dropping and therefore terminating the process is our best option.\n     child: JodGroupChild,\n-    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n+    thread: stdx::thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n@@ -409,7 +409,7 @@ impl CargoHandle {\n \n         let (sender, receiver) = unbounded();\n         let actor = CargoActor::new(sender, stdout, stderr);\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"CargoHandle\".to_owned())\n             .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");"}, {"sha": "f049a225f077ead3e27bfe70de277790035f8fb6", "filename": "crates/ide/src/prime_caches.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -80,7 +80,11 @@ pub(crate) fn parallel_prime_caches(\n         for _ in 0..num_worker_threads {\n             let worker = prime_caches_worker.clone();\n             let db = db.snapshot();\n-            std::thread::spawn(move || Cancelled::catch(|| worker(db)));\n+\n+            stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n+                .allow_leak(true)\n+                .spawn(move || Cancelled::catch(|| worker(db)))\n+                .expect(\"failed to spawn thread\");\n         }\n \n         (work_sender, progress_receiver)"}, {"sha": "d5eb157bfef97b8695da47271b05b4ccf45b45db", "filename": "crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2FCargo.toml?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -22,6 +22,7 @@ object = { version = \"0.30.2\", default-features = false, features = [\n libloading = \"0.7.3\"\n memmap2 = \"0.5.4\"\n \n+stdx.workspace = true\n tt.workspace = true\n mbe.workspace = true\n paths.workspace = true"}, {"sha": "3f795340b2f6b8e2feba9302d50d86fb999a89b5", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -86,7 +86,6 @@ jemallocator = { version = \"0.5.0\", package = \"tikv-jemallocator\", optional = tr\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n-jod-thread = \"0.1.2\"\n xshell = \"0.2.2\"\n \n test-utils.workspace = true"}, {"sha": "660a780eb03837f1d8f56584441de17eb43e4729", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -78,7 +78,7 @@ fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n                 println!(\"rust-analyzer {}\", rust_analyzer::version());\n                 return Ok(());\n             }\n-            with_extra_thread(\"LspServer\", run_server)?;\n+            with_extra_thread(\"LspServer\", stdx::thread::QoSClass::Utility, run_server)?;\n         }\n         flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,\n@@ -136,14 +136,17 @@ const STACK_SIZE: usize = 1024 * 1024 * 8;\n /// space.\n fn with_extra_thread(\n     thread_name: impl Into<String>,\n+    qos_class: stdx::thread::QoSClass,\n     f: impl FnOnce() -> Result<()> + Send + 'static,\n ) -> Result<()> {\n-    let handle =\n-        std::thread::Builder::new().name(thread_name.into()).stack_size(STACK_SIZE).spawn(f)?;\n-    match handle.join() {\n-        Ok(res) => res,\n-        Err(panic) => std::panic::resume_unwind(panic),\n-    }\n+    let handle = stdx::thread::Builder::new(qos_class)\n+        .name(thread_name.into())\n+        .stack_size(STACK_SIZE)\n+        .spawn(f)?;\n+\n+    handle.join()?;\n+\n+    Ok(())\n }\n \n fn run_server() -> Result<()> {"}, {"sha": "0c5a4f30553479976690236c77478672dbbb2e17", "filename": "crates/rust-analyzer/src/task_pool.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ftask_pool.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -1,5 +1,7 @@\n //! A thin wrapper around `ThreadPool` to make sure that we join all things\n //! properly.\n+use std::sync::{Arc, Barrier};\n+\n use crossbeam_channel::Sender;\n \n pub(crate) struct TaskPool<T> {\n@@ -16,6 +18,18 @@ impl<T> TaskPool<T> {\n             .thread_stack_size(STACK_SIZE)\n             .num_threads(threads)\n             .build();\n+\n+        // Set QoS of all threads in threadpool.\n+        let barrier = Arc::new(Barrier::new(threads + 1));\n+        for _ in 0..threads {\n+            let barrier = barrier.clone();\n+            inner.execute(move || {\n+                stdx::thread::set_current_thread_qos_class(stdx::thread::QoSClass::Utility);\n+                barrier.wait();\n+            });\n+        }\n+        barrier.wait();\n+\n         TaskPool { sender, inner }\n     }\n \n@@ -26,7 +40,16 @@ impl<T> TaskPool<T> {\n     {\n         self.inner.execute({\n             let sender = self.sender.clone();\n-            move || sender.send(task()).unwrap()\n+            move || {\n+                if stdx::thread::IS_QOS_AVAILABLE {\n+                    debug_assert_eq!(\n+                        stdx::thread::get_current_thread_qos_class(),\n+                        Some(stdx::thread::QoSClass::Utility)\n+                    );\n+                }\n+\n+                sender.send(task()).unwrap()\n+            }\n         })\n     }\n "}, {"sha": "33d7f6576c3cd96552af96bf557e4ceae11c3c15", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -155,7 +155,7 @@ pub(crate) fn project(fixture: &str) -> Server {\n pub(crate) struct Server {\n     req_id: Cell<i32>,\n     messages: RefCell<Vec<Message>>,\n-    _thread: jod_thread::JoinHandle<()>,\n+    _thread: stdx::thread::JoinHandle,\n     client: Connection,\n     /// XXX: remove the tempdir last\n     dir: TestDir,\n@@ -165,7 +165,7 @@ impl Server {\n     fn new(dir: TestDir, config: Config) -> Server {\n         let (connection, client) = Connection::memory();\n \n-        let _thread = jod_thread::Builder::new()\n+        let _thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"test server\".to_string())\n             .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");"}, {"sha": "986e3fcdcfc394f89f67ffb179bf1f7b8d388326", "filename": "crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2FCargo.toml?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -15,6 +15,7 @@ doctest = false\n libc = \"0.2.135\"\n backtrace = { version = \"0.3.65\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n+jod-thread = \"0.1.2\"\n # Think twice before adding anything here\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "24990d6a0e71431ba3a538fa14011390a5a8dba5", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -11,6 +11,7 @@ pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;\n pub mod rand;\n+pub mod thread;\n \n pub use always_assert::{always, never};\n "}, {"sha": "2bf9141cbf99b0a24a61123851ba89cfc9a82e2a", "filename": "crates/stdx/src/thread.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2Fsrc%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fstdx%2Fsrc%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fthread.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -0,0 +1,200 @@\n+//! A utility module for working with threads that automatically joins threads upon drop\n+//! and provides functionality for interfacing with operating system quality of service (QoS) APIs.\n+//!\n+//! As a system, rust-analyzer should have the property that\n+//! old manual scheduling APIs are replaced entirely by QoS.\n+//! To maintain this invariant, we panic when it is clear that\n+//! old scheduling APIs have been used.\n+//!\n+//! Moreover, we also want to ensure that every thread has a QoS set explicitly\n+//! to force a decision about its importance to the system.\n+//! Thus, [`QoSClass`] has no default value\n+//! and every entry point to creating a thread requires a [`QoSClass`] upfront.\n+\n+use std::fmt;\n+\n+pub fn spawn<F, T>(qos_class: QoSClass, f: F) -> JoinHandle<T>\n+where\n+    F: FnOnce() -> T,\n+    F: Send + 'static,\n+    T: Send + 'static,\n+{\n+    Builder::new(qos_class).spawn(f).expect(\"failed to spawn thread\")\n+}\n+\n+pub struct Builder {\n+    qos_class: QoSClass,\n+    inner: jod_thread::Builder,\n+    allow_leak: bool,\n+}\n+\n+impl Builder {\n+    pub fn new(qos_class: QoSClass) -> Builder {\n+        Builder { qos_class, inner: jod_thread::Builder::new(), allow_leak: false }\n+    }\n+\n+    pub fn name(self, name: String) -> Builder {\n+        Builder { inner: self.inner.name(name), ..self }\n+    }\n+\n+    pub fn stack_size(self, size: usize) -> Builder {\n+        Builder { inner: self.inner.stack_size(size), ..self }\n+    }\n+\n+    pub fn allow_leak(self, b: bool) -> Builder {\n+        Builder { allow_leak: b, ..self }\n+    }\n+\n+    pub fn spawn<F, T>(self, f: F) -> std::io::Result<JoinHandle<T>>\n+    where\n+        F: FnOnce() -> T,\n+        F: Send + 'static,\n+        T: Send + 'static,\n+    {\n+        let inner_handle = self.inner.spawn(move || {\n+            set_current_thread_qos_class(self.qos_class);\n+            f()\n+        })?;\n+\n+        Ok(JoinHandle { inner: Some(inner_handle), allow_leak: self.allow_leak })\n+    }\n+}\n+\n+pub struct JoinHandle<T = ()> {\n+    // `inner` is an `Option` so that we can\n+    // take ownership of the contained `JoinHandle`\n+    // in the `Drop` impl below.\n+    inner: Option<jod_thread::JoinHandle<T>>,\n+    allow_leak: bool,\n+}\n+\n+impl<T> JoinHandle<T> {\n+    pub fn join(mut self) -> T {\n+        self.inner.take().unwrap().join()\n+    }\n+}\n+\n+impl<T> Drop for JoinHandle<T> {\n+    fn drop(&mut self) {\n+        if !self.allow_leak {\n+            return;\n+        }\n+\n+        if let Some(join_handle) = self.inner.take() {\n+            join_handle.detach();\n+        }\n+    }\n+}\n+\n+impl<T> fmt::Debug for JoinHandle<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"JoinHandle { .. }\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum QoSClass {\n+    // Maintain order in priority from least to most.\n+    Background,\n+    Utility,\n+    UserInitiated,\n+    UserInteractive,\n+}\n+\n+#[cfg(target_vendor = \"apple\")]\n+pub const IS_QOS_AVAILABLE: bool = true;\n+\n+#[cfg(not(target_vendor = \"apple\"))]\n+pub const IS_QOS_AVAILABLE: bool = false;\n+\n+// All Apple platforms use XNU as their kernel\n+// and thus have the concept of QoS.\n+#[cfg(target_vendor = \"apple\")]\n+pub fn set_current_thread_qos_class(class: QoSClass) {\n+    let c = match class {\n+        QoSClass::UserInteractive => libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE,\n+        QoSClass::UserInitiated => libc::qos_class_t::QOS_CLASS_USER_INITIATED,\n+        QoSClass::Utility => libc::qos_class_t::QOS_CLASS_UTILITY,\n+        QoSClass::Background => libc::qos_class_t::QOS_CLASS_BACKGROUND,\n+    };\n+\n+    let code = unsafe { libc::pthread_set_qos_class_self_np(c, 0) };\n+\n+    if code == 0 {\n+        return;\n+    }\n+\n+    let errno = unsafe { *libc::__error() };\n+\n+    match errno {\n+        libc::EPERM => {\n+            // This thread has been excluded from the QoS system\n+            // due to a previous call to a function such as `pthread_setschedparam`\n+            // which is incompatible with QoS.\n+            //\n+            // Let\u2019s just panic here because rust-analyzer as a system\n+            // should have the property that QoS is used consistently\n+            // instead of old manual scheduling management APIs.\n+            panic!(\"tried to set QoS of thread which has opted out of QoS (os error {errno})\")\n+        }\n+\n+        libc::EINVAL => {\n+            // This is returned if we pass something other than a qos_class_t\n+            // to `pthread_set_qos_class_self_np`.\n+            //\n+            // This is impossible, so again panic.\n+            unreachable!(\"invalid qos_class_t value was passed to pthread_set_qos_class_self_np\")\n+        }\n+\n+        _ => {\n+            // `pthread_set_qos_class_self_np`\u2019s documentation\n+            // does not mention any other errors.\n+            unreachable!(\"`pthread_set_qos_class_self_np` returned unexpected error {errno}\")\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_vendor = \"apple\"))]\n+pub fn set_current_thread_qos_class(class: QoSClass) {\n+    // FIXME: Windows has QoS APIs, we should use them!\n+}\n+\n+#[cfg(target_vendor = \"apple\")]\n+pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n+    let current_thread = unsafe { libc::pthread_self() };\n+    let mut qos_class_raw = libc::qos_class_t::QOS_CLASS_UNSPECIFIED;\n+    let code = unsafe {\n+        libc::pthread_get_qos_class_np(current_thread, &mut qos_class_raw, std::ptr::null_mut())\n+    };\n+\n+    if code != 0 {\n+        // `pthread_get_qos_class_np`\u2019s documentation states that\n+        // an error value is placed into errno if the return code is not zero.\n+        // However, it never states what errors are possible.\n+        // Inspecting the source[0] shows that, as of this writing, it always returns zero.\n+        //\n+        // Whatever errors the function could report in future are likely to be\n+        // ones which we cannot handle anyway\n+        //\n+        // 0: https://github.com/apple-oss-distributions/libpthread/blob/67e155c94093be9a204b69637d198eceff2c7c46/src/qos.c#L171-L177\n+        let errno = unsafe { *libc::__error() };\n+        unreachable!(\"`pthread_get_qos_class_np` failed unexpectedly (os error {errno})\");\n+    }\n+\n+    match qos_class_raw {\n+        libc::qos_class_t::QOS_CLASS_USER_INTERACTIVE => Some(QoSClass::UserInteractive),\n+        libc::qos_class_t::QOS_CLASS_USER_INITIATED => Some(QoSClass::UserInitiated),\n+        libc::qos_class_t::QOS_CLASS_DEFAULT => None, // QoS has never been set\n+        libc::qos_class_t::QOS_CLASS_UTILITY => Some(QoSClass::Utility),\n+        libc::qos_class_t::QOS_CLASS_BACKGROUND => Some(QoSClass::Background),\n+        libc::qos_class_t::QOS_CLASS_UNSPECIFIED => {\n+            // We panic here because rust-analyzer should never use\n+            panic!(\"tried to get QoS of thread which has opted out of QoS\")\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_vendor = \"apple\"))]\n+pub fn get_current_thread_qos_class() -> Option<QoSClass> {\n+    None\n+}"}, {"sha": "5d61a227284ed173a57f436774f9ca46eb9d1689", "filename": "crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -13,10 +13,10 @@ doctest = false\n \n [dependencies]\n tracing = \"0.1.35\"\n-jod-thread = \"0.1.2\"\n walkdir = \"2.3.2\"\n crossbeam-channel = \"0.5.5\"\n notify = \"5.0\"\n \n+stdx.workspace = true\n vfs.workspace = true\n paths.workspace = true"}, {"sha": "26f7a9fc423593a0cfe493788200c8228d92fb6e", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6461c1431dbe043a80fc98f69912b955692d16/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=ca6461c1431dbe043a80fc98f69912b955692d16", "patch": "@@ -21,7 +21,7 @@ use walkdir::WalkDir;\n pub struct NotifyHandle {\n     // Relative order of fields below is significant.\n     sender: Sender<Message>,\n-    _thread: jod_thread::JoinHandle,\n+    _thread: stdx::thread::JoinHandle,\n }\n \n #[derive(Debug)]\n@@ -34,7 +34,7 @@ impl loader::Handle for NotifyHandle {\n     fn spawn(sender: loader::Sender) -> NotifyHandle {\n         let actor = NotifyActor::new(sender);\n         let (sender, receiver) = unbounded::<Message>();\n-        let thread = jod_thread::Builder::new()\n+        let thread = stdx::thread::Builder::new(stdx::thread::QoSClass::Utility)\n             .name(\"VfsLoader\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");"}]}