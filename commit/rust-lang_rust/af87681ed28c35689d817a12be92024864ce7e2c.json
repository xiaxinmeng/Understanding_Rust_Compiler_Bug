{"sha": "af87681ed28c35689d817a12be92024864ce7e2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmODc2ODFlZDI4YzM1Njg5ZDgxN2ExMmJlOTIwMjQ4NjRjZTdlMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-22T14:25:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-22T14:25:06Z"}, "message": "Auto merge of #34917 - michaelwoerister:fix-internalize-symbols, r=eddyb\n\nFix wrong condition in base::internalize_symbols().\n\nFix a typo that snuck into https://github.com/rust-lang/rust/pull/34899 (and completely broke `internalize_symbols()`).", "tree": {"sha": "87336b443f8735dbc6dc3fd02a82e510ce7daf84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87336b443f8735dbc6dc3fd02a82e510ce7daf84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af87681ed28c35689d817a12be92024864ce7e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af87681ed28c35689d817a12be92024864ce7e2c", "html_url": "https://github.com/rust-lang/rust/commit/af87681ed28c35689d817a12be92024864ce7e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af87681ed28c35689d817a12be92024864ce7e2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d15e2656e574533704cee927592f6dbe2ee59c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d15e2656e574533704cee927592f6dbe2ee59c5f", "html_url": "https://github.com/rust-lang/rust/commit/d15e2656e574533704cee927592f6dbe2ee59c5f"}, {"sha": "ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc12953dbe401b3e8cb663ce6529706c50cbf8d", "html_url": "https://github.com/rust-lang/rust/commit/ecc12953dbe401b3e8cb663ce6529706c50cbf8d"}], "stats": {"total": 94, "additions": 78, "deletions": 16}, "files": [{"sha": "ea8c248d0239fb2fd842c8f5af9e913f5fbf31d3", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/af87681ed28c35689d817a12be92024864ce7e2c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af87681ed28c35689d817a12be92024864ce7e2c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=af87681ed28c35689d817a12be92024864ce7e2c", "patch": "@@ -89,13 +89,14 @@ use value::Value;\n use Disr;\n use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{NodeMap, NodeSet, FnvHashSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n+use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n use std::str;\n@@ -2256,12 +2257,20 @@ fn write_metadata(cx: &SharedCrateContext,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n+fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n+                                 symbol_map: &SymbolMap<'tcx>,\n+                                 reachable: &FnvHashSet<&str>) {\n+    let scx = ccxs.shared();\n+    let tcx = scx.tcx();\n+\n+    // 'unsafe' because we are holding on to CStr's from the LLVM module within\n+    // this block.\n     unsafe {\n-        let mut declared = HashSet::new();\n+        let mut referenced_somewhere = FnvHashSet();\n \n-        // Collect all external declarations in all compilation units.\n-        for ccx in cx.iter() {\n+        // Collect all symbols that need to stay externally visible because they\n+        // are referenced via a declaration in some other codegen unit.\n+        for ccx in ccxs.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n@@ -2270,39 +2279,67 @@ fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n                 let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n \n                 if is_decl || is_available_externally {\n-                    let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    declared.insert(name);\n+                    let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                    referenced_somewhere.insert(symbol_name);\n                 }\n             }\n         }\n \n+        // Also collect all symbols for which we cannot adjust linkage, because\n+        // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n+        let linkage_fixed_explicitly: FnvHashSet<_> = scx\n+            .translation_items()\n+            .borrow()\n+            .iter()\n+            .cloned()\n+            .filter(|trans_item|{\n+                let def_id = match *trans_item {\n+                    TransItem::DropGlue(..) => {\n+                        return false\n+                    },\n+                    TransItem::Fn(ref instance) => {\n+                        instance.def\n+                    }\n+                    TransItem::Static(node_id) => {\n+                        tcx.map.local_def_id(node_id)\n+                    }\n+                };\n+\n+                trans_item.explicit_linkage(tcx).is_some() ||\n+                attr::contains_extern_indicator(tcx.sess.diagnostic(),\n+                                                &tcx.get_attrs(def_id))\n+            })\n+            .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n+            .collect();\n+\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in cx.iter() {\n+        for ccx in ccxs.iter() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n                 let is_externally_visible = (linkage == llvm::ExternalLinkage as c_uint) ||\n                                             (linkage == llvm::LinkOnceODRLinkage as c_uint) ||\n                                             (linkage == llvm::WeakODRLinkage as c_uint);\n-                let is_definition = llvm::LLVMIsDeclaration(val) != 0;\n+                let is_definition = llvm::LLVMIsDeclaration(val) == 0;\n \n                 // If this is a definition (as opposed to just a declaration)\n                 // and externally visible, check if we can internalize it\n                 if is_definition && is_externally_visible {\n                     let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                     let name_str = name_cstr.to_str().unwrap();\n+                    let name_cow = Cow::Borrowed(name_str);\n \n-                    let is_referenced_somewhere = declared.contains(&name_cstr);\n-                    let is_reachable = reachable.contains(name_str);\n+                    let is_referenced_somewhere = referenced_somewhere.contains(&name_cstr);\n+                    let is_reachable = reachable.contains(&name_str);\n+                    let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n \n-                    if !is_referenced_somewhere && !is_reachable {\n+                    if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n                         llvm::SetLinkage(val, llvm::InternalLinkage);\n                         llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n                         llvm::UnsetComdat(val);\n                     }\n-\n                 }\n             }\n         }\n@@ -2616,8 +2653,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }));\n     }\n \n-    internalize_symbols(&crate_context_list,\n-                        &reachable_symbols.iter().map(|x| &x[..]).collect());\n+    time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n+        internalize_symbols(&crate_context_list,\n+                            &symbol_map,\n+                            &reachable_symbols.iter()\n+                                              .map(|s| &s[..])\n+                                              .collect())\n+    });\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {"}, {"sha": "90aafd6a3bb3b119d7903dfd7aacb8c1d845d55c", "filename": "src/test/codegen/internalize-closures.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af87681ed28c35689d817a12be92024864ce7e2c/src%2Ftest%2Fcodegen%2Finternalize-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af87681ed28c35689d817a12be92024864ce7e2c/src%2Ftest%2Fcodegen%2Finternalize-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finternalize-closures.rs?ref=af87681ed28c35689d817a12be92024864ce7e2c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+pub fn main() {\n+\n+    // We want to make sure that closures get 'internal' linkage instead of\n+    // 'weak_odr' when they are not shared between codegen units\n+    // CHECK: define internal {{.*}}_ZN20internalize_closures4main{{.*}}$u7b$$u7b$closure$u7d$$u7d$\n+    let c = |x:i32| { x + 1 };\n+    let _ = c(1);\n+}"}]}