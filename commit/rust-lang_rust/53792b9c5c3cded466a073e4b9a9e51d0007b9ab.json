{"sha": "53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "node_id": "C_kwDOAAsO6NoAKDUzNzkyYjljNWMzY2RlZDQ2NmEwNzNlNGI5YTllNTFkMDAwN2I5YWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T09:36:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T09:36:29Z"}, "message": "Auto merge of #96862 - oli-obk:enum_cast_mir, r=RalfJung\n\nChange enum->int casts to not go through MIR casts.\n\nfollow-up to https://github.com/rust-lang/rust/pull/96814\n\nthis simplifies all backends and even gives LLVM more information about the return value of `Rvalue::Discriminant`, enabling optimizations in more cases.", "tree": {"sha": "b05bde5cea72745097189ea09cdcb03b55c6453c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b05bde5cea72745097189ea09cdcb03b55c6453c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "html_url": "https://github.com/rust-lang/rust/commit/53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4045ce641a9eede71cc12031a2cd71692b273890", "url": "https://api.github.com/repos/rust-lang/rust/commits/4045ce641a9eede71cc12031a2cd71692b273890", "html_url": "https://github.com/rust-lang/rust/commit/4045ce641a9eede71cc12031a2cd71692b273890"}, {"sha": "82c73af4a60c5c9b4ac92813a9f5e902ada67e6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/82c73af4a60c5c9b4ac92813a9f5e902ada67e6b", "html_url": "https://github.com/rust-lang/rust/commit/82c73af4a60c5c9b4ac92813a9f5e902ada67e6b"}], "stats": {"total": 381, "additions": 238, "deletions": 143}, "files": [{"sha": "f71d749df629cfd811854f0d44a5a40e9f2d220e", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -635,29 +635,6 @@ fn codegen_stmt<'tcx>(\n                             let (ptr, _extra) = operand.load_scalar_pair(fx);\n                             lval.write_cvalue(fx, CValue::by_val(ptr, dest_layout))\n                         }\n-                    } else if let ty::Adt(adt_def, _substs) = from_ty.kind() {\n-                        // enum -> discriminant value\n-                        assert!(adt_def.is_enum());\n-                        match to_ty.kind() {\n-                            ty::Uint(_) | ty::Int(_) => {}\n-                            _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n-                        }\n-                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n-\n-                        let discriminant = crate::discriminant::codegen_get_discriminant(\n-                            fx,\n-                            operand,\n-                            fx.layout_of(operand.layout().ty.discriminant_ty(fx.tcx)),\n-                        )\n-                        .load_scalar(fx);\n-\n-                        let res = crate::cast::clif_intcast(\n-                            fx,\n-                            discriminant,\n-                            to_clif_ty,\n-                            to_ty.is_signed(),\n-                        );\n-                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);"}, {"sha": "4a4cccb490d1cf7df48145e6b5597ef843bc8c77", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -28,7 +28,7 @@ use std::ffi::CStr;\n use std::iter;\n use std::ops::Deref;\n use std::ptr;\n-use tracing::debug;\n+use tracing::{debug, instrument};\n \n // All Builders must have an llfn associated with them\n #[must_use]\n@@ -464,15 +464,15 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"trace\", skip(self))]\n     fn load_operand(&mut self, place: PlaceRef<'tcx, &'ll Value>) -> OperandRef<'tcx, &'ll Value> {\n-        debug!(\"PlaceRef::load: {:?}\", place);\n-\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n             return OperandRef::new_zst(self, place.layout);\n         }\n \n+        #[instrument(level = \"trace\", skip(bx))]\n         fn scalar_load_metadata<'a, 'll, 'tcx>(\n             bx: &mut Builder<'a, 'll, 'tcx>,\n             load: &'ll Value,"}, {"sha": "5ebc2d6139fc863b219646859d44fbb38868554a", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -1619,7 +1619,7 @@ extern \"C\" {\n         B: &Builder<'a>,\n         Val: &'a Value,\n         DestTy: &'a Type,\n-        IsSized: bool,\n+        IsSigned: bool,\n     ) -> &'a Value;\n \n     // Comparisons"}, {"sha": "58cee0c8bb0dbf166d9d7fbb827e44d319607e1a", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -204,6 +204,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n+    #[instrument(level = \"trace\", skip(bx))]\n     pub fn codegen_get_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,\n@@ -420,12 +421,12 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    #[instrument(level = \"trace\", skip(self, bx))]\n     pub fn codegen_place(\n         &mut self,\n         bx: &mut Bx,\n         place_ref: mir::PlaceRef<'tcx>,\n     ) -> PlaceRef<'tcx, Bx::Value> {\n-        debug!(\"codegen_place(place_ref={:?})\", place_ref);\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n "}, {"sha": "7ff12823bf739f710c73616a18fbacbbc1c39678", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 72, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -12,17 +12,15 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::{Abi, Int, Variants};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    #[instrument(level = \"trace\", skip(self, bx))]\n     pub fn codegen_rvalue(\n         &mut self,\n         mut bx: Bx,\n         dest: PlaceRef<'tcx, Bx::Value>,\n         rvalue: &mir::Rvalue<'tcx>,\n     ) -> Bx {\n-        debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\", dest.llval, rvalue);\n-\n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n                 let cg_operand = self.codegen_operand(&mut bx, operand);\n@@ -285,74 +283,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             CastTy::from_ty(operand.layout.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n                         let ll_t_in = bx.cx().immediate_backend_type(operand.layout);\n-                        match operand.layout.variants {\n-                            Variants::Single { index } => {\n-                                if let Some(discr) =\n-                                    operand.layout.ty.discriminant_for_variant(bx.tcx(), index)\n-                                {\n-                                    let discr_layout = bx.cx().layout_of(discr.ty);\n-                                    let discr_t = bx.cx().immediate_backend_type(discr_layout);\n-                                    let discr_val = bx.cx().const_uint_big(discr_t, discr.val);\n-                                    let discr_val =\n-                                        bx.intcast(discr_val, ll_t_out, discr.ty.is_signed());\n-\n-                                    return (\n-                                        bx,\n-                                        OperandRef {\n-                                            val: OperandValue::Immediate(discr_val),\n-                                            layout: cast,\n-                                        },\n-                                    );\n-                                }\n-                            }\n-                            Variants::Multiple { .. } => {}\n-                        }\n                         let llval = operand.immediate();\n \n-                        let mut signed = false;\n-                        if let Abi::Scalar(scalar) = operand.layout.abi {\n-                            if let Int(_, s) = scalar.primitive() {\n-                                // We use `i1` for bytes that are always `0` or `1`,\n-                                // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n-                                // let LLVM interpret the `i1` as signed, because\n-                                // then `i1 1` (i.e., E::B) is effectively `i8 -1`.\n-                                signed = !scalar.is_bool() && s;\n-\n-                                if !scalar.is_always_valid(bx.cx())\n-                                    && scalar.valid_range(bx.cx()).end\n-                                        >= scalar.valid_range(bx.cx()).start\n-                                {\n-                                    // We want `table[e as usize \u00b1 k]` to not\n-                                    // have bound checks, and this is the most\n-                                    // convenient place to put the `assume`s.\n-                                    if scalar.valid_range(bx.cx()).start > 0 {\n-                                        let enum_value_lower_bound = bx.cx().const_uint_big(\n-                                            ll_t_in,\n-                                            scalar.valid_range(bx.cx()).start,\n-                                        );\n-                                        let cmp_start = bx.icmp(\n-                                            IntPredicate::IntUGE,\n-                                            llval,\n-                                            enum_value_lower_bound,\n-                                        );\n-                                        bx.assume(cmp_start);\n-                                    }\n-\n-                                    let enum_value_upper_bound = bx\n-                                        .cx()\n-                                        .const_uint_big(ll_t_in, scalar.valid_range(bx.cx()).end);\n-                                    let cmp_end = bx.icmp(\n-                                        IntPredicate::IntULE,\n-                                        llval,\n-                                        enum_value_upper_bound,\n-                                    );\n-                                    bx.assume(cmp_end);\n-                                }\n-                            }\n-                        }\n-\n                         let newval = match (r_t_in, r_t_out) {\n-                            (CastTy::Int(_), CastTy::Int(_)) => bx.intcast(llval, ll_t_out, signed),\n+                            (CastTy::Int(i), CastTy::Int(_)) => {\n+                                bx.intcast(llval, ll_t_out, i.is_signed())\n+                            }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = bx.cx().float_width(ll_t_in);\n                                 let dstsz = bx.cx().float_width(ll_t_out);\n@@ -364,8 +300,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     llval\n                                 }\n                             }\n-                            (CastTy::Int(_), CastTy::Float) => {\n-                                if signed {\n+                            (CastTy::Int(i), CastTy::Float) => {\n+                                if i.is_signed() {\n                                     bx.sitofp(llval, ll_t_out)\n                                 } else {\n                                     bx.uitofp(llval, ll_t_out)\n@@ -374,8 +310,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Ptr(_)) => {\n                                 bx.pointercast(llval, ll_t_out)\n                             }\n-                            (CastTy::Int(_), CastTy::Ptr(_)) => {\n-                                let usize_llval = bx.intcast(llval, bx.cx().type_isize(), signed);\n+                            (CastTy::Int(i), CastTy::Ptr(_)) => {\n+                                let usize_llval =\n+                                    bx.intcast(llval, bx.cx().type_isize(), i.is_signed());\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n                             (CastTy::Float, CastTy::Int(IntTy::I)) => {"}, {"sha": "f452f29883f939a86d35bd16b92b81913eac60d1", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -6,9 +6,8 @@ use crate::traits::BuilderMethods;\n use crate::traits::*;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    #[instrument(level = \"debug\", skip(self, bx))]\n     pub fn codegen_statement(&mut self, mut bx: Bx, statement: &mir::Statement<'tcx>) -> Bx {\n-        debug!(\"codegen_statement(statement={:?})\", statement);\n-\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box (ref place, ref rvalue)) => {"}, {"sha": "fc81b22b4065cf9030896722dd1c0c85f0e64cc2", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, FloatTy, Ty, TypeAndMut};\n-use rustc_target::abi::{Integer, Variants};\n+use rustc_target::abi::Integer;\n use rustc_type_ir::sty::TyKind::*;\n \n use super::{\n@@ -128,12 +128,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n-            // are represented as integers.\n+            // The rest is integer/pointer-\"like\", including fn ptr casts\n             _ => assert!(\n                 src.layout.ty.is_bool()\n                     || src.layout.ty.is_char()\n-                    || src.layout.ty.is_enum()\n                     || src.layout.ty.is_integral()\n                     || src.layout.ty.is_any_ptr(),\n                 \"Unexpected cast from type {:?}\",\n@@ -143,25 +141,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // # First handle non-scalar source values.\n \n-        // Handle cast from a ZST enum (0 or 1 variants).\n-        match src.layout.variants {\n-            Variants::Single { index } => {\n-                if src.layout.abi.is_uninhabited() {\n-                    // This is dead code, because an uninhabited enum is UB to\n-                    // instantiate.\n-                    throw_ub!(Unreachable);\n-                }\n-                if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n-                    assert!(src.layout.is_zst());\n-                    let discr_layout = self.layout_of(discr.ty)?;\n-\n-                    let scalar = Scalar::from_uint(discr.val, discr_layout.layout.size());\n-                    return Ok(self.cast_from_int_like(scalar, discr_layout, cast_ty)?.into());\n-                }\n-            }\n-            Variants::Multiple { .. } => {}\n-        }\n-\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n         if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n             let dest_layout = self.layout_of(cast_ty)?;"}, {"sha": "315233e8b09a5f94c02f4875694020da343b1e61", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -7,9 +7,9 @@ use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, Local, Location, MirPass,\n-    MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, Local, Location,\n+    MirPass, MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope,\n+    Statement, StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n@@ -361,6 +361,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n+            Rvalue::Ref(..) => {}\n             Rvalue::Len(p) => {\n                 let pty = p.ty(&self.body.local_decls, self.tcx).ty;\n                 check_kinds!(\n@@ -503,7 +504,30 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 let a = operand.ty(&self.body.local_decls, self.tcx);\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n-            _ => {}\n+            Rvalue::Cast(kind, operand, target_type) => {\n+                match kind {\n+                    CastKind::Misc => {\n+                        let op_ty = operand.ty(self.body, self.tcx);\n+                        if op_ty.is_enum() {\n+                            self.fail(\n+                                location,\n+                                format!(\n+                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                ),\n+                            );\n+                        }\n+                    }\n+                    // Nothing to check here\n+                    CastKind::PointerFromExposedAddress\n+                    | CastKind::PointerExposeAddress\n+                    | CastKind::Pointer(_) => {}\n+                }\n+            }\n+            Rvalue::Repeat(_, _)\n+            | Rvalue::ThreadLocalRef(_)\n+            | Rvalue::AddressOf(_, _)\n+            | Rvalue::NullaryOp(_, _)\n+            | Rvalue::Discriminant(_) => {}\n         }\n         self.super_rvalue(rvalue, location);\n     }"}, {"sha": "c4b743dd46701e11601ccc8991b8b54dae07401d", "filename": "compiler/rustc_middle/src/ty/cast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -15,6 +15,12 @@ pub enum IntTy {\n     Char,\n }\n \n+impl IntTy {\n+    pub fn is_signed(self) -> bool {\n+        matches!(self, Self::I)\n+    }\n+}\n+\n // Valid types for the result of a non-coercion cast\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CastTy<'tcx> {"}, {"sha": "e3a383f86a76ad7f792fa69d0d9f237dc85a87cc", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -1,6 +1,7 @@\n //! See docs in `build/expr/mod.rs`.\n \n use rustc_index::vec::Idx;\n+use rustc_middle::ty::util::IntTypeExt;\n \n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -190,7 +191,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Cast { source } => {\n                 let source = &this.thir[source];\n-                let from_ty = CastTy::from_ty(source.ty);\n+\n+                // Casting an enum to an integer is equivalent to computing the discriminant and casting the\n+                // discriminant. Previously every backend had to repeat the logic for this operation. Now we\n+                // create all the steps directly in MIR with operations all backends need to support anyway.\n+                let (source, ty) = if let ty::Adt(adt_def, ..) = source.ty.kind() && adt_def.is_enum() {\n+                    let discr_ty = adt_def.repr().discr_type().to_ty(this.tcx);\n+                    let place = unpack!(block = this.as_place(block, source));\n+                    let discr = this.temp(discr_ty, source.span);\n+                    this.cfg.push_assign(\n+                        block,\n+                        source_info,\n+                        discr,\n+                        Rvalue::Discriminant(place),\n+                    );\n+\n+                    (Operand::Move(discr), discr_ty)\n+                } else {\n+                    let ty = source.ty;\n+                    let source = unpack!(\n+                        block = this.as_operand(block, scope, source, None, NeedsTemporary::No)\n+                    );\n+                    (source, ty)\n+                };\n+                let from_ty = CastTy::from_ty(ty);\n                 let cast_ty = CastTy::from_ty(expr.ty);\n                 let cast_kind = match (from_ty, cast_ty) {\n                     (Some(CastTy::Ptr(_) | CastTy::FnPtr), Some(CastTy::Int(_))) => {\n@@ -201,9 +225,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     (_, _) => CastKind::Misc,\n                 };\n-                let source = unpack!(\n-                    block = this.as_operand(block, scope, source, None, NeedsTemporary::No)\n-                );\n                 block.and(Rvalue::Cast(cast_kind, source, expr.ty))\n             }\n             ExprKind::Pointer { cast, source } => {"}, {"sha": "4bc3d216a40d625b833d0d246ded3ad1a86c25d0", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -32,13 +32,14 @@ impl<'tcx> Cx<'tcx> {\n         exprs.iter().map(|expr| self.mirror_expr_inner(expr)).collect()\n     }\n \n+    #[instrument(level = \"trace\", skip(self, hir_expr))]\n     pub(super) fn mirror_expr_inner(&mut self, hir_expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n         let temp_lifetime =\n             self.rvalue_scopes.temporary_scope(self.region_scope_tree, hir_expr.hir_id.local_id);\n         let expr_scope =\n             region::Scope { id: hir_expr.hir_id.local_id, data: region::ScopeData::Node };\n \n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", hir_expr.hir_id, hir_expr.span);\n+        trace!(?hir_expr.hir_id, ?hir_expr.span);\n \n         let mut expr = self.make_mirror_unadjusted(hir_expr);\n \n@@ -49,7 +50,7 @@ impl<'tcx> Cx<'tcx> {\n \n         // Now apply adjustments, if any.\n         for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n-            debug!(\"make_mirror: expr={:?} applying adjustment={:?}\", expr, adjustment);\n+            trace!(?expr, ?adjustment);\n             let span = expr.span;\n             expr =\n                 self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));"}, {"sha": "fe02aeb5f6252924ce56820ea011e3b39287eb2d", "filename": "src/test/codegen/enum-bounds-check-derived-idx.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-derived-idx.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -12,13 +12,15 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_inc\n #[no_mangle]\n pub fn lookup_inc(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize + 1]\n }\n \n // CHECK-LABEL: @lookup_dec\n #[no_mangle]\n pub fn lookup_dec(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize - 1]\n }"}, {"sha": "1aec41d54411b267f82847754d25419e64a77de9", "filename": "src/test/codegen/enum-bounds-check-issue-13926.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-13926.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -13,6 +13,7 @@ pub enum Exception {\n // CHECK-LABEL: @access\n #[no_mangle]\n pub fn access(array: &[usize; 12], exc: Exception) -> usize {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     array[(exc as u8 - 4) as usize]\n }"}, {"sha": "32fdc4a5f4fab96d020626640c495e6871abe95e", "filename": "src/test/codegen/enum-bounds-check-issue-82871.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check-issue-82871.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -C opt-level=0\n \n #![crate_type = \"lib\"]\n \n@@ -9,7 +9,10 @@ pub enum E {\n \n // CHECK-LABEL: @index\n #[no_mangle]\n-pub fn index(x: &[u32; 3], ind: E) -> u32{\n-    // CHECK-NOT: panic_bounds_check\n+pub fn index(x: &[u32; 3], ind: E) -> u32 {\n+    // Canary: we should be able to optimize out the bounds check, but we need\n+    // to track the range of the discriminant result in order to be able to do that.\n+    // oli-obk tried to add that, but that caused miscompilations all over the place.\n+    // CHECK: panic_bounds_check\n     x[ind as usize]\n }"}, {"sha": "f85c6817deda3417ec7295137dca12e71d2fed43", "filename": "src/test/codegen/enum-bounds-check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fenum-bounds-check.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -21,6 +21,7 @@ pub enum Bar {\n // CHECK-LABEL: @lookup_unmodified\n #[no_mangle]\n pub fn lookup_unmodified(buf: &[u8; 5], f: Bar) -> u8 {\n-    // CHECK-NOT: panic_bounds_check\n+    // FIXME: panic check can be removed by adding the assumes back after https://github.com/rust-lang/rust/pull/98332\n+    // CHECK: panic_bounds_check\n     buf[f as usize]\n }"}, {"sha": "1b4a469135cb6d5fa7945006b97a13226a77f305", "filename": "src/test/mir-opt/enum_cast.bar.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.bar.mir_map.0.mir?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `bar` 0 mir_map\n+\n+fn bar(_1: Bar) -> usize {\n+    debug bar => _1;                     // in scope 0 at $DIR/enum_cast.rs:22:8: 22:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:22:21: 22:26\n+    let mut _2: isize;                   // in scope 0 at $DIR/enum_cast.rs:23:5: 23:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:23:5: 23:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:23:5: 23:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:24:2: 24:2\n+    }\n+}"}, {"sha": "7724e89a22854965ab1ad2b4ca30d1e09ad5ecf6", "filename": "src/test/mir-opt/enum_cast.boo.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.boo.mir_map.0.mir?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `boo` 0 mir_map\n+\n+fn boo(_1: Boo) -> usize {\n+    debug boo => _1;                     // in scope 0 at $DIR/enum_cast.rs:26:8: 26:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:26:21: 26:26\n+    let mut _2: u8;                      // in scope 0 at $DIR/enum_cast.rs:27:5: 27:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:27:5: 27:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:27:5: 27:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:28:2: 28:2\n+    }\n+}"}, {"sha": "a9dcfadae75c716c37ebc749d1f4d83d66958ffd", "filename": "src/test/mir-opt/enum_cast.droppy.mir_map.0.mir", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.droppy.mir_map.0.mir?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -0,0 +1,54 @@\n+// MIR for `droppy` 0 mir_map\n+\n+fn droppy() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/enum_cast.rs:39:13: 39:13\n+    let _1: ();                          // in scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+    let _2: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+    let mut _4: isize;                   // in scope 0 at $DIR/enum_cast.rs:44:17: 44:18\n+    let _5: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+    scope 1 {\n+        debug x => _2;                   // in scope 1 at $DIR/enum_cast.rs:41:13: 41:14\n+        scope 2 {\n+            debug y => _3;               // in scope 2 at $DIR/enum_cast.rs:44:13: 44:14\n+        }\n+        scope 3 {\n+            let _3: usize;               // in scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        }\n+    }\n+    scope 4 {\n+        debug z => _5;                   // in scope 4 at $DIR/enum_cast.rs:46:9: 46:10\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+        _2 = Droppy::C;                  // scope 0 at $DIR/enum_cast.rs:41:17: 41:26\n+        FakeRead(ForLet(None), _2);      // scope 0 at $DIR/enum_cast.rs:41:13: 41:14\n+        StorageLive(_3);                 // scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        _4 = discriminant(_2);           // scope 3 at $DIR/enum_cast.rs:44:17: 44:27\n+        _3 = move _4 as usize (Misc);    // scope 3 at $DIR/enum_cast.rs:44:17: 44:27\n+        FakeRead(ForLet(None), _3);      // scope 3 at $DIR/enum_cast.rs:44:13: 44:14\n+        _1 = const ();                   // scope 0 at $DIR/enum_cast.rs:40:5: 45:6\n+        StorageDead(_3);                 // scope 1 at $DIR/enum_cast.rs:45:5: 45:6\n+        drop(_2) -> [return: bb1, unwind: bb3]; // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+    }\n+\n+    bb1: {\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+        StorageDead(_1);                 // scope 0 at $DIR/enum_cast.rs:45:5: 45:6\n+        StorageLive(_5);                 // scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+        _5 = Droppy::B;                  // scope 0 at $DIR/enum_cast.rs:46:13: 46:22\n+        FakeRead(ForLet(None), _5);      // scope 0 at $DIR/enum_cast.rs:46:9: 46:10\n+        _0 = const ();                   // scope 0 at $DIR/enum_cast.rs:39:13: 47:2\n+        drop(_5) -> [return: bb2, unwind: bb3]; // scope 0 at $DIR/enum_cast.rs:47:1: 47:2\n+    }\n+\n+    bb2: {\n+        StorageDead(_5);                 // scope 0 at $DIR/enum_cast.rs:47:1: 47:2\n+        return;                          // scope 0 at $DIR/enum_cast.rs:47:2: 47:2\n+    }\n+\n+    bb3 (cleanup): {\n+        resume;                          // scope 0 at $DIR/enum_cast.rs:39:1: 47:2\n+    }\n+}"}, {"sha": "d89dc9519239bc90fcee553c1715eb58e7cf3274", "filename": "src/test/mir-opt/enum_cast.foo.mir_map.0.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.foo.mir_map.0.mir?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `foo` 0 mir_map\n+\n+fn foo(_1: Foo) -> usize {\n+    debug foo => _1;                     // in scope 0 at $DIR/enum_cast.rs:18:8: 18:11\n+    let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:18:21: 18:26\n+    let mut _2: isize;                   // in scope 0 at $DIR/enum_cast.rs:19:5: 19:8\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $DIR/enum_cast.rs:19:5: 19:17\n+        _0 = move _2 as usize (Misc);    // scope 0 at $DIR/enum_cast.rs:19:5: 19:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:20:2: 20:2\n+    }\n+}"}, {"sha": "090142aaf3559ae4c0b111992c0b98f44dc0ffb2", "filename": "src/test/mir-opt/enum_cast.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Fmir-opt%2Fenum_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fenum_cast.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -0,0 +1,50 @@\n+// EMIT_MIR enum_cast.foo.mir_map.0.mir\n+// EMIT_MIR enum_cast.bar.mir_map.0.mir\n+// EMIT_MIR enum_cast.boo.mir_map.0.mir\n+\n+enum Foo {\n+    A\n+}\n+\n+enum Bar {\n+    A, B\n+}\n+\n+#[repr(u8)]\n+enum Boo {\n+    A, B\n+}\n+\n+fn foo(foo: Foo) -> usize {\n+    foo as usize\n+}\n+\n+fn bar(bar: Bar) -> usize {\n+    bar as usize\n+}\n+\n+fn boo(boo: Boo) -> usize {\n+    boo as usize\n+}\n+\n+// EMIT_MIR enum_cast.droppy.mir_map.0.mir\n+enum Droppy {\n+    A, B, C\n+}\n+\n+impl Drop for Droppy {\n+    fn drop(&mut self) {}\n+}\n+\n+fn droppy() {\n+    {\n+        let x = Droppy::C;\n+        // remove this entire test once `cenum_impl_drop_cast` becomes a hard error\n+        #[allow(cenum_impl_drop_cast)]\n+        let y = x as usize;\n+    }\n+    let z = Droppy::B;\n+}\n+\n+fn main() {\n+}"}, {"sha": "f29bc50e84c4ea36322de62068f6d88dac3424e5", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53792b9c5c3cded466a073e4b9a9e51d0007b9ab/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=53792b9c5c3cded466a073e4b9a9e51d0007b9ab", "patch": "@@ -30,5 +30,5 @@ fn main() {\n         assert_eq!(e as u32, 2);\n         assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n     }\n-    assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n+    assert_eq!(FLAG.load(Ordering::SeqCst), 1);\n }"}]}