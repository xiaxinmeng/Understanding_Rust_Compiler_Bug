{"sha": "0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNWZkY2U4MmUxZTA5ZGY5NmVhMmVlMTkwZTlmZmZkOTFiMmM3MTQ=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-27T13:49:54Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-05-27T18:47:21Z"}, "message": "syntax highlight code examples in docstrings", "tree": {"sha": "3a003da2cb972550f937356f803fa6461ff8f56c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a003da2cb972550f937356f803fa6461ff8f56c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "html_url": "https://github.com/rust-lang/rust/commit/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3941f78a1bfb3ecf077dd782e5d03ea7fafcad86", "url": "https://api.github.com/repos/rust-lang/rust/commits/3941f78a1bfb3ecf077dd782e5d03ea7fafcad86", "html_url": "https://github.com/rust-lang/rust/commit/3941f78a1bfb3ecf077dd782e5d03ea7fafcad86"}], "stats": {"total": 282, "additions": 165, "deletions": 117}, "files": [{"sha": "319fb83d3f833e424b1183953344b8c8887aed6b", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -17,7 +17,7 @@\n  * In this example, a large vector of floats is shared between several tasks.\n  * With simple pipes, without ARC, a copy would have to be made for each task.\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * extern mod std;\n  * use std::arc;\n  * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n@@ -370,7 +370,10 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * See sync::rwlock.write_downgrade(). The RWWriteMode token must be used\n      * to obtain the &mut T, and can be transformed into a RWReadMode token by\n      * calling downgrade(), after which a &T can be obtained instead.\n-     * ~~~\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n      * do arc.write_downgrade |write_mode| {\n      *     do (&write_mode).write_cond |state, condvar| {\n      *         ... exclusive access with mutable state ..."}, {"sha": "e06bf2844828489e3193a5fefa1e951776efde51", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -28,17 +28,17 @@ impl<'self> ToBase64 for &'self [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n      *\n-     * *Example*:\n+     * # Example\n      *\n-     * ~~~~\n+     * ~~~ {.rust}\n      * extern mod std;\n      * use std::base64::ToBase64;\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64();\n      *     println(fmt!(\"%s\", str));\n      * }\n-     * ~~~~\n+     * ~~~\n      */\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n@@ -91,17 +91,17 @@ impl<'self> ToBase64 for &'self str {\n      * Convert any string (literal, `@`, `&`, or `~`) to base64 encoding.\n      *\n      *\n-     * *Example*:\n+     * # Example\n      *\n-     * ~~~~\n+     * ~~~ {.rust}\n      * extern mod std;\n      * use std::base64::ToBase64;\n      *\n      * fn main () {\n      *     let str = \"Hello, World\".to_base64();\n      *     println(fmt!(\"%s\",str));\n      * }\n-     * ~~~~\n+     * ~~~\n      *\n      */\n     fn to_base64(&self) -> ~str {\n@@ -118,9 +118,9 @@ impl FromBase64 for ~[u8] {\n      * Convert base64 `u8` vector into u8 byte values.\n      * Every 4 encoded characters is converted into 3 octets, modulo padding.\n      *\n-     * *Example*:\n+     * # Example\n      *\n-     * ~~~~\n+     * ~~~ {.rust}\n      * extern mod std;\n      * use std::base64::ToBase64;\n      * use std::base64::FromBase64;\n@@ -131,7 +131,7 @@ impl FromBase64 for ~[u8] {\n      *     let bytes = str.from_base64();\n      *     println(fmt!(\"%?\",bytes));\n      * }\n-     * ~~~~\n+     * ~~~\n      */\n     fn from_base64(&self) -> ~[u8] {\n         if self.len() % 4u != 0u { fail!(\"invalid base64 length\"); }\n@@ -196,11 +196,11 @@ impl FromBase64 for ~str {\n      * You can use the `from_bytes` function in `core::str`\n      * to turn a `[u8]` into a string with characters corresponding to those values.\n      *\n-     * *Example*:\n+     * # Example\n      *\n      * This converts a string literal to base64 and back.\n      *\n-     * ~~~~\n+     * ~~~ {.rust}\n      * extern mod std;\n      * use std::base64::ToBase64;\n      * use std::base64::FromBase64;\n@@ -214,7 +214,7 @@ impl FromBase64 for ~str {\n      *     let result_str = str::from_bytes(bytes);\n      *     println(fmt!(\"%s\",result_str));\n      * }\n-     * ~~~~\n+     * ~~~\n      */\n     fn from_base64(&self) -> ~[u8] {\n         str::to_bytes(*self).from_base64()"}, {"sha": "ed9614285e9a333fc5f80b3e3d02d7113d7e3457", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -25,7 +25,7 @@ ports and channels.\n \n This example sends boxed integers across tasks using serialization.\n \n-~~~\n+~~~ {.rust}\n let (port, chan) = serial::pipe_stream();\n \n do task::spawn || {"}, {"sha": "38df0c6a2085cd47ebba5fa38dd57983625df0af", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -14,7 +14,7 @@\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n  * let mut delayed_fib = std::future::spawn (|| fib(5000) );"}, {"sha": "aaa10fe562a8a6db685e94efab9ccf90999095f2", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -466,7 +466,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  * Here, the `new_conn` is used in conjunction with `accept` from within\n  * a task spawned by the `new_connect_cb` passed into `listen`\n  *\n- * ~~~~~~~~~~~\n+ * ~~~ {.rust}\n  * do net::tcp::listen(remote_ip, remote_port, backlog, iotask,\n  *     // this callback is ran once after the connection is successfully\n  *     // set up\n@@ -497,7 +497,7 @@ fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n  *       None => ()\n  *     }\n  * };\n- * ~~~~~~~~~~~\n+ * ~~~\n  *\n  * # Arguments\n  *"}, {"sha": "5768b015ab11f160e50fb21317bacf8968a88cc0", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -545,7 +545,10 @@ pub impl RWlock {\n      * the meantime (such as unlocking and then re-locking as a reader would\n      * do). The block takes a \"write mode token\" argument, which can be\n      * transformed into a \"read mode token\" by calling downgrade(). Example:\n-     * ~~~\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n      * do lock.write_downgrade |write_mode| {\n      *     do (&write_mode).write_cond |condvar| {\n      *         ... exclusive access ..."}, {"sha": "d91c09c99a22bb56754667d1e997e676c3f27acb", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -43,10 +43,13 @@ use from_str::FromStr;\n * Negation of a boolean value.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::not(true)\n * false\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::not(false)\n * true\n * ~~~\n@@ -57,10 +60,13 @@ pub fn not(v: bool) -> bool { !v }\n * Conjunction of two boolean values.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::and(true, false)\n * false\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::and(true, true)\n * true\n * ~~~\n@@ -71,10 +77,13 @@ pub fn and(a: bool, b: bool) -> bool { a && b }\n * Disjunction of two boolean values.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::or(true, false)\n * true\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::or(false, false)\n * false\n * ~~~\n@@ -87,10 +96,13 @@ pub fn or(a: bool, b: bool) -> bool { a || b }\n * 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::xor(true, false)\n * true\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::xor(true, true)\n * false\n * ~~~\n@@ -105,10 +117,12 @@ pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n * 'if a then b' is equivalent to `!a || b`.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::implies(true, true)\n * true\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::implies(true, false)\n * false\n * ~~~\n@@ -121,10 +135,13 @@ pub fn implies(a: bool, b: bool) -> bool { !a || b }\n * Two booleans are equal if they have the same value.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::eq(false, true)\n * false\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::eq(false, false)\n * true\n * ~~~\n@@ -137,10 +154,13 @@ pub fn eq(a: bool, b: bool) -> bool { a == b }\n * Two booleans are not equal if they have different values.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::ne(false, true)\n * true\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::ne(false, false)\n * false\n * ~~~\n@@ -151,10 +171,13 @@ pub fn ne(a: bool, b: bool) -> bool { a != b }\n * Is a given boolean value true?\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::is_true(true)\n * true\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::is_true(false)\n * false\n * ~~~\n@@ -165,10 +188,13 @@ pub fn is_true(v: bool) -> bool { v }\n * Is a given boolean value false?\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::is_false(false)\n * true\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::is_false(true)\n * false\n * ~~~\n@@ -181,13 +207,18 @@ pub fn is_false(v: bool) -> bool { !v }\n * Yields an `Option<bool>`, because `str` may or may not actually be parseable.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> FromStr::from_str::<bool>(\"true\")\n * Some(true)\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> FromStr::from_str::<bool>(\"false\")\n * Some(false)\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> FromStr::from_str::<bool>(\"not even a boolean\")\n * None\n * ~~~\n@@ -206,10 +237,13 @@ impl FromStr for bool {\n * Convert a `bool` to a `str`.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::to_str(true)\n * \"true\"\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::to_str(false)\n * \"false\"\n * ~~~\n@@ -237,10 +271,13 @@ pub fn all_values(blk: &fn(v: bool)) {\n * Convert a `bool` to a `u8`.\n *\n * # Examples\n-* ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::to_bit(true)\n * 1\n * ~~~\n+*\n+* ~~~ {.rust}\n * rusti> std::bool::to_bit(false)\n * 0\n * ~~~"}, {"sha": "fec7cde5360d6bfb63f41447b86f86d3e1083761", "filename": "src/libstd/io.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -1009,8 +1009,9 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n /**\n * Gives a `Reader` that allows you to read values from standard input.\n *\n-* # Examples\n-* ~~~\n+* # Example\n+*\n+* ~~~ {.rust}\n * let stdin = core::io::stdin();\n * let line = stdin.read_line();\n * core::io::print(line);\n@@ -1572,8 +1573,9 @@ pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n /**\n * Gives a `Writer` which allows you to write to the standard output.\n *\n-* # Examples\n-* ~~~\n+* # Example\n+*\n+* ~~~ {.rust}\n * let stdout = core::io::stdout();\n * stdout.write_str(\"hello\\n\");\n * ~~~\n@@ -1583,8 +1585,9 @@ pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n /**\n * Gives a `Writer` which allows you to write to standard error.\n *\n-* # Examples\n-* ~~~\n+* # Example\n+*\n+* ~~~ {.rust}\n * let stderr = core::io::stderr();\n * stderr.write_str(\"hello\\n\");\n * ~~~\n@@ -1597,8 +1600,9 @@ pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n * This string will not have an implicit newline at the end. If you want\n * an implicit newline, please see `println`.\n *\n-* # Examples\n-* ~~~\n+* # Example\n+*\n+* ~~~ {.rust}\n * // print is imported into the prelude, and so is always available.\n * print(\"hello\");\n * ~~~\n@@ -1612,8 +1616,9 @@ pub fn print(s: &str) {\n *\n * If you do not want an implicit newline, please see `print`.\n *\n-* # Examples\n-* ~~~\n+* # Example\n+*\n+* ~~~ {.rust}\n * // println is imported into the prelude, and so is always available.\n * println(\"hello\");\n * ~~~"}, {"sha": "800ce9f05dc75bfca6e9542fd4cf36f44ca7be86", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -16,14 +16,14 @@ An internal iterator takes `fn(...) -> bool` as a parameter, with returning `fal\n breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n tied to specific traits. For example:\n \n-~~~~\n+~~~ {.rust}\n println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n-~~~~\n+~~~\n \n An external iterator object implementing the interface in the `iterator` module can be used as an\n internal iterator by calling the `advance` method. For example:\n \n-~~~~\n+~~~ {.rust}\n use core::iterator::*;\n \n let xs = [0u, 1, 2, 3, 4, 5];\n@@ -32,7 +32,7 @@ let mut it = xs.iter().chain(ys.iter());\n for it.advance |&x: &uint| {\n     println(x.to_str());\n }\n-~~~~\n+~~~\n \n Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n@@ -55,7 +55,7 @@ pub trait Times {\n  *\n  * # Example:\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let xs = ~[1, 2, 3];\n  * let ys = do iter::to_vec |f| { xs.each(|x| f(*x)) };\n  * assert_eq!(xs, ys);\n@@ -73,11 +73,11 @@ pub fn to_vec<T>(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n  *\n  * Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs = ~[1u, 2, 3, 4, 5];\n  * assert!(any(|&x: &uint| x > 2, |f| xs.each(f)));\n  * assert!(!any(|&x: &uint| x > 5, |f| xs.each(f)));\n- * ~~~~\n+ * ~~~\n  */\n #[inline(always)]\n pub fn any<T>(predicate: &fn(T) -> bool,\n@@ -95,10 +95,10 @@ pub fn any<T>(predicate: &fn(T) -> bool,\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n  * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~~\n+ * ~~~\n  */\n #[inline(always)]\n pub fn all<T>(predicate: &fn(T) -> bool,\n@@ -113,10 +113,10 @@ pub fn all<T>(predicate: &fn(T) -> bool,\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs = ~[1u, 2, 3, 4, 5, 6];\n  * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.each(f)).unwrap(), 4);\n- * ~~~~\n+ * ~~~\n  */\n #[inline(always)]\n pub fn find<T>(predicate: &fn(&T) -> bool,\n@@ -134,10 +134,10 @@ pub fn find<T>(predicate: &fn(&T) -> bool,\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n  * assert_eq!(max(|f| xs.each(f)).unwrap(), &15);\n- * ~~~~\n+ * ~~~\n  */\n #[inline]\n pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n@@ -160,10 +160,10 @@ pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n  * assert_eq!(max(|f| xs.each(f)).unwrap(), &-5);\n- * ~~~~\n+ * ~~~\n  */\n #[inline]\n pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n@@ -186,9 +186,9 @@ pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~~\n+ * ~~~\n  */\n #[inline]\n pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n@@ -207,11 +207,11 @@ pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T,\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n  * }\n- * ~~~~\n+ * ~~~\n  */\n #[inline]\n pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n@@ -227,10 +227,10 @@ pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&m\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs: ~[int] = ~[1, 2, 3, 4];\n  * assert_eq!(do sum |f| { xs.each(f) }, 10);\n- * ~~~~\n+ * ~~~\n  */\n #[inline(always)]\n pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n@@ -242,10 +242,10 @@ pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n  *\n  * # Example:\n  *\n- * ~~~~\n+ * ~~~ {.rust}\n  * let xs: ~[int] = ~[1, 2, 3, 4];\n  * assert_eq!(do product |f| { xs.each(f) }, 24);\n- * ~~~~\n+ * ~~~\n  */\n #[inline(always)]\n pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {"}, {"sha": "94cff78375af005fa64f65604b81235262d0f354", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -364,7 +364,7 @@ impl Round for f32 {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~\n+    /// ~~~ {.rust}\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///"}, {"sha": "b7754ed07ad72abc6407a5d3567559d65b7e389b", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -376,7 +376,7 @@ impl Round for f64 {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~\n+    /// ~~~ {.rust}\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///"}, {"sha": "acc5e5a6f39a20d6d33f074cba6c2c1f2235d5b3", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -454,7 +454,7 @@ impl Round for float {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~\n+    /// ~~~ {.rust}\n     /// assert!(x == trunc(x) + fract(x))\n     /// ~~~\n     ///"}, {"sha": "4203f87f1395ba9817a0005a03a28bde20b19cb9", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -16,7 +16,7 @@ the other can receive messages. The set of legal messages and which\n directions they can flow at any given point are determined by a\n protocol. Below is an example protocol.\n \n-~~~\n+~~~ {.rust}\n proto! pingpong (\n     ping: send {\n         ping -> pong\n@@ -785,20 +785,20 @@ or `right` if the second endpoint receives something. In each case,\n the result includes the other endpoint as well so it can be used\n again. Below is an example of using `select2`.\n \n-~~~\n+~~~ {.rust}\n match select2(a, b) {\n-  left((none, b)) {\n-    // endpoint a was closed.\n-  }\n-  right((a, none)) {\n-    // endpoint b was closed.\n-  }\n-  left((Some(_), b)) {\n-    // endpoint a received a message\n-  }\n-  right(a, Some(_)) {\n-    // endpoint b received a message.\n-  }\n+    left((none, b)) {\n+        // endpoint a was closed.\n+    }\n+    right((a, none)) {\n+        // endpoint b was closed.\n+    }\n+    left((Some(_), b)) {\n+        // endpoint a received a message\n+    }\n+    right(a, Some(_)) {\n+        // endpoint b received a message.\n+    }\n }\n ~~~\n "}, {"sha": "2bcc9c8bba20213afcd8494cf9108d2243d2db53", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -20,7 +20,8 @@ See the `distributions` submodule for sampling random numbers from\n distributions like normal and exponential.\n \n # Examples\n-~~~\n+\n+~~~ {.rust}\n use core::rand::RngUtil;\n \n fn main() {\n@@ -31,7 +32,7 @@ fn main() {\n }\n ~~~\n \n-~~~\n+~~~ {.rust}\n fn main () {\n     let tuple_ptr = rand::random::<~(f64, char)>();\n     println(fmt!(\"%?\", tuple_ptr))\n@@ -276,9 +277,9 @@ pub trait RngUtil {\n     /**\n      * Return a bool with a 1 in n chance of true\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -292,9 +293,9 @@ pub trait RngUtil {\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -308,9 +309,9 @@ pub trait RngUtil {\n     /**\n      * Return a random byte string of the specified length\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -324,9 +325,9 @@ pub trait RngUtil {\n     /**\n      * Choose an item randomly, failing if values is empty\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -343,9 +344,9 @@ pub trait RngUtil {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -363,9 +364,9 @@ pub trait RngUtil {\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -384,9 +385,9 @@ pub trait RngUtil {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -403,9 +404,9 @@ pub trait RngUtil {\n     /**\n      * Shuffle a vec\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *\n@@ -419,9 +420,9 @@ pub trait RngUtil {\n     /**\n      * Shuffle a mutable vec in place\n      *\n-     * *Example*\n+     * # Example\n      *\n-     * ~~~\n+     * ~~~ {.rust}\n      *\n      * use core::rand::RngUtil;\n      *"}, {"sha": "449c7848f5636b47fb5fe3c3814b20dc251a810e", "filename": "src/libstd/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -726,7 +726,7 @@ fn iter_between_matches<'a,'b>(s: &'a str,\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let mut v = ~[];\n  * for each_split_str(\".XXX.YYY.\", \".\") |subs| { v.push(subs); }\n  * assert!(v == [\"\", \"XXX\", \"YYY\", \"\"]);\n@@ -1923,7 +1923,7 @@ pub fn is_char_boundary(s: &str, index: uint) -> bool {\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n  * let i = 0u;\n  * while i < str::len(s) {\n@@ -2109,7 +2109,7 @@ static tag_six_b: uint = 252u;\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let i = str::as_bytes(\"Hello World\") { |bytes| bytes.len() };\n  * ~~~\n  */\n@@ -2145,7 +2145,7 @@ pub fn as_bytes_slice<'a>(s: &'a str) -> &'a [u8] {\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n@@ -2184,7 +2184,7 @@ pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n  *\n  * # Example\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * let string = \"a\\nb\\nc\";\n  * let mut lines = ~[];\n  * for each_line(string) |line| { lines.push(line) }"}, {"sha": "9e7f18f446d08056ac23cd276cd71d55e1a848ae", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -138,7 +138,7 @@ terminate normally, but instead directly return from a function.\n \n # Example\n \n-~~~\n+~~~ {.rust}\n fn choose_weighted_item(v: &[Item]) -> Item {\n     assert!(!v.is_empty());\n     let mut so_far = 0u;"}, {"sha": "7e73158fee4d14b638af91f1988f2e5e26aa22a4", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5fdce82e1e09df96ea2ee190e9fffd91b2c714/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0d5fdce82e1e09df96ea2ee190e9fffd91b2c714", "patch": "@@ -977,7 +977,7 @@ pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n  *\n  * Sum all values in the vector [1, 2, 3]:\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * vec::foldl(0, [1, 2, 3], |a, b| a + *b);\n  * ~~~\n  *\n@@ -1009,7 +1009,7 @@ pub fn foldl<'a, T, U>(z: T, v: &'a [U], p: &fn(t: T, u: &'a U) -> T) -> T {\n  *\n  * Sum all values in the vector [1, 2, 3]:\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * vec::foldr([1, 2, 3], 0, |a, b| a + *b);\n  * ~~~\n  *\n@@ -1376,10 +1376,8 @@ pub fn reverse<T>(v: &mut [T]) {\n  *\n  * Assume a mutable vector `v` contains `[1,2,3,4,5]`. After the call:\n  *\n- * ~~~\n- *\n+ * ~~~ {.rust}\n  * reverse_part(v, 1, 4);\n- *\n  * ~~~\n  *\n  * `v` now contains `[1,4,3,2,5]`.\n@@ -1416,14 +1414,15 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * * continue iterating, false to break.\n  *\n  * # Examples\n- * ~~~\n+ *\n+ * ~~~ {.rust}\n  * [1,2,3].each(|&i| {\n  *     io::println(int::str(i));\n  *     true\n  * });\n  * ~~~\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * [1,2,3,4,5].each(|&i| {\n  *     if i < 4 {\n  *         io::println(int::str(i));\n@@ -1438,7 +1437,7 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n  * You probably will want to use each with a `for`/`do` expression, depending\n  * on your iteration needs:\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * for [1,2,3].each |&i| {\n  *     io::println(int::str(i));\n  * }\n@@ -1700,7 +1699,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n  *\n  * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`, `[3,4]`)\n  *\n- * ~~~\n+ * ~~~ {.rust}\n  * for windowed(2, &[1,2,3,4]) |v| {\n  *     io::println(fmt!(\"%?\", v));\n  * }"}]}