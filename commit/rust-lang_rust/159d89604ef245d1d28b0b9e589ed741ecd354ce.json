{"sha": "159d89604ef245d1d28b0b9e589ed741ecd354ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OWQ4OTYwNGVmMjQ1ZDFkMjhiMGI5ZTU4OWVkNzQxZWNkMzU0Y2U=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-04-03T17:37:02Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-04-04T05:43:10Z"}, "message": "std: add a pure rust strptime parser.", "tree": {"sha": "7d838889dafe8092e6783b5d36d63fbff19c56a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d838889dafe8092e6783b5d36d63fbff19c56a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/159d89604ef245d1d28b0b9e589ed741ecd354ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/159d89604ef245d1d28b0b9e589ed741ecd354ce", "html_url": "https://github.com/rust-lang/rust/commit/159d89604ef245d1d28b0b9e589ed741ecd354ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/159d89604ef245d1d28b0b9e589ed741ecd354ce/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff9305cd99fe6d8f69937eed6d5244bde76a431a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9305cd99fe6d8f69937eed6d5244bde76a431a", "html_url": "https://github.com/rust-lang/rust/commit/ff9305cd99fe6d8f69937eed6d5244bde76a431a"}], "stats": {"total": 606, "additions": 605, "deletions": 1}, "files": [{"sha": "b4c37a5d44df4ce9260bd3f4c7c7dfb1bbf3f57c", "filename": "src/libstd/time.rs", "status": "modified", "additions": 605, "deletions": 1, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/159d89604ef245d1d28b0b9e589ed741ecd354ce/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/159d89604ef245d1d28b0b9e589ed741ecd354ce/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=159d89604ef245d1d28b0b9e589ed741ecd354ce", "patch": "@@ -12,7 +12,8 @@ export\n     now,\n     at,\n     now_utc,\n-    at_utc;\n+    at_utc,\n+    strptime;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -116,6 +117,464 @@ fn now() -> tm {\n     at(get_time())\n }\n \n+#[doc = \"Parses the time from the string according to the format string.\"]\n+fn strptime(s: str, format: str) -> result<tm, str> {\n+    type tm_mut = {\n+       mut tm_sec: i32,\n+       mut tm_min: i32,\n+       mut tm_hour: i32,\n+       mut tm_mday: i32,\n+       mut tm_mon: i32,\n+       mut tm_year: i32,\n+       mut tm_wday: i32,\n+       mut tm_yday: i32,\n+       mut tm_isdst: i32,\n+       mut tm_gmtoff: i32,\n+       mut tm_zone: str,\n+       mut tm_nsec: i32,\n+    };\n+\n+    fn match_str(s: str, pos: uint, needle: str) -> bool {\n+        let mut i = pos;\n+        for str::each(needle) {|ch|\n+            if s[i] != ch {\n+                ret false;\n+            }\n+            i += 1u;\n+        }\n+        ret true;\n+    }\n+\n+    fn match_strs(s: str, pos: uint, strs: [(str, i32)])\n+      -> option<(i32, uint)> {\n+        let mut i = 0u;\n+        let len = vec::len(strs);\n+        while i < len {\n+            let (needle, value) = strs[i];\n+\n+            if match_str(s, pos, needle) {\n+                ret some((value, pos + str::len(needle)));\n+            }\n+            i += 1u;\n+        }\n+\n+        none\n+    }\n+\n+    fn match_digits(s: str, pos: uint, digits: uint, ws: bool)\n+      -> option<(i32, uint)> {\n+        let mut pos = pos;\n+        let mut value = 0_i32;\n+\n+        let mut i = 0u;\n+        while i < digits {\n+            let {ch, next} = str::char_range_at(s, pos);\n+            pos = next;\n+\n+            alt ch {\n+              '0' to '9' {\n+                value = value * 10_i32 + (ch as i32 - '0' as i32);\n+              }\n+              ' ' if ws { }\n+              _ { ret none; }\n+            }\n+            i += 1u;\n+        }\n+\n+        some((value, pos))\n+    }\n+\n+    fn parse_char(s: str, pos: uint, c: char) -> result<uint, str> {\n+        let {ch, next} = str::char_range_at(s, pos);\n+\n+        if c == ch {\n+            ok(next)\n+        } else {\n+            err(#fmt(\"Expected %?, found %?\",\n+                str::from_char(c),\n+                str::from_char(ch)))\n+        }\n+    }\n+\n+    fn parse_type(s: str, pos: uint, ch: char, tm: tm_mut)\n+      -> result<uint, str> {\n+        alt ch {\n+          'A' {\n+            alt match_strs(s, pos, [\n+                (\"Sunday\", 0_i32),\n+                (\"Monday\", 1_i32),\n+                (\"Tuesday\", 2_i32),\n+                (\"Wednesday\", 3_i32),\n+                (\"Thursday\", 4_i32),\n+                (\"Friday\", 5_i32),\n+                (\"Saturday\", 6_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid day\") }\n+            }\n+          }\n+          'a' {\n+            alt match_strs(s, pos, [\n+                (\"Sun\", 0_i32),\n+                (\"Mon\", 1_i32),\n+                (\"Tue\", 2_i32),\n+                (\"Wed\", 3_i32),\n+                (\"Thu\", 4_i32),\n+                (\"Fri\", 5_i32),\n+                (\"Sat\", 6_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid day\") }\n+            }\n+          }\n+          'B' {\n+            alt match_strs(s, pos, [\n+                (\"January\", 0_i32),\n+                (\"February\", 1_i32),\n+                (\"March\", 2_i32),\n+                (\"April\", 3_i32),\n+                (\"May\", 4_i32),\n+                (\"June\", 5_i32),\n+                (\"July\", 6_i32),\n+                (\"August\", 7_i32),\n+                (\"September\", 8_i32),\n+                (\"October\", 9_i32),\n+                (\"November\", 10_i32),\n+                (\"December\", 11_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'b' | 'h' {\n+            alt match_strs(s, pos, [\n+                (\"Jan\", 0_i32),\n+                (\"Feb\", 1_i32),\n+                (\"Mar\", 2_i32),\n+                (\"Apr\", 3_i32),\n+                (\"May\", 4_i32),\n+                (\"Jun\", 5_i32),\n+                (\"Jul\", 6_i32),\n+                (\"Aug\", 7_i32),\n+                (\"Sep\", 8_i32),\n+                (\"Oct\", 9_i32),\n+                (\"Nov\", 10_i32),\n+                (\"Dec\", 11_i32)\n+            ]) {\n+              some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'C' {\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year += (v * 100_i32) - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid year\") }\n+            }\n+          }\n+          'c' {\n+            parse_type(s, pos, 'a', tm)\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'b', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'e', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'T', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+          }\n+          'D' | 'x' {\n+            parse_type(s, pos, 'm', tm)\n+                .chain { |pos| parse_char(s, pos, '/') }\n+                .chain { |pos| parse_type(s, pos, 'd', tm) }\n+                .chain { |pos| parse_char(s, pos, '/') }\n+                .chain { |pos| parse_type(s, pos, 'y', tm) }\n+          }\n+          'd' {\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+              none { err(\"Invalid day of the month\") }\n+            }\n+          }\n+          'e' {\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n+              none { err(\"Invalid day of the month\") }\n+            }\n+          }\n+          'F' {\n+            parse_type(s, pos, 'Y', tm)\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'm', tm) }\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'd', tm) }\n+          }\n+          'H' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'I' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                  let (v, pos) = item;\n+                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n+                  ok(pos)\n+              }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'j' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 3u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_yday = v - 1_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid year\") }\n+            }\n+          }\n+          'k' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'l' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, true) {\n+              some(item) {\n+                  let (v, pos) = item;\n+                  tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n+                  ok(pos)\n+              }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'M' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n+              none { err(\"Invalid minute\") }\n+            }\n+          }\n+          'm' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_mon = v - 1_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid month\") }\n+            }\n+          }\n+          'n' { parse_char(s, pos, '\\n') }\n+          'P' {\n+            alt match_strs(s, pos, [(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n+              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'p' {\n+            alt match_strs(s, pos, [(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n+              some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n+              none { err(\"Invalid hour\") }\n+            }\n+          }\n+          'R' {\n+            parse_type(s, pos, 'H', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+          }\n+          'r' {\n+            parse_type(s, pos, 'I', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'S', tm) }\n+                .chain { |pos| parse_char(s, pos, ' ') }\n+                .chain { |pos| parse_type(s, pos, 'p', tm) }\n+          }\n+          'S' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_sec = v;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid second\") }\n+            }\n+          }\n+          //'s' {}\n+          'T' | 'X' {\n+            parse_type(s, pos, 'H', tm)\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'M', tm) }\n+                .chain { |pos| parse_char(s, pos, ':') }\n+                .chain { |pos| parse_type(s, pos, 'S', tm) }\n+          }\n+          't' { parse_char(s, pos, '\\t') }\n+          'u' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 1u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_wday = v;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'v' {\n+            parse_type(s, pos, 'e', tm)\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'b', tm) }\n+                .chain { |pos| parse_char(s, pos, '-') }\n+                .chain { |pos| parse_type(s, pos, 'Y', tm) }\n+          }\n+          //'W' {}\n+          'w' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 1u, false) {\n+              some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          //'X' {}\n+          //'x' {}\n+          'Y' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 4u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year = v - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'y' {\n+            // FIXME: range check.\n+            alt match_digits(s, pos, 2u, false) {\n+              some(item) {\n+                let (v, pos) = item;\n+                tm.tm_year = v - 1900_i32;\n+                ok(pos)\n+              }\n+              none { err(\"Invalid weekday\") }\n+            }\n+          }\n+          'Z' {\n+            if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n+                tm.tm_gmtoff = 0_i32;\n+                tm.tm_zone = \"UTC\";\n+                ok(pos + 3u)\n+            } else {\n+                // It's odd, but to maintain compatibility with c's\n+                // strptime we ignore the timezone.\n+                let mut pos = pos;\n+                let len = str::len(s);\n+                while pos < len {\n+                    let {ch, next} = str::char_range_at(s, pos);\n+                    pos = next;\n+                    if ch == ' ' { break; }\n+                }\n+\n+                ok(pos)\n+            }\n+          }\n+          'z' {\n+            let {ch, next} = str::char_range_at(s, pos);\n+\n+            if ch == '+' || ch == '-' {\n+                alt match_digits(s, next, 4u, false) {\n+                  some(item) {\n+                    let (v, pos) = item;\n+                    if v == 0_i32 {\n+                        tm.tm_gmtoff = 0_i32;\n+                        tm.tm_zone = \"UTC\";\n+                    }\n+\n+                    ok(pos)\n+                  }\n+                  none { err(\"Invalid zone offset\") }\n+                }\n+            } else {\n+                err(\"Invalid zone offset\")\n+            }\n+          }\n+          '%' { parse_char(s, pos, '%') }\n+          ch {\n+            err(#fmt(\"unknown formatting type: %?\", str::from_char(ch)))\n+          }\n+        }\n+    }\n+\n+    io::with_str_reader(format) { |rdr|\n+        let tm = {\n+            mut tm_sec: 0_i32,\n+            mut tm_min: 0_i32,\n+            mut tm_hour: 0_i32,\n+            mut tm_mday: 0_i32,\n+            mut tm_mon: 0_i32,\n+            mut tm_year: 0_i32,\n+            mut tm_wday: 0_i32,\n+            mut tm_yday: 0_i32,\n+            mut tm_isdst: 0_i32,\n+            mut tm_gmtoff: 0_i32,\n+            mut tm_zone: \"\",\n+            mut tm_nsec: 0_i32,\n+        };\n+        let mut pos = 0u;\n+        let len = str::len(s);\n+        let mut result = err(\"Invalid time\");\n+\n+        while !rdr.eof() && pos < len {\n+            let {ch, next} = str::char_range_at(s, pos);\n+\n+            alt rdr.read_char() {\n+              '%' {\n+                alt parse_type(s, pos, rdr.read_char(), tm) {\n+                  ok(next) { pos = next; }\n+                  err(e) { result = err(e); break; }\n+                }\n+              }\n+              c {\n+                if c != ch { break }\n+                pos = next;\n+              }\n+            }\n+        }\n+\n+        if pos == len && rdr.eof() {\n+            ok({\n+                tm_sec: tm.tm_sec,\n+                tm_min: tm.tm_min,\n+                tm_hour: tm.tm_hour,\n+                tm_mday: tm.tm_mday,\n+                tm_mon: tm.tm_mon,\n+                tm_year: tm.tm_year,\n+                tm_wday: tm.tm_wday,\n+                tm_yday: tm.tm_yday,\n+                tm_isdst: tm.tm_isdst,\n+                tm_gmtoff: tm.tm_gmtoff,\n+                tm_zone: tm.tm_zone,\n+                tm_nsec: tm.tm_nsec,\n+            })\n+        } else { result }\n+    }\n+}\n+\n fn strftime(format: str, tm: tm) -> str {\n     fn parse_type(ch: char, tm: tm) -> str {\n         //FIXME: Implement missing types.\n@@ -480,6 +939,151 @@ mod tests {\n         assert utc.to_local().to_utc() == utc;\n     }\n \n+    #[test]\n+    fn test_strptime() {\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+\n+        alt strptime(\"\", \"\") {\n+          ok(tm) {\n+            assert tm.tm_sec == 0_i32;\n+            assert tm.tm_min == 0_i32;\n+            assert tm.tm_hour == 0_i32;\n+            assert tm.tm_mday == 0_i32;\n+            assert tm.tm_mon == 0_i32;\n+            assert tm.tm_year == 0_i32;\n+            assert tm.tm_wday == 0_i32;\n+            assert tm.tm_isdst== 0_i32;\n+            assert tm.tm_gmtoff == 0_i32;\n+            assert tm.tm_zone == \"\";\n+            assert tm.tm_nsec == 0_i32;\n+          }\n+          err(_) {}\n+        }\n+\n+        let format = \"%a %b %e %T %Y\";\n+        assert strptime(\"\", format) == err(\"Invalid time\");\n+        assert strptime(\"Fri Feb 13 15:31:30\", format) == err(\"Invalid time\");\n+\n+        alt strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n+          err(e) { fail e }\n+          ok(tm) {\n+            assert tm.tm_sec == 30_i32;\n+            assert tm.tm_min == 31_i32;\n+            assert tm.tm_hour == 15_i32;\n+            assert tm.tm_mday == 13_i32;\n+            assert tm.tm_mon == 1_i32;\n+            assert tm.tm_year == 109_i32;\n+            assert tm.tm_wday == 5_i32;\n+            assert tm.tm_yday == 0_i32;\n+            assert tm.tm_isdst == 0_i32;\n+            assert tm.tm_gmtoff == 0_i32;\n+            assert tm.tm_zone == \"\";\n+            assert tm.tm_nsec == 0_i32;\n+          }\n+        }\n+\n+        fn test(s: str, format: str) -> bool {\n+            alt strptime(s, format) {\n+              ok(tm) { tm.strftime(format) == s }\n+              err(e) { fail e }\n+            }\n+        }\n+\n+        [\n+            \"Sunday\",\n+            \"Monday\",\n+            \"Tuesday\",\n+            \"Wednesday\",\n+            \"Thursday\",\n+            \"Friday\",\n+            \"Saturday\"\n+        ].iter { |day| assert test(day, \"%A\"); }\n+\n+        [\n+            \"Sun\",\n+            \"Mon\",\n+            \"Tue\",\n+            \"Wed\",\n+            \"Thu\",\n+            \"Fri\",\n+            \"Sat\"\n+        ].iter { |day| assert test(day, \"%a\"); }\n+\n+        [\n+            \"January\",\n+            \"February\",\n+            \"March\",\n+            \"April\",\n+            \"May\",\n+            \"June\",\n+            \"July\",\n+            \"August\",\n+            \"September\",\n+            \"October\",\n+            \"November\",\n+            \"December\"\n+        ].iter { |day| assert test(day, \"%B\"); }\n+\n+        [\n+            \"Jan\",\n+            \"Feb\",\n+            \"Mar\",\n+            \"Apr\",\n+            \"May\",\n+            \"Jun\",\n+            \"Jul\",\n+            \"Aug\",\n+            \"Sep\",\n+            \"Oct\",\n+            \"Nov\",\n+            \"Dec\"\n+        ].iter { |day| assert test(day, \"%b\"); }\n+\n+        assert test(\"19\", \"%C\");\n+        assert test(\"Fri Feb 13 23:31:30 2009\", \"%c\");\n+        assert test(\"02/13/09\", \"%D\");\n+        assert test(\"03\", \"%d\");\n+        assert test(\"13\", \"%d\");\n+        assert test(\" 3\", \"%e\");\n+        assert test(\"13\", \"%e\");\n+        assert test(\"2009-02-13\", \"%F\");\n+        assert test(\"03\", \"%H\");\n+        assert test(\"13\", \"%H\");\n+        assert test(\"03\", \"%I\"); // FIXME: flesh out\n+        assert test(\"11\", \"%I\"); // FIXME: flesh out\n+        assert test(\"044\", \"%j\");\n+        assert test(\" 3\", \"%k\");\n+        assert test(\"13\", \"%k\");\n+        assert test(\" 1\", \"%l\");\n+        assert test(\"11\", \"%l\");\n+        assert test(\"03\", \"%M\");\n+        assert test(\"13\", \"%M\");\n+        assert test(\"\\n\", \"%n\");\n+        assert test(\"am\", \"%P\");\n+        assert test(\"pm\", \"%P\");\n+        assert test(\"AM\", \"%p\");\n+        assert test(\"PM\", \"%p\");\n+        assert test(\"23:31\", \"%R\");\n+        assert test(\"11:31:30 AM\", \"%r\");\n+        assert test(\"11:31:30 PM\", \"%r\");\n+        assert test(\"03\", \"%S\");\n+        assert test(\"13\", \"%S\");\n+        assert test(\"15:31:30\", \"%T\");\n+        assert test(\"\\t\", \"%t\");\n+        assert test(\"1\", \"%u\");\n+        assert test(\"7\", \"%u\");\n+        assert test(\"13-Feb-2009\", \"%v\");\n+        assert test(\"0\", \"%w\");\n+        assert test(\"6\", \"%w\");\n+        assert test(\"2009\", \"%Y\");\n+        assert test(\"09\", \"%y\");\n+        assert strptime(\"UTC\", \"%Z\").get().tm_zone == \"UTC\";\n+        assert strptime(\"PST\", \"%Z\").get().tm_zone == \"\";\n+        assert strptime(\"-0000\", \"%z\").get().tm_gmtoff == 0_i32;\n+        assert strptime(\"-0800\", \"%z\").get().tm_gmtoff == 0_i32;\n+        assert test(\"%\", \"%%\");\n+    }\n+\n     #[test]\n     fn test_ctime() {\n         os::setenv(\"TZ\", \"America/Los_Angeles\");"}]}