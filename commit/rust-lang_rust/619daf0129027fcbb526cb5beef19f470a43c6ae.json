{"sha": "619daf0129027fcbb526cb5beef19f470a43c6ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWRhZjAxMjkwMjdmY2JiNTI2Y2I1YmVlZjE5ZjQ3MGE0M2M2YWU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T13:48:38Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T13:48:38Z"}, "message": "Re-add support for integer binops.", "tree": {"sha": "4647473f4f5a74a00ea14a57757fde2420200920", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4647473f4f5a74a00ea14a57757fde2420200920"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619daf0129027fcbb526cb5beef19f470a43c6ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619daf0129027fcbb526cb5beef19f470a43c6ae", "html_url": "https://github.com/rust-lang/rust/commit/619daf0129027fcbb526cb5beef19f470a43c6ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619daf0129027fcbb526cb5beef19f470a43c6ae/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83adde623f5ba4c7fb1aee5200658a677e8a7046", "url": "https://api.github.com/repos/rust-lang/rust/commits/83adde623f5ba4c7fb1aee5200658a677e8a7046", "html_url": "https://github.com/rust-lang/rust/commit/83adde623f5ba4c7fb1aee5200658a677e8a7046"}], "stats": {"total": 194, "additions": 97, "deletions": 97}, "files": [{"sha": "d37a95113bb82db562169c2f4731d29ce73f6a15", "filename": "src/interpreter.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/619daf0129027fcbb526cb5beef19f470a43c6ae/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619daf0129027fcbb526cb5beef19f470a43c6ae/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=619daf0129027fcbb526cb5beef19f470a43c6ae", "patch": "@@ -236,90 +236,39 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Pointer> {\n-        let frame = self.current_frame();\n-\n-        use rustc::mir::repr::Lvalue::*;\n-        let ptr = match *lvalue {\n-            ReturnPointer =>\n-                frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i) => frame.arg_ptr(i),\n-            Var(i) => frame.var_ptr(i),\n-            Temp(i) => frame.temp_ptr(i),\n-            ref l => panic!(\"can't handle lvalue: {:?}\", l),\n+    fn eval_binary_op(\n+        &mut self, bin_op: mir::BinOp, left_operand: &mir::Operand<'tcx>,\n+        right_operand: &mir::Operand<'tcx>, dest: Pointer\n+    ) -> EvalResult<()> {\n+        // FIXME(tsion): Check for non-integer binary operations.\n+        let left = try!(self.operand_to_ptr(left_operand));\n+        let right = try!(self.operand_to_ptr(right_operand));\n+        let l = try!(self.memory.read_int(left));\n+        let r = try!(self.memory.read_int(right));\n+\n+        use rustc::mir::repr::BinOp::*;\n+        let n = match bin_op {\n+            Add    => l + r,\n+            Sub    => l - r,\n+            Mul    => l * r,\n+            Div    => l / r,\n+            Rem    => l % r,\n+            BitXor => l ^ r,\n+            BitAnd => l & r,\n+            BitOr  => l | r,\n+            Shl    => l << r,\n+            Shr    => l >> r,\n+            _      => unimplemented!(),\n+            // Eq     => Value::Bool(l == r),\n+            // Lt     => Value::Bool(l < r),\n+            // Le     => Value::Bool(l <= r),\n+            // Ne     => Value::Bool(l != r),\n+            // Ge     => Value::Bool(l >= r),\n+            // Gt     => Value::Bool(l > r),\n         };\n-\n-        Ok(ptr)\n-\n-        //     mir::Lvalue::Projection(ref proj) => {\n-        //         let base_ptr = self.lvalue_to_ptr(&proj.base);\n-\n-        //         match proj.elem {\n-        //             mir::ProjectionElem::Field(field, _) => {\n-        //                 base_ptr.offset(field.index())\n-        //             }\n-\n-        //             mir::ProjectionElem::Downcast(_, variant) => {\n-        //                 let adt_val = self.read_pointer(base_ptr);\n-        //                 if let Value::Adt { variant: actual_variant, data_ptr } = adt_val {\n-        //                     debug_assert_eq!(variant, actual_variant);\n-        //                     data_ptr\n-        //                 } else {\n-        //                     panic!(\"Downcast attempted on non-ADT: {:?}\", adt_val)\n-        //                 }\n-        //             }\n-\n-        //             mir::ProjectionElem::Deref => {\n-        //                 let ptr_val = self.read_pointer(base_ptr);\n-        //                 if let Value::Pointer(ptr) = ptr_val {\n-        //                     ptr\n-        //                 } else {\n-        //                     panic!(\"Deref attempted on non-pointer: {:?}\", ptr_val)\n-        //                 }\n-        //             }\n-\n-        //             mir::ProjectionElem::Index(ref _operand) => unimplemented!(),\n-        //             mir::ProjectionElem::ConstantIndex { .. } => unimplemented!(),\n-        //         }\n-        //     }\n-\n-        //     _ => unimplemented!(),\n-        // }\n+        self.memory.write_int(dest, n)\n     }\n \n-    // fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, dest: Pointer)\n-    //         -> EvalResult<()> {\n-    //     use rustc::mir::repr::BinOp::*;\n-    //     match (&left.repr, &right.repr, &dest.repr) {\n-    //         (&Repr::Int, &Repr::Int, &Repr::Int) => {\n-    //             let l = try!(self.memory.read_int(left));\n-    //             let r = try!(self.memory.read_int(right));\n-    //             let n = match bin_op {\n-    //                 Add    => l + r,\n-    //                 Sub    => l - r,\n-    //                 Mul    => l * r,\n-    //                 Div    => l / r,\n-    //                 Rem    => l % r,\n-    //                 BitXor => l ^ r,\n-    //                 BitAnd => l & r,\n-    //                 BitOr  => l | r,\n-    //                 Shl    => l << r,\n-    //                 Shr    => l >> r,\n-    //                 _      => unimplemented!(),\n-    //                 // Eq     => Value::Bool(l == r),\n-    //                 // Lt     => Value::Bool(l < r),\n-    //                 // Le     => Value::Bool(l <= r),\n-    //                 // Ne     => Value::Bool(l != r),\n-    //                 // Ge     => Value::Bool(l >= r),\n-    //                 // Gt     => Value::Bool(l > r),\n-    //             };\n-    //             self.memory.write_int(dest, n)\n-    //         }\n-    //         (l, r, o) =>\n-    //             panic!(\"unhandled binary operation: {:?}({:?}, {:?}) into {:?}\", bin_op, l, r, o),\n-    //     }\n-    // }\n-\n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n         -> EvalResult<()>\n     {\n@@ -334,8 +283,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 self.memory.copy(src, dest, dest_repr.size())\n             }\n \n-            // BinaryOp(bin_op, ref left, ref right) =>\n-            //     self.eval_binary_op(lvalue, bin_op, left, right),\n+            BinaryOp(bin_op, ref left, ref right) =>\n+                self.eval_binary_op(bin_op, left, right, dest),\n \n             // UnaryOp(un_op, ref operand) => {\n             //     let ptr = try!(self.operand_to_ptr(operand));\n@@ -408,6 +357,57 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n+    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Pointer> {\n+        let frame = self.current_frame();\n+\n+        use rustc::mir::repr::Lvalue::*;\n+        let ptr = match *lvalue {\n+            ReturnPointer =>\n+                frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n+            Arg(i) => frame.arg_ptr(i),\n+            Var(i) => frame.var_ptr(i),\n+            Temp(i) => frame.temp_ptr(i),\n+            ref l => panic!(\"can't handle lvalue: {:?}\", l),\n+        };\n+\n+        Ok(ptr)\n+\n+        //     mir::Lvalue::Projection(ref proj) => {\n+        //         let base_ptr = self.lvalue_to_ptr(&proj.base);\n+\n+        //         match proj.elem {\n+        //             mir::ProjectionElem::Field(field, _) => {\n+        //                 base_ptr.offset(field.index())\n+        //             }\n+\n+        //             mir::ProjectionElem::Downcast(_, variant) => {\n+        //                 let adt_val = self.read_pointer(base_ptr);\n+        //                 if let Value::Adt { variant: actual_variant, data_ptr } = adt_val {\n+        //                     debug_assert_eq!(variant, actual_variant);\n+        //                     data_ptr\n+        //                 } else {\n+        //                     panic!(\"Downcast attempted on non-ADT: {:?}\", adt_val)\n+        //                 }\n+        //             }\n+\n+        //             mir::ProjectionElem::Deref => {\n+        //                 let ptr_val = self.read_pointer(base_ptr);\n+        //                 if let Value::Pointer(ptr) = ptr_val {\n+        //                     ptr\n+        //                 } else {\n+        //                     panic!(\"Deref attempted on non-pointer: {:?}\", ptr_val)\n+        //                 }\n+        //             }\n+\n+        //             mir::ProjectionElem::Index(ref _operand) => unimplemented!(),\n+        //             mir::ProjectionElem::ConstantIndex { .. } => unimplemented!(),\n+        //         }\n+        //     }\n+\n+        //     _ => unimplemented!(),\n+        // }\n+    }\n+\n     fn const_to_ptr(&mut self, const_val: &const_eval::ConstVal) -> EvalResult<Pointer> {\n         use rustc::middle::const_eval::ConstVal::*;\n         match *const_val {"}, {"sha": "8bba137da6c0f5a6a0bac5bdeeefa04e7df785c3", "filename": "test/new_values.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/619daf0129027fcbb526cb5beef19f470a43c6ae/test%2Fnew_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619daf0129027fcbb526cb5beef19f470a43c6ae/test%2Fnew_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fnew_values.rs?ref=619daf0129027fcbb526cb5beef19f470a43c6ae", "patch": "@@ -11,10 +11,10 @@ fn ret() -> i32 {\n //     -1\n // }\n \n-// #[miri_run]\n-// fn add() -> i32 {\n-//     1 + 2\n-// }\n+#[miri_run]\n+fn add() -> i32 {\n+    1 + 2\n+}\n \n #[miri_run]\n fn empty() {}\n@@ -34,17 +34,17 @@ fn tuple_5() -> (i32, i32, i32, i32, i32) {\n     (1, 2, 3, 4, 5)\n }\n \n-// #[miri_run]\n-// fn indirect_add() -> i32 {\n-//     let x = 1;\n-//     let y = 2;\n-//     x + y\n-// }\n+#[miri_run]\n+fn indirect_add() -> i32 {\n+    let x = 1;\n+    let y = 2;\n+    x + y\n+}\n \n-// #[miri_run]\n-// fn arith() -> i32 {\n-//     3*3 + 4*4\n-// }\n+#[miri_run]\n+fn arith() -> i32 {\n+    3*3 + 4*4\n+}\n \n #[miri_run]\n fn boolean() -> bool {"}]}