{"sha": "3c2c13bae4783c808f6640286d41cba6d9394dd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMmMxM2JhZTQ3ODNjODA4ZjY2NDAyODZkNDFjYmE2ZDkzOTRkZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T01:11:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-19T01:11:42Z"}, "message": "auto merge of #11029 : huonw/rust/rm-vec-as-buf, r=cmr\n\nFor `str.as_mut_buf`, un-closure-ification is achieved by outright removal (see commit message). The others are replaced by `.as_ptr`, `.as_mut_ptr` and `.len`", "tree": {"sha": "d3ae5a40f19d374e7c30aae661b7083172769ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3ae5a40f19d374e7c30aae661b7083172769ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c2c13bae4783c808f6640286d41cba6d9394dd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c2c13bae4783c808f6640286d41cba6d9394dd9", "html_url": "https://github.com/rust-lang/rust/commit/3c2c13bae4783c808f6640286d41cba6d9394dd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c2c13bae4783c808f6640286d41cba6d9394dd9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6933f8d8b86f78ac7b5f70f0781d794144763a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6933f8d8b86f78ac7b5f70f0781d794144763a0", "html_url": "https://github.com/rust-lang/rust/commit/b6933f8d8b86f78ac7b5f70f0781d794144763a0"}, {"sha": "b906a8b256e8e7a289bb7b0e4382f30c4bd0f431", "url": "https://api.github.com/repos/rust-lang/rust/commits/b906a8b256e8e7a289bb7b0e4382f30c4bd0f431", "html_url": "https://github.com/rust-lang/rust/commit/b906a8b256e8e7a289bb7b0e4382f30c4bd0f431"}], "stats": {"total": 662, "additions": 261, "deletions": 401}, "files": [{"sha": "1153c3a6ef300b32433d8cebc532e6df9f816cce", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -44,21 +44,18 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    bytes.as_imm_buf(|b, len| {\n-        unsafe {\n-            let mut outsz : size_t = 0;\n-            let res =\n-                rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n-                                                   len as size_t,\n-                                                   &mut outsz,\n-                                                   flags);\n-            assert!(res as int != 0);\n+    unsafe {\n+        let mut outsz : size_t = 0;\n+        let res = rustrt::tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n+                                                     bytes.len() as size_t,\n+                                                     &mut outsz,\n+                                                     flags);\n+        assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                              outsz as uint);\n-            libc::free(res);\n-            out\n-        }\n-    })\n+        libc::free(res);\n+        out\n+    }\n }\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n@@ -70,21 +67,18 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    bytes.as_imm_buf(|b, len| {\n-        unsafe {\n-            let mut outsz : size_t = 0;\n-            let res =\n-                rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n-                                                     len as size_t,\n-                                                     &mut outsz,\n-                                                     flags);\n-            assert!(res as int != 0);\n-            let out = vec::raw::from_buf_raw(res as *u8,\n-                                            outsz as uint);\n-            libc::free(res);\n-            out\n-        }\n-    })\n+    unsafe {\n+        let mut outsz : size_t = 0;\n+        let res = rustrt::tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n+                                                       bytes.len() as size_t,\n+                                                       &mut outsz,\n+                                                       flags);\n+        assert!(res as int != 0);\n+        let out = vec::raw::from_buf_raw(res as *u8,\n+                                         outsz as uint);\n+        libc::free(res);\n+        out\n+    }\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {"}, {"sha": "2e9687bb9c1f35b453fbb2d2a33a2fb6e5753b47", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -354,9 +354,7 @@ pub mod write {\n             add(*arg);\n         }\n \n-        llvm_args.as_imm_buf(|p, len| {\n-            llvm::LLVMRustSetLLVMOptions(len as c_int, p);\n-        })\n+        llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,"}, {"sha": "8e85603b31cffdc0e22c86c16ac5c4b7779fbc7d", "filename": "src/librustc/back/manifest.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fback%2Fmanifest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fback%2Fmanifest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmanifest.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -55,7 +55,7 @@ mod windows {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n-        t.as_imm_buf(|buf, _len| f(buf))\n+        f(t.as_ptr())\n     }\n \n     #[link_name = \"kernel32\"]\n@@ -86,14 +86,12 @@ mod windows {\n                 return Err(format!(\"failure in BeginUpdateResourceW: {}\", os::last_os_error()));\n             }\n \n-            let ok = manifest.as_imm_buf(|p, len| {\n-                UpdateResourceW(hUpdate,\n-                                MAKEINTRESOURCEW(24), // RT_MANIFEST\n-                                MAKEINTRESOURCEW(1),  // CREATEPROCESS_MANIFEST_RESOURCE_ID\n-                                0,                    // LANG_NEUTRAL, SUBLANG_NEUTRAL\n-                                p as LPCVOID,\n-                                len as u32)\n-            });\n+            let ok = UpdateResourceW(hUpdate,\n+                                     MAKEINTRESOURCEW(24), // RT_MANIFEST\n+                                     MAKEINTRESOURCEW(1),  // CREATEPROCESS_MANIFEST_RESOURCE_ID\n+                                     0,                    // LANG_NEUTRAL, SUBLANG_NEUTRAL\n+                                     manifest.as_ptr() as LPCVOID,\n+                                     manifest.len() as u32);\n             if ok == FALSE {\n                 return Err(format!(\"failure in UpdateResourceW: {}\", os::last_os_error()));\n             }"}, {"sha": "7ab3b4fd69eab8e1375664a7b881fc8d2abcf0ea", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -2404,9 +2404,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 (rust_main, args)\n             };\n \n-            let result = args.as_imm_buf(|buf, len| {\n-                llvm::LLVMBuildCall(bld, start_fn, buf, len as c_uint, noname())\n-            });\n+            let result = llvm::LLVMBuildCall(bld, start_fn,\n+                                             args.as_ptr(), args.len() as c_uint,\n+                                             noname());\n \n             llvm::LLVMBuildRet(bld, result);\n         }"}, {"sha": "02e2232bfc8f09f67fb41d1733685a58bc127613", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -464,11 +464,11 @@ impl Builder {\n             let min = llvm::LLVMConstInt(t, lo, signed);\n             let max = llvm::LLVMConstInt(t, hi, signed);\n \n-            [min, max].as_imm_buf(|ptr, len| {\n-                llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n-                                      llvm::LLVMMDNodeInContext(self.ccx.llcx,\n-                                                                ptr, len as c_uint));\n-            })\n+            let v = [min, max];\n+\n+            llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n+                                  llvm::LLVMMDNodeInContext(self.ccx.llcx,\n+                                                            v.as_ptr(), v.len() as c_uint));\n         }\n \n         value"}, {"sha": "e64e44695f3e97e64d49e1ec7ff0d4267131a767", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -894,9 +894,9 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = s.as_imm_buf(|buf, buflen| {\n-            llvm::LLVMConstStringInContext(cx.llcx, buf as *c_char, buflen as c_uint, False)\n-        });\n+        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n+                                                s.as_ptr() as *c_char, s.len() as c_uint,\n+                                                False);\n \n         let gsym = token::gensym(\"str\");\n         let g = format!(\"str{}\", gsym).with_c_str(|buf| {\n@@ -952,17 +952,16 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        elts.as_imm_buf(|ptr, len| {\n-            llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, packed as Bool)\n-        })\n+\n+        llvm::LLVMConstStructInContext(base::task_llcx(),\n+                                       elts.as_ptr(), elts.len() as c_uint,\n+                                       packed as Bool)\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        elts.as_imm_buf(|ptr, len| {\n-            llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n-        })\n+        llvm::LLVMConstNamedStruct(T.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n     }\n }\n \n@@ -988,9 +987,7 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = us.as_imm_buf(|p, len| {\n-            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-        });\n+        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));"}, {"sha": "5560efacfa5359f50a4ac24f8335a2960de259ab", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -646,11 +646,9 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         }\n \n         // Perform the call itself\n-        let llrust_ret_val = llrust_args.as_imm_buf(|ptr, len| {\n-            debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n-            llvm::LLVMBuildCall(builder, llrustfn, ptr,\n-                                len as c_uint, noname())\n-        });\n+        debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n+        let llrust_ret_val = llvm::LLVMBuildCall(builder, llrustfn, llrust_args.as_ptr(),\n+                                                 llrust_args.len() as c_uint, noname());\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {"}, {"sha": "513144ad73132f5f1ded439e94ed698a355e1aeb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -106,9 +106,8 @@ fn render(w: &mut io::Writer, s: &str) {\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n                                        &options as *html_renderopt as *libc::c_void);\n \n-        s.as_imm_buf(|data, len| {\n-            sd_markdown_render(ob, data, len as libc::size_t, markdown);\n-        });\n+\n+        sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n         sd_markdown_free(markdown);\n \n         vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {"}, {"sha": "9e359e26f03d6abddcb2371af62450d89f3925cb", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -70,7 +70,7 @@ impl Process {\n                     },\n                     flags: 0,\n                     stdio_count: stdio.len() as libc::c_int,\n-                    stdio: stdio.as_imm_buf(|p, _| p),\n+                    stdio: stdio.as_ptr(),\n                     uid: 0,\n                     gid: 0,\n                 };\n@@ -163,7 +163,7 @@ fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n         c_args.push(s.with_ref(|p| p));\n     }\n     c_args.push(ptr::null());\n-    c_args.as_imm_buf(|buf, _| f(buf))\n+    f(c_args.as_ptr())\n }\n \n /// Converts the environment to the env array expected by libuv\n@@ -182,7 +182,7 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n         c_envp.push(s.with_ref(|p| p));\n     }\n     c_envp.push(ptr::null());\n-    c_envp.as_imm_buf(|buf, _| f(buf))\n+    f(c_envp.as_ptr())\n }\n \n impl HomingIO for Process {"}, {"sha": "592efe6d981b128df194979d6d97d33cd8f92f6a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -267,17 +267,16 @@ impl<'a> ToCStr for &'a [u8] {\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_imm_buf(|self_buf, self_len| {\n-            let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n-            if buf.is_null() {\n-                fail!(\"failed to allocate memory!\");\n-            }\n+        let self_len = self.len();\n+        let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n+        if buf.is_null() {\n+            fail!(\"failed to allocate memory!\");\n+        }\n \n-            ptr::copy_memory(buf, self_buf, self_len);\n-            *ptr::mut_offset(buf, self_len as int) = 0;\n+        ptr::copy_memory(buf, self.as_ptr(), self_len);\n+        *ptr::mut_offset(buf, self_len as int) = 0;\n \n-            CString::new(buf as *libc::c_char, true)\n-        })\n+        CString::new(buf as *libc::c_char, true)\n     }\n \n     fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n@@ -296,13 +295,12 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n         vec::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n \n-        buf.as_mut_buf(|buf, _| {\n-            if checked {\n-                check_for_null(v, buf as *mut libc::c_char);\n-            }\n+        let buf = buf.as_mut_ptr();\n+        if checked {\n+            check_for_null(v, buf as *mut libc::c_char);\n+        }\n \n-            f(buf as *libc::c_char)\n-        })\n+        f(buf as *libc::c_char)\n     } else if checked {\n         v.to_c_str().with_ref(f)\n     } else {\n@@ -575,15 +573,14 @@ mod bench {\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n-        s.as_imm_buf(|s_buf, s_len| {\n-            for i in range(0, s_len) {\n-                unsafe {\n-                    assert_eq!(\n-                        *ptr::offset(s_buf, i as int) as libc::c_char,\n-                        *ptr::offset(c_str, i as int));\n-                }\n+        let s_buf = s.as_ptr();\n+        for i in range(0, s.len()) {\n+            unsafe {\n+                assert_eq!(\n+                    *ptr::offset(s_buf, i as int) as libc::c_char,\n+                    *ptr::offset(c_str, i as int));\n             }\n-        })\n+        }\n     }\n \n     static s_short: &'static str = \"Mary\";"}, {"sha": "74d18f11a1d60c9df0ca0fb4892a7382aef5a304", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -37,8 +37,8 @@ fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n \n-    let (data, origamt) = data.as_imm_buf(|data, amt| (data, amt));\n-    let mut data = data;\n+    let origamt = data.len();\n+    let mut data = data.as_ptr();\n     let mut amt = origamt;\n     while amt > 0 {\n         let mut ret;"}, {"sha": "ef972dc4d0ad115cc29206662fe55f70e100763e", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cast;\n use io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n@@ -17,6 +16,8 @@ use prelude::*;\n use ptr;\n use rt::rtio;\n use super::file;\n+#[cfg(windows)]\n+use cast;\n \n use p = io::process;\n \n@@ -453,7 +454,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n     // Finally, make sure we add a null pointer.\n     ptrs.push(ptr::null());\n \n-    ptrs.as_imm_buf(|buf, _| cb(buf))\n+    cb(ptrs.as_ptr())\n }\n \n #[cfg(unix)]\n@@ -476,7 +477,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n             let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n             ptrs.push(ptr::null());\n \n-            ptrs.as_imm_buf(|buf, _| unsafe { cb(cast::transmute(buf)) })\n+            cb(ptrs.as_ptr() as *c_void)\n         }\n         _ => cb(ptr::null())\n     }\n@@ -499,7 +500,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n \n             blk.push(0);\n \n-            blk.as_imm_buf(|p, _len| unsafe { cb(cast::transmute(p)) })\n+            cb(blk.as_mut_ptr() as *mut c_void)\n         }\n         _ => cb(ptr::mut_null())\n     }"}, {"sha": "5067f6eb1279b44a986ea146b968d1ebceebae32", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -436,10 +436,10 @@ mod tests {\n     #[test]\n     fn test_get_str() {\n         let x = ~\"test\";\n-        let addr_x = x.as_imm_buf(|buf, _len| buf);\n+        let addr_x = x.as_ptr();\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y = y.as_imm_buf(|buf, _len| buf);\n+        let addr_y = y.as_ptr();\n         assert_eq!(addr_x, addr_y);\n     }\n "}, {"sha": "8da7c0340f7fe04fc1411063ef33bbe092a90d75", "filename": "src/libstd/os.rs", "status": "modified", "additions": 41, "deletions": 56, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -59,29 +59,24 @@ static BUF_BYTES : uint = 2048u;\n #[cfg(unix)]\n pub fn getcwd() -> Path {\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n-    buf.as_mut_buf(|buf, len| {\n-        unsafe {\n-            if libc::getcwd(buf, len as size_t).is_null() {\n-                fail!()\n-            }\n-\n-            Path::new(CString::new(buf as *c_char, false))\n+    unsafe {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n+            fail!()\n         }\n-    })\n+        Path::new(CString::new(buf.as_ptr(), false))\n+    }\n }\n \n #[cfg(windows)]\n pub fn getcwd() -> Path {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n     let mut buf = [0 as u16, ..BUF_BYTES];\n-    buf.as_mut_buf(|buf, len| {\n-        unsafe {\n-            if libc::GetCurrentDirectoryW(len as DWORD, buf) == 0 as DWORD {\n-                fail!();\n-            }\n+    unsafe {\n+        if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n+            fail!();\n         }\n-    });\n+    }\n     Path::new(str::from_utf16(buf))\n }\n \n@@ -103,20 +98,17 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                buf.as_mut_buf(|b, _sz| {\n-                    k = f(b, TMPBUF_SZ as DWORD);\n-                    if k == (0 as DWORD) {\n-                        done = true;\n-                    } else if (k == n &&\n-                               libc::GetLastError() ==\n-                               libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n-                        n *= (2 as DWORD);\n-                    } else {\n-                        done = true;\n-                    }\n-                });\n+                let k = f(buf.as_mut_ptr(), TMPBUF_SZ as DWORD);\n+                if k == (0 as DWORD) {\n+                    done = true;\n+                } else if (k == n &&\n+                           libc::GetLastError() ==\n+                           libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n+                    n *= (2 as DWORD);\n+                } else {\n+                    done = true;\n+                }\n                 if k != 0 && done {\n                     let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n@@ -130,7 +122,7 @@ pub mod win32 {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n-        t.as_imm_buf(|buf, _len| f(buf))\n+        f(t.as_ptr())\n     }\n }\n \n@@ -363,10 +355,8 @@ pub fn self_exe_path() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = v.as_mut_buf(|buf,_| {\n-                sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                       buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n-            });\n+            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n+                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(), 0u as size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -394,9 +384,7 @@ pub fn self_exe_path() -> Option<Path> {\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = v.as_mut_buf(|buf, _| {\n-                _NSGetExecutablePath(buf as *mut i8, &mut sz)\n-            });\n+            let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n             if err != 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n             Some(v)\n@@ -628,15 +616,14 @@ pub fn last_os_error() -> ~str {\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n \n-        buf.as_mut_buf(|buf, len| {\n-            unsafe {\n-                if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n-                    fail!(\"strerror_r failure\");\n-                }\n-\n-                str::raw::from_c_str(buf as *c_char)\n+        let p = buf.as_mut_ptr();\n+        unsafe {\n+            if strerror_r(errno() as c_int, p, buf.len() as size_t) < 0 {\n+                fail!(\"strerror_r failure\");\n             }\n-        })\n+\n+            str::raw::from_c_str(p as *c_char)\n+        }\n     }\n \n     #[cfg(windows)]\n@@ -669,19 +656,17 @@ pub fn last_os_error() -> ~str {\n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n-            buf.as_mut_buf(|buf, len| {\n-                let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                         FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                         ptr::mut_null(),\n-                                         err,\n-                                         langId,\n-                                         buf,\n-                                         len as DWORD,\n-                                         ptr::null());\n-                if res == 0 {\n-                    fail!(\"[{}] FormatMessage failure\", errno());\n-                }\n-            });\n+            let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n+                                     FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                     ptr::mut_null(),\n+                                     err,\n+                                     langId,\n+                                     buf.as_mut_ptr(),\n+                                     buf.len() as DWORD,\n+                                     ptr::null());\n+            if res == 0 {\n+                fail!(\"[{}] FormatMessage failure\", errno());\n+            }\n \n             str::from_utf16(buf)\n         }"}, {"sha": "070884c078c475207e8e6d9a8ec3fb7641b40d21", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -511,10 +511,9 @@ pub mod ptr_tests {\n             \"there\".with_c_str(|p1| {\n                 \"thing\".with_c_str(|p2| {\n                     let v = ~[p0, p1, p2, null()];\n-                    v.as_imm_buf(|vp, len| {\n-                        assert_eq!(unsafe { buf_len(vp) }, 3u);\n-                        assert_eq!(len, 4u);\n-                    })\n+                    unsafe {\n+                        assert_eq!(buf_len(v.as_ptr()), 3u);\n+                    }\n                 })\n             })\n         })\n@@ -623,23 +622,21 @@ pub mod ptr_tests {\n                 one, two, three\n             ];\n \n-            arr.as_imm_buf(|arr_ptr, arr_len| {\n-                let mut ctr = 0;\n-                let mut iteration_count = 0;\n-                array_each_with_len(arr_ptr, arr_len, |e| {\n-                     let actual = str::raw::from_c_str(e);\n-                     let expected = expected_arr[ctr].with_ref(|buf| {\n-                         str::raw::from_c_str(buf)\n-                     });\n-                     debug!(\n-                         \"test_ptr_array_each_with_len e: {}, a: {}\",\n-                         expected, actual);\n-                     assert_eq!(actual, expected);\n-                     ctr += 1;\n-                     iteration_count += 1;\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n+                    let actual = str::raw::from_c_str(e);\n+                    let expected = expected_arr[ctr].with_ref(|buf| {\n+                            str::raw::from_c_str(buf)\n+                        });\n+                    debug!(\n+                        \"test_ptr_array_each_with_len e: {}, a: {}\",\n+                        expected, actual);\n+                    assert_eq!(actual, expected);\n+                    ctr += 1;\n+                    iteration_count += 1;\n                 });\n-                assert_eq!(iteration_count, 3u);\n-            })\n+            assert_eq!(iteration_count, 3u);\n         }\n     }\n \n@@ -660,23 +657,22 @@ pub mod ptr_tests {\n                 one, two, three\n             ];\n \n-            arr.as_imm_buf(|arr_ptr, _| {\n-                let mut ctr = 0;\n-                let mut iteration_count = 0;\n-                array_each(arr_ptr, |e| {\n-                     let actual = str::raw::from_c_str(e);\n-                     let expected = expected_arr[ctr].with_ref(|buf| {\n-                         str::raw::from_c_str(buf)\n-                     });\n-                     debug!(\n-                         \"test_ptr_array_each e: {}, a: {}\",\n-                         expected, actual);\n-                     assert_eq!(actual, expected);\n-                     ctr += 1;\n-                     iteration_count += 1;\n+            let arr_ptr = arr.as_ptr();\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            array_each(arr_ptr, |e| {\n+                    let actual = str::raw::from_c_str(e);\n+                    let expected = expected_arr[ctr].with_ref(|buf| {\n+                        str::raw::from_c_str(buf)\n+                    });\n+                    debug!(\n+                        \"test_ptr_array_each e: {}, a: {}\",\n+                        expected, actual);\n+                    assert_eq!(actual, expected);\n+                    ctr += 1;\n+                    iteration_count += 1;\n                 });\n-                assert_eq!(iteration_count, 3);\n-            })\n+            assert_eq!(iteration_count, 3);\n         }\n     }\n "}, {"sha": "1eaff3f51a6d775eae22f5495bbe03243d701e11", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -111,9 +111,7 @@ impl Rng for OSRng {\n                                    pbBuffer: *mut BYTE);\n         }\n \n-        v.as_mut_buf(|ptr, len| {\n-            unsafe {rust_win32_rand_gen(self.hcryptprov, len as DWORD, ptr)}\n-        })\n+        unsafe {rust_win32_rand_gen(self.hcryptprov, v.len() as DWORD, v.as_mut_ptr())}\n     }\n }\n "}, {"sha": "cd21cdeb711b720eafe1355f50550cd711aceacb", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -914,13 +914,11 @@ fn new_sched_rng() -> XorShiftRng {\n     let mut seeds = [0u32, .. 4];\n     let size = mem::size_of_val(&seeds);\n     loop {\n-        let nbytes = seeds.as_mut_buf(|buf, _| {\n-            unsafe {\n-                libc::read(fd,\n-                           buf as *mut libc::c_void,\n-                           size as libc::size_t)\n-            }\n-        });\n+        let nbytes = unsafe {\n+            libc::read(fd,\n+                       seeds.as_mut_ptr() as *mut libc::c_void,\n+                       size as libc::size_t)\n+        };\n         rtassert!(nbytes as uint == size);\n \n         if !seeds.iter().all(|x| *x == 0) {"}, {"sha": "78a09d459def21359f4a41f01db95f1ede21f5af", "filename": "src/libstd/str.rs", "status": "modified", "additions": 62, "deletions": 108, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -111,6 +111,7 @@ use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n use default::Default;\n use send_str::{SendStr, SendStrOwned};\n+use unstable::raw::Repr;\n \n /*\n Section: Conditions\n@@ -382,11 +383,7 @@ impl<'a> Iterator<(uint, char)> for CharOffsetIterator<'a> {\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n         // the original string slice and the iterator's remaining part\n-        let offset = self.string.as_imm_buf(|a, _| {\n-            self.iter.string.as_imm_buf(|b, _| {\n-                b as uint - a as uint\n-            })\n-        });\n+        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n         self.iter.next().map(|ch| (offset, ch))\n     }\n \n@@ -400,11 +397,8 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n-            let offset = self.string.as_imm_buf(|a, _| {\n-                self.iter.string.as_imm_buf(|b, len| {\n-                    b as uint - a as uint + len\n-                })\n-            });\n+            let offset = self.iter.string.len() +\n+                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n             (offset, ch)\n         })\n     }\n@@ -748,41 +742,30 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n Section: Comparing strings\n */\n \n+// share the implementation of the lang-item vs. non-lang-item\n+// eq_slice.\n+#[inline]\n+fn eq_slice_(a: &str, b: &str) -> bool {\n+    a.len() == b.len() && unsafe {\n+        libc::memcmp(a.as_ptr() as *libc::c_void,\n+                     b.as_ptr() as *libc::c_void,\n+                     a.len() as libc::size_t) == 0\n+    }\n+}\n+\n /// Bytewise slice equality\n #[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_imm_buf(|ap, alen| {\n-        b.as_imm_buf(|bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 alen as libc::size_t) == 0\n-                }\n-            }\n-        })\n-    })\n+    eq_slice_(a, b)\n }\n \n /// Bytewise slice equality\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    a.as_imm_buf(|ap, alen| {\n-        b.as_imm_buf(|bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 alen as libc::size_t) == 0\n-                }\n-            }\n-        })\n-    })\n+    eq_slice_(a, b)\n }\n \n /// Bytewise string equality\n@@ -1000,7 +983,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n-        v.as_mut_buf(|vbuf, _len| ptr::copy_memory(vbuf, buf as *u8, len));\n+        ptr::copy_memory(v.as_mut_ptr(), buf as *u8, len);\n         v.set_len(len);\n \n         assert!(is_utf8(v));\n@@ -1080,12 +1063,10 @@ pub mod raw {\n     /// Caller must check slice boundaries!\n     #[inline]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        s.as_imm_buf(|sbuf, _n| {\n-             cast::transmute(Slice {\n-                 data: sbuf.offset(begin as int),\n-                 len: end - begin,\n-             })\n-        })\n+        cast::transmute(Slice {\n+                data: s.as_ptr().offset(begin as int),\n+                len: end - begin,\n+            })\n     }\n \n     /// Appends a byte to a string.\n@@ -1309,7 +1290,7 @@ impl<'a> Str for @str {\n impl<'a> Container for &'a str {\n     #[inline]\n     fn len(&self) -> uint {\n-        self.as_imm_buf(|_p, n| n)\n+        self.repr().len\n     }\n }\n \n@@ -1997,10 +1978,12 @@ pub trait StrSlice<'a> {\n     /// ```\n     fn subslice_offset(&self, inner: &str) -> uint;\n \n-    /// Work with the byte buffer and length of a slice.\n+    /// Return an unsafe pointer to the strings buffer.\n     ///\n-    /// The buffer does not have a null terminator.\n-    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T;\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    fn as_ptr(&self) -> *u8;\n }\n \n impl<'a> StrSlice<'a> for &'a str {\n@@ -2278,15 +2261,14 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        self.as_imm_buf(|src, len| {\n-            unsafe {\n-                let mut v = vec::with_capacity(len);\n+        let len = self.len();\n+        unsafe {\n+            let mut v = vec::with_capacity(len);\n \n-                v.as_mut_buf(|dst, _| ptr::copy_memory(dst, src, len));\n-                v.set_len(len);\n-                ::cast::transmute(v)\n-            }\n-        })\n+            ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n+            v.set_len(len);\n+            ::cast::transmute(v)\n+        }\n     }\n \n     #[inline]\n@@ -2482,27 +2464,19 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n-        self.as_imm_buf(|a, a_len| {\n-            inner.as_imm_buf(|b, b_len| {\n-                let a_start: uint;\n-                let a_end: uint;\n-                let b_start: uint;\n-                let b_end: uint;\n-                unsafe {\n-                    a_start = cast::transmute(a); a_end = a_len + cast::transmute(a);\n-                    b_start = cast::transmute(b); b_end = b_len + cast::transmute(b);\n-                }\n-                assert!(a_start <= b_start);\n-                assert!(b_end <= a_end);\n-                b_start - a_start\n-            })\n-        })\n+        let a_start = self.as_ptr() as uint;\n+        let a_end = a_start + self.len();\n+        let b_start = inner.as_ptr() as uint;\n+        let b_end = b_start + inner.len();\n+\n+        assert!(a_start <= b_start);\n+        assert!(b_end <= a_end);\n+        b_start - a_start\n     }\n \n     #[inline]\n-    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T {\n-        let v: &[u8] = unsafe { cast::transmute(*self) };\n-        v.as_imm_buf(f)\n+    fn as_ptr(&self) -> *u8 {\n+        self.repr().data\n     }\n }\n \n@@ -2581,14 +2555,6 @@ pub trait OwnedStr {\n     /// The buffer does not have a null terminator.\n     fn into_bytes(self) -> ~[u8];\n \n-    /// Work with the mutable byte buffer and length of a slice.\n-    ///\n-    /// The buffer does not have a null terminator.\n-    ///\n-    /// The caller must make sure any mutations to this buffer keep the string\n-    /// valid UTF-8!\n-    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T;\n-\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n@@ -2617,16 +2583,15 @@ impl OwnedStr for ~str {\n         let cur_len = self.len();\n         // may use up to 4 bytes.\n         unsafe {\n-            raw::as_owned_vec(self).reserve_additional(4);\n+            let v = raw::as_owned_vec(self);\n+            v.reserve_additional(4);\n \n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n-            let used = self.as_mut_buf(|buf, _| {\n-                vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4, |slc| {\n-                    c.encode_utf8(slc)\n-                })\n-            });\n-            self.set_len(cur_len + used);\n+            let write_ptr = v.as_mut_ptr().offset(cur_len as int);\n+            let used = vec::raw::mut_buf_as_slice(write_ptr, 4, |slc| c.encode_utf8(slc));\n+\n+            v.set_len(cur_len + used);\n         }\n     }\n \n@@ -2694,13 +2659,6 @@ impl OwnedStr for ~str {\n         unsafe { cast::transmute(self) }\n     }\n \n-    #[inline]\n-    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T {\n-        unsafe {\n-            raw::as_owned_vec(self).as_mut_buf(f)\n-        }\n-    }\n-\n     #[inline]\n     unsafe fn set_len(&mut self, new_len: uint) {\n         raw::as_owned_vec(self).set_len(new_len)\n@@ -3390,19 +3348,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_imm_buf() {\n-        \"\".as_imm_buf(|_, len| assert_eq!(len, 0));\n-\n-        \"hello\".as_imm_buf(|buf, len| {\n-            assert_eq!(len, 5);\n-            unsafe {\n-                assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n-                assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n-                assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n-                assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n-                assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n-            }\n-        })\n+    fn test_as_ptr() {\n+        let buf = \"hello\".as_ptr();\n+        unsafe {\n+            assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n+            assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n+            assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n+            assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n+            assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+        }\n     }\n \n     #[test]\n@@ -3935,10 +3889,10 @@ mod tests {\n         assert_eq!(s.as_slice(), \"\");\n \n         let mut s = ~\"12345\";\n-        let p = s.as_imm_buf(|p,_| p);\n+        let p = s.as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n-        let p_ = s.as_imm_buf(|p,_| p);\n+        let p_ = s.as_ptr();\n         assert_eq!(p_, p);\n     }\n "}, {"sha": "ad0d8861ee9c4e7e9b477327526858536bc71606", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 26, "deletions": 78, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -775,15 +775,15 @@ impl<'a, T> Container for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        self.as_imm_buf(|_p, len| len)\n+        self.repr().len\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        self.as_imm_buf(|_p, len| len)\n+        self.repr().len\n     }\n }\n \n@@ -984,14 +984,6 @@ pub trait ImmutableVector<'a, T> {\n     /// of a vector and return the results.\n     fn map<U>(&self, |t: &T| -> U) -> ~[U];\n \n-    /**\n-     * Work with the buffer of a vector.\n-     *\n-     * Allows for unsafe manipulation of vector contents, which is useful for\n-     * foreign interop.\n-     */\n-    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U;\n-\n     /**\n      * Returns a mutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -1032,14 +1024,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     fn slice(&self, start: uint, end: uint) -> &'a [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        self.as_imm_buf(|p, _len| {\n-            unsafe {\n-                cast::transmute(Slice {\n-                    data: ptr::offset(p, start as int),\n+        unsafe {\n+            cast::transmute(Slice {\n+                    data: self.as_ptr().offset(start as int),\n                     len: (end - start)\n                 })\n-            }\n-        })\n+        }\n     }\n \n     #[inline]\n@@ -1197,12 +1187,6 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         self.iter().map(f).collect()\n     }\n \n-    #[inline]\n-    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U {\n-        let s = self.repr();\n-        f(s.data, s.len)\n-    }\n-\n     fn shift_ref(&mut self) -> &'a T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n@@ -1697,15 +1681,16 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.pop()\n     }\n     fn truncate(&mut self, newlen: uint) {\n-        self.as_mut_buf(|p, oldlen| {\n-            assert!(newlen <= oldlen);\n-            unsafe {\n-                // This loop is optimized out for non-drop types.\n-                for i in range(newlen, oldlen) {\n-                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i as int));\n-                }\n+        let oldlen = self.len();\n+        assert!(newlen <= oldlen);\n+\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            // This loop is optimized out for non-drop types.\n+            for i in range(newlen, oldlen) {\n+                ptr::read_and_zero_ptr(p.offset(i as int));\n             }\n-        });\n+        }\n         unsafe { self.set_len(newlen); }\n     }\n \n@@ -2069,24 +2054,19 @@ pub trait MutableVector<'a, T> {\n     /// `self` and `src` must not overlap. Fails if `self` is\n     /// shorter than `src`.\n     unsafe fn copy_memory(self, src: &[T]);\n-\n-    /// Similar to `as_imm_buf` but passing a `*mut T`\n-    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n \n impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n     fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        self.as_mut_buf(|p, _len| {\n-            unsafe {\n-                cast::transmute(Slice {\n-                    data: ptr::mut_offset(p, start as int) as *T,\n+        unsafe {\n+            cast::transmute(Slice {\n+                    data: self.as_mut_ptr().offset(start as int) as *T,\n                     len: (end - start)\n                 })\n-            }\n-        })\n+        }\n     }\n \n     #[inline]\n@@ -2205,18 +2185,9 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n \n     #[inline]\n     unsafe fn copy_memory(self, src: &[T]) {\n-        self.as_mut_buf(|p_dst, len_dst| {\n-            src.as_imm_buf(|p_src, len_src| {\n-                assert!(len_dst >= len_src)\n-                ptr::copy_nonoverlapping_memory(p_dst, p_src, len_src)\n-            })\n-        })\n-    }\n-\n-    #[inline]\n-    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U {\n-        let Slice{ data, len } = self.repr();\n-        f(data as *mut T, len)\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n     }\n }\n \n@@ -2300,7 +2271,7 @@ pub mod raw {\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n         dst.set_len(elts);\n-        dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n+        ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n@@ -2332,6 +2303,7 @@ pub mod raw {\n \n /// Operations on `[u8]`.\n pub mod bytes {\n+    use container::Container;\n     use vec::MutableVector;\n     use ptr;\n \n@@ -2344,9 +2316,7 @@ pub mod bytes {\n     impl<'a> MutableByteVector for &'a mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            self.as_mut_buf(|p, len| {\n-                unsafe { ptr::set_memory(p, value, len) };\n-            })\n+            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n         }\n     }\n \n@@ -2368,11 +2338,7 @@ pub mod bytes {\n         let old_len = dst.len();\n         dst.reserve_additional(src.len());\n         unsafe {\n-            dst.as_mut_buf(|p_dst, len_dst| {\n-                src.as_imm_buf(|p_src, len_src| {\n-                    ptr::copy_memory(p_dst.offset(len_dst as int), p_src, len_src)\n-                })\n-            });\n+            ptr::copy_memory(dst.as_mut_ptr().offset(old_len as int), src.as_ptr(), src.len());\n             dst.set_len(old_len + src.len());\n         }\n     }\n@@ -3553,24 +3519,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_as_imm_buf_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        v.as_imm_buf(|_buf, _i| {\n-            fail!()\n-        })\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_as_mut_buf_fail() {\n-        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        v.as_mut_buf(|_buf, _i| {\n-            fail!()\n-        })\n-    }\n-\n     #[test]\n     #[should_fail]\n     fn test_copy_memory_oob() {"}, {"sha": "932b9a0d4510656d042b309ee12b34cac45c5abf", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c2c13bae4783c808f6640286d41cba6d9394dd9/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=3c2c13bae4783c808f6640286d41cba6d9394dd9", "patch": "@@ -21,16 +21,15 @@ fn main() {\n     // huge).\n \n     let x = ~[1u,2u,3u];\n-    x.as_imm_buf(|p, _len| {\n-        let base = p as uint;\n-        let idx = base / mem::size_of::<uint>();\n-        error!(\"ov1 base = 0x{:x}\", base);\n-        error!(\"ov1 idx = 0x{:x}\", idx);\n-        error!(\"ov1 sizeof::<uint>() = 0x{:x}\", mem::size_of::<uint>());\n-        error!(\"ov1 idx * sizeof::<uint>() = 0x{:x}\",\n-               idx * mem::size_of::<uint>());\n \n-        // This should fail.\n-        error!(\"ov1 0x{:x}\",  x[idx]);\n-    })\n+    let base = x.as_ptr() as uint;\n+    let idx = base / mem::size_of::<uint>();\n+    error!(\"ov1 base = 0x{:x}\", base);\n+    error!(\"ov1 idx = 0x{:x}\", idx);\n+    error!(\"ov1 sizeof::<uint>() = 0x{:x}\", mem::size_of::<uint>());\n+    error!(\"ov1 idx * sizeof::<uint>() = 0x{:x}\",\n+           idx * mem::size_of::<uint>());\n+\n+    // This should fail.\n+    error!(\"ov1 0x{:x}\",  x[idx]);\n }"}]}