{"sha": "496b68d485698ae230be5a06aadf5fbbbcc0fd83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NmI2OGQ0ODU2OThhZTIzMGJlNWEwNmFhZGY1ZmJiYmNjMGZkODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-29T01:03:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-29T01:03:06Z"}, "message": "auto merge of #17533 : michaelwoerister/rust/function-call-locs, r=luqmana\n\nThis PR makes rustc emit debug locations for *all* call and invoke statements in LLVM IR, if they are contained within a function that debuginfo is enabled for. This is important because LLVM does not handle the case where a function body containing debuginfo is inlined into another function with debuginfo, but the inlined call statement does not have a debug location. In this case, LLVM will not know where (in terms of source code coordinates) the function was inlined to and we end up with some statements still linked to the source locations in there original, non-inlined function without any indication that they are indeed an inline-copy. Later, when generating DWARF from the IR, LLVM will interpret this as corrupt IR and abort.\r\n\r\nUnfortunately, the undesirable case described above can still occur when using LTO. If there is a crate compiled without debuginfo calling into a crate compiled with debuginfo, we again end up with the conditions triggering the error. This is why some LTO tests still fail with the dreaded assertion, if the standard library was built with debuginfo enabled. That is, `RUSTFLAGS_STAGE2=-g make rustc-stage2` will succeed but `RUSTFLAGS_STAGE2=-g make check` will still fail after this PR has been merged. I will open a separate issue for this problem.", "tree": {"sha": "07756d8d0a2cf0ee4ceb561dd1525c3319394894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07756d8d0a2cf0ee4ceb561dd1525c3319394894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/496b68d485698ae230be5a06aadf5fbbbcc0fd83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/496b68d485698ae230be5a06aadf5fbbbcc0fd83", "html_url": "https://github.com/rust-lang/rust/commit/496b68d485698ae230be5a06aadf5fbbbcc0fd83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/496b68d485698ae230be5a06aadf5fbbbcc0fd83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7aa03a3caab2f15f32dcdb20b23510707ba47f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7aa03a3caab2f15f32dcdb20b23510707ba47f8", "html_url": "https://github.com/rust-lang/rust/commit/b7aa03a3caab2f15f32dcdb20b23510707ba47f8"}, {"sha": "302486e49bca590347d018665c339c512168da08", "url": "https://api.github.com/repos/rust-lang/rust/commits/302486e49bca590347d018665c339c512168da08", "html_url": "https://github.com/rust-lang/rust/commit/302486e49bca590347d018665c339c512168da08"}], "stats": {"total": 357, "additions": 284, "deletions": 73}, "files": [{"sha": "03045777155d411c6c13af4438d9fb58d61c8488", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -1791,7 +1791,7 @@ pub fn trans_closure(ccx: &CrateContext,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n                      param_substs: &param_substs,\n-                     id: ast::NodeId,\n+                     fn_ast_id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      arg_types: Vec<ty::t>,\n                      output_type: ty::t,\n@@ -1811,7 +1811,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx,\n                           llfndecl,\n-                          id,\n+                          fn_ast_id,\n                           has_env,\n                           output_type,\n                           param_substs,\n@@ -1820,7 +1820,9 @@ pub fn trans_closure(ccx: &CrateContext,\n     let mut bcx = init_function(&fcx, false, output_type);\n \n     // cleanup scope for the incoming arguments\n-    let arg_scope = fcx.push_custom_cleanup_scope();\n+    let fn_cleanup_debug_loc =\n+        debuginfo::get_cleanup_debug_loc_for_ast_node(fn_ast_id, body.span, true);\n+    let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n \n     let block_ty = node_id_type(bcx, body.id);\n \n@@ -1969,7 +1971,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  ctor_ty: ty::t,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n-                                                 dest: expr::Dest) -> Result<'blk, 'tcx> {\n+                                                 dest: expr::Dest,\n+                                                 call_info: Option<NodeInfo>)\n+                                                 -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n     let tcx = ccx.tcx();\n@@ -1999,8 +2003,13 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         match args {\n             callee::ArgExprs(exprs) => {\n                 let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n-                bcx = expr::trans_adt(bcx, result_ty, disr, fields.as_slice(),\n-                                      None, expr::SaveIn(llresult));\n+                bcx = expr::trans_adt(bcx,\n+                                      result_ty,\n+                                      disr,\n+                                      fields.as_slice(),\n+                                      None,\n+                                      expr::SaveIn(llresult),\n+                                      call_info);\n             }\n             _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n         }\n@@ -2010,7 +2019,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // drop the temporary we made\n     let bcx = match dest {\n         expr::SaveIn(_) => bcx,\n-        expr::Ignore => glue::drop_ty(bcx, llresult, result_ty)\n+        expr::Ignore => {\n+            glue::drop_ty(bcx, llresult, result_ty, call_info)\n+        }\n     };\n \n     Result::new(bcx, llresult)"}, {"sha": "5962bee023abcd7ca6c9e6477e04167db9926d75", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -714,8 +714,12 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             fcx.pop_custom_cleanup_scope(arg_cleanup_scope);\n \n             let ctor_ty = callee_ty.subst(bcx.tcx(), &substs);\n-            return base::trans_named_tuple_constructor(bcx, ctor_ty, disr,\n-                                                       args, dest.unwrap());\n+            return base::trans_named_tuple_constructor(bcx,\n+                                                       ctor_ty,\n+                                                       disr,\n+                                                       args,\n+                                                       dest.unwrap(),\n+                                                       call_info);\n         }\n     };\n \n@@ -835,7 +839,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match (dest, opt_llretslot) {\n         (Some(expr::Ignore), Some(llretslot)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+            bcx = glue::drop_ty(bcx, llretslot, ret_ty, call_info);\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}"}, {"sha": "35464be0e43125e8aaea5f49da8b1768b9e02326", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 96, "deletions": 24, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -18,7 +18,8 @@ use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n use middle::trans::common;\n-use middle::trans::common::{Block, FunctionContext, ExprId};\n+use middle::trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n+use middle::trans::debuginfo;\n use middle::trans::glue;\n use middle::trans::type_::Type;\n use middle::ty;\n@@ -36,6 +37,10 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     // Cleanups to run upon scope exit.\n     cleanups: Vec<CleanupObj>,\n \n+    // The debug location any drop calls generated for this scope will be\n+    // associated with.\n+    debug_loc: Option<NodeInfo>,\n+\n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n@@ -69,7 +74,10 @@ pub struct CachedEarlyExit {\n pub trait Cleanup {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n-    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx>;\n+    fn trans<'blk, 'tcx>(&self,\n+                         bcx: Block<'blk, 'tcx>,\n+                         debug_loc: Option<NodeInfo>)\n+                      -> Block<'blk, 'tcx>;\n }\n \n pub type CleanupObj = Box<Cleanup+'static>;\n@@ -80,14 +88,14 @@ pub enum ScopeId {\n }\n \n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: ast::NodeId) {\n+    fn push_ast_cleanup_scope(&self, debug_loc: NodeInfo) {\n         /*!\n          * Invoked when we start to trans the code contained\n          * within a new cleanup scope.\n          */\n \n         debug!(\"push_ast_cleanup_scope({})\",\n-               self.ccx.tcx().map.node_to_string(id));\n+               self.ccx.tcx().map.node_to_string(debug_loc.id));\n \n         // FIXME(#2202) -- currently closure bodies have a parent\n         // region, which messes up the assertion below, since there\n@@ -101,10 +109,15 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n-            assert_eq!(self.ccx.tcx().region_maps.opt_encl_scope(id), top_scope);\n+            assert_eq!(self.ccx\n+                           .tcx()\n+                           .region_maps\n+                           .opt_encl_scope(debug_loc.id),\n+                       top_scope);\n         }\n \n-        self.push_scope(CleanupScope::new(AstScopeKind(id)));\n+        self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n+                                          Some(debug_loc)));\n     }\n \n     fn push_loop_cleanup_scope(&self,\n@@ -114,13 +127,38 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                self.ccx.tcx().map.node_to_string(id));\n         assert_eq!(Some(id), self.top_ast_scope());\n \n-        self.push_scope(CleanupScope::new(LoopScopeKind(id, exits)));\n+        // Just copy the debuginfo source location from the enclosing scope\n+        let debug_loc = self.scopes\n+                            .borrow()\n+                            .last()\n+                            .unwrap()\n+                            .debug_loc;\n+\n+        self.push_scope(CleanupScope::new(LoopScopeKind(id, exits), debug_loc));\n     }\n \n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n-        self.push_scope(CleanupScope::new(CustomScopeKind));\n+\n+        // Just copy the debuginfo source location from the enclosing scope\n+        let debug_loc = self.scopes\n+                            .borrow()\n+                            .last()\n+                            .map(|opt_scope| opt_scope.debug_loc)\n+                            .unwrap_or(None);\n+\n+        self.push_scope(CleanupScope::new(CustomScopeKind, debug_loc));\n+        CustomScopeIndex { index: index }\n+    }\n+\n+    fn push_custom_cleanup_scope_with_debug_loc(&self,\n+                                                debug_loc: NodeInfo)\n+                                                -> CustomScopeIndex {\n+        let index = self.scopes_len();\n+        debug!(\"push_custom_cleanup_scope(): {}\", index);\n+\n+        self.push_scope(CleanupScope::new(CustomScopeKind, Some(debug_loc)));\n         CustomScopeIndex { index: index }\n     }\n \n@@ -141,7 +179,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         let scope = self.pop_scope();\n         self.trans_scope_cleanups(bcx, &scope)\n-\n     }\n \n     fn pop_loop_cleanup_scope(&self,\n@@ -175,9 +212,9 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     }\n \n     fn pop_and_trans_custom_cleanup_scope(&self,\n-                                        bcx: Block<'blk, 'tcx>,\n-                                        custom_scope: CustomScopeIndex)\n-                                        -> Block<'blk, 'tcx> {\n+                                          bcx: Block<'blk, 'tcx>,\n+                                          custom_scope: CustomScopeIndex)\n+                                          -> Block<'blk, 'tcx> {\n         /*!\n          * Removes the top cleanup scope from the stack, which must be\n          * a temporary scope, and generates the code to do its\n@@ -503,7 +540,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         let mut bcx = bcx;\n         if !bcx.unreachable.get() {\n             for cleanup in scope.cleanups.iter().rev() {\n-                bcx = cleanup.trans(bcx);\n+                bcx = cleanup.trans(bcx, scope.debug_loc);\n             }\n         }\n         bcx\n@@ -671,7 +708,8 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n                     if cleanup_is_suitable_for(&**cleanup, label) {\n-                        bcx_out = cleanup.trans(bcx_out);\n+                        bcx_out = cleanup.trans(bcx_out,\n+                                                scope.debug_loc);\n                     }\n                 }\n                 build::Br(bcx_out, prev_llbb);\n@@ -785,9 +823,12 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n }\n \n impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n-    fn new(kind: CleanupScopeKind<'blk, 'tcx>) -> CleanupScope<'blk, 'tcx> {\n+    fn new(kind: CleanupScopeKind<'blk, 'tcx>,\n+           debug_loc: Option<NodeInfo>)\n+        -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n+            debug_loc: debug_loc,\n             cleanups: vec!(),\n             cached_early_exits: vec!(),\n             cached_landing_pad: None,\n@@ -902,11 +943,14 @@ impl Cleanup for DropValue {\n         self.must_unwind\n     }\n \n-    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n+    fn trans<'blk, 'tcx>(&self,\n+                         bcx: Block<'blk, 'tcx>,\n+                         debug_loc: Option<NodeInfo>)\n+                         -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty)\n+            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n         } else {\n-            glue::drop_ty(bcx, self.val, self.ty)\n+            glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n         };\n         if self.zero {\n             base::zero_mem(bcx, self.val, self.ty);\n@@ -935,7 +979,12 @@ impl Cleanup for FreeValue {\n         true\n     }\n \n-    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n+    fn trans<'blk, 'tcx>(&self,\n+                         bcx: Block<'blk, 'tcx>,\n+                         debug_loc: Option<NodeInfo>)\n+                      -> Block<'blk, 'tcx> {\n+        apply_debug_loc(bcx.fcx, debug_loc);\n+\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -963,7 +1012,12 @@ impl Cleanup for FreeSlice {\n         true\n     }\n \n-    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n+    fn trans<'blk, 'tcx>(&self,\n+                         bcx: Block<'blk, 'tcx>,\n+                         debug_loc: Option<NodeInfo>)\n+                      -> Block<'blk, 'tcx> {\n+        apply_debug_loc(bcx.fcx, debug_loc);\n+\n         match self.heap {\n             HeapManaged => {\n                 glue::trans_free(bcx, self.ptr)\n@@ -988,7 +1042,11 @@ impl Cleanup for LifetimeEnd {\n         true\n     }\n \n-    fn trans<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n+    fn trans<'blk, 'tcx>(&self,\n+                         bcx: Block<'blk, 'tcx>,\n+                         debug_loc: Option<NodeInfo>)\n+                      -> Block<'blk, 'tcx> {\n+        apply_debug_loc(bcx.fcx, debug_loc);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1023,15 +1081,29 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n     !label.is_unwind() || c.clean_on_unwind()\n }\n \n+fn apply_debug_loc(fcx: &FunctionContext, debug_loc: Option<NodeInfo>) {\n+    match debug_loc {\n+        Some(ref src_loc) => {\n+            debuginfo::set_source_location(fcx, src_loc.id, src_loc.span);\n+        }\n+        None => {\n+            debuginfo::clear_source_location(fcx);\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n pub trait CleanupMethods<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: ast::NodeId);\n+    fn push_ast_cleanup_scope(&self, id: NodeInfo);\n     fn push_loop_cleanup_scope(&self,\n-                                   id: ast::NodeId,\n-                                   exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);\n+                               id: ast::NodeId,\n+                               exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n+    fn push_custom_cleanup_scope_with_debug_loc(&self,\n+                                                debug_loc: NodeInfo)\n+                                                -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n                                               bcx: Block<'blk, 'tcx>,\n                                               cleanup_scope: ast::NodeId)"}, {"sha": "424007519af1ad93feb0cb6aa12b40f52c7571dc", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -22,6 +22,7 @@ use middle::trans::cleanup;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::datum;\n+use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::meth;\n use middle::trans::type_::Type;\n@@ -53,7 +54,9 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let mut bcx = cx;\n \n     let id = ast_util::stmt_id(s);\n-    fcx.push_ast_cleanup_scope(id);\n+    let cleanup_debug_loc =\n+        debuginfo::get_cleanup_debug_loc_for_ast_node(id, s.span, false);\n+    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n     match s.node {\n         ast::StmtExpr(ref e, _) | ast::StmtSemi(ref e, _) => {\n@@ -75,8 +78,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n     }\n \n-    bcx = fcx.pop_and_trans_ast_cleanup_scope(\n-        bcx, ast_util::stmt_id(s));\n+    bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, ast_util::stmt_id(s));\n \n     return bcx;\n }\n@@ -100,7 +102,9 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n-    fcx.push_ast_cleanup_scope(b.id);\n+    let cleanup_debug_loc =\n+        debuginfo::get_cleanup_debug_loc_for_ast_node(b.id, b.span, true);\n+    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n     for s in b.stmts.iter() {\n         bcx = trans_stmt(bcx, &**s);"}, {"sha": "7a0e5aea7fffc90873080de035f44d9f64a5cc53", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 69, "deletions": 9, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -1030,6 +1030,55 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     })\n }\n \n+pub fn get_cleanup_debug_loc_for_ast_node(node_id: ast::NodeId,\n+                                          node_span: Span,\n+                                          is_block: bool)\n+                                          -> NodeInfo {\n+    // A debug location needs two things:\n+    // (1) A span (of which only the beginning will actually be used)\n+    // (2) An AST node-id which will be used to look up the lexical scope\n+    //     for the location in the functions scope-map\n+    //\n+    // This function will calculate the debug location for compiler-generated\n+    // cleanup calls that are executed when control-flow leaves the\n+    // scope identified by `node_id`.\n+    //\n+    // For everything but block-like things we can simply take id and span of\n+    // the given expression, meaning that from a debugger's view cleanup code is\n+    // executed at the same source location as the statement/expr itself.\n+    //\n+    // Blocks are a special case. Here we want the cleanup to be linked to the\n+    // closing curly brace of the block. The *scope* the cleanup is executed in\n+    // is up to debate: It could either still be *within* the block being\n+    // cleaned up, meaning that locals from the block are still visible in the\n+    // debugger.\n+    // Or it could be in the scope that the block is contained in, so any locals\n+    // from within the block are already considered out-of-scope and thus not\n+    // accessible in the debugger anymore.\n+    //\n+    // The current implementation opts for the second option: cleanup of a block\n+    // already happens in the parent scope of the block. The main reason for\n+    // this decision is that scoping becomes controlflow dependent when variable\n+    // shadowing is involved and it's impossible to decide statically which\n+    // scope is actually left when the cleanup code is executed.\n+    // In practice it shouldn't make much of a difference.\n+\n+    let cleanup_span = if is_block {\n+        Span {\n+            lo: node_span.hi - codemap::BytePos(1), // closing brace should always be 1 byte...\n+            hi: node_span.hi,\n+            expn_id: node_span.expn_id\n+        }\n+    } else {\n+        node_span\n+    };\n+\n+    NodeInfo {\n+        id: node_id,\n+        span: cleanup_span\n+    }\n+}\n+\n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n@@ -1107,7 +1156,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // Do this here already, in case we do an early exit from this function.\n     set_debug_location(cx, UnknownLocation);\n \n-    if fn_ast_id == -1 {\n+    if fn_ast_id == ast::DUMMY_NODE_ID {\n+        // This is a function not linked to any source location, so don't\n+        // generate debuginfo for it.\n         return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n@@ -1289,6 +1340,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                        fn_decl.inputs.as_slice(),\n                        &*top_level_block,\n                        fn_metadata,\n+                       fn_ast_id,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n     return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n@@ -1297,7 +1349,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::FnDecl,\n                               param_substs: &param_substs,\n-                              error_span: Span) -> DIArray {\n+                              error_reporting_span: Span) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), []);\n         }\n@@ -1310,7 +1362,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 signature.push(ptr::null_mut());\n             }\n             _ => {\n-                assert_type_for_node_id(cx, fn_ast_id, error_span);\n+                assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n \n                 let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n                 let return_type = return_type.substp(cx.tcx(), param_substs);\n@@ -1634,15 +1686,17 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n /// Finds the scope metadata node for the given AST node.\n fn scope_metadata(fcx: &FunctionContext,\n                   node_id: ast::NodeId,\n-                  span: Span)\n+                  error_reporting_span: Span)\n                -> DIScope {\n-    let scope_map = &fcx.debug_context.get_ref(fcx.ccx, span).scope_map;\n+    let scope_map = &fcx.debug_context\n+                        .get_ref(fcx.ccx, error_reporting_span)\n+                        .scope_map;\n     match scope_map.borrow().find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n         None => {\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n-            fcx.ccx.sess().span_bug(span,\n+            fcx.ccx.sess().span_bug(error_reporting_span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\",\n                         node).as_slice());\n         }\n@@ -3139,9 +3193,12 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     }\n }\n \n-fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n+fn assert_type_for_node_id(cx: &CrateContext,\n+                           node_id: ast::NodeId,\n+                           error_reporting_span: Span) {\n     if !cx.tcx().node_types.borrow().contains_key(&(node_id as uint)) {\n-        cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n+        cx.sess().span_bug(error_reporting_span,\n+                           \"debuginfo: Could not find type for node id!\");\n     }\n }\n \n@@ -3169,6 +3226,7 @@ fn populate_scope_map(cx: &CrateContext,\n                       args: &[ast::Arg],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n+                      fn_ast_id: ast::NodeId,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n     let def_map = &cx.tcx().def_map;\n \n@@ -3179,13 +3237,15 @@ fn populate_scope_map(cx: &CrateContext,\n \n     let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                  ident: None });\n+    scope_map.insert(fn_ast_id, fn_metadata);\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args.iter() {\n-        pat_util::pat_bindings(def_map, &*arg.pat, |_, _, _, path1| {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                ident: Some(path1.node) });\n+            scope_map.insert(node_id, fn_metadata);\n         })\n     }\n "}, {"sha": "120e8404f2c67502671aa2be8fdd383d4c5e698b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -119,10 +119,13 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n \n-    bcx.fcx.push_ast_cleanup_scope(expr.id);\n+    let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(expr.id,\n+                                                                          expr.span,\n+                                                                          false);\n+    bcx.fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n     let kind = ty::expr_kind(bcx.tcx(), expr);\n     bcx = match kind {\n         ty::LvalueExpr | ty::RvalueDatumExpr => {\n@@ -154,7 +157,10 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n \n-    fcx.push_ast_cleanup_scope(expr.id);\n+    let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(expr.id,\n+                                                                          expr.span,\n+                                                                          false);\n+    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n     let datum = unpack_datum!(bcx, trans_unadjusted(bcx, expr));\n     let datum = unpack_datum!(bcx, apply_adjustments(bcx, expr, datum));\n     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n@@ -644,7 +650,9 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match x.node {\n                 ast::ExprRepeat(..) | ast::ExprVec(..) => {\n                     // Special case for slices.\n-                    fcx.push_ast_cleanup_scope(x.id);\n+                    let cleanup_debug_loc =\n+                        debuginfo::get_cleanup_debug_loc_for_ast_node(x.id, x.span, false);\n+                    fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n                     let datum = unpack_datum!(\n                         bcx, tvec::trans_slice_vec(bcx, expr, &**x));\n                     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n@@ -908,6 +916,8 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return bcx;\n     }\n \n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+\n     match expr.node {\n         ast::ExprParen(ref e) => {\n             trans_into(bcx, &**e, Ignore)\n@@ -954,10 +964,14 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 //\n                 // We could avoid this intermediary with some analysis\n                 // to determine whether `dst` may possibly own `src`.\n+                debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n                 let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n-                bcx = glue::drop_ty(bcx, dst_datum.val, dst_datum.ty);\n+                bcx = glue::drop_ty(bcx,\n+                                    dst_datum.val,\n+                                    dst_datum.ty,\n+                                    Some(NodeInfo { id: expr.id, span: expr.span }));\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 trans_into(bcx, &**src, SaveIn(dst_datum.to_llref()))\n@@ -987,6 +1001,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n \n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+\n     match expr.node {\n         ast::ExprParen(ref e) => {\n             trans_into(bcx, &**e, dest)\n@@ -1014,7 +1030,13 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprTup(ref args) => {\n             let numbered_fields: Vec<(uint, &ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n-            trans_adt(bcx, expr_ty(bcx, expr), 0, numbered_fields.as_slice(), None, dest)\n+            trans_adt(bcx,\n+                      expr_ty(bcx, expr),\n+                      0,\n+                      numbered_fields.as_slice(),\n+                      None,\n+                      dest,\n+                      Some(NodeInfo { id: expr.id, span: expr.span }))\n         }\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n@@ -1297,15 +1319,15 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n \n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[ast::Field],\n-                       base: Option<&ast::Expr>,\n+                            base: Option<&ast::Expr>,\n                             expr_span: codemap::Span,\n-                            id: ast::NodeId,\n+                            expr_id: ast::NodeId,\n                             dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rec\");\n \n-    let ty = node_id_type(bcx, id);\n+    let ty = node_id_type(bcx, expr_id);\n     let tcx = bcx.tcx();\n-    with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n+    with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n         let mut need_base = Vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = fields.iter().map(|field| {\n@@ -1342,7 +1364,13 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         };\n \n-        trans_adt(bcx, ty, discr, numbered_fields.as_slice(), optbase, dest)\n+        trans_adt(bcx,\n+                  ty,\n+                  discr,\n+                  numbered_fields.as_slice(),\n+                  optbase,\n+                  dest,\n+                  Some(NodeInfo { id: expr_id, span: expr_span }))\n     })\n }\n \n@@ -1376,11 +1404,20 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              discr: ty::Disr,\n                              fields: &[(uint, &ast::Expr)],\n                              optbase: Option<StructBaseInfo>,\n-                             dest: Dest) -> Block<'blk, 'tcx> {\n+                             dest: Dest,\n+                             source_location: Option<NodeInfo>)\n+                          -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n \n+    match source_location {\n+        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n+                                                        src_loc.id,\n+                                                        src_loc.span),\n+        None => {}\n+    };\n+\n     // If we don't care about the result, just make a\n     // temporary stack slot\n     let addr = match dest {\n@@ -1414,6 +1451,13 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n+    match source_location {\n+        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n+                                                        src_loc.id,\n+                                                        src_loc.span),\n+        None => {}\n+    };\n+\n     // Now, we just overwrite the fields we've explicitly specified\n     for &(i, ref e) in fields.iter() {\n         let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n@@ -1432,7 +1476,7 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match dest {\n         SaveIn(_) => bcx,\n         Ignore => {\n-            bcx = glue::drop_ty(bcx, addr, ty);\n+            bcx = glue::drop_ty(bcx, addr, ty, source_location);\n             base::call_lifetime_end(bcx, addr);\n             bcx\n         }"}, {"sha": "c8cc89ca66a2066804227c8a5f6aff913f34c207", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -28,6 +28,7 @@ use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::datum;\n+use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n@@ -125,7 +126,10 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n     }\n }\n \n-pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           v: ValueRef,\n+                           t: ty::t,\n+                           source_location: Option<NodeInfo>)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n@@ -139,17 +143,26 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n         } else {\n             v\n         };\n+\n+        match source_location {\n+            Some(sl) => debuginfo::set_source_location(bcx.fcx, sl.id, sl.span),\n+            None => debuginfo::clear_source_location(bcx.fcx)\n+        };\n+\n         Call(bcx, glue, [ptr], None);\n     }\n     bcx\n }\n \n-pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v: ValueRef, t: ty::t)\n+pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     v: ValueRef,\n+                                     t: ty::t,\n+                                     source_location: Option<NodeInfo>)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     Store(bcx, v, vp);\n-    drop_ty(bcx, vp, t)\n+    drop_ty(bcx, vp, t, source_location)\n }\n \n pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n@@ -464,7 +477,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty);\n+                        let bcx = drop_ty(bcx, v0, content_ty, None);\n                         let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n@@ -477,7 +490,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty);\n+                        let bcx = drop_ty(bcx, llbox, content_ty, None);\n                         trans_exchange_free_ty(bcx, llbox, content_ty)\n                     })\n                 }\n@@ -508,11 +521,14 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n                 }\n                 ty::NoDtor => {\n                     // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, drop_ty)\n+                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx, v0, t, drop_ty),\n+        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx,\n+                                                         v0,\n+                                                         t,\n+                                                         |bb, vv, tt| drop_ty(bb, vv, tt, None)),\n         ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n@@ -544,7 +560,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n             assert!(ty::type_is_sized(bcx.tcx(), t));\n             if ty::type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n-                iter_structural_ty(bcx, v0, t, drop_ty)\n+                iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n             } else {\n                 bcx\n             }\n@@ -574,7 +590,7 @@ fn decr_refcnt_maybe_free<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v = Load(free_bcx, box_ptr_ptr);\n     let body = GEPi(free_bcx, v, [0u, abi::box_field_body]);\n-    let free_bcx = drop_ty(free_bcx, body, t);\n+    let free_bcx = drop_ty(free_bcx, body, t, None);\n     let free_bcx = trans_free(free_bcx, v);\n     Br(free_bcx, next_bcx.llbb);\n "}, {"sha": "628971775ae8ce42fcf2ef9d38ca3bc748838ce4", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -541,7 +541,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n     // If we made a temporary stack slot, let's clean it up\n     match dest {\n         expr::Ignore => {\n-            bcx = glue::drop_ty(bcx, llresult, ret_ty);\n+            bcx = glue::drop_ty(bcx, llresult, ret_ty, Some(call_info));\n         }\n         expr::SaveIn(_) => {}\n     }"}, {"sha": "848e59e2a60d8dff822bb5d63e01b27c0fe6ed33", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -64,7 +64,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let dataptr = get_dataptr(bcx, vptr);\n         let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n             let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx, dataptr, unit_ty, len, glue::drop_ty)\n+            iter_vec_raw(bcx, dataptr, unit_ty, len, |bb, vv, tt| glue::drop_ty(bb, vv, tt, None))\n         } else {\n             bcx\n         };"}, {"sha": "dae14a1be2b156ef2108c9d82d9f49761ce10d38", "filename": "src/test/debuginfo/borrowed-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496b68d485698ae230be5a06aadf5fbbbcc0fd83/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-basic.rs?ref=496b68d485698ae230be5a06aadf5fbbbcc0fd83", "patch": "@@ -130,8 +130,8 @@ fn main() {\n     let i32_val: i32 = -32;\n     let i32_ref: &i32 = &i32_val;\n \n-    let uint_val: i64 = -64;\n-    let i64_ref: &i64 = &uint_val;\n+    let i64_val: i64 = -64;\n+    let i64_ref: &i64 = &i64_val;\n \n     let uint_val: uint = 1;\n     let uint_ref: &uint = &uint_val;"}]}