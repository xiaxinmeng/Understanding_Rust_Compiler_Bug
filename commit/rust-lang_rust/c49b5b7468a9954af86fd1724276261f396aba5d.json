{"sha": "c49b5b7468a9954af86fd1724276261f396aba5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OWI1Yjc0NjhhOTk1NGFmODZmZDE3MjQyNzYyNjFmMzk2YWJhNWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-16T13:14:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-16T13:14:48Z"}, "message": "Merge #7498\n\n7498: Clone for update r=matklad a=matklad\n\nrowan counterpart https://github.com/rust-analyzer/rowan/pull/93\r\n\r\n#6857\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f9b9126cd0cc9a2829de3cdb20f681b354fbe67b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9b9126cd0cc9a2829de3cdb20f681b354fbe67b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c49b5b7468a9954af86fd1724276261f396aba5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUK9ICRBK7hj4Ov3rIwAAdHIIAF2xd/yu2bZ6j5KV9xu/5Vw+\nYsq/Mrz3GITd/VRyLl/TwnwdbfaomUnap9lQfPOFnz/63Rq1oljkvBDs9TzZf5Wb\n2/t/ZZ1OWbbvZzaGOxD2UmiLDGKNw3DQS6xdAqwDPeutw1CM3P0BqxBB3kZJvPPb\nap9gLidl5RYO9Ieu6Qld4/uNPj/sTHA04QmPY07+BtWniR5t3n6uUHCpMDQOt+8j\n7wY7LD5k3EK7eRV+T6Vi8sWHd6qzgsTKO1n8/l+p5/JoK+tvTR5/HsVAYiMLIFEq\nkuO2QDROjVpiJw2HoFrwt1mKlBhz0yZDZuz8Q9aXJtNxOaUf4YapcROUnRv8ljA=\n=44oC\n-----END PGP SIGNATURE-----\n", "payload": "tree f9b9126cd0cc9a2829de3cdb20f681b354fbe67b\nparent 1a82af3527e476d52410ff4dfd2fb4c57466abcb\nparent f5a81ec4683613bd62624811733345d627f2127b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615900488 +0000\ncommitter GitHub <noreply@github.com> 1615900488 +0000\n\nMerge #7498\n\n7498: Clone for update r=matklad a=matklad\n\nrowan counterpart https://github.com/rust-analyzer/rowan/pull/93\r\n\r\n#6857\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c49b5b7468a9954af86fd1724276261f396aba5d", "html_url": "https://github.com/rust-lang/rust/commit/c49b5b7468a9954af86fd1724276261f396aba5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c49b5b7468a9954af86fd1724276261f396aba5d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a82af3527e476d52410ff4dfd2fb4c57466abcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a82af3527e476d52410ff4dfd2fb4c57466abcb", "html_url": "https://github.com/rust-lang/rust/commit/1a82af3527e476d52410ff4dfd2fb4c57466abcb"}, {"sha": "f5a81ec4683613bd62624811733345d627f2127b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a81ec4683613bd62624811733345d627f2127b", "html_url": "https://github.com/rust-lang/rust/commit/f5a81ec4683613bd62624811733345d627f2127b"}], "stats": {"total": 550, "additions": 375, "deletions": 175}, "files": [{"sha": "b99c243a4765773e70d782469f177712809bd0c8", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -1,7 +1,5 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n-version = 3\n-\n [[package]]\n name = \"addr2line\"\n version = \"0.14.1\"\n@@ -1326,9 +1324,9 @@ checksum = \"b5eb417147ba9860a96cfe72a0b93bf88fee1744b5636ec99ab20c1aa9376581\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.12.6\"\n+version = \"0.13.0-pre.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1b36e449f3702f3b0c821411db1cbdf30fb451726a9456dce5dabcd44420043\"\n+checksum = \"8f300be7fa17c3fa563d2bc6ab5b1a8d5163162f9111599eda4f86a563714724\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\","}, {"sha": "03c9371b5ed5f1f9844c74d5eed9c121354258b6", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -143,6 +143,12 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.diagnostics_display_range(diagnostics)\n     }\n \n+    pub fn token_ancestors_with_macros(\n+        &self,\n+        token: SyntaxToken,\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        token.parent().into_iter().flat_map(move |it| self.ancestors_with_macros(it))\n+    }\n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         self.imp.ancestors_with_macros(node)\n     }\n@@ -270,8 +276,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.scope(node)\n     }\n \n-    pub fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n-        self.imp.scope_at_offset(node, offset)\n+    pub fn scope_at_offset(&self, token: &SyntaxToken, offset: TextSize) -> SemanticsScope<'db> {\n+        self.imp.scope_at_offset(&token.parent().unwrap(), offset)\n     }\n \n     pub fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n@@ -341,7 +347,10 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n         let _p = profile::span(\"descend_into_macros\");\n-        let parent = token.parent();\n+        let parent = match token.parent() {\n+            Some(it) => it,\n+            None => return token,\n+        };\n         let sa = self.analyze(&parent);\n \n         let token = successors(Some(InFile::new(sa.file_id, token)), |token| {\n@@ -360,7 +369,9 @@ impl<'db> SemanticsImpl<'db> {\n                 .as_ref()?\n                 .map_token_down(token.as_ref())?;\n \n-            self.cache(find_root(&token.value.parent()), token.file_id);\n+            if let Some(parent) = token.value.parent() {\n+                self.cache(find_root(&parent), token.file_id);\n+            }\n \n             Some(token)\n         })\n@@ -378,7 +389,7 @@ impl<'db> SemanticsImpl<'db> {\n         // Handle macro token cases\n         node.token_at_offset(offset)\n             .map(|token| self.descend_into_macros(token))\n-            .map(|it| self.ancestors_with_macros(it.parent()))\n+            .map(|it| self.token_ancestors_with_macros(it))\n             .flatten()\n     }\n \n@@ -394,6 +405,13 @@ impl<'db> SemanticsImpl<'db> {\n         src.with_value(&node).original_file_range(self.db.upcast())\n     }\n \n+    fn token_ancestors_with_macros(\n+        &self,\n+        token: SyntaxToken,\n+    ) -> impl Iterator<Item = SyntaxNode> + '_ {\n+        token.parent().into_iter().flat_map(move |parent| self.ancestors_with_macros(parent))\n+    }\n+\n     fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         let node = self.find_file(node);\n         node.ancestors_with_macros(self.db.upcast()).map(|it| it.value)\n@@ -405,7 +423,7 @@ impl<'db> SemanticsImpl<'db> {\n         offset: TextSize,\n     ) -> impl Iterator<Item = SyntaxNode> + '_ {\n         node.token_at_offset(offset)\n-            .map(|token| self.ancestors_with_macros(token.parent()))\n+            .map(|token| self.token_ancestors_with_macros(token))\n             .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n     }\n "}, {"sha": "eee430af135c396a842da56a4518f4a38c6c9379", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -510,7 +510,10 @@ impl InFile<SyntaxToken> {\n         self,\n         db: &dyn db::AstDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n-        self.map(|it| it.parent()).ancestors_with_macros(db)\n+        self.value\n+            .parent()\n+            .into_iter()\n+            .flat_map(move |parent| InFile::new(self.file_id, parent).ancestors_with_macros(db))\n     }\n }\n "}, {"sha": "96021f677f58959120c1fa49372b07206ea1bf7e", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -53,10 +53,8 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n         for (r_range, _) in references {\n             let token = file.token_at_offset(r_range.start()).next()?;\n             let token = sema.descend_into_macros(token);\n-            let syntax = token.parent();\n-\n             // This target is the containing function\n-            if let Some(nav) = syntax.ancestors().find_map(|node| {\n+            if let Some(nav) = token.ancestors().find_map(|node| {\n                 let fn_ = ast::Fn::cast(node)?;\n                 let def = sema.to_def(&fn_)?;\n                 def.try_to_nav(sema.db)\n@@ -77,12 +75,13 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     let file = file.syntax();\n     let token = file.token_at_offset(position.offset).next()?;\n     let token = sema.descend_into_macros(token);\n-    let syntax = token.parent();\n \n     let mut calls = CallLocations::default();\n \n-    syntax\n-        .descendants()\n+    token\n+        .parent()\n+        .into_iter()\n+        .flat_map(|it| it.descendants())\n         .filter_map(|node| FnCallNode::with_node_exact(&node))\n         .filter_map(|call_node| {\n             let name_ref = call_node.name_ref()?;"}, {"sha": "461e110605df1a47119fb308f6cd145609f3d1d3", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -279,7 +279,7 @@ pub(crate) fn external_docs(\n     let token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(token);\n \n-    let node = token.parent();\n+    let node = token.parent()?;\n     let definition = match_ast! {\n         match node {\n             ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),"}, {"sha": "e187243cbf9b38b16d9a5d9456eed88b8cc611b9", "filename": "crates/ide/src/extend_selection.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fextend_selection.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -88,7 +88,7 @@ fn try_extend_selection(\n                     return Some(range);\n                 }\n             }\n-            token.parent()\n+            token.parent()?\n         }\n         NodeOrToken::Node(node) => node,\n     };\n@@ -142,7 +142,8 @@ fn extend_tokens_from_range(\n     let extended = {\n         let fst_expanded = sema.descend_into_macros(first_token.clone());\n         let lst_expanded = sema.descend_into_macros(last_token.clone());\n-        let mut lca = algo::least_common_ancestor(&fst_expanded.parent(), &lst_expanded.parent())?;\n+        let mut lca =\n+            algo::least_common_ancestor(&fst_expanded.parent()?, &lst_expanded.parent()?)?;\n         lca = shallowest_node(&lca);\n         if lca.first_token() == Some(fst_expanded) && lca.last_token() == Some(lst_expanded) {\n             lca = lca.parent()?;\n@@ -151,9 +152,13 @@ fn extend_tokens_from_range(\n     };\n \n     // Compute parent node range\n-    let validate = |token: &SyntaxToken| {\n+    let validate = |token: &SyntaxToken| -> bool {\n         let expanded = sema.descend_into_macros(token.clone());\n-        algo::least_common_ancestor(&extended, &expanded.parent()).as_ref() == Some(&extended)\n+        let parent = match expanded.parent() {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+        algo::least_common_ancestor(&extended, &parent).as_ref() == Some(&extended)\n     };\n \n     // Find the first and last text range under expanded parent"}, {"sha": "6986477a586f6435987cc3c2ef7e90858f790d30", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn goto_definition(\n     let file = sema.parse(position.file_id).syntax().clone();\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = sema.descend_into_macros(original_token.clone());\n-    let parent = token.parent();\n+    let parent = token.parent()?;\n     if let Some(comment) = ast::Comment::cast(token) {\n         let nav = def_for_doc_comment(&sema, position, &comment)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n@@ -63,7 +63,7 @@ fn def_for_doc_comment(\n     position: FilePosition,\n     doc_comment: &ast::Comment,\n ) -> Option<hir::ModuleDef> {\n-    let parent = doc_comment.syntax().parent();\n+    let parent = doc_comment.syntax().parent()?;\n     let (link, ns) = extract_positioned_link_from_comment(position, doc_comment)?;\n \n     let def = doc_owner_to_def(sema, parent)?;"}, {"sha": "2d38cb1128c30bc8ce9d973fbe12730fd7e170f6", "filename": "crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn goto_type_definition(\n     let token: SyntaxToken = pick_best(file.syntax().token_at_offset(position.offset))?;\n     let token: SyntaxToken = sema.descend_into_macros(token);\n \n-    let (ty, node) = sema.ancestors_with_macros(token.parent()).find_map(|node| {\n+    let (ty, node) = sema.token_ancestors_with_macros(token).find_map(|node| {\n         let ty = match_ast! {\n             match node {\n                 ast::Expr(it) => sema.type_of_expr(&it)?,"}, {"sha": "8d45b4875004ced0654f8b0121e31d9deba1de16", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn hover(\n \n     let mut res = HoverResult::default();\n \n-    let node = token.parent();\n+    let node = token.parent()?;\n     let definition = match_ast! {\n         match node {\n             // we don't use NameClass::referenced_or_defined here as we do not want to resolve\n@@ -421,7 +421,7 @@ fn hover_for_keyword(\n     if !token.kind().is_keyword() {\n         return None;\n     }\n-    let famous_defs = FamousDefs(&sema, sema.scope(&token.parent()).krate());\n+    let famous_defs = FamousDefs(&sema, sema.scope(&token.parent()?).krate());\n     // std exposes {}_keyword modules with docstrings on the root to document keywords\n     let keyword_mod = format!(\"{}_keyword\", token.text());\n     let doc_owner = find_std_module(&famous_defs, &keyword_mod)?;"}, {"sha": "4b25135cdb9272016b8593bdb3c081650076c076", "filename": "crates/ide/src/join_lines.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -32,29 +32,35 @@ pub(crate) fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n         range\n     };\n \n-    let node = match file.syntax().covering_element(range) {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n     let mut edit = TextEdit::builder();\n-    for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {\n-        let range = match range.intersect(token.text_range()) {\n-            Some(range) => range,\n-            None => continue,\n-        } - token.text_range().start();\n-        let text = token.text();\n-        for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n-            let pos: TextSize = (pos as u32).into();\n-            let offset = token.text_range().start() + range.start() + pos;\n-            if !edit.invalidates_offset(offset) {\n-                remove_newline(&mut edit, &token, offset);\n+    match file.syntax().covering_element(range) {\n+        NodeOrToken::Node(node) => {\n+            for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {\n+                remove_newlines(&mut edit, &token, range)\n             }\n         }\n-    }\n-\n+        NodeOrToken::Token(token) => remove_newlines(&mut edit, &token, range),\n+    };\n     edit.finish()\n }\n \n+fn remove_newlines(edit: &mut TextEditBuilder, token: &SyntaxToken, range: TextRange) {\n+    let intersection = match range.intersect(token.text_range()) {\n+        Some(range) => range,\n+        None => return,\n+    };\n+\n+    let range = intersection - token.text_range().start();\n+    let text = token.text();\n+    for (pos, _) in text[range].bytes().enumerate().filter(|&(_, b)| b == b'\\n') {\n+        let pos: TextSize = (pos as u32).into();\n+        let offset = token.text_range().start() + range.start() + pos;\n+        if !edit.invalidates_offset(offset) {\n+            remove_newline(edit, &token, offset);\n+        }\n+    }\n+}\n+\n fn remove_newline(edit: &mut TextEditBuilder, token: &SyntaxToken, offset: TextSize) {\n     if token.kind() != WHITESPACE || token.text().bytes().filter(|&b| b == b'\\n').count() != 1 {\n         let mut string_open_quote = false;\n@@ -148,7 +154,7 @@ fn has_comma_after(node: &SyntaxNode) -> bool {\n }\n \n fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n-    let block_expr = ast::BlockExpr::cast(token.parent())?;\n+    let block_expr = ast::BlockExpr::cast(token.parent()?)?;\n     if !block_expr.is_standalone() {\n         return None;\n     }\n@@ -170,7 +176,7 @@ fn join_single_expr_block(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Op\n }\n \n fn join_single_use_tree(edit: &mut TextEditBuilder, token: &SyntaxToken) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(token.parent())?;\n+    let use_tree_list = ast::UseTreeList::cast(token.parent()?)?;\n     let (tree,) = use_tree_list.use_trees().collect_tuple()?;\n     edit.replace(use_tree_list.syntax().text_range(), tree.syntax().text().to_string());\n     Some(())"}, {"sha": "4241a6dac965254d647e131f59ec42a9f5bb851c", "filename": "crates/ide/src/matching_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmatching_brace.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -25,7 +25,7 @@ pub(crate) fn matching_brace(file: &SourceFile, offset: TextSize) -> Option<Text\n             Some((node, idx))\n         })\n         .next()?;\n-    let parent = brace_token.parent();\n+    let parent = brace_token.parent()?;\n     if brace_token.kind() == T![|] && !ast::ParamList::can_cast(parent.kind()) {\n         cov_mark::hit!(pipes_not_braces);\n         return None;"}, {"sha": "e8a5666bc16b3c6f8a0b0499a2c4f32a121e547a", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -148,14 +148,15 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n \n fn get_name_of_item_declaration(syntax: &SyntaxNode, position: FilePosition) -> Option<ast::Name> {\n     let token = syntax.token_at_offset(position.offset).right_biased()?;\n+    let token_parent = token.parent()?;\n     let kind = token.kind();\n     if kind == T![;] {\n-        ast::Struct::cast(token.parent())\n+        ast::Struct::cast(token_parent)\n             .filter(|struct_| struct_.field_list().is_none())\n             .and_then(|struct_| struct_.name())\n     } else if kind == T!['{'] {\n         match_ast! {\n-            match (token.parent()) {\n+            match token_parent {\n                 ast::RecordFieldList(rfl) => match_ast! {\n                     match (rfl.syntax().parent()?) {\n                         ast::Variant(it) => it.name(),\n@@ -169,7 +170,7 @@ fn get_name_of_item_declaration(syntax: &SyntaxNode, position: FilePosition) ->\n             }\n         }\n     } else if kind == T!['('] {\n-        let tfl = ast::TupleFieldList::cast(token.parent())?;\n+        let tfl = ast::TupleFieldList::cast(token_parent)?;\n         match_ast! {\n             match (tfl.syntax().parent()?) {\n                 ast::Variant(it) => it.name(),"}, {"sha": "397e2126b86bdb56e384ae3c6a89ce137bc49b75", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -167,8 +167,7 @@ fn find_related_tests(\n             let functions = refs.iter().filter_map(|(range, _)| {\n                 let token = file.token_at_offset(range.start()).next()?;\n                 let token = sema.descend_into_macros(token);\n-                let syntax = token.parent();\n-                syntax.ancestors().find_map(ast::Fn::cast)\n+                token.ancestors().find_map(ast::Fn::cast)\n             });\n \n             for fn_def in functions {"}, {"sha": "870146d24fae22319efa15ef4deed3f4e4be0c33", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn highlight(\n             Some(range) => {\n                 let node = match source_file.syntax().covering_element(range) {\n                     NodeOrToken::Node(it) => it,\n-                    NodeOrToken::Token(it) => it.parent(),\n+                    NodeOrToken::Token(it) => it.parent().unwrap(),\n                 };\n                 (node, range)\n             }\n@@ -167,16 +167,19 @@ fn traverse(\n         let element_to_highlight = if current_macro_call.is_some() && element.kind() != COMMENT {\n             // Inside a macro -- expand it first\n             let token = match element.clone().into_token() {\n-                Some(it) if it.parent().kind() == TOKEN_TREE => it,\n+                Some(it) if it.parent().map_or(false, |it| it.kind() == TOKEN_TREE) => it,\n                 _ => continue,\n             };\n             let token = sema.descend_into_macros(token.clone());\n-            let parent = token.parent();\n-\n-            // We only care Name and Name_ref\n-            match (token.kind(), parent.kind()) {\n-                (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n-                _ => token.into(),\n+            match token.parent() {\n+                Some(parent) => {\n+                    // We only care Name and Name_ref\n+                    match (token.kind(), parent.kind()) {\n+                        (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n+                        _ => token.into(),\n+                    }\n+                }\n+                None => token.into(),\n             }\n         } else {\n             element.clone()"}, {"sha": "e503abc93a40cf158601d21bf63975f8085ad190", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -28,7 +28,7 @@ pub(super) fn highlight_format_string(\n }\n \n fn is_format_string(string: &ast::String) -> Option<()> {\n-    let parent = string.syntax().parent();\n+    let parent = string.syntax().parent()?;\n \n     let name = parent.parent().and_then(ast::MacroCall::cast)?.path()?.segment()?.name_ref()?;\n     if !matches!(name.text(), \"format_args\" | \"format_args_nl\") {"}, {"sha": "8979de5287adf9e95e9ef93f089d56079aca4102", "filename": "crates/ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_tree.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn syntax_tree(\n                 if let Some(tree) = syntax_tree_for_string(&token, text_range) {\n                     return tree;\n                 }\n-                token.parent()\n+                token.parent().unwrap()\n             }\n         };\n "}, {"sha": "e10b7d98e33ba04a25b8c62cb8ebb142d78919aa", "filename": "crates/ide/src/typing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -108,7 +108,7 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     };\n     let current_indent_len = TextSize::of(current_indent);\n \n-    let parent = whitespace.syntax().parent();\n+    let parent = whitespace.syntax().parent()?;\n     // Make sure dot is a part of call chain\n     if !matches!(parent.kind(), FIELD_EXPR | METHOD_CALL_EXPR) {\n         return None;"}, {"sha": "436767895404d26986df095081d6b4be7a52b691", "filename": "crates/ide_assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         cov_mark::hit!(add_turbo_fish_one_fish_is_enough);\n         return None;\n     }\n-    let name_ref = ast::NameRef::cast(ident.parent())?;\n+    let name_ref = ast::NameRef::cast(ident.parent()?)?;\n     let def = match NameRefClass::classify(&ctx.sema, &name_ref)? {\n         NameRefClass::Definition(def) => def,\n         NameRefClass::ExternCrate(_) | NameRefClass::FieldShorthand { .. } => return None,"}, {"sha": "d7e39b2aecd88a987924917dcb6a84058f80d787", "filename": "crates/ide_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -41,7 +41,7 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     });\n \n     let (offset, target) = if let Some(keyword) = item_keyword {\n-        let parent = keyword.parent();\n+        let parent = keyword.parent()?;\n         let def_kws = vec![CONST, STATIC, TYPE_ALIAS, FN, MODULE, STRUCT, ENUM, TRAIT];\n         // Parent is not a definition, can't add visibility\n         if !def_kws.iter().any(|&def_kw| def_kw == parent.kind()) {"}, {"sha": "5b540df5ce570d851dbc9aca840dfdfb656be462", "filename": "crates/ide_assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -48,7 +48,7 @@ pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Opti\n         _ => return None,\n     };\n \n-    let current_scope = ctx.sema.scope(&star.parent());\n+    let current_scope = ctx.sema.scope(&star.parent()?);\n     let current_module = current_scope.module()?;\n \n     let refs_in_target = find_refs_in_mod(ctx, target_module, Some(current_module))?;"}, {"sha": "5fdc8bf387b428a86aa36588fe7be9bf03399347", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -16,7 +16,6 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    SyntaxElement,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n@@ -62,7 +61,10 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         return None;\n     }\n \n-    let node = element_to_node(node);\n+    let node = match node {\n+        syntax::NodeOrToken::Node(n) => n,\n+        syntax::NodeOrToken::Token(t) => t.parent()?,\n+    };\n \n     let body = extraction_target(&node, ctx.frange.range)?;\n \n@@ -560,14 +562,6 @@ impl HasTokenAtOffset for FunctionBody {\n     }\n }\n \n-/// node or token's parent\n-fn element_to_node(node: SyntaxElement) -> SyntaxNode {\n-    match node {\n-        syntax::NodeOrToken::Node(n) => n,\n-        syntax::NodeOrToken::Token(t) => t.parent(),\n-    }\n-}\n-\n /// Try to guess what user wants to extract\n ///\n /// We have basically have two cases:\n@@ -1246,7 +1240,7 @@ fn make_body(\n             })\n         }\n         FlowHandler::If { .. } => {\n-            let lit_false = ast::Literal::cast(make::tokens::literal(\"false\").parent()).unwrap();\n+            let lit_false = make::expr_literal(\"false\");\n             with_tail_expr(block, lit_false.into())\n         }\n         FlowHandler::IfOption { .. } => {\n@@ -1420,9 +1414,7 @@ fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> S\n fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Option<ast::Expr> {\n     let value = match handler {\n         FlowHandler::None | FlowHandler::Try { .. } => return None,\n-        FlowHandler::If { .. } => {\n-            ast::Literal::cast(make::tokens::literal(\"true\").parent()).unwrap().into()\n-        }\n+        FlowHandler::If { .. } => make::expr_literal(\"true\").into(),\n         FlowHandler::IfOption { .. } => {\n             let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n             let args = make::arg_list(iter::once(expr));"}, {"sha": "a868aa43d6d0251a396965c83898f5e8cf7e8bed", "filename": "crates/ide_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let plus = ctx.find_token_syntax_at_offset(T![+])?;\n \n     // Make sure we're in a `TypeBoundList`\n-    if ast::TypeBoundList::cast(plus.parent()).is_none() {\n+    if ast::TypeBoundList::cast(plus.parent()?).is_none() {\n         return None;\n     }\n "}, {"sha": "53612ec3f4bcb9d6c22d9bea4654597f4ef723fc", "filename": "crates/ide_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -30,7 +30,7 @@ use crate::{\n \n pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_syntax_at_offset(T![if])?;\n-    let expr = ast::IfExpr::cast(if_keyword.parent())?;\n+    let expr = ast::IfExpr::cast(if_keyword.parent()?)?;\n     let if_range = if_keyword.text_range();\n     let cursor_in_range = if_range.contains_range(ctx.frange.range);\n     if !cursor_in_range {"}, {"sha": "48efa67ed71723affdca5ebd089d753f988c8942", "filename": "crates/ide_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 21, "deletions": 41, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -1,8 +1,6 @@\n use syntax::{\n-    ast::{self, edit::AstNodeEdit, make, AstNode, NameOwner, TypeBoundsOwner},\n+    ast::{self, edit_in_place::GenericParamsOwnerEdit, make, AstNode, NameOwner, TypeBoundsOwner},\n     match_ast,\n-    SyntaxKind::*,\n-    T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -23,61 +21,43 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n // ```\n pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let type_param_list = ctx.find_node_at_offset::<ast::GenericParamList>()?;\n+    let type_param_list = ctx.find_node_at_offset::<ast::GenericParamList>()?.clone_for_update();\n \n     let mut type_params = type_param_list.type_params();\n     if type_params.all(|p| p.type_bound_list().is_none()) {\n         return None;\n     }\n \n     let parent = type_param_list.syntax().parent()?;\n-    if parent.children_with_tokens().any(|it| it.kind() == WHERE_CLAUSE) {\n-        return None;\n-    }\n-\n-    let anchor = match_ast! {\n-        match parent {\n-            ast::Fn(it) => it.body()?.syntax().clone().into(),\n-            ast::Trait(it) => it.assoc_item_list()?.syntax().clone().into(),\n-            ast::Impl(it) => it.assoc_item_list()?.syntax().clone().into(),\n-            ast::Enum(it) => it.variant_list()?.syntax().clone().into(),\n-            ast::Struct(it) => {\n-                it.syntax().children_with_tokens()\n-                    .find(|it| it.kind() == RECORD_FIELD_LIST || it.kind() == T![;])?\n-            },\n-            _ => return None\n-        }\n-    };\n+    let original_parent_range = parent.text_range();\n \n     let target = type_param_list.syntax().text_range();\n     acc.add(\n         AssistId(\"move_bounds_to_where_clause\", AssistKind::RefactorRewrite),\n         \"Move to where clause\",\n         target,\n         |edit| {\n-            let new_params = type_param_list\n-                .type_params()\n-                .filter(|it| it.type_bound_list().is_some())\n-                .map(|type_param| {\n-                    let without_bounds = type_param.remove_bounds();\n-                    (type_param, without_bounds)\n-                });\n-\n-            let new_type_param_list = type_param_list.replace_descendants(new_params);\n-            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-            let where_clause = {\n-                let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                make::where_clause(predicates)\n+            let where_clause: ast::WhereClause = match_ast! {\n+                match parent {\n+                    ast::Fn(it) => it.get_or_create_where_clause(),\n+                    // ast::Trait(it) => it.get_or_create_where_clause(),\n+                    ast::Impl(it) => it.get_or_create_where_clause(),\n+                    // ast::Enum(it) => it.get_or_create_where_clause(),\n+                    ast::Struct(it) => it.get_or_create_where_clause(),\n+                    _ => return,\n+                }\n             };\n \n-            let to_insert = match anchor.prev_sibling_or_token() {\n-                Some(ref elem) if elem.kind() == WHITESPACE => {\n-                    format!(\"{} \", where_clause.syntax())\n+            for type_param in type_param_list.type_params() {\n+                if let Some(tbl) = type_param.type_bound_list() {\n+                    if let Some(predicate) = build_predicate(type_param.clone()) {\n+                        where_clause.add_predicate(predicate.clone_for_update())\n+                    }\n+                    tbl.remove()\n                 }\n-                _ => format!(\" {}\", where_clause.syntax()),\n-            };\n-            edit.insert(anchor.text_range().start(), to_insert);\n+            }\n+\n+            edit.replace(original_parent_range, parent.to_string())\n         },\n     )\n }"}, {"sha": "446f305444e9d8c037c10515a00436d39d8f3e58", "filename": "crates/ide_assists/src/handlers/split_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -17,7 +17,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let colon_colon = ctx.find_token_syntax_at_offset(T![::])?;\n-    let path = ast::Path::cast(colon_colon.parent())?.qualifier()?;\n+    let path = ast::Path::cast(colon_colon.parent()?)?.qualifier()?;\n     let top_path = successors(Some(path.clone()), |it| it.parent_path()).last()?;\n \n     let use_tree = top_path.syntax().ancestors().find_map(ast::UseTree::cast)?;"}, {"sha": "440639322d48a7a0f5dc72fd3d916a5f5f04b0cb", "filename": "crates/ide_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let assist_label = \"Unwrap block\";\n \n     let l_curly_token = ctx.find_token_syntax_at_offset(T!['{'])?;\n-    let mut block = ast::BlockExpr::cast(l_curly_token.parent())?;\n+    let mut block = ast::BlockExpr::cast(l_curly_token.parent()?)?;\n     let target = block.syntax().text_range();\n     let mut parent = block.syntax().parent()?;\n     if ast::MatchArm::can_cast(parent.kind()) {"}, {"sha": "0ea55848936cd02c38eb3495d12cb69d00afa46d", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -33,7 +33,7 @@ pub(crate) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n         });\n     };\n \n-    for node in ctx.token.parent().ancestors() {\n+    for node in ctx.token.ancestors() {\n         match_ast! {\n             match node {\n                 ast::SourceFile(it) => it.items().filter_map(|item| match item {"}, {"sha": "a26fe7c6cb906051fafec7060692e482968a5f13", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -82,13 +82,14 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n \n fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, SyntaxNode, Impl)> {\n     let mut token = ctx.token.clone();\n-    // For keywork without name like `impl .. { fn $0 }`, the current position is inside\n+    // For keyword without name like `impl .. { fn $0 }`, the current position is inside\n     // the whitespace token, which is outside `FN` syntax node.\n     // We need to follow the previous token in this case.\n     if token.kind() == SyntaxKind::WHITESPACE {\n         token = token.prev_token()?;\n     }\n \n+    let parent_kind = token.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n     let impl_item_offset = match token.kind() {\n         // `impl .. { const $0 }`\n         // ERROR      0\n@@ -102,14 +103,14 @@ fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, Synt\n         // FN/TYPE_ALIAS/CONST  1\n         //  NAME                0\n         //    IDENT             <- *\n-        SyntaxKind::IDENT if token.parent().kind() == SyntaxKind::NAME => 1,\n+        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n         // `impl .. { foo$0 }`\n         // MACRO_CALL       3\n         //  PATH            2\n         //    PATH_SEGMENT  1\n         //      NAME_REF    0\n         //        IDENT     <- *\n-        SyntaxKind::IDENT if token.parent().kind() == SyntaxKind::NAME_REF => 3,\n+        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n         _ => return None,\n     };\n "}, {"sha": "8cbbdb4775ffc7db7b1382164e965be1c2d6bc82", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -120,7 +120,7 @@ impl<'a> CompletionContext<'a> {\n         let original_token =\n             original_file.syntax().token_at_offset(position.offset).left_biased()?;\n         let token = sema.descend_into_macros(original_token.clone());\n-        let scope = sema.scope_at_offset(&token.parent(), position.offset);\n+        let scope = sema.scope_at_offset(&token, position.offset);\n         let mut locals = vec![];\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n@@ -281,7 +281,7 @@ impl<'a> CompletionContext<'a> {\n     fn fill_impl_def(&mut self) {\n         self.impl_def = self\n             .sema\n-            .ancestors_with_macros(self.token.parent())\n+            .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Impl::cast);\n     }\n@@ -293,7 +293,10 @@ impl<'a> CompletionContext<'a> {\n         offset: TextSize,\n     ) {\n         let expected = {\n-            let mut node = self.token.parent();\n+            let mut node = match self.token.parent() {\n+                Some(it) => it,\n+                None => return,\n+            };\n             loop {\n                 let ret = match_ast! {\n                     match node {\n@@ -474,17 +477,17 @@ impl<'a> CompletionContext<'a> {\n         }\n \n         self.use_item_syntax =\n-            self.sema.ancestors_with_macros(self.token.parent()).find_map(ast::Use::cast);\n+            self.sema.token_ancestors_with_macros(self.token.clone()).find_map(ast::Use::cast);\n \n         self.function_syntax = self\n             .sema\n-            .ancestors_with_macros(self.token.parent())\n+            .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Fn::cast);\n \n         self.record_field_syntax = self\n             .sema\n-            .ancestors_with_macros(self.token.parent())\n+            .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| {\n                 it.kind() != SOURCE_FILE && it.kind() != MODULE && it.kind() != CALL_EXPR\n             })"}, {"sha": "cf5ef07b726fa8e987a27884e5028844fd96ec2f", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -184,11 +184,7 @@ fn test_has_impl_as_prev_sibling() {\n }\n \n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n-    let leaf = match element {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-    for node in leaf.ancestors() {\n+    for node in element.ancestors() {\n         if node.kind() == FN || node.kind() == CLOSURE_EXPR {\n             break;\n         }\n@@ -201,7 +197,7 @@ pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n             }\n         };\n         if let Some(body) = loop_body {\n-            if body.syntax().text_range().contains_range(leaf.text_range()) {\n+            if body.syntax().text_range().contains_range(element.text_range()) {\n                 return true;\n             }\n         }\n@@ -235,12 +231,8 @@ fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<Syntax\n         Some(sibling)\n     } else {\n         // if not trying to find first ancestor which has such a sibling\n-        let node = match element {\n-            NodeOrToken::Node(node) => node,\n-            NodeOrToken::Token(token) => token.parent(),\n-        };\n-        let range = node.text_range();\n-        let top_node = node.ancestors().take_while(|it| it.text_range() == range).last()?;\n+        let range = element.text_range();\n+        let top_node = element.ancestors().take_while(|it| it.text_range() == range).last()?;\n         let prev_sibling_node = top_node.ancestors().find(|it| {\n             non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n         })?;"}, {"sha": "d4016973c668c1c7ca8a3ecb284fd9f811b2f4bd", "filename": "crates/ide_db/src/call_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_db%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -109,7 +109,7 @@ fn call_info_impl(\n     token: SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n     // Find the calling expression and it's NameRef\n-    let calling_node = FnCallNode::with_node(&token.parent())?;\n+    let calling_node = FnCallNode::with_node(&token.parent()?)?;\n \n     let callable = match &calling_node {\n         FnCallNode::CallExpr(call) => sema.type_of_expr(&call.expr()?)?.as_callable(sema.db)?,"}, {"sha": "dc78354739a31be7278078956b1008f61843d6e8", "filename": "crates/ide_ssr/src/resolving.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fide_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fresolving.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -195,7 +195,7 @@ impl<'db> ResolutionScope<'db> {\n             .syntax()\n             .token_at_offset(resolve_context.offset)\n             .left_biased()\n-            .map(|token| token.parent())\n+            .and_then(|token| token.parent())\n             .unwrap_or_else(|| file.syntax().clone());\n         let node = pick_node_for_resolution(node);\n         let scope = sema.scope(&node);"}, {"sha": "74cafaa8d21c1de39b59c073601fc82e7265d772", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -13,7 +13,7 @@ doctest = false\n [dependencies]\n cov-mark = { version = \"1.1\", features = [\"thread-local\"] }\n itertools = \"0.10.0\"\n-rowan = \"0.12.2\"\n+rowan = \"0.13.0-pre.2\"\n rustc_lexer = { version = \"710.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\""}, {"sha": "82ebf9037c0619f53eb4862450a23ded95bfea7f", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -4,7 +4,6 @@ use std::{\n     fmt,\n     hash::BuildHasherDefault,\n     ops::{self, RangeInclusive},\n-    ptr,\n };\n \n use indexmap::IndexMap;\n@@ -27,7 +26,7 @@ pub fn ancestors_at_offset(\n     offset: TextSize,\n ) -> impl Iterator<Item = SyntaxNode> {\n     node.token_at_offset(offset)\n-        .map(|token| token.parent().ancestors())\n+        .map(|token| token.ancestors())\n         .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n }\n \n@@ -171,7 +170,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n             && lhs.text_range().len() == rhs.text_range().len()\n             && match (&lhs, &rhs) {\n                 (NodeOrToken::Node(lhs), NodeOrToken::Node(rhs)) => {\n-                    ptr::eq(lhs.green(), rhs.green()) || lhs.text() == rhs.text()\n+                    lhs == rhs || lhs.text() == rhs.text()\n                 }\n                 (NodeOrToken::Token(lhs), NodeOrToken::Token(rhs)) => lhs.text() == rhs.text(),\n                 _ => false,\n@@ -280,9 +279,10 @@ fn _insert_children(\n         to_green_element(element)\n     });\n \n-    let mut old_children = parent.green().children().map(|it| match it {\n-        NodeOrToken::Token(it) => NodeOrToken::Token(it.clone()),\n-        NodeOrToken::Node(it) => NodeOrToken::Node(it.clone()),\n+    let parent_green = parent.green();\n+    let mut old_children = parent_green.children().map(|it| match it {\n+        NodeOrToken::Token(it) => NodeOrToken::Token(it.to_owned()),\n+        NodeOrToken::Node(it) => NodeOrToken::Node(it.to_owned()),\n     });\n \n     let new_children = match &position {\n@@ -319,9 +319,10 @@ fn _replace_children(\n ) -> SyntaxNode {\n     let start = position_of_child(parent, to_delete.start().clone());\n     let end = position_of_child(parent, to_delete.end().clone());\n-    let mut old_children = parent.green().children().map(|it| match it {\n-        NodeOrToken::Token(it) => NodeOrToken::Token(it.clone()),\n-        NodeOrToken::Node(it) => NodeOrToken::Node(it.clone()),\n+    let parent_green = parent.green();\n+    let mut old_children = parent_green.children().map(|it| match it {\n+        NodeOrToken::Token(it) => NodeOrToken::Token(it.to_owned()),\n+        NodeOrToken::Node(it) => NodeOrToken::Node(it.to_owned()),\n     });\n \n     let before = old_children.by_ref().take(start).collect::<Vec<_>>();\n@@ -487,19 +488,19 @@ impl<'a> SyntaxRewriter<'a> {\n     /// Returns `None` when there are no replacements.\n     pub fn rewrite_root(&self) -> Option<SyntaxNode> {\n         let _p = profile::span(\"rewrite_root\");\n-        fn element_to_node_or_parent(element: &SyntaxElement) -> SyntaxNode {\n+        fn element_to_node_or_parent(element: &SyntaxElement) -> Option<SyntaxNode> {\n             match element {\n-                SyntaxElement::Node(it) => it.clone(),\n+                SyntaxElement::Node(it) => Some(it.clone()),\n                 SyntaxElement::Token(it) => it.parent(),\n             }\n         }\n \n         assert!(self.f.is_none());\n         self.replacements\n             .keys()\n-            .map(element_to_node_or_parent)\n-            .chain(self.insertions.keys().map(|pos| match pos {\n-                InsertPos::FirstChildOf(it) => it.clone(),\n+            .filter_map(element_to_node_or_parent)\n+            .chain(self.insertions.keys().filter_map(|pos| match pos {\n+                InsertPos::FirstChildOf(it) => Some(it.clone()),\n                 InsertPos::After(it) => element_to_node_or_parent(it),\n             }))\n             // If we only have one replacement/insertion, we must return its parent node, since `rewrite` does\n@@ -552,7 +553,7 @@ impl<'a> SyntaxRewriter<'a> {\n             };\n         } else {\n             match element {\n-                NodeOrToken::Token(it) => acc.push(NodeOrToken::Token(it.green().clone())),\n+                NodeOrToken::Token(it) => acc.push(NodeOrToken::Token(it.green().to_owned())),\n                 NodeOrToken::Node(it) => {\n                     acc.push(NodeOrToken::Node(self.rewrite_children(it)));\n                 }\n@@ -567,7 +568,7 @@ impl<'a> SyntaxRewriter<'a> {\n fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n     match element {\n         NodeOrToken::Node(it) => NodeOrToken::Node(it.green().to_owned()),\n-        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n+        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().to_owned()),\n     }\n }\n \n@@ -625,7 +626,7 @@ fn position_of_child(parent: &SyntaxNode, child: SyntaxElement) -> usize {\n fn to_green_element(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n     match element {\n         NodeOrToken::Node(it) => it.green().to_owned().into(),\n-        NodeOrToken::Token(it) => it.green().clone().into(),\n+        NodeOrToken::Token(it) => it.green().to_owned().into(),\n     }\n }\n "}, {"sha": "19261686cb96431be767bbdd5c5af4683c60ed3d", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -6,6 +6,7 @@ mod token_ext;\n mod node_ext;\n mod expr_ext;\n pub mod edit;\n+pub mod edit_in_place;\n pub mod make;\n \n use std::marker::PhantomData;\n@@ -40,6 +41,12 @@ pub trait AstNode {\n         Self: Sized;\n \n     fn syntax(&self) -> &SyntaxNode;\n+    fn clone_for_update(&self) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        Self::cast(self.syntax().clone_for_update()).unwrap()\n+    }\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes."}, {"sha": "06cde591de794fc068f7f7ead0684e2b7a9c5a11", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -0,0 +1,105 @@\n+//! Structural editing for ast.\n+\n+use std::iter::empty;\n+\n+use ast::{edit::AstNodeEdit, make, GenericParamsOwner, WhereClause};\n+use parser::T;\n+\n+use crate::{\n+    ast,\n+    ted::{self, Position},\n+    AstNode, Direction, SyntaxKind,\n+};\n+\n+use super::NameOwner;\n+\n+pub trait GenericParamsOwnerEdit: ast::GenericParamsOwner + AstNodeEdit {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause;\n+}\n+\n+impl GenericParamsOwnerEdit for ast::Fn {\n+    fn get_or_create_where_clause(&self) -> WhereClause {\n+        if self.where_clause().is_none() {\n+            let position = if let Some(ty) = self.ret_type() {\n+                Position::after(ty.syntax().clone())\n+            } else if let Some(param_list) = self.param_list() {\n+                Position::after(param_list.syntax().clone())\n+            } else {\n+                Position::last_child_of(self.syntax().clone())\n+            };\n+            create_where_clause(position)\n+        }\n+        self.where_clause().unwrap()\n+    }\n+}\n+\n+impl GenericParamsOwnerEdit for ast::Impl {\n+    fn get_or_create_where_clause(&self) -> WhereClause {\n+        if self.where_clause().is_none() {\n+            let position = if let Some(ty) = self.self_ty() {\n+                Position::after(ty.syntax().clone())\n+            } else {\n+                Position::last_child_of(self.syntax().clone())\n+            };\n+            create_where_clause(position)\n+        }\n+        self.where_clause().unwrap()\n+    }\n+}\n+impl GenericParamsOwnerEdit for ast::Struct {\n+    fn get_or_create_where_clause(&self) -> WhereClause {\n+        if self.where_clause().is_none() {\n+            let tfl = self.field_list().and_then(|fl| match fl {\n+                ast::FieldList::RecordFieldList(_) => None,\n+                ast::FieldList::TupleFieldList(it) => Some(it),\n+            });\n+            let position = if let Some(tfl) = tfl {\n+                Position::after(tfl.syntax().clone())\n+            } else if let Some(gpl) = self.generic_param_list() {\n+                Position::after(gpl.syntax().clone())\n+            } else if let Some(name) = self.name() {\n+                Position::after(name.syntax().clone())\n+            } else {\n+                Position::last_child_of(self.syntax().clone())\n+            };\n+            create_where_clause(position)\n+        }\n+        self.where_clause().unwrap()\n+    }\n+}\n+\n+fn create_where_clause(position: Position) {\n+    let elements = vec![\n+        make::tokens::single_space().into(),\n+        make::where_clause(empty()).clone_for_update().syntax().clone().into(),\n+    ];\n+    ted::insert_all(position, elements);\n+}\n+\n+impl ast::WhereClause {\n+    pub fn add_predicate(&self, predicate: ast::WherePred) {\n+        if let Some(pred) = self.predicates().last() {\n+            if !pred.syntax().siblings_with_tokens(Direction::Next).any(|it| it.kind() == T![,]) {\n+                ted::append_child(self.syntax().clone(), make::token(T![,]));\n+            }\n+        }\n+        if self.syntax().children_with_tokens().last().map(|it| it.kind())\n+            != Some(SyntaxKind::WHITESPACE)\n+        {\n+            ted::append_child(self.syntax().clone(), make::tokens::single_space());\n+        }\n+        ted::append_child(self.syntax().clone(), predicate.syntax().clone())\n+    }\n+}\n+\n+impl ast::TypeBoundList {\n+    pub fn remove(&self) {\n+        if let Some(colon) =\n+            self.syntax().siblings_with_tokens(Direction::Prev).find(|it| it.kind() == T![:])\n+        {\n+            ted::remove_all(colon..=self.syntax().clone().into())\n+        } else {\n+            ted::remove(self.syntax().clone())\n+        }\n+    }\n+}"}, {"sha": "810c8d4c86d2e4651f8fc9521d0052fa2baa6cd6", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -174,6 +174,11 @@ pub fn block_expr(\n pub fn expr_unit() -> ast::Expr {\n     expr_from_text(\"()\")\n }\n+pub fn expr_literal(text: &str) -> ast::Literal {\n+    assert_eq!(text.trim(), text);\n+    ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text))\n+}\n+\n pub fn expr_empty_block() -> ast::Expr {\n     expr_from_text(\"{}\")\n }\n@@ -390,6 +395,7 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n     tokens::SOURCE_FILE\n         .tree()\n         .syntax()\n+        .clone_for_update()\n         .descendants_with_tokens()\n         .filter_map(|it| it.into_token())\n         .find(|it| it.kind() == kind)\n@@ -544,6 +550,7 @@ pub mod tokens {\n         SOURCE_FILE\n             .tree()\n             .syntax()\n+            .clone_for_update()\n             .descendants_with_tokens()\n             .filter_map(|it| it.into_token())\n             .find(|it| it.kind() == WHITESPACE && it.text() == \" \")\n@@ -569,13 +576,16 @@ pub mod tokens {\n     }\n \n     pub fn single_newline() -> SyntaxToken {\n-        SOURCE_FILE\n+        let res = SOURCE_FILE\n             .tree()\n             .syntax()\n+            .clone_for_update()\n             .descendants_with_tokens()\n             .filter_map(|it| it.into_token())\n             .find(|it| it.kind() == WHITESPACE && it.text() == \"\\n\")\n-            .unwrap()\n+            .unwrap();\n+        res.detach();\n+        res\n     }\n \n     pub fn blank_line() -> SyntaxToken {"}, {"sha": "0b0d39a7571e7630e4abed822db92eb7c5feef36", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -34,7 +34,9 @@ impl ast::NameRef {\n }\n \n fn text_of_first_token(node: &SyntaxNode) -> &str {\n-    node.green().children().next().and_then(|it| it.into_token()).unwrap().text()\n+    let t =\n+        node.green().children().next().and_then(|it| it.into_token()).unwrap().text().to_string();\n+    Box::leak(Box::new(t))\n }\n \n pub enum Macro {"}, {"sha": "2a5c61171b3a57c8071035ee1f6e7a1eebb80564", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -38,6 +38,7 @@ pub mod ast;\n #[doc(hidden)]\n pub mod fuzz;\n pub mod utils;\n+pub mod ted;\n \n use std::{marker::PhantomData, sync::Arc};\n "}, {"sha": "4ad50ab729b8963bac06a7bd8bf0574b1e4d559e", "filename": "crates/syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -124,11 +124,7 @@ fn is_contextual_kw(text: &str) -> bool {\n fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(SyntaxNode, Reparser)> {\n     let node = node.covering_element(range);\n \n-    let mut ancestors = match node {\n-        NodeOrToken::Token(it) => it.parent().ancestors(),\n-        NodeOrToken::Node(it) => it.ancestors(),\n-    };\n-    ancestors.find_map(|node| {\n+    node.ancestors().find_map(|node| {\n         let first_child = node.first_child_or_token().map(|it| it.kind());\n         let parent = node.parent().map(|it| it.kind());\n         Reparser::for_node(node.kind(), first_child, parent).map(|r| (node, r))"}, {"sha": "8d6175ed9510dfa76df909fe8420f132735c871b", "filename": "crates/syntax/src/ted.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49b5b7468a9954af86fd1724276261f396aba5d/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=c49b5b7468a9954af86fd1724276261f396aba5d", "patch": "@@ -0,0 +1,78 @@\n+//! Primitive tree editor, ed for trees\n+#![allow(unused)]\n+use std::ops::RangeInclusive;\n+\n+use crate::{SyntaxElement, SyntaxNode};\n+\n+#[derive(Debug)]\n+pub struct Position {\n+    repr: PositionRepr,\n+}\n+\n+#[derive(Debug)]\n+enum PositionRepr {\n+    FirstChild(SyntaxNode),\n+    After(SyntaxElement),\n+}\n+\n+impl Position {\n+    pub fn after(elem: impl Into<SyntaxElement>) -> Position {\n+        let repr = PositionRepr::After(elem.into());\n+        Position { repr }\n+    }\n+    pub fn before(elem: impl Into<SyntaxElement>) -> Position {\n+        let elem = elem.into();\n+        let repr = match elem.prev_sibling_or_token() {\n+            Some(it) => PositionRepr::After(it),\n+            None => PositionRepr::FirstChild(elem.parent().unwrap()),\n+        };\n+        Position { repr }\n+    }\n+    pub fn first_child_of(node: impl Into<SyntaxNode>) -> Position {\n+        let repr = PositionRepr::FirstChild(node.into());\n+        Position { repr }\n+    }\n+    pub fn last_child_of(node: impl Into<SyntaxNode>) -> Position {\n+        let node = node.into();\n+        let repr = match node.last_child_or_token() {\n+            Some(it) => PositionRepr::After(it),\n+            None => PositionRepr::FirstChild(node),\n+        };\n+        Position { repr }\n+    }\n+}\n+\n+pub fn insert(position: Position, elem: impl Into<SyntaxElement>) {\n+    insert_all(position, vec![elem.into()])\n+}\n+pub fn insert_all(position: Position, elements: Vec<SyntaxElement>) {\n+    let (parent, index) = match position.repr {\n+        PositionRepr::FirstChild(parent) => (parent, 0),\n+        PositionRepr::After(child) => (child.parent().unwrap(), child.index() + 1),\n+    };\n+    parent.splice_children(index..index, elements);\n+}\n+\n+pub fn remove(elem: impl Into<SyntaxElement>) {\n+    let elem = elem.into();\n+    remove_all(elem.clone()..=elem)\n+}\n+pub fn remove_all(range: RangeInclusive<SyntaxElement>) {\n+    replace_all(range, Vec::new())\n+}\n+\n+pub fn replace(old: impl Into<SyntaxElement>, new: impl Into<SyntaxElement>) {\n+    let old = old.into();\n+    replace_all(old.clone()..=old, vec![new.into()])\n+}\n+pub fn replace_all(range: RangeInclusive<SyntaxElement>, new: Vec<SyntaxElement>) {\n+    let start = range.start().index();\n+    let end = range.end().index();\n+    let parent = range.start().parent().unwrap();\n+    parent.splice_children(start..end + 1, new)\n+}\n+\n+pub fn append_child(node: impl Into<SyntaxNode>, child: impl Into<SyntaxElement>) {\n+    let position = Position::last_child_of(node);\n+    insert(position, child)\n+}"}]}