{"sha": "3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMmMzOWIzZDhkZTA5Y2E0YjU4YTIyYjVmNTkxMTUxOTEyNjJmZDc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-18T07:19:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-18T07:19:25Z"}, "message": "Fix symbol names on LLVM C library binding and library-name for LLVM.", "tree": {"sha": "d1fc63b9945451e34131bf90be05e20bd33bace0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1fc63b9945451e34131bf90be05e20bd33bace0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "html_url": "https://github.com/rust-lang/rust/commit/3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f2c39b3d8de09ca4b58a22b5f59115191262fd7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9277f551d34d4891cf440316d5d10e1457310b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9277f551d34d4891cf440316d5d10e1457310b0d", "html_url": "https://github.com/rust-lang/rust/commit/9277f551d34d4891cf440316d5d10e1457310b0d"}], "stats": {"total": 1453, "additions": 857, "deletions": 596}, "files": [{"sha": "9a31a1934b9405159a1037f0078a5f42e356704f", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 852, "deletions": 593, "changes": 1445, "blob_url": "https://github.com/rust-lang/rust/blob/3f2c39b3d8de09ca4b58a22b5f59115191262fd7/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f2c39b3d8de09ca4b58a22b5f59115191262fd7/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "patch": "@@ -1,616 +1,875 @@\n import std._str.rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n \n+import llvm.ModuleRef;\n+import llvm.ContextRef;\n+import llvm.TypeRef;\n+import llvm.TypeHandleRef;\n+import llvm.ValueRef;\n+import llvm.BasicBlockRef;\n+import llvm.BuilderRef;\n+import llvm.ModuleProviderRef;\n+import llvm.MemoryBufferRef;\n+import llvm.PassManagerRef;\n+import llvm.UseRef;\n+import llvm.Linkage;\n+import llvm.Attribute;\n+import llvm.Visibility;\n+import llvm.CallConv;\n+import llvm.IntPredicate;\n+import llvm.RealPredicate;\n+import llvm.Opcode;\n+\n type ULongLong = u64;\n type LongLong = i64;\n type Long = i32;\n type Bool = int;\n \n native mod llvm = llvm_lib {\n \n-  type ModuleRef;\n-  type ContextRef;\n-  type TypeRef;\n-  type TypeHandleRef;\n-  type ValueRef;\n-  type BasicBlockRef;\n-  type BuilderRef;\n-  type ModuleProviderRef;\n-  type MemoryBufferRef;\n-  type PassManagerRef;\n-  type UseRef;\n-\n-  /* FIXME: These are enums in the C header. Represent them how, in rust? */\n-  type Linkage;\n-  type Attribute;\n-  type Visibility;\n-  type CallConv;\n-  type IntPredicate;\n-  type RealPredicate;\n-  type Opcode;\n-\n-  /* Create and destroy contexts. */\n-  fn ContextCreate() -> ContextRef;\n-  fn GetGlobalContext() -> ContextRef;\n-  fn ContextDispose(ContextRef C);\n-  fn GetMDKindIDInContext(ContextRef C, sbuf Name, uint SLen) -> uint;\n-  fn GetMDKindID(sbuf Name, uint SLen) -> uint;\n-\n-  /* Create and destroy modules. */\n-  fn ModuleCreateWithNameInContext(sbuf ModuleID, ContextRef C) -> ModuleRef;\n-  fn DisposeModule(ModuleRef M);\n-\n-  /** Data layout. See Module::getDataLayout. */\n-  fn GetDataLayout(ModuleRef M) -> sbuf;\n-  fn SetDataLayout(ModuleRef M, sbuf Triple);\n-\n-  /** Target triple. See Module::getTargetTriple. */\n-  fn GetTarget(ModuleRef M) -> sbuf;\n-  fn SetTarget(ModuleRef M, sbuf Triple);\n-\n-  /** See Module::addTypeName. */\n-  fn AddTypeName(ModuleRef M, sbuf Name, TypeRef Ty) -> Bool;\n-  fn DeleteTypeName(ModuleRef M, sbuf Name);\n-  fn GetTypeByName(ModuleRef M, sbuf Name) -> TypeRef;\n-\n-  /** See Module::dump. */\n-  fn DumpModule(ModuleRef M);\n-\n-  /** See Module::setModuleInlineAsm. */\n-  fn SetModuleInlineAsm(ModuleRef M, sbuf Asm);\n-\n-  /** See llvm::LLVMType::getContext. */\n-  fn GetTypeContext(TypeRef Ty) -> ContextRef;\n-\n-  /* Operations on integer types */\n-  fn Int1TypeInContext(ContextRef C) -> TypeRef;\n-  fn Int8TypeInContext(ContextRef C) -> TypeRef;\n-  fn Int16TypeInContext(ContextRef C) -> TypeRef;\n-  fn Int32TypeInContext(ContextRef C) -> TypeRef;\n-  fn Int64TypeInContext(ContextRef C) -> TypeRef;\n-  fn IntTypeInContext(ContextRef C, uint NumBits) -> TypeRef;\n-\n-  fn Int1Type() -> TypeRef;\n-  fn Int8Type() -> TypeRef;\n-  fn Int16Type() -> TypeRef;\n-  fn Int32Type() -> TypeRef;\n-  fn Int64Type() -> TypeRef;\n-  fn IntType(uint NumBits) -> TypeRef;\n-  fn GetIntTypeWidth(TypeRef IntegerTy) -> uint;\n-\n-  /* Operations on real types */\n-  fn FloatTypeInContext(ContextRef C) -> TypeRef;\n-  fn DoubleTypeInContext(ContextRef C) -> TypeRef;\n-  fn X86FP80TypeInContext(ContextRef C) -> TypeRef;\n-  fn FP128TypeInContext(ContextRef C) -> TypeRef;\n-  fn PPCFP128TypeInContext(ContextRef C) -> TypeRef;\n-\n-  fn FloatType() -> TypeRef;\n-  fn DoubleType() -> TypeRef;\n-  fn X86FP80Type() -> TypeRef;\n-  fn FP128Type() -> TypeRef;\n-  fn PPCFP128Type() -> TypeRef;\n-\n-  /* Operations on function types */\n-  fn FunctionType(TypeRef ReturnType, vbuf ParamTypes,\n-                  uint ParamCount, Bool IsVarArg) -> TypeRef;\n-  fn IsFunctionVarArg(TypeRef FunctionTy) -> Bool;\n-  fn GetReturnType(TypeRef FunctionTy) -> TypeRef;\n-  fn CountParamTypes(TypeRef FunctionTy) -> uint;\n-  fn GetParamTypes(TypeRef FunctionTy, vbuf Dest);\n-\n-  /* Operations on struct types */\n-  fn StructTypeInContext(ContextRef C, vbuf ElementTypes,\n-                         uint ElementCount, Bool Packed) -> TypeRef;\n-  fn StructType(vbuf ElementTypes, uint ElementCount,\n-                Bool Packed) -> TypeRef;\n-  fn CountStructElementTypes(TypeRef StructTy) -> uint;\n-  fn GetStructElementTypes(TypeRef StructTy, vbuf Dest);\n-  fn IsPackedStruct(TypeRef StructTy) -> Bool;\n-\n-  /* Operations on union types */\n-  fn UnionTypeInContext(ContextRef C, vbuf ElementTypes,\n-                        uint ElementCount) -> TypeRef;\n-  fn UnionType(vbuf ElementTypes, uint ElementCount) -> TypeRef;\n-  fn CountUnionElementTypes(TypeRef UnionTy) -> uint;\n-  fn GetUnionElementTypes(TypeRef UnionTy, vbuf Dest);\n-\n-  /* Operations on array, pointer, and vector types (sequence types) */\n-  fn ArrayType(TypeRef ElementType, uint ElementCount) -> TypeRef;\n-  fn PointerType(TypeRef ElementType, uint AddressSpace) -> TypeRef;\n-  fn VectorType(TypeRef ElementType, uint ElementCount) -> TypeRef;\n-\n-  fn GetElementType(TypeRef Ty) -> TypeRef;\n-  fn GetArrayLength(TypeRef ArrayTy) -> uint;\n-  fn GetPointerAddressSpace(TypeRef PointerTy) -> uint;\n-  fn GetVectorSize(TypeRef VectorTy) -> uint;\n-\n-  /* Operations on other types */\n-  fn VoidTypeInContext(ContextRef C) -> TypeRef;\n-  fn LabelTypeInContext(ContextRef C) -> TypeRef;\n-  fn OpaqueTypeInContext(ContextRef C) -> TypeRef;\n-\n-  fn VoidType() -> TypeRef;\n-  fn LabelType() -> TypeRef;\n-  fn OpaqueType() -> TypeRef;\n-\n-  /* Operations on type handles */\n-  fn CreateTypeHandle(TypeRef PotentiallyAbstractTy) -> TypeHandleRef;\n-  fn RefineType(TypeRef AbstractTy, TypeRef ConcreteTy);\n-  fn ResolveTypeHandle(TypeHandleRef TypeHandle) -> TypeRef;\n-  fn DisposeTypeHandle(TypeHandleRef TypeHandle);\n-\n-  /* Operations on all values */\n-  fn TypeOf(ValueRef Val) -> TypeRef;\n-  fn GetValueName(ValueRef Val) -> sbuf;\n-  fn SetValueName(ValueRef Val, sbuf Name);\n-  fn DumpValue(ValueRef Val);\n-  fn ReplaceAllUsesWith(ValueRef OldVal, ValueRef NewVal);\n-  fn HasMetadata(ValueRef Val) -> int;\n-  fn GetMetadata(ValueRef Val, uint KindID) -> ValueRef;\n-  fn SetMetadata(ValueRef Val, uint KindID, ValueRef Node);\n-\n-  /* Operations on Uses */\n-  fn GetFirstUse(ValueRef Val) -> UseRef;\n-  fn GetNextUse(UseRef U) -> UseRef;\n-  fn GetUser(UseRef U) -> ValueRef;\n-  fn GetUsedValue(UseRef U) -> ValueRef;\n-\n-  /* Operations on Users */\n-  fn GetOperand(ValueRef Val, uint Index) -> ValueRef;\n-\n-  /* Operations on constants of any type */\n-  fn ConstNull(TypeRef Ty) -> ValueRef; /* all zeroes */\n-  fn ConstAllOnes(TypeRef Ty) -> ValueRef; /* only for int/vector */\n-  fn GetUndef(TypeRef Ty) -> ValueRef;\n-  fn IsConstant(ValueRef Val) -> Bool;\n-  fn IsNull(ValueRef Val) -> Bool;\n-  fn IsUndef(ValueRef Val) -> Bool;\n-  fn ConstPointerNull(TypeRef Ty) -> ValueRef;\n-\n-  /* Operations on metadata */\n-  fn MDStringInContext(ContextRef C, sbuf Str, uint SLen) -> ValueRef;\n-  fn MDString(sbuf Str, uint SLen) -> ValueRef;\n-  fn MDNodeInContext(ContextRef C, vbuf Vals, uint Count) -> ValueRef;\n-  fn MDNode(vbuf Vals, uint Count) -> ValueRef;\n-\n-  /* Operations on scalar constants */\n-  fn ConstInt(TypeRef IntTy, ULongLong N, Bool SignExtend) -> ValueRef;\n-  fn ConstIntOfString(TypeRef IntTy, sbuf Text, u8 Radix) -> ValueRef;\n-  fn ConstIntOfStringAndSize(TypeRef IntTy, sbuf Text,\n-                             uint SLen, u8 Radix) -> ValueRef;\n-  fn ConstReal(TypeRef RealTy, f64 N) -> ValueRef;\n-  fn ConstRealOfString(TypeRef RealTy, sbuf Text) -> ValueRef;\n-  fn ConstRealOfStringAndSize(TypeRef RealTy, sbuf Text,\n-                              uint SLen) -> ValueRef;\n-  fn ConstIntGetZExtValue(ValueRef ConstantVal) -> ULongLong;\n-  fn ConstIntGetSExtValue(ValueRef ConstantVal) -> LongLong;\n-\n-\n-  /* Operations on composite constants */\n-  fn ConstStringInContext(ContextRef C, sbuf Str,\n-                          uint Length, Bool DontNullTerminate) -> ValueRef;\n-  fn ConstStructInContext(ContextRef C, vbuf ConstantVals,\n-                          uint Count, Bool Packed) -> ValueRef;\n-\n-  fn ConstString(sbuf Str, uint Length, Bool DontNullTerminate) -> ValueRef;\n-  fn ConstArray(TypeRef ElementTy,\n-                vbuf ConstantVals, uint Length) -> ValueRef;\n-  fn ConstStruct(vbuf ConstantVals, uint Count, Bool Packed) -> ValueRef;\n-  fn ConstVector(vbuf ScalarConstantVals, uint Size) -> ValueRef;\n-  fn ConstUnion(TypeRef Ty, ValueRef Val) -> ValueRef;\n-\n-  /* Constant expressions */\n-  fn AlignOf(TypeRef Ty) -> ValueRef;\n-  fn SizeOf(TypeRef Ty) -> ValueRef;\n-  fn ConstNeg(ValueRef ConstantVal) -> ValueRef;\n-  fn ConstNSWNeg(ValueRef ConstantVal) -> ValueRef;\n-  fn ConstNUWNeg(ValueRef ConstantVal) -> ValueRef;\n-  fn ConstFNeg(ValueRef ConstantVal) -> ValueRef;\n-  fn ConstNot(ValueRef ConstantVal) -> ValueRef;\n-  fn ConstAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNSWAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNUWAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstFAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNSWSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNUWSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstFSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNSWMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstNUWMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstFMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstUDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstSDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstExactSDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstFDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstURem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstSRem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstFRem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstAnd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstOr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstXor(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstShl(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstLShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstAShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n-  fn ConstGEP(ValueRef ConstantVal,\n-              vbuf ConstantIndices, uint NumIndices) -> ValueRef;\n-  fn ConstInBoundsGEP(ValueRef ConstantVal,\n-                      vbuf ConstantIndices,\n-                      uint NumIndices) -> ValueRef;\n-  fn ConstTrunc(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstSExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstZExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstFPTrunc(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstFPExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstUIToFP(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstSIToFP(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstFPToUI(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstFPToSI(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstPtrToInt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstIntToPtr(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstBitCast(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstZExtOrBitCast(ValueRef ConstantVal,\n-                        TypeRef ToType) -> ValueRef;\n-  fn ConstSExtOrBitCast(ValueRef ConstantVal,\n-                        TypeRef ToType) -> ValueRef;\n-  fn ConstTruncOrBitCast(ValueRef ConstantVal,\n-                         TypeRef ToType) -> ValueRef;\n-  fn ConstPointerCast(ValueRef ConstantVal,\n-                      TypeRef ToType) -> ValueRef;\n-  fn ConstIntCast(ValueRef ConstantVal, TypeRef ToType,\n-                  Bool isSigned) -> ValueRef;\n-  fn ConstFPCast(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n-  fn ConstSelect(ValueRef ConstantCondition,\n-                 ValueRef ConstantIfTrue,\n-                 ValueRef ConstantIfFalse) -> ValueRef;\n-  fn ConstExtractElement(ValueRef VectorConstant,\n-                         ValueRef IndexConstant) -> ValueRef;\n-  fn ConstInsertElement(ValueRef VectorConstant,\n-                        ValueRef ElementValueConstant,\n-                        ValueRef IndexConstant) -> ValueRef;\n-  fn ConstShuffleVector(ValueRef VectorAConstant,\n-                        ValueRef VectorBConstant,\n-                        ValueRef MaskConstant) -> ValueRef;\n-  fn ConstExtractValue(ValueRef AggConstant, vbuf IdxList,\n-                       uint NumIdx) -> ValueRef;\n-  fn ConstInsertValue(ValueRef AggConstant,\n-                      ValueRef ElementValueConstant,\n-                      vbuf IdxList, uint NumIdx) -> ValueRef;\n-  fn ConstInlineAsm(TypeRef Ty,\n-                    sbuf AsmString, sbuf Constraints,\n-                    Bool HasSideEffects, Bool IsAlignStack) -> ValueRef;\n-  fn BlockAddress(ValueRef F, BasicBlockRef BB) -> ValueRef;\n-\n-\n-\n-  /* Operations on global variables, functions, and aliases (globals) */\n-  fn GetGlobalParent(ValueRef Global) -> ModuleRef;\n-  fn IsDeclaration(ValueRef Global) -> Bool;\n-  fn GetLinkage(ValueRef Global) -> Linkage;\n-  fn SetLinkage(ValueRef Global, Linkage Link);\n-  fn GetSection(ValueRef Global) -> sbuf;\n-  fn SetSection(ValueRef Global, sbuf Section);\n-  fn GetVisibility(ValueRef Global) -> Visibility;\n-  fn SetVisibility(ValueRef Global, Visibility Viz);\n-  fn GetAlignment(ValueRef Global) -> uint;\n-  fn SetAlignment(ValueRef Global, uint Bytes);\n-\n-\n-  /* Operations on global variables */\n-  fn AddGlobal(ModuleRef M, TypeRef Ty, sbuf Name) -> ValueRef;\n-  fn AddGlobalInAddressSpace(ModuleRef M, TypeRef Ty,\n-                             sbuf Name,\n-                             uint AddressSpace) -> ValueRef;\n-  fn GetNamedGlobal(ModuleRef M, sbuf Name) -> ValueRef;\n-  fn GetFirstGlobal(ModuleRef M) -> ValueRef;\n-  fn GetLastGlobal(ModuleRef M) -> ValueRef;\n-  fn GetNextGlobal(ValueRef GlobalVar) -> ValueRef;\n-  fn GetPreviousGlobal(ValueRef GlobalVar) -> ValueRef;\n-  fn DeleteGlobal(ValueRef GlobalVar);\n-  fn GetInitializer(ValueRef GlobalVar) -> ValueRef;\n-  fn SetInitializer(ValueRef GlobalVar, ValueRef ConstantVal);\n-  fn IsThreadLocal(ValueRef GlobalVar) -> Bool;\n-  fn SetThreadLocal(ValueRef GlobalVar, Bool IsThreadLocal);\n-  fn IsGlobalConstant(ValueRef GlobalVar) -> Bool;\n-  fn SetGlobalConstant(ValueRef GlobalVar, Bool IsConstant);\n-\n-  /* Operations on aliases */\n-  fn AddAlias(ModuleRef M, TypeRef Ty, ValueRef Aliasee,\n-              sbuf Name) -> ValueRef;\n-\n-  /* Operations on functions */\n-  fn AddFunction(ModuleRef M, sbuf Name,\n-                 TypeRef FunctionTy) -> ValueRef;\n-  fn GetNamedFunction(ModuleRef M, sbuf Name) -> ValueRef;\n-  fn GetFirstFunction(ModuleRef M) -> ValueRef;\n-  fn GetLastFunction(ModuleRef M) -> ValueRef;\n-  fn GetNextFunction(ValueRef Fn) -> ValueRef;\n-  fn GetPreviousFunction(ValueRef Fn) -> ValueRef;\n-  fn DeleteFunction(ValueRef Fn);\n-  fn GetIntrinsicID(ValueRef Fn) -> uint;\n-  fn GetFunctionCallConv(ValueRef Fn) -> uint;\n-  fn SetFunctionCallConv(ValueRef Fn, uint CC);\n-  fn GetGC(ValueRef Fn) -> sbuf;\n-  fn SetGC(ValueRef Fn, sbuf Name);\n-  fn AddFunctionAttr(ValueRef Fn, Attribute PA);\n-  fn GetFunctionAttr(ValueRef Fn) -> Attribute;\n-  fn RemoveFunctionAttr(ValueRef Fn, Attribute PA);\n-\n-  /* Operations on parameters */\n-  fn CountParams(ValueRef Fn) -> uint;\n-  fn GetParams(ValueRef Fn, vbuf Params);\n-  fn GetParam(ValueRef Fn, uint Index) -> ValueRef;\n-  fn GetParamParent(ValueRef Inst) -> ValueRef;\n-  fn GetFirstParam(ValueRef Fn) -> ValueRef;\n-  fn GetLastParam(ValueRef Fn) -> ValueRef;\n-  fn GetNextParam(ValueRef Arg) -> ValueRef;\n-  fn GetPreviousParam(ValueRef Arg) -> ValueRef;\n-  fn AddAttribute(ValueRef Arg, Attribute PA);\n-  fn RemoveAttribute(ValueRef Arg, Attribute PA);\n-  fn GetAttribute(ValueRef Arg) -> Attribute;\n-  fn SetParamAlignment(ValueRef Arg, uint align);\n-\n-  /* Operations on basic blocks */\n-  fn BasicBlockAsValue(BasicBlockRef BB) -> ValueRef;\n-  fn ValueIsBasicBlock(ValueRef Val) -> Bool;\n-  fn ValueAsBasicBlock(ValueRef Val) -> BasicBlockRef;\n-  fn GetBasicBlockParent(BasicBlockRef BB) -> ValueRef;\n-  fn CountBasicBlocks(ValueRef Fn) -> uint;\n-  fn GetBasicBlocks(ValueRef Fn, vbuf BasicBlocks);\n-  fn GetFirstBasicBlock(ValueRef Fn) -> BasicBlockRef;\n-  fn GetLastBasicBlock(ValueRef Fn) -> BasicBlockRef;\n-  fn GetNextBasicBlock(BasicBlockRef BB) -> BasicBlockRef;\n-  fn GetPreviousBasicBlock(BasicBlockRef BB) -> BasicBlockRef;\n-  fn GetEntryBasicBlock(ValueRef Fn) -> BasicBlockRef;\n-\n-  fn AppendBasicBlockInContext(ContextRef C, ValueRef Fn,\n-                               sbuf Name) -> BasicBlockRef;\n-  fn InsertBasicBlockInContext(ContextRef C, BasicBlockRef BB,\n-                               sbuf Name) -> BasicBlockRef;\n-\n-  fn AppendBasicBlock(ValueRef Fn, sbuf Name) -> BasicBlockRef;\n-  fn InsertBasicBlock(BasicBlockRef InsertBeforeBB,\n-                      sbuf Name) -> BasicBlockRef;\n-  fn DeleteBasicBlock(BasicBlockRef BB);\n-\n-  /* Operations on instructions */\n-  fn GetInstructionParent(ValueRef Inst) -> BasicBlockRef;\n-  fn GetFirstInstruction(BasicBlockRef BB) -> ValueRef;\n-  fn GetLastInstruction(BasicBlockRef BB) -> ValueRef;\n-  fn GetNextInstruction(ValueRef Inst) -> ValueRef;\n-  fn GetPreviousInstruction(ValueRef Inst) -> ValueRef;\n-\n-  /* Operations on call sites */\n-  fn SetInstructionCallConv(ValueRef Instr, uint CC);\n-  fn GetInstructionCallConv(ValueRef Instr) -> uint;\n-  fn AddInstrAttribute(ValueRef Instr, uint index, Attribute IA);\n-  fn RemoveInstrAttribute(ValueRef Instr, uint index, Attribute IA);\n-  fn SetInstrParamAlignment(ValueRef Instr, uint index, uint align);\n-\n-  /* Operations on call instructions (only) */\n-  fn IsTailCall(ValueRef CallInst) -> Bool;\n-  fn SetTailCall(ValueRef CallInst, Bool IsTailCall);\n-\n-  /* Operations on phi nodes */\n-  fn AddIncoming(ValueRef PhiNode, vbuf IncomingValues,\n-                 vbuf IncomingBlocks, uint Count);\n-  fn CountIncoming(ValueRef PhiNode) -> uint;\n-  fn GetIncomingValue(ValueRef PhiNode, uint Index) -> ValueRef;\n-  fn GetIncomingBlock(ValueRef PhiNode, uint Index) -> BasicBlockRef;\n-\n-  /* Instruction builders */\n-  fn CreateBuilderInContext(ContextRef C) -> BuilderRef;\n-  fn CreateBuilder() -> BuilderRef;\n-  fn PositionBuilder(BuilderRef Builder, BasicBlockRef Block,\n-                     ValueRef Instr);\n-  fn PositionBuilderBefore(BuilderRef Builder, ValueRef Instr);\n-  fn PositionBuilderAtEnd(BuilderRef Builder, BasicBlockRef Block);\n-  fn GetInsertBlock(BuilderRef Builder) -> BasicBlockRef;\n-  fn ClearInsertionPosition(BuilderRef Builder);\n-  fn InsertIntoBuilder(BuilderRef Builder, ValueRef Instr);\n-  fn InsertIntoBuilderWithName(BuilderRef Builder, ValueRef Instr,\n-                               sbuf Name);\n-  fn DisposeBuilder(BuilderRef Builder);\n-\n-  /* Metadata */\n-  fn SetCurrentDebugLocation(BuilderRef Builder, ValueRef L);\n-  fn GetCurrentDebugLocation(BuilderRef Builder) -> ValueRef;\n-  fn SetInstDebugLocation(BuilderRef Builder, ValueRef Inst);\n-\n-  /* Terminators */\n-  fn BuildRetVoid(BuilderRef B) -> ValueRef;\n-  fn BuildRet(BuilderRef B, ValueRef V) -> ValueRef;\n-  fn BuildAggregateRet(BuilderRef B, vbuf RetVals,\n-                       uint N) -> ValueRef;\n-  fn BuildBr(BuilderRef B, BasicBlockRef Dest) -> ValueRef;\n-  fn BuildCondBr(BuilderRef B, ValueRef If,\n-                 BasicBlockRef Then, BasicBlockRef Else) -> ValueRef;\n-  fn BuildSwitch(BuilderRef B, ValueRef V,\n-                 BasicBlockRef Else, uint NumCases) -> ValueRef;\n-  fn BuildIndirectBr(BuilderRef B, ValueRef Addr,\n-                     uint NumDests) -> ValueRef;\n-  fn BuildInvoke(BuilderRef B, ValueRef Fn,\n-                 vbuf Args, uint NumArgs,\n-                 BasicBlockRef Then, BasicBlockRef Catch,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildUnwind(BuilderRef B) -> ValueRef;\n-  fn BuildUnreachable(BuilderRef B) -> ValueRef;\n-\n-  /* Add a case to the switch instruction */\n-  fn AddCase(ValueRef Switch, ValueRef OnVal,\n-             BasicBlockRef Dest);\n-\n-  /* Add a destination to the indirectbr instruction */\n-  fn AddDestination(ValueRef IndirectBr, BasicBlockRef Dest);\n-\n-  /* Arithmetic */\n-  fn BuildAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildNSWAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildNUWAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildFAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildNSWSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildNUWSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildFSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildNSWMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildNUWMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildFMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildUDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildSDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildExactSDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+    type ModuleRef;\n+    type ContextRef;\n+    type TypeRef;\n+    type TypeHandleRef;\n+    type ValueRef;\n+    type BasicBlockRef;\n+    type BuilderRef;\n+    type ModuleProviderRef;\n+    type MemoryBufferRef;\n+    type PassManagerRef;\n+    type UseRef;\n+\n+    /* FIXME: These are enums in the C header. Represent them how, in rust? */\n+    type Linkage;\n+    type Attribute;\n+    type Visibility;\n+    type CallConv;\n+    type IntPredicate;\n+    type RealPredicate;\n+    type Opcode;\n+\n+    /* Create and destroy contexts. */\n+    fn LLVMContextCreate() -> ContextRef;\n+    fn LLVMGetGlobalContext() -> ContextRef;\n+    fn LLVMContextDispose(ContextRef C);\n+    fn LLVMGetMDKindIDInContext(ContextRef C, sbuf Name, uint SLen) -> uint;\n+    fn LLVMGetMDKindID(sbuf Name, uint SLen) -> uint;\n+\n+    /* Create and destroy modules. */\n+    fn LLVMModuleCreateWithNameInContext(sbuf ModuleID,\n+                                         ContextRef C)-> ModuleRef;\n+    fn LLVMDisposeModule(ModuleRef M);\n+\n+    /** Data layout. See Module::getDataLayout. */\n+    fn LLVMGetDataLayout(ModuleRef M) -> sbuf;\n+    fn LLVMSetDataLayout(ModuleRef M, sbuf Triple);\n+\n+    /** Target triple. See Module::getTargetTriple. */\n+    fn LLVMGetTarget(ModuleRef M) -> sbuf;\n+    fn LLVMSetTarget(ModuleRef M, sbuf Triple);\n+\n+    /** See Module::addTypeName. */\n+    fn LLVMAddTypeName(ModuleRef M, sbuf Name, TypeRef Ty) -> Bool;\n+    fn LLVMDeleteTypeName(ModuleRef M, sbuf Name);\n+    fn LLVMGetTypeByName(ModuleRef M, sbuf Name) -> TypeRef;\n+\n+    /** See Module::dump. */\n+    fn LLVMDumpModule(ModuleRef M);\n+\n+    /** See Module::setModuleInlineAsm. */\n+    fn LLVMSetModuleInlineAsm(ModuleRef M, sbuf Asm);\n+\n+    /** See llvm::LLVMType::getContext. */\n+    fn LLVMGetTypeContext(TypeRef Ty) -> ContextRef;\n+\n+    /* Operations on integer types */\n+    fn LLVMInt1TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMInt8TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMInt16TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMInt32TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMInt64TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMIntTypeInContext(ContextRef C, uint NumBits) -> TypeRef;\n+\n+    fn LLVMInt1Type() -> TypeRef;\n+    fn LLVMInt8Type() -> TypeRef;\n+    fn LLVMInt16Type() -> TypeRef;\n+    fn LLVMInt32Type() -> TypeRef;\n+    fn LLVMInt64Type() -> TypeRef;\n+    fn LLVMIntType(uint NumBits) -> TypeRef;\n+    fn LLVMGetIntTypeWidth(TypeRef IntegerTy) -> uint;\n+\n+    /* Operations on real types */\n+    fn LLVMFloatTypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMDoubleTypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMX86FP80TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMFP128TypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMPPCFP128TypeInContext(ContextRef C) -> TypeRef;\n+\n+    fn LLVMFloatType() -> TypeRef;\n+    fn LLVMDoubleType() -> TypeRef;\n+    fn LLVMX86FP80Type() -> TypeRef;\n+    fn LLVMFP128Type() -> TypeRef;\n+    fn LLVMPPCFP128Type() -> TypeRef;\n+\n+    /* Operations on function types */\n+    fn LLVMFunctionType(TypeRef ReturnType, vbuf ParamTypes,\n+                        uint ParamCount, Bool IsVarArg) -> TypeRef;\n+    fn LLVMIsFunctionVarArg(TypeRef FunctionTy) -> Bool;\n+    fn LLVMGetReturnType(TypeRef FunctionTy) -> TypeRef;\n+    fn LLVMCountParamTypes(TypeRef FunctionTy) -> uint;\n+    fn LLVMGetParamTypes(TypeRef FunctionTy, vbuf Dest);\n+\n+    /* Operations on struct types */\n+    fn LLVMStructTypeInContext(ContextRef C, vbuf ElementTypes,\n+                               uint ElementCount, Bool Packed) -> TypeRef;\n+    fn LLVMStructType(vbuf ElementTypes, uint ElementCount,\n+                      Bool Packed) -> TypeRef;\n+    fn LLVMCountStructElementTypes(TypeRef StructTy) -> uint;\n+    fn LLVMGetStructElementTypes(TypeRef StructTy, vbuf Dest);\n+    fn LLVMIsPackedStruct(TypeRef StructTy) -> Bool;\n+\n+    /* Operations on union types */\n+    fn LLVMUnionTypeInContext(ContextRef C, vbuf ElementTypes,\n+                              uint ElementCount) -> TypeRef;\n+    fn LLVMUnionType(vbuf ElementTypes, uint ElementCount) -> TypeRef;\n+    fn LLVMCountUnionElementTypes(TypeRef UnionTy) -> uint;\n+    fn LLVMGetUnionElementTypes(TypeRef UnionTy, vbuf Dest);\n+\n+    /* Operations on array, pointer, and vector types (sequence types) */\n+    fn LLVMArrayType(TypeRef ElementType, uint ElementCount) -> TypeRef;\n+    fn LLVMPointerType(TypeRef ElementType, uint AddressSpace) -> TypeRef;\n+    fn LLVMVectorType(TypeRef ElementType, uint ElementCount) -> TypeRef;\n+\n+    fn LLVMGetElementType(TypeRef Ty) -> TypeRef;\n+    fn LLVMGetArrayLength(TypeRef ArrayTy) -> uint;\n+    fn LLVMGetPointerAddressSpace(TypeRef PointerTy) -> uint;\n+    fn LLVMGetVectorSize(TypeRef VectorTy) -> uint;\n+\n+    /* Operations on other types */\n+    fn LLVMVoidTypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMLabelTypeInContext(ContextRef C) -> TypeRef;\n+    fn LLVMOpaqueTypeInContext(ContextRef C) -> TypeRef;\n+\n+    fn LLVMVoidType() -> TypeRef;\n+    fn LLVMLabelType() -> TypeRef;\n+    fn LLVMOpaqueType() -> TypeRef;\n+\n+    /* Operations on type handles */\n+    fn LLVMCreateTypeHandle(TypeRef PotentiallyAbstractTy) -> TypeHandleRef;\n+    fn LLVMRefineType(TypeRef AbstractTy, TypeRef ConcreteTy);\n+    fn LLVMResolveTypeHandle(TypeHandleRef TypeHandle) -> TypeRef;\n+    fn LLVMDisposeTypeHandle(TypeHandleRef TypeHandle);\n+\n+    /* Operations on all values */\n+    fn LLVMTypeOf(ValueRef Val) -> TypeRef;\n+    fn LLVMGetValueName(ValueRef Val) -> sbuf;\n+    fn LLVMSetValueName(ValueRef Val, sbuf Name);\n+    fn LLVMDumpValue(ValueRef Val);\n+    fn LLVMReplaceAllUsesWith(ValueRef OldVal, ValueRef NewVal);\n+    fn LLVMHasMetadata(ValueRef Val) -> int;\n+    fn LLVMGetMetadata(ValueRef Val, uint KindID) -> ValueRef;\n+    fn LLVMSetMetadata(ValueRef Val, uint KindID, ValueRef Node);\n+\n+    /* Operations on Uses */\n+    fn LLVMGetFirstUse(ValueRef Val) -> UseRef;\n+    fn LLVMGetNextUse(UseRef U) -> UseRef;\n+    fn LLVMGetUser(UseRef U) -> ValueRef;\n+    fn LLVMGetUsedValue(UseRef U) -> ValueRef;\n+\n+    /* Operations on Users */\n+    fn LLVMGetOperand(ValueRef Val, uint Index) -> ValueRef;\n+\n+    /* Operations on constants of any type */\n+    fn LLVMConstNull(TypeRef Ty) -> ValueRef; /* all zeroes */\n+    fn LLVMConstAllOnes(TypeRef Ty) -> ValueRef; /* only for int/vector */\n+    fn LLVMGetUndef(TypeRef Ty) -> ValueRef;\n+    fn LLVMIsConstant(ValueRef Val) -> Bool;\n+    fn LLVMIsNull(ValueRef Val) -> Bool;\n+    fn LLVMIsUndef(ValueRef Val) -> Bool;\n+    fn LLVMConstPointerNull(TypeRef Ty) -> ValueRef;\n+\n+    /* Operations on metadata */\n+    fn LLVMMDStringInContext(ContextRef C, sbuf Str, uint SLen) -> ValueRef;\n+    fn LLVMMDString(sbuf Str, uint SLen) -> ValueRef;\n+    fn LLVMMDNodeInContext(ContextRef C, vbuf Vals, uint Count) -> ValueRef;\n+    fn LLVMMDNode(vbuf Vals, uint Count) -> ValueRef;\n+\n+    /* Operations on scalar constants */\n+    fn LLVMConstInt(TypeRef IntTy, ULongLong N, Bool SignExtend) -> ValueRef;\n+    fn LLVMConstIntOfString(TypeRef IntTy, sbuf Text, u8 Radix) -> ValueRef;\n+    fn LLVMConstIntOfStringAndSize(TypeRef IntTy, sbuf Text,\n+                                   uint SLen, u8 Radix) -> ValueRef;\n+    fn LLVMConstReal(TypeRef RealTy, f64 N) -> ValueRef;\n+    fn LLVMConstRealOfString(TypeRef RealTy, sbuf Text) -> ValueRef;\n+    fn LLVMConstRealOfStringAndSize(TypeRef RealTy, sbuf Text,\n+                                    uint SLen) -> ValueRef;\n+    fn LLVMConstIntGetZExtValue(ValueRef ConstantVal) -> ULongLong;\n+    fn LLVMConstIntGetSExtValue(ValueRef ConstantVal) -> LongLong;\n+\n+\n+    /* Operations on composite constants */\n+    fn LLVMConstStringInContext(ContextRef C, sbuf Str, uint Length,\n+                                Bool DontNullTerminate) -> ValueRef;\n+    fn LLVMConstStructInContext(ContextRef C, vbuf ConstantVals,\n+                                uint Count, Bool Packed) -> ValueRef;\n+\n+    fn LLVMConstString(sbuf Str, uint Length,\n+                       Bool DontNullTerminate) -> ValueRef;\n+    fn LLVMConstArray(TypeRef ElementTy,\n+                      vbuf ConstantVals, uint Length) -> ValueRef;\n+    fn LLVMConstStruct(vbuf ConstantVals, uint Count,\n+                       Bool Packed) -> ValueRef;\n+    fn LLVMConstVector(vbuf ScalarConstantVals, uint Size) -> ValueRef;\n+    fn LLVMConstUnion(TypeRef Ty, ValueRef Val) -> ValueRef;\n+\n+    /* Constant expressions */\n+    fn LLVMAlignOf(TypeRef Ty) -> ValueRef;\n+    fn LLVMSizeOf(TypeRef Ty) -> ValueRef;\n+    fn LLVMConstNeg(ValueRef ConstantVal) -> ValueRef;\n+    fn LLVMConstNSWNeg(ValueRef ConstantVal) -> ValueRef;\n+    fn LLVMConstNUWNeg(ValueRef ConstantVal) -> ValueRef;\n+    fn LLVMConstFNeg(ValueRef ConstantVal) -> ValueRef;\n+    fn LLVMConstNot(ValueRef ConstantVal) -> ValueRef;\n+    fn LLVMConstAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNSWAdd(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNUWAdd(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstFAdd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNSWSub(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNUWSub(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstFSub(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNSWMul(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstNUWMul(ValueRef LHSConstant,\n+                       ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstFMul(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstUDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstSDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstExactSDiv(ValueRef LHSConstant,\n+                          ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstFDiv(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstURem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstSRem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstFRem(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstAnd(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstOr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstXor(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstShl(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstLShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstAShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n+    fn LLVMConstGEP(ValueRef ConstantVal,\n+                    vbuf ConstantIndices, uint NumIndices) -> ValueRef;\n+    fn LLVMConstInBoundsGEP(ValueRef ConstantVal,\n+                            vbuf ConstantIndices,\n+                            uint NumIndices) -> ValueRef;\n+    fn LLVMConstTrunc(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstSExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstZExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstFPTrunc(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstFPExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstUIToFP(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstSIToFP(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstFPToUI(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstFPToSI(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstPtrToInt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstIntToPtr(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstBitCast(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstZExtOrBitCast(ValueRef ConstantVal,\n+                              TypeRef ToType) -> ValueRef;\n+    fn LLVMConstSExtOrBitCast(ValueRef ConstantVal,\n+                              TypeRef ToType) -> ValueRef;\n+    fn LLVMConstTruncOrBitCast(ValueRef ConstantVal,\n+                               TypeRef ToType) -> ValueRef;\n+    fn LLVMConstPointerCast(ValueRef ConstantVal,\n+                            TypeRef ToType) -> ValueRef;\n+    fn LLVMConstIntCast(ValueRef ConstantVal, TypeRef ToType,\n+                        Bool isSigned) -> ValueRef;\n+    fn LLVMConstFPCast(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n+    fn LLVMConstSelect(ValueRef ConstantCondition,\n+                       ValueRef ConstantIfTrue,\n+                       ValueRef ConstantIfFalse) -> ValueRef;\n+    fn LLVMConstExtractElement(ValueRef VectorConstant,\n+                               ValueRef IndexConstant) -> ValueRef;\n+    fn LLVMConstInsertElement(ValueRef VectorConstant,\n+                              ValueRef ElementValueConstant,\n+                              ValueRef IndexConstant) -> ValueRef;\n+    fn LLVMConstShuffleVector(ValueRef VectorAConstant,\n+                              ValueRef VectorBConstant,\n+                              ValueRef MaskConstant) -> ValueRef;\n+    fn LLVMConstExtractValue(ValueRef AggConstant, vbuf IdxList,\n+                             uint NumIdx) -> ValueRef;\n+    fn LLVMConstInsertValue(ValueRef AggConstant,\n+                            ValueRef ElementValueConstant,\n+                            vbuf IdxList, uint NumIdx) -> ValueRef;\n+    fn LLVMConstInlineAsm(TypeRef Ty,\n+                          sbuf AsmString, sbuf Constraints,\n+                          Bool HasSideEffects, Bool IsAlignStack) -> ValueRef;\n+    fn LLVMBlockAddress(ValueRef F, BasicBlockRef BB) -> ValueRef;\n+\n+\n+\n+    /* Operations on global variables, functions, and aliases (globals) */\n+    fn LLVMGetGlobalParent(ValueRef Global) -> ModuleRef;\n+    fn LLVMIsDeclaration(ValueRef Global) -> Bool;\n+    fn LLVMGetLinkage(ValueRef Global) -> Linkage;\n+    fn LLVMSetLinkage(ValueRef Global, Linkage Link);\n+    fn LLVMGetSection(ValueRef Global) -> sbuf;\n+    fn LLVMSetSection(ValueRef Global, sbuf Section);\n+    fn LLVMGetVisibility(ValueRef Global) -> Visibility;\n+    fn LLVMSetVisibility(ValueRef Global, Visibility Viz);\n+    fn LLVMGetAlignment(ValueRef Global) -> uint;\n+    fn LLVMSetAlignment(ValueRef Global, uint Bytes);\n+\n+\n+    /* Operations on global variables */\n+    fn LLVMAddGlobal(ModuleRef M, TypeRef Ty, sbuf Name) -> ValueRef;\n+    fn LLVMAddGlobalInAddressSpace(ModuleRef M, TypeRef Ty,\n+                                   sbuf Name,\n+                                   uint AddressSpace) -> ValueRef;\n+    fn LLVMGetNamedGlobal(ModuleRef M, sbuf Name) -> ValueRef;\n+    fn LLVMGetFirstGlobal(ModuleRef M) -> ValueRef;\n+    fn LLVMGetLastGlobal(ModuleRef M) -> ValueRef;\n+    fn LLVMGetNextGlobal(ValueRef GlobalVar) -> ValueRef;\n+    fn LLVMGetPreviousGlobal(ValueRef GlobalVar) -> ValueRef;\n+    fn LLVMDeleteGlobal(ValueRef GlobalVar);\n+    fn LLVMGetInitializer(ValueRef GlobalVar) -> ValueRef;\n+    fn LLVMSetInitializer(ValueRef GlobalVar, ValueRef ConstantVal);\n+    fn LLVMIsThreadLocal(ValueRef GlobalVar) -> Bool;\n+    fn LLVMSetThreadLocal(ValueRef GlobalVar, Bool IsThreadLocal);\n+    fn LLVMIsGlobalConstant(ValueRef GlobalVar) -> Bool;\n+    fn LLVMSetGlobalConstant(ValueRef GlobalVar, Bool IsConstant);\n+\n+    /* Operations on aliases */\n+    fn LLVMAddAlias(ModuleRef M, TypeRef Ty, ValueRef Aliasee,\n                     sbuf Name) -> ValueRef;\n-  fn BuildFDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildURem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildSRem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildFRem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildShl(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildLShr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildAShr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildAnd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildOr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-             sbuf Name) -> ValueRef;\n-  fn BuildXor(BuilderRef B, ValueRef LHS, ValueRef RHS,\n-              sbuf Name) -> ValueRef;\n-  fn BuildBinOp(BuilderRef B, Opcode Op,\n-                ValueRef LHS, ValueRef RHS,\n-                sbuf Name) -> ValueRef;\n-  fn BuildNeg(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n-  fn BuildNSWNeg(BuilderRef B, ValueRef V,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildNUWNeg(BuilderRef B, ValueRef V,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildFNeg(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n-  fn BuildNot(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n-\n-  /* Memory */\n-  fn BuildMalloc(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n-  fn BuildArrayMalloc(BuilderRef B, TypeRef Ty,\n-                      ValueRef Val, sbuf Name) -> ValueRef;\n-  fn BuildAlloca(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n-  fn BuildArrayAlloca(BuilderRef B, TypeRef Ty,\n-                      ValueRef Val, sbuf Name) -> ValueRef;\n-  fn BuildFree(BuilderRef B, ValueRef PointerVal) -> ValueRef;\n-  fn BuildLoad(BuilderRef B, ValueRef PointerVal,\n-               sbuf Name) -> ValueRef;\n-  fn BuildStore(BuilderRef B, ValueRef Val, ValueRef Ptr) -> ValueRef;\n-  fn BuildGEP(BuilderRef B, ValueRef Pointer,\n-              vbuf Indices, uint NumIndices,\n-              sbuf Name) -> ValueRef;\n-  fn BuildInBoundsGEP(BuilderRef B, ValueRef Pointer,\n-                      vbuf Indices, uint NumIndices,\n-                      sbuf Name) -> ValueRef;\n-  fn BuildStructGEP(BuilderRef B, ValueRef Pointer,\n-                    uint Idx, sbuf Name) -> ValueRef;\n-  fn BuildGlobalString(BuilderRef B, sbuf Str,\n+\n+    /* Operations on functions */\n+    fn LLVMAddFunction(ModuleRef M, sbuf Name,\n+                       TypeRef FunctionTy) -> ValueRef;\n+    fn LLVMGetNamedFunction(ModuleRef M, sbuf Name) -> ValueRef;\n+    fn LLVMGetFirstFunction(ModuleRef M) -> ValueRef;\n+    fn LLVMGetLastFunction(ModuleRef M) -> ValueRef;\n+    fn LLVMGetNextFunction(ValueRef Fn) -> ValueRef;\n+    fn LLVMGetPreviousFunction(ValueRef Fn) -> ValueRef;\n+    fn LLVMDeleteFunction(ValueRef Fn);\n+    fn LLVMGetIntrinsicID(ValueRef Fn) -> uint;\n+    fn LLVMGetFunctionCallConv(ValueRef Fn) -> uint;\n+    fn LLVMSetFunctionCallConv(ValueRef Fn, uint CC);\n+    fn LLVMGetGC(ValueRef Fn) -> sbuf;\n+    fn LLVMSetGC(ValueRef Fn, sbuf Name);\n+    fn LLVMAddFunctionAttr(ValueRef Fn, Attribute PA);\n+    fn LLVMGetFunctionAttr(ValueRef Fn) -> Attribute;\n+    fn LLVMRemoveFunctionAttr(ValueRef Fn, Attribute PA);\n+\n+    /* Operations on parameters */\n+    fn LLVMCountParams(ValueRef Fn) -> uint;\n+    fn LLVMGetParams(ValueRef Fn, vbuf Params);\n+    fn LLVMGetParam(ValueRef Fn, uint Index) -> ValueRef;\n+    fn LLVMGetParamParent(ValueRef Inst) -> ValueRef;\n+    fn LLVMGetFirstParam(ValueRef Fn) -> ValueRef;\n+    fn LLVMGetLastParam(ValueRef Fn) -> ValueRef;\n+    fn LLVMGetNextParam(ValueRef Arg) -> ValueRef;\n+    fn LLVMGetPreviousParam(ValueRef Arg) -> ValueRef;\n+    fn LLVMAddAttribute(ValueRef Arg, Attribute PA);\n+    fn LLVMRemoveAttribute(ValueRef Arg, Attribute PA);\n+    fn LLVMGetAttribute(ValueRef Arg) -> Attribute;\n+    fn LLVMSetParamAlignment(ValueRef Arg, uint align);\n+\n+    /* Operations on basic blocks */\n+    fn LLVMBasicBlockAsValue(BasicBlockRef BB) -> ValueRef;\n+    fn LLVMValueIsBasicBlock(ValueRef Val) -> Bool;\n+    fn LLVMValueAsBasicBlock(ValueRef Val) -> BasicBlockRef;\n+    fn LLVMGetBasicBlockParent(BasicBlockRef BB) -> ValueRef;\n+    fn LLVMCountBasicBlocks(ValueRef Fn) -> uint;\n+    fn LLVMGetBasicBlocks(ValueRef Fn, vbuf BasicBlocks);\n+    fn LLVMGetFirstBasicBlock(ValueRef Fn) -> BasicBlockRef;\n+    fn LLVMGetLastBasicBlock(ValueRef Fn) -> BasicBlockRef;\n+    fn LLVMGetNextBasicBlock(BasicBlockRef BB) -> BasicBlockRef;\n+    fn LLVMGetPreviousBasicBlock(BasicBlockRef BB) -> BasicBlockRef;\n+    fn LLVMGetEntryBasicBlock(ValueRef Fn) -> BasicBlockRef;\n+\n+    fn LLVMAppendBasicBlockInContext(ContextRef C, ValueRef Fn,\n+                                     sbuf Name) -> BasicBlockRef;\n+    fn LLVMInsertBasicBlockInContext(ContextRef C, BasicBlockRef BB,\n+                                     sbuf Name) -> BasicBlockRef;\n+\n+    fn LLVMAppendBasicBlock(ValueRef Fn, sbuf Name) -> BasicBlockRef;\n+    fn LLVMInsertBasicBlock(BasicBlockRef InsertBeforeBB,\n+                            sbuf Name) -> BasicBlockRef;\n+    fn LLVMDeleteBasicBlock(BasicBlockRef BB);\n+\n+    /* Operations on instructions */\n+    fn LLVMGetInstructionParent(ValueRef Inst) -> BasicBlockRef;\n+    fn LLVMGetFirstInstruction(BasicBlockRef BB) -> ValueRef;\n+    fn LLVMGetLastInstruction(BasicBlockRef BB) -> ValueRef;\n+    fn LLVMGetNextInstruction(ValueRef Inst) -> ValueRef;\n+    fn LLVMGetPreviousInstruction(ValueRef Inst) -> ValueRef;\n+\n+    /* Operations on call sites */\n+    fn LLVMSetInstructionCallConv(ValueRef Instr, uint CC);\n+    fn LLVMGetInstructionCallConv(ValueRef Instr) -> uint;\n+    fn LLVMAddInstrAttribute(ValueRef Instr, uint index, Attribute IA);\n+    fn LLVMRemoveInstrAttribute(ValueRef Instr, uint index, Attribute IA);\n+    fn LLVMSetInstrParamAlignment(ValueRef Instr, uint index, uint align);\n+\n+    /* Operations on call instructions (only) */\n+    fn LLVMIsTailCall(ValueRef CallInst) -> Bool;\n+    fn LLVMSetTailCall(ValueRef CallInst, Bool IsTailCall);\n+\n+    /* Operations on phi nodes */\n+    fn LLVMAddIncoming(ValueRef PhiNode, vbuf IncomingValues,\n+                       vbuf IncomingBlocks, uint Count);\n+    fn LLVMCountIncoming(ValueRef PhiNode) -> uint;\n+    fn LLVMGetIncomingValue(ValueRef PhiNode, uint Index) -> ValueRef;\n+    fn LLVMGetIncomingBlock(ValueRef PhiNode, uint Index) -> BasicBlockRef;\n+\n+    /* Instruction builders */\n+    fn LLVMCreateBuilderInContext(ContextRef C) -> BuilderRef;\n+    fn LLVMCreateBuilder() -> BuilderRef;\n+    fn LLVMPositionBuilder(BuilderRef Builder, BasicBlockRef Block,\n+                           ValueRef Instr);\n+    fn LLVMPositionBuilderBefore(BuilderRef Builder, ValueRef Instr);\n+    fn LLVMPositionBuilderAtEnd(BuilderRef Builder, BasicBlockRef Block);\n+    fn LLVMGetInsertBlock(BuilderRef Builder) -> BasicBlockRef;\n+    fn LLVMClearInsertionPosition(BuilderRef Builder);\n+    fn LLVMInsertIntoBuilder(BuilderRef Builder, ValueRef Instr);\n+    fn LLVMInsertIntoBuilderWithName(BuilderRef Builder, ValueRef Instr,\n+                                     sbuf Name);\n+    fn LLVMDisposeBuilder(BuilderRef Builder);\n+\n+    /* Metadata */\n+    fn LLVMSetCurrentDebugLocation(BuilderRef Builder, ValueRef L);\n+    fn LLVMGetCurrentDebugLocation(BuilderRef Builder) -> ValueRef;\n+    fn LLVMSetInstDebugLocation(BuilderRef Builder, ValueRef Inst);\n+\n+    /* Terminators */\n+    fn LLVMBuildRetVoid(BuilderRef B) -> ValueRef;\n+    fn LLVMBuildRet(BuilderRef B, ValueRef V) -> ValueRef;\n+    fn LLVMBuildAggregateRet(BuilderRef B, vbuf RetVals,\n+                             uint N) -> ValueRef;\n+    fn LLVMBuildBr(BuilderRef B, BasicBlockRef Dest) -> ValueRef;\n+    fn LLVMBuildCondBr(BuilderRef B, ValueRef If,\n+                       BasicBlockRef Then, BasicBlockRef Else) -> ValueRef;\n+    fn LLVMBuildSwitch(BuilderRef B, ValueRef V,\n+                       BasicBlockRef Else, uint NumCases) -> ValueRef;\n+    fn LLVMBuildIndirectBr(BuilderRef B, ValueRef Addr,\n+                           uint NumDests) -> ValueRef;\n+    fn LLVMBuildInvoke(BuilderRef B, ValueRef Fn,\n+                       vbuf Args, uint NumArgs,\n+                       BasicBlockRef Then, BasicBlockRef Catch,\n                        sbuf Name) -> ValueRef;\n-  fn BuildGlobalStringPtr(BuilderRef B, sbuf Str,\n-                          sbuf Name) -> ValueRef;\n+    fn LLVMBuildUnwind(BuilderRef B) -> ValueRef;\n+    fn LLVMBuildUnreachable(BuilderRef B) -> ValueRef;\n \n-  /* Casts */\n-  fn BuildTrunc(BuilderRef B, ValueRef Val,\n-                TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildZExt(BuilderRef B, ValueRef Val,\n-               TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildSExt(BuilderRef B, ValueRef Val,\n-               TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildFPToUI(BuilderRef B, ValueRef Val,\n-                 TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildFPToSI(BuilderRef B, ValueRef Val,\n-                 TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildUIToFP(BuilderRef B, ValueRef Val,\n-                 TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildSIToFP(BuilderRef B, ValueRef Val,\n-                 TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildFPTrunc(BuilderRef B, ValueRef Val,\n-                  TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildFPExt(BuilderRef B, ValueRef Val,\n-                TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildPtrToInt(BuilderRef B, ValueRef Val,\n-                   TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildIntToPtr(BuilderRef B, ValueRef Val,\n-                   TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildBitCast(BuilderRef B, ValueRef Val,\n-                  TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildZExtOrBitCast(BuilderRef B, ValueRef Val,\n-                        TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildSExtOrBitCast(BuilderRef B, ValueRef Val,\n+    /* Add a case to the switch instruction */\n+    fn LLVMAddCase(ValueRef Switch, ValueRef OnVal,\n+                   BasicBlockRef Dest);\n+\n+    /* Add a destination to the indirectbr instruction */\n+    fn LLVMAddDestination(ValueRef IndirectBr, BasicBlockRef Dest);\n+\n+    /* Arithmetic */\n+    fn LLVMBuildAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildNSWAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildNUWAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildFAdd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildNSWSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildNUWSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildFSub(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildNSWMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildNUWMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildFMul(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildUDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildSDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildExactSDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                          sbuf Name) -> ValueRef;\n+    fn LLVMBuildFDiv(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildURem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildSRem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildFRem(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildShl(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildLShr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildAShr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildAnd(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildOr(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                   sbuf Name) -> ValueRef;\n+    fn LLVMBuildXor(BuilderRef B, ValueRef LHS, ValueRef RHS,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildBinOp(BuilderRef B, Opcode Op,\n+                      ValueRef LHS, ValueRef RHS,\n+                      sbuf Name) -> ValueRef;\n+    fn LLVMBuildNeg(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n+    fn LLVMBuildNSWNeg(BuilderRef B, ValueRef V,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildNUWNeg(BuilderRef B, ValueRef V,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildFNeg(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n+    fn LLVMBuildNot(BuilderRef B, ValueRef V, sbuf Name) -> ValueRef;\n+\n+    /* Memory */\n+    fn LLVMBuildMalloc(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n+    fn LLVMBuildArrayMalloc(BuilderRef B, TypeRef Ty,\n+                            ValueRef Val, sbuf Name) -> ValueRef;\n+    fn LLVMBuildAlloca(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n+    fn LLVMBuildArrayAlloca(BuilderRef B, TypeRef Ty,\n+                            ValueRef Val, sbuf Name) -> ValueRef;\n+    fn LLVMBuildFree(BuilderRef B, ValueRef PointerVal) -> ValueRef;\n+    fn LLVMBuildLoad(BuilderRef B, ValueRef PointerVal,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildStore(BuilderRef B, ValueRef Val, ValueRef Ptr) -> ValueRef;\n+    fn LLVMBuildGEP(BuilderRef B, ValueRef Pointer,\n+                    vbuf Indices, uint NumIndices,\n+                    sbuf Name) -> ValueRef;\n+    fn LLVMBuildInBoundsGEP(BuilderRef B, ValueRef Pointer,\n+                            vbuf Indices, uint NumIndices,\n+                            sbuf Name) -> ValueRef;\n+    fn LLVMBuildStructGEP(BuilderRef B, ValueRef Pointer,\n+                          uint Idx, sbuf Name) -> ValueRef;\n+    fn LLVMBuildGlobalString(BuilderRef B, sbuf Str,\n+                             sbuf Name) -> ValueRef;\n+    fn LLVMBuildGlobalStringPtr(BuilderRef B, sbuf Str,\n+                                sbuf Name) -> ValueRef;\n+\n+    /* Casts */\n+    fn LLVMBuildTrunc(BuilderRef B, ValueRef Val,\n+                      TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildZExt(BuilderRef B, ValueRef Val,\n+                     TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildSExt(BuilderRef B, ValueRef Val,\n+                     TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildFPToUI(BuilderRef B, ValueRef Val,\n+                       TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildFPToSI(BuilderRef B, ValueRef Val,\n+                       TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildUIToFP(BuilderRef B, ValueRef Val,\n+                       TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildSIToFP(BuilderRef B, ValueRef Val,\n+                       TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildFPTrunc(BuilderRef B, ValueRef Val,\n                         TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildTruncOrBitCast(BuilderRef B, ValueRef Val,\n-                         TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildCast(BuilderRef B, Opcode Op, ValueRef Val,\n-               TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildPointerCast(BuilderRef B, ValueRef Val,\n+    fn LLVMBuildFPExt(BuilderRef B, ValueRef Val,\n                       TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildIntCast(BuilderRef B, ValueRef Val,\n-                  TypeRef DestTy, sbuf Name) -> ValueRef;\n-  fn BuildFPCast(BuilderRef B, ValueRef Val,\n-                 TypeRef DestTy, sbuf Name) -> ValueRef;\n-\n-  /* Comparisons */\n-  fn BuildICmp(BuilderRef B, IntPredicate Op,\n-               ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-  fn BuildFCmp(BuilderRef B, RealPredicate Op,\n-               ValueRef LHS, ValueRef RHS,\n-               sbuf Name) -> ValueRef;\n-\n-  /* Miscellaneous instructions */\n-  fn BuildPhi(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n-  fn BuildCall(BuilderRef B, ValueRef Fn,\n-               vbuf Args, uint NumArgs,\n-               sbuf Name) -> ValueRef;\n-  fn BuildSelect(BuilderRef B, ValueRef If,\n-                 ValueRef Then, ValueRef Else,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildVAArg(BuilderRef B, ValueRef List, TypeRef Ty,\n-                sbuf Name) -> ValueRef;\n-  fn BuildExtractElement(BuilderRef B, ValueRef VecVal,\n-                         ValueRef Index, sbuf Name) -> ValueRef;\n-  fn BuildInsertElement(BuilderRef B, ValueRef VecVal,\n-                        ValueRef EltVal, ValueRef Index,\n-                        sbuf Name) -> ValueRef;\n-  fn BuildShuffleVector(BuilderRef B, ValueRef V1,\n-                        ValueRef V2, ValueRef Mask,\n-                        sbuf Name) -> ValueRef;\n-  fn BuildExtractValue(BuilderRef B, ValueRef AggVal,\n-                       uint Index, sbuf Name) -> ValueRef;\n-  fn BuildInsertValue(BuilderRef B, ValueRef AggVal,\n-                      ValueRef EltVal, uint Index,\n+    fn LLVMBuildPtrToInt(BuilderRef B, ValueRef Val,\n+                         TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildIntToPtr(BuilderRef B, ValueRef Val,\n+                         TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildBitCast(BuilderRef B, ValueRef Val,\n+                        TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildZExtOrBitCast(BuilderRef B, ValueRef Val,\n+                              TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildSExtOrBitCast(BuilderRef B, ValueRef Val,\n+                              TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildTruncOrBitCast(BuilderRef B, ValueRef Val,\n+                               TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildCast(BuilderRef B, Opcode Op, ValueRef Val,\n+                     TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildPointerCast(BuilderRef B, ValueRef Val,\n+                            TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildIntCast(BuilderRef B, ValueRef Val,\n+                        TypeRef DestTy, sbuf Name) -> ValueRef;\n+    fn LLVMBuildFPCast(BuilderRef B, ValueRef Val,\n+                       TypeRef DestTy, sbuf Name) -> ValueRef;\n+\n+    /* Comparisons */\n+    fn LLVMBuildICmp(BuilderRef B, IntPredicate Op,\n+                     ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildFCmp(BuilderRef B, RealPredicate Op,\n+                     ValueRef LHS, ValueRef RHS,\n+                     sbuf Name) -> ValueRef;\n+\n+    /* Miscellaneous instructions */\n+    fn LLVMBuildPhi(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n+    fn LLVMBuildCall(BuilderRef B, ValueRef Fn,\n+                     vbuf Args, uint NumArgs,\n+                     sbuf Name) -> ValueRef;\n+    fn LLVMBuildSelect(BuilderRef B, ValueRef If,\n+                       ValueRef Then, ValueRef Else,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildVAArg(BuilderRef B, ValueRef List, TypeRef Ty,\n                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildExtractElement(BuilderRef B, ValueRef VecVal,\n+                               ValueRef Index, sbuf Name) -> ValueRef;\n+    fn LLVMBuildInsertElement(BuilderRef B, ValueRef VecVal,\n+                              ValueRef EltVal, ValueRef Index,\n+                              sbuf Name) -> ValueRef;\n+    fn LLVMBuildShuffleVector(BuilderRef B, ValueRef V1,\n+                              ValueRef V2, ValueRef Mask,\n+                              sbuf Name) -> ValueRef;\n+    fn LLVMBuildExtractValue(BuilderRef B, ValueRef AggVal,\n+                             uint Index, sbuf Name) -> ValueRef;\n+    fn LLVMBuildInsertValue(BuilderRef B, ValueRef AggVal,\n+                            ValueRef EltVal, uint Index,\n+                            sbuf Name) -> ValueRef;\n+\n+    fn LLVMBuildIsNull(BuilderRef B, ValueRef Val,\n+                       sbuf Name) -> ValueRef;\n+    fn LLVMBuildIsNotNull(BuilderRef B, ValueRef Val,\n+                          sbuf Name) -> ValueRef;\n+    fn LLVMBuildPtrDiff(BuilderRef B, ValueRef LHS,\n+                        ValueRef RHS, sbuf Name) -> ValueRef;\n \n-  fn BuildIsNull(BuilderRef B, ValueRef Val,\n-                 sbuf Name) -> ValueRef;\n-  fn BuildIsNotNull(BuilderRef B, ValueRef Val,\n-                    sbuf Name) -> ValueRef;\n-  fn BuildPtrDiff(BuilderRef B, ValueRef LHS,\n-                  ValueRef RHS, sbuf Name) -> ValueRef;\n \n+    /** Writes a module to the specified path. Returns 0 on success. */\n+    fn LLVMWriteBitcodeToFile(ModuleRef M, sbuf Path) -> int;\n+}\n+\n+/* Slightly more terse object-interface to LLVM's 'builder' functions. */\n+\n+obj builder(BuilderRef B) {\n+\n+    /* Terminators */\n+    fn RetVoid()  -> ValueRef {\n+        ret llvm.LLVMBuildRetVoid(B);\n+    }\n+\n+    fn Ret(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildRet(B, V);\n+    }\n+\n+    fn AggregateRet(vbuf RetVals, uint N) -> ValueRef {\n+        ret llvm.LLVMBuildAggregateRet(B, RetVals, N);\n+    }\n+\n+    fn Br(BasicBlockRef Dest) -> ValueRef {\n+        ret llvm.LLVMBuildBr(B, Dest);\n+    }\n+\n+    fn CondBr(ValueRef If, BasicBlockRef Then,\n+              BasicBlockRef Else) -> ValueRef {\n+        ret llvm.LLVMBuildCondBr(B, If, Then, Else);\n+    }\n+\n+    fn Switch(ValueRef V, BasicBlockRef Else, uint NumCases) -> ValueRef {\n+        ret llvm.LLVMBuildSwitch(B, V, Else, NumCases);\n+    }\n+\n+    fn IndirectBr(ValueRef Addr, uint NumDests) -> ValueRef {\n+        ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n+    }\n+\n+    fn Invoke(ValueRef Fn, vbuf Args, uint NumArgs,\n+              BasicBlockRef Then, BasicBlockRef Catch,\n+              sbuf Name) -> ValueRef {\n+        ret llvm.LLVMBuildInvoke(B, Fn, Args, NumArgs,\n+                                 Then, Catch, Name);\n+    }\n+\n+    fn Unwind() -> ValueRef {\n+        ret llvm.LLVMBuildUnwind(B);\n+    }\n+\n+    fn Unreachable() -> ValueRef {\n+        ret llvm.LLVMBuildUnreachable(B);\n+    }\n+\n+    /* Arithmetic */\n+    fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildAdd(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, 0 as sbuf);\n+    }\n \n+    fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFAdd(B, LHS, RHS, 0 as sbuf);\n+    }\n \n+    fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildSub(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFSub(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildMul(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFMul(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildUDiv(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildSDiv(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFDiv(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildURem(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildSRem(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFRem(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildShl(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildLShr(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildAShr(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildAnd(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildOr(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildXor(B, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, 0 as sbuf);\n+    }\n+\n+    fn Neg(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildNeg(B, V, 0 as sbuf);\n+    }\n+\n+    fn NSWNeg(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildNSWNeg(B, V, 0 as sbuf);\n+    }\n+\n+    fn NUWNeg(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildNUWNeg(B, V, 0 as sbuf);\n+    }\n+    fn FNeg(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildFNeg(B, V, 0 as sbuf);\n+    }\n+    fn Not(ValueRef V) -> ValueRef {\n+        ret llvm.LLVMBuildNot(B, V, 0 as sbuf);\n+    }\n+\n+    /* Memory */\n+    fn Malloc(TypeRef Ty) -> ValueRef {\n+        ret llvm.LLVMBuildMalloc(B, Ty, 0 as sbuf);\n+    }\n+\n+    fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n+        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, 0 as sbuf);\n+    }\n+\n+    fn Alloca(TypeRef Ty) -> ValueRef {\n+        ret llvm.LLVMBuildAlloca(B, Ty, 0 as sbuf);\n+    }\n+\n+    fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n+        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, 0 as sbuf);\n+    }\n+\n+    fn Free(ValueRef PointerVal) -> ValueRef {\n+        ret llvm.LLVMBuildFree(B, PointerVal);\n+    }\n+\n+    fn Load(ValueRef PointerVal) -> ValueRef {\n+        ret llvm.LLVMBuildLoad(B, PointerVal, 0 as sbuf);\n+    }\n+\n+    fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n+        ret llvm.LLVMBuildStore(B, Val, Ptr);\n+    }\n+\n+    fn GEP(ValueRef Pointer, vbuf Indices, uint NumIndices,\n+           sbuf Name) -> ValueRef {\n+        ret llvm.LLVMBuildGEP(B, Pointer, Indices, NumIndices, 0 as sbuf);\n+    }\n+\n+    fn InBoundsGEP(ValueRef Pointer, vbuf Indices, uint NumIndices,\n+                   sbuf Name) -> ValueRef {\n+        ret llvm.LLVMBuildInBoundsGEP(B, Pointer, Indices,\n+                                      NumIndices, 0 as sbuf);\n+    }\n+\n+    fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n+        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, 0 as sbuf);\n+    }\n+\n+    fn GlobalString(sbuf Str) -> ValueRef {\n+        ret llvm.LLVMBuildGlobalString(B, Str, 0 as sbuf);\n+    }\n+\n+    fn GlobalStringPtr(sbuf Str) -> ValueRef {\n+        ret llvm.LLVMBuildGlobalStringPtr(B, Str, 0 as sbuf);\n+    }\n+\n+    drop {\n+        llvm.LLVMDisposeBuilder(B);\n+    }\n }\n \n //"}, {"sha": "77b898062e9dc6ce999710789e83308ef1d92373", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f2c39b3d8de09ca4b58a22b5f59115191262fd7/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3f2c39b3d8de09ca4b58a22b5f59115191262fd7/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=3f2c39b3d8de09ca4b58a22b5f59115191262fd7", "patch": "@@ -13,20 +13,22 @@ mod driver {\n     mod rustc;\n }\n \n+auth driver = unsafe;\n+\n mod lib {\n   alt (target_os) {\n     case (\"win32\") {\n-      let (llvm_lib = \"llvm-2.8svn.dll\") {\n+      let (llvm_lib = \"LLVM-2.8svn.dll\") {\n         mod llvm;\n       }\n     }\n     case (\"macos\") {\n-      let (llvm_lib = \"libllvm-2.8svn.dylib\") {\n+      let (llvm_lib = \"libLLVM-2.8svn.dylib\") {\n         mod llvm;\n       }\n     }\n     else {\n-      let (llvm_lib = \"libllvm-2.8svn.so\") {\n+      let (llvm_lib = \"libLLVM-2.8svn.so\") {\n         mod llvm;\n       }\n     }"}]}