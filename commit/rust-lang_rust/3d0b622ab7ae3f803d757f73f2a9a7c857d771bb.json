{"sha": "3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMGI2MjJhYjdhZTNmODAzZDc1N2Y3M2YyYTlhN2M4NTdkNzcxYmI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-22T15:58:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-04T22:33:43Z"}, "message": "expand: Less path cloning during module loading", "tree": {"sha": "1ebea1b273a36d9c7dd155126e89b87d90d4dd97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ebea1b273a36d9c7dd155126e89b87d90d4dd97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "html_url": "https://github.com/rust-lang/rust/commit/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bdf81d5fa7ada2274617ebfa97e6bd157ae5a52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bdf81d5fa7ada2274617ebfa97e6bd157ae5a52", "html_url": "https://github.com/rust-lang/rust/commit/5bdf81d5fa7ada2274617ebfa97e6bd157ae5a52"}], "stats": {"total": 88, "additions": 51, "deletions": 37}, "files": [{"sha": "a81bc381c508a378717335572e203deaa9cfd163", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "patch": "@@ -3,7 +3,7 @@ use crate::config::StripUnconfigured;\n use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n-use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n+use crate::module::{parse_external_mod, push_directory, DirectoryOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n use rustc_ast as ast;\n@@ -1277,28 +1277,36 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n-                let dir = Directory {\n-                    ownership: self.cx.current_expansion.directory_ownership,\n-                    path: self.cx.current_expansion.module.dir_path.clone(),\n-                };\n-                let (file_path, Directory { ownership, path }) = match mod_kind {\n+                let (file_path, dir_path, dir_ownership) = match mod_kind {\n                     ModKind::Loaded(_, Inline::Yes, _) => {\n                         // Inline `mod foo { ... }`, but we still need to push directories.\n-                        let dir_path = push_directory(&self.cx.sess, ident, &attrs, dir);\n+                        let (dir_path, dir_ownership) = push_directory(\n+                            &self.cx.sess,\n+                            ident,\n+                            &attrs,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.directory_ownership,\n+                        );\n                         item.attrs = attrs;\n-                        (None, dir_path)\n+                        (None, dir_path, dir_ownership)\n                     }\n                     ModKind::Loaded(_, Inline::No, _) => {\n                         panic!(\"`mod` item is loaded from a file for the second time\")\n                     }\n                     ModKind::Unloaded => {\n                         // We have an outline `mod foo;` so we need to parse the file.\n-                        let (items, inner_span, file_path, dir_path) = parse_external_mod(\n+                        let ParsedExternalMod {\n+                            items,\n+                            inner_span,\n+                            file_path,\n+                            dir_path,\n+                            dir_ownership,\n+                        } = parse_external_mod(\n                             &self.cx.sess,\n                             ident,\n                             span,\n-                            &self.cx.current_expansion.module.file_path_stack,\n-                            dir,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.directory_ownership,\n                             &mut attrs,\n                         );\n \n@@ -1312,12 +1320,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         item.attrs = krate.attrs;\n                         // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n                         item = configure!(self, item);\n-                        (Some(file_path), dir_path)\n+                        (Some(file_path), dir_path, dir_ownership)\n                     }\n                 };\n \n                 // Set the module info before we flat map.\n-                let mut module = self.cx.current_expansion.module.with_dir_path(path);\n+                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n                 module.mod_path.push(ident);\n                 if let Some(file_path) = file_path {\n                     module.file_path_stack.push(file_path);\n@@ -1326,7 +1334,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let orig_dir_ownership =\n-                    mem::replace(&mut self.cx.current_expansion.directory_ownership, ownership);\n+                    mem::replace(&mut self.cx.current_expansion.directory_ownership, dir_ownership);\n \n                 let result = noop_flat_map_item(item, self);\n "}, {"sha": "4ba24ace8eb8c3cb22382ba5646a63d33824bc21", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d0b622ab7ae3f803d757f73f2a9a7c857d771bb/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=3d0b622ab7ae3f803d757f73f2a9a7c857d771bb", "patch": "@@ -1,3 +1,4 @@\n+use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n use rustc_ast::{token, Attribute, Item};\n use rustc_errors::{struct_span_err, PResult};\n@@ -9,12 +10,6 @@ use rustc_span::Span;\n \n use std::path::{self, Path, PathBuf};\n \n-#[derive(Clone)]\n-pub struct Directory {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n-}\n-\n #[derive(Copy, Clone)]\n pub enum DirectoryOwnership {\n     Owned {\n@@ -38,22 +33,30 @@ pub struct ModulePathSuccess {\n     pub ownership: DirectoryOwnership,\n }\n \n+crate struct ParsedExternalMod {\n+    pub items: Vec<P<Item>>,\n+    pub inner_span: Span,\n+    pub file_path: PathBuf,\n+    pub dir_path: PathBuf,\n+    pub dir_ownership: DirectoryOwnership,\n+}\n+\n crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n-    file_path_stack: &[PathBuf],\n-    Directory { mut ownership, path }: Directory,\n+    module: &ModuleData,\n+    mut dir_ownership: DirectoryOwnership,\n     attrs: &mut Vec<Attribute>,\n-) -> (Vec<P<Item>>, Span, PathBuf, Directory) {\n+) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n-        let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n-        ownership = mp.ownership;\n+        let mp = submod_path(sess, id, span, &attrs, dir_ownership, &module.dir_path)?;\n+        dir_ownership = mp.ownership;\n \n         // Ensure file paths are acyclic.\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, file_path_stack)?;\n+        error_on_circular_module(&sess.parse_sess, span, &mp.path, &module.file_path_stack)?;\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n@@ -65,9 +68,9 @@ crate fn parse_external_mod(\n     let (items, inner_span, file_path) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n \n     // Extract the directory path for submodules of the module.\n-    let path = file_path.parent().unwrap_or(&file_path).to_owned();\n+    let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n \n-    (items, inner_span, file_path, Directory { ownership, path })\n+    ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership }\n }\n \n fn error_on_circular_module<'a>(\n@@ -92,27 +95,30 @@ crate fn push_directory(\n     sess: &Session,\n     id: Ident,\n     attrs: &[Attribute],\n-    Directory { mut ownership, mut path }: Directory,\n-) -> Directory {\n-    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n-        path.push(&*filename.as_str());\n-        ownership = DirectoryOwnership::Owned { relative: None };\n+    module: &ModuleData,\n+    mut dir_ownership: DirectoryOwnership,\n+) -> (PathBuf, DirectoryOwnership) {\n+    let mut dir_path = module.dir_path.clone();\n+    if let Some(file_path) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n+        dir_path.push(&*file_path.as_str());\n+        dir_ownership = DirectoryOwnership::Owned { relative: None };\n     } else {\n         // We have to push on the current module name in the case of relative\n         // paths in order to ensure that any additional module paths from inline\n         // `mod x { ... }` come after the relative extension.\n         //\n         // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n         // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n+        if let DirectoryOwnership::Owned { relative } = &mut dir_ownership {\n             if let Some(ident) = relative.take() {\n                 // Remove the relative offset.\n-                path.push(&*ident.as_str());\n+                dir_path.push(&*ident.as_str());\n             }\n         }\n-        path.push(&*id.as_str());\n+        dir_path.push(&*id.as_str());\n     }\n-    Directory { ownership, path }\n+\n+    (dir_path, dir_ownership)\n }\n \n fn submod_path<'a>("}]}