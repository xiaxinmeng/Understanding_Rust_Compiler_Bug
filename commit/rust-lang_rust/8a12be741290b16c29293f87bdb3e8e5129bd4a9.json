{"sha": "8a12be741290b16c29293f87bdb3e8e5129bd4a9", "node_id": "C_kwDOAAsO6NoAKDhhMTJiZTc0MTI5MGIxNmMyOTI5M2Y4N2JkYjNlOGU1MTI5YmQ0YTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-27T21:29:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-27T21:29:19Z"}, "message": "Auto merge of #89249 - Aaron1011:higher-ranked-cause, r=estebank\n\nImprove cause information for NLL higher-ranked errors\n\nThis PR has several interconnected pieces:\n\n1. In some of the NLL region error code, we now pass\n   around an `ObligationCause`, instead of just a plain `Span`.\n   This gets forwarded into `fulfill_cx.register_predicate_obligation`\n   during error reporting.\n2. The general InferCtxt error reporting code is extended to\n   handle `ObligationCauseCode::BindingObligation`\n3. A new enum variant `ConstraintCategory::Predicate` is added.\n   We try to avoid using this as the 'best blame constraint' - instead,\n   we use it to enhance the `ObligationCause` of the `BlameConstraint`\n   that we do end up choosing.\n\nAs a result, several NLL error messages now contain the same\n\"the lifetime requirement is introduced here\" message as non-NLL\nerrors.\n\nHaving an `ObligationCause` available will likely prove useful\nfor future improvements to NLL error messages.", "tree": {"sha": "8f10ec28936aa5bc33fcd1b19880a89c23ddfec5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f10ec28936aa5bc33fcd1b19880a89c23ddfec5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a12be741290b16c29293f87bdb3e8e5129bd4a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a12be741290b16c29293f87bdb3e8e5129bd4a9", "html_url": "https://github.com/rust-lang/rust/commit/8a12be741290b16c29293f87bdb3e8e5129bd4a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a12be741290b16c29293f87bdb3e8e5129bd4a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98c8619502093f34ca82f8f26ccf32e753924440", "url": "https://api.github.com/repos/rust-lang/rust/commits/98c8619502093f34ca82f8f26ccf32e753924440", "html_url": "https://github.com/rust-lang/rust/commit/98c8619502093f34ca82f8f26ccf32e753924440"}, {"sha": "41ad383e111423ba3f3062ede1354da4e0673e3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/41ad383e111423ba3f3062ede1354da4e0673e3d", "html_url": "https://github.com/rust-lang/rust/commit/41ad383e111423ba3f3062ede1354da4e0673e3d"}], "stats": {"total": 295, "additions": 209, "deletions": 86}, "files": [{"sha": "366ade1a71388940210cec5d8f6a3d699dfb8bcf", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 73, "deletions": 45, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n-use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_span};\n+use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use std::fmt;\n use std::rc::Rc;\n@@ -45,21 +45,20 @@ impl UniverseInfo<'tcx> {\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         placeholder: ty::PlaceholderRegion,\n         error_element: RegionElement,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n     ) {\n         match self.0 {\n             UniverseInfoInner::RelateTys { expected, found } => {\n-                let body_id = mbcx.infcx.tcx.hir().local_def_id_to_hir_id(mbcx.mir_def_id());\n                 let err = mbcx.infcx.report_mismatched_types(\n-                    &ObligationCause::misc(span, body_id),\n+                    &cause,\n                     expected,\n                     found,\n                     TypeError::RegionsPlaceholderMismatch,\n                 );\n                 err.buffer(&mut mbcx.errors_buffer);\n             }\n             UniverseInfoInner::TypeOp(ref type_op_info) => {\n-                type_op_info.report_error(mbcx, placeholder, error_element, span);\n+                type_op_info.report_error(mbcx, placeholder, error_element, cause);\n             }\n             UniverseInfoInner::Other => {\n                 // FIXME: This error message isn't great, but it doesn't show\n@@ -68,7 +67,7 @@ impl UniverseInfo<'tcx> {\n                 mbcx.infcx\n                     .tcx\n                     .sess\n-                    .struct_span_err(span, \"higher-ranked subtype error\")\n+                    .struct_span_err(cause.span, \"higher-ranked subtype error\")\n                     .buffer(&mut mbcx.errors_buffer);\n             }\n         }\n@@ -130,7 +129,7 @@ trait TypeOpInfo<'tcx> {\n     fn nice_error(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>>;\n@@ -140,7 +139,7 @@ trait TypeOpInfo<'tcx> {\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         placeholder: ty::PlaceholderRegion,\n         error_element: RegionElement,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n     ) {\n         let tcx = mbcx.infcx.tcx;\n         let base_universe = self.base_universe();\n@@ -150,7 +149,7 @@ trait TypeOpInfo<'tcx> {\n         {\n             adjusted\n         } else {\n-            self.fallback_error(tcx, span).buffer(&mut mbcx.errors_buffer);\n+            self.fallback_error(tcx, cause.span).buffer(&mut mbcx.errors_buffer);\n             return;\n         };\n \n@@ -175,7 +174,8 @@ trait TypeOpInfo<'tcx> {\n \n         debug!(?placeholder_region);\n \n-        let nice_error = self.nice_error(tcx, span, placeholder_region, error_region);\n+        let span = cause.span;\n+        let nice_error = self.nice_error(tcx, cause, placeholder_region, error_region);\n \n         if let Some(nice_error) = nice_error {\n             nice_error.buffer(&mut mbcx.errors_buffer);\n@@ -205,15 +205,24 @@ impl TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n     fn nice_error(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n-            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n-            type_op_prove_predicate_with_span(infcx, &mut *fulfill_cx, key, Some(span));\n-            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n-        })\n+        tcx.infer_ctxt().enter_with_canonical(\n+            cause.span,\n+            &self.canonical_query,\n+            |ref infcx, key, _| {\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n+                try_extract_error_from_fulfill_cx(\n+                    fulfill_cx,\n+                    infcx,\n+                    placeholder_region,\n+                    error_region,\n+                )\n+            },\n+        )\n     }\n }\n \n@@ -239,32 +248,41 @@ where\n     fn nice_error(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n-            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n-\n-            let mut selcx = SelectionContext::new(infcx);\n-\n-            // FIXME(lqd): Unify and de-duplicate the following with the actual\n-            // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n-            // `ObligationCause`. The normalization results are currently different between\n-            // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n-            // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n-            // after #85499 lands to see if its fixes have erased this difference.\n-            let (param_env, value) = key.into_parts();\n-            let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n-                &mut selcx,\n-                param_env,\n-                ObligationCause::dummy_with_span(span),\n-                value.value,\n-            );\n-            fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n-        })\n+        tcx.infer_ctxt().enter_with_canonical(\n+            cause.span,\n+            &self.canonical_query,\n+            |ref infcx, key, _| {\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+\n+                let mut selcx = SelectionContext::new(infcx);\n+\n+                // FIXME(lqd): Unify and de-duplicate the following with the actual\n+                // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n+                // `ObligationCause`. The normalization results are currently different between\n+                // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n+                // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n+                // after #85499 lands to see if its fixes have erased this difference.\n+                let (param_env, value) = key.into_parts();\n+                let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n+                    &mut selcx,\n+                    param_env,\n+                    cause,\n+                    value.value,\n+                );\n+                fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                try_extract_error_from_fulfill_cx(\n+                    fulfill_cx,\n+                    infcx,\n+                    placeholder_region,\n+                    error_region,\n+                )\n+            },\n+        )\n     }\n }\n \n@@ -287,15 +305,25 @@ impl TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     fn nice_error(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        span: Span,\n+        cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(span, &self.canonical_query, |ref infcx, key, _| {\n-            let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n-            type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(span)).ok()?;\n-            try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n-        })\n+        tcx.infer_ctxt().enter_with_canonical(\n+            cause.span,\n+            &self.canonical_query,\n+            |ref infcx, key, _| {\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n+                    .ok()?;\n+                try_extract_error_from_fulfill_cx(\n+                    fulfill_cx,\n+                    infcx,\n+                    placeholder_region,\n+                    error_region,\n+                )\n+            },\n+        )\n     }\n }\n "}, {"sha": "d5de0801ac4431ccfcaab25872a16923501b8925", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -300,7 +300,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let BlameConstraint { category, from_closure, span, variance_info: _ } =\n+        let BlameConstraint { category, from_closure, cause, variance_info: _ } =\n             self.regioncx.best_blame_constraint(\n                 &self.body,\n                 borrow_region,\n@@ -310,7 +310,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n \n-        (category, from_closure, span, outlived_fr_name)\n+        (category, from_closure, cause.span, outlived_fr_name)\n     }\n \n     /// Returns structured explanation for *why* the borrow contains the"}, {"sha": "d05cfebc5f02e113d6d887eb41adb7e2f8c51e34", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -13,6 +13,7 @@ use rustc_span::{BytePos, Span};\n \n use crate::borrowck_errors;\n \n+use super::{OutlivesSuggestionBuilder, RegionName};\n use crate::region_infer::BlameConstraint;\n use crate::{\n     nll::ConstraintDescription,\n@@ -21,8 +22,6 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionName};\n-\n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n@@ -41,7 +40,8 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::OpaqueType => \"opaque type \",\n             ConstraintCategory::ClosureUpvar(_) => \"closure capture \",\n             ConstraintCategory::Usage => \"this usage \",\n-            ConstraintCategory::Boring\n+            ConstraintCategory::Predicate(_)\n+            | ConstraintCategory::Boring\n             | ConstraintCategory::BoringNoLocation\n             | ConstraintCategory::Internal => \"\",\n         }\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let error_vid = self.regioncx.region_from_element(longer_fr, &error_element);\n \n                     // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-                    let (_, span) = self.regioncx.find_outlives_blame_span(\n+                    let (_, cause) = self.regioncx.find_outlives_blame_span(\n                         &self.body,\n                         longer_fr,\n                         NllRegionVariableOrigin::Placeholder(placeholder),\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let universe = placeholder.universe;\n                     let universe_info = self.regioncx.universe_info(universe);\n \n-                    universe_info.report_error(self, placeholder, error_element, span);\n+                    universe_info.report_error(self, placeholder, error_element, cause);\n                 }\n \n                 RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n@@ -275,15 +275,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let BlameConstraint { category, span, variance_info, from_closure: _ } =\n+        let BlameConstraint { category, cause, variance_info, from_closure: _ } =\n             self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n \n-        debug!(\"report_region_error: category={:?} {:?} {:?}\", category, span, variance_info);\n+        debug!(\"report_region_error: category={:?} {:?} {:?}\", category, cause, variance_info);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f);\n+            let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 diag.buffer(&mut self.errors_buffer);\n                 return;\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             fr_is_local,\n             outlived_fr_is_local,\n             category,\n-            span,\n+            span: cause.span,\n         };\n \n         let mut diag = match (category, fr_is_local, outlived_fr_is_local) {"}, {"sha": "917d69a5c866446ac4fc7ac6046d40642341326e", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -5,7 +5,8 @@ use rustc_data_structures::binary_search_util;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n@@ -14,6 +15,8 @@ use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n     ConstraintCategory, Local, Location, ReturnConstraint,\n };\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n \n@@ -1596,7 +1599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                         subject: ClosureOutlivesSubject::Region(fr_minus),\n                         outlived_free_region: fr,\n-                        blame_span: blame_span_category.1,\n+                        blame_span: blame_span_category.1.span,\n                         category: blame_span_category.0,\n                     });\n                 }\n@@ -1738,7 +1741,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 return BlameConstraint {\n                     category: constraint.category,\n                     from_closure: false,\n-                    span,\n+                    cause: ObligationCause::dummy_with_span(span),\n                     variance_info: constraint.variance_info,\n                 };\n             }\n@@ -1751,30 +1754,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|&(category, span)| BlameConstraint {\n                 category,\n                 from_closure: true,\n-                span: span,\n+                cause: ObligationCause::dummy_with_span(span),\n                 variance_info: constraint.variance_info,\n             })\n             .unwrap_or(BlameConstraint {\n                 category: constraint.category,\n                 from_closure: false,\n-                span: body.source_info(loc).span,\n+                cause: ObligationCause::dummy_with_span(body.source_info(loc).span),\n                 variance_info: constraint.variance_info,\n             })\n     }\n \n-    /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     crate fn find_outlives_blame_span(\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n-    ) -> (ConstraintCategory, Span) {\n-        let BlameConstraint { category, span, .. } =\n+    ) -> (ConstraintCategory, ObligationCause<'tcx>) {\n+        let BlameConstraint { category, cause, .. } =\n             self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n                 self.provides_universal_region(r, fr1, fr2)\n             });\n-        (category, span)\n+        (category, cause)\n     }\n \n     /// Walks the graph of constraints (where `'a: 'b` is considered\n@@ -1990,6 +1993,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .collect::<Vec<_>>()\n         );\n \n+        // We try to avoid reporting a `ConstraintCategory::Predicate` as our best constraint.\n+        // Instead, we use it to produce an improved `ObligationCauseCode`.\n+        // FIXME - determine what we should do if we encounter multiple `ConstraintCategory::Predicate`\n+        // constraints. Currently, we just pick the first one.\n+        let cause_code = path\n+            .iter()\n+            .find_map(|constraint| {\n+                if let ConstraintCategory::Predicate(predicate_span) = constraint.category {\n+                    // We currentl'y doesn't store the `DefId` in the `ConstraintCategory`\n+                    // for perforamnce reasons. The error reporting code used by NLL only\n+                    // uses the span, so this doesn't cause any problems at the moment.\n+                    Some(ObligationCauseCode::BindingObligation(\n+                        CRATE_DEF_ID.to_def_id(),\n+                        predicate_span,\n+                    ))\n+                } else {\n+                    None\n+                }\n+            })\n+            .unwrap_or_else(|| ObligationCauseCode::MiscObligation);\n+\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n@@ -2000,7 +2024,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     BlameConstraint {\n                         category: constraint.category,\n                         from_closure: false,\n-                        span: constraint.locations.span(body),\n+                        cause: ObligationCause::new(\n+                            constraint.locations.span(body),\n+                            CRATE_HIR_ID,\n+                            cause_code.clone(),\n+                        ),\n                         variance_info: constraint.variance_info,\n                     }\n                 }\n@@ -2083,7 +2111,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n+                    | ConstraintCategory::Internal\n+                    | ConstraintCategory::Predicate(_) => false,\n                     ConstraintCategory::TypeAnnotation\n                     | ConstraintCategory::Return(_)\n                     | ConstraintCategory::Yield => true,\n@@ -2094,7 +2123,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n+                    | ConstraintCategory::Internal\n+                    | ConstraintCategory::Predicate(_) => false,\n                     _ => true,\n                 }\n             }\n@@ -2249,6 +2279,6 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n pub struct BlameConstraint<'tcx> {\n     pub category: ConstraintCategory,\n     pub from_closure: bool,\n-    pub span: Span,\n+    pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,\n }"}, {"sha": "df28fb6e28e06acbcaaaf222ed85e8f26d0a62e2", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -4,6 +4,7 @@ use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n use rustc_trait_selection::traits::query::Fallible;\n@@ -100,12 +101,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     pub(super) fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n+        // Keep this parameter for now, in case we start using\n+        // it in `ConstraintCategory` at some point.\n+        _def_id: DefId,\n         instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n         locations: Locations,\n     ) {\n-        for predicate in instantiated_predicates.predicates {\n+        for (predicate, span) in instantiated_predicates\n+            .predicates\n+            .into_iter()\n+            .zip(instantiated_predicates.spans.into_iter())\n+        {\n             let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n+            self.prove_predicate(predicate, locations, ConstraintCategory::Predicate(span));\n         }\n     }\n "}, {"sha": "4bbeed39e45ae313d9ed5f7191bdb1cab35c75b8", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -32,6 +32,7 @@ use rustc_middle::ty::{\n     self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, OpaqueTypeKey, RegionVid,\n     ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n };\n+use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n@@ -449,6 +450,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n             if let ty::FnDef(def_id, substs) = *constant.literal.ty().kind() {\n                 let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n                 self.cx.normalize_and_prove_instantiated_predicates(\n+                    def_id,\n                     instantiated_predicates,\n                     location.to_locations(),\n                 );\n@@ -2572,9 +2574,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             aggregate_kind, location\n         );\n \n-        let instantiated_predicates = match aggregate_kind {\n+        let (def_id, instantiated_predicates) = match aggregate_kind {\n             AggregateKind::Adt(def, _, substs, _, _) => {\n-                tcx.predicates_of(def.did).instantiate(tcx, substs)\n+                (def.did, tcx.predicates_of(def.did).instantiate(tcx, substs))\n             }\n \n             // For closures, we have some **extra requirements** we\n@@ -2599,13 +2601,16 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs)\n             | AggregateKind::Generator(def_id, substs, _) => {\n-                self.prove_closure_bounds(tcx, def_id.expect_local(), substs, location)\n+                (*def_id, self.prove_closure_bounds(tcx, def_id.expect_local(), substs, location))\n             }\n \n-            AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n+            AggregateKind::Array(_) | AggregateKind::Tuple => {\n+                (CRATE_DEF_ID.to_def_id(), ty::InstantiatedPredicates::empty())\n+            }\n         };\n \n         self.normalize_and_prove_instantiated_predicates(\n+            def_id,\n             instantiated_predicates,\n             location.to_locations(),\n         );"}, {"sha": "45dd8868d6ccad52e1c3f385a15e826c5107567f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -609,6 +609,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n+        terr: &TypeError<'tcx>,\n     ) {\n         match cause.code {\n             ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n@@ -785,7 +786,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n                 err.help(\"...or use `match` instead of `let...else`\");\n             }\n-            _ => (),\n+            _ => {\n+                if let ObligationCauseCode::BindingObligation(_, binding_span) =\n+                    cause.code.peel_derives()\n+                {\n+                    if matches!(terr, TypeError::RegionsPlaceholderMismatch) {\n+                        err.span_note(*binding_span, \"the lifetime requirement is introduced here\");\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -1724,7 +1733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // It reads better to have the error origin as the final\n         // thing.\n-        self.note_error_origin(diag, cause, exp_found);\n+        self.note_error_origin(diag, cause, exp_found, terr);\n     }\n \n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {"}, {"sha": "d5541d7890c77de20e6906d5ee913dc8c02aa804", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -309,6 +309,9 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub category: ConstraintCategory,\n }\n \n+// Make sure this enum doesn't unintentionally grow\n+rustc_data_structures::static_assert_size!(ConstraintCategory, 12);\n+\n /// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n@@ -338,6 +341,11 @@ pub enum ConstraintCategory {\n     OpaqueType,\n     ClosureUpvar(hir::HirId),\n \n+    /// A constraint from a user-written predicate\n+    /// with the provided span, written on the item\n+    /// with the given `DefId`\n+    Predicate(Span),\n+\n     /// A \"boring\" constraint (caused by the given location) is one that\n     /// the user probably doesn't want to see described in diagnostics,\n     /// because it is kind of an artifact of the type system setup."}, {"sha": "8612499623be628ea17c66230ed0cc2af5b3dd0a", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -19,7 +19,7 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n-pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_span};\n+pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use rustc_middle::ty::query::Providers;\n "}, {"sha": "cc0b7d5817b435832a8b9c0ad7c270352a535286", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -257,25 +257,20 @@ fn type_op_prove_predicate<'tcx>(\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        type_op_prove_predicate_with_span(infcx, fulfill_cx, key, None);\n+        type_op_prove_predicate_with_cause(infcx, fulfill_cx, key, ObligationCause::dummy());\n         Ok(())\n     })\n }\n \n /// The core of the `type_op_prove_predicate` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_prove_predicate_with_span<'a, 'tcx: 'a>(\n+pub fn type_op_prove_predicate_with_cause<'a, 'tcx: 'a>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n     key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n-    span: Option<Span>,\n+    cause: ObligationCause<'tcx>,\n ) {\n-    let cause = if let Some(span) = span {\n-        ObligationCause::dummy_with_span(span)\n-    } else {\n-        ObligationCause::dummy()\n-    };\n     let (param_env, ProvePredicate { predicate }) = key.into_parts();\n     fulfill_cx.register_predicate_obligation(infcx, Obligation::new(cause, param_env, predicate));\n }"}, {"sha": "de254b7a1636c904ddf0eb76def308ae37ef186a", "filename": "src/test/ui/associated-types/higher-ranked-projection.bad.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhigher-ranked-projection.bad.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -6,6 +6,11 @@ LL |     foo(());\n    |\n    = note: expected reference `&'a ()`\n               found reference `&()`\n+note: the lifetime requirement is introduced here\n+  --> $DIR/higher-ranked-projection.rs:15:33\n+   |\n+LL |     where for<'a> &'a T: Mirror<Image=U>\n+   |                                 ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b5144c607a8808463b6c9465c76fb5dd2b7c9979", "filename": "src/test/ui/generator/resume-arg-late-bound.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -6,6 +6,11 @@ LL |     test(gen);\n    |\n    = note: expected type `for<'a> Generator<&'a mut bool>`\n               found type `Generator<&mut bool>`\n+note: the lifetime requirement is introduced here\n+  --> $DIR/resume-arg-late-bound.rs:8:17\n+   |\n+LL | fn test(a: impl for<'a> Generator<&'a mut bool>) {}\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "04d9b64d64fdda70639588a0c4760b03087bd5e2", "filename": "src/test/ui/lifetimes/issue-79187-2.nll.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187-2.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -38,6 +38,11 @@ note: this closure does not fulfill the lifetime requirements\n    |\n LL |     take_foo(|a| a);\n    |              ^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-79187-2.rs:5:21\n+   |\n+LL | fn take_foo(_: impl Foo) {}\n+   |                     ^^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:9:5\n@@ -47,6 +52,11 @@ LL |     take_foo(|a: &i32| a);\n    |\n    = note: expected reference `&i32`\n               found reference `&i32`\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-79187-2.rs:5:21\n+   |\n+LL | fn take_foo(_: impl Foo) {}\n+   |                     ^^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:10:5\n@@ -56,6 +66,11 @@ LL |     take_foo(|a: &i32| -> &i32 { a });\n    |\n    = note: expected reference `&i32`\n               found reference `&i32`\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-79187-2.rs:5:21\n+   |\n+LL | fn take_foo(_: impl Foo) {}\n+   |                     ^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "3a993e88d8a92577a605ef0a811ae9e22e16ac63", "filename": "src/test/ui/lifetimes/issue-79187.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -11,6 +11,11 @@ note: this closure does not fulfill the lifetime requirements\n    |\n LL |     let f = |_| ();\n    |             ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-79187.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32)) {}\n+   |                  ^^^^^^^^^^^^\n \n error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-79187.rs:5:5"}, {"sha": "5509226cb1cdd83c5c8eebcc6cae3673e52a9e53", "filename": "src/test/ui/lifetimes/lifetime-errors/issue_74400.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fissue_74400.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -14,6 +14,11 @@ LL |     f(data, identity)\n    |\n    = note: expected type `for<'r> Fn<(&'r T,)>`\n               found type `Fn<(&T,)>`\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue_74400.rs:8:34\n+   |\n+LL | fn f<T, S>(data: &[T], key: impl Fn(&T) -> S) {\n+   |                                  ^^^^^^^^^^^\n \n error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue_74400.rs:12:5"}, {"sha": "bd36fab92886dd600a168db9c7186504b286165b", "filename": "src/test/ui/mismatched_types/closure-mismatch.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a12be741290b16c29293f87bdb3e8e5129bd4a9/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.nll.stderr?ref=8a12be741290b16c29293f87bdb3e8e5129bd4a9", "patch": "@@ -20,6 +20,11 @@ note: this closure does not fulfill the lifetime requirements\n    |\n LL |     baz(|_| ());\n    |         ^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/closure-mismatch.rs:5:11\n+   |\n+LL | fn baz<T: Foo>(_: T) {}\n+   |           ^^^\n \n error: aborting due to 2 previous errors\n "}]}