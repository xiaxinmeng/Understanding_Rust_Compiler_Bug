{"sha": "e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MDAzYzU1NzRiYmM5MGIyMTkyNjZhNTZkM2U0ZGNkMGNhZTU5YjM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-06T19:58:28Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-06-09T10:23:00Z"}, "message": "merge the RemoveDeadBlocks pass into the SimplifyCfg pass", "tree": {"sha": "7ffa18c76a81383e0e9e218d48c81344387165c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ffa18c76a81383e0e9e218d48c81344387165c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "html_url": "https://github.com/rust-lang/rust/commit/e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb4b3fb7f97924919f072ec9a360bdf943218dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4b3fb7f97924919f072ec9a360bdf943218dbf", "html_url": "https://github.com/rust-lang/rust/commit/bb4b3fb7f97924919f072ec9a360bdf943218dbf"}], "stats": {"total": 173, "additions": 70, "deletions": 103}, "files": [{"sha": "67eb2479994e13ef70ee44a24429f89d005154d8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "patch": "@@ -976,11 +976,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         time(time_passes, \"MIR passes\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n-            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n             passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n-            passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n             passes.run_passes(tcx, &mut mir_map);\n         });\n@@ -1047,14 +1046,18 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(time_passes, \"Prepare MIR codegen passes\", || {\n         let mut passes = ::rustc::mir::transform::Passes::new();\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"no-landing-pads\"));\n+\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n+\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box borrowck::ElaborateDrops);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n+        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"elaborate-drops\"));\n+\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::DumpMir(\"pre_trans\"));\n+\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "32ebbf5e936ad5cf97084bfb96c33610b144bfd2", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub mod remove_dead_blocks;\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;"}, {"sha": "44f3ce7361cf49f18b7eb14e5d13c505f0eb97ef", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb4b3fb7f97924919f072ec9a360bdf943218dbf/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=bb4b3fb7f97924919f072ec9a360bdf943218dbf", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A pass that erases the contents of dead blocks. This pass must\n-//! run before any analysis passes because some of the dead blocks\n-//! can be ill-typed.\n-//!\n-//! The main problem is that typeck lets most blocks whose end is not\n-//! reachable have an arbitrary return type, rather than having the\n-//! usual () return type (as a note, typeck's notion of reachability\n-//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n-//!\n-//! A standard example of the situation is:\n-//! ```rust\n-//!   fn example() {\n-//!       let _a: char = { return; };\n-//!   }\n-//! ```\n-//!\n-//! Here the block (`{ return; }`) has the return type `char`,\n-//! rather than `()`, but the MIR we naively generate still contains\n-//! the `_a = ()` write in the unreachable block \"after\" the return.\n-//!\n-//! As we have to run this pass even when we want to debug the MIR,\n-//! this pass just replaces the blocks with empty \"return\" blocks\n-//! and does not renumber anything.\n-\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n-use rustc::mir::transform::{Pass, MirPass, MirSource};\n-\n-pub struct RemoveDeadBlocks;\n-\n-impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut seen = BitVector::new(mir.basic_blocks.len());\n-        // This block is always required.\n-        seen.insert(START_BLOCK.index());\n-\n-        let mut worklist = Vec::with_capacity(4);\n-        worklist.push(START_BLOCK);\n-        while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n-                if seen.insert(succ.index()) {\n-                    worklist.push(*succ);\n-                }\n-            }\n-        }\n-        retain_basic_blocks(mir, &seen);\n-    }\n-}\n-\n-impl Pass for RemoveDeadBlocks {}\n-\n-/// Mass removal of basic blocks to keep the ID-remapping cheap.\n-fn retain_basic_blocks(mir: &mut Mir, keep: &BitVector) {\n-    let num_blocks = mir.basic_blocks.len();\n-\n-    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n-    let mut used_blocks = 0;\n-    for alive_index in keep.iter() {\n-        replacements[alive_index] = BasicBlock::new(used_blocks);\n-        if alive_index != used_blocks {\n-            // Swap the next alive block data with the current available slot. Since alive_index is\n-            // non-decreasing this is a valid operation.\n-            mir.basic_blocks.swap(alive_index, used_blocks);\n-        }\n-        used_blocks += 1;\n-    }\n-    mir.basic_blocks.truncate(used_blocks);\n-\n-    for bb in mir.all_basic_blocks() {\n-        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n-            *target = replacements[target.index()];\n-        }\n-    }\n-}"}, {"sha": "8cce55a9beba64a7a0c4aac4aa3134b5adc32f2a", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9003c5574bbc90b219266a56d3e4dcd0cae59b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=e9003c5574bbc90b219266a56d3e4dcd0cae59b3", "patch": "@@ -8,6 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A pass that removes various redundancies in the CFG. It should be\n+//! called after every significant CFG modification to tidy things\n+//! up.\n+//!\n+//! This pass must also be run before any analysis passes because it removes\n+//! dead blocks, and some of these can be ill-typed.\n+//!\n+//! The cause of that is that typeck lets most blocks whose end is not\n+//! reachable have an arbitrary return type, rather than having the\n+//! usual () return type (as a note, typeck's notion of reachability\n+//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//!\n+//! A standard example of the situation is:\n+//! ```rust\n+//!   fn example() {\n+//!       let _a: char = { return; };\n+//!   }\n+//! ```\n+//!\n+//! Here the block (`{ return; }`) has the return type `char`,\n+//! rather than `()`, but the MIR we naively generate still contains\n+//! the `_a = ()` write in the unreachable block \"after\" the return.\n+\n+\n use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n@@ -17,30 +41,29 @@ use rustc::mir::traversal;\n use pretty;\n use std::mem;\n \n-use super::remove_dead_blocks::RemoveDeadBlocks;\n+pub struct SimplifyCfg<'a> { label: &'a str }\n \n-pub struct SimplifyCfg;\n-\n-impl SimplifyCfg {\n-    pub fn new() -> SimplifyCfg {\n-        SimplifyCfg\n+impl<'a> SimplifyCfg<'a> {\n+    pub fn new(label: &'a str) -> Self {\n+        SimplifyCfg { label: label }\n     }\n }\n \n-impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n+impl<'l, 'tcx> MirPass<'tcx> for SimplifyCfg<'l> {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+        pretty::dump_mir(tcx, \"simplify_cfg\", &format!(\"{}-before\", self.label), src, mir, None);\n         simplify_branches(mir);\n-        RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        remove_dead_blocks(mir);\n         merge_consecutive_blocks(mir);\n-        RemoveDeadBlocks.run_pass(tcx, src, mir);\n-        pretty::dump_mir(tcx, \"simplify_cfg\", &0, src, mir, None);\n+        remove_dead_blocks(mir);\n+        pretty::dump_mir(tcx, \"simplify_cfg\", &format!(\"{}-after\", self.label), src, mir, None);\n \n         // FIXME: Should probably be moved into some kind of pass manager\n         mir.basic_blocks.shrink_to_fit();\n     }\n }\n \n-impl Pass for SimplifyCfg {}\n+impl<'l> Pass for SimplifyCfg<'l> {}\n \n fn merge_consecutive_blocks(mir: &mut Mir) {\n     // Build the precedecessor map for the MIR\n@@ -202,3 +225,31 @@ fn simplify_branches(mir: &mut Mir) {\n         }\n     }\n }\n+\n+fn remove_dead_blocks(mir: &mut Mir) {\n+    let mut seen = BitVector::new(mir.basic_blocks.len());\n+    for (bb, _) in traversal::preorder(mir) {\n+        seen.insert(bb.index());\n+    }\n+\n+    let num_blocks = mir.basic_blocks.len();\n+\n+    let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n+    let mut used_blocks = 0;\n+    for alive_index in seen.iter() {\n+        replacements[alive_index] = BasicBlock::new(used_blocks);\n+        if alive_index != used_blocks {\n+            // Swap the next alive block data with the current available slot. Since alive_index is\n+            // non-decreasing this is a valid operation.\n+            mir.basic_blocks.swap(alive_index, used_blocks);\n+        }\n+        used_blocks += 1;\n+    }\n+    mir.basic_blocks.truncate(used_blocks);\n+\n+    for bb in mir.all_basic_blocks() {\n+        for target in mir.basic_block_data_mut(bb).terminator_mut().successors_mut() {\n+            *target = replacements[target.index()];\n+        }\n+    }\n+}"}]}