{"sha": "ff1860ad763baac652d3a43a93985e29ade805cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMTg2MGFkNzYzYmFhYzY1MmQzYTQzYTkzOTg1ZTI5YWRlODA1Y2I=", "commit": {"author": {"name": "Mikko Rantanen", "email": "jubjub@jubjubnest.net", "date": "2019-10-03T00:55:31Z"}, "committer": {"name": "Mikko Rantanen", "email": "jubjub@jubjubnest.net", "date": "2019-10-21T16:28:29Z"}, "message": "Fix the start/end byte positions in the compiler JSON output", "tree": {"sha": "4c425dd8c70519e74aa630405d35019e234ee591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c425dd8c70519e74aa630405d35019e234ee591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff1860ad763baac652d3a43a93985e29ade805cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQEcBAABCAAGBQJdrdzAAAoJELaA6c4QpVeYhrcH+wWBZ0gSRbz4py92OAe/csj3\nLk05ei0oIqlvMmUHFrM0wfzVhtvf2i4yeDqCaY1OLRZ7NbeuR9sgdlUYRoadKOX+\nYM2Vr81DZ/UB4S4sKN2jbOOs3we549Gl4JYfweW2pWL7bz8qTQzvgVTmX+JSpXw/\nNi3J9iM0wLRX0Ufk6dxXxn68iZcA03SJNrDMHZRmHmWCV4UKqx4AnS5JyY86JwM9\n/qbS90Am8LM+T6i9hgt90wuGRhSdIihaTeBAkxrPZ5h9BWU+khSlHKdDe99eRxzr\nkl+OxW9EfLujMi4gc5MmVl63U04VPejEuwXBcEHSYE2Htx1wGSGz2aYA7hT1Q8E=\n=cMWn\n-----END PGP SIGNATURE-----", "payload": "tree 4c425dd8c70519e74aa630405d35019e234ee591\nparent 2748a9fd93dd1a00a4521f4f16de5befbf77f6cd\nauthor Mikko Rantanen <jubjub@jubjubnest.net> 1570064131 +0300\ncommitter Mikko Rantanen <jubjub@jubjubnest.net> 1571675309 +0300\n\nFix the start/end byte positions in the compiler JSON output\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff1860ad763baac652d3a43a93985e29ade805cb", "html_url": "https://github.com/rust-lang/rust/commit/ff1860ad763baac652d3a43a93985e29ade805cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff1860ad763baac652d3a43a93985e29ade805cb/comments", "author": {"login": "Rantanen", "id": 385385, "node_id": "MDQ6VXNlcjM4NTM4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/385385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rantanen", "html_url": "https://github.com/Rantanen", "followers_url": "https://api.github.com/users/Rantanen/followers", "following_url": "https://api.github.com/users/Rantanen/following{/other_user}", "gists_url": "https://api.github.com/users/Rantanen/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rantanen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rantanen/subscriptions", "organizations_url": "https://api.github.com/users/Rantanen/orgs", "repos_url": "https://api.github.com/users/Rantanen/repos", "events_url": "https://api.github.com/users/Rantanen/events{/privacy}", "received_events_url": "https://api.github.com/users/Rantanen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rantanen", "id": 385385, "node_id": "MDQ6VXNlcjM4NTM4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/385385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rantanen", "html_url": "https://github.com/Rantanen", "followers_url": "https://api.github.com/users/Rantanen/followers", "following_url": "https://api.github.com/users/Rantanen/following{/other_user}", "gists_url": "https://api.github.com/users/Rantanen/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rantanen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rantanen/subscriptions", "organizations_url": "https://api.github.com/users/Rantanen/orgs", "repos_url": "https://api.github.com/users/Rantanen/repos", "events_url": "https://api.github.com/users/Rantanen/events{/privacy}", "received_events_url": "https://api.github.com/users/Rantanen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd", "html_url": "https://github.com/rust-lang/rust/commit/2748a9fd93dd1a00a4521f4f16de5befbf77f6cd"}], "stats": {"total": 565, "additions": 543, "deletions": 22}, "files": [{"sha": "93a3c1f60324e6489d73557bf048550c277f6b2b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -424,6 +424,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             ref lines,\n             ref multibyte_chars,\n             ref non_narrow_chars,\n+            ref normalized_pos,\n         } = *self;\n \n         (name_hash as u64).hash_stable(hcx, hasher);\n@@ -452,6 +453,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         for &char_pos in non_narrow_chars.iter() {\n             stable_non_narrow_char(char_pos, start_pos).hash_stable(hcx, hasher);\n         }\n+\n+        normalized_pos.len().hash_stable(hcx, hasher);\n+        for &char_pos in normalized_pos.iter() {\n+            stable_normalized_pos(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n+\n     }\n }\n \n@@ -481,6 +488,18 @@ fn stable_non_narrow_char(swc: ::syntax_pos::NonNarrowChar,\n     (pos.0 - source_file_start.0, width as u32)\n }\n \n+fn stable_normalized_pos(np: ::syntax_pos::NormalizedPos,\n+                         source_file_start: ::syntax_pos::BytePos)\n+                         -> (u32, u32) {\n+    let ::syntax_pos::NormalizedPos {\n+        pos,\n+        diff\n+    } = np;\n+\n+    (pos.0 - source_file_start.0, diff)\n+}\n+\n+\n impl<'tcx> HashStable<StableHashingContext<'tcx>> for feature_gate::Features {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'tcx>, hasher: &mut StableHasher) {\n         // Unfortunately we cannot exhaustively list fields here, since the"}, {"sha": "cb2312ab172ffa728faab8ca036015ab82078418", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -1317,6 +1317,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                       mut lines,\n                                       mut multibyte_chars,\n                                       mut non_narrow_chars,\n+                                      mut normalized_pos,\n                                       name_hash,\n                                       .. } = source_file_to_import;\n \n@@ -1336,6 +1337,9 @@ impl<'a, 'tcx> CrateMetadata {\n             for swc in &mut non_narrow_chars {\n                 *swc = *swc - start_pos;\n             }\n+            for np in &mut normalized_pos {\n+                np.pos = np.pos - start_pos;\n+            }\n \n             let local_version = local_source_map.new_imported_source_file(name,\n                                                                    name_was_remapped,\n@@ -1345,7 +1349,8 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars,\n-                                                                   non_narrow_chars);\n+                                                                   non_narrow_chars,\n+                                                                   normalized_pos);\n             debug!(\"CrateMetaData::imported_source_files alloc \\\n                     source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n                     translated (start_pos {:?} end_pos {:?})\","}, {"sha": "aa0b41171744eeb2ffdab8d576aee19389eb738f", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -25,6 +25,9 @@ use std::sync::{Arc, Mutex};\n \n use rustc_serialize::json::{as_json, as_pretty_json};\n \n+#[cfg(test)]\n+mod tests;\n+\n pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n@@ -332,8 +335,8 @@ impl DiagnosticSpan {\n \n         DiagnosticSpan {\n             file_name: start.file.name.to_string(),\n-            byte_start: span.lo().0 - start.file.start_pos.0,\n-            byte_end: span.hi().0 - start.file.start_pos.0,\n+            byte_start: start.file.original_relative_byte_pos(span.lo()).0,\n+            byte_end: start.file.original_relative_byte_pos(span.hi()).0,\n             line_start: start.line,\n             line_end: end.line,\n             column_start: start.col.0 + 1,"}, {"sha": "eb0d9ef3947c8f0d67165b88f66fda212216ec61", "filename": "src/libsyntax/json/tests.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson%2Ftests.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,186 @@\n+use super::*;\n+\n+use crate::json::JsonEmitter;\n+use crate::source_map::{FilePathMapping, SourceMap};\n+use crate::tests::Shared;\n+use crate::with_default_globals;\n+\n+use errors::emitter::{ColorConfig, HumanReadableErrorType};\n+use errors::Handler;\n+use rustc_serialize::json::decode;\n+use syntax_pos::{BytePos, Span};\n+\n+use std::str;\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct TestData {\n+    spans: Vec<SpanTestData>,\n+}\n+\n+#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+struct SpanTestData {\n+    pub byte_start: u32,\n+    pub byte_end: u32,\n+    pub line_start: u32,\n+    pub column_start: u32,\n+    pub line_end: u32,\n+    pub column_end: u32,\n+}\n+\n+/// Test the span yields correct positions in JSON.\n+fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n+    let expected_output = TestData { spans: vec![expected_output] };\n+\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n+\n+        let output = Arc::new(Mutex::new(Vec::new()));\n+        let je = JsonEmitter::new(\n+            Box::new(Shared { data: output.clone() }),\n+            None,\n+            sm,\n+            true,\n+            HumanReadableErrorType::Short(ColorConfig::Never),\n+            false,\n+        );\n+\n+        let span = Span::with_root_ctxt(BytePos(span.0), BytePos(span.1));\n+        let handler = Handler::with_emitter(true, None, Box::new(je));\n+        handler.span_err(span, \"foo\");\n+\n+        let bytes = output.lock().unwrap();\n+        let actual_output = str::from_utf8(&bytes).unwrap();\n+        let actual_output: TestData = decode(actual_output).unwrap();\n+\n+        assert_eq!(expected_output, actual_output)\n+    })\n+}\n+\n+#[test]\n+fn empty() {\n+    test_positions(\n+        \" \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 0,\n+            byte_end: 1,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn bom() {\n+    test_positions(\n+        \"\\u{feff} \",\n+        (0, 1),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 4,\n+            line_start: 1,\n+            column_start: 1,\n+            line_end: 1,\n+            column_end: 2,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn lf_newlines() {\n+    test_positions(\n+        \"\\nmod foo;\\nmod bar;\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 12,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines() {\n+    test_positions(\n+        \"\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 6,\n+            byte_end: 14,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn crlf_newlines_with_bom() {\n+    test_positions(\n+        \"\\u{feff}\\r\\nmod foo;\\r\\nmod bar;\\r\\n\",\n+        (5, 12),\n+        SpanTestData {\n+            byte_start: 9,\n+            byte_end: 17,\n+            line_start: 2,\n+            column_start: 5,\n+            line_end: 3,\n+            column_end: 3,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_before_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (2, 3),\n+        SpanTestData {\n+            byte_start: 2,\n+            byte_end: 3,\n+            line_start: 1,\n+            column_start: 3,\n+            line_end: 1,\n+            column_end: 4,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_on_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (3, 4),\n+        SpanTestData {\n+            byte_start: 3,\n+            byte_end: 5,\n+            line_start: 1,\n+            column_start: 4,\n+            line_end: 2,\n+            column_end: 1,\n+        },\n+    )\n+}\n+\n+#[test]\n+fn span_after_crlf() {\n+    test_positions(\n+        \"foo\\r\\nbar\",\n+        (4, 5),\n+        SpanTestData {\n+            byte_start: 5,\n+            byte_end: 6,\n+            line_start: 2,\n+            column_start: 1,\n+            line_end: 2,\n+            column_end: 2,\n+        },\n+    )\n+}"}, {"sha": "359b5957167955e94829be9ec469982a8de82bf7", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -283,6 +283,7 @@ impl SourceMap {\n         mut file_local_lines: Vec<BytePos>,\n         mut file_local_multibyte_chars: Vec<MultiByteChar>,\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n+        mut file_local_normalized_pos: Vec<NormalizedPos>,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self.next_start_pos();\n \n@@ -301,6 +302,10 @@ impl SourceMap {\n             *swc = *swc + start_pos;\n         }\n \n+        for nc in &mut file_local_normalized_pos {\n+            nc.pos = nc.pos + start_pos;\n+        }\n+\n         let source_file = Lrc::new(SourceFile {\n             name: filename,\n             name_was_remapped,\n@@ -314,6 +319,7 @@ impl SourceMap {\n             lines: file_local_lines,\n             multibyte_chars: file_local_multibyte_chars,\n             non_narrow_chars: file_local_non_narrow_chars,\n+            normalized_pos: file_local_normalized_pos,\n             name_hash,\n         });\n "}, {"sha": "a95880d9620044b89709855b7b53f9e8c3688c63", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -110,8 +110,8 @@ struct SpanLabel {\n     label: &'static str,\n }\n \n-struct Shared<T: Write> {\n-    data: Arc<Mutex<T>>,\n+crate struct Shared<T: Write> {\n+    pub data: Arc<Mutex<T>>,\n }\n \n impl<T: Write> Write for Shared<T> {"}, {"sha": "806aace13815868589bf3aef6367f965184ff2ff", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -855,6 +855,15 @@ impl Sub<BytePos> for NonNarrowChar {\n     }\n }\n \n+/// Identifies an offset of a character that was normalized away from `SourceFile`.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+pub struct NormalizedPos {\n+    /// The absolute offset of the character in the `SourceMap`.\n+    pub pos: BytePos,\n+    /// The difference between original and normalized string at position.\n+    pub diff: u32,\n+}\n+\n /// The state of the lazy external source loading mechanism of a `SourceFile`.\n #[derive(PartialEq, Eq, Clone)]\n pub enum ExternalSource {\n@@ -918,6 +927,8 @@ pub struct SourceFile {\n     pub multibyte_chars: Vec<MultiByteChar>,\n     /// Width of characters that are not narrow in the source code.\n     pub non_narrow_chars: Vec<NonNarrowChar>,\n+    /// Locations of characters removed during normalization.\n+    pub normalized_pos: Vec<NormalizedPos>,\n     /// A hash of the filename, used for speeding up hashing in incremental compilation.\n     pub name_hash: u128,\n }\n@@ -984,6 +995,9 @@ impl Encodable for SourceFile {\n             })?;\n             s.emit_struct_field(\"name_hash\", 8, |s| {\n                 self.name_hash.encode(s)\n+            })?;\n+            s.emit_struct_field(\"normalized_pos\", 9, |s| {\n+                self.normalized_pos.encode(s)\n             })\n         })\n     }\n@@ -1034,6 +1048,8 @@ impl Decodable for SourceFile {\n                 d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n             let name_hash: u128 =\n                 d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n+            let normalized_pos: Vec<NormalizedPos> =\n+                d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n@@ -1050,6 +1066,7 @@ impl Decodable for SourceFile {\n                 lines,\n                 multibyte_chars,\n                 non_narrow_chars,\n+                normalized_pos,\n                 name_hash,\n             })\n         })\n@@ -1068,8 +1085,7 @@ impl SourceFile {\n                unmapped_path: FileName,\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n-        remove_bom(&mut src);\n-        normalize_newlines(&mut src);\n+        let normalized_pos = normalize_src(&mut src, start_pos);\n \n         let src_hash = {\n             let mut hasher: StableHasher = StableHasher::new();\n@@ -1102,6 +1118,7 @@ impl SourceFile {\n             lines,\n             multibyte_chars,\n             non_narrow_chars,\n+            normalized_pos,\n             name_hash,\n         })\n     }\n@@ -1228,20 +1245,52 @@ impl SourceFile {\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n+\n+    /// Calculates the original byte position relative to the start of the file\n+    /// based on the given byte position.\n+    pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {\n+\n+        // Diff before any records is 0. Otherwise use the previously recorded\n+        // diff as that applies to the following characters until a new diff\n+        // is recorded.\n+        let diff = match self.normalized_pos.binary_search_by(\n+                            |np| np.pos.cmp(&pos)) {\n+            Ok(i) => self.normalized_pos[i].diff,\n+            Err(i) if i == 0 => 0,\n+            Err(i) => self.normalized_pos[i-1].diff,\n+        };\n+\n+        BytePos::from_u32(pos.0 - self.start_pos.0 + diff)\n+    }\n+}\n+\n+/// Normalizes the source code and records the normalizations.\n+fn normalize_src(src: &mut String, start_pos: BytePos) -> Vec<NormalizedPos> {\n+    let mut normalized_pos = vec![];\n+    remove_bom(src, &mut normalized_pos);\n+    normalize_newlines(src, &mut normalized_pos);\n+\n+    // Offset all the positions by start_pos to match the final file positions.\n+    for np in &mut normalized_pos {\n+        np.pos.0 += start_pos.0;\n+    }\n+\n+    normalized_pos\n }\n \n /// Removes UTF-8 BOM, if any.\n-fn remove_bom(src: &mut String) {\n+fn remove_bom(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if src.starts_with(\"\\u{feff}\") {\n         src.drain(..3);\n+        normalized_pos.push(NormalizedPos { pos: BytePos(0), diff: 3 });\n     }\n }\n \n \n /// Replaces `\\r\\n` with `\\n` in-place in `src`.\n ///\n /// Returns error if there's a lone `\\r` in the string\n-fn normalize_newlines(src: &mut String) {\n+fn normalize_newlines(src: &mut String, normalized_pos: &mut Vec<NormalizedPos>) {\n     if !src.as_bytes().contains(&b'\\r') {\n         return;\n     }\n@@ -1254,6 +1303,8 @@ fn normalize_newlines(src: &mut String) {\n     let mut buf = std::mem::replace(src, String::new()).into_bytes();\n     let mut gap_len = 0;\n     let mut tail = buf.as_mut_slice();\n+    let mut cursor = 0;\n+    let original_gap = normalized_pos.last().map_or(0, |l| l.diff);\n     loop {\n         let idx = match find_crlf(&tail[gap_len..]) {\n             None => tail.len(),\n@@ -1264,7 +1315,12 @@ fn normalize_newlines(src: &mut String) {\n         if tail.len() == gap_len {\n             break;\n         }\n+        cursor += idx - gap_len;\n         gap_len += 1;\n+        normalized_pos.push(NormalizedPos {\n+            pos: BytePos::from_usize(cursor + 1),\n+            diff: original_gap + gap_len as u32,\n+        });\n     }\n \n     // Account for removed `\\r`."}, {"sha": "87cc3505e389b40a90ac6b798385622889d3e595", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -19,20 +19,25 @@ fn test_lookup_line() {\n \n #[test]\n fn test_normalize_newlines() {\n-    fn check(before: &str, after: &str) {\n+    fn check(before: &str, after: &str, expected_positions: &[u32]) {\n         let mut actual = before.to_string();\n-        normalize_newlines(&mut actual);\n+        let mut actual_positions = vec![];\n+        normalize_newlines(&mut actual, &mut actual_positions);\n+        let actual_positions : Vec<_> = actual_positions\n+            .into_iter()\n+            .map(|nc| nc.pos.0).collect();\n         assert_eq!(actual.as_str(), after);\n+        assert_eq!(actual_positions, expected_positions);\n     }\n-    check(\"\", \"\");\n-    check(\"\\n\", \"\\n\");\n-    check(\"\\r\", \"\\r\");\n-    check(\"\\r\\r\", \"\\r\\r\");\n-    check(\"\\r\\n\", \"\\n\");\n-    check(\"hello world\", \"hello world\");\n-    check(\"hello\\nworld\", \"hello\\nworld\");\n-    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n-    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n-    check(\"\\r\\r\\n\", \"\\r\\n\");\n-    check(\"hello\\rworld\", \"hello\\rworld\");\n+    check(\"\", \"\", &[]);\n+    check(\"\\n\", \"\\n\", &[]);\n+    check(\"\\r\", \"\\r\", &[]);\n+    check(\"\\r\\r\", \"\\r\\r\", &[]);\n+    check(\"\\r\\n\", \"\\n\", &[1]);\n+    check(\"hello world\", \"hello world\", &[]);\n+    check(\"hello\\nworld\", \"hello\\nworld\", &[]);\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\", &[6]);\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\", &[1, 7, 13]);\n+    check(\"\\r\\r\\n\", \"\\r\\n\", &[2]);\n+    check(\"hello\\rworld\", \"hello\\rworld\", &[]);\n }"}, {"sha": "9ea3d3fb0e1f125038c940d40d0d2235ef8febea", "filename": "src/test/ui/.gitattributes", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2F.gitattributes?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -1,3 +1,6 @@\n lexer-crlf-line-endings-string-literal-doc-comment.rs -text\n+json-bom-plus-crlf.rs -text\n+json-bom-plus-crlf-multifile.rs -text\n+json-bom-plus-crlf-multifile-aux.rs -text\n trailing-carriage-return-in-string.rs -text\n *.bin -text"}, {"sha": "991ea1d85d2ca3d8ae73449e5516524d4e092d6d", "filename": "src/test/ui/json-bom-plus-crlf-multifile-aux.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile-aux.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// ignore-test Not a test. Used by other tests\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json-bom-plus-crlf.rs - given the actual fn is identical (just with\r\n+// a different, but equally sized name), the easiest way to do this is to\r\n+// ensure the two files are of equal size on disk.\r\n+// Padding............................\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+pub fn test() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "c71dd325f4427f107b3a6999a31c57d062b17bd5", "filename": "src/test/ui/json-bom-plus-crlf-multifile.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,12 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+#[path = \"json-bom-plus-crlf-multifile-aux.rs\"]\r\n+mod json_bom_plus_crlf_multifile_aux;\r\n+\r\n+fn main() {\r\n+    json_bom_plus_crlf_multifile_aux::test();\r\n+}\r"}, {"sha": "8472f16108909f0699a671fee0c2db7c37fabeee", "filename": "src/test/ui/json-bom-plus-crlf-multifile.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}, {"sha": "ae54a35d4805ce97bd638619cb64af180e42a98e", "filename": "src/test/ui/json-bom-plus-crlf.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.rs?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,27 @@\n+\ufeff// (This line has BOM so it's ignored by compiletest for directives)\r\n+//\r\n+// build-fail\r\n+// compile-flags: --json=diagnostic-short --error-format=json\r\n+// ignore-tidy-cr\r\n+\r\n+// For easier verifying, the byte offsets in this file should match those\r\n+// in the json_bom_plus_crlf_multifile_aux.rs - given the actual fn is\r\n+// identical (just with a different, but equally sized name), the easiest way\r\n+// to do this is to ensure the two files are of equal size on disk.\r\n+\r\n+// N.B., this file needs CRLF line endings. The .gitattributes file in\r\n+// this directory should enforce it.\r\n+\r\n+fn main() {\r\n+\r\n+    let s : String = 1;  // Error in the middle of line.\r\n+\r\n+    let s : String = 1\r\n+    ;  // Error before the newline.\r\n+\r\n+    let s : String =\r\n+1;  // Error after the newline.\r\n+\r\n+    let s : String = (\r\n+    );  // Error spanning the newline.\r\n+}\r"}, {"sha": "17775f59fd16f8dc643fa89d0e36f5b1c1e1b57e", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff1860ad763baac652d3a43a93985e29ade805cb/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=ff1860ad763baac652d3a43a93985e29ade805cb", "patch": "@@ -0,0 +1,86 @@\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:17:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:19:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `{integer}`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null},{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:23:1: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \\\"I am not a number!\\\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```\n+\"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found ()\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"expected type `std::string::String`\n+   found type `()`\",\"code\":null,\"level\":\"note\",\"spans\":[],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:25:22: error[E0308]: mismatched types\n+\"}\n+{\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors\n+\"}"}]}