{"sha": "8fd946c63a6c3aae9788bd459d278cb2efa77099", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZDk0NmM2M2E2YzNhYWU5Nzg4YmQ0NTlkMjc4Y2IyZWZhNzcwOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T13:34:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-05T13:34:33Z"}, "message": "Auto merge of #82795 - m-ou-se:rollup-uzx0b92, r=m-ou-se\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #80723 (Implement NOOP_METHOD_CALL lint)\n - #80763 (resolve: Reduce scope of `pub_use_of_private_extern_crate` deprecation lint)\n - #81136 (Improved IO Bytes Size Hint)\n - #81939 (Add suggestion `.collect()` for iterators in iterators)\n - #82289 (Fix underflow in specialized ZipImpl::size_hint)\n - #82728 (Avoid unnecessary Vec construction in BufReader)\n - #82764 (Add {BTreeMap,HashMap}::try_insert)\n - #82770 (Add assert_matches macro.)\n - #82773 (Add diagnostic item to `Default` trait)\n - #82787 (Remove unused code from main.js)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "96945c52f9a705346f2b6f198475a80c3451c639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96945c52f9a705346f2b6f198475a80c3451c639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fd946c63a6c3aae9788bd459d278cb2efa77099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd946c63a6c3aae9788bd459d278cb2efa77099", "html_url": "https://github.com/rust-lang/rust/commit/8fd946c63a6c3aae9788bd459d278cb2efa77099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fd946c63a6c3aae9788bd459d278cb2efa77099/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ccc89bc312caa65ca46b55b47492abdd5b6910a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ccc89bc312caa65ca46b55b47492abdd5b6910a", "html_url": "https://github.com/rust-lang/rust/commit/8ccc89bc312caa65ca46b55b47492abdd5b6910a"}, {"sha": "16518e70fba278b8e1f7ae70f6941b453c459654", "url": "https://api.github.com/repos/rust-lang/rust/commits/16518e70fba278b8e1f7ae70f6941b453c459654", "html_url": "https://github.com/rust-lang/rust/commit/16518e70fba278b8e1f7ae70f6941b453c459654"}], "stats": {"total": 893, "additions": 776, "deletions": 117}, "files": [{"sha": "5f21046b05e475e9e3934faa2a671d927ee99383", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -24,7 +24,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let libs = config.used_crates.clone();\n+    let libs = config.used_crates;\n     let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     let mut flags = rpaths_to_flags(&rpaths);"}, {"sha": "9e61c83fda3a565823fcbb41f919c4341e8ddae1", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -57,6 +57,7 @@ mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n+mod noop_method_call;\n mod passes;\n mod redundant_semicolon;\n mod traits;\n@@ -81,6 +82,7 @@ use methods::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n+use noop_method_call::*;\n use redundant_semicolon::*;\n use traits::*;\n use types::*;\n@@ -168,6 +170,7 @@ macro_rules! late_lint_passes {\n                 DropTraitConstraints: DropTraitConstraints,\n                 TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n                 NonPanicFmt: NonPanicFmt,\n+                NoopMethodCall: NoopMethodCall,\n             ]\n         );\n     };"}, {"sha": "479cc00199f6adb33e54dc76fa47caf4cedb66f3", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,111 @@\n+use crate::context::LintContext;\n+use crate::rustc_middle::ty::TypeFoldable;\n+use crate::LateContext;\n+use crate::LateLintPass;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+declare_lint! {\n+    /// The `noop_method_call` lint detects specific calls to noop methods\n+    /// such as a calling `<&T as Clone>::clone` where `T: !Clone`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// #![warn(noop_method_call)]\n+    /// struct Foo;\n+    /// let foo = &Foo;\n+    /// let clone: &Foo = foo.clone();\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Some method calls are noops meaning that they do nothing. Usually such methods\n+    /// are the result of blanket implementations that happen to create some method invocations\n+    /// that end up not doing anything. For instance, `Clone` is implemented on all `&T`, but\n+    /// calling `clone` on a `&T` where `T` does not implement clone, actually doesn't do anything\n+    /// as references are copy. This lint detects these calls and warns the user about them.\n+    pub NOOP_METHOD_CALL,\n+    Allow,\n+    \"detects the use of well-known noop methods\"\n+}\n+\n+declare_lint_pass!(NoopMethodCall => [NOOP_METHOD_CALL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        // We only care about method calls.\n+        let (call, elements) = match expr.kind {\n+            ExprKind::MethodCall(call, _, elements, _) => (call, elements),\n+            _ => return,\n+        };\n+        // We only care about method calls corresponding to the `Clone`, `Deref` and `Borrow`\n+        // traits and ignore any other method call.\n+        let (trait_id, did) = match cx.typeck_results().type_dependent_def(expr.hir_id) {\n+            // Verify we are dealing with a method/associated function.\n+            Some((DefKind::AssocFn, did)) => match cx.tcx.trait_of_item(did) {\n+                // Check that we're dealing with a trait method for one of the traits we care about.\n+                Some(trait_id)\n+                    if [sym::Clone, sym::Deref, sym::Borrow]\n+                        .iter()\n+                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id)) =>\n+                {\n+                    (trait_id, did)\n+                }\n+                _ => return,\n+            },\n+            _ => return,\n+        };\n+        let substs = cx.typeck_results().node_substs(expr.hir_id);\n+        if substs.needs_subst() {\n+            // We can't resolve on types that require monomorphization, so we don't handle them if\n+            // we need to perfom substitution.\n+            return;\n+        }\n+        let param_env = cx.tcx.param_env(trait_id);\n+        // Resolve the trait method instance.\n+        let i = match ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n+            Ok(Some(i)) => i,\n+            _ => return,\n+        };\n+        // (Re)check that it implements the noop diagnostic.\n+        for s in [sym::noop_method_clone, sym::noop_method_deref, sym::noop_method_borrow].iter() {\n+            if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n+                let method = &call.ident.name;\n+                let receiver = &elements[0];\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+                if receiver_ty != expr_ty {\n+                    // This lint will only trigger if the receiver type and resulting expression \\\n+                    // type are the same, implying that the method call is unnecessary.\n+                    return;\n+                }\n+                let expr_span = expr.span;\n+                let note = format!(\n+                    \"the type `{:?}` which `{}` is being called on is the same as \\\n+                     the type returned from `{}`, so the method call does not do \\\n+                     anything and can be removed\",\n+                    receiver_ty, method, method,\n+                );\n+\n+                let span = expr_span.with_lo(receiver.span.hi());\n+                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                    let method = &call.ident.name;\n+                    let message = format!(\n+                        \"call to `.{}()` on a reference in this situation does nothing\",\n+                        &method,\n+                    );\n+                    lint.build(&message)\n+                        .span_label(span, \"unnecessary method call\")\n+                        .note(&note)\n+                        .emit()\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "f19cc99844926a0d0ce821c8698c2d503695fa26", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -12,7 +12,6 @@ use rustc_target::spec::abi;\n \n use std::borrow::Cow;\n use std::fmt;\n-use std::ops::Deref;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable)]\n pub struct ExpectedFound<T> {\n@@ -548,7 +547,6 @@ impl<T> Trait<T> for X {\n             TargetFeatureCast(def_id) => {\n                 let attrs = self.get_attrs(*def_id);\n                 let target_spans = attrs\n-                    .deref()\n                     .iter()\n                     .filter(|attr| attr.has_name(sym::target_feature))\n                     .map(|attr| attr.span);"}, {"sha": "24b9408ffb657d758bcd1aec9157918818be1dcf", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -10,16 +10,18 @@ use rustc_middle::mir::{\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_param, Instance, Ty};\n-use rustc_span::{source_map::DesugaringKind, symbol::sym, Span};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TypeFoldable};\n+use rustc_span::source_map::DesugaringKind;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};\n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n-    borrow_set::BorrowData, prefixes::IsPrefixOf, InitializationRequiringAction, MirBorrowckCtxt,\n-    PrefixSet, WriteKind,\n+    borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n+    InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n };\n \n use super::{\n@@ -1267,6 +1269,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if return_span != borrow_span {\n             err.span_label(borrow_span, note);\n+\n+            let tcx = self.infcx.tcx;\n+            let ty_params = ty::List::empty();\n+\n+            let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n+            let return_ty = tcx.erase_regions(return_ty);\n+\n+            // to avoid panics\n+            if !return_ty.has_infer_types() {\n+                if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator) {\n+                    if tcx.type_implements_trait((iter_trait, return_ty, ty_params, self.param_env))\n+                    {\n+                        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(return_span) {\n+                            err.span_suggestion_hidden(\n+                                return_span,\n+                                \"use `.collect()` to allocate the iterator\",\n+                                format!(\"{}{}\", snippet, \".collect::<Vec<_>>()\"),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n         }\n \n         Some(err)"}, {"sha": "e423e449746fc54f23754814fcbd1ee2bae86cc0", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -165,7 +165,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n-                let borrow_set = self.borrow_set.clone();\n+                let borrow_set = self.borrow_set;\n                 let resume = self.location_table.start_index(resume.start_location());\n                 for (i, data) in borrow_set.iter_enumerated() {\n                     if borrow_of_local_data(data.borrowed_place) {\n@@ -177,7 +177,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n                 // Invalidate all borrows of local places\n-                let borrow_set = self.borrow_set.clone();\n+                let borrow_set = self.borrow_set;\n                 let start = self.location_table.start_index(location);\n                 for (i, data) in borrow_set.iter_enumerated() {\n                     if borrow_of_local_data(data.borrowed_place) {\n@@ -369,15 +369,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         );\n         let tcx = self.tcx;\n         let body = self.body;\n-        let borrow_set = self.borrow_set.clone();\n+        let borrow_set = self.borrow_set;\n         let indices = self.borrow_set.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,\n             body,\n             location,\n             (sd, place),\n-            &borrow_set.clone(),\n+            borrow_set,\n             indices,\n             |this, borrow_index, borrow| {\n                 match (rw, borrow.kind) {"}, {"sha": "4db7debee7e8f64c8aca6769d0f8a3968ebfbe32", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::Constant { value } => Test {\n                 span: match_pair.pattern.span,\n-                kind: TestKind::Eq { value, ty: match_pair.pattern.ty.clone() },\n+                kind: TestKind::Eq { value, ty: match_pair.pattern.ty },\n             },\n \n             PatKind::Range(range) => {"}, {"sha": "61f4c00a4ca42fca2d062d5dd50aab703100f75d", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -156,6 +156,21 @@ impl<'a> NameResolution<'a> {\n     }\n }\n \n+// Reexports of the form `pub use foo as bar;` where `foo` is `extern crate foo;`\n+// are permitted for backward-compatibility under a deprecation lint.\n+fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBinding<'_>) -> bool {\n+    match (&import.kind, &binding.kind) {\n+        (\n+            ImportKind::Single { .. },\n+            NameBindingKind::Import {\n+                import: Import { kind: ImportKind::ExternCrate { .. }, .. },\n+                ..\n+            },\n+        ) => import.vis.get() == ty::Visibility::Public,\n+        _ => false,\n+    }\n+}\n+\n impl<'a> Resolver<'a> {\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n@@ -263,10 +278,7 @@ impl<'a> Resolver<'a> {\n                     return Err((Determined, Weak::No));\n                 }\n             }\n-            // `extern crate` are always usable for backwards compatibility, see issue #37020,\n-            // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n-            let usable = this.is_accessible_from(binding.vis, parent_scope.module)\n-                || binding.is_extern_crate();\n+            let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n@@ -309,10 +321,7 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n \n-                        if !(self.is_accessible_from(binding.vis, parent_scope.module) ||\n-                       // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n-                       (self.last_import_segment && binding.is_extern_crate()))\n-                        {\n+                        if !self.is_accessible_from(binding.vis, parent_scope.module) {\n                             self.privacy_errors.push(PrivacyError {\n                                 ident,\n                                 binding,\n@@ -455,9 +464,8 @@ impl<'a> Resolver<'a> {\n         binding: &'a NameBinding<'a>,\n         import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let vis = if binding.vis.is_at_least(import.vis.get(), self) ||\n-                     // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n-                     !import.is_glob() && binding.is_extern_crate()\n+        let vis = if binding.vis.is_at_least(import.vis.get(), self)\n+            || pub_use_of_private_extern_crate_hack(import, binding)\n         {\n             import.vis.get()\n         } else {\n@@ -1188,7 +1196,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // All namespaces must be re-exported with extra visibility for an error to occur.\n         if !any_successful_reexport {\n             let (ns, binding) = reexport_error.unwrap();\n-            if ns == TypeNS && binding.is_extern_crate() {\n+            if pub_use_of_private_extern_crate_hack(import, binding) {\n                 let msg = format!(\n                     \"extern crate `{}` is private, and cannot be \\\n                                    re-exported (error E0365), consider declaring with \\"}, {"sha": "9663760cba1895183b1b6dea4f70613474ca9bc0", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -18,7 +18,7 @@ use crate::{Edition, Span, DUMMY_SP, SESSION_GLOBALS};\n #[cfg(test)]\n mod tests;\n \n-// The proc macro code for this is in `src/librustc_macros/src/symbols.rs`.\n+// The proc macro code for this is in `compiler/rustc_macros/src/symbols.rs`.\n symbols! {\n     // After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n     // this should be rarely necessary though if the keywords are kept in alphabetic order.\n@@ -129,6 +129,7 @@ symbols! {\n         BTreeMap,\n         BTreeSet,\n         BinaryHeap,\n+        Borrow,\n         C,\n         CString,\n         Center,\n@@ -141,6 +142,7 @@ symbols! {\n         Decodable,\n         Decoder,\n         Default,\n+        Deref,\n         Encodable,\n         Encoder,\n         Eq,\n@@ -789,6 +791,9 @@ symbols! {\n         none_error,\n         nontemporal_store,\n         nontrapping_dash_fptoint: \"nontrapping-fptoint\",\n+        noop_method_borrow,\n+        noop_method_clone,\n+        noop_method_deref,\n         noreturn,\n         nostack,\n         not,"}, {"sha": "a3faf4cb7d4c19d1f2eb457087368fbcbfd56618", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -819,7 +819,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 sig.decl\n                     .inputs\n                     .iter()\n-                    .map(|arg| match arg.clone().kind {\n+                    .map(|arg| match arg.kind {\n                         hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                             Some(arg.span),\n                             vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],"}, {"sha": "b7275bac19048f701feeae31fb0f31654a51bf7a", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -165,7 +165,7 @@ crate fn evaluate_goal<'tcx>(\n                         // let's just ignore that\n                         let sol = Canonical {\n                             max_universe: ty::UniverseIndex::from_usize(0),\n-                            variables: obligation.variables.clone(),\n+                            variables: obligation.variables,\n                             value: QueryResponse {\n                                 var_values: CanonicalVarValues { var_values: IndexVec::new() }\n                                     .make_identity(tcx),"}, {"sha": "6ef63bcbbbf2171bc750a3a34cf1d51694e6b0e9", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expected_arg_tys = self.expected_inputs_for_expected_output(\n             call_expr.span,\n             expected,\n-            fn_sig.output().clone(),\n+            fn_sig.output(),\n             fn_sig.inputs(),\n         );\n "}, {"sha": "48740e533da8ea196155929cc884a9698e7aa2a2", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -711,7 +711,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         let ret_ty = ret_coercion.borrow().expected_ty();\n-        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n+        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty);\n         ret_coercion.borrow_mut().coerce(\n             self,\n             &self.cause(return_expr.span, ObligationCauseCode::ReturnValue(return_expr.hir_id)),"}, {"sha": "622983996aa08651edb6c36a82f5b868a4152e2b", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -14,7 +14,7 @@ use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n use super::search::SearchResult::*;\n \n mod entry;\n-pub use entry::{Entry, OccupiedEntry, VacantEntry};\n+pub use entry::{Entry, OccupiedEntry, OccupiedError, VacantEntry};\n use Entry::*;\n \n /// Minimum number of elements in nodes that are not a root.\n@@ -836,6 +836,40 @@ impl<K, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Tries to insert a key-value pair into the map, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// If the map already had this key present, nothing is updated, and\n+    /// an error containing the occupied entry and the value is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_try_insert)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n+    ///\n+    /// let err = map.try_insert(37, \"b\").unwrap_err();\n+    /// assert_eq!(err.entry.key(), &37);\n+    /// assert_eq!(err.entry.get(), &\"a\");\n+    /// assert_eq!(err.value, \"b\");\n+    /// ```\n+    #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n+        match self.entry(key) {\n+            Occupied(entry) => Err(OccupiedError { entry, value }),\n+            Vacant(entry) => Ok(entry.insert(value)),\n+        }\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///"}, {"sha": "6b30d95977395fc9c53d7cba74d5c79a487719a1", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -71,6 +71,41 @@ impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n     }\n }\n \n+/// The error returned by [`try_insert`](BTreeMap::try_insert) when the key already exists.\n+///\n+/// Contains the occupied entry, and the value that was not inserted.\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+pub struct OccupiedError<'a, K: 'a, V: 'a> {\n+    /// The entry in the map that was already occupied.\n+    pub entry: OccupiedEntry<'a, K, V>,\n+    /// The value which was not inserted, because the entry was already occupied.\n+    pub value: V,\n+}\n+\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<K: Debug + Ord, V: Debug> Debug for OccupiedError<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OccupiedError\")\n+            .field(\"key\", self.entry.key())\n+            .field(\"old_value\", self.entry.get())\n+            .field(\"new_value\", &self.value)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<'a, K: Debug + Ord, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"failed to insert {:?}, key {:?} already exists with value {:?}\",\n+            self.value,\n+            self.entry.key(),\n+            self.entry.get(),\n+        )\n+    }\n+}\n+\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry."}, {"sha": "e636e490e1bf4d02ce7dbb4fb59c57388b480764", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1801,11 +1801,11 @@ fn test_occupied_entry_key() {\n     let key = \"hello there\";\n     let value = \"value goes here\";\n     assert!(a.is_empty());\n-    a.insert(key.clone(), value.clone());\n+    a.insert(key, value);\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n \n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Vacant(_) => panic!(),\n         Occupied(e) => assert_eq!(key, *e.key()),\n     }\n@@ -1821,11 +1821,11 @@ fn test_vacant_entry_key() {\n     let value = \"value goes here\";\n \n     assert!(a.is_empty());\n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Occupied(_) => panic!(),\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n-            e.insert(value.clone());\n+            e.insert(value);\n         }\n     }\n     assert_eq!(a.len(), 1);"}, {"sha": "f28be20aaa1e6309d72be3a403a055a546707c18", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -153,6 +153,7 @@\n /// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n /// [`String`]: ../../std/string/struct.String.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Borrow\"]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n     ///\n@@ -205,6 +206,7 @@ pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Borrow<T> for T {\n+    #[rustc_diagnostic_item = \"noop_method_borrow\"]\n     fn borrow(&self) -> &T {\n         self\n     }"}, {"sha": "51a2dc03de3186668e51f942acd9cd841a0b3017", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -104,12 +104,14 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n+#[rustc_diagnostic_item = \"Clone\"]\n pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![allow(noop_method_call)]\n     /// let hello = \"Hello\"; // &str implements Clone\n     ///\n     /// assert_eq!(\"Hello\", hello.clone());\n@@ -221,6 +223,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Clone for &T {\n         #[inline]\n+        #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {\n             *self\n         }"}, {"sha": "fd7159d35fa7f063f02dfdc66daa678568d08536", "filename": "library/core/src/default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -80,6 +80,7 @@\n ///     bar: f32,\n /// }\n /// ```\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Default\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Default: Sized {\n     /// Returns the \"default value\" for a type."}, {"sha": "817fc2a51e981885a7cf926f8ad8e6d92e5d30eb", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -200,6 +200,7 @@ where\n         } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a.size() {\n             let i = self.index;\n             self.index += 1;\n+            self.len += 1;\n             // match the base implementation's potential side effects\n             // SAFETY: we just checked that `i` < `self.a.len()`\n             unsafe {\n@@ -258,7 +259,7 @@ where\n             if sz_a != sz_b {\n                 let sz_a = self.a.size();\n                 if A::MAY_HAVE_SIDE_EFFECT && sz_a > self.len {\n-                    for _ in 0..sz_a - cmp::max(self.len, self.index) {\n+                    for _ in 0..sz_a - self.len {\n                         self.a.next_back();\n                     }\n                 }"}, {"sha": "e179ce01c417a601f6c69814eeb7bc062609fd1b", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -93,6 +93,7 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n     message = \"`{Self}` is not an iterator\"\n )]\n #[doc(spotlight)]\n+#[rustc_diagnostic_item = \"Iterator\"]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub trait Iterator {\n     /// The type of the elements being iterated over."}, {"sha": "3e70ba81d49975f884e457a677b2e9ccd75f6c19", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -110,6 +110,60 @@ macro_rules! assert_ne {\n     });\n }\n \n+/// Asserts that an expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// On panic, this macro will print the value of the expression with its\n+/// debug representation.\n+///\n+/// Like [`assert!`], this macro has a second form, where a custom\n+/// panic message can be provided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(assert_matches)]\n+///\n+/// let a = 1u32.checked_add(2);\n+/// let b = 1u32.checked_sub(2);\n+/// assert_matches!(a, Some(_));\n+/// assert_matches!(b, None);\n+///\n+/// let c = Ok(\"abc\".to_string());\n+/// assert_matches!(c, Ok(x) | Err(x) if x.len() < 100);\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"assert_matches\", issue = \"82775\")]\n+#[allow_internal_unstable(core_panic)]\n+macro_rules! assert_matches {\n+    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => ({\n+        match $left {\n+            $( $pattern )|+ $( if $guard )? => {}\n+            ref left_val => {\n+                $crate::panicking::assert_matches_failed(\n+                    left_val,\n+                    $crate::stringify!($($pattern)|+ $(if $guard)?),\n+                    $crate::option::Option::None\n+                );\n+            }\n+        }\n+    });\n+    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )?, $($arg:tt)+) => ({\n+        match $left {\n+            $( $pattern )|+ $( if $guard )? => {}\n+            ref left_val => {\n+                $crate::panicking::assert_matches_failed(\n+                    left_val,\n+                    $crate::stringify!($($pattern)|+ $(if $guard)?),\n+                    $crate::option::Option::Some($crate::format_args!($($arg)+))\n+                );\n+            }\n+        }\n+    });\n+}\n+\n /// Asserts that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the [`panic!`] macro if the provided expression cannot be\n@@ -208,6 +262,42 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n+/// Asserts that an expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// On panic, this macro will print the value of the expression with its\n+/// debug representation.\n+///\n+/// Unlike [`assert_matches!`], `debug_assert_matches!` statements are only\n+/// enabled in non optimized builds by default. An optimized build will not\n+/// execute `debug_assert_matches!` statements unless `-C debug-assertions` is\n+/// passed to the compiler. This makes `debug_assert_matches!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development. The result of expanding `debug_assert_matches!`\n+/// is always type checked.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(assert_matches)]\n+///\n+/// let a = 1u32.checked_add(2);\n+/// let b = 1u32.checked_sub(2);\n+/// debug_assert_matches!(a, Some(_));\n+/// debug_assert_matches!(b, None);\n+///\n+/// let c = Ok(\"abc\".to_string());\n+/// debug_assert_matches!(c, Ok(x) | Err(x) if x.len() < 100);\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"assert_matches\", issue = \"82775\")]\n+#[allow_internal_unstable(assert_matches)]\n+macro_rules! debug_assert_matches {\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_matches!($($arg)*); })\n+}\n+\n /// Returns whether the given expression matches any of the given patterns.\n ///\n /// Like in a `match` expression, the pattern can be optionally followed by `if`"}, {"sha": "10e3ce67448c8d717dc28484ca6d5867516f7ffb", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -60,6 +60,7 @@\n #[doc(alias = \"*\")]\n #[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Deref\"]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -78,6 +79,7 @@ pub trait Deref {\n impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n+    #[rustc_diagnostic_item = \"noop_method_deref\"]\n     fn deref(&self) -> &T {\n         *self\n     }"}, {"sha": "12acf5b4329dbba8d615d355013dc0ca2035a8ca", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -97,6 +97,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n pub enum AssertKind {\n     Eq,\n     Ne,\n+    Match,\n }\n \n /// Internal function for `assert_eq!` and `assert_ne!` macros\n@@ -113,32 +114,54 @@ where\n     T: fmt::Debug + ?Sized,\n     U: fmt::Debug + ?Sized,\n {\n-    #[track_caller]\n-    fn inner(\n-        kind: AssertKind,\n-        left: &dyn fmt::Debug,\n-        right: &dyn fmt::Debug,\n-        args: Option<fmt::Arguments<'_>>,\n-    ) -> ! {\n-        let op = match kind {\n-            AssertKind::Eq => \"==\",\n-            AssertKind::Ne => \"!=\",\n-        };\n-\n-        match args {\n-            Some(args) => panic!(\n-                r#\"assertion failed: `(left {} right)`\n+    assert_failed_inner(kind, &left, &right, args)\n+}\n+\n+/// Internal function for `assert_match!`\n+#[cold]\n+#[track_caller]\n+#[doc(hidden)]\n+pub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n+    left: &T,\n+    right: &str,\n+    args: Option<fmt::Arguments<'_>>,\n+) -> ! {\n+    // Use the Display implementation to display the pattern.\n+    struct Pattern<'a>(&'a str);\n+    impl fmt::Debug for Pattern<'_> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::Display::fmt(self.0, f)\n+        }\n+    }\n+    assert_failed_inner(AssertKind::Match, &left, &Pattern(right), args);\n+}\n+\n+/// Non-generic version of the above functions, to avoid code bloat.\n+#[track_caller]\n+fn assert_failed_inner(\n+    kind: AssertKind,\n+    left: &dyn fmt::Debug,\n+    right: &dyn fmt::Debug,\n+    args: Option<fmt::Arguments<'_>>,\n+) -> ! {\n+    let op = match kind {\n+        AssertKind::Eq => \"==\",\n+        AssertKind::Ne => \"!=\",\n+        AssertKind::Match => \"matches\",\n+    };\n+\n+    match args {\n+        Some(args) => panic!(\n+            r#\"assertion failed: `(left {} right)`\n   left: `{:?}`,\n  right: `{:?}: {}`\"#,\n-                op, left, right, args\n-            ),\n-            None => panic!(\n-                r#\"assertion failed: `(left {} right)`\n+            op, left, right, args\n+        ),\n+        None => panic!(\n+            r#\"assertion failed: `(left {} right)`\n   left: `{:?}`,\n  right: `{:?}`\"#,\n-                op, left, right,\n-            ),\n-        }\n+            op, left, right,\n+        ),\n     }\n-    inner(kind, &left, &right, args)\n }"}, {"sha": "b336c03b5adbe04464d72376f78e9bb122d34fbf", "filename": "library/core/tests/iter/adapters/intersperse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fintersperse.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -9,7 +9,7 @@ fn test_intersperse() {\n     assert_eq!(v, vec![1]);\n \n     let xs = [\"a\", \"\", \"b\", \"c\"];\n-    let v: Vec<&str> = xs.iter().map(|x| x.clone()).intersperse(\", \").collect();\n+    let v: Vec<&str> = xs.iter().map(|x| *x).intersperse(\", \").collect();\n     let text: String = v.concat();\n     assert_eq!(text, \"a, , b, c\".to_string());\n \n@@ -24,7 +24,7 @@ fn test_intersperse_size_hint() {\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n \n     let xs = [\"a\", \"\", \"b\", \"c\"];\n-    let mut iter = xs.iter().map(|x| x.clone()).intersperse(\", \");\n+    let mut iter = xs.iter().map(|x| *x).intersperse(\", \");\n     assert_eq!(iter.size_hint(), (7, Some(7)));\n \n     assert_eq!(iter.next(), Some(\"a\"));"}, {"sha": "a5977103929527bcd7e636eb7ae5cfd42878fca5", "filename": "library/core/tests/iter/adapters/zip.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fzip.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -245,3 +245,23 @@ fn test_double_ended_zip() {\n     assert_eq!(it.next_back(), Some((3, 3)));\n     assert_eq!(it.next(), None);\n }\n+\n+#[test]\n+fn test_issue_82282() {\n+    fn overflowed_zip(arr: &[i32]) -> impl Iterator<Item = (i32, &())> {\n+        static UNIT_EMPTY_ARR: [(); 0] = [];\n+\n+        let mapped = arr.into_iter().map(|i| *i);\n+        let mut zipped = mapped.zip(UNIT_EMPTY_ARR.iter());\n+        zipped.next();\n+        zipped\n+    }\n+\n+    let arr = [1, 2, 3];\n+    let zip = overflowed_zip(&arr).zip(overflowed_zip(&arr));\n+\n+    assert_eq!(zip.size_hint(), (0, Some(0)));\n+    for _ in zip {\n+        panic!();\n+    }\n+}"}, {"sha": "233afa92389992328b7838417e2e046587a04a56", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-filelength\n+\n #[cfg(test)]\n mod tests;\n \n@@ -842,6 +844,37 @@ where\n         self.base.insert(k, v)\n     }\n \n+    /// Tries to insert a key-value pair into the map, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// If the map already had this key present, nothing is updated, and\n+    /// an error containing the occupied entry and the value is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_try_insert)]\n+    ///\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// assert_eq!(map.try_insert(37, \"a\").unwrap(), &\"a\");\n+    ///\n+    /// let err = map.try_insert(37, \"b\").unwrap_err();\n+    /// assert_eq!(err.entry.key(), &37);\n+    /// assert_eq!(err.entry.get(), &\"a\");\n+    /// assert_eq!(err.value, \"b\");\n+    /// ```\n+    #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+    pub fn try_insert(&mut self, key: K, value: V) -> Result<&mut V, OccupiedError<'_, K, V>> {\n+        match self.entry(key) {\n+            Occupied(entry) => Err(OccupiedError { entry, value }),\n+            Vacant(entry) => Ok(entry.insert(value)),\n+        }\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -1851,6 +1884,41 @@ impl<K: Debug, V> Debug for VacantEntry<'_, K, V> {\n     }\n }\n \n+/// The error returned by [`try_insert`](HashMap::try_insert) when the key already exists.\n+///\n+/// Contains the occupied entry, and the value that was not inserted.\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+pub struct OccupiedError<'a, K: 'a, V: 'a> {\n+    /// The entry in the map that was already occupied.\n+    pub entry: OccupiedEntry<'a, K, V>,\n+    /// The value which was not inserted, because the entry was already occupied.\n+    pub value: V,\n+}\n+\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<K: Debug, V: Debug> Debug for OccupiedError<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OccupiedError\")\n+            .field(\"key\", self.entry.key())\n+            .field(\"old_value\", self.entry.get())\n+            .field(\"new_value\", &self.value)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<'a, K: Debug, V: Debug> fmt::Display for OccupiedError<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"failed to insert {:?}, key {:?} already exists with value {:?}\",\n+            self.value,\n+            self.entry.key(),\n+            self.entry.get(),\n+        )\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n     type Item = (&'a K, &'a V);"}, {"sha": "819be14222752e1eb5724713361f22e504d90798", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -774,11 +774,11 @@ fn test_occupied_entry_key() {\n     let key = \"hello there\";\n     let value = \"value goes here\";\n     assert!(a.is_empty());\n-    a.insert(key.clone(), value.clone());\n+    a.insert(key, value);\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n \n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Vacant(_) => panic!(),\n         Occupied(e) => assert_eq!(key, *e.key()),\n     }\n@@ -793,11 +793,11 @@ fn test_vacant_entry_key() {\n     let value = \"value goes here\";\n \n     assert!(a.is_empty());\n-    match a.entry(key.clone()) {\n+    match a.entry(key) {\n         Occupied(_) => panic!(),\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n-            e.insert(value.clone());\n+            e.insert(value);\n         }\n     }\n     assert_eq!(a.len(), 1);"}, {"sha": "80c35307d52ac73643c26a9eef7e8f5bc46d75ac", "filename": "library/std/src/error.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -470,6 +470,24 @@ impl Error for char::DecodeUtf16Error {\n     }\n }\n \n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<'a, K: Debug + Ord, V: Debug> Error\n+    for crate::collections::btree_map::OccupiedError<'a, K, V>\n+{\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"key already exists\"\n+    }\n+}\n+\n+#[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n+impl<'a, K: Debug, V: Debug> Error for crate::collections::hash_map::OccupiedError<'a, K, V> {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"key already exists\"\n+    }\n+}\n+\n #[stable(feature = \"box_error\", since = \"1.8.0\")]\n impl<T: Error> Error for Box<T> {\n     #[allow(deprecated, deprecated_in_future)]"}, {"sha": "02b0fc0c57d559e85e37f9eca6296c659d6a1000", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1,6 +1,8 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::io::{self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, DEFAULT_BUF_SIZE};\n+use crate::io::{\n+    self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n+};\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n ///\n@@ -90,10 +92,9 @@ impl<R: Read> BufReader<R> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n         unsafe {\n-            let mut buffer = Vec::with_capacity(capacity);\n-            buffer.set_len(capacity);\n-            inner.initializer().initialize(&mut buffer);\n-            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n+            let mut buf = Box::new_uninit_slice(capacity).assume_init();\n+            inner.initializer().initialize(&mut buf);\n+            BufReader { inner, buf, pos: 0, cap: 0 }\n         }\n     }\n }\n@@ -435,3 +436,9 @@ impl<R: Seek> Seek for BufReader<R> {\n         })\n     }\n }\n+\n+impl<T> SizeHint for BufReader<T> {\n+    fn lower_bound(&self) -> usize {\n+        self.buffer().len()\n+    }\n+}"}, {"sha": "17002e3b8602d7eb2c45bbe1d8f7a48bb2941137", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -2238,6 +2238,19 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n     }\n }\n \n+impl<T, U> SizeHint for Chain<T, U> {\n+    fn lower_bound(&self) -> usize {\n+        SizeHint::lower_bound(&self.first) + SizeHint::lower_bound(&self.second)\n+    }\n+\n+    fn upper_bound(&self) -> Option<usize> {\n+        match (SizeHint::upper_bound(&self.first), SizeHint::upper_bound(&self.second)) {\n+            (Some(first), Some(second)) => Some(first + second),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// Reader adaptor which limits the bytes read from an underlying reader.\n ///\n /// This struct is generally created by calling [`take`] on a reader.\n@@ -2464,6 +2477,30 @@ impl<R: Read> Iterator for Bytes<R> {\n             };\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        SizeHint::size_hint(&self.inner)\n+    }\n+}\n+\n+trait SizeHint {\n+    fn lower_bound(&self) -> usize;\n+\n+    fn upper_bound(&self) -> Option<usize>;\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.lower_bound(), self.upper_bound())\n+    }\n+}\n+\n+impl<T> SizeHint for T {\n+    default fn lower_bound(&self) -> usize {\n+        0\n+    }\n+\n+    default fn upper_bound(&self) -> Option<usize> {\n+        None\n+    }\n }\n \n /// An iterator over the contents of an instance of `BufRead` split on a"}, {"sha": "a85dd0d98271565ca6d6fb9cf69e54d3ba22aa7d", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1,7 +1,7 @@\n use super::{repeat, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::io::{BufRead, Read, Seek, Write};\n+use crate::io::{BufRead, BufReader, Read, Seek, Write};\n use crate::ops::Deref;\n \n #[test]\n@@ -198,6 +198,53 @@ fn chain_bufread() {\n     cmp_bufread(chain1, chain2, &testdata[..]);\n }\n \n+#[test]\n+fn bufreader_size_hint() {\n+    let testdata = b\"ABCDEFGHIJKL\";\n+    let mut buf_reader = BufReader::new(&testdata[..]);\n+    assert_eq!(buf_reader.buffer().len(), 0);\n+\n+    let buffer_length = testdata.len();\n+    buf_reader.fill_buf().unwrap();\n+\n+    // Check that size hint matches buffer contents\n+    let mut buffered_bytes = buf_reader.bytes();\n+    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n+    assert_eq!(lower_bound, buffer_length);\n+\n+    // Check that size hint matches buffer contents after advancing\n+    buffered_bytes.next().unwrap().unwrap();\n+    let (lower_bound, _upper_bound) = buffered_bytes.size_hint();\n+    assert_eq!(lower_bound, buffer_length - 1);\n+}\n+\n+#[test]\n+fn empty_size_hint() {\n+    let size_hint = io::empty().bytes().size_hint();\n+    assert_eq!(size_hint, (0, Some(0)));\n+}\n+\n+#[test]\n+fn chain_empty_size_hint() {\n+    let chain = io::empty().chain(io::empty());\n+    let size_hint = chain.bytes().size_hint();\n+    assert_eq!(size_hint, (0, Some(0)));\n+}\n+\n+#[test]\n+fn chain_size_hint() {\n+    let testdata = b\"ABCDEFGHIJKL\";\n+    let mut buf_reader_1 = BufReader::new(&testdata[..6]);\n+    let mut buf_reader_2 = BufReader::new(&testdata[6..]);\n+\n+    buf_reader_1.fill_buf().unwrap();\n+    buf_reader_2.fill_buf().unwrap();\n+\n+    let chain = buf_reader_1.chain(buf_reader_2);\n+    let size_hint = chain.bytes().size_hint();\n+    assert_eq!(size_hint, (testdata.len(), None));\n+}\n+\n #[test]\n fn chain_zero_length_read_is_not_eof() {\n     let a = b\"A\";"}, {"sha": "f472361f916db3f0615e92b732791f8c75ad53d8", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -4,7 +4,9 @@\n mod tests;\n \n use crate::fmt;\n-use crate::io::{self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n+use crate::io::{\n+    self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n+};\n \n /// A reader which is always at EOF.\n ///\n@@ -80,6 +82,12 @@ impl fmt::Debug for Empty {\n     }\n }\n \n+impl SizeHint for Empty {\n+    fn upper_bound(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+}\n+\n /// A reader which yields one byte over and over and over and over and over and...\n ///\n /// This struct is generally created by calling [`repeat()`]. Please"}, {"sha": "72b86338d2c9783e7fef77db8a45b471dbfcb7d1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -228,6 +228,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n+#![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n@@ -281,6 +282,7 @@\n #![feature(linkage)]\n #![feature(llvm_asm)]\n #![feature(log_syntax)]\n+#![feature(map_try_insert)]\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n@@ -289,6 +291,7 @@\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n+#![feature(new_uninit)]\n #![feature(nll)]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(once_cell)]\n@@ -550,8 +553,8 @@ pub use std_detect::detect;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::{\n-    assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne, matches, r#try, todo,\n-    unimplemented, unreachable, write, writeln,\n+    assert_eq, assert_matches, assert_ne, debug_assert, debug_assert_eq, debug_assert_matches,\n+    debug_assert_ne, matches, r#try, todo, unimplemented, unreachable, write, writeln,\n };\n \n // Re-export built-in macros defined through libcore."}, {"sha": "c9b8100fd03784b6fa01092b188fa46aefa42fd2", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -843,7 +843,6 @@ function defocusSearchBar() {\n             function checkGenerics(obj, val) {\n                 // The names match, but we need to be sure that all generics kinda\n                 // match as well.\n-                var lev_distance = MAX_LEV_DISTANCE + 1;\n                 if (val.generics.length > 0) {\n                     if (obj.length > GENERICS_DATA &&\n                           obj[GENERICS_DATA].length >= val.generics.length) {\n@@ -866,7 +865,6 @@ function defocusSearchBar() {\n                             }\n                             if (lev.pos !== -1) {\n                                 elems.splice(lev.pos, 1);\n-                                lev_distance = Math.min(lev.lev, lev_distance);\n                                 total += lev.lev;\n                                 done += 1;\n                             } else {\n@@ -2054,24 +2052,6 @@ function defocusSearchBar() {\n         }\n     }\n \n-    /**\n-     * Convert HTML to plaintext:\n-     *\n-     *   * Replace \"<code>foo</code>\" with \"`foo`\"\n-     *   * Strip all other HTML tags\n-     *\n-     * Used by the dynamic sidebar crate list renderer.\n-     *\n-     * @param  {[string]} html [The HTML to convert]\n-     * @return {[string]}      [The resulting plaintext]\n-     */\n-    function convertHTMLToPlaintext(html) {\n-        var x = document.createElement(\"div\");\n-        x.innerHTML = html.replace('<code>', '`').replace('</code>', '`');\n-        return x.innerText;\n-    }\n-\n-\n     // delayed sidebar rendering.\n     window.initSidebarItems = function(items) {\n         var sidebar = document.getElementsByClassName(\"sidebar-elems\")[0];"}, {"sha": "0383ccf7db666492997aa7663df2ab69454b51d9", "filename": "src/test/rustdoc/extern-links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Frustdoc%2Fextern-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Frustdoc%2Fextern-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-links.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -3,7 +3,7 @@\n \n #![crate_name = \"foo\"]\n \n-extern crate extern_links;\n+pub extern crate extern_links;\n \n // @!has foo/index.html '//a' 'extern_links'\n #[doc(no_inline)]"}, {"sha": "38a520850b6dd44b9e20d9b15671178d418ca987", "filename": "src/test/rustdoc/issue-28927.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Frustdoc%2Fissue-28927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Frustdoc%2Fissue-28927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28927.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -2,5 +2,5 @@\n // aux-build:issue-28927-1.rs\n // ignore-cross-compile\n \n-extern crate issue_28927_1 as inner1;\n+pub extern crate issue_28927_1 as inner1;\n pub use inner1 as foo;"}, {"sha": "1cad59f1062c6cf8f01e6593bfebcd5b8d6c6a3b", "filename": "src/test/ui/issues/issue-81584.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81584.fixed?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+        let _ = vec![vec![0, 1], vec![2]]\n+            .into_iter()\n+            .map(|y| y.iter().map(|x| x + 1).collect::<Vec<_>>())\n+                  //~^ ERROR cannot return value referencing function parameter `y`\n+            .collect::<Vec<_>>();\n+}"}, {"sha": "452288db08bd8981f096c24e808184ff6b2a0173", "filename": "src/test/ui/issues/issue-81584.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81584.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+fn main() {\n+        let _ = vec![vec![0, 1], vec![2]]\n+            .into_iter()\n+            .map(|y| y.iter().map(|x| x + 1))\n+                  //~^ ERROR cannot return value referencing function parameter `y`\n+            .collect::<Vec<_>>();\n+}"}, {"sha": "d57f1b778df176db34d013dea24b35af61b12d18", "filename": "src/test/ui/issues/issue-81584.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fissues%2Fissue-81584.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-81584.stderr?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,14 @@\n+error[E0515]: cannot return value referencing function parameter `y`\n+  --> $DIR/issue-81584.rs:5:22\n+   |\n+LL |             .map(|y| y.iter().map(|x| x + 1))\n+   |                      -^^^^^^^^^^^^^^^^^^^^^^\n+   |                      |\n+   |                      returns a value referencing data owned by the current function\n+   |                      `y` is borrowed here\n+   |\n+   = help: use `.collect()` to allocate the iterator\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "9870c813572e36d15c6935adfe8f742f778d7368", "filename": "src/test/ui/lint/noop-method-call.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,54 @@\n+// check-pass\n+\n+#![allow(unused)]\n+#![warn(noop_method_call)]\n+\n+use std::borrow::Borrow;\n+use std::ops::Deref;\n+\n+struct PlainType<T>(T);\n+\n+#[derive(Clone)]\n+struct CloneType<T>(T);\n+\n+fn main() {\n+    let non_clone_type_ref = &PlainType(1u32);\n+    let non_clone_type_ref_clone: &PlainType<u32> = non_clone_type_ref.clone();\n+    //~^ WARNING call to `.clone()` on a reference in this situation does nothing\n+\n+    let clone_type_ref = &CloneType(1u32);\n+    let clone_type_ref_clone: CloneType<u32> = clone_type_ref.clone();\n+\n+    // Calling clone on a double reference doesn't warn since the method call itself\n+    // peels the outer reference off\n+    let clone_type_ref = &&CloneType(1u32);\n+    let clone_type_ref_clone: &CloneType<u32> = clone_type_ref.clone();\n+\n+    let non_deref_type = &PlainType(1u32);\n+    let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+    //~^ WARNING call to `.deref()` on a reference in this situation does nothing\n+\n+    // Dereferencing a &&T does not warn since it has collapsed the double reference\n+    let non_deref_type = &&PlainType(1u32);\n+    let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+\n+    let non_borrow_type = &PlainType(1u32);\n+    let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+    //~^ WARNING call to `.borrow()` on a reference in this situation does nothing\n+\n+    // Borrowing a &&T does not warn since it has collapsed the double reference\n+    let non_borrow_type = &&PlainType(1u32);\n+    let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+\n+    let xs = [\"a\", \"b\", \"c\"];\n+    let _v: Vec<&str> = xs.iter().map(|x| x.clone()).collect(); // ok, but could use `*x` instead\n+}\n+\n+fn generic<T>(non_clone_type: &PlainType<T>) {\n+    non_clone_type.clone();\n+}\n+\n+fn non_generic(non_clone_type: &PlainType<u32>) {\n+    non_clone_type.clone();\n+    //~^ WARNING call to `.clone()` on a reference in this situation does nothing\n+}"}, {"sha": "7f6f96bf1d142218d4e923ec25fe6d79bed6da81", "filename": "src/test/ui/lint/noop-method-call.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -0,0 +1,39 @@\n+warning: call to `.clone()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:16:71\n+   |\n+LL |     let non_clone_type_ref_clone: &PlainType<u32> = non_clone_type_ref.clone();\n+   |                                                                       ^^^^^^^^ unnecessary method call\n+   |\n+note: the lint level is defined here\n+  --> $DIR/noop-method-call.rs:4:9\n+   |\n+LL | #![warn(noop_method_call)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: the type `&PlainType<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n+\n+warning: call to `.deref()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:28:63\n+   |\n+LL |     let non_deref_type_deref: &PlainType<u32> = non_deref_type.deref();\n+   |                                                               ^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `deref` is being called on is the same as the type returned from `deref`, so the method call does not do anything and can be removed\n+\n+warning: call to `.borrow()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:36:66\n+   |\n+LL |     let non_borrow_type_borrow: &PlainType<u32> = non_borrow_type.borrow();\n+   |                                                                  ^^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `borrow` is being called on is the same as the type returned from `borrow`, so the method call does not do anything and can be removed\n+\n+warning: call to `.clone()` on a reference in this situation does nothing\n+  --> $DIR/noop-method-call.rs:52:19\n+   |\n+LL |     non_clone_type.clone();\n+   |                   ^^^^^^^^ unnecessary method call\n+   |\n+   = note: the type `&PlainType<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n+\n+warning: 4 warnings emitted\n+"}, {"sha": "dd5cd420fa546df0c3d779783d18d04d3f247a09", "filename": "src/test/ui/pub/pub-reexport-priv-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1,5 +1,3 @@\n-#![allow(unused)]\n-\n extern crate core;\n pub use core as reexported_core; //~ ERROR `core` is private, and cannot be re-exported\n                                  //~^ WARN this was previously accepted\n@@ -9,16 +7,14 @@ mod foo1 {\n }\n \n mod foo2 {\n-    use foo1::core; //~ ERROR `core` is private, and cannot be re-exported\n-                    //~^ WARN this was previously accepted\n+    use foo1::core; //~ ERROR crate import `core` is private\n     pub mod bar {\n         extern crate core;\n     }\n }\n \n mod baz {\n-    pub use foo2::bar::core; //~ ERROR `core` is private, and cannot be re-exported\n-                             //~^ WARN this was previously accepted\n+    pub use foo2::bar::core; //~ ERROR crate import `core` is private\n }\n \n fn main() {}"}, {"sha": "e4d73c6475dc4b20a841f24cd4eb1d2b60951207", "filename": "src/test/ui/pub/pub-reexport-priv-extern-crate.stderr", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-reexport-priv-extern-crate.stderr?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -1,30 +1,37 @@\n-error: extern crate `core` is private, and cannot be re-exported (error E0365), consider declaring with `pub`\n-  --> $DIR/pub-reexport-priv-extern-crate.rs:4:9\n+error[E0603]: crate import `core` is private\n+  --> $DIR/pub-reexport-priv-extern-crate.rs:10:15\n    |\n-LL | pub use core as reexported_core;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     use foo1::core;\n+   |               ^^^^ private crate import\n    |\n-   = note: `#[deny(pub_use_of_private_extern_crate)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+note: the crate import `core` is defined here\n+  --> $DIR/pub-reexport-priv-extern-crate.rs:6:5\n+   |\n+LL |     extern crate core;\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: extern crate `core` is private, and cannot be re-exported (error E0365), consider declaring with `pub`\n-  --> $DIR/pub-reexport-priv-extern-crate.rs:12:9\n+error[E0603]: crate import `core` is private\n+  --> $DIR/pub-reexport-priv-extern-crate.rs:17:24\n    |\n-LL |     use foo1::core;\n-   |         ^^^^^^^^^^\n+LL |     pub use foo2::bar::core;\n+   |                        ^^^^ private crate import\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+note: the crate import `core` is defined here\n+  --> $DIR/pub-reexport-priv-extern-crate.rs:12:9\n+   |\n+LL |         extern crate core;\n+   |         ^^^^^^^^^^^^^^^^^^\n \n error: extern crate `core` is private, and cannot be re-exported (error E0365), consider declaring with `pub`\n-  --> $DIR/pub-reexport-priv-extern-crate.rs:20:13\n+  --> $DIR/pub-reexport-priv-extern-crate.rs:2:9\n    |\n-LL |     pub use foo2::bar::core;\n-   |             ^^^^^^^^^^^^^^^\n+LL | pub use core as reexported_core;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: `#[deny(pub_use_of_private_extern_crate)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "ff15884bd445d1ca3ace54e8f2348db6f0d5314a", "filename": "src/test/ui/static/static-reference-to-fn-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fstatic%2Fstatic-reference-to-fn-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Fstatic%2Fstatic-reference-to-fn-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-reference-to-fn-2.stderr?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -40,6 +40,8 @@ LL | |         statefn: &id(state1 as StateMachineFunc)\n    | |                   ------------------------------ temporary value created here\n LL | |     }\n    | |_____^ returns a value referencing data owned by the current function\n+   |\n+   = help: use `.collect()` to allocate the iterator\n \n error: aborting due to 4 previous errors\n "}, {"sha": "510d91d0d462487ee91e4cbfc18739f919b0448d", "filename": "src/test/ui/underscore-imports/hygiene-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fd946c63a6c3aae9788bd459d278cb2efa77099/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene-2.rs?ref=8fd946c63a6c3aae9788bd459d278cb2efa77099", "patch": "@@ -29,5 +29,6 @@ m!(y);\n \n fn main() {\n     use crate::y::*;\n+    #[allow(noop_method_call)]\n     (&()).deref();\n }"}]}