{"sha": "18a825bda0a6098d3d8982784f3dffb908df5e40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YTgyNWJkYTBhNjA5OGQzZDg5ODI3ODRmM2RmZmI5MDhkZjVlNDA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-13T01:14:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-13T01:14:15Z"}, "message": "Reorder codemap decls", "tree": {"sha": "c87f8a8828bd9894f57b27db0bfbd73e21c3b6a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c87f8a8828bd9894f57b27db0bfbd73e21c3b6a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18a825bda0a6098d3d8982784f3dffb908df5e40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18a825bda0a6098d3d8982784f3dffb908df5e40", "html_url": "https://github.com/rust-lang/rust/commit/18a825bda0a6098d3d8982784f3dffb908df5e40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18a825bda0a6098d3d8982784f3dffb908df5e40/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b248a6ca8962249d5882375610764a6dd9561c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b248a6ca8962249d5882375610764a6dd9561c3", "html_url": "https://github.com/rust-lang/rust/commit/5b248a6ca8962249d5882375610764a6dd9561c3"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "be7e2025120ef7deb5bb6fc116bd42c883337ba7", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/18a825bda0a6098d3d8982784f3dffb908df5e40/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18a825bda0a6098d3d8982784f3dffb908df5e40/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=18a825bda0a6098d3d8982784f3dffb908df5e40", "patch": "@@ -39,8 +39,40 @@ export loc;\n export get_filemap;\n export new_codemap;\n \n+struct span {lo: uint, hi: uint, expn_info: expn_info}\n+\n+impl span : cmp::Eq {\n+    pure fn eq(other: &span) -> bool {\n+        return self.lo == (*other).lo && self.hi == (*other).hi;\n+    }\n+    pure fn ne(other: &span) -> bool { !self.eq(other) }\n+}\n+\n+impl<S: Serializer> span: Serializable<S> {\n+    /* Note #1972 -- spans are serialized but not deserialized */\n+    fn serialize(&self, _s: &S) { }\n+}\n+\n+impl<D: Deserializer> span: Deserializable<D> {\n+    static fn deserialize(_d: &D) -> span {\n+        ast_util::dummy_sp()\n+    }\n+}\n+\n+enum expn_info_ {\n+    expanded_from({call_site: span,\n+                   callie: {name: ~str, span: Option<span>}})\n+}\n+type expn_info = Option<@expn_info_>;\n+\n type filename = ~str;\n \n+type lookup_fn = pure fn(file_pos) -> uint;\n+\n+struct loc {\n+    file: @filemap, line: uint, col: uint\n+}\n+\n struct file_pos {\n     ch: uint, byte: uint\n }\n@@ -90,10 +122,6 @@ struct CodeMap {\n     files: DVec<@filemap>\n }\n \n-struct loc {\n-    file: @filemap, line: uint, col: uint\n-}\n-\n fn new_codemap() -> CodeMap {\n     CodeMap {\n         files: DVec()\n@@ -110,8 +138,6 @@ fn next_line(file: @filemap, chpos: uint, byte_pos: uint) {\n     file.lines.push(file_pos {ch: chpos, byte: byte_pos + file.start_pos.byte});\n }\n \n-type lookup_fn = pure fn(file_pos) -> uint;\n-\n fn lookup_line(map: @CodeMap, pos: uint, lookup: lookup_fn)\n     -> {fm: @filemap, line: uint}\n {\n@@ -186,32 +212,6 @@ fn adjust_span(map: @CodeMap, sp: span) -> span {\n     }\n }\n \n-enum expn_info_ {\n-    expanded_from({call_site: span,\n-                   callie: {name: ~str, span: Option<span>}})\n-}\n-type expn_info = Option<@expn_info_>;\n-\n-struct span {lo: uint, hi: uint, expn_info: expn_info}\n-\n-impl span : cmp::Eq {\n-    pure fn eq(other: &span) -> bool {\n-        return self.lo == (*other).lo && self.hi == (*other).hi;\n-    }\n-    pure fn ne(other: &span) -> bool { !self.eq(other) }\n-}\n-\n-impl<S: Serializer> span: Serializable<S> {\n-    /* Note #1972 -- spans are serialized but not deserialized */\n-    fn serialize(&self, _s: &S) { }\n-}\n-\n-impl<D: Deserializer> span: Deserializable<D> {\n-    static fn deserialize(_d: &D) -> span {\n-        ast_util::dummy_sp()\n-    }\n-}\n-\n fn span_to_str_no_adj(sp: span, cm: @CodeMap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);"}]}