{"sha": "76854677c1b730ecb262b5277a6520fc2ff75974", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ODU0Njc3YzFiNzMwZWNiMjYyYjUyNzdhNjUyMGZjMmZmNzU5NzQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T01:00:46Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T01:00:46Z"}, "message": "New reformatting of fns", "tree": {"sha": "035a797668300dc97bcb722f9b6b0f463ebc9dd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/035a797668300dc97bcb722f9b6b0f463ebc9dd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76854677c1b730ecb262b5277a6520fc2ff75974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76854677c1b730ecb262b5277a6520fc2ff75974", "html_url": "https://github.com/rust-lang/rust/commit/76854677c1b730ecb262b5277a6520fc2ff75974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76854677c1b730ecb262b5277a6520fc2ff75974/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a82a9791f80599a2e476be740c49136acd6aa618", "url": "https://api.github.com/repos/rust-lang/rust/commits/a82a9791f80599a2e476be740c49136acd6aa618", "html_url": "https://github.com/rust-lang/rust/commit/a82a9791f80599a2e476be740c49136acd6aa618"}], "stats": {"total": 676, "additions": 555, "deletions": 121}, "files": [{"sha": "562aada3103fc306d697f80da9f1386336be3295", "filename": "src/changes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -45,7 +45,8 @@ impl<'a> ChangeSet<'a> {\n     }\n \n     pub fn push_str(&mut self, file_name: &str, text: &str) {\n-        self.file_map[*file_name].push_str(text)\n+        let buf = self.file_map.get_mut(&*file_name).unwrap();\n+        buf.push_str(text)\n     }\n \n     pub fn push_str_span(&mut self, span: Span, text: &str) {\n@@ -54,7 +55,7 @@ impl<'a> ChangeSet<'a> {\n     }\n \n     pub fn cur_offset(&mut self, file_name: &str) -> usize {\n-        self.file_map[*file_name].cur_offset()\n+        self.file_map[&*file_name].cur_offset()\n     }\n \n     pub fn cur_offset_span(&mut self, span: Span) -> usize {\n@@ -91,7 +92,7 @@ impl<'c, 'a> Iterator for FileIterator<'c, 'a> {\n \n         let key = self.keys[self.cur_key];\n         self.cur_key += 1;\n-        return Some((&key, &self.change_set.file_map[*key]))\n+        return Some((&key, &self.change_set.file_map[&*key]))\n     }\n }\n "}, {"sha": "34f79e639167415ab6e9c24a2d309a0d41053bed", "filename": "src/mod.rs", "status": "modified", "additions": 545, "deletions": 116, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -12,14 +12,21 @@\n #![feature(box_patterns)]\n #![feature(rustc_private)]\n #![feature(collections)]\n-#![feature(os)]\n #![feature(core)]\n #![feature(unicode)]\n #![feature(exit_status)]\n-#![feature(path)]\n+#![feature(str_char)]\n \n // TODO we're going to allocate a whole bunch of temp Strings, is it worth\n // keeping some scratch mem for this and running our own StrPool?\n+// TODO for lint violations of names, emit a refactor script\n+\n+// TODO priorities\n+// Fix fns and methods properly - need visibility in visit\n+// Use strings crate\n+// Writing output\n+// Working on multiple files, inclding empty ones\n+// Smoke testing till we can use it\n \n #[macro_use]\n extern crate log;\n@@ -33,15 +40,14 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input};\n use rustc_driver::{driver, CompilerCalls, Compilation};\n \n-use syntax::{ast, ptr};\n+use syntax::{ast, ptr, abi};\n use syntax::codemap::{self, CodeMap, Span, Pos, BytePos};\n use syntax::diagnostics;\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::visit;\n \n use std::path::PathBuf;\n-use std::slice::SliceConcatExt;\n \n use changes::ChangeSet;\n \n@@ -53,6 +59,7 @@ const IDEAL_WIDTH: usize = 80;\n const LEEWAY: usize = 5;\n const MAX_WIDTH: usize = 100;\n const MIN_STRING: usize = 10;\n+const TAB_SPACES: usize = 4;\n \n // Formatting which depends on the AST.\n fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n@@ -71,7 +78,7 @@ fn fmt_lines(changes: &mut ChangeSet) {\n     // Iterate over the chars in the change set.\n     for (f, text) in changes.text() {\n         let mut trims = vec![];\n-        let mut last_wspace = None;\n+        let mut last_wspace: Option<usize> = None;\n         let mut line_len = 0;\n         let mut cur_line = 1;\n         for (c, b) in text.chars() {\n@@ -113,11 +120,16 @@ struct FmtVisitor<'a> {\n     codemap: &'a CodeMap,\n     changes: ChangeSet<'a>,\n     last_pos: BytePos,\n+    // TODO RAII util for indenting\n     block_indent: usize,\n }\n \n impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        // TODO uncomment\n+        // debug!(\"visit_expr: {:?} {:?}\",\n+        //        self.codemap.lookup_char_pos(ex.span.lo),\n+        //        self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n         let offset = self.changes.cur_offset_span(ex.span);\n         let new_str = self.rewrite_expr(ex, MAX_WIDTH - offset, offset);\n@@ -126,15 +138,19 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     }\n \n     fn visit_block(&mut self, b: &'v ast::Block) {\n+        // TODO uncomment\n+        // debug!(\"visit_block: {:?} {:?}\",\n+        //        self.codemap.lookup_char_pos(b.span.lo),\n+        //        self.codemap.lookup_char_pos(b.span.hi));\n         self.format_missing(b.span.lo);\n \n         self.changes.push_str_span(b.span, \"{\");\n         self.last_pos = self.last_pos + BytePos(1);\n-        self.block_indent += 4;\n+        self.block_indent += TAB_SPACES;\n \n         for stmt in &b.stmts {\n             self.format_missing_with_indent(stmt.span.lo);\n-            self.visit_stmt(&**stmt)\n+            self.visit_stmt(&stmt)\n         }\n         match b.expr {\n             Some(ref e) => {\n@@ -144,7 +160,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             None => {}\n         }\n \n-        self.block_indent -= 4;\n+        self.block_indent -= TAB_SPACES;\n         // TODO we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - BytePos(1));\n         self.changes.push_str_span(b.span, \"}\");\n@@ -157,10 +173,44 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 _: ast::NodeId) {\n-        if let Some(new_str) = self.formal_args(fk, fd) {\n-            self.changes.push_str_span(s, &new_str);            \n+        // TODO need to get the visibility from somewhere\n+        self.format_missing(s.lo);\n+        self.last_pos = s.lo;\n+\n+        // TODO need to check against expected indent\n+        let indent = self.codemap.lookup_char_pos(s.lo).col.0;\n+        match fk {\n+            visit::FkItemFn(ident, ref generics, ref unsafety, ref abi) => {\n+                let new_fn = self.rewrite_fn(indent,\n+                                             ident,\n+                                             fd,\n+                                             None,\n+                                             generics,\n+                                             unsafety,\n+                                             abi,\n+                                             ast::Visibility::Inherited);\n+                self.changes.push_str_span(s, &new_fn);\n+            }\n+            visit::FkMethod(ident, ref sig) => {\n+                let new_fn = self.rewrite_fn(indent,\n+                                             ident,\n+                                             fd,\n+                                             Some(&sig.explicit_self),\n+                                             &sig.generics,\n+                                             &sig.unsafety,\n+                                             &sig.abi,\n+                                             ast::Visibility::Inherited);\n+                self.changes.push_str_span(s, &new_fn);\n+            }\n+            visit::FkFnBlock(..) => {}\n         }\n-        visit::walk_fn(self, fk, fd, b, s);\n+\n+        // FIXME we'll miss anything between the end of the signature and the start\n+        // of the body, but we need more spans from the compiler to solve this.\n+        self.changes.push_str_span(s, \"\\n\");\n+        self.changes.push_str_span(s, &make_indent(self.block_indent));\n+        self.last_pos = b.span.lo;\n+        self.visit_block(b)\n     }\n \n     fn visit_item(&mut self, item: &'v ast::Item) {\n@@ -169,7 +219,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 match vp.node {\n                     ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n                         self.format_missing(item.span.lo);\n-                        let new_str = self.fix_use_list(path, path_list, vp.span);\n+                        let new_str = self.rewrite_use_list(path, path_list, vp.span);\n                         self.changes.push_str_span(item.span, &new_str);\n                         self.last_pos = item.span.hi;\n                     }\n@@ -181,15 +231,19 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 visit::walk_item(self, item);\n             }\n             ast::Item_::ItemImpl(..) => {\n-                self.block_indent += 4;\n+                self.block_indent += TAB_SPACES;\n                 visit::walk_item(self, item);\n-                self.block_indent -= 4;\n+                self.block_indent -= TAB_SPACES;\n             }\n             _ => {\n                 visit::walk_item(self, item);\n             }\n         }\n     }\n+\n+    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n+        visit::walk_mac(self, mac)\n+    }\n }\n \n fn make_indent(width: usize) -> String {\n@@ -200,6 +254,131 @@ fn make_indent(width: usize) -> String {\n     indent\n }\n \n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+enum ListTactic {\n+    // One item per row.\n+    Vertical,\n+    // All items on one row.\n+    Horizontal,\n+    // Try Horizontal layout, if that fails then vertical\n+    HorizontalVertical,\n+    // Pack as many items as possible per row over (possibly) many rows.\n+    Mixed,\n+}\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+enum SeparatorTactic {\n+    Always,\n+    Never,\n+    Vertical,\n+}\n+\n+struct ListFormatting<'a> {\n+    tactic: ListTactic,\n+    separator: &'a str,\n+    trailing_separator: SeparatorTactic,\n+    indent: usize,\n+    // Available width if we layout horizontally.\n+    h_width: usize,\n+    // Available width if we layout vertically\n+    v_width: usize,\n+}\n+\n+// Format a list of strings into a string.\n+fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>) -> String {\n+    if items.len() == 0 {\n+        return String::new();\n+    }\n+\n+    let mut tactic = formatting.tactic;\n+\n+    let h_width = formatting.h_width;\n+    let v_width = formatting.v_width;\n+    let sep_len = formatting.separator.len();\n+\n+    // Conservatively overestimates because of the changing separator tactic.\n+    let sep_count = if formatting.trailing_separator != SeparatorTactic::Never {\n+        items.len()\n+    } else {\n+        items.len() - 1\n+    };\n+\n+    // TODO count dead space too.\n+    let total_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n+\n+    // Check if we need to fallback from horizontal listing, if possible.\n+    if tactic == ListTactic::HorizontalVertical { \n+        if (total_width + (sep_len + 1) * sep_count) > h_width {\n+            tactic = ListTactic::Vertical;\n+        } else {\n+            tactic = ListTactic::Horizontal;\n+        }\n+    }\n+\n+    // Now that we know how we will layout, we can decide for sure if there\n+    // will be a trailing separator.\n+    let trailing_separator = match formatting.trailing_separator {\n+        SeparatorTactic::Always => true,\n+        SeparatorTactic::Vertical => tactic == ListTactic::Vertical,\n+        SeparatorTactic::Never => false,\n+    };\n+\n+    // Create a buffer for the result.\n+    // TODO could use a StringBuffer or rope for this\n+    let alloc_width = if tactic == ListTactic::Horizontal {\n+        total_width + (sep_len + 1) * sep_count\n+    } else {\n+        total_width + items.len() * (formatting.indent + 1)\n+    };\n+    let mut result = String::with_capacity(alloc_width);\n+\n+    let mut line_len = 0;\n+    let indent_str = &make_indent(formatting.indent);\n+    for (i, &(ref item, _)) in items.iter().enumerate() {\n+        let first = i == 0;\n+        let separate = i != items.len() - 1 || trailing_separator;\n+\n+        match tactic {\n+            ListTactic::Horizontal if !first => {\n+                result.push(' ');\n+            }\n+            ListTactic::Vertical if !first => {\n+                result.push('\\n');\n+                result.push_str(indent_str);\n+            }\n+            ListTactic::Mixed => {\n+                let mut item_width = item.len();\n+                if separate {\n+                    item_width += sep_len;\n+                }\n+\n+                if line_len > 0 && line_len + item_width > v_width {\n+                    result.push('\\n');\n+                    result.push_str(indent_str);\n+                    line_len = 0;\n+                }\n+\n+                if line_len > 0 {\n+                    result.push(' ');\n+                    line_len += 1;\n+                }\n+\n+                line_len += item_width;\n+            }\n+            _ => {}\n+        }\n+\n+        result.push_str(item);\n+        \n+        if separate {\n+            result.push_str(formatting.separator);\n+        }\n+        // TODO dead spans\n+    }\n+\n+    result\n+}\n+\n impl<'a> FmtVisitor<'a> {\n     fn from_codemap<'b>(codemap: &'b CodeMap) -> FmtVisitor<'b> {\n         FmtVisitor {\n@@ -210,6 +389,8 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n+    // TODO these format_missing methods are ugly. Refactor and add unit tests\n+    // for the central whitespace stripping loop.\n     fn format_missing(&mut self, end: BytePos) {\n         self.format_missing_inner(end, |this, last_snippet, span, _| {\n             this.changes.push_str_span(span, last_snippet)\n@@ -226,7 +407,7 @@ impl<'a> FmtVisitor<'a> {\n                 this.changes.push_str_span(span, last_snippet.trim_right());\n             }\n             let indent = make_indent(this.block_indent);\n-            this.changes.push_str_span(span, &indent);           \n+            this.changes.push_str_span(span, &indent);\n         })\n     }\n \n@@ -235,14 +416,30 @@ impl<'a> FmtVisitor<'a> {\n                                                                       process_last_snippet: F)\n     {\n         let start = self.last_pos;\n+        // TODO uncomment\n+        // debug!(\"format_missing_inner: {:?} to {:?}\",\n+        //        self.codemap.lookup_char_pos(start),\n+        //        self.codemap.lookup_char_pos(end));\n+\n         // TODO(#11) gets tricky if we're missing more than one file\n-        assert!(self.codemap.lookup_char_pos(start).file.name == self.codemap.lookup_char_pos(end).file.name,\n-                \"not implemented: unformated span across files\");\n+        // assert!(self.codemap.lookup_char_pos(start).file.name == self.codemap.lookup_char_pos(end).file.name,\n+        //         \"not implemented: unformated span across files: {} and {}\",\n+        //         self.codemap.lookup_char_pos(start).file.name,\n+        //         self.codemap.lookup_char_pos(end).file.name);\n+        // assert!(start <= end,\n+        //         \"Request to format inverted span: {:?} to {:?}\",\n+        //         self.codemap.lookup_char_pos(start),\n+        //         self.codemap.lookup_char_pos(end));\n+\n+        if start == end {\n+            return;\n+        }\n \n         self.last_pos = end;\n         let span = codemap::mk_sp(start, end);\n         let snippet = self.snippet(span);\n \n+        // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n         // quite right, so we must do it ourselves.\n         let mut line_start = 0;\n@@ -282,7 +479,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     // TODO NEEDS TESTS\n-    fn rewrite_string(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n+    fn rewrite_string_lit(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n         // FIXME I bet this stomps unicode escapes in the source string\n \n         // Check if there is anything to fix: we always try to fixup multi-line\n@@ -346,123 +543,328 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     // Basically just pretty prints a multi-item import.\n-    fn fix_use_list(&mut self,\n-                    path: &ast::Path,\n-                    path_list: &[ast::PathListItem],\n-                    vp_span: Span) -> String {\n+    fn rewrite_use_list(&mut self,\n+                        path: &ast::Path,\n+                        path_list: &[ast::PathListItem],\n+                        vp_span: Span) -> String {\n         // FIXME remove unused imports\n \n         // FIXME check indentation\n         let l_loc = self.codemap.lookup_char_pos(vp_span.lo);\n+\n         let path_str = pprust::path_to_string(&path);\n-        let indent = l_loc.col.0;\n-        // After accounting for the overhead, how much space left for\n-        // the item list? ( 5 = :: + { + } + ; )\n-        let space = IDEAL_WIDTH - (indent + path_str.len() + 5);\n-        // 4 = `use` + one space\n-        // TODO might be pub use\n-        let indent = make_indent(indent-4);\n-\n-        let mut cur_str = String::new();\n-        let mut first = true;\n+\n+        // 3 = :: + {\n+        let indent = l_loc.col.0 + path_str.len() + 3;\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::Mixed,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: indent,\n+            // 2 = } + ;\n+            h_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n+            v_width: IDEAL_WIDTH - (indent + path_str.len() + 2),\n+        };\n+\n+        // TODO handle any comments inbetween items.\n         // If `self` is in the list, put it first.\n-        if path_list.iter().any(|vpi|\n+        let head = if path_list.iter().any(|vpi|\n             if let ast::PathListItem_::PathListMod{ .. } = vpi.node {\n                 true\n             } else {\n                 false\n             }\n         ) {\n-            cur_str = \"self\".to_string();\n-            first = false;\n-        }\n+            Some((\"self\".to_string(), String::new()))\n+        } else {\n+            None\n+        };\n \n-        let mut new_str = String::new();\n-        for vpi in path_list.iter() {\n+        let items: Vec<_> = head.into_iter().chain(path_list.iter().filter_map(|vpi| {\n             match vpi.node {\n                 ast::PathListItem_::PathListIdent{ name, .. } => {\n-                    let next_item = &token::get_ident(name);\n-                    if cur_str.len() + next_item.len() > space {\n-                        let cur_line = format!(\"{}use {}::{{{}}};\\n\", indent, path_str, cur_str);\n-                        new_str.push_str(&cur_line);\n+                    Some((token::get_ident(name).to_string(), String::new()))\n+                }\n+                // Skip `self`, because we added it above.\n+                ast::PathListItem_::PathListMod{ .. } => None,\n+            }\n+        })).collect();\n \n-                        cur_str = String::new();\n-                        first = true;\n-                    }\n+        format!(\"use {}::{{{}}};\", path_str, write_list(&items, &fmt))\n+    }\n \n-                    if first {\n-                        first = false;\n-                    } else {\n-                        cur_str.push_str(\", \");\n-                    }\n+    fn rewrite_fn(&mut self,\n+                  indent: usize,\n+                  ident: ast::Ident,\n+                  fd: &ast::FnDecl,\n+                  explicit_self: Option<&ast::ExplicitSelf>,\n+                  generics: &ast::Generics,\n+                  unsafety: &ast::Unsafety,\n+                  abi: &abi::Abi,\n+                  vis: ast::Visibility)\n+        -> String\n+    {\n+        // FIXME we'll lose any comments in between parts of the function decl, but anyone\n+        // who comments there probably deserves what they get.\n+\n+        let mut result = String::with_capacity(1024);\n+        // Vis unsafety abi.\n+        if vis == ast::Visibility::Public {\n+            result.push_str(\"pub \");\n+        }\n+        if let &ast::Unsafety::Unsafe = unsafety {\n+            result.push_str(\"unsafe \");\n+        }\n+        if *abi != abi::Rust {\n+            result.push_str(\"extern \");\n+            result.push_str(&abi.to_string());\n+            result.push(' ');\n+        }\n+\n+        // fn foo\n+        result.push_str(\"fn \");\n+        result.push_str(&token::get_ident(ident));\n+\n+        // Generics.\n+        // FIXME convert bounds to where clauses where they get too big or if\n+        // there is a where clause at all.\n+        let lifetimes: &[_] = &generics.lifetimes;\n+        let tys: &[_] = &generics.ty_params;\n+        let where_clause = &generics.where_clause;\n+        if lifetimes.len() + tys.len() > 0 {\n+            let budget = MAX_WIDTH - indent - result.len() - 2;\n+            // TODO might need to insert a newline if the generics are really long\n+            result.push('<');\n+\n+            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n+            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n+            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::HorizontalVertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: indent + result.len() + 1,\n+                h_width: budget,\n+                v_width: budget,\n+            };\n+            result.push_str(&write_list(&generics_strs, &fmt));\n+\n+            result.push('>');\n+        }\n+\n+        let ret_str = match fd.output {\n+            ast::FunctionRetTy::DefaultReturn(_) => String::new(),\n+            ast::FunctionRetTy::NoReturn(_) => \"-> !\".to_string(),\n+            ast::FunctionRetTy::Return(ref ty) => \"-> \".to_string() + &pprust::ty_to_string(ty),\n+        };\n+\n+        // Args.\n+        let args = &fd.inputs;\n+\n+        let mut budgets = None;\n+\n+        // Try keeping everything on the same line\n+        if !result.contains(\"\\n\") {\n+            // 3 = `() `, space is before ret_string\n+            let used_space = indent + result.len() + 3 + ret_str.len();\n+            let one_line_budget = if used_space > MAX_WIDTH {\n+                0\n+            } else {\n+                MAX_WIDTH - used_space\n+            };\n+\n+            let used_space = indent + result.len() + 2;\n+            let max_space = IDEAL_WIDTH + LEEWAY;\n+            if used_space < max_space {\n+                budgets = Some((one_line_budget,\n+                                // 2 = `()`\n+                                max_space - used_space,\n+                                indent + result.len() + 1));\n+            }\n+        }\n+\n+        // Didn't work. we must force vertical layout and put args on a newline.\n+        if let None = budgets {\n+            result.push('\\n');\n+            result.push_str(&make_indent(indent + 4));\n+            // 6 = new indent + `()`\n+            let used_space = indent + 6;\n+            let max_space = IDEAL_WIDTH + LEEWAY;\n+            if used_space > max_space {\n+                // Whoops! bankrupt.\n+                // TODO take evasive action, perhaps kill the indent or something.\n+            } else {\n+                // 5 = new indent + `(`\n+                budgets = Some((0, max_space - used_space, indent + 5));\n+            }\n+        }\n+\n+        let (one_line_budget, multi_line_budget, arg_indent) = budgets.unwrap();\n+        result.push('(');\n \n-                    cur_str.push_str(next_item);\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::HorizontalVertical,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: arg_indent,\n+            h_width: one_line_budget,\n+            v_width: multi_line_budget,\n+        };\n+        // TODO dead spans\n+        let mut arg_strs: Vec<_> = args.iter().map(|a| (self.rewrite_fn_input(a), String::new())).collect();\n+        // Account for sugary self.\n+        if let Some(explicit_self) = explicit_self {\n+            match explicit_self.node {\n+                ast::ExplicitSelf_::SelfRegion(ref lt, ref m, _) => {\n+                    let lt_str = match lt {\n+                        &Some(ref l) => format!(\"{} \", pprust::lifetime_to_string(l)),\n+                        &None => String::new(),\n+                    };\n+                    let mut_str = match m {\n+                        &ast::Mutability::MutMutable => \"mut \".to_string(),\n+                        &ast::Mutability::MutImmutable => String::new(),\n+                    };\n+                    arg_strs[0].0 = format!(\"&{}{}self\", lt_str, mut_str)\n+                }\n+                ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n+                    arg_strs[0].0 = format!(\"self: {}\", pprust::ty_to_string(ty))\n                 }\n-                ast::PathListItem_::PathListMod{ .. } => {}\n+                _ => {}\n             }\n         }\n+        result.push_str(&write_list(&arg_strs, &fmt));\n+\n+        result.push(')');\n+\n+        // Where clause.\n+        if where_clause.predicates.len() > 0 {\n+            result.push('\\n');\n+            result.push_str(&make_indent(indent + 4));\n+            result.push_str(\"where \");\n+\n+            let budget = IDEAL_WIDTH + LEEWAY - indent - 10;\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::Vertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Always,\n+                indent: indent + 10,\n+                h_width: budget,\n+                v_width: budget,\n+            };\n+            let where_strs: Vec<_> = where_clause.predicates.iter().map(|p| (self.rewrite_pred(p), String::new())).collect();\n+            result.push_str(&write_list(&where_strs, &fmt));\n+        }\n \n-        assert!(!first);\n-        let cur_line = format!(\"{}use {}::{{{}}};\", indent, path_str, cur_str);\n-        new_str.push_str(&cur_line);\n+        // Return type.\n+        if ret_str.len() > 0 {\n+            // If we've already gone multi-line, or the return type would push\n+            // over the max width, then put the return type on a new line.\n+            if result.contains(\"\\n\") ||\n+               result.len() + indent + ret_str.len() > MAX_WIDTH {\n+                let indent = indent + 4;\n+                result.push('\\n');\n+                result.push_str(&make_indent(indent));\n+            } else {\n+                result.push(' ');\n+            }\n+            result.push_str(&ret_str);\n+        }\n \n-        new_str\n+        result\n     }\n \n-    fn formal_args<'v>(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl) -> Option<String> {\n-        // For now, just check the arguments line up and make them per-row if the line is too long.\n-        let args = &fd.inputs;\n+    // TODO we farm this out, but this could spill over the column limit, so we ought to handle it properly\n+    fn rewrite_fn_input(&self, arg: &ast::Arg) -> String {\n+        format!(\"{}: {}\",\n+                pprust::pat_to_string(&arg.pat),\n+                pprust::ty_to_string(&arg.ty))\n+    }\n \n-        let ret_str = match fd.output {\n-            ast::FunctionRetTy::DefaultReturn(_) => \"\".to_string(),\n-            ast::FunctionRetTy::NoReturn(_) => \" -> !\".to_string(),\n-            ast::FunctionRetTy::Return(ref ty) => pprust::ty_to_string(ty),\n-        };\n+    fn rewrite_pred(&self, predicate: &ast::WherePredicate) -> String\n+    {\n+        // TODO dead spans\n+        // TODO assumes we'll always fit on one line...\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n+                                                                          ref bounded_ty,\n+                                                                          ref bounds,\n+                                                                          ..}) => {\n+                if bound_lifetimes.len() > 0 {\n+                    format!(\"for<{}> {}: {}\",\n+                            bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n+                            pprust::ty_to_string(bounded_ty),\n+                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n \n-        // TODO don't return, want to do the return type etc.\n-        if args.len() == 0 {\n-            return None;\n+                } else {\n+                    format!(\"{}: {}\",\n+                            pprust::ty_to_string(bounded_ty),\n+                            bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\"+\"))\n+                }\n+            }\n+            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                            ref bounds,\n+                                                                            ..}) => {\n+                format!(\"{}: {}\",\n+                        pprust::lifetime_to_string(lifetime),\n+                        bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n+            }\n+            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                format!(\"{} = {}\", pprust::path_to_string(path), pprust::ty_to_string(ty))\n+            }\n         }\n+    }\n \n-        // TODO not really using the hi positions\n-        let spans: Vec<_> = args.iter().map(|a| (a.pat.span.lo, a.ty.span.hi)).collect();\n-        let locs: Vec<_> = spans.iter().map(|&(a, b)| {\n-            (self.codemap.lookup_char_pos(a), self.codemap.lookup_char_pos(b))\n-        }).collect();\n-        let first_col = locs[0].0.col.0;\n+    fn rewrite_lifetime_def(&self, lifetime: &ast::LifetimeDef) -> String\n+    {\n+        if lifetime.bounds.len() == 0 {\n+            return pprust::lifetime_to_string(&lifetime.lifetime);\n+        }\n \n-        // Print up to the start of the args.\n-        self.format_missing(spans[0].0);\n-        self.last_pos = spans.last().unwrap().1;\n+        format!(\"{}: {}\",\n+                pprust::lifetime_to_string(&lifetime.lifetime),\n+                lifetime.bounds.iter().map(|l| pprust::lifetime_to_string(l)).collect::<Vec<_>>().connect(\"+\"))\n+    }\n \n-        let arg_strs: Vec<_> = args.iter().map(|a| format!(\"{}: {}\",\n-                                                           pprust::pat_to_string(&a.pat),\n-                                                           pprust::ty_to_string(&a.ty))).collect();\n+    fn rewrite_ty_bound(&self, bound: &ast::TyParamBound) -> String\n+    {\n+        match *bound {\n+            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n+                self.rewrite_poly_trait_ref(tref)\n+            }\n+            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n+                format!(\"?{}\", self.rewrite_poly_trait_ref(tref))\n+            }\n+            ast::TyParamBound::RegionTyParamBound(ref l) => {\n+                pprust::lifetime_to_string(l)\n+            }\n+        }\n+    }\n \n-        // Try putting everything on one row:\n-        let mut len = arg_strs.iter().fold(0, |a, b| a + b.len());\n-        // Account for punctuation and spacing.\n-        len += 2 * arg_strs.len() + 2 * (arg_strs.len()-1);\n-        // Return type.\n-        len += ret_str.len();\n-        // Opening brace if no where clause.\n-        match fk {\n-            visit::FnKind::FkItemFn(_, &ref g, _, _) |\n-            visit::FnKind::FkMethod(_, &ast::MethodSig { generics: ref g, ..})\n-            if g.where_clause.predicates.len() > 0 => {}\n-            _ => len += 2 // ` {`\n+    fn rewrite_ty_param(&self, ty_param: &ast::TyParam) -> String\n+    {\n+        let mut result = String::with_capacity(128);\n+        result.push_str(&token::get_ident(ty_param.ident));\n+        if ty_param.bounds.len() > 0 {\n+            result.push_str(\": \");\n+            result.push_str(&ty_param.bounds.iter().map(|b| self.rewrite_ty_bound(b)).collect::<Vec<_>>().connect(\", \"));\n+        }\n+        if let Some(ref def) = ty_param.default {\n+            result.push_str(\" = \");\n+            result.push_str(&pprust::ty_to_string(&def));\n         }\n-        len += first_col;\n \n-        if len <= IDEAL_WIDTH + LEEWAY || args.len() == 1 {\n-            // It should all fit on one line.\n-            return Some(arg_strs.connect(\", \"));\n+        result\n+    }\n+\n+    fn rewrite_poly_trait_ref(&self, t: &ast::PolyTraitRef) -> String\n+    {\n+        if t.bound_lifetimes.len() > 0 {\n+            format!(\"for<{}> {}\",\n+                    t.bound_lifetimes.iter().map(|l| self.rewrite_lifetime_def(l)).collect::<Vec<_>>().connect(\", \"),\n+                    pprust::path_to_string(&t.trait_ref.path))\n+\n         } else {\n-            // TODO multi-line\n-            let mut indent = String::with_capacity(first_col + 2);\n-            indent.push_str(\",\\n\");\n-            for _ in 0..first_col { indent.push(' '); }\n-            return Some(arg_strs.connect(&indent));\n+            pprust::path_to_string(&t.trait_ref.path)\n         }\n     }\n \n@@ -482,18 +884,28 @@ impl<'a> FmtVisitor<'a> {\n         let remaining_width = width - callee_str.len() - 2;\n         let offset = callee_str.len() + 1 + offset;\n         let arg_count = args.len();\n-        let args: Vec<_> = args.iter().map(|e| self.rewrite_expr(e,\n-                                                                 remaining_width,\n-                                                                 offset)).collect();\n-        debug!(\"rewrite_call, args: `{}`\", args.connect(\",\"));\n-\n-        let multi_line = args.iter().any(|s| s.contains('\\n'));\n-        let args_width = args.iter().map(|s| s.len()).fold(0, |a, l| a + l);\n-        let over_wide = args_width + (arg_count - 1) * 2 > remaining_width;\n-        let args_str = if multi_line || over_wide {\n-            args.connect(&(\",\\n\".to_string() + &make_indent(offset)))\n+\n+        let args_str = if arg_count > 0 {\n+            let args: Vec<_> = args.iter().map(|e| (self.rewrite_expr(e,\n+                                                                      remaining_width,\n+                                                                      offset), String::new())).collect();\n+            // TODO move this into write_list\n+            let tactics = if args.iter().any(|&(ref s, _)| s.contains('\\n')) {\n+                ListTactic::Vertical\n+            } else {\n+                ListTactic::HorizontalVertical\n+            };\n+            let fmt = ListFormatting {\n+                tactic: tactics,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: offset,\n+                h_width: remaining_width,\n+                v_width: remaining_width,\n+            };\n+            write_list(&args, &fmt)\n         } else {\n-            args.connect(\", \")\n+            String::new()\n         };\n \n         format!(\"{}({})\", callee_str, args_str)\n@@ -504,7 +916,7 @@ impl<'a> FmtVisitor<'a> {\n             ast::Expr_::ExprLit(ref l) => {\n                 match l.node {\n                     ast::Lit_::LitStr(ref is, _) => {\n-                        return self.rewrite_string(&is, l.span, width, offset);\n+                        return self.rewrite_string_lit(&is, l.span, width, offset);\n                     }\n                     _ => {}\n                 }\n@@ -596,20 +1008,37 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n \n             println!(\"{}\", changes);\n             // FIXME(#5) Should be user specified whether to show or replace.\n-\n-            // TODO we stop before expansion, but we still seem to get expanded for loops which\n-            // cause problems - probably a rustc bug\n         };\n \n         control\n     }\n }\n \n fn main() {\n-    let args = std::os::args();\n+    let args: Vec<_> = std::env::args().collect();\n     let mut call_ctxt = RustFmtCalls { input_path: None };\n     rustc_driver::run_compiler(&args, &mut call_ctxt);\n     std::env::set_exit_status(0);\n+\n+    // TODO unit tests\n+    // let fmt = ListFormatting {\n+    //     tactic: ListTactic::Horizontal,\n+    //     separator: \",\",\n+    //     trailing_separator: SeparatorTactic::Vertical,\n+    //     indent: 2,\n+    //     h_width: 80,\n+    //     v_width: 100,\n+    // };\n+    // let inputs = vec![(format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new()),\n+    //                   (format!(\"foo\"), String::new())];\n+    // let s = write_list(&inputs, &fmt);\n+    // println!(\"  {}\", s);\n }\n \n // FIXME comments"}, {"sha": "61f543175cfdba75e0670239c1eeb51dec8c7793", "filename": "src/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -1063,7 +1063,7 @@ impl Lnode {\n         debug_assert!(start + new_str.len() <= self.len);\n         let addr = (self.text as usize + start) as *mut u8;\n         unsafe {\n-            ::std::intrinsics::copy_nonoverlapping_memory(addr, &new_str.as_bytes()[0], new_str.len());\n+            ::std::intrinsics::volatile_copy_nonoverlapping_memory(addr, &new_str.as_bytes()[0], new_str.len());\n         }\n     }\n "}, {"sha": "df11e79d318215d0ed5361ceec4773c56f1d97fd", "filename": "src/string_buffer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fstring_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76854677c1b730ecb262b5277a6520fc2ff75974/src%2Fstring_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring_buffer.rs?ref=76854677c1b730ecb262b5277a6520fc2ff75974", "patch": "@@ -81,7 +81,11 @@ impl StringBuffer {\n     pub fn cur_offset(&self) -> usize {\n         unsafe {\n             let result = (&*self.last).cur_offset();\n-            result.unwrap_or_else(|| panic!(\"Unimplemented cur_offset across node boundaries\"))\n+            // TODO\n+            result.unwrap_or_else(|| {\n+                println!(\" FIXME Unimplemented cur_offset across node boundaries\");\n+                0\n+            })\n         }\n     }\n "}]}