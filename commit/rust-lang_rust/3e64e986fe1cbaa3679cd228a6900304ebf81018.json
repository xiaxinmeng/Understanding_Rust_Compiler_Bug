{"sha": "3e64e986fe1cbaa3679cd228a6900304ebf81018", "node_id": "C_kwDOAAsO6NoAKDNlNjRlOTg2ZmUxY2JhYTM2NzljZDIyOGE2OTAwMzA0ZWJmODEwMTg", "commit": {"author": {"name": "Ezra Shaw", "email": "ezrasure@outlook.com", "date": "2023-04-21T11:49:05Z"}, "committer": {"name": "Ezra Shaw", "email": "ezrashawdev@gmail.com", "date": "2023-05-05T11:11:54Z"}, "message": "fix trait definition spans in \"make mut\" suggestion", "tree": {"sha": "aa16aba059a1cead7e2582e9e16df8eaf1986b4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa16aba059a1cead7e2582e9e16df8eaf1986b4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e64e986fe1cbaa3679cd228a6900304ebf81018", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE/c15HB+s7bjrqpLmUVbPWEUVCw0FAmRU5H8ACgkQUVbPWEUV\nCw3hVw//V1gfJ/FTF6QzEHSqNOOMRO9+wLiZV+bHSrUFJyHH2Vy2ZIRw+X65iAmc\nDzmox9GKcXMC3Dj8jk8V7ZBqipdwb1owDHPxYq12Q0SXBdcXyJS6Kh7D+rKvT2sf\n3bTgrqyq8clcuRkMQFVFbj4oD0Ai1pctbmPyLQLlUuH+HzQ9VokMNT1uXaMyZFoS\nlnlvIMQtli4Y+g5DMJ6de1WBsWnhwoW7YSgNoLofbXcPthBJZgGMh1O4UBd/z5Y+\nvIJrKeWxqYtXgEaeqjdUmcjN3iEomH7rFduUUgZjTrKF9PPt/wsFNEPBtGzFHhGp\n7ShCL3zPYXuPuETpa7EICQ65vzX1LdpUTnv6zJdLkZH0x8rjmotTANkNBRsSmmIH\nLpZyPze5jIxGfofojU3uAv6JNrt+iv+kxNB4IPUqPHMX0a7pEJSJYGZsj+RFaTc8\nlCRIqCOgKgb+GaDhgiLrKnggST4jTZXzYTJPM3mRYypxD/2Iwfm6dRLdKLN6ujF4\nfeOYTAvHK8Q9+QBytnYjIjQ1fkjU8KPqExNT3USOsOFXaBkGgA5W+qbLPx/aki7D\nwPnZM3hnxm2sY1b/CKLmFbQjSFcXpSxpPnCurV43TZiVuzWrUaJN6P1P+wO/f66g\nWivkwuKbf3LtyS1312EFQ11h9XZoqiB+yLyoAfQ2lYGLvZEYNa8=\n=tywR\n-----END PGP SIGNATURE-----", "payload": "tree aa16aba059a1cead7e2582e9e16df8eaf1986b4c\nparent d2608dfabb3a353fd2ab25f8bb1abf04b497af3b\nauthor Ezra Shaw <ezrasure@outlook.com> 1682077745 +1200\ncommitter Ezra Shaw <ezrashawdev@gmail.com> 1683285114 +1200\n\nfix trait definition spans in \"make mut\" suggestion\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e64e986fe1cbaa3679cd228a6900304ebf81018", "html_url": "https://github.com/rust-lang/rust/commit/3e64e986fe1cbaa3679cd228a6900304ebf81018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e64e986fe1cbaa3679cd228a6900304ebf81018/comments", "author": {"login": "Ezrashaw", "id": 38062690, "node_id": "MDQ6VXNlcjM4MDYyNjkw", "avatar_url": "https://avatars.githubusercontent.com/u/38062690?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ezrashaw", "html_url": "https://github.com/Ezrashaw", "followers_url": "https://api.github.com/users/Ezrashaw/followers", "following_url": "https://api.github.com/users/Ezrashaw/following{/other_user}", "gists_url": "https://api.github.com/users/Ezrashaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ezrashaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ezrashaw/subscriptions", "organizations_url": "https://api.github.com/users/Ezrashaw/orgs", "repos_url": "https://api.github.com/users/Ezrashaw/repos", "events_url": "https://api.github.com/users/Ezrashaw/events{/privacy}", "received_events_url": "https://api.github.com/users/Ezrashaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ezrashaw", "id": 38062690, "node_id": "MDQ6VXNlcjM4MDYyNjkw", "avatar_url": "https://avatars.githubusercontent.com/u/38062690?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ezrashaw", "html_url": "https://github.com/Ezrashaw", "followers_url": "https://api.github.com/users/Ezrashaw/followers", "following_url": "https://api.github.com/users/Ezrashaw/following{/other_user}", "gists_url": "https://api.github.com/users/Ezrashaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ezrashaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ezrashaw/subscriptions", "organizations_url": "https://api.github.com/users/Ezrashaw/orgs", "repos_url": "https://api.github.com/users/Ezrashaw/repos", "events_url": "https://api.github.com/users/Ezrashaw/events{/privacy}", "received_events_url": "https://api.github.com/users/Ezrashaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2608dfabb3a353fd2ab25f8bb1abf04b497af3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2608dfabb3a353fd2ab25f8bb1abf04b497af3b", "html_url": "https://github.com/rust-lang/rust/commit/d2608dfabb3a353fd2ab25f8bb1abf04b497af3b"}], "stats": {"total": 401, "additions": 201, "deletions": 200}, "files": [{"sha": "6286033e0672d2bf2a041c1705def878ddfb582c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 197, "deletions": 196, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/3e64e986fe1cbaa3679cd228a6900304ebf81018/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e64e986fe1cbaa3679cd228a6900304ebf81018/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=3e64e986fe1cbaa3679cd228a6900304ebf81018", "patch": "@@ -1,4 +1,4 @@\n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -478,186 +478,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match *local_decl.local_info() {\n-                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n-                                let (span, suggestion) =\n-                                    suggest_ampmut_self(self.infcx.tcx, local_decl);\n-                                Some((true, span, suggestion))\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(_),\n-                                opt_ty_info,\n-                                ..\n-                            })) => {\n-                                // check if the RHS is from desugaring\n-                                let opt_assignment_rhs_span =\n-                                    self.body.find_assignments(local).first().map(|&location| {\n-                                        if let Some(mir::Statement {\n-                                            source_info: _,\n-                                            kind:\n-                                                mir::StatementKind::Assign(box (\n-                                                    _,\n-                                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n-                                                )),\n-                                        }) = self.body[location.block]\n-                                            .statements\n-                                            .get(location.statement_index)\n-                                        {\n-                                            self.body.local_decls[place.local].source_info.span\n-                                        } else {\n-                                            self.body.source_info(location).span\n-                                        }\n-                                    });\n-                                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n-                                    // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => {\n-                                        self.suggest_similar_mut_method_for_for_loop(&mut err);\n-                                        err.span_label(opt_assignment_rhs_span.unwrap(), format!(\n-                                            \"this iterator yields `{pointer_sigil}` {pointer_desc}s\",\n-                                        ));\n-                                        None\n-                                    }\n-                                    // don't create labels for compiler-generated spans\n-                                    Some(_) => None,\n-                                    None => {\n-                                        let label = if name != kw::SelfLower {\n-                                            suggest_ampmut(\n-                                                self.infcx.tcx,\n-                                                local_decl,\n-                                                opt_assignment_rhs_span,\n-                                                opt_ty_info,\n-                                            )\n-                                        } else {\n-                                            match local_decl.local_info() {\n-                                                LocalInfo::User(mir::BindingForm::Var(\n-                                                    mir::VarBindingForm {\n-                                                        opt_ty_info: None, ..\n-                                                    },\n-                                                )) => {\n-                                                    let (span, sugg) = suggest_ampmut_self(\n-                                                        self.infcx.tcx,\n-                                                        local_decl,\n-                                                    );\n-                                                    (true, span, sugg)\n-                                                }\n-                                                // explicit self (eg `self: &'a Self`)\n-                                                _ => suggest_ampmut(\n-                                                    self.infcx.tcx,\n-                                                    local_decl,\n-                                                    opt_assignment_rhs_span,\n-                                                    opt_ty_info,\n-                                                ),\n-                                            }\n-                                        };\n-                                        Some(label)\n-                                    }\n-                                }\n-                            }\n-\n-                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByReference(_),\n-                                ..\n-                            })) => {\n-                                let pattern_span: Span = local_decl.source_info.span;\n-                                suggest_ref_mut(self.infcx.tcx, pattern_span)\n-                                    .map(|span| (true, span, \"mut \".to_owned()))\n-                            }\n-\n-                            _ => unreachable!(),\n-                        };\n-\n-                        match label {\n-                            Some((true, err_help_span, suggested_code)) => {\n-                                let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n-                                if !is_trait_sig {\n-                                    err.span_suggestion_verbose(\n-                                        err_help_span,\n-                                        format!(\n-                                            \"consider changing this to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                } else if let Some(x) = local_trait {\n-                                    err.span_suggestion_verbose(\n-                                        x,\n-                                        format!(\n-                                            \"consider changing that to be a mutable {pointer_desc}\"\n-                                        ),\n-                                        suggested_code,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                            }\n-                            Some((false, err_label_span, message)) => {\n-                                struct BindingFinder {\n-                                    span: Span,\n-                                    hir_id: Option<hir::HirId>,\n-                                }\n-\n-                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n-                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-                                        if let hir::StmtKind::Local(local) = s.kind {\n-                                            if local.pat.span == self.span {\n-                                                self.hir_id = Some(local.hir_id);\n-                                            }\n-                                        }\n-                                        hir::intravisit::walk_stmt(self, s);\n-                                    }\n-                                }\n-                                let hir_map = self.infcx.tcx.hir();\n-                                let def_id = self.body.source.def_id();\n-                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n-                                let node = hir_map.find(hir_id);\n-                                let hir_id = if let Some(hir::Node::Item(item)) = node\n-                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n-                                {\n-                                    let body = hir_map.body(body_id);\n-                                    let mut v = BindingFinder {\n-                                        span: err_label_span,\n-                                        hir_id: None,\n-                                    };\n-                                    v.visit_body(body);\n-                                    v.hir_id\n-                                } else {\n-                                    None\n-                                };\n-                                if let Some(hir_id) = hir_id\n-                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n-                                {\n-                                    let (changing, span, sugg) = match local.ty {\n-                                        Some(ty) => (\"changing\", ty.span, message),\n-                                        None => (\n-                                            \"specifying\",\n-                                            local.pat.span.shrink_to_hi(),\n-                                            format!(\": {message}\"),\n-                                        ),\n-                                    };\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        format!(\"consider {changing} this binding's type\"),\n-                                        sugg,\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                } else {\n-                                    err.span_label(\n-                                        err_label_span,\n-                                        format!(\n-                                            \"consider changing this binding's type to be: `{message}`\"\n-                                        ),\n-                                    );\n-                                }\n-                            }\n-                            None => {}\n-                        }\n                         err.span_label(\n                             span,\n                             format!(\n                                 \"`{name}` is a `{pointer_sigil}` {pointer_desc}, \\\n                                  so the data it refers to cannot be {acted_on}\",\n                             ),\n                         );\n+\n+                        self.suggest_make_local_mut(&mut err, local, name);\n                     }\n                     _ => {\n                         err.span_label(\n@@ -1131,6 +960,184 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn suggest_make_local_mut(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        local: Local,\n+        name: Symbol,\n+    ) {\n+        let local_decl = &self.body.local_decls[local];\n+\n+        let (pointer_sigil, pointer_desc) =\n+            if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n+\n+        let (is_trait_sig, local_trait) = self.is_error_in_trait(local);\n+        if is_trait_sig && local_trait.is_none() {\n+            return;\n+        }\n+\n+        let decl_span = match local_trait {\n+            Some(span) => span,\n+            None => local_decl.source_info.span,\n+        };\n+\n+        let label = match *local_decl.local_info() {\n+            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                Some((true, decl_span, suggestion))\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info,\n+                ..\n+            })) => {\n+                // check if the RHS is from desugaring\n+                let opt_assignment_rhs_span =\n+                    self.body.find_assignments(local).first().map(|&location| {\n+                        if let Some(mir::Statement {\n+                            source_info: _,\n+                            kind:\n+                                mir::StatementKind::Assign(box (\n+                                    _,\n+                                    mir::Rvalue::Use(mir::Operand::Copy(place)),\n+                                )),\n+                        }) = self.body[location.block].statements.get(location.statement_index)\n+                        {\n+                            self.body.local_decls[place.local].source_info.span\n+                        } else {\n+                            self.body.source_info(location).span\n+                        }\n+                    });\n+                match opt_assignment_rhs_span.and_then(|s| s.desugaring_kind()) {\n+                    // on for loops, RHS points to the iterator part\n+                    Some(DesugaringKind::ForLoop) => {\n+                        self.suggest_similar_mut_method_for_for_loop(err);\n+                        err.span_label(\n+                            opt_assignment_rhs_span.unwrap(),\n+                            format!(\"this iterator yields `{pointer_sigil}` {pointer_desc}s\",),\n+                        );\n+                        None\n+                    }\n+                    // don't create labels for compiler-generated spans\n+                    Some(_) => None,\n+                    None => {\n+                        let label = if name != kw::SelfLower {\n+                            suggest_ampmut(\n+                                self.infcx.tcx,\n+                                local_decl.ty,\n+                                decl_span,\n+                                opt_assignment_rhs_span,\n+                                opt_ty_info,\n+                            )\n+                        } else {\n+                            match local_decl.local_info() {\n+                                LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                    opt_ty_info: None,\n+                                    ..\n+                                })) => {\n+                                    let sugg = suggest_ampmut_self(self.infcx.tcx, decl_span);\n+                                    (true, decl_span, sugg)\n+                                }\n+                                // explicit self (eg `self: &'a Self`)\n+                                _ => suggest_ampmut(\n+                                    self.infcx.tcx,\n+                                    local_decl.ty,\n+                                    decl_span,\n+                                    opt_assignment_rhs_span,\n+                                    opt_ty_info,\n+                                ),\n+                            }\n+                        };\n+                        Some(label)\n+                    }\n+                }\n+            }\n+\n+            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByReference(_),\n+                ..\n+            })) => {\n+                let pattern_span: Span = local_decl.source_info.span;\n+                suggest_ref_mut(self.infcx.tcx, pattern_span)\n+                    .map(|span| (true, span, \"mut \".to_owned()))\n+            }\n+\n+            _ => unreachable!(),\n+        };\n+\n+        match label {\n+            Some((true, err_help_span, suggested_code)) => {\n+                err.span_suggestion_verbose(\n+                    err_help_span,\n+                    format!(\"consider changing this to be a mutable {pointer_desc}\"),\n+                    suggested_code,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((false, err_label_span, message)) => {\n+                struct BindingFinder {\n+                    span: Span,\n+                    hir_id: Option<hir::HirId>,\n+                }\n+\n+                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                        if let hir::StmtKind::Local(local) = s.kind {\n+                            if local.pat.span == self.span {\n+                                self.hir_id = Some(local.hir_id);\n+                            }\n+                        }\n+                        hir::intravisit::walk_stmt(self, s);\n+                    }\n+                }\n+                let hir_map = self.infcx.tcx.hir();\n+                let def_id = self.body.source.def_id();\n+                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                let node = hir_map.find(hir_id);\n+                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                && let hir::ItemKind::Fn(.., body_id) = item.kind\n+            {\n+                let body = hir_map.body(body_id);\n+                let mut v = BindingFinder {\n+                    span: err_label_span,\n+                    hir_id: None,\n+                };\n+                v.visit_body(body);\n+                v.hir_id\n+            } else {\n+                None\n+            };\n+                if let Some(hir_id) = hir_id\n+                && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+            {\n+                let (changing, span, sugg) = match local.ty {\n+                    Some(ty) => (\"changing\", ty.span, message),\n+                    None => (\n+                        \"specifying\",\n+                        local.pat.span.shrink_to_hi(),\n+                        format!(\": {message}\"),\n+                    ),\n+                };\n+                err.span_suggestion_verbose(\n+                    span,\n+                    format!(\"consider {changing} this binding's type\"),\n+                    sugg,\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_label(\n+                    err_label_span,\n+                    format!(\n+                        \"consider changing this binding's type to be: `{message}`\"\n+                    ),\n+                );\n+            }\n+            }\n+            None => {}\n+        }\n+    }\n }\n \n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n@@ -1160,25 +1167,18 @@ pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<\n     }\n }\n \n-fn suggest_ampmut_self<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n-) -> (Span, String) {\n-    let sp = local_decl.source_info.span;\n-    (\n-        sp,\n-        match tcx.sess.source_map().span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let lt_pos = snippet.find('\\'');\n-                if let Some(lt_pos) = lt_pos {\n-                    format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n-                } else {\n-                    \"&mut self\".to_string()\n-                }\n+fn suggest_ampmut_self<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n+    match tcx.sess.source_map().span_to_snippet(span) {\n+        Ok(snippet) => {\n+            let lt_pos = snippet.find('\\'');\n+            if let Some(lt_pos) = lt_pos {\n+                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+            } else {\n+                \"&mut self\".to_string()\n             }\n-            _ => \"&mut self\".to_string(),\n-        },\n-    )\n+        }\n+        _ => \"&mut self\".to_string(),\n+    }\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -1198,7 +1198,8 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    local_decl: &mir::LocalDecl<'tcx>,\n+    decl_ty: Ty<'tcx>,\n+    decl_span: Span,\n     opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (bool, Span, String) {\n@@ -1250,7 +1251,7 @@ fn suggest_ampmut<'tcx>(\n         // otherwise, we'll suggest *adding* an annotated type, we'll suggest\n         // the RHS's type for that.\n         // this is `Applicability::HasPlaceholders`.\n-        None => (false, local_decl.source_info.span),\n+        None => (false, decl_span),\n     };\n \n     // if the binding already exists and is a reference with a explicit\n@@ -1271,13 +1272,13 @@ fn suggest_ampmut<'tcx>(\n     } else {\n         // otherwise, suggest that the user annotates the binding; we provide the\n         // type of the local.\n-        let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n+        let ty_mut = decl_ty.builtin_deref(true).unwrap();\n         assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n \n         (\n             false,\n             span,\n-            format!(\"{}mut {}\", if local_decl.ty.is_ref() {\"&\"} else {\"*\"}, ty_mut.ty)\n+            format!(\"{}mut {}\", if decl_ty.is_ref() {\"&\"} else {\"*\"}, ty_mut.ty)\n         )\n     }\n }"}, {"sha": "6f3c78443f8293d097885a0f1267904afcb1f326", "filename": "tests/ui/suggestions/issue-68049-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e64e986fe1cbaa3679cd228a6900304ebf81018/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e64e986fe1cbaa3679cd228a6900304ebf81018/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-68049-2.stderr?ref=3e64e986fe1cbaa3679cd228a6900304ebf81018", "patch": "@@ -4,18 +4,18 @@ error[E0594]: cannot assign to `*input`, which is behind a `&` reference\n LL |       *input = self.0;\n    |       ^^^^^^^^^^^^^^^ `input` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n-LL |   fn example(&self, input: mut ); // should suggest here\n-   |                            ~~~\n+LL |   fn example(&self, input: &mut i32) { // should not suggest here\n+   |                             +++\n \n error[E0594]: cannot assign to `self.0`, which is behind a `&` reference\n   --> $DIR/issue-68049-2.rs:17:5\n    |\n LL |     self.0 += *input;\n    |     ^^^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be written\n    |\n-help: consider changing that to be a mutable reference\n+help: consider changing this to be a mutable reference\n    |\n LL |   fn example(&mut self, input: &i32); // should suggest here\n    |              ~~~~~~~~~"}]}