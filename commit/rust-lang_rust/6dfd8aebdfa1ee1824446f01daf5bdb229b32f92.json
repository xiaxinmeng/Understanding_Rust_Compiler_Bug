{"sha": "6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "node_id": "C_kwDOAAsO6NoAKDZkZmQ4YWViZGZhMWVlMTgyNDQ0NmYwMWRhZjViZGIyMjliMzJmOTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-05T11:24:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-05T11:24:54Z"}, "message": "Auto merge of #13192 - lowr:fix/dyn-sort-all-bounds, r=Veykril\n\nfix: sort all bounds on trait object types\n\nFixes #13181\n\n#12793 allowed different ordering of trait bounds in trait object types but failed to account for the ordering of projection bounds. I opted for sorting all the bounds at once rather than splitting them into `SmallVec`s so it's easier to do the same thing for other bounds when we have them.", "tree": {"sha": "a7b29b5234c938c331c609660c3c34406ca14bdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7b29b5234c938c331c609660c3c34406ca14bdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "html_url": "https://github.com/rust-lang/rust/commit/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5be2e6574d96d11f765027e62cfc32fd7d24617f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5be2e6574d96d11f765027e62cfc32fd7d24617f", "html_url": "https://github.com/rust-lang/rust/commit/5be2e6574d96d11f765027e62cfc32fd7d24617f"}, {"sha": "265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/265c75c53ffbc2c4cd13014e958af6e2f743e9bf", "html_url": "https://github.com/rust-lang/rust/commit/265c75c53ffbc2c4cd13014e958af6e2f743e9bf"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "4a5533c6487e48361dd1a94943f7e917c384821e", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "patch": "@@ -164,6 +164,8 @@ impl TyExt for Ty {\n \n     fn dyn_trait(&self) -> Option<TraitId> {\n         let trait_ref = match self.kind(Interner) {\n+            // The principal trait bound should be the first element of the bounds. This is an\n+            // invariant ensured by `TyLoweringContext::lower_dyn_trait()`.\n             TyKind::Dyn(dyn_ty) => dyn_ty.bounds.skip_binders().interned().get(0).and_then(|b| {\n                 match b.skip_binders() {\n                     WhereClause::Implemented(trait_ref) => Some(trait_ref),"}, {"sha": "532544fee595c51eee1680627a70cbfe327a7a01", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "patch": "@@ -981,43 +981,72 @@ impl<'a> TyLoweringContext<'a> {\n \n     fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n         let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n+        // INVARIANT: The principal trait bound must come first. Others may be in any order but\n+        // should be in the same order for the same set but possibly different order of bounds in\n+        // the input.\n+        // This invariant is used by `TyExt::dyn_trait()` and chalk.\n         let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            let bounds =\n-                bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false));\n-\n-            let mut auto_traits = SmallVec::<[_; 8]>::new();\n-            let mut regular_traits = SmallVec::<[_; 2]>::new();\n-            let mut other_bounds = SmallVec::<[_; 8]>::new();\n-            for bound in bounds {\n-                if let Some(id) = bound.trait_id() {\n-                    if ctx.db.trait_data(from_chalk_trait_id(id)).is_auto {\n-                        auto_traits.push(bound);\n-                    } else {\n-                        regular_traits.push(bound);\n+            let mut bounds: Vec<_> = bounds\n+                .iter()\n+                .flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false))\n+                .collect();\n+\n+            let mut multiple_regular_traits = false;\n+            let mut multiple_same_projection = false;\n+            bounds.sort_unstable_by(|lhs, rhs| {\n+                use std::cmp::Ordering;\n+                match (lhs.skip_binders(), rhs.skip_binders()) {\n+                    (WhereClause::Implemented(lhs), WhereClause::Implemented(rhs)) => {\n+                        let lhs_id = lhs.trait_id;\n+                        let lhs_is_auto = ctx.db.trait_data(from_chalk_trait_id(lhs_id)).is_auto;\n+                        let rhs_id = rhs.trait_id;\n+                        let rhs_is_auto = ctx.db.trait_data(from_chalk_trait_id(rhs_id)).is_auto;\n+\n+                        if !lhs_is_auto && !rhs_is_auto {\n+                            multiple_regular_traits = true;\n+                        }\n+                        // Note that the ordering here is important; this ensures the invariant\n+                        // mentioned above.\n+                        (lhs_is_auto, lhs_id).cmp(&(rhs_is_auto, rhs_id))\n                     }\n-                } else {\n-                    other_bounds.push(bound);\n+                    (WhereClause::Implemented(_), _) => Ordering::Less,\n+                    (_, WhereClause::Implemented(_)) => Ordering::Greater,\n+                    (WhereClause::AliasEq(lhs), WhereClause::AliasEq(rhs)) => {\n+                        match (&lhs.alias, &rhs.alias) {\n+                            (AliasTy::Projection(lhs_proj), AliasTy::Projection(rhs_proj)) => {\n+                                // We only compare the `associated_ty_id`s. We shouldn't have\n+                                // multiple bounds for an associated type in the correct Rust code,\n+                                // and if we do, we error out.\n+                                if lhs_proj.associated_ty_id == rhs_proj.associated_ty_id {\n+                                    multiple_same_projection = true;\n+                                }\n+                                lhs_proj.associated_ty_id.cmp(&rhs_proj.associated_ty_id)\n+                            }\n+                            // We don't produce `AliasTy::Opaque`s yet.\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                    // We don't produce `WhereClause::{TypeOutlives, LifetimeOutlives}` yet.\n+                    _ => unreachable!(),\n                 }\n-            }\n+            });\n \n-            if regular_traits.len() > 1 {\n+            if multiple_regular_traits || multiple_same_projection {\n                 return None;\n             }\n \n-            auto_traits.sort_unstable_by_key(|b| b.trait_id().unwrap());\n-            auto_traits.dedup();\n+            // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n+            // bounds. We shouldn't have repeated elements besides auto traits at this point.\n+            bounds.dedup();\n \n-            Some(QuantifiedWhereClauses::from_iter(\n-                Interner,\n-                regular_traits.into_iter().chain(other_bounds).chain(auto_traits),\n-            ))\n+            Some(QuantifiedWhereClauses::from_iter(Interner, bounds))\n         });\n \n         if let Some(bounds) = bounds {\n             let bounds = crate::make_single_type_binders(bounds);\n             TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n         } else {\n-            // FIXME: report error (additional non-auto traits)\n+            // FIXME: report error (additional non-auto traits or associated type rebound)\n             TyKind::Error.intern(Interner)\n         }\n     }"}, {"sha": "21a86319763fc1d78212c1aef02e9f9e22878918", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfd8aebdfa1ee1824446f01daf5bdb229b32f92/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=6dfd8aebdfa1ee1824446f01daf5bdb229b32f92", "patch": "@@ -3900,6 +3900,34 @@ fn g(t: &(dyn Sync + T<Proj = ()> + Send)) {\n     );\n }\n \n+#[test]\n+fn dyn_multiple_projection_bounds() {\n+    check_no_mismatches(\n+        r#\"\n+trait Trait {\n+    type T;\n+    type U;\n+}\n+\n+fn f(t: &dyn Trait<T = (), U = ()>) {}\n+fn g(t: &dyn Trait<U = (), T = ()>) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type T;\n+}\n+\n+fn f(t: &dyn Trait<T = (), T = ()>) {}\n+   //^&{unknown}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn dyn_duplicate_auto_trait() {\n     check_no_mismatches("}]}