{"sha": "8673c4f195be8377f8e0d83929f9a16bb99092a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NzNjNGYxOTViZTgzNzdmOGUwZDgzOTI5ZjlhMTZiYjk5MDkyYTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T14:15:28Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-06T15:53:25Z"}, "message": "Make ty::t type self-sufficient\n\nIt is now no longer needed to have a ty::ctxt to get at the contents\nof a ty::t. The straight-forward approach of doing this, simply making\nty::t a box type, unfortunately killed our compiler performance (~15%\nslower) through refcounting cost. Thus, this patch now represents\nty::t as an unsafe pointer, assuming that the ty::ctxt, which holds\nthese boxes alive, outlives any uses of the ty::t values. In the\ncurrent compiler this trivially holds, but it is does of course add a\nnew potential pitfall.\n\nty::get takes a ty::t and returns a boxed representation of the type.\nI've changed calls to ty::struct(X) to do ty::get(X).struct. Type\nstructs are full of vectors, and copying them every time we wanted to\naccess them was a bit of a cost.", "tree": {"sha": "809c4016f5c84da9adf08a756e67bda6b5bf6b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/809c4016f5c84da9adf08a756e67bda6b5bf6b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8673c4f195be8377f8e0d83929f9a16bb99092a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8673c4f195be8377f8e0d83929f9a16bb99092a0", "html_url": "https://github.com/rust-lang/rust/commit/8673c4f195be8377f8e0d83929f9a16bb99092a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8673c4f195be8377f8e0d83929f9a16bb99092a0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ed8d037841aab1b2855525bf141c5c1c4de4910", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed8d037841aab1b2855525bf141c5c1c4de4910", "html_url": "https://github.com/rust-lang/rust/commit/6ed8d037841aab1b2855525bf141c5c1c4de4910"}], "stats": {"total": 1630, "additions": 661, "deletions": 969}, "files": [{"sha": "aeee29255e4806fff610c78d320927690d07d88a", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -113,7 +113,7 @@ fn doc_type(doc: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n fn item_type(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n-        ty::mk_named(tcx, t, @item_name(item))\n+        ty::mk_named(tcx, t, item_name(item))\n     } else { t }\n }\n \n@@ -247,7 +247,7 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let ctor_ty = item_type(item, tcx, cdata);\n         let name = item_name(item);\n         let arg_tys: [ty::t] = [];\n-        alt ty::struct(tcx, ctor_ty) {\n+        alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n             for a: ty::arg in f.inputs { arg_tys += [a.ty]; }\n           }\n@@ -302,7 +302,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n-        let fty = alt ty::struct(tcx, ty) { ty::ty_fn(f) { f }\n+        let fty = alt ty::get(ty).struct { ty::ty_fn(f) { f }\n           _ { tcx.sess.bug(\"get_iface_methods: id has non-function type\");\n         } };\n         result += [{ident: name, tps: bounds, fty: fty}];"}, {"sha": "fda3ab14cbe3841f305cd798d06d8a7a665f802a", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -353,7 +353,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(ctor_id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(tcx, fn_ty));\n+        encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n         encode_name(ebml_w, item.ident);\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);"}, {"sha": "230d5eeaaf52e4382f268d07b579d300b156cb02", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -299,7 +299,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         while peek(st) as char != '\"' { str::push_byte(name, next(st)); }\n         st.pos = st.pos + 1u;\n         let inner = parse_ty(st, conv);\n-        ty::mk_named(st.tcx, inner, @name)\n+        ty::mk_named(st.tcx, inner, name)\n       }\n       c { #error(\"unexpected char in type string: %c\", c); fail;}\n     }"}, {"sha": "d4e43d36b20b057e8dfa3790dbb8ac1e6783faa7", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -42,8 +42,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n           some(s) { *s }\n           none {\n             let buf = io::mk_mem_buffer();\n-            enc_sty(io::mem_buffer_writer(buf), cx,\n-                    ty::struct_raw(cx.tcx, t));\n+            enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).struct);\n             cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n             io::mem_buffer_str(buf)\n           }\n@@ -55,7 +54,15 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n           some(a) { w.write_str(*a.s); ret; }\n           none {\n             let pos = w.tell();\n-            enc_sty(w, cx, ty::struct_raw(cx.tcx, t));\n+            alt ty::type_name(t) {\n+              some(n) {\n+                w.write_char('\"');\n+                w.write_str(n);\n+                w.write_char('\"');\n+              }\n+              _ {}\n+            }\n+            enc_sty(w, cx, ty::get(t).struct);\n             let end = w.tell();\n             let len = end - pos;\n             fn estimate_sz(u: uint) -> uint {\n@@ -185,14 +192,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         for tc: @ty::type_constr in cs { enc_ty_constr(w, cx, tc); }\n         w.write_char(']');\n       }\n-      ty::ty_named(t, name) {\n-        if cx.abbrevs != ac_no_abbrevs {\n-            w.write_char('\"');\n-            w.write_str(*name);\n-            w.write_char('\"');\n-        }\n-        enc_ty(w, cx, t);\n-      }\n     }\n }\n fn enc_proto(w: io::writer, proto: proto) {"}, {"sha": "1420469004c5f629f40c0be163182e9a7d55ce94", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -80,7 +80,7 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n             id: ast::node_id, sc: scope, v: vt<scope>) {\n     visit::visit_fn_decl(decl, sc, v);\n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    let args = ty::ty_fn_args(cx.tcx, fty);\n+    let args = ty::ty_fn_args(fty);\n     for arg in args {\n         alt ty::resolved_mode(cx.tcx, arg.mode) {\n           ast::by_val if ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n@@ -92,7 +92,7 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n \n     // Blocks need to obey any restrictions from the enclosing scope, and may\n     // be called multiple times.\n-    let proto = ty::ty_fn_proto(cx.tcx, fty);\n+    let proto = ty::ty_fn_proto(fty);\n     alt proto {\n       ast::proto_block | ast::proto_any {\n         check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n@@ -221,7 +221,7 @@ fn cant_copy(cx: ctx, b: binding) -> bool {\n fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     -> [binding] {\n     let fty = ty::expr_ty(cx.tcx, f);\n-    let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n+    let arg_ts = ty::ty_fn_args(fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n     let bindings = [];\n     let i = 0u;\n@@ -371,7 +371,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     let cur_mut = root.mut;\n-    alt ty::struct(cx.tcx, seq_t) {\n+    alt ty::get(seq_t).struct {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm {\n             cur_mut = some(contains(seq_t));\n@@ -510,7 +510,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n           contains(ty) { ty == haystack }\n           mut_contains(ty) { mut && ty == haystack }\n         } { ret true; }\n-        alt ty::struct(tcx, haystack) {\n+        alt ty::get(haystack).struct {\n           ty::ty_enum(_, ts) {\n             for t: ty::t in ts {\n                 if helper(tcx, needle, t, mut) { ret true; }\n@@ -565,7 +565,7 @@ fn local_id_of_node(cx: ctx, id: node_id) -> uint {\n // implicit copy.\n fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n     fn score_ty(tcx: ty::ctxt, ty: ty::t) -> uint {\n-        ret alt ty::struct(tcx, ty) {\n+        ret alt ty::get(ty).struct {\n           ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) |\n           ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type |\n           ty::ty_ptr(_) { 1u }\n@@ -623,7 +623,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat)\n           }\n           ast::pat_box(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n-            let m = alt ty::struct(tcx, ty) {\n+            let m = alt ty::get(ty).struct {\n               ty::ty_box(mt) { mt.mut != ast::imm }\n               _ { tcx.sess.span_bug(pat.span, \"box pat has non-box type\"); }\n             },\n@@ -632,7 +632,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option<unsafe_ty>, pat: @ast::pat)\n           }\n           ast::pat_uniq(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n-            let m = alt ty::struct(tcx, ty) {\n+            let m = alt ty::get(ty).struct {\n               ty::ty_uniq(mt) { mt.mut != ast::imm }\n               _ { tcx.sess.span_bug(pat.span, \"uniq pat has non-uniq type\"); }\n             },"}, {"sha": "f21dcd5cc400a14b4c1a5e4e7f910944ea22da86", "filename": "src/comp/middle/block_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fblock_use.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -13,7 +13,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) {\n \n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     if !cx.allow_block {\n-        alt ty::struct(cx.tcx, ty::expr_ty(cx.tcx, ex)) {\n+        alt ty::get(ty::expr_ty(cx.tcx, ex)).struct {\n           ty::ty_fn({proto: p, _}) if is_blockish(p) {\n             cx.tcx.sess.span_err(ex.span, \"expressions with block type \\\n                 can only appear in callee or (by-ref) argument position\");\n@@ -27,7 +27,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);\n         let i = 0u;\n-        for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n+        for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n             cx.allow_block = (ty::arg_mode(cx.tcx, arg_t) == by_ref);\n             v.visit_expr(args[i], cx, v);\n             i += 1u;"}, {"sha": "bd0182d7badcd6ffffff2d8c35ca0b92c76fe77f", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -73,7 +73,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp:span, scrut_ty:ty::t, pats:[@pat]) {\n     /* Otherwise, get the list of variants and make sure each one is\n      represented. Then recurse on the columns. */\n \n-    let ty_def_id = alt ty::struct(tcx, scrut_ty) {\n+    let ty_def_id = alt ty::get(scrut_ty).struct {\n             ty_enum(id, _) { id }\n             _ { ret; } };\n "}, {"sha": "b5a30d7573e512c51835ad987c8bad971707b34f", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -280,7 +280,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n-        cache, tg, {|md| t == md.data.hash}) {\n+        cache, tg, {|md| ty::type_id(t) == md.data.hash}) {\n       option::some(md) { ret md; }\n       option::none {}\n     }\n@@ -325,7 +325,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n                   lli32(0), //XXX flags?\n                   lli32(encoding)];\n     let llnode = llmdnode(lldata);\n-    let mdval = @{node: llnode, data: {hash: t}};\n+    let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n@@ -347,7 +347,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     //let cu_node = create_compile_unit(cx, fname);\n     let llnode = create_derived_type(tg, file_node.node, \"\", 0, size * 8,\n                                      align * 8, 0, pointee.node);\n-    let mdval = @{node: llnode, data: {hash: t}};\n+    let mdval = @{node: llnode, data: {hash: ty::type_id(t)}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n@@ -420,7 +420,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n-    let mdval = @{node: finish_structure(scx), data:{hash: t}};\n+    let mdval = @{node: finish_structure(scx), data:{hash: ty::type_id(t)}};\n     ret mdval;\n }\n \n@@ -448,7 +448,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n                8, //XXX just a guess\n                boxed.node);\n     let llnode = finish_structure(scx);\n-    let mdval = @{node: llnode, data: {hash: outer}};\n+    let mdval = @{node: llnode, data: {hash: ty::type_id(outer)}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n@@ -507,7 +507,7 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     add_member(scx, \"data\", 0, 0, // clang says the size should be 0\n                sys::align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n-    ret @{node: llnode, data: {hash: vec_t}};\n+    ret @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n }\n \n fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n@@ -561,7 +561,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     }*/\n \n     fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n-        let ty = alt ty::struct(ccx_tcx(cx), t) {\n+        let ty = alt ty::get(t).struct {\n           ty::ty_nil { ast::ty_nil }\n           ty::ty_bot { ast::ty_bot }\n           ty::ty_bool { ast::ty_bool }\n@@ -593,7 +593,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n \n     alt ty.node {\n       ast::ty_box(mt) {\n-        let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n+        let inner_t = alt ty::get(t).struct {\n           ty::ty_box(boxed) { boxed.ty }\n           _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n         };\n@@ -603,7 +603,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       }\n \n       ast::ty_uniq(mt) {\n-        let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n+        let inner_t = alt ty::get(t).struct {\n           ty::ty_uniq(boxed) { boxed.ty }\n           // Hoping we'll have a way to eliminate this check soon.\n           _ { cx.tcx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }"}, {"sha": "6c468cdd1e8a9e2c1c1c425593766c0cc97180b0", "filename": "src/comp/middle/fn_usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffn_usage.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -31,7 +31,7 @@ fn fn_usage_expr(expr: @ast::expr,\n         }\n         if !ctx.generic_bare_fn_legal\n             && ty::expr_has_ty_params(ctx.tcx, expr) {\n-            alt ty::struct(ctx.tcx, ty::expr_ty(ctx.tcx, expr)) {\n+            alt ty::get(ty::expr_ty(ctx.tcx, expr)).struct {\n               ty::ty_fn({proto: ast::proto_bare, _}) {\n                 ctx.tcx.sess.span_fatal(\n                     expr.span,"}, {"sha": "b9dd96f9abe54188d355ff986cd050a97ba37e1e", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -60,7 +60,7 @@ fn check_crate(tcx: ty::ctxt, method_map: typeck::method_map,\n fn with_appropriate_checker(cx: ctx, id: node_id,\n                             b: fn(fn@(ctx, ty::t, sp: span))) {\n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    alt ty::ty_fn_proto(cx.tcx, fty) {\n+    alt ty::ty_fn_proto(fty) {\n       proto_uniq { b(check_send); }\n       proto_box { b(check_copy); }\n       proto_bare { b(check_none); }\n@@ -142,9 +142,10 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n           some(ex) {\n             // All noncopyable fields must be overridden\n             let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f }\n-              _ { cx.tcx.sess.span_bug(ex.span,\n-                     \"Bad expr type in record\"); } };\n+            let ty_fields = alt ty::get(t).struct {\n+              ty::ty_rec(f) { f }\n+              _ { cx.tcx.sess.span_bug(ex.span, \"Bad expr type in record\"); }\n+            };\n             for tf in ty_fields {\n                 if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n                     !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n@@ -164,7 +165,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_call(f, args, _) {\n         let i = 0u;\n-        for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n+        for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n             alt ty::arg_mode(cx.tcx, arg_t) {\n               by_copy { maybe_copy(cx, args[i]); }\n               by_ref | by_val | by_mut_ref | by_move { }\n@@ -242,7 +243,7 @@ fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n         check_copy(cx, ty, ex.span);\n         // FIXME turn this on again once vector types are no longer unique.\n         // Right now, it is too annoying to be useful.\n-        /* if warn && ty::type_is_unique(cx.tcx, ty) {\n+        /* if warn && ty::type_is_unique(ty) {\n             cx.tcx.sess.span_warn(ex.span, \"copying a unique value\");\n         }*/\n     }"}, {"sha": "0f34f270821a7a1fbae0ffc74764b3e0877feb4f", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -65,7 +65,7 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n }\n \n fn ex_is_blockish(cx: ctx, id: node_id) -> bool {\n-    alt ty::struct(cx.tcx, ty::node_id_to_type(cx.tcx, id)) {\n+    alt ty::get(ty::node_id_to_type(cx.tcx, id)).struct {\n       ty::ty_fn({proto: p, _}) if is_blockish(p) { true }\n       _ { false }\n     }\n@@ -147,7 +147,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_call(f, args, _) {\n         v.visit_expr(f, cx, v);\n         let i = 0u, fns = [];\n-        let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n+        let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n         for arg in args {\n             alt arg.node {\n               expr_fn(p, _, _, _) if is_blockish(p) {\n@@ -175,7 +175,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n             sp: span, id: node_id,\n             cx: ctx, v: visit::vt<ctx>) {\n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    let proto = ty::ty_fn_proto(cx.tcx, fty);\n+    let proto = ty::ty_fn_proto(fty);\n     alt proto {\n       proto_any | proto_block {\n         visit_block(func, cx, {||"}, {"sha": "1e996b4e3d3b3557b6432eba62f0a7614b77d6da", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -18,7 +18,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n     fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let ds = [], t = t;\n         while true {\n-            alt ty::struct(tcx, t) {\n+            alt ty::get(t).struct {\n               ty::ty_box(mt) {\n                 ds += [@{mut: mt.mut == mut, kind: unbox(false), outer_t: t}];\n                 t = mt.ty;\n@@ -51,7 +51,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n           expr_field(base, ident, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n             let is_mut = false;\n-            alt ty::struct(tcx, auto_unbox.t) {\n+            alt ty::get(auto_unbox.t).struct {\n               ty::ty_rec(fields) {\n                 for fld: ty::field in fields {\n                     if str::eq(ident, fld.ident) {\n@@ -68,7 +68,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n           }\n           expr_index(base, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n-            alt ty::struct(tcx, auto_unbox.t) {\n+            alt ty::get(auto_unbox.t).struct {\n               ty::ty_vec(mt) {\n                 ds +=\n                     [@{mut: mt.mut == mut,\n@@ -87,7 +87,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n             if op == deref {\n                 let base_t = ty::expr_ty(tcx, base);\n                 let is_mut = false, ptr = false;\n-                alt ty::struct(tcx, base_t) {\n+                alt ty::get(base_t).struct {\n                   ty::ty_box(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_uniq(mt) { is_mut = mt.mut == mut; }\n                   ty::ty_res(_, _, _) { }\n@@ -225,7 +225,7 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n }\n \n fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n-    let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n+    let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n@@ -238,7 +238,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n }\n \n fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n-    let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n+    let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n     let i = 0u;\n     for arg in args {\n         alt arg {\n@@ -277,7 +277,7 @@ fn is_immutable_def(cx: @ctx, def: def) -> option<str> {\n       def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, node_id) {\n         let ty = ty::node_id_to_type(cx.tcx, node_id);\n-        let proto = ty::ty_fn_proto(cx.tcx, ty);\n+        let proto = ty::ty_fn_proto(ty);\n         ret alt proto {\n           proto_any | proto_block { is_immutable_def(cx, *inner) }\n           _ { some(\"upvar\") }"}, {"sha": "509054167bc2f5970ea5f137d1abfcec9a769f82", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -76,7 +76,7 @@ fn hash_res_info(ri: res_info) -> uint {\n     h *= 33u;\n     h += ri.did.node as uint;\n     h *= 33u;\n-    h += ri.t as uint;\n+    h += ty::type_id(ri.t);\n     ret h;\n }\n \n@@ -121,7 +121,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n         let bounded = true;\n         let {a: min_size, b: min_align} = {a: 0u, b: 0u};\n         for elem_t: ty::t in variant.args {\n-            if ty::type_contains_params(ccx.tcx, elem_t) {\n+            if ty::type_has_params(elem_t) {\n                 // TODO: We could do better here; this causes us to\n                 // conservatively assume that (int, T) has minimum size 0,\n                 // when in fact it has minimum size sizeof(int).\n@@ -319,7 +319,7 @@ fn add_substr(&dest: [u8], src: [u8]) {\n fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n-    alt ty::struct(ccx.tcx, t) {\n+    alt ty::get(t).struct {\n       ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n       ty::ty_bot { s += [shape_u8]; }\n       ty::ty_int(ast::ty_i) { s += [s_int(ccx.tcx)]; }\n@@ -447,7 +447,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_constr(inner_t, _) {\n         s += shape_of(ccx, inner_t, ty_param_map);\n       }\n-      ty::ty_var(_) | ty::ty_named(_, _) | ty::ty_self(_) {\n+      ty::ty_var(_) | ty::ty_self(_) {\n         ccx.tcx.sess.bug(\"shape_of: unexpected type struct found\");\n       }\n     }\n@@ -664,7 +664,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n-    alt ty::struct(cx.tcx, t) {\n+    alt ty::get(t).struct {\n       ty::ty_enum(tid, subtys) {\n         // Compute max(variant sizes).\n \n@@ -719,7 +719,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n         ret { bcx: bcx, sz: off, align: max_align };\n     }\n \n-    alt ty::struct(bcx_tcx(cx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_param(p, _) {\n         let ti = none::<@tydesc_info>;\n         let {bcx, val: tydesc} = base::get_tydesc(cx, t, false, ti).result;\n@@ -783,7 +783,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n // types.\n fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-        alt ty::struct(ccx.tcx, typ) {\n+        alt ty::get(typ).struct {\n           ty::ty_box(_) | ty::ty_iface(_, _) {\n             ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }"}, {"sha": "20c0d0672dac2f4ebcd129cfda858bc7c715e463", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -428,8 +428,6 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         let rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n-            // not sure how to get rid of this check\n-            check type_is_tup_like(bcx, rec_ty);\n             let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             rec_vals += [r.val];\n             bcx = r.bcx;\n@@ -441,18 +439,12 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     if any_tup_pat(m, col) {\n         let tup_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n-        let n_tup_elts =\n-            alt ty::struct(ccx.tcx, tup_ty) {\n-              ty::ty_tup(elts) { vec::len(elts) }\n-              _ {\n-                  ccx.sess.bug(\"Non-tuple type in tuple\\\n-                    pattern\");\n-              }\n-            };\n+        let n_tup_elts = alt ty::get(tup_ty).struct {\n+          ty::ty_tup(elts) { vec::len(elts) }\n+          _ { ccx.sess.bug(\"Non-tuple type in tuple pattern\"); }\n+        };\n         let tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n-            // how to get rid of this check?\n-            check type_is_tup_like(bcx, tup_ty);\n             let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             tup_vals += [r.val];\n             bcx = r.bcx;\n@@ -500,11 +492,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           lit(l) {\n             test_val = Load(bcx, val);\n             let pty = ty::node_id_to_type(ccx.tcx, pat_id);\n-            kind = if ty::type_is_integral(ccx.tcx, pty) {\n-                       switch\n-                   } else {\n-                       compare\n-                   };\n+            kind = if ty::type_is_integral(pty) { switch }\n+                   else { compare };\n           }\n           range(_, _) {\n             test_val = Load(bcx, val);\n@@ -729,7 +718,6 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // FIXME: Could constrain pat_bind to make this\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n-            check non_ty_var(ccx, ty);\n             let llty = base::type_of(ccx, ty);\n             let alloc = base::alloca(bcx, llty);\n             bcx = base::copy_val(bcx, base::INIT, alloc,\n@@ -758,7 +746,6 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         for f: ast::field_pat in fields {\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n-            check type_is_tup_like(bcx, rec_ty);\n             let r = base::GEP_tup_like(bcx, rec_ty, val, [0, ix as int]);\n             bcx = bind_irrefutable_pat(r.bcx, f.pat, r.val, make_copy);\n         }\n@@ -767,8 +754,6 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let tup_ty = node_id_type(bcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n-            // how to get rid of this check?\n-            check type_is_tup_like(bcx, tup_ty);\n             let r = base::GEP_tup_like(bcx, tup_ty, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(r.bcx, elem, r.val, make_copy);\n             i += 1u;"}, {"sha": "103c831130de8b5acb5b0f324de112fd81835571", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 158, "deletions": 219, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -55,9 +55,6 @@ fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n \n fn type_of(cx: @crate_ctxt, t: ty::t) : type_has_static_size(cx, t)\n    -> TypeRef {\n-    // Should follow from type_has_static_size -- argh.\n-    // FIXME (requires Issue #586)\n-    check non_ty_var(cx, t);\n     type_of_inner(cx, t)\n }\n \n@@ -66,9 +63,6 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) ->\n     let tcx = ccx_tcx(cx);\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n-        // FIXME: would be nice to have a constraint on arg\n-        // that would obviate the need for this check\n-        check non_ty_var(cx, arg_ty);\n         let llty = type_of_inner(cx, arg_ty);\n         alt ty::resolved_mode(tcx, arg.mode) {\n           ast::by_val { llty }\n@@ -89,7 +83,6 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n-    check non_ty_var(cx, output);\n     let out_ty = T_ptr(type_of_inner(cx, output));\n     atys += [out_ty];\n \n@@ -114,17 +107,15 @@ fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n                       param_bounds: [ty::param_bounds]) -> TypeRef {\n-    let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n-    ret type_of_fn(cx, ty::ty_fn_args(cx.tcx, fty),\n-                   ret_ty, param_bounds);\n+    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty), param_bounds)\n }\n \n-fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n-    : non_ty_var(cx, t) -> TypeRef {\n+fn type_of_inner(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+    assert !ty::type_has_vars(t);\n     // Check the cache.\n \n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n-    let llty = alt ty::struct(cx.tcx, t) {\n+    let llty = alt ty::get(t).struct {\n       ty::ty_nil { T_nil() }\n       ty::ty_bot {\n         T_nil() /* ...I guess? */\n@@ -137,30 +128,24 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n       ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n-        check non_ty_var(cx, mt_ty);\n         T_ptr(T_box(cx, type_of_inner(cx, mt_ty))) }\n       ty::ty_uniq(mt) {\n         let mt_ty = mt.ty;\n-        check non_ty_var(cx, mt_ty);\n         T_ptr(type_of_inner(cx, mt_ty)) }\n       ty::ty_vec(mt) {\n         let mt_ty = mt.ty;\n         if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n             T_ptr(cx.opaque_vec_type)\n         } else {\n-            // should be unnecessary\n-            check non_ty_var(cx, mt_ty);\n             T_ptr(T_vec(cx, type_of_inner(cx, mt_ty))) }\n       }\n       ty::ty_ptr(mt) {\n         let mt_ty = mt.ty;\n-        check non_ty_var(cx, mt_ty);\n         T_ptr(type_of_inner(cx, mt_ty)) }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = [];\n         for f: ty::field in fields {\n             let mt_ty = f.mt.ty;\n-            check non_ty_var(cx, mt_ty);\n             tys += [type_of_inner(cx, mt_ty)];\n         }\n         T_struct(tys)\n@@ -171,7 +156,6 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n       ty::ty_iface(_, _) { T_opaque_iface_ptr(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n-        check non_ty_var(cx, sub1);\n         // FIXME #1184: Resource flag is larger than necessary\n         ret T_struct([cx.int_type, type_of_inner(cx, sub1)]);\n       }\n@@ -187,7 +171,6 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n       ty::ty_tup(elts) {\n         let tys = [];\n         for elt in elts {\n-            check non_ty_var(cx, elt);\n             tys += [type_of_inner(cx, elt)];\n         }\n         T_struct(tys)\n@@ -196,8 +179,6 @@ fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n         T_opaque_box_ptr(cx)\n       }\n       ty::ty_constr(subt,_) {\n-        // FIXME: could be a constraint on ty_fn\n-          check non_ty_var(cx, subt);\n           type_of_inner(cx, subt)\n       }\n       _ {\n@@ -226,7 +207,7 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n fn type_of_ty_param_bounds_and_ty\n     (ccx: @crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let t = tpt.ty;\n-    alt ty::struct(ccx.tcx, t) {\n+    alt ty::get(t).struct {\n       ty::ty_fn(_) {\n         ret type_of_fn_from_ty(ccx, t, *tpt.bounds);\n       }\n@@ -451,7 +432,7 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n // types.\n fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-        alt ty::struct(ccx.tcx, typ) {\n+        alt ty::get(typ).struct {\n           ty::ty_box(_) | ty::ty_iface(_, _) {\n             ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }\n@@ -509,7 +490,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n         //};\n         ret rslt(bcx, off);\n     }\n-    alt ty::struct(bcx_tcx(cx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_param(p, _) {\n         let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n         ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n@@ -563,7 +544,7 @@ fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n // FIXME: Typestate constraint that shows this alt is\n // exhaustive\n-    alt ty::struct(bcx_tcx(cx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_param(p, _) {\n         let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n         ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n@@ -616,22 +597,13 @@ fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     } else { bumped }\n }\n \n-// GEP_tup_like is a pain to use if you always have to precede it with a\n-// check.\n-fn GEP_tup_like_1(cx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n-    -> result {\n-    check type_is_tup_like(cx, t);\n-    ret GEP_tup_like(cx, t, base, ixs);\n-}\n-\n // Replacement for the LLVM 'GEP' instruction when field-indexing into a\n // tuple-like structure (tup, rec) with a static index. This one is driven off\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n-    : type_is_tup_like(bcx, t) -> result {\n-\n+    -> result {\n     fn compute_off(bcx: @block_ctxt,\n                    off: ValueRef,\n                    t: ty::t,\n@@ -641,11 +613,10 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n             ret (bcx, off, t);\n         }\n \n-        let tcx = bcx_tcx(bcx);\n         let ix = ixs[n];\n         let bcx = bcx, off = off;\n         int::range(0, ix) {|i|\n-            let comp_t = ty::get_element_type(tcx, t, i as uint);\n+            let comp_t = ty::get_element_type(t, i as uint);\n             let align = align_of(bcx, comp_t);\n             bcx = align.bcx;\n             off = align_to(bcx, off, align.val);\n@@ -654,7 +625,7 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n             off = Add(bcx, off, sz.val);\n         }\n \n-        let comp_t = ty::get_element_type(tcx, t, ix as uint);\n+        let comp_t = ty::get_element_type(t, ix as uint);\n         let align = align_of(bcx, comp_t);\n         bcx = align.bcx;\n         off = align_to(bcx, off, align.val);\n@@ -723,8 +694,6 @@ fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n     } else { llunionptr = llblobptr; }\n \n     // Do the GEP_tup_like().\n-    // Silly check -- postcondition on mk_tup?\n-    check type_is_tup_like(cx, tup_ty);\n     let rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix as int]);\n     // Cast the result to the appropriate type, if necessary.\n \n@@ -822,7 +791,7 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n    {params: [uint], descs: [ValueRef]} {\n     let param_vals = [], param_defs = [];\n     ty::walk_ty(bcx_tcx(cx), t) {|t|\n-        alt ty::struct(bcx_tcx(cx), t) {\n+        alt ty::get(t).struct {\n           ty::ty_param(pid, _) {\n             if !vec::any(param_defs, {|d| d == pid}) {\n                 param_vals += [cx.fcx.lltyparams[pid].desc];\n@@ -937,7 +906,7 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n    -> get_tydesc_result {\n \n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n-    alt ty::type_param(bcx_tcx(cx), t) {\n+    alt ty::type_param(t) {\n       some(id) {\n         if id < vec::len(cx.fcx.lltyparams) {\n             ret {kind: tk_param,\n@@ -952,7 +921,7 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n-    if ty::type_contains_params(bcx_tcx(cx), t) {\n+    if ty::type_has_params(t) {\n         ret {kind: tk_derived,\n              result: get_derived_tydesc(cx, t, escapes, static_ti)};\n     }\n@@ -997,8 +966,8 @@ fn set_custom_stack_growth_fn(f: ValueRef) {\n     llvm::LLVMAddFunctionAttr(f, 0u as c_uint, 1u as c_uint);\n }\n \n-fn set_glue_inlining(ccx: @crate_ctxt, f: ValueRef, t: ty::t) {\n-    if ty::type_is_structural(ccx.tcx, t) {\n+fn set_glue_inlining(f: ValueRef, t: ty::t) {\n+    if ty::type_is_structural(t) {\n         set_no_inline(f);\n     } else { set_always_inline(f); }\n }\n@@ -1054,7 +1023,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n         fn_nm = sanitize(fn_nm);\n     } else { fn_nm = mangle_internal_name_by_seq(ccx, \"glue_\" + name); }\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n-    set_glue_inlining(ccx, llfn, t);\n+    set_glue_inlining(llfn, t);\n     ret llfn;\n }\n \n@@ -1171,14 +1140,12 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n \n     let bcx = cx;\n-    let tcx = bcx_tcx(cx);\n     // NB: v is an *alias* of type t here, not a direct value.\n-    bcx = alt ty::struct(tcx, t) {\n+    bcx = alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_iface(_, _) {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v))\n       }\n       ty::ty_uniq(_) {\n-        check uniq::type_is_unique_box(bcx, t);\n         let r = uniq::duplicate(bcx, Load(bcx, v), t);\n         Store(r.bcx, r.val, v);\n         r.bcx\n@@ -1202,7 +1169,7 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n-      _ if ty::type_is_structural(bcx_tcx(bcx), t) {\n+      _ if ty::type_is_structural(t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n       }\n       _ { bcx }\n@@ -1222,7 +1189,7 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n }\n \n fn free_box(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n-    ret alt ty::struct(bcx_tcx(bcx), t) {\n+    ret alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n         let v = PointerCast(bcx, v, type_of_1(bcx, t));\n         let body = GEPi(bcx, v, [0, abi::box_field_body]);\n@@ -1238,12 +1205,11 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n     // everything to a pointer to the type that the glue acts on).\n-    let bcx = alt ty::struct(bcx_tcx(bcx), t) {\n+    let bcx = alt ty::get(t).struct {\n       ty::ty_box(body_mt) {\n         free_box(bcx, v, t)\n       }\n       ty::ty_uniq(content_mt) {\n-        check uniq::type_is_unique_box(bcx, t);\n         let v = PointerCast(bcx, v, type_of_1(bcx, t));\n         uniq::make_free_glue(bcx, v, t)\n       }\n@@ -1286,30 +1252,29 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(bcx);\n-    let bcx =\n-        alt ty::struct(ccx.tcx, t) {\n-          ty::ty_box(_) | ty::ty_iface(_, _) {\n-              decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n-          }\n-          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str | ty::ty_send_type {\n-            free_ty(bcx, Load(bcx, v0), t)\n-          }\n-          ty::ty_res(did, inner, tps) {\n-            trans_res_drop(bcx, v0, did, inner, tps)\n-          }\n-          ty::ty_fn(_) {\n-            closure::make_fn_glue(bcx, v0, t, drop_ty)\n-          }\n-          ty::ty_opaque_closure_ptr(ck) {\n-            closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n-          }\n-          _ {\n-            if ty::type_needs_drop(ccx.tcx, t) &&\n-               ty::type_is_structural(ccx.tcx, t) {\n-                iter_structural_ty(bcx, v0, t, drop_ty)\n-            } else { bcx }\n-          }\n-        };\n+    let bcx = alt ty::get(t).struct {\n+      ty::ty_box(_) | ty::ty_iface(_, _) {\n+        decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n+      }\n+      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str | ty::ty_send_type {\n+        free_ty(bcx, Load(bcx, v0), t)\n+      }\n+      ty::ty_res(did, inner, tps) {\n+        trans_res_drop(bcx, v0, did, inner, tps)\n+      }\n+      ty::ty_fn(_) {\n+        closure::make_fn_glue(bcx, v0, t, drop_ty)\n+      }\n+      ty::ty_opaque_closure_ptr(ck) {\n+        closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n+      }\n+      _ {\n+        if ty::type_needs_drop(ccx.tcx, t) &&\n+            ty::type_is_structural(t) {\n+            iter_structural_ty(bcx, v0, t, drop_ty)\n+        } else { bcx }\n+      }\n+    };\n     build_return(bcx);\n }\n \n@@ -1321,15 +1286,12 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n \n-    // Silly check\n-    check type_is_tup_like(cx, tup_ty);\n     let drop_flag = GEP_tup_like(cx, tup_ty, rs, [0, 0]);\n     let cx = drop_flag.bcx;\n     let null_test = IsNull(cx, Load(cx, drop_flag.val));\n     CondBr(cx, null_test, next_cx.llbb, drop_cx.llbb);\n     cx = drop_cx;\n \n-    check type_is_tup_like(cx, tup_ty);\n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n@@ -1408,7 +1370,7 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n                         t: ty::t, op: ast::binop) -> result {\n     let f = bind compare_scalar_values(cx, lhs, rhs, _, op);\n \n-    alt ty::struct(bcx_tcx(cx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_nil { ret rslt(cx, f(nil_type)); }\n       ty::ty_bool | ty::ty_ptr(_) { ret rslt(cx, f(unsigned_int)); }\n       ty::ty_int(_) { ret rslt(cx, f(signed_int)); }\n@@ -1522,7 +1484,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let fn_ty = variant.ctor_ty;\n         let ccx = bcx_ccx(cx);\n         let cx = cx;\n-        alt ty::struct(ccx.tcx, fn_ty) {\n+        alt ty::get(fn_ty).struct {\n           ty::ty_fn({inputs: args, _}) {\n             let j = 0u;\n             let v_id = variant.id;\n@@ -1546,12 +1508,10 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     Typestate constraint that shows the unimpl case doesn't happen?\n     */\n     let cx = cx;\n-    alt ty::struct(bcx_tcx(cx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n         let i: int = 0;\n         for fld: ty::field in fields {\n-            // Silly check\n-            check type_is_tup_like(cx, t);\n             let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n             cx = f(bcx, llfld_a, fld.mt.ty);\n             i += 1;\n@@ -1560,8 +1520,6 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n       ty::ty_tup(args) {\n         let i = 0;\n         for arg in args {\n-            // Silly check\n-            check type_is_tup_like(cx, t);\n             let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, t, av, [0, i]);\n             cx = f(bcx, llfld_a, arg);\n             i += 1;\n@@ -1572,8 +1530,6 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         let inner1 = ty::substitute_type_params(tcx, tps, inner);\n         let inner_t_s = ty::substitute_type_params(tcx, tps, inner);\n         let tup_t = ty::mk_tup(tcx, [ty::mk_int(tcx), inner_t_s]);\n-        // Silly check\n-        check type_is_tup_like(cx, tup_t);\n         let {bcx: bcx, val: llfld_a} = GEP_tup_like(cx, tup_t, av, [0, 1]);\n         ret f(bcx, llfld_a, inner1);\n       }\n@@ -1802,7 +1758,7 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n }\n \n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n-    alt ty::struct(bcx_tcx(bcx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n       ty::ty_box(_) | ty::ty_iface(_, _) { decr_refcnt_maybe_free(bcx, v, t) }\n       // Precondition?\n@@ -1811,12 +1767,11 @@ fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n }\n \n fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n-    alt ty::struct(bcx_tcx(bcx), t) {\n+    alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_iface(_, _) {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n       }\n       ty::ty_uniq(_) {\n-        check uniq::type_is_unique_box(bcx, t);\n         uniq::duplicate(bcx, v, t)\n       }\n       ty::ty_str | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n@@ -1860,7 +1815,7 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        if ty::type_is_structural(bcx_tcx(bcx), t) {\n+        if ty::type_is_structural(t) {\n             let llsz = llsize_of(ccx, type_of(ccx, t));\n             ret call_memmove(bcx, dst, src, llsz).bcx;\n         }\n@@ -1875,9 +1830,9 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n enum copy_action { INIT, DROP_EXISTING, }\n \n // These are the types that are passed by pointer.\n-fn type_is_structural_or_param(tcx: ty::ctxt, t: ty::t) -> bool {\n-    if ty::type_is_structural(tcx, t) { ret true; }\n-    alt ty::struct(tcx, t) {\n+fn type_is_structural_or_param(t: ty::t) -> bool {\n+    if ty::type_is_structural(t) { ret true; }\n+    alt ty::get(t).struct {\n       ty::ty_param(_, _) { ret true; }\n       _ { ret false; }\n     }\n@@ -1886,8 +1841,8 @@ fn type_is_structural_or_param(tcx: ty::ctxt, t: ty::t) -> bool {\n fn copy_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: ValueRef, t: ty::t) -> @block_ctxt {\n     if action == DROP_EXISTING &&\n-        (type_is_structural_or_param(bcx_tcx(cx), t) ||\n-         ty::type_is_unique(bcx_tcx(cx), t)) {\n+        (type_is_structural_or_param(t) ||\n+         ty::type_is_unique(t)) {\n         let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n         let dstcmp = load_if_immediate(cx, dst, t);\n@@ -1905,18 +1860,18 @@ fn copy_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n-    if ty::type_is_scalar(ccx.tcx, t) {\n+    if ty::type_is_scalar(t) {\n         Store(bcx, src, dst);\n         ret bcx;\n     }\n-    if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) { ret bcx; }\n-    if ty::type_is_boxed(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t) ||\n-       ty::type_is_unique_box(ccx.tcx, t) {\n+    if ty::type_is_nil(t) || ty::type_is_bot(t) { ret bcx; }\n+    if ty::type_is_boxed(t) || ty::type_is_vec(t) ||\n+       ty::type_is_unique_box(t) {\n         if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         Store(bcx, src, dst);\n         ret take_ty(bcx, dst, t);\n     }\n-    if type_is_structural_or_param(ccx.tcx, t) {\n+    if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         bcx = memmove_ty(bcx, dst, src, t);\n         ret take_ty(bcx, dst, t);\n@@ -1935,21 +1890,21 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> @block_ctxt {\n     let src_val = src.val;\n     let tcx = bcx_tcx(cx), cx = cx;\n-    if ty::type_is_scalar(tcx, t) {\n+    if ty::type_is_scalar(t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n         ret cx;\n-    } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n+    } else if ty::type_is_nil(t) || ty::type_is_bot(t) {\n         ret cx;\n-    } else if ty::type_is_boxed(tcx, t) || ty::type_is_unique(tcx, t) {\n+    } else if ty::type_is_boxed(t) || ty::type_is_unique(t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n         if src.kind == owned { ret zero_alloca(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n         ret cx;\n-    } else if type_is_structural_or_param(tcx, t) {\n+    } else if type_is_structural_or_param(t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t);\n         if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n@@ -2023,7 +1978,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n       }\n       ast::neg {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n-        let neg = if ty::type_is_fp(bcx_tcx(bcx), e_ty) {\n+        let neg = if ty::type_is_fp(e_ty) {\n             FNeg(bcx, val)\n         } else { Neg(bcx, val) };\n         ret store_in_dest(bcx, neg, dest);\n@@ -2056,7 +2011,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n \n fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n-    if ty::type_is_scalar(bcx_tcx(cx), rhs_t) {\n+    if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n       ret rslt(rs.bcx, rs.val);\n     }\n@@ -2092,10 +2047,10 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     -> @block_ctxt {\n     if dest == ignore { ret cx; }\n     let intype = lhs_t;\n-    if ty::type_is_bot(bcx_tcx(cx), intype) { intype = rhs_t; }\n-    let is_float = ty::type_is_fp(bcx_tcx(cx), intype);\n+    if ty::type_is_bot(intype) { intype = rhs_t; }\n+    let is_float = ty::type_is_fp(intype);\n \n-    if op == ast::add && ty::type_is_sequence(bcx_tcx(cx), intype) {\n+    if op == ast::add && ty::type_is_sequence(intype) {\n         ret tvec::trans_add(cx, intype, lhs, rhs, dest);\n     }\n     let cx = cx, val = alt op {\n@@ -2113,13 +2068,13 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n       }\n       ast::div {\n         if is_float { FDiv(cx, lhs, rhs) }\n-        else if ty::type_is_signed(bcx_tcx(cx), intype) {\n+        else if ty::type_is_signed(intype) {\n             SDiv(cx, lhs, rhs)\n         } else { UDiv(cx, lhs, rhs) }\n       }\n       ast::rem {\n         if is_float { FRem(cx, lhs, rhs) }\n-        else if ty::type_is_signed(bcx_tcx(cx), intype) {\n+        else if ty::type_is_signed(intype) {\n             SRem(cx, lhs, rhs)\n         } else { URem(cx, lhs, rhs) }\n       }\n@@ -2159,7 +2114,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n     }\n \n     // Special case for `+= [x]`\n-    alt ty::struct(tcx, t) {\n+    alt ty::get(t).struct {\n       ty::ty_vec(_) {\n         alt src.node {\n           ast::expr_vec(args, _) {\n@@ -2172,7 +2127,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n       _ { }\n     }\n     let {bcx, val: rhs_val} = trans_temp_expr(lhs_res.bcx, src);\n-    if ty::type_is_sequence(tcx, t) {\n+    if ty::type_is_sequence(t) {\n         alt op {\n           ast::add {\n             ret tvec::trans_append(bcx, t, lhs_res.val, rhs_val);\n@@ -2189,7 +2144,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     let t1: ty::t = t;\n     let ccx = bcx_ccx(cx);\n     while true {\n-        alt ty::struct(ccx.tcx, t1) {\n+        alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n             let body = GEPi(cx, v1, [0, abi::box_field_body]);\n             t1 = mt.ty;\n@@ -2204,8 +2159,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             } else { v1 = body; }\n           }\n           ty::ty_uniq(_) {\n-            check uniq::type_is_unique_box(cx, t1);\n-            let derefed = uniq::autoderef(cx, v1, t1);\n+            let derefed = uniq::autoderef(v1, t1);\n             t1 = derefed.t;\n             v1 = derefed.v;\n           }\n@@ -2428,7 +2382,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n     let seq = PointerCast(bcx, seq, T_ptr(ccx.opaque_vec_type));\n     let fill = tvec::get_fill(bcx, seq);\n-    if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n+    if ty::type_is_str(seq_ty) {\n         fill = Sub(bcx, fill, C_int(ccx, 1));\n     }\n     let bcx = tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n@@ -2562,7 +2516,7 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     if ccx.sess.opts.monomorphize && vec::len(tys) > 0u &&\n        fn_id.crate == ast::local_crate &&\n-       !vec::any(tys, {|t| ty::type_contains_params(ccx.tcx, t)}) &&\n+       !vec::any(tys, {|t| ty::type_has_params(t)}) &&\n        vec::all(*tpt.bounds, {|bs| vec::all(*bs, {|b|\n            alt b { ty::bound_iface(_) { false } _ { true } }\n        })}) {\n@@ -2701,15 +2655,13 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n-    let fields = alt ty::struct(bcx_tcx(bcx), ty) {\n+    let fields = alt ty::get(ty).struct {\n             ty::ty_rec(fs) { fs }\n             // Constraint?\n             _ { bcx_tcx(bcx).sess.span_bug(base.span, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n         };\n     let ix = option::get(ty::field_idx(field, fields));\n-    // Silly check\n-    check type_is_tup_like(bcx, ty);\n     let {bcx, val} = GEP_tup_like(bcx, ty, val, [0, ix as int]);\n     ret {bcx: bcx, val: val, kind: owned};\n }\n@@ -2810,29 +2762,28 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         let ccx = bcx_ccx(cx);\n         let sub = trans_temp_expr(cx, base);\n         let t = expr_ty(cx, base);\n-        let val =\n-            alt ty::struct(ccx.tcx, t) {\n-              ty::ty_box(_) {\n-                GEPi(sub.bcx, sub.val, [0, abi::box_field_body])\n-              }\n-              ty::ty_res(_, _, _) {\n-                GEPi(sub.bcx, sub.val, [0, 1])\n-              }\n-              ty::ty_enum(_, _) {\n-                let ety = expr_ty(cx, e);\n-                let ellty =\n-                    if check type_has_static_size(ccx, ety) {\n-                        T_ptr(type_of(ccx, ety))\n-                    } else { T_typaram_ptr(ccx.tn) };\n-                PointerCast(sub.bcx, sub.val, ellty)\n-              }\n-              ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n-              // Precondition?\n-              _ {\n-                  bcx_tcx(cx).sess.span_bug(e.span, \"trans_lval:\\\n-                    Weird argument in deref\");\n-              }\n-            };\n+        let val = alt ty::get(t).struct {\n+          ty::ty_box(_) {\n+            GEPi(sub.bcx, sub.val, [0, abi::box_field_body])\n+          }\n+          ty::ty_res(_, _, _) {\n+            GEPi(sub.bcx, sub.val, [0, 1])\n+          }\n+          ty::ty_enum(_, _) {\n+            let ety = expr_ty(cx, e);\n+            let ellty =\n+                if check type_has_static_size(ccx, ety) {\n+                T_ptr(type_of(ccx, ety))\n+            } else { T_typaram_ptr(ccx.tn) };\n+            PointerCast(sub.bcx, sub.val, ellty)\n+          }\n+          ty::ty_ptr(_) | ty::ty_uniq(_) { sub.val }\n+          // Precondition?\n+          _ {\n+            bcx_tcx(cx).sess.span_bug(e.span, \"trans_lval:\\\n+                                               Weird argument in deref\");\n+          }\n+        };\n         ret lval_owned(sub.bcx, val);\n       }\n       _ { bcx_ccx(cx).sess.span_bug(e.span, \"non-lval in trans_lval\"); }\n@@ -2857,7 +2808,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     alt c.generic {\n       some(gi) {\n-        let n_args = vec::len(ty::ty_fn_args(bcx_tcx(c.bcx), ty));\n+        let n_args = vec::len(ty::ty_fn_args(ty));\n         let args = vec::init_elt(n_args, none::<@ast::expr>);\n         let space = alloc_ty(c.bcx, ty);\n         let bcx = closure::trans_bind_1(space.bcx, ty, c, args, ty,\n@@ -2900,7 +2851,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     let t_out = node_id_type(cx, id);\n-    alt ty::struct(bcx_tcx(cx), t_out) {\n+    alt ty::get(t_out).struct {\n       ty::ty_iface(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n       _ {}\n     }\n@@ -2913,20 +2864,16 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     let ll_t_out = type_of(ccx, t_out);\n \n     enum kind { pointer, integral, float, enum_, other, }\n-    fn t_kind(tcx: ty::ctxt, t: ty::t) -> kind {\n-        ret if ty::type_is_fp(tcx, t) {\n-                float\n-            } else if ty::type_is_unsafe_ptr(tcx, t) {\n-                pointer\n-            } else if ty::type_is_integral(tcx, t) {\n-                integral\n-            } else if ty::type_is_enum(tcx, t) {\n-                enum_\n-            } else { other };\n-    }\n-    let k_in = t_kind(ccx.tcx, t_in);\n-    let k_out = t_kind(ccx.tcx, t_out);\n-    let s_in = k_in == integral && ty::type_is_signed(ccx.tcx, t_in);\n+    fn t_kind(t: ty::t) -> kind {\n+        ret if ty::type_is_fp(t) { float }\n+        else if ty::type_is_unsafe_ptr(t) { pointer }\n+        else if ty::type_is_integral(t) { integral }\n+        else if ty::type_is_enum(t) { enum_ }\n+        else { other };\n+    }\n+    let k_in = t_kind(t_in);\n+    let k_out = t_kind(t_out);\n+    let s_in = k_in == integral && ty::type_is_signed(t_in);\n \n     let newval =\n         alt {in: k_in, out: k_out} {\n@@ -2942,7 +2889,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n             } else { UIToFP(e_res.bcx, e_res.val, ll_t_out) }\n           }\n           {in: float, out: integral} {\n-            if ty::type_is_signed(ccx.tcx, t_out) {\n+            if ty::type_is_signed(t_out) {\n                 FPToSI(e_res.bcx, e_res.val, ll_t_out)\n             } else { FPToUI(e_res.bcx, e_res.val, ll_t_out) }\n           }\n@@ -2979,7 +2926,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n    result {\n     let ccx = bcx_ccx(cx);\n     let e_ty = expr_ty(cx, e);\n-    let is_bot = ty::type_is_bot(ccx.tcx, e_ty);\n+    let is_bot = ty::type_is_bot(e_ty);\n     let lv = trans_temp_lval(cx, e);\n     let bcx = lv.bcx;\n     let val = lv.val;\n@@ -2991,7 +2938,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n     } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n-        let copied = false, imm = ty::type_is_immediate(ccx.tcx, e_ty);\n+        let copied = false, imm = ty::type_is_immediate(e_ty);\n         if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n@@ -3013,7 +2960,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         let last_use = ccx.last_uses.contains_key(e.id);\n         bcx = cx;\n         if lv.kind == temporary { revoke_clean(bcx, val); }\n-        if lv.kind == owned || !ty::type_is_immediate(ccx.tcx, e_ty) {\n+        if lv.kind == owned || !ty::type_is_immediate(e_ty) {\n             bcx = memmove_ty(bcx, alloc, val, e_ty);\n             if last_use && ty::type_needs_drop(ccx.tcx, e_ty) {\n                 bcx = zero_alloca(bcx, val, e_ty);\n@@ -3023,13 +2970,13 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n         if lv.kind != temporary && !last_use {\n             bcx = take_ty(bcx, val, e_ty);\n         }\n-    } else if ty::type_is_immediate(ccx.tcx, e_ty) && lv.kind != owned {\n+    } else if ty::type_is_immediate(e_ty) && lv.kind != owned {\n         let r = do_spill(bcx, val, e_ty);\n         val = r.val;\n         bcx = r.bcx;\n     }\n \n-    if !is_bot && ty::type_contains_params(ccx.tcx, arg.ty) {\n+    if !is_bot && ty::type_has_params(arg.ty) {\n         val = PointerCast(bcx, val, lldestty);\n     }\n \n@@ -3060,17 +3007,16 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n        to_zero: [{v: ValueRef, t: ty::t}],\n        to_revoke: [{v: ValueRef, t: ty::t}]} {\n \n-    let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n+    let args = ty::ty_fn_args(fn_ty);\n     let llargs: [ValueRef] = [];\n     let lltydescs: [ValueRef] = [];\n     let to_zero = [];\n     let to_revoke = [];\n \n     let ccx = bcx_ccx(cx);\n-    let tcx = ccx.tcx;\n     let bcx = cx;\n \n-    let retty = ty::ty_fn_ret(tcx, fn_ty), full_retty = retty;\n+    let retty = ty::ty_fn_ret(fn_ty), full_retty = retty;\n     alt gen {\n       some(g) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, g);\n@@ -3091,15 +3037,15 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n             }\n             i += 1u;\n         }\n-        args = ty::ty_fn_args(tcx, g.item_type);\n-        retty = ty::ty_fn_ret(tcx, g.item_type);\n+        args = ty::ty_fn_args(g.item_type);\n+        retty = ty::ty_fn_ret(g.item_type);\n       }\n       _ { }\n     }\n     // Arg 0: Output pointer.\n     let llretslot = alt dest {\n       ignore {\n-        if ty::type_is_nil(tcx, retty) {\n+        if ty::type_is_nil(retty) {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n         } else {\n             let {bcx: cx, val} = alloc_ty(bcx, full_retty);\n@@ -3115,13 +3061,12 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n       }\n     };\n \n-    if ty::type_contains_params(tcx, retty) {\n+    if ty::type_has_params(retty) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-        check non_ty_var(ccx, retty);\n         let llretty = T_ptr(type_of_inner(ccx, retty));\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n@@ -3225,7 +3170,7 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n \n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n-    if bcx.unreachable || ty::type_is_bot(tcx, ret_ty) {\n+    if bcx.unreachable || ty::type_is_bot(ret_ty) {\n         Unreachable(next_cx);\n     }\n     Br(bcx, next_cx.llbb);\n@@ -3363,7 +3308,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n-        let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n+        let dst = GEP_tup_like(bcx, t, addr, [0, i]);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n         add_clean_temp_mem(bcx, dst.val, e_ty);\n@@ -3390,15 +3335,16 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n       _ { bcx_tcx(bcx).sess.bug(\"trans_rec: weird dest\"); }\n     };\n \n-    let ty_fields = alt ty::struct(bcx_tcx(bcx), t) { ty::ty_rec(f) { f }\n+    let ty_fields = alt ty::get(t).struct {\n+      ty::ty_rec(f) { f }\n       _ { bcx_tcx(bcx).sess.bug(\"trans_rec: id doesn't\\\n            have a record type\") } };\n     let temp_cleanups = [];\n     for fld in fields {\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n         }));\n-        let dst = GEP_tup_like_1(bcx, t, addr, [0, ix as int]);\n+        let dst = GEP_tup_like(bcx, t, addr, [0, ix as int]);\n         bcx = trans_expr_save_in(dst.bcx, fld.node.expr, dst.val);\n         add_clean_temp_mem(bcx, dst.val, ty_fields[ix].mt.ty);\n         temp_cleanups += [dst.val];\n@@ -3410,8 +3356,8 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         // Copy over inherited fields\n         for tf in ty_fields {\n             if !vec::any(fields, {|f| str::eq(f.node.ident, tf.ident)}) {\n-                let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n-                let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n+                let dst = GEP_tup_like(bcx, t, addr, [0, i]);\n+                let base = GEP_tup_like(bcx, t, base_val, [0, i]);\n                 let val = load_if_immediate(base.bcx, base.val, tf.mt.ty);\n                 bcx = copy_val(base.bcx, INIT, dst.val, val, tf.mt.ty);\n             }\n@@ -3431,8 +3377,8 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n // that nil or bot expressions get ignore rather than save_in as destination.\n fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n     -> @block_ctxt {\n-    let tcx = bcx_tcx(bcx), t = expr_ty(bcx, e);\n-    let do_ignore = ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t);\n+    let t = expr_ty(bcx, e);\n+    let do_ignore = ty::type_is_bot(t) || ty::type_is_nil(t);\n     ret trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n }\n \n@@ -3446,12 +3392,11 @@ fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     if expr_is_lval(bcx, e) {\n         ret trans_lval(bcx, e);\n     } else {\n-        let tcx = bcx_tcx(bcx);\n         let ty = expr_ty(bcx, e);\n-        if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n+        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n             bcx = trans_expr(bcx, e, ignore);\n             ret {bcx: bcx, val: C_nil(), kind: temporary};\n-        } else if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n+        } else if ty::type_is_immediate(ty) {\n             let cell = empty_dest_cell();\n             bcx = trans_expr(bcx, e, by_val(cell));\n             add_clean_temp(bcx, *cell, ty);\n@@ -3525,7 +3470,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n             bcx, proto, decl, body, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n-        alt ty::struct(tcx, expr_ty(bcx, e)) {\n+        alt ty::get(expr_ty(bcx, e)).struct {\n           ty::ty_fn({proto, _}) {\n             #debug(\"translating fn_block %s with type %s\",\n                    expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n@@ -3708,7 +3653,7 @@ fn do_spill(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     // We have a value but we have to spill it, and root it, to pass by alias.\n     let bcx = cx;\n \n-    if ty::type_is_bot(bcx_tcx(bcx), t) {\n+    if ty::type_is_bot(t) {\n         ret rslt(bcx, C_null(T_ptr(T_i8())));\n     }\n \n@@ -3730,18 +3675,18 @@ fn do_spill_noroot(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n }\n \n fn spill_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n-    if ty::type_is_immediate(bcx_tcx(cx), t) { ret do_spill(cx, v, t); }\n+    if ty::type_is_immediate(t) { ret do_spill(cx, v, t); }\n     ret rslt(cx, v);\n }\n \n fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n-    if ty::type_is_immediate(bcx_tcx(cx), t) { ret Load(cx, v); }\n+    if ty::type_is_immediate(t) { ret Load(cx, v); }\n     ret v;\n }\n \n fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n-    let ccx = bcx_ccx(cx), tcx = ccx.tcx;\n-    if ty::type_is_bot(tcx, expr_ty(cx, lvl)) {\n+    let ccx = bcx_ccx(cx);\n+    if ty::type_is_bot(expr_ty(cx, lvl)) {\n        ret trans_expr(cx, lvl, ignore);\n     }\n \n@@ -3819,12 +3764,12 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option<span>,\n         let e_ty = expr_ty(bcx, expr);\n         bcx = expr_res.bcx;\n \n-        if ty::type_is_str(tcx, e_ty) {\n+        if ty::type_is_str(e_ty) {\n             let data = tvec::get_dataptr(\n                 bcx, expr_res.val, type_of_or_i8(\n                     bcx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n             ret trans_fail_value(bcx, sp_opt, data);\n-        } else if bcx.unreachable || ty::type_is_bot(tcx, e_ty) {\n+        } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;\n         } else {\n             bcx_ccx(bcx).sess.span_bug(\n@@ -4246,7 +4191,7 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     if is_simple && !ccx.mut_map.contains_key(local.node.pat.id) &&\n        !ccx.last_uses.contains_key(local.node.pat.id) &&\n-       ty::type_is_immediate(ccx.tcx, t) {\n+       ty::type_is_immediate(t) {\n         alt local.node.init {\n           some({op: ast::init_assign, _}) { ret cx; }\n           _ {}\n@@ -4281,7 +4226,7 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     }\n     alt b.node.expr {\n       some(e) {\n-        let bt = ty::type_is_bot(bcx_tcx(bcx), expr_ty(bcx, e));\n+        let bt = ty::type_is_bot(expr_ty(bcx, e));\n         debuginfo::update_source_pos(bcx, e.span);\n         bcx = trans_expr(bcx, e, if bt { ignore } else { dest });\n       }\n@@ -4431,7 +4376,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n           ast::by_mut_ref { }\n           ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n           ast::by_val {\n-            if !ty::type_is_immediate(bcx_tcx(bcx), arg.ty) {\n+            if !ty::type_is_immediate(arg.ty) {\n                 let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n                 bcx = cx;\n                 Store(bcx, argval, alloc);\n@@ -4453,7 +4398,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n // cries out for a precondition\n fn arg_tys_of_fn(ccx: @crate_ctxt, id: ast::node_id) -> [ty::arg] {\n     let tt = ty::node_id_to_type(ccx.tcx, id);\n-    alt ty::struct(ccx.tcx, tt) {\n+    alt ty::get(tt).struct {\n       ty::ty_fn({inputs, _}) { inputs }\n       _ { ccx.sess.bug(#fmt(\"arg_tys_of_fn called on non-function\\\n             type %s\", ty_to_str(ccx.tcx, tt)));}\n@@ -4506,8 +4451,8 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n     if option::is_none(body.node.expr) ||\n-       ty::type_is_bot(ccx.tcx, block_ty) ||\n-       ty::type_is_nil(ccx.tcx, block_ty) {\n+       ty::type_is_bot(block_ty) ||\n+       ty::type_is_nil(block_ty) {\n         bcx = trans_block(bcx, body);\n     } else {\n         bcx = trans_block_dps(bcx, body, save_in(fcx.llretptr));\n@@ -4561,11 +4506,8 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n         llretptr = BitCast(bcx, llretptr, llret_t);\n     }\n \n-    // FIXME: silly checks\n-    check type_is_tup_like(bcx, tup_t);\n     let {bcx, val: dst} = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n     bcx = memmove_ty(bcx, dst, arg, arg_t);\n-    check type_is_tup_like(bcx, tup_t);\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n     // FIXME #1184: Resource flag is larger than necessary\n@@ -4640,7 +4582,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n           _ { bcx_tcx(bcx).sess.span_fatal(variant.span, \"Someone forgot\\\n                 to document an invariant in trans_tag_variant\"); } };\n         let arg_ty = arg_tys[i].ty;\n-        if ty::type_contains_params(bcx_tcx(bcx), arg_ty) {\n+        if ty::type_has_params(arg_ty) {\n             lldestptr = PointerCast(bcx, lldestptr, val_ty(llarg));\n         }\n         bcx = memmove_ty(bcx, lldestptr, llarg, arg_ty);\n@@ -4663,8 +4605,8 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         /* Neither type is bottom, and we expect them to be unified already,\n          * so the following is safe. */\n         let ty = ty::expr_ty(cx.tcx, e1);\n-        let is_float = ty::type_is_fp(ccx_tcx(cx), ty);\n-        let signed = ty::type_is_signed(ccx_tcx(cx), ty);\n+        let is_float = ty::type_is_fp(ty);\n+        let signed = ty::type_is_signed(ty);\n         ret alt b {\n           ast::add    {\n             if is_float { llvm::LLVMConstFAdd(te1, te2) }\n@@ -4707,7 +4649,7 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       ast::expr_unary(u, e) {\n         let te = trans_const_expr(cx, e);\n         let ty = ty::expr_ty(cx.tcx, e);\n-        let is_float = ty::type_is_fp(ccx_tcx(cx), ty);\n+        let is_float = ty::type_is_fp(ty);\n         ret alt u {\n           ast::box(_)  |\n           ast::uniq(_) |\n@@ -4751,18 +4693,15 @@ type c_stack_tys = {\n \n fn c_stack_tys(ccx: @crate_ctxt,\n                id: ast::node_id) -> @c_stack_tys {\n-    alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n+    alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n-        let tcx = ccx.tcx;\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n-        check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n         let llretty = type_of_inner(ccx, ret_ty);\n         let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n         ret @{\n             arg_tys: llargtys,\n             ret_ty: llretty,\n-            ret_def: !ty::type_is_bot(tcx, ret_ty) &&\n-                !ty::type_is_nil(tcx, ret_ty),\n+            ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n             base_fn_ty: T_fn(llargtys, llretty),\n             bundle_ty: bundle_ty,\n             shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n@@ -5028,7 +4967,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n     let main_takes_argv =\n         // invariant!\n-        alt ty::struct(ccx.tcx, main_node_type) {\n+        alt ty::get(main_node_type).struct {\n           ty::ty_fn({inputs, _}) { vec::len(inputs) != 0u }\n           _ { ccx.sess.span_fatal(sp, \"main has a non-function type\"); }\n         };\n@@ -5140,7 +5079,7 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n                           param_bounds: [ty::param_bounds],\n                           x: ty::t) -> TypeRef {\n-    alt ty::struct(cx.tcx, x) {\n+    alt ty::get(x).struct {\n       ty::ty_fn({inputs: args, output: out, _}) {\n         ret type_of_fn(cx, args, out, param_bounds);\n       }\n@@ -5316,7 +5255,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_iface(_, _) {\n         if !vec::any(*ty::iface_methods(ccx.tcx, local_def(it.id)), {|m|\n-            ty::type_contains_vars(ccx.tcx, ty::mk_fn(ccx.tcx, m.fty))}) {\n+            ty::type_has_vars(ty::mk_fn(ccx.tcx, m.fty))}) {\n             impl::trans_iface_vtable(ccx, item_path(ccx, it), it);\n         }\n       }"}, {"sha": "49a202585cd852d19537f93a4acb63602e7db1a7", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -202,7 +202,6 @@ fn allocate_cbox(bcx: @block_ctxt,\n       }\n       ty::ck_uniq {\n         let uniq_cbox_ty = mk_tuplified_uniq_cbox_ty(tcx, cdata_ty);\n-        check uniq::type_is_unique_box(bcx, uniq_cbox_ty);\n         let {bcx, val: box} = uniq::alloc_uniq(bcx, uniq_cbox_ty);\n         nuke_ref_count(bcx, box);\n         let bcx = store_uniq_tydesc(bcx, cdata_ty, box, ti);\n@@ -279,7 +278,6 @@ fn store_environment(\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     let llbox = cast_if_we_can(bcx, llbox, cboxptr_ty);\n-    check type_is_tup_like(bcx, cbox_ty);\n \n     // If necessary, copy tydescs describing type parameters into the\n     // appropriate slot in the closure.\n@@ -308,11 +306,9 @@ fn store_environment(\n                                   ev_to_str(ccx, bv)));\n         }\n \n-        let bound_data = GEP_tup_like_1(bcx, cbox_ty, llbox,\n-                                        [0,\n-                                         abi::box_field_body,\n-                                         abi::closure_body_bindings,\n-                                         i as int]);\n+        let bound_data = GEP_tup_like(bcx, cbox_ty, llbox,\n+                                      [0, abi::box_field_body,\n+                                       abi::closure_body_bindings, i as int]);\n         bcx = bound_data.bcx;\n         let bound_data = bound_data.val;\n         alt bv {\n@@ -404,7 +400,6 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    check type_is_tup_like(bcx, cdata_ty);\n     let {bcx, val: lltydescs} = GEP_tup_like(bcx, cdata_ty, llcdata,\n                                             [0, abi::closure_body_ty_params]);\n     let off = 0;\n@@ -429,7 +424,6 @@ fn load_environment(enclosing_cx: @block_ctxt,\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n-            check type_is_tup_like(bcx, cdata_ty);\n             let upvarptr =\n                 GEP_tup_like(bcx, cdata_ty, llcdata,\n                              [0, abi::closure_body_bindings, i as int]);\n@@ -612,7 +606,7 @@ fn make_fn_glue(\n         }\n     };\n \n-    ret alt ty::struct(tcx, t) {\n+    ret alt ty::get(t).struct {\n       ty::ty_fn({proto: ast::proto_bare, _}) |\n       ty::ty_fn({proto: ast::proto_block, _}) |\n       ty::ty_fn({proto: ast::proto_any, _}) { bcx }\n@@ -742,7 +736,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // If we supported constraints on record fields, we could make the\n     // constraints for this function:\n     /*\n-    : returns_non_ty_var(ccx, outgoing_fty),\n+    : returns_non_ty_var(outgoing_fty),\n       type_has_static_size(ccx, incoming_fty) ->\n     */\n     // but since we don't, we have to do the checks at the beginning.\n@@ -811,8 +805,6 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n         (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n       }\n       none {\n-        // Silly check\n-        check type_is_tup_like(bcx, cdata_ty);\n         let {bcx: cx, val: pair} =\n             GEP_tup_like(bcx, cdata_ty, llcdata,\n                          [0, abi::closure_body_bindings, 0]);\n@@ -830,16 +822,15 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n \n     // Get f's return type, which will also be the return type of the entire\n     // bind expression.\n-    let outgoing_ret_ty = ty::ty_fn_ret(ccx.tcx, outgoing_fty);\n+    let outgoing_ret_ty = ty::ty_fn_ret(outgoing_fty);\n \n     // Get the types of the arguments to f.\n-    let outgoing_args = ty::ty_fn_args(ccx.tcx, outgoing_fty);\n+    let outgoing_args = ty::ty_fn_args(outgoing_fty);\n \n     // The 'llretptr' that will arrive in the thunk we're creating also needs\n     // to be the correct type.  Cast it to f's return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n-        check non_ty_var(ccx, outgoing_ret_ty);\n+    if ty::type_has_params(outgoing_ret_ty) {\n         let llretty = type_of_inner(ccx, outgoing_ret_ty);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n@@ -848,7 +839,6 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    check type_is_tup_like(l_bcx, cdata_ty);\n     let {bcx: l_bcx, val: param_record} =\n         GEP_tup_like(l_bcx, cdata_ty, llcdata,\n                      [0, abi::closure_body_ty_params]);\n@@ -888,8 +878,6 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n-            // Silly check\n-            check type_is_tup_like(bcx, cdata_ty);\n             let bound_arg =\n                 GEP_tup_like(bcx, cdata_ty, llcdata,\n                              [0, abi::closure_body_bindings, b]);\n@@ -911,7 +899,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n \n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n-            if ty::type_contains_params(ccx.tcx, out_arg.ty) {\n+            if ty::type_has_params(out_arg.ty) {\n                 val = PointerCast(bcx, val, llout_arg_ty);\n             }\n             llargs += [val];\n@@ -921,7 +909,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n           // Arg will be provided when the thunk is invoked.\n           none {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a as c_uint);\n-            if ty::type_contains_params(ccx.tcx, out_arg.ty) {\n+            if ty::type_has_params(out_arg.ty) {\n                 arg = PointerCast(bcx, arg, llout_arg_ty);\n             }\n             llargs += [arg];"}, {"sha": "32a4509da204d013fd46e90d4a5bbb56dfe4580d", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -234,7 +234,7 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n     fn do_drop(bcx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n        @block_ctxt {\n-        if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n+        if ty::type_is_immediate(ty) {\n             ret base::drop_ty_immediate(bcx, val, ty);\n         } else {\n             ret drop_ty(bcx, val, ty);\n@@ -298,8 +298,6 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n \n     let param_bounds = ty::lookup_item_type(ccx.tcx, did).bounds;\n     let nil_res = ty::mk_nil(ccx.tcx);\n-    // FIXME: Silly check -- mk_nil should have a postcondition\n-    check non_ty_var(ccx, nil_res);\n     let fn_mode = ast::expl(ast::by_ref);\n     let f_t = type_of_fn(ccx, [{mode: fn_mode, ty: inner_t}],\n                          nil_res, *param_bounds);\n@@ -856,23 +854,6 @@ pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }\n \n-pure fn non_ty_var(cx: @crate_ctxt, t: ty::t) -> bool {\n-    let st = ty::struct(cx.tcx, t);\n-    alt st {\n-      ty::ty_var(_) { false }\n-      _          { true }\n-    }\n-}\n-\n-pure fn returns_non_ty_var(cx: @crate_ctxt, t: ty::t) -> bool {\n-    non_ty_var(cx, ty::ty_fn_ret(cx.tcx, t))\n-}\n-\n-pure fn type_is_tup_like(cx: @block_ctxt, t: ty::t) -> bool {\n-    let tcx = bcx_tcx(cx);\n-    ty::type_is_tup_like(tcx, t)\n-}\n-\n // Used to identify cached dictionaries\n enum dict_param {\n     dict_param_dict(dict_id),\n@@ -885,7 +866,7 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n         h = h << 2u;\n         alt param {\n           dict_param_dict(d) { h += hash_dict_id(d); }\n-          dict_param_ty(t) { h += t; }\n+          dict_param_ty(t) { h += ty::type_id(t); }\n         }\n     }\n     h\n@@ -896,7 +877,7 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: [dict_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let h = syntax::ast_util::hash_def_id(mi.def);\n-    for ty in mi.substs { h = (h << 2u) + ty; }\n+    for ty in mi.substs { h = (h << 2u) + ty::type_id(ty); }\n     for dict in mi.dicts { h = (h << 2u) + hash_dict_id(dict); }\n     h\n }"}, {"sha": "872bcb6118de981b9f20c53b97a3a3016437548f", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -113,7 +113,7 @@ fn trans_vtable_callee(bcx: @block_ctxt, self: ValueRef, dict: ValueRef,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n     let generic = none;\n-    if vec::len(*method.tps) > 0u || ty::type_contains_params(tcx, fty) {\n+    if vec::len(*method.tps) > 0u || ty::type_has_params(fty) {\n         let tydescs = [], tis = [];\n         let tptys = ty::node_id_to_type_params(tcx, callee_id);\n         for t in vec::tail_n(tptys, vec::len(tptys) - vec::len(*method.tps)) {\n@@ -147,15 +147,14 @@ fn trans_param_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       base: @ast::expr, n_method: uint)\n     -> lval_maybe_callee {\n-    let tcx = bcx_tcx(bcx);\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let box_body = GEPi(bcx, val, [0, abi::box_field_body]);\n     let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, box_body, [0, 1]),\n                                      T_ptr(T_ptr(T_dict()))));\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = PointerCast(bcx, GEPi(bcx, box_body, [0, 2]),\n                            T_opaque_cbox_ptr(bcx_ccx(bcx)));\n-    let iface_id = alt ty::struct(tcx, expr_ty(bcx, base)) {\n+    let iface_id = alt ty::get(expr_ty(bcx, base)).struct {\n         ty::ty_iface(did, _) { did }\n         // precondition\n         _ { bcx_tcx(bcx).sess.span_bug(base.span, \"base has non-iface type \\\n@@ -310,7 +309,7 @@ fn trans_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n fn dict_is_static(tcx: ty::ctxt, origin: typeck::dict_origin) -> bool {\n     alt origin {\n       typeck::dict_static(_, ts, origs) {\n-        vec::all(ts, {|t| !ty::type_contains_params(tcx, t)}) &&\n+        vec::all(ts, {|t| !ty::type_has_params(t)}) &&\n         vec::all(*origs, {|o| dict_is_static(tcx, o)})\n       }\n       typeck::dict_iface(_) { true }"}, {"sha": "db78b1c762b4efe913ab175688fd8e1829bd6b55", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -157,7 +157,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n             (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n              PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)))\n         };\n-    let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n+    let strings = alt ty::get(vec_ty).struct {\n       ty::ty_str { true }\n       ty::ty_vec(_) { false }\n       _ {\n@@ -233,7 +233,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef, dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n-    let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n+    let strings = alt ty::get(vec_ty).struct {\n       ty::ty_str { true }\n       _ { false }\n     };"}, {"sha": "320965c52490045f76638b576a12f273b7edd101", "filename": "src/comp/middle/trans/uniq.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Funiq.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -14,36 +14,26 @@ import base::{\n };\n import shape::{size_of};\n \n-export trans_uniq, make_free_glue, type_is_unique_box, autoderef, duplicate,\n-       alloc_uniq;\n-\n-pure fn type_is_unique_box(bcx: @block_ctxt, ty: ty::t) -> bool {\n-    ty::type_is_unique_box(bcx_tcx(bcx), ty)\n-}\n+export trans_uniq, make_free_glue, autoderef, duplicate, alloc_uniq;\n \n fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n               node_id: ast::node_id, dest: dest) -> @block_ctxt {\n     let uniq_ty = node_id_type(bcx, node_id);\n-    check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n     bcx = base::trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n     ret base::store_in_dest(bcx, llptr, dest);\n }\n \n-fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n-    : type_is_unique_box(cx, uniq_ty) -> result {\n-\n+fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t) -> result {\n     let bcx = cx;\n-    let contents_ty = content_ty(bcx, uniq_ty);\n+    let contents_ty = content_ty(uniq_ty);\n     let r = size_of(bcx, contents_ty);\n     bcx = r.bcx;\n     let llsz = r.val;\n \n-    let ccx = bcx_ccx(bcx);\n-    check non_ty_var(ccx, contents_ty);\n-    let llptrty = T_ptr(type_of_inner(ccx, contents_ty));\n+    let llptrty = T_ptr(type_of_inner(bcx_ccx(bcx), contents_ty));\n \n     r = trans_shared_malloc(bcx, llptrty, llsz);\n     bcx = r.bcx;\n@@ -53,41 +43,34 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n }\n \n fn make_free_glue(cx: @block_ctxt, vptr: ValueRef, t: ty::t)\n-    : type_is_unique_box(cx, t) -> @block_ctxt {\n-\n+    -> @block_ctxt {\n     let bcx = cx;\n     let free_cx = new_sub_block_ctxt(bcx, \"uniq_free\");\n     let next_cx = new_sub_block_ctxt(bcx, \"uniq_free_next\");\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, free_cx.llbb);\n \n     let bcx = free_cx;\n-    let bcx = drop_ty(bcx, vptr, content_ty(cx, t));\n+    let bcx = drop_ty(bcx, vptr, content_ty(t));\n     let bcx = trans_shared_free(bcx, vptr);\n     Br(bcx, next_cx.llbb);\n     next_cx\n }\n \n-fn content_ty(bcx: @block_ctxt, t: ty::t)\n-    : type_is_unique_box(bcx, t) -> ty::t {\n-\n-    alt ty::struct(bcx_tcx(bcx), t) {\n+fn content_ty(t: ty::t) -> ty::t {\n+    alt ty::get(t).struct {\n       ty::ty_uniq({ty: ct, _}) { ct }\n       _ { std::util::unreachable(); }\n     }\n }\n \n-fn autoderef(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n-    : type_is_unique_box(bcx, t) -> {v: ValueRef, t: ty::t} {\n-\n-    let content_ty = content_ty(bcx, t);\n+fn autoderef(v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n+    let content_ty = content_ty(t);\n     ret {v: v, t: content_ty};\n }\n \n-fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t)\n-    : type_is_unique_box(bcx, t) -> result {\n-\n-    let content_ty = content_ty(bcx, t);\n+fn duplicate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n+    let content_ty = content_ty(t);\n     let {bcx, val: llptr} = alloc_uniq(bcx, t);\n \n     let src = load_if_immediate(bcx, v, content_ty);"}, {"sha": "f98b2d0a59591aaecbfe4fbed9ccd2a1cbfe0995", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -492,14 +492,14 @@ fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> ret_style {\n-    alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id)) {\n+    alt ty::get(ty::node_id_to_type(ccx.tcx, e.id)).struct {\n       ty::ty_fn(f) { ret f.ret_style; }\n       _ { ret return_val; }\n     }\n }\n \n fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr] {\n-    alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n+    alt ty::get(ty::node_id_to_type(cx, e.id)).struct {\n       ty::ty_fn(f) { ret f.constraints; }\n       _ { ret []; }\n     }\n@@ -1071,10 +1071,9 @@ fn locals_to_bindings(tcx: ty::ctxt,\n }\n \n fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n-    let ty =\n-        ty::type_autoderef(fcx.ccx.tcx,\n-                           ty::node_id_to_type(fcx.ccx.tcx, callee));\n-    alt ty::struct(fcx.ccx.tcx, ty) {\n+    let ty = ty::type_autoderef(fcx.ccx.tcx,\n+                                ty::node_id_to_type(fcx.ccx.tcx, callee));\n+    alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n         let modes = [];\n         for arg: ty::arg in args { modes += [arg.mode]; }"}, {"sha": "323605b3d51d86588a9f5154035686fec5dce800", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -113,7 +113,7 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f_body);\n     if !promises(fcx, post, fcx.enclosing.i_return) &&\n-       !type_is_nil(fcx.ccx.tcx, ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n+       !type_is_nil(ret_ty_of_fn(fcx.ccx.tcx, id)) &&\n        f_decl.cf == return_val {\n         fcx.ccx.tcx.sess.span_err(f_body.span,\n                                   \"In function \" + fcx.name +"}, {"sha": "854617cea0a54df2f8bb48a4735fc8152b10b887", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -758,7 +758,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n         // We don't want to clear the diverges bit for bottom typed things,\n         // which really do diverge. I feel like there is a cleaner way\n         // to do this than checking the type.\n-        if !type_is_bot(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, tailexpr)) {\n+        if !type_is_bot(expr_ty(fcx.ccx.tcx, tailexpr)) {\n             let post = false_postcond(num_constrs);\n             // except for the \"diverges\" bit...\n             kill_poststate_(fcx, fcx.enclosing.i_diverge, post);"}, {"sha": "01ce126e267267333824d39f9d820802e0a01993", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 336, "deletions": 519, "changes": 855, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -16,7 +16,6 @@ import syntax::ast_util;\n import syntax::codemap::span;\n import metadata::csearch;\n import util::common::*;\n-import syntax::util::interner;\n import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n import syntax::print::pprust::*;\n@@ -44,7 +43,6 @@ export get_field;\n export get_fields;\n export fm_general;\n export get_element_type;\n-export idx_nil;\n export is_binopable;\n export is_pred_ty;\n export lookup_item_type;\n@@ -83,14 +81,11 @@ export mk_var;\n export mk_self;\n export mk_opaque_closure_ptr;\n export mk_named;\n-export gen_ty;\n export mt;\n export node_type_table;\n export pat_ty;\n export ret_ty_of_fn;\n export sequence_element_type;\n-export struct, struct_raw;\n-export ty_name;\n export sort_methods;\n export stmt_node_id;\n export sty;\n@@ -128,13 +123,11 @@ export ty_uint;\n export ty_uniq;\n export ty_var;\n export ty_self;\n-export ty_named;\n+export get, type_has_params, type_has_vars, type_name, type_id;\n export same_type;\n export ty_var_id;\n export ty_fn_args;\n export type_constr;\n-export type_contains_params;\n-export type_contains_vars;\n export kind, kind_sendable, kind_copyable, kind_noncopyable;\n export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n export type_err;\n@@ -205,10 +198,11 @@ type mt = {ty: t, mut: ast::mutability};\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, ty::t>;\n+type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, t>;\n \n type ctxt =\n-    @{ts: @type_store,\n+    @{interner: hashmap<{struct: sty, name: option<str>}, t_box>,\n+      mutable next_id: uint,\n       sess: session::session,\n       def_map: resolve::def_map,\n       node_types: node_type_table,\n@@ -226,15 +220,31 @@ type ctxt =\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n       inferred_modes: hashmap<ast::node_id, ast::mode>};\n \n-type ty_ctxt = ctxt;\n+type t_box = @{struct: sty,\n+               id: uint,\n+               has_params: bool,\n+               has_vars: bool,\n+               name: option<str>};\n \n-// Never construct these manually. These are interned.\n-type raw_t = {struct: sty,\n-              hash: uint,\n-              has_params: bool,\n-              has_vars: bool};\n+// To reduce refcounting cost, we're representing types as unsafe pointers\n+// throughout the compiler. These are simply casted t_box values. Use ty::get\n+// to cast them back to a box. (Without the cast, compiler performance suffers\n+// ~15%.) This does mean that a t value relies on the ctxt to keep its box\n+// alive, and using ty::get is unsafe when the ctxt is no longer alive.\n+enum t_opaque {}\n+type t = *t_opaque;\n \n-type t = uint;\n+pure fn get(t: t) -> t_box unsafe {\n+    let t2 = unsafe::reinterpret_cast::<t, t_box>(t);\n+    let t3 = t2;\n+    unsafe::leak(t2);\n+    t3\n+}\n+\n+fn type_has_params(t: t) -> bool { get(t).has_params }\n+fn type_has_vars(t: t) -> bool { get(t).has_vars }\n+fn type_name(t: t) -> option<str> { get(t).name }\n+fn type_id(t: t) -> uint { get(t).id }\n \n enum closure_kind {\n     ck_block,\n@@ -277,7 +287,6 @@ enum sty {\n     ty_send_type, // type_desc* that has been cloned into exchange heap\n     ty_constr(t, [@type_constr]),\n     ty_opaque_closure_ptr(closure_kind), // ptr to env for fn, fn@, fn~\n-    ty_named(t, @str),\n }\n \n // In the middle end, constraints have a def_id attached, referring\n@@ -326,56 +335,8 @@ type ty_param_bounds_and_ty = {bounds: @[param_bounds], ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n \n-const idx_nil: uint = 0u;\n-const idx_bool: uint = 1u;\n-const idx_int: uint = 2u;\n-const idx_float: uint = 3u;\n-const idx_uint: uint = 4u;\n-const idx_i8: uint = 5u;\n-const idx_i16: uint = 6u;\n-const idx_i32: uint = 7u;\n-const idx_i64: uint = 8u;\n-const idx_u8: uint = 9u;\n-const idx_u16: uint = 10u;\n-const idx_u32: uint = 11u;\n-const idx_u64: uint = 12u;\n-const idx_f32: uint = 13u;\n-const idx_f64: uint = 14u;\n-const idx_char: uint = 15u;\n-const idx_str: uint = 16u;\n-const idx_type: uint = 17u;\n-const idx_send_type: uint = 18u;\n-const idx_bot: uint = 19u;\n-const idx_first_others: uint = 20u;\n-\n-type type_store = interner::interner<@raw_t>;\n-\n type node_type_table = @smallintmap::smallintmap<t>;\n \n-fn populate_type_store(cx: ctxt) {\n-    intern(cx, ty_nil);\n-    intern(cx, ty_bool);\n-    intern(cx, ty_int(ast::ty_i));\n-    intern(cx, ty_float(ast::ty_f));\n-    intern(cx, ty_uint(ast::ty_u));\n-    intern(cx, ty_int(ast::ty_i8));\n-    intern(cx, ty_int(ast::ty_i16));\n-    intern(cx, ty_int(ast::ty_i32));\n-    intern(cx, ty_int(ast::ty_i64));\n-    intern(cx, ty_uint(ast::ty_u8));\n-    intern(cx, ty_uint(ast::ty_u16));\n-    intern(cx, ty_uint(ast::ty_u32));\n-    intern(cx, ty_uint(ast::ty_u64));\n-    intern(cx, ty_float(ast::ty_f32));\n-    intern(cx, ty_float(ast::ty_f64));\n-    intern(cx, ty_int(ast::ty_char));\n-    intern(cx, ty_str);\n-    intern(cx, ty_type);\n-    intern(cx, ty_send_type);\n-    intern(cx, ty_bot);\n-    assert (vec::len(cx.ts.vect) == idx_first_others);\n-}\n-\n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n     fn hash_cache_entry(k: val) -> uint {\n@@ -387,263 +348,188 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap(hash_cache_entry, eq_cache_entries);\n }\n \n-fn new_ty_hash<V: copy>() -> map::hashmap<t, V> { map::new_uint_hash() }\n+fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n+    map::mk_hashmap({|&&t: t| type_id(t)},\n+                    {|&&a: t, &&b: t| type_id(a) == type_id(b)})\n+}\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n-    fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n-        ret a.hash == b.hash && a.struct == b.struct;\n-    }\n-    let ts = @interner::mk::<@raw_t>(hash_raw_ty, eq_raw_ty);\n-    let cx =\n-        @{ts: ts,\n-          sess: s,\n-          def_map: dm,\n-          node_types: @smallintmap::mk(),\n-          node_type_substs: map::new_int_hash(),\n-          items: amap,\n-          freevars: freevars,\n-          tcache: new_def_hash(),\n-          rcache: mk_rcache(),\n-          short_names_cache: new_ty_hash(),\n-          needs_drop_cache: new_ty_hash(),\n-          kind_cache: new_ty_hash(),\n-          ast_ty_to_ty_cache:\n-              map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n-          enum_var_cache: new_def_hash(),\n-          iface_method_cache: new_def_hash(),\n-          ty_param_bounds: map::new_int_hash(),\n-          inferred_modes: map::new_int_hash()};\n-    populate_type_store(cx);\n-    ret cx;\n+    let interner = map::mk_hashmap({|&&k: {struct: sty, name: option<str>}|\n+        hash_type_structure(k.struct) + alt k.name {\n+          some(s) { str::hash(s) } _ { 0u }\n+        }\n+    }, {|&&a, &&b| a == b});\n+    @{interner: interner,\n+      mutable next_id: 0u,\n+      sess: s,\n+      def_map: dm,\n+      node_types: @smallintmap::mk(),\n+      node_type_substs: map::new_int_hash(),\n+      items: amap,\n+      freevars: freevars,\n+      tcache: new_def_hash(),\n+      rcache: mk_rcache(),\n+      short_names_cache: new_ty_hash(),\n+      needs_drop_cache: new_ty_hash(),\n+      kind_cache: new_ty_hash(),\n+      ast_ty_to_ty_cache: map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n+      enum_var_cache: new_def_hash(),\n+      iface_method_cache: new_def_hash(),\n+      ty_param_bounds: map::new_int_hash(),\n+      inferred_modes: map::new_int_hash()}\n }\n \n \n // Type constructors\n-fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n-    let h = hash_type_structure(st);\n-    let has_params: bool = false;\n-    let has_vars: bool = false;\n-    fn derive_flags_t(cx: ctxt, &has_params: bool, &has_vars: bool, tt: t) {\n-        let rt = interner::get::<@raw_t>(*cx.ts, tt);\n-        has_params = has_params || rt.has_params;\n-        has_vars = has_vars || rt.has_vars;\n-    }\n-    fn derive_flags_mt(cx: ctxt, &has_params: bool, &has_vars: bool, m: mt) {\n-        derive_flags_t(cx, has_params, has_vars, m.ty);\n-    }\n-    fn derive_flags_arg(cx: ctxt, &has_params: bool, &has_vars: bool,\n-                        a: arg) {\n-        derive_flags_t(cx, has_params, has_vars, a.ty);\n-    }\n-    fn derive_flags_sig(cx: ctxt, &has_params: bool, &has_vars: bool,\n-                        args: [arg], tt: t) {\n-        for a: arg in args { derive_flags_arg(cx, has_params, has_vars, a); }\n-        derive_flags_t(cx, has_params, has_vars, tt);\n+fn mk_t(cx: ctxt, st: sty) -> t { mk_t_named(cx, st, none) }\n+\n+// Interns a type/name combination, stores the resulting box in cx.interner,\n+// and returns the box as cast to an unsafe ptr (see comments for t above).\n+fn mk_t_named(cx: ctxt, st: sty, name: option<str>) -> t {\n+    let key = {struct: st, name: name};\n+    alt cx.interner.find(key) {\n+      some(t) { unsafe { ret unsafe::reinterpret_cast(t); } }\n+      _ {}\n+    }\n+    let has_params = false, has_vars = false;\n+    fn derive_flags(&has_params: bool, &has_vars: bool, tt: t) {\n+        let t = get(tt);\n+        has_params |= t.has_params;\n+        has_vars |= t.has_vars;\n     }\n     alt st {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, tys) | ty_iface(_, tys) {\n-        for tt: t in tys { derive_flags_t(cx, has_params, has_vars, tt); }\n+        for tt in tys { derive_flags(has_params, has_vars, tt); }\n+      }\n+      ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_ptr(m) {\n+        derive_flags(has_params, has_vars, m.ty);\n       }\n-      ty_box(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n-      ty_uniq(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n-      ty_vec(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n-      ty_ptr(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_rec(flds) {\n-        for f: field in flds {\n-            derive_flags_mt(cx, has_params, has_vars, f.mt);\n-        }\n+        for f in flds { derive_flags(has_params, has_vars, f.mt.ty); }\n       }\n       ty_tup(ts) {\n-        for tt in ts { derive_flags_t(cx, has_params, has_vars, tt); }\n+        for tt in ts { derive_flags(has_params, has_vars, tt); }\n       }\n       ty_fn(f) {\n-        derive_flags_sig(cx, has_params, has_vars, f.inputs, f.output);\n+        for a in f.inputs { derive_flags(has_params, has_vars, a.ty); }\n+        derive_flags(has_params, has_vars, f.output);\n       }\n       ty_res(_, tt, tps) {\n-        derive_flags_t(cx, has_params, has_vars, tt);\n-        for tt: t in tps { derive_flags_t(cx, has_params, has_vars, tt); }\n+        derive_flags(has_params, has_vars, tt);\n+        for tt in tps { derive_flags(has_params, has_vars, tt); }\n       }\n-      ty_constr(tt, _) | ty_named(tt, _) {\n-        derive_flags_t(cx, has_params, has_vars, tt);\n+      ty_constr(tt, _) {\n+        derive_flags(has_params, has_vars, tt);\n       }\n     }\n-    ret @{struct: st,\n-          hash: h,\n-          has_params: has_params,\n-          has_vars: has_vars};\n+    let t = @{struct: st,\n+              id: cx.next_id,\n+              has_params: has_params,\n+              has_vars: has_vars,\n+              name: name};\n+    cx.interner.insert(key, t);\n+    cx.next_id += 1u;\n+    unsafe { unsafe::reinterpret_cast(t) }\n }\n \n-fn intern(cx: ctxt, st: sty) {\n-    interner::intern(*cx.ts, mk_raw_ty(cx, st));\n-}\n+fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n \n-// These are private constructors to this module. External users should always\n-// use the mk_foo() functions below.\n-fn gen_ty(cx: ctxt, st: sty) -> t {\n-    let raw_type = mk_raw_ty(cx, st);\n-    ret interner::intern(*cx.ts, raw_type);\n-}\n+fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n \n-fn mk_nil(_cx: ctxt) -> t { ret idx_nil; }\n+fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n \n-fn mk_bot(_cx: ctxt) -> t { ret idx_bot; }\n+fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n \n-fn mk_bool(_cx: ctxt) -> t { ret idx_bool; }\n+fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n \n-fn mk_int(_cx: ctxt) -> t { ret idx_int; }\n+fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n \n-fn mk_float(_cx: ctxt) -> t { ret idx_float; }\n+fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n \n-fn mk_uint(_cx: ctxt) -> t { ret idx_uint; }\n+fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n \n-fn mk_mach_int(_cx: ctxt, tm: ast::int_ty) -> t {\n-    alt tm {\n-      ast::ty_i { ret idx_int; }\n-      ast::ty_char { ret idx_char; }\n-      ast::ty_i8 { ret idx_i8; }\n-      ast::ty_i16 { ret idx_i16; }\n-      ast::ty_i32 { ret idx_i32; }\n-      ast::ty_i64 { ret idx_i64; }\n-    }\n-}\n+fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t { mk_t(cx, ty_float(tm)) }\n \n-fn mk_mach_uint(_cx: ctxt, tm: ast::uint_ty) -> t {\n-    alt tm {\n-      ast::ty_u { ret idx_uint; }\n-      ast::ty_u8 { ret idx_u8; }\n-      ast::ty_u16 { ret idx_u16; }\n-      ast::ty_u32 { ret idx_u32; }\n-      ast::ty_u64 { ret idx_u64; }\n-    }\n-}\n+fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n \n-fn mk_mach_float(_cx: ctxt, tm: ast::float_ty) -> t {\n-    alt tm {\n-      ast::ty_f { ret idx_float; }\n-      ast::ty_f32 { ret idx_f32; }\n-      ast::ty_f64 { ret idx_f64; }\n-    }\n-}\n-\n-\n-fn mk_char(_cx: ctxt) -> t { ret idx_char; }\n-\n-fn mk_str(_cx: ctxt) -> t { ret idx_str; }\n+fn mk_str(cx: ctxt) -> t { mk_t(cx, ty_str) }\n \n fn mk_enum(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n-    ret gen_ty(cx, ty_enum(did, tys));\n+    mk_t(cx, ty_enum(did, tys))\n }\n \n-fn mk_box(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_box(tm)); }\n+fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n-fn mk_uniq(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_uniq(tm)); }\n+fn mk_imm_box(cx: ctxt, ty: t) -> t { mk_box(cx, {ty: ty, mut: ast::imm}) }\n \n-fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n-    ret mk_uniq(cx, {ty: ty, mut: ast::imm});\n-}\n+fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n-fn mk_ptr(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_ptr(tm)); }\n+fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty, mut: ast::imm}) }\n \n-fn mk_imm_box(cx: ctxt, ty: t) -> t {\n-    ret mk_box(cx, {ty: ty, mut: ast::imm});\n-}\n+fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n-    ret mk_ptr(cx, {ty: ty, mut: ast::mut});\n-}\n+fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty, mut: ast::mut}) }\n \n-fn mk_vec(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n+fn mk_vec(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_vec(tm)) }\n \n-fn mk_rec(cx: ctxt, fs: [field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n+fn mk_rec(cx: ctxt, fs: [field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n fn mk_constr(cx: ctxt, t: t, cs: [@type_constr]) -> t {\n-    ret gen_ty(cx, ty_constr(t, cs));\n+    mk_t(cx, ty_constr(t, cs))\n }\n \n-fn mk_tup(cx: ctxt, ts: [t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n+fn mk_tup(cx: ctxt, ts: [t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-fn mk_fn(cx: ctxt, fty: fn_ty) -> t {\n-    ret gen_ty(cx, ty_fn(fty));\n-}\n+fn mk_fn(cx: ctxt, fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n \n fn mk_iface(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n-    ret gen_ty(cx, ty_iface(did, tys));\n+    mk_t(cx, ty_iface(did, tys))\n }\n \n fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n-    ret gen_ty(cx, ty_res(did, inner, tps));\n+    mk_t(cx, ty_res(did, inner, tps))\n }\n \n-fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n+fn mk_var(cx: ctxt, v: int) -> t { mk_t(cx, ty_var(v)) }\n \n-fn mk_self(cx: ctxt, tps: [t]) -> t { ret gen_ty(cx, ty_self(tps)); }\n+fn mk_self(cx: ctxt, tps: [t]) -> t { mk_t(cx, ty_self(tps)) }\n \n-fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n-    ret gen_ty(cx, ty_param(n, k));\n-}\n+fn mk_param(cx: ctxt, n: uint, k: def_id) -> t { mk_t(cx, ty_param(n, k)) }\n \n-fn mk_type(_cx: ctxt) -> t { ret idx_type; }\n+fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-fn mk_send_type(_cx: ctxt) -> t { ret idx_send_type; }\n+fn mk_send_type(cx: ctxt) -> t { mk_t(cx, ty_send_type) }\n \n fn mk_opaque_closure_ptr(cx: ctxt, ck: closure_kind) -> t {\n-    ret gen_ty(cx, ty_opaque_closure_ptr(ck));\n+    mk_t(cx, ty_opaque_closure_ptr(ck))\n }\n \n-fn mk_named(cx: ctxt, base: t, name: @str) -> t {\n-    gen_ty(cx, ty_named(base, name))\n-}\n-\n-// Returns the one-level-deep type structure of the given type.\n-pure fn struct(cx: ctxt, typ: t) -> sty {\n-    alt interner::get(*cx.ts, typ).struct {\n-      ty_named(t, _) { struct(cx, t) }\n-      s { s }\n-    }\n-}\n-\n-pure fn struct_raw(cx: ctxt, typ: t) -> sty {\n-    interner::get(*cx.ts, typ).struct\n-}\n-\n-// Returns struct(cx, typ) but replaces all occurences of platform\n-// dependent primitive types with their machine type equivalent\n-pure fn mach_struct(cx: ctxt, cfg: @session::config, typ: t) -> sty {\n-    alt interner::get(*cx.ts, typ).struct {\n-      ty_named(t, _) { mach_struct(cx, cfg, t) }\n-      s { mach_sty(cfg, s) }\n-    }\n+fn mk_named(cx: ctxt, base: t, name: str) -> t {\n+    mk_t_named(cx, get(base).struct, some(name))\n }\n \n // Converts s to its machine type equivalent\n-pure fn mach_sty(cfg: @session::config, s: sty) -> sty {\n-    alt s {\n+pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n+    alt get(t).struct {\n       ty_int(ast::ty_i) { ty_int(cfg.int_type) }\n       ty_uint(ast::ty_u) { ty_uint(cfg.uint_type) }\n       ty_float(ast::ty_f) { ty_float(cfg.float_type) }\n       s { s }\n     }\n }\n \n-pure fn ty_name(cx: ctxt, typ: t) -> option<@str> {\n-    alt interner::get(*cx.ts, typ).struct {\n-      ty_named(_, n) { some(n) }\n-      _ { none }\n-    }\n-}\n-\n-fn default_arg_mode_for_ty(tcx: ty::ctxt, ty: ty::t) -> ast::rmode {\n-    if ty::type_is_immediate(tcx, ty) { ast::by_val }\n+fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n+    if ty::type_is_immediate(ty) { ast::by_val }\n     else { ast::by_ref }\n }\n \n fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n-    alt struct(cx, ty) {\n+    alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_send_type | ty_type |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n@@ -665,9 +551,6 @@ fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n       }\n       ty_constr(sub, _) { walk_ty(cx, sub, f); }\n       ty_uniq(tm) { walk_ty(cx, tm.ty, f); }\n-      // precondition?\n-      ty_named(_,_) { cx.sess.bug(\"walk_ty: should not see a ty_named \\\n-                        here\"); }\n     }\n     f(ty);\n }\n@@ -681,14 +564,14 @@ enum fold_mode {\n fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     let ty = ty_0;\n \n-    // Fast paths.\n+    let tb = get(ty);\n     alt fld {\n-      fm_var(_) { if !type_contains_vars(cx, ty) { ret ty; } }\n-      fm_param(_) { if !type_contains_params(cx, ty) { ret ty; } }\n+      fm_var(_) { if !tb.has_vars { ret ty; } }\n+      fm_param(_) { if !tb.has_params { ret ty; } }\n       fm_general(_) {/* no fast path */ }\n     }\n \n-    alt interner::get(*cx.ts, ty).struct {\n+    alt tb.struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n       ty_box(tm) {\n@@ -697,9 +580,6 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_uniq(tm) {\n         ty = mk_uniq(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n-      ty_named(t, nm) {\n-        ty = mk_named(cx, fold_ty(cx, fld, t), nm);\n-      }\n       ty_ptr(tm) {\n         ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -765,20 +645,14 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n \n // Type utilities\n \n-fn type_is_nil(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_nil { ret true; } _ { ret false; } }\n-}\n+fn type_is_nil(ty: t) -> bool { get(ty).struct == ty_nil }\n \n-fn type_is_bot(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_bot { ret true; } _ { ret false; } }\n-}\n+fn type_is_bot(ty: t) -> bool { get(ty).struct == ty_bot }\n \n-fn type_is_bool(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_bool { ret true; } _ { ret false; } }\n-}\n+fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n-fn type_is_structural(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_structural(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_rec(_) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n       ty_res(_, _, _) { true }\n       _ { false }\n@@ -789,103 +663,96 @@ fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n     ret kind_can_be_copied(type_kind(cx, ty));\n }\n \n-fn type_is_sequence(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_sequence(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_str { ret true; }\n       ty_vec(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-fn type_is_str(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_str { ret true; } _ { ret false; } }\n-}\n+fn type_is_str(ty: t) -> bool { get(ty).struct == ty_str }\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n-    alt struct(cx, ty) {\n+    alt get(ty).struct {\n       ty_str { ret mk_mach_uint(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n \n-pure fn type_is_tup_like(cx: ctxt, ty: t) -> bool {\n-    let sty = struct(cx, ty);\n-    alt sty {\n+pure fn type_is_tup_like(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_rec(_) | ty_tup(_) { true }\n       _ { false }\n     }\n }\n \n-fn get_element_type(cx: ctxt, ty: t, i: uint) -> t {\n-    alt struct(cx, ty) {\n+fn get_element_type(ty: t, i: uint) -> t {\n+    alt get(ty).struct {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n-      _ {\n-        cx.sess.bug(\n-            #fmt[\"get_element_type called on invalid type %s with index %u\",\n-                 ty_to_str(cx, ty), i]);\n-      }\n+      _ { fail \"get_element_type called on invalid type\"; }\n     }\n }\n \n-pure fn type_is_box(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_box(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_box(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-pure fn type_is_boxed(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_boxed(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_box(_) | ty_iface(_, _) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-pure fn type_is_unique_box(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_unique_box(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_uniq(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-pure fn type_is_unsafe_ptr(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_unsafe_ptr(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_ptr(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-pure fn type_is_vec(cx: ctxt, ty: t) -> bool {\n-    ret alt struct(cx, ty) {\n+pure fn type_is_vec(ty: t) -> bool {\n+    ret alt get(ty).struct {\n           ty_vec(_) { true }\n           ty_str { true }\n           _ { false }\n         };\n }\n \n-pure fn type_is_unique(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_unique(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_uniq(_) { ret true; }\n       ty_vec(_) { true }\n       ty_str { true }\n       _ { ret false; }\n     }\n }\n \n-pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+pure fn type_is_scalar(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_send_type | ty_type | ty_ptr(_) { true }\n       _ { false }\n     }\n }\n \n // FIXME maybe inline this for speed?\n-fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n-    ret type_is_scalar(cx, ty) || type_is_boxed(cx, ty) ||\n-        type_is_unique(cx, ty);\n+fn type_is_immediate(ty: t) -> bool {\n+    ret type_is_scalar(ty) || type_is_boxed(ty) ||\n+        type_is_unique(ty);\n }\n \n fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n@@ -895,7 +762,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     }\n \n     let accum = false;\n-    let result = alt struct(cx, ty) {\n+    let result = alt get(ty).struct {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_type | ty_ptr(_) { false }\n@@ -966,7 +833,7 @@ fn kind_lteq(a: kind, b: kind) -> bool {\n }\n \n fn lower_kind(a: kind, b: kind) -> kind {\n-    if ty::kind_lteq(a, b) { a } else { b }\n+    if kind_lteq(a, b) { a } else { b }\n }\n \n fn type_kind(cx: ctxt, ty: t) -> kind {\n@@ -978,7 +845,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_sendable);\n \n-    let result = alt struct(cx, ty) {\n+    let result = alt get(ty).struct {\n       // Scalar and unique types are sendable\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_ptr(_) | ty_send_type | ty_str { kind_sendable }\n@@ -1032,7 +899,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n \n fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n    bool {\n-    let sty = struct(cx, ty);\n+    let sty = get(ty).struct;\n     if test(sty) { ret true; }\n     alt sty {\n       ty_enum(did, tps) {\n@@ -1074,7 +941,7 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n     actually checkable. It seems to me like a lot of properties\n     that the type context tracks about types should be immutable.)\n     */\n-    type_structurally_contains(cx, ty) {|sty|\n+    type_has_params(ty) && type_structurally_contains(cx, ty) {|sty|\n         alt sty {\n           ty_param(_, _) { true }\n           _ { false }\n@@ -1117,26 +984,26 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     });\n }\n \n-fn type_is_integral(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_integral(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_int(_) | ty_uint(_) | ty_bool { true }\n       _ { false }\n     }\n }\n \n-fn type_is_fp(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_fp(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_float(_) { true }\n       _ { false }\n     }\n }\n \n-fn type_is_numeric(cx: ctxt, ty: t) -> bool {\n-    ret type_is_integral(cx, ty) || type_is_fp(cx, ty);\n+fn type_is_numeric(ty: t) -> bool {\n+    ret type_is_integral(ty) || type_is_fp(ty);\n }\n \n-fn type_is_signed(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_signed(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_int(_) { true }\n       _ { false }\n     }\n@@ -1146,7 +1013,7 @@ fn type_is_signed(cx: ctxt, ty: t) -> bool {\n // that the cycle collector might care about.\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let result = true;\n-    alt struct(cx, ty) {\n+    alt get(ty).struct {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_send_type | ty_type | ty_ptr(_) { result = true; }\n@@ -1184,8 +1051,8 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-fn type_is_enum(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+fn type_is_enum(ty: t) -> bool {\n+    alt get(ty).struct {\n       ty_enum(_, _) { ret true; }\n       _ { ret false;}\n     }\n@@ -1194,7 +1061,7 @@ fn type_is_enum(cx: ctxt, ty: t) -> bool {\n // Whether a type is enum like, that is a enum type with only nullary\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) {\n+    alt get(ty).struct {\n       ty_enum(did, tps) {\n         let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, {|v| vec::len(v.args) > 0u});\n@@ -1204,8 +1071,8 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_param(cx: ctxt, ty: t) -> option<uint> {\n-    alt struct(cx, ty) {\n+fn type_param(ty: t) -> option<uint> {\n+    alt get(ty).struct {\n       ty_param(id, _) { ret some(id); }\n       _ {/* fall through */ }\n     }\n@@ -1217,15 +1084,15 @@ fn type_param(cx: ctxt, ty: t) -> option<uint> {\n fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n     let rslt = [];\n     walk_ty(cx, ty) {|ty|\n-        alt struct(cx, ty) { ty_var(v) { rslt += [v]; } _ { } }\n+        alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n     }\n     rslt\n }\n \n-fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n+fn type_autoderef(cx: ctxt, t: t) -> t {\n     let t1 = t;\n     while true {\n-        alt struct(cx, t1) {\n+        alt get(t1).struct {\n           ty_box(mt) | ty_uniq(mt) { t1 = mt.ty; }\n           ty_res(_, inner, tps) {\n             t1 = substitute_type_params(cx, tps, inner);\n@@ -1245,57 +1112,29 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n \n // Type hashing.\n fn hash_type_structure(st: sty) -> uint {\n-    fn hash_uint(id: uint, n: uint) -> uint {\n-        let h = id;\n-        h += (h << 5u) + n;\n-        ret h;\n-    }\n+    fn hash_uint(id: uint, n: uint) -> uint { (id << 2u) + n }\n     fn hash_def(id: uint, did: ast::def_id) -> uint {\n-        let h = id;\n-        h += (h << 5u) + (did.crate as uint);\n-        h += (h << 5u) + (did.node as uint);\n-        ret h;\n-    }\n-    fn hash_subty(id: uint, subty: t) -> uint {\n-        let h = id;\n-        h += (h << 5u) + subty;\n-        ret h;\n+        let h = (id << 2u) + (did.crate as uint);\n+        (h << 2u) + (did.node as uint)\n     }\n+    fn hash_subty(id: uint, subty: t) -> uint { (id << 2u) + type_id(subty) }\n     fn hash_subtys(id: uint, subtys: [t]) -> uint {\n         let h = id;\n-        vec::iter(subtys) { |subty|\n-            h = hash_subty(h, subty);\n-        }\n-        ret h;\n+        for s in subtys { h = (h << 2u) + type_id(s) }\n+        h\n     }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let h = id;\n-        h += (h << 5u) + hash_def(h, c.node.id);\n-        ret hash_type_constr_args(h, c.node.args);\n-    }\n-    fn hash_type_constr_args(id: uint, args: [@ty_constr_arg]) -> uint {\n-        let h = id;\n-        for a: @ty_constr_arg in args {\n+        h = (h << 2u) + hash_def(h, c.node.id);\n+        // FIXME this makes little sense\n+        for a in c.node.args {\n             alt a.node {\n-              carg_base { h += h << 5u; }\n-              carg_lit(_) {\n-                // FIXME\n-                fail \"lit args not implemented yet\";\n-              }\n-              carg_ident(p) {\n-                // FIXME: Not sure what to do here.\n-                h += h << 5u;\n-              }\n+              carg_base { h += h << 2u; }\n+              carg_lit(_) { fail \"lit args not implemented yet\"; }\n+              carg_ident(p) { h += h << 2u; }\n             }\n         }\n-        ret h;\n-    }\n-\n-    fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n-        let h = id;\n-        for a: arg in args { h += (h << 5u) + a.ty; }\n-        h += (h << 5u) + rty;\n-        ret h;\n+        h\n     }\n     alt st {\n       ty_nil { 0u } ty_bool { 1u }\n@@ -1314,58 +1153,57 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_float(t) {\n         alt t { ast::ty_f { 13u } ast::ty_f32 { 14u } ast::ty_f64 { 15u } }\n       }\n-      ty_str { ret 17u; }\n+      ty_str { 17u }\n       ty_enum(did, tys) {\n         let h = hash_def(18u, did);\n-        for typ: t in tys { h += (h << 5u) + typ; }\n-        ret h;\n+        for typ: t in tys { h = hash_subty(h, typ); }\n+        h\n       }\n-      ty_box(mt) { ret hash_subty(19u, mt.ty); }\n-      ty_vec(mt) { ret hash_subty(21u, mt.ty); }\n+      ty_box(mt) { hash_subty(19u, mt.ty) }\n+      ty_vec(mt) { hash_subty(21u, mt.ty) }\n       ty_rec(fields) {\n         let h = 26u;\n-        for f: field in fields { h += (h << 5u) + f.mt.ty; }\n-        ret h;\n+        for f in fields { h = hash_subty(h, f.mt.ty); }\n+        h\n       }\n-      ty_tup(ts) { ret hash_subtys(25u, ts); }\n-\n-      // ???\n-      ty_fn(f) { ret hash_fn(27u, f.inputs, f.output); }\n-      ty_var(v) { ret hash_uint(30u, v as uint); }\n-      ty_param(pid, _) { ret hash_uint(31u, pid); }\n+      ty_tup(ts) { hash_subtys(25u, ts) }\n+      ty_fn(f) {\n+        let h = 27u;\n+        for a in f.inputs { h = hash_subty(h, a.ty); }\n+        hash_subty(h, f.output)\n+      }\n+      ty_var(v) { hash_uint(30u, v as uint) }\n+      ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n       ty_self(ts) {\n         let h = 28u;\n-        for t in ts { h += (h << 5u) + t; }\n-        ret h;\n+        for t in ts { h = hash_subty(h, t); }\n+        h\n       }\n-      ty_type { ret 32u; }\n-      ty_bot { ret 34u; }\n-      ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n+      ty_type { 32u }\n+      ty_bot { 34u }\n+      ty_ptr(mt) { hash_subty(35u, mt.ty) }\n       ty_res(did, sub, tps) {\n         let h = hash_subty(hash_def(18u, did), sub);\n-        ret hash_subtys(h, tps);\n+        hash_subtys(h, tps)\n       }\n       ty_constr(t, cs) {\n         let h = hash_subty(36u, t);\n-        for c: @type_constr in cs { h += (h << 5u) + hash_type_constr(h, c); }\n-        ret h;\n+        for c in cs { h = (h << 2u) + hash_type_constr(h, c); }\n+        h\n       }\n-      ty_uniq(mt) { ret hash_subty(37u, mt.ty); }\n-      ty_send_type { ret 38u; }\n-      ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(39u, t) }\n+      ty_uniq(mt) { hash_subty(37u, mt.ty) }\n+      ty_send_type { 38u }\n       ty_iface(did, tys) {\n         let h = hash_def(40u, did);\n         for typ: t in tys { h = hash_subty(h, typ); }\n-        ret h;\n+        h\n       }\n-      ty_opaque_closure_ptr(ck_block) { ret 41u; }\n-      ty_opaque_closure_ptr(ck_box) { ret 42u; }\n-      ty_opaque_closure_ptr(ck_uniq) { ret 43u; }\n+      ty_opaque_closure_ptr(ck_block) { 41u }\n+      ty_opaque_closure_ptr(ck_box) { 42u }\n+      ty_opaque_closure_ptr(ck_uniq) { 43u }\n     }\n }\n \n-fn hash_raw_ty(&&rt: @raw_t) -> uint { ret rt.hash; }\n-\n fn arg_eq<T>(eq: fn(T, T) -> bool,\n              a: @sp_constr_arg<T>,\n              b: @sp_constr_arg<T>)\n@@ -1429,7 +1267,7 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n fn count_ty_params(cx: ctxt, ty: t) -> uint {\n     let param_indices = [];\n     walk_ty(cx, ty) {|t|\n-        alt struct(cx, t) {\n+        alt get(t).struct {\n           ty_param(param_idx, _) {\n             if !vec::any(param_indices, {|i| i == param_idx}) {\n                 param_indices += [param_idx];\n@@ -1441,68 +1279,51 @@ fn count_ty_params(cx: ctxt, ty: t) -> uint {\n     vec::len(param_indices)\n }\n \n-fn type_contains_vars(cx: ctxt, typ: t) -> bool {\n-    ret interner::get(*cx.ts, typ).has_vars;\n-}\n-\n-fn type_contains_params(cx: ctxt, typ: t) -> bool {\n-    ret interner::get(*cx.ts, typ).has_params;\n-}\n-\n-\n // Type accessors for substructures of types\n-fn ty_fn_args(cx: ctxt, fty: t) -> [arg] {\n-    alt struct(cx, fty) {\n-      ty::ty_fn(f) { ret f.inputs; }\n-      _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n+fn ty_fn_args(fty: t) -> [arg] {\n+    alt get(fty).struct {\n+      ty_fn(f) { f.inputs }\n+      _ { fail \"ty_fn_args() called on non-fn type\"; }\n     }\n }\n \n-fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n-    alt struct(cx, fty) {\n-      ty::ty_fn(f) { ret f.proto; }\n-      _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n+fn ty_fn_proto(fty: t) -> ast::proto {\n+    alt get(fty).struct {\n+      ty_fn(f) { f.proto }\n+      _ { fail \"ty_fn_proto() called on non-fn type\"; }\n     }\n }\n \n-pure fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n-    let sty = struct(cx, fty);\n-    alt sty {\n-      ty::ty_fn(f) { ret f.output; }\n-      _ {\n-        // Unchecked is ok since we diverge here\n-        // (might want to change the typechecker to allow\n-        // it without an unchecked)\n-        // Or, it wouldn't be necessary if we had the right\n-        // typestate constraint on cx and t (then we could\n-        // call unreachable() instead)\n-        unchecked { cx.sess.bug(\"ty_fn_ret() called on non-fn type\"); }}\n+pure fn ty_fn_ret(fty: t) -> t {\n+    alt get(fty).struct {\n+      ty_fn(f) { f.output }\n+      _ { fail \"ty_fn_ret() called on non-fn type\"; }\n     }\n }\n \n-fn ty_fn_ret_style(cx: ctxt, fty: t) -> ast::ret_style {\n-    alt struct(cx, fty) {\n-      ty::ty_fn(f) { f.ret_style }\n-      _ { cx.sess.bug(\"ty_fn_ret_style() called on non-fn type\"); }\n+fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n+    alt get(fty).struct {\n+      ty_fn(f) { f.ret_style }\n+      _ { fail \"ty_fn_ret_style() called on non-fn type\"; }\n     }\n }\n \n-fn is_fn_ty(cx: ctxt, fty: t) -> bool {\n-    alt struct(cx, fty) {\n-      ty::ty_fn(_) { ret true; }\n+fn is_fn_ty(fty: t) -> bool {\n+    alt get(fty).struct {\n+      ty_fn(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n // Just checks whether it's a fn that returns bool,\n // not its purity.\n-fn is_pred_ty(cx: ctxt, fty: t) -> bool {\n-    is_fn_ty(cx, fty) && type_is_bool(cx, ty_fn_ret(cx, fty))\n+fn is_pred_ty(fty: t) -> bool {\n+    is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n-fn ty_var_id(cx: ctxt, typ: t) -> int {\n-    alt struct(cx, typ) {\n-      ty::ty_var(vid) { ret vid; }\n+fn ty_var_id(typ: t) -> int {\n+    alt get(typ).struct {\n+      ty_var(vid) { ret vid; }\n       _ { #error(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n@@ -1573,8 +1394,8 @@ fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n \n // TODO: could have a precondition instead of failing\n fn get_fields(tcx:ctxt, rec_ty:t) -> [field] {\n-    alt struct(tcx, rec_ty) {\n-       ty::ty_rec(fields) { fields }\n+    alt get(rec_ty).struct {\n+       ty_rec(fields) { fields }\n        _ { tcx.sess.bug(\"get_fields called on non-record type\"); }\n     }\n }\n@@ -1594,10 +1415,8 @@ fn sort_methods(meths: [method]) -> [method] {\n \n fn occurs_check_fails(tcx: ctxt, sp: option<span>, vid: int, rt: t) ->\n    bool {\n-    if !type_contains_vars(tcx, rt) {\n-        // Fast path\n-        ret false;\n-    }\n+    // Fast path\n+    if !type_has_vars(rt) { ret false; }\n \n     // Occurs check!\n     if vec::member(vid, vars_in_type(tcx, rt)) {\n@@ -1609,7 +1428,7 @@ fn occurs_check_fails(tcx: ctxt, sp: option<span>, vid: int, rt: t) ->\n             tcx.sess.span_fatal\n                 (s, \"Type inference failed because I \\\n                      could not find a type\\n that's both of the form \"\n-                 + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n+                 + ty_to_str(tcx, mk_var(tcx, vid)) +\n                  \" and of the form \" + ty_to_str(tcx, rt) +\n                  \". Such a type would have to be infinitely large.\");\n           }\n@@ -1655,7 +1474,7 @@ fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n     }\n }\n \n-fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { ty::resolved_mode(cx, a.mode) }\n+fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n \n // Unifies `m1` and `m2`.  Returns unified value or failure code.\n fn unify_mode(cx: ctxt, m1: ast::mode, m2: ast::mode)\n@@ -1694,7 +1513,6 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n //\n //     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n mod unify {\n-\n     export fixup_result;\n     export fixup_vars;\n     export fix_ok;\n@@ -1722,14 +1540,14 @@ mod unify {\n         precise,\n         in_bindings(@var_bindings),\n     }\n-    type ctxt = {st: unify_style, tcx: ty_ctxt};\n+    type uctxt = {st: unify_style, tcx: ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n         ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n     }\n \n     // Unifies two sets.\n-    fn union(cx: @ctxt, set_a: uint, set_b: uint,\n+    fn union(cx: @uctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n         let vb = alt cx.st {\n             in_bindings(vb) { vb }\n@@ -1770,20 +1588,20 @@ mod unify {\n     }\n \n     fn record_var_binding_for_expected(\n-        cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n+        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n         record_var_binding(\n             cx, key, typ, variance_transform(variance, covariant))\n     }\n \n     fn record_var_binding_for_actual(\n-        cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n+        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n         // Unifying in 'the other direction' so flip the variance\n         record_var_binding(\n             cx, key, typ, variance_transform(variance, contravariant))\n     }\n \n     fn record_var_binding(\n-        cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n+        cx: @uctxt, key: int, typ: t, variance: variance) -> result {\n \n         let vb = alt cx.st { in_bindings(vb) { vb }\n             _ { cx.tcx.sess.bug(\"Someone forgot to document an invariant \\\n@@ -1806,10 +1624,10 @@ mod unify {\n     }\n \n     // Simple structural type comparison.\n-    fn struct_cmp(cx: @ctxt, expected: t, actual: t) -> result {\n+    fn struct_cmp(cx: @uctxt, expected: t, actual: t) -> result {\n         let tcx = cx.tcx;\n         let cfg = tcx.sess.targ_cfg;\n-        if mach_struct(tcx, cfg, expected) == mach_struct(tcx, cfg, actual) {\n+        if mach_sty(cfg, expected) == mach_sty(cfg, actual) {\n             ret ures_ok(expected);\n         }\n         ret ures_err(terr_mismatch);\n@@ -1925,8 +1743,8 @@ mod unify {\n           _ { some(ures_err(terr_mismatch)) }\n         };\n     }\n-    fn unify_args(cx: @ctxt, e_args: [arg], a_args: [arg], variance: variance)\n-        -> either::t<result, [arg]> {\n+    fn unify_args(cx: @uctxt, e_args: [arg], a_args: [arg],\n+                  variance: variance) -> either::t<result, [arg]> {\n         if !vec::same_length(e_args, a_args) {\n             ret either::left(ures_err(terr_arg_count));\n         }\n@@ -1956,7 +1774,7 @@ mod unify {\n         }\n         either::right(result)\n     }\n-    fn unify_fn(cx: @ctxt, e_f: fn_ty, a_f: fn_ty, variance: variance)\n+    fn unify_fn(cx: @uctxt, e_f: fn_ty, a_f: fn_ty, variance: variance)\n         -> result {\n         alt unify_fn_proto(e_f.proto, a_f.proto, variance) {\n           some(err) { ret err; }\n@@ -1991,9 +1809,9 @@ mod unify {\n     }\n \n     // If the given type is a variable, returns the structure of that type.\n-    fn resolve_type_structure(tcx: ty_ctxt, vb: @var_bindings, typ: t) ->\n+    fn resolve_type_structure(vb: @var_bindings, typ: t) ->\n        fixup_result {\n-        alt struct(tcx, typ) {\n+        alt get(typ).struct {\n           ty_var(vid) {\n             if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n             let root_id = ufind::find(vb.sets, vid as uint);\n@@ -2048,7 +1866,7 @@ mod unify {\n         }\n     }\n \n-    fn unify_tps(cx: @ctxt, expected_tps: [t], actual_tps: [t],\n+    fn unify_tps(cx: @uctxt, expected_tps: [t], actual_tps: [t],\n                  variance: variance, finish: fn([t]) -> result) -> result {\n         let result_tps = [], i = 0u;\n         for exp in expected_tps {\n@@ -2062,7 +1880,7 @@ mod unify {\n         }\n         finish(result_tps)\n     }\n-    fn unify_step(cx: @ctxt, expected: t, actual: t,\n+    fn unify_step(cx: @uctxt, expected: t, actual: t,\n                   variance: variance) -> result {\n         // FIXME: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n@@ -2076,13 +1894,13 @@ mod unify {\n         // Stage 1: Handle the cases in which one side or another is a type\n         // variable\n \n-        alt struct(cx.tcx, actual) {\n+        alt get(actual).struct {\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n-          ty::ty_var(actual_id) {\n+          ty_var(actual_id) {\n             let actual_n = actual_id as uint;\n-            alt struct(cx.tcx, expected) {\n-              ty::ty_var(expected_id) {\n+            alt get(expected).struct {\n+              ty_var(expected_id) {\n                 let expected_n = expected_id as uint;\n                 alt union(cx, expected_n, actual_n, variance) {\n                   unres_ok {/* fall through */ }\n@@ -2102,8 +1920,8 @@ mod unify {\n           }\n           _ {/* empty */ }\n         }\n-        alt struct(cx.tcx, expected) {\n-          ty::ty_var(expected_id) {\n+        alt get(expected).struct {\n+          ty_var(expected_id) {\n             // Add a binding. (`actual` can't actually be a var here.)\n             alt record_var_binding_for_expected(\n                 cx, expected_id, actual,\n@@ -2117,31 +1935,31 @@ mod unify {\n         }\n         // Stage 2: Handle all other cases.\n \n-        alt struct(cx.tcx, actual) {\n-          ty::ty_bot { ret ures_ok(expected); }\n+        alt get(actual).struct {\n+          ty_bot { ret ures_ok(expected); }\n           _ {/* fall through */ }\n         }\n-        alt struct(cx.tcx, expected) {\n-          ty::ty_nil { ret struct_cmp(cx, expected, actual); }\n+        alt get(expected).struct {\n+          ty_nil { ret struct_cmp(cx, expected, actual); }\n           // _|_ unifies with anything\n-          ty::ty_bot {\n+          ty_bot {\n             ret ures_ok(actual);\n           }\n-          ty::ty_bool | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty::ty_str | ty::ty_send_type {\n+          ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty_str | ty_send_type {\n             ret struct_cmp(cx, expected, actual);\n           }\n-          ty::ty_param(expected_n, _) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_param(actual_n, _) if expected_n == actual_n {\n+          ty_param(expected_n, _) {\n+            alt get(actual).struct {\n+              ty_param(actual_n, _) if expected_n == actual_n {\n                 ret ures_ok(expected);\n               }\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_enum(expected_id, expected_tps) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_enum(actual_id, actual_tps) {\n+          ty_enum(expected_id, expected_tps) {\n+            alt get(actual).struct {\n+              ty_enum(actual_id, actual_tps) {\n                 if expected_id != actual_id {\n                     ret ures_err(terr_mismatch);\n                 }\n@@ -2154,8 +1972,8 @@ mod unify {\n             ret ures_err(terr_mismatch);\n           }\n           ty_iface(expected_id, expected_tps) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_iface(actual_id, actual_tps) {\n+            alt get(actual).struct {\n+              ty_iface(actual_id, actual_tps) {\n                 if expected_id != actual_id {\n                     ret ures_err(terr_mismatch);\n                 }\n@@ -2167,9 +1985,9 @@ mod unify {\n             }\n             ret ures_err(terr_mismatch);\n           }\n-          ty::ty_box(expected_mt) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_box(actual_mt) {\n+          ty_box(expected_mt) {\n+            alt get(actual).struct {\n+              ty_box(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none { ret ures_err(terr_box_mutability); }\n@@ -2188,9 +2006,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_uniq(expected_mt) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_uniq(actual_mt) {\n+          ty_uniq(expected_mt) {\n+            alt get(actual).struct {\n+              ty_uniq(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none { ret ures_err(terr_box_mutability); }\n@@ -2209,9 +2027,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_vec(expected_mt) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_vec(actual_mt) {\n+          ty_vec(expected_mt) {\n+            alt get(actual).struct {\n+              ty_vec(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none { ret ures_err(terr_vec_mutability); }\n@@ -2230,9 +2048,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_ptr(expected_mt) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_ptr(actual_mt) {\n+          ty_ptr(expected_mt) {\n+            alt get(actual).struct {\n+              ty_ptr(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n                   none { ret ures_err(terr_vec_mutability); }\n@@ -2251,9 +2069,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_res(ex_id, ex_inner, ex_tps) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_res(act_id, act_inner, act_tps) {\n+          ty_res(ex_id, ex_inner, ex_tps) {\n+            alt get(actual).struct {\n+              ty_res(act_id, act_inner, act_tps) {\n                 if ex_id.crate != act_id.crate || ex_id.node != act_id.node {\n                     ret ures_err(terr_mismatch);\n                 }\n@@ -2280,9 +2098,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_rec(expected_fields) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_rec(actual_fields) {\n+          ty_rec(expected_fields) {\n+            alt get(actual).struct {\n+              ty_rec(actual_fields) {\n                 let expected_len = vec::len::<field>(expected_fields);\n                 let actual_len = vec::len::<field>(actual_fields);\n                 if expected_len != actual_len {\n@@ -2326,9 +2144,9 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_tup(expected_elems) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_tup(actual_elems) {\n+          ty_tup(expected_elems) {\n+            alt get(actual).struct {\n+              ty_tup(actual_elems) {\n                 let expected_len = vec::len(expected_elems);\n                 let actual_len = vec::len(actual_elems);\n                 if expected_len != actual_len {\n@@ -2356,19 +2174,19 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_fn(expected_f) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_fn(actual_f) {\n+          ty_fn(expected_f) {\n+            alt get(actual).struct {\n+              ty_fn(actual_f) {\n                 ret unify_fn(cx, expected_f, actual_f, variance);\n               }\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_constr(expected_t, expected_constrs) {\n+          ty_constr(expected_t, expected_constrs) {\n \n             // unify the base types...\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_constr(actual_t, actual_constrs) {\n+            alt get(actual).struct {\n+              ty_constr(actual_t, actual_constrs) {\n                 let rslt = unify_step(\n                     cx, expected_t, actual_t, variance);\n                 alt rslt {\n@@ -2395,11 +2213,11 @@ mod unify {\n         }\n     }\n     fn unify(expected: t, actual: t, st: unify_style,\n-             tcx: ty_ctxt) -> result {\n+             tcx: ctxt) -> result {\n         let cx = @{st: st, tcx: tcx};\n         ret unify_step(cx, expected, actual, covariant);\n     }\n-    fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n+    fn dump_var_bindings(tcx: ctxt, vb: @var_bindings) {\n         let i = 0u;\n         while i < vec::len::<ufind::node>(vb.sets.nodes) {\n             let sets = \"\";\n@@ -2422,20 +2240,20 @@ mod unify {\n     //    Takes an optional span - complain about occurs check violations\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n+    fn fixup_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n                   typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n+        fn subst_vars(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n                       unresolved: @mutable option<int>,\n                       vars_seen: std::list::list<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n             if vid as uint >= ufind::set_count(vb.sets) {\n                 *unresolved = some(vid);\n-                ret ty::mk_var(tcx, vid);\n+                ret mk_var(tcx, vid);\n             }\n             let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find::<t>(vb.types, root_id) {\n-              none { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n+              none { *unresolved = some(vid); ret mk_var(tcx, vid); }\n               some(rt) {\n                 let give_up = false;\n                 std::list::iter(vars_seen) {|v|\n@@ -2465,7 +2283,7 @@ mod unify {\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: ty_ctxt, sp: option<span>, vb: @var_bindings,\n+    fn resolve_type_var(tcx: ctxt, sp: option<span>, vb: @var_bindings,\n                         vid: int) -> fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n@@ -2483,7 +2301,7 @@ fn same_type(cx: ctxt, a: t, b: t) -> bool {\n     }\n }\n \n-fn type_err_to_str(err: ty::type_err) -> str {\n+fn type_err_to_str(err: type_err) -> str {\n     alt err {\n       terr_mismatch { ret \"types differ\"; }\n       terr_ret_style_mismatch(expect, actual) {\n@@ -2574,7 +2392,7 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n }\n \n // Enum information\n-type variant_info = @{args: [ty::t], ctor_ty: ty::t, name: str,\n+type variant_info = @{args: [t], ctor_ty: t, name: str,\n                       id: ast::def_id, disr_val: int};\n \n fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n@@ -2594,7 +2412,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n             @vec::map(variants, {|variant|\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n                 let arg_tys = if vec::len(variant.node.args) > 0u {\n-                    vec::map(ty_fn_args(cx, ctor_ty), {|a| a.ty})\n+                    vec::map(ty_fn_args(ctor_ty), {|a| a.ty})\n                 } else { [] };\n                 alt variant.node.disr_expr {\n                   some (ex) {\n@@ -2653,11 +2471,10 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n }\n \n fn ret_ty_of_fn(cx: ctxt, id: ast::node_id) -> t {\n-    ty_fn_ret(cx, node_id_to_type(cx, id))\n+    ty_fn_ret(node_id_to_type(cx, id))\n }\n \n-fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n-\n+fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const tycat_other: int = 0;\n     const tycat_bool: int = 1;\n     const tycat_int: int = 2;\n@@ -2700,8 +2517,8 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n         }\n     }\n \n-    fn tycat(cx: ctxt, ty: t) -> int {\n-        alt struct(cx, ty) {\n+    fn tycat(ty: t) -> int {\n+        alt get(ty).struct {\n           ty_bool { tycat_bool }\n           ty_int(_) { tycat_int }\n           ty_uint(_) { tycat_int }\n@@ -2735,11 +2552,11 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n          [t, f, f, f, t, t, f, f], [t, f, f, f, t, t, f, f],\n          [f, f, f, f, t, t, f, f], [t, t, t, t, t, t, t, t]]; /*struct*/\n \n-    ret tbl[tycat(cx, ty)][opcat(op)];\n+    ret tbl[tycat(ty)][opcat(op)];\n }\n \n-fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: @ast::constr_general<T>) ->\n-   @ty::constr_general<T> {\n+fn ast_constr_to_constr<T>(tcx: ctxt, c: @ast::constr_general<T>) ->\n+   @constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n       some(ast::def_fn(pred_id, ast::pure_fn)) {\n         ret @ast_util::respan(c.span,"}, {"sha": "3b9c7451c5f56f953406246d97b9258966de838a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -165,7 +165,7 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n \n // Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n-    alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n+    alt ty::unify::resolve_type_structure(fcx.var_bindings, tp) {\n       fix_ok(typ_s) { ret typ_s; }\n       fix_err(_) {\n         fcx.ccx.tcx.sess.span_fatal\n@@ -177,29 +177,29 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n \n // Returns the one-level-deep structure of the given type.f\n fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n-    ret ty::struct(fcx.ccx.tcx, structurally_resolved_type(fcx, sp, typ));\n+    ty::get(structurally_resolved_type(fcx, sp, typ)).struct\n }\n \n // Returns the one-level-deep structure of the given type or none if it\n // is not known yet.\n fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n    option<ty::sty> {\n     let r =\n-        ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n+        ty::unify::resolve_type_structure(fcx.var_bindings, typ);\n     ret alt r {\n-          fix_ok(typ_s) { some(ty::struct(fcx.ccx.tcx, typ_s)) }\n+          fix_ok(typ_s) { some(ty::get(typ_s).struct) }\n           fix_err(_) { none }\n         }\n }\n \n fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    ret ty::type_is_integral(fcx.ccx.tcx, typ_s);\n+    ret ty::type_is_integral(typ_s);\n }\n \n fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    ret ty::type_is_scalar(fcx.ccx.tcx, typ_s);\n+    ret ty::type_is_scalar(typ_s);\n }\n \n fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n@@ -389,7 +389,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         // call to resolve any named types.\n         let tpt = {bounds: ty_param_bounds(tcx, mode, tps),\n                    ty: ty::mk_named(tcx, ast_ty_to_ty(tcx, mode, t),\n-                                    @it.ident)};\n+                                    it.ident)};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -398,7 +398,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         let t_arg = ty_of_arg(tcx, mode, decl.inputs[0]);\n         let t = ty::mk_named(tcx, ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n                                              params),\n-                             @it.ident);\n+                             it.ident);\n         let t_res = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n@@ -407,7 +407,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         // Create a new generic polytype.\n         let {bounds, params} = mk_ty_params(tcx, tps);\n         let t = ty::mk_named(tcx, ty::mk_enum(tcx, local_def(it.id), params),\n-                             @it.ident);\n+                             it.ident);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n@@ -416,7 +416,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         let {bounds, params} = mk_ty_params(tcx, tps);\n         let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n                                                params),\n-                             @it.ident);\n+                             it.ident);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n@@ -441,7 +441,7 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n     fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n         alt m {\n           ast::infer(_) {\n-            alt ty::struct(tcx, ty) {\n+            alt ty::get(ty).struct {\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere.\n@@ -452,7 +452,7 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n               // tables in tcx but should never fail, because nothing else\n               // will have been unified with m yet:\n               _ {\n-                let m1 = ast::expl(ty::default_arg_mode_for_ty(tcx, ty));\n+                let m1 = ast::expl(ty::default_arg_mode_for_ty(ty));\n                 result::get(ty::unify_mode(tcx, m, m1))\n               }\n             }\n@@ -520,7 +520,7 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n                   ast::bound_copy { ty::bound_copy }\n                   ast::bound_iface(t) {\n                     let ity = ast_ty_to_ty(tcx, mode, t);\n-                    alt ty::struct(tcx, ity) {\n+                    alt ty::get(ity).struct {\n                       ty::ty_iface(_, _) {}\n                       _ {\n                         tcx.sess.span_fatal(\n@@ -575,7 +575,7 @@ fn write_substs(tcx: ty::ctxt, node_id: ast::node_id, +substs: [ty::t]) {\n }\n fn write_ty_substs(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n                    +substs: [ty::t]) {\n-    let ty = if ty::type_contains_params(tcx, ty) {\n+    let ty = if ty::type_has_params(ty) {\n         ty::substitute_type_params(tcx, substs, ty)\n     } else { ty };\n     write_ty(tcx, node_id, ty);\n@@ -608,7 +608,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         ty::mk_fn(tcx, impl_m.fty)\n     } else {\n         let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n-            alt ty::struct(tcx, f.ty) {\n+            alt ty::get(f.ty).struct {\n               ty::ty_param(_, _) | ty::ty_self(_)\n               if alt i.mode { ast::infer(_) { true } _ { false } } {\n                 {mode: ast::expl(ast::by_ref) with i}\n@@ -623,7 +623,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         });\n         let if_fty = ty::mk_fn(tcx, if_m.fty);\n         if_fty = ty::substitute_type_params(tcx, substs, if_fty);\n-        if ty::type_contains_vars(tcx, if_fty) {\n+        if ty::type_has_vars(if_fty) {\n             if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n                                              self_full(self_ty, impl_tps));\n         }\n@@ -648,9 +648,9 @@ enum self_subst { self_param(ty::t, @fn_ctxt, span), self_full(ty::t, uint) }\n // some mangling of the substituted types is required.\n fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n                            self: self_subst) -> ty::t {\n-    if ty::type_contains_vars(cx, mty) {\n+    if ty::type_has_vars(mty) {\n         ty::fold_ty(cx, ty::fm_general(fn@(t: ty::t) -> ty::t {\n-            alt ty::struct(cx, t) {\n+            alt ty::get(t).struct {\n               ty::ty_self(tps) {\n                 if vec::len(tps) > 0u {\n                     // Move the substs into the type param system of the\n@@ -783,7 +783,7 @@ mod collect {\n                 let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n                 cx.tcx.tcache.insert(local_def(it.id),\n                                      {bounds: i_bounds, ty: iface_ty});\n-                alt ty::struct(cx.tcx, iface_ty) {\n+                alt ty::get(iface_ty).struct {\n                   ty::ty_iface(did, tys) {\n                     if did.crate == ast::local_crate {\n                         ensure_iface_methods(cx.tcx, did.node);\n@@ -897,7 +897,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     while true {\n         alt structure_of(fcx, sp, t1) {\n           ty::ty_box(inner) | ty::ty_uniq(inner) {\n-            alt ty::struct(fcx.ccx.tcx, t1) {\n+            alt ty::get(t1).struct {\n               ty::ty_var(v1) {\n                 if ty::occurs_check_fails(fcx.ccx.tcx, some(sp), v1,\n                                           ty::mk_box(fcx.ccx.tcx, inner)) {\n@@ -962,7 +962,7 @@ mod demand {\n             // substitution. We will then pull out these type variables.\n             let t_0 = next_ty_var(fcx);\n             ty_param_substs += [mutable t_0];\n-            ty_param_subst_var_ids += [ty::ty_var_id(fcx.ccx.tcx, t_0)];\n+            ty_param_subst_var_ids += [ty::ty_var_id(t_0)];\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n \n@@ -1011,7 +1011,7 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n                      enum_ty_params: [ty::t]) -> [ty::t] {\n     let result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n-    alt ty::struct(ccx.tcx, tpt.ty) {\n+    alt ty::get(tpt.ty).struct {\n       ty::ty_fn(f) {\n         // N-ary variant.\n         for arg: ty::arg in f.inputs {\n@@ -1040,7 +1040,7 @@ mod writeback {\n \n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n        option<ty::t> {\n-        if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n+        if !ty::type_has_vars(typ) { ret some(typ); }\n         alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n                                   typ) {\n           fix_ok(new_type) { ret some(new_type); }\n@@ -1105,7 +1105,7 @@ mod writeback {\n                 alt (r_ty, input.mode) {\n                   (some(t), ast::infer(_)) {\n                     let tcx = wbcx.fcx.ccx.tcx;\n-                    let m_def = ty::default_arg_mode_for_ty(tcx, t);\n+                    let m_def = ty::default_arg_mode_for_ty(t);\n                     ty::set_default_mode(tcx, input.mode, m_def);\n                   }\n                   _ {}\n@@ -1219,7 +1219,7 @@ fn gather_locals(ccx: @crate_ctxt,\n         };\n \n     // Add formal parameters.\n-    let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n+    let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n         assign(decl.inputs[i].id, some(arg.ty));\n@@ -1305,7 +1305,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         if !ty::same_type(tcx, b_ty, resolve_type_vars_if_possible(\n             fcx, expr_ty(tcx, end))) {\n             tcx.sess.span_err(pat.span, \"mismatched types in range\");\n-        } else if !ty::type_is_numeric(tcx, b_ty) {\n+        } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else if !valid_range_bounds(begin, end) {\n             tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n@@ -1532,7 +1532,8 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n        -> ty::t {\n         actual\n     }\n-    ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n+    ret check_expr_with_unifier(fcx, expr, dummy_unify,\n+                                ty::mk_nil(fcx.ccx.tcx));\n }\n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n@@ -1562,7 +1563,7 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n       some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n         let tcx = fcx.ccx.tcx;\n         let substs = substs, n_tps = vec::len(substs), n_tys = vec::len(tps);\n-        let has_self = ty::type_contains_params(tcx, fty);\n+        let has_self = ty::type_has_params(fty);\n         if method_n_tps + n_tps > 0u {\n             if n_tys > 0u {\n                 if n_tys != method_n_tps {\n@@ -1604,13 +1605,13 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                   self_sub: option::t<self_subst>}> {\n     let tcx = fcx.ccx.tcx;\n     // First, see whether this is an interface-bounded parameter\n-    alt ty::struct(tcx, ty) {\n+    alt ty::get(ty).struct {\n       ty::ty_param(n, did) {\n         let bound_n = 0u;\n         for bound in *tcx.ty_param_bounds.get(did.node) {\n             alt bound {\n               ty::bound_iface(t) {\n-                let (iid, tps) = alt ty::struct(tcx, t) {\n+                let (iid, tps) = alt ty::get(t).struct {\n                   ty::ty_iface(i, tps) { (i, tps) }\n                   _ { fail; }\n                 };\n@@ -1639,7 +1640,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         for m in *ty::iface_methods(tcx, did) {\n             if m.ident == name {\n                 let fty = ty::mk_fn(tcx, m.fty);\n-                if ty::type_contains_vars(tcx, fty) {\n+                if ty::type_has_vars(fty) {\n                     tcx.sess.span_fatal(\n                         expr.span, \"can not call a method that contains a \\\n                                     self type through a boxed iface\");\n@@ -1883,7 +1884,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 let thn_t = block_ty(fcx.ccx.tcx, thn);\n                 let els_bot = check_expr_with(fcx, els, thn_t);\n                 let els_t = expr_ty(fcx.ccx.tcx, els);\n-                let if_t = if !ty::type_is_bot(fcx.ccx.tcx, els_t) {\n+                let if_t = if !ty::type_is_bot(els_t) {\n                     els_t\n                 } else {\n                     thn_t\n@@ -1916,7 +1917,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n             check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n-            some(ty::ty_fn_ret(fcx.ccx.tcx, method_ty))\n+            some(ty::ty_fn_ret(method_ty))\n           }\n           _ { none }\n         }\n@@ -2024,15 +2025,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n           ast::not {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n-            if !(ty::type_is_integral(tcx, oper_t) ||\n-                 ty::struct(tcx, oper_t) == ty::ty_bool) {\n+            if !(ty::type_is_integral(oper_t) ||\n+                 ty::get(oper_t).struct == ty::ty_bool) {\n                 oper_t = check_user_unop(fcx, \"!\", \"!\", expr, oper_t);\n             }\n           }\n           ast::neg {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n-            if !(ty::type_is_integral(tcx, oper_t) ||\n-                 ty::type_is_fp(tcx, oper_t)) {\n+            if !(ty::type_is_integral(oper_t) ||\n+                 ty::type_is_fp(oper_t)) {\n                 oper_t = check_user_unop(fcx, \"-\", \"unary-\", expr, oper_t);\n             }\n           }\n@@ -2187,7 +2188,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n-        let proto = alt ty::struct(tcx, expected) {\n+        let proto = alt ty::get(expected).struct {\n           ty::ty_fn({proto, _}) { proto }\n           _ { ast::proto_box }\n         };\n@@ -2262,15 +2263,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n         let t_e = ty::expr_ty(tcx, e);\n \n-        alt ty::struct(tcx, t_1) {\n+        alt ty::get(t_1).struct {\n           // This will be looked up later on\n           ty::ty_iface(_, _) {}\n           _ {\n-            if ty::type_is_nil(tcx, t_e) {\n+            if ty::type_is_nil(t_e) {\n                 tcx.sess.span_err(expr.span, \"cast from nil: \" +\n                                   ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n-            } else if ty::type_is_nil(tcx, t_1) {\n+            } else if ty::type_is_nil(t_1) {\n                 tcx.sess.span_err(expr.span, \"cast to nil: \" +\n                                   ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n@@ -2653,7 +2654,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     literals or slots */\n     alt e.node {\n       ast::expr_call(operator, operands, _) {\n-        if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n+        if !ty::is_pred_ty(expr_ty(fcx.ccx.tcx, operator)) {\n             fcx.ccx.tcx.sess.span_err\n                 (operator.span,\n                  \"operator in constraint has non-boolean return type\");\n@@ -2768,7 +2769,7 @@ fn check_fn(ccx: @crate_ctxt,\n \n     let gather_result = gather_locals(ccx, decl, body, id, old_fcx);\n     let fcx: @fn_ctxt =\n-        @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n+        @{ret_ty: ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n           proto: proto,\n           var_bindings: gather_result.var_bindings,\n@@ -2789,7 +2790,7 @@ fn check_fn(ccx: @crate_ctxt,\n       none { }\n     }\n \n-    let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n+    let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n         write_ty(ccx.tcx, decl.inputs[i].id, arg.ty);\n@@ -2829,11 +2830,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n-    alt ty::struct(tcx, a.ty) {\n+fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n+    alt ty::get(a.ty).struct {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm { ret false; }\n-        alt ty::struct(tcx, mt.ty) {\n+        alt ty::get(mt.ty).struct {\n           ty::ty_str { ret true; }\n           _ { ret false; }\n         }\n@@ -2844,11 +2845,11 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n \n fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id, main_span: span) {\n     let main_t = ty::node_id_to_type(tcx, main_id);\n-    alt ty::struct(tcx, main_t) {\n+    alt ty::get(main_t).struct {\n       ty::ty_fn({proto: ast::proto_bare, inputs, output,\n                  ret_style: ast::return_val, constraints}) {\n         let ok = vec::len(constraints) == 0u;\n-        ok &= ty::type_is_nil(tcx, output);\n+        ok &= ty::type_is_nil(output);\n         let num_args = vec::len(inputs);\n         ok &= num_args == 0u || num_args == 1u &&\n               arg_is_argv_ty(tcx, inputs[0]);\n@@ -2906,19 +2907,19 @@ mod dict {\n     fn lookup_dict(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                    ty: ty::t, iface_ty: ty::t) -> dict_origin {\n         let tcx = fcx.ccx.tcx;\n-        let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n+        let (iface_id, iface_tps) = alt ty::get(iface_ty).struct {\n             ty::ty_iface(did, tps) { (did, tps) }\n             _ { tcx.sess.span_bug(sp, \"Undocumented invariant in lookup\\\n                  _dict\"); }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n-        alt ty::struct(tcx, ty) {\n+        alt ty::get(ty).struct {\n           ty::ty_param(n, did) {\n             let n_bound = 0u;\n             for bound in *tcx.ty_param_bounds.get(did.node) {\n                 alt bound {\n                   ty::bound_iface(ity) {\n-                    alt ty::struct(tcx, ity) {\n+                    alt ty::get(ity).struct {\n                       ty::ty_iface(idid, _) {\n                         if iface_id == idid { ret dict_param(n, n_bound); }\n                       }\n@@ -2941,7 +2942,7 @@ mod dict {\n                 for im in *impls {\n                     let match = alt ty::impl_iface(tcx, im.did) {\n                       some(ity) {\n-                        alt ty::struct(tcx, ity) {\n+                        alt ty::get(ity).struct {\n                           ty::ty_iface(id, _) { id == iface_id }\n                           // Bleah, abstract this\n                           _ { tcx.sess.span_bug(sp, \"Undocumented invariant \\\n@@ -3007,7 +3008,7 @@ mod dict {\n         let tcx = fcx.ccx.tcx;\n         let ity = option::get(ty::impl_iface(tcx, impl_did));\n         let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n-        alt ty::struct(tcx, iface_ty) {\n+        alt ty::get(iface_ty).struct {\n           ty::ty_iface(_, tps) {\n             vec::iter2(tps, iface_tys,\n                        {|a, b| demand::simple(fcx, sp, a, b);});\n@@ -3059,7 +3060,7 @@ mod dict {\n           }\n           ast::expr_cast(src, _) {\n             let target_ty = expr_ty(cx.tcx, ex);\n-            alt ty::struct(cx.tcx, target_ty) {\n+            alt ty::get(target_ty).struct {\n               ty::ty_iface(_, _) {\n                 let impls = cx.impl_map.get(ex.id);\n                 let dict = lookup_dict(fcx, impls, ex.span,"}, {"sha": "3b2cf157e320dbb49026801abb1901a2f3775855", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8673c4f195be8377f8e0d83929f9a16bb99092a0/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=8673c4f195be8377f8e0d83929f9a16bb99092a0", "patch": "@@ -16,8 +16,8 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         let modestr = alt canon_mode(cx, mode) {\n           ast::infer(_) { \"\" }\n           ast::expl(m) {\n-            if !ty::type_contains_vars(cx, ty) &&\n-                m == ty::default_arg_mode_for_ty(cx, ty) {\n+            if !ty::type_has_vars(ty) &&\n+                m == ty::default_arg_mode_for_ty(ty) {\n                 \"\"\n             } else {\n                 mode_to_str(ast::expl(m))\n@@ -36,7 +36,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n         s += str::connect(strs, \", \");\n         s += \")\";\n-        if struct(cx, output) != ty_nil {\n+        if ty::get(output).struct != ty_nil {\n             s += \" -> \";\n             alt cf {\n               ast::noreturn { s += \"!\"; }\n@@ -62,22 +62,22 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         }\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n-    alt ty_name(cx, typ) {\n+    alt ty::type_name(typ) {\n       some(cs) {\n-        alt struct(cx, typ) {\n+        alt ty::get(typ).struct {\n           ty_enum(_, tps) | ty_res(_, _, tps) {\n             if vec::len(tps) > 0u {\n                 let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n-                ret *cs + \"<\" + str::connect(strs, \",\") + \">\";\n+                ret cs + \"<\" + str::connect(strs, \",\") + \">\";\n             }\n           }\n           _ {}\n         }\n-        ret *cs;\n+        ret cs;\n       }\n       _ { }\n     }\n-    ret alt struct(cx, typ) {\n+    ret alt ty::get(typ).struct {\n       ty_nil { \"()\" }\n       ty_bot { \"_|_\" }\n       ty_bool { \"bool\" }"}]}