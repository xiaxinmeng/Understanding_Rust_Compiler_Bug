{"sha": "fdd721e9ef4d330351769a7498d459a198bf0a0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZDcyMWU5ZWY0ZDMzMDM1MTc2OWE3NDk4ZDQ1OWExOThiZjBhMGI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-07T17:35:24Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-09T09:21:31Z"}, "message": "Improve indexing of impls\n\nStore impls for e.g. &Foo with the ones for Foo instead of the big\n\"other\" bucket. This can improve performance and simplifies the HIR impl\nsearch a bit.", "tree": {"sha": "5faf803211bb427d97d82e2e44ddc1b4ae6ca3c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5faf803211bb427d97d82e2e44ddc1b4ae6ca3c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd721e9ef4d330351769a7498d459a198bf0a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd721e9ef4d330351769a7498d459a198bf0a0b", "html_url": "https://github.com/rust-lang/rust/commit/fdd721e9ef4d330351769a7498d459a198bf0a0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd721e9ef4d330351769a7498d459a198bf0a0b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "354151df3556c5e2989746aa01a5aeb620ee9baa", "url": "https://api.github.com/repos/rust-lang/rust/commits/354151df3556c5e2989746aa01a5aeb620ee9baa", "html_url": "https://github.com/rust-lang/rust/commit/354151df3556c5e2989746aa01a5aeb620ee9baa"}], "stats": {"total": 113, "additions": 85, "deletions": 28}, "files": [{"sha": "eba46a056960eed00fe58dae1130c8edcdb3c655", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=fdd721e9ef4d330351769a7498d459a198bf0a0b", "patch": "@@ -1580,25 +1580,37 @@ impl Impl {\n             ty.equals_ctor(rref.as_ref().map_or(&self_ty.ty, |it| &it.ty))\n         };\n \n+        let fp = TyFingerprint::for_inherent_impl(&ty);\n+        let fp = if let Some(fp) = fp {\n+            fp\n+        } else {\n+            return Vec::new();\n+        };\n+\n         let mut all = Vec::new();\n         def_crates.iter().for_each(|&id| {\n-            all.extend(db.inherent_impls_in_crate(id).all_impls().map(Self::from).filter(filter))\n+            all.extend(\n+                db.inherent_impls_in_crate(id)\n+                    .for_self_ty(&ty)\n+                    .into_iter()\n+                    .cloned()\n+                    .map(Self::from)\n+                    .filter(filter),\n+            )\n         });\n-        let fp = TyFingerprint::for_impl(&ty);\n         for id in def_crates\n             .iter()\n             .flat_map(|&id| Crate { id }.transitive_reverse_dependencies(db))\n             .map(|Crate { id }| id)\n             .chain(def_crates.iter().copied())\n             .unique()\n         {\n-            match fp {\n-                Some(fp) => all.extend(\n-                    db.trait_impls_in_crate(id).for_self_ty(fp).map(Self::from).filter(filter),\n-                ),\n-                None => all\n-                    .extend(db.trait_impls_in_crate(id).all_impls().map(Self::from).filter(filter)),\n-            }\n+            all.extend(\n+                db.trait_impls_in_crate(id)\n+                    .for_self_ty_without_blanket_impls(fp)\n+                    .map(Self::from)\n+                    .filter(filter),\n+            );\n         }\n         all\n     }"}, {"sha": "55c7b1a09c52118bb1db39c68b948ba26708e0eb", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 63, "deletions": 18, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=fdd721e9ef4d330351769a7498d459a198bf0a0b", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::always;\n \n use crate::{\n     autoderef,\n@@ -21,50 +22,89 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     static_lifetime,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n-    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n+    Scalar, Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n+    // These are lang item impls:\n     Str,\n     Slice,\n     Array,\n     Never,\n     RawPtr(Mutability),\n     Scalar(Scalar),\n+    // These can have user-defined impls:\n     Adt(hir_def::AdtId),\n     Dyn(TraitId),\n-    Tuple(usize),\n     ForeignType(ForeignDefId),\n-    FnPtr(usize, FnSig),\n+    // These only exist for trait impls\n+    Unit,\n+    Unnameable,\n+    Function(u32),\n }\n \n impl TyFingerprint {\n-    /// Creates a TyFingerprint for looking up an impl. Only certain types can\n-    /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n-    /// `impl &S`. Hence, this will return `None` for reference types and such.\n-    pub fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n+    /// Creates a TyFingerprint for looking up an inherent impl. Only certain\n+    /// types can have inherent impls: if we have some `struct S`, we can have\n+    /// an `impl S`, but not `impl &S`. Hence, this will return `None` for\n+    /// reference types and such.\n+    pub fn for_inherent_impl(ty: &Ty) -> Option<TyFingerprint> {\n         let fp = match ty.kind(&Interner) {\n             TyKind::Str => TyFingerprint::Str,\n             TyKind::Never => TyFingerprint::Never,\n             TyKind::Slice(..) => TyFingerprint::Slice,\n             TyKind::Array(..) => TyFingerprint::Array,\n             TyKind::Scalar(scalar) => TyFingerprint::Scalar(*scalar),\n             TyKind::Adt(AdtId(adt), _) => TyFingerprint::Adt(*adt),\n-            TyKind::Tuple(cardinality, _) => TyFingerprint::Tuple(*cardinality),\n             TyKind::Raw(mutability, ..) => TyFingerprint::RawPtr(*mutability),\n             TyKind::Foreign(alias_id, ..) => TyFingerprint::ForeignType(*alias_id),\n-            TyKind::Function(FnPointer { sig, substitution: substs, .. }) => {\n-                TyFingerprint::FnPtr(substs.0.len(&Interner) - 1, *sig)\n-            }\n             TyKind::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n             _ => return None,\n         };\n         Some(fp)\n     }\n+\n+    /// Creates a TyFingerprint for looking up a trait impl.\n+    pub fn for_trait_impl(ty: &Ty) -> Option<TyFingerprint> {\n+        let fp = match ty.kind(&Interner) {\n+            TyKind::Str => TyFingerprint::Str,\n+            TyKind::Never => TyFingerprint::Never,\n+            TyKind::Slice(..) => TyFingerprint::Slice,\n+            TyKind::Array(..) => TyFingerprint::Array,\n+            TyKind::Scalar(scalar) => TyFingerprint::Scalar(*scalar),\n+            TyKind::Adt(AdtId(adt), _) => TyFingerprint::Adt(*adt),\n+            TyKind::Raw(mutability, ..) => TyFingerprint::RawPtr(*mutability),\n+            TyKind::Foreign(alias_id, ..) => TyFingerprint::ForeignType(*alias_id),\n+            TyKind::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n+            TyKind::Ref(_, _, ty) => return TyFingerprint::for_trait_impl(ty),\n+            TyKind::Tuple(_, subst) => {\n+                let first_ty = subst.interned().get(0).map(|arg| arg.assert_ty_ref(&Interner));\n+                if let Some(ty) = first_ty {\n+                    return TyFingerprint::for_trait_impl(ty);\n+                } else {\n+                    TyFingerprint::Unit\n+                }\n+            }\n+            TyKind::AssociatedType(_, _)\n+            | TyKind::OpaqueType(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Closure(_, _)\n+            | TyKind::Generator(..)\n+            | TyKind::GeneratorWitness(..) => TyFingerprint::Unnameable,\n+            TyKind::Function(fn_ptr) => {\n+                TyFingerprint::Function(fn_ptr.substitution.0.len(&Interner) as u32)\n+            }\n+            TyKind::Alias(_)\n+            | TyKind::Placeholder(_)\n+            | TyKind::BoundVar(_)\n+            | TyKind::InferenceVar(_, _)\n+            | TyKind::Error => return None,\n+        };\n+        Some(fp)\n+    }\n }\n \n pub(crate) const ALL_INT_FPS: [TyFingerprint; 12] = [\n@@ -112,7 +152,7 @@ impl TraitImpls {\n                         None => continue,\n                     };\n                     let self_ty = db.impl_self_ty(impl_id);\n-                    let self_ty_fp = TyFingerprint::for_impl(self_ty.skip_binders());\n+                    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty.skip_binders());\n                     impls\n                         .map\n                         .entry(target_trait)\n@@ -157,10 +197,13 @@ impl TraitImpls {\n     }\n \n     /// Queries all trait impls for the given type.\n-    pub fn for_self_ty(&self, fp: TyFingerprint) -> impl Iterator<Item = ImplId> + '_ {\n+    pub fn for_self_ty_without_blanket_impls(\n+        &self,\n+        fp: TyFingerprint,\n+    ) -> impl Iterator<Item = ImplId> + '_ {\n         self.map\n             .values()\n-            .flat_map(move |impls| impls.get(&None).into_iter().chain(impls.get(&Some(fp))))\n+            .flat_map(move |impls| impls.get(&Some(fp)).into_iter())\n             .flat_map(|it| it.iter().copied())\n     }\n \n@@ -215,7 +258,9 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                if let Some(fp) = TyFingerprint::for_impl(self_ty.skip_binders()) {\n+                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n+                always!(fp.is_some());\n+                if let Some(fp) = fp {\n                     map.entry(fp).or_default().push(impl_id);\n                 }\n             }\n@@ -228,7 +273,7 @@ impl InherentImpls {\n     }\n \n     pub fn for_self_ty(&self, self_ty: &Ty) -> &[ImplId] {\n-        match TyFingerprint::for_impl(self_ty) {\n+        match TyFingerprint::for_inherent_impl(self_ty) {\n             Some(fp) => self.map.get(&fp).map(|vec| vec.as_ref()).unwrap_or(&[]),\n             None => &[],\n         }"}, {"sha": "cd511477b9122f956083537b7b26f44ac02e4500", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd721e9ef4d330351769a7498d459a198bf0a0b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=fdd721e9ef4d330351769a7498d459a198bf0a0b", "patch": "@@ -101,7 +101,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             None\n         }\n \n-        let self_ty_fp = TyFingerprint::for_impl(&ty);\n+        let self_ty_fp = TyFingerprint::for_trait_impl(&ty);\n         let fps: &[TyFingerprint] = match binder_kind(&ty, binders) {\n             Some(chalk_ir::TyVariableKind::Integer) => &ALL_INT_FPS,\n             Some(chalk_ir::TyVariableKind::Float) => &ALL_FLOAT_FPS,"}]}