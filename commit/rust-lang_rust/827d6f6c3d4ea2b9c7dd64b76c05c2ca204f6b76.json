{"sha": "827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyN2Q2ZjZjM2Q0ZWEyYjljN2RkNjRiNzZjMDVjMmNhMjA0ZjZiNzY=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-04-29T13:49:48Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-04-29T13:50:21Z"}, "message": "document stable counterparts of intrinsics", "tree": {"sha": "c1d25e341aeb9a57b118df6149964ba90e161763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1d25e341aeb9a57b118df6149964ba90e161763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "html_url": "https://github.com/rust-lang/rust/commit/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9312a8db30b9eb345baf7ebaba6d92061d49096", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9312a8db30b9eb345baf7ebaba6d92061d49096", "html_url": "https://github.com/rust-lang/rust/commit/d9312a8db30b9eb345baf7ebaba6d92061d49096"}], "stats": {"total": 98, "additions": 86, "deletions": 12}, "files": [{"sha": "962bcbe61985b18eeb621d9755b08350b4ebeb04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 84, "deletions": 12, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "patch": "@@ -782,36 +782,43 @@ extern \"rust-intrinsic\" {\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n }\n \n extern \"rust-intrinsic\" {\n-\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n@@ -905,12 +912,14 @@ extern \"rust-intrinsic\" {\n     /// that `rustc_peek(potentially_uninitialized)` would actually\n     /// double-check that dataflow did indeed compute that it is\n     /// uninitialized at that point in the control flow.\n+    ///\n+    /// This intrinsic should not be used outside of the compiler.\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::process::abort`](../../std/process/fn.abort.html)\n+    /// [`std::process::abort`](../../std/process/fn.abort.html).\n     pub fn abort() -> !;\n \n     /// Tells LLVM that this point in the code is not reachable, enabling\n@@ -932,21 +941,29 @@ extern \"rust-intrinsic\" {\n     /// with optimization of surrounding code and reduce performance. It should\n     /// not be used if the invariant can be discovered by the optimizer on its\n     /// own, or if it does not enable any significant optimizations.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -973,6 +990,9 @@ extern \"rust-intrinsic\" {\n     /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n+    /// The prefered alignment of a type.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n     pub fn pref_align_of<T>() -> usize;\n \n@@ -981,6 +1001,10 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n+    /// The required alignment of the referenced value.\n+    ///\n+    /// The stabilized version of this intrinsic is\n+    /// [`std::mem::align_of_val`](../../std/mem/fn.align_of_val.html).\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -1001,22 +1025,33 @@ extern \"rust-intrinsic\" {\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n     /// This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n     /// zero-initialization: This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` has invalid\n     /// bit patterns: This will statically either panic, or do nothing.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn assert_uninit_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n+    ///\n+    /// Consider using [`std::panic::Location::caller`](../../std/panic/struct.Location.html#method.caller)\n+    /// instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n-    /// This exists solely for `mem::forget_unsized`; normal `forget` uses `ManuallyDrop` instead.\n+    ///\n+    /// This exists solely for [`mem::forget_unsized`](../../std/mem/fn.forget_unsized.html);\n+    /// normal `forget` uses `ManuallyDrop` instead.\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1300,20 +1335,26 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n     /// The volatile parameter is set to `true`, so it will not be optimized out\n     /// unless size is equal to zero.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n@@ -1329,9 +1370,13 @@ extern \"rust-intrinsic\" {\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n@@ -1539,8 +1584,12 @@ extern \"rust-intrinsic\" {\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n@@ -1556,28 +1605,39 @@ extern \"rust-intrinsic\" {\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n-    /// Stabilized as `f32::to_int_unchecked` and `f64::to_int_unchecked`.\n+    /// Stabilized as [`f32::to_int_unchecked`](../../std/primitive.f32.html#method.to_int_unchecked)\n+    /// and [`f64::to_int_unchecked`](../../std/primitive.f64.html#method.to_int_unchecked).\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1623,6 +1683,8 @@ extern \"rust-intrinsic\" {\n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n     ///\n+    /// This intrinsic does not have a stable counterpart.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1672,6 +1734,8 @@ extern \"rust-intrinsic\" {\n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n     /// given an `x` with value `0`.\n     ///\n+    /// This intrinsic does not have a stable counterpart.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1728,20 +1792,22 @@ extern \"rust-intrinsic\" {\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::MIN` and y = -1\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n     /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n@@ -1750,32 +1816,38 @@ extern \"rust-intrinsic\" {\n     /// Performs an unchecked left shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shl` method. For example,\n     /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n-    /// The stabilized versions of this intrinsic are available on the integer\n+    /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n     /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n "}, {"sha": "1ffd493d8130ba677c939f7da69e614fc9721266", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=827d6f6c3d4ea2b9c7dd64b76c05c2ca204f6b76", "patch": "@@ -228,6 +228,8 @@ impl<'a> Location<'a> {\n     /// assert_ne!(this_location.line(), another_location.line());\n     /// assert_ne!(this_location.column(), another_location.column());\n     /// ```\n+    // FIXME: When stabilizing this method, please also update the documentation\n+    // of `intrinsics::caller_location`.\n     #[unstable(\n         feature = \"track_caller\",\n         reason = \"uses #[track_caller] which is not yet stable\","}]}