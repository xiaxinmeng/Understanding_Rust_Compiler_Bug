{"sha": "2a280de64fb34378174fa33b6866a7ee920ceb8d", "node_id": "C_kwDOAAsO6NoAKDJhMjgwZGU2NGZiMzQzNzgxNzRmYTMzYjY4NjZhN2VlOTIwY2ViOGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-02T05:32:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-02T05:32:00Z"}, "message": "Auto merge of #94514 - matthiaskrgr:rollup-pdzn82h, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #94464 (Suggest adding a new lifetime parameter when two elided lifetimes should match up for traits and impls.)\n - #94476 (7 - Make more use of `let_chains`)\n - #94478 (Fix panic when handling intra doc links generated from macro)\n - #94482 (compiler: fix some typos)\n - #94490 (Update books)\n - #94496 (tests: accept llvm intrinsic in align-checking test)\n - #94498 (9 - Make more use of `let_chains`)\n - #94503 (Provide C FFI types via core::ffi, not just in std)\n - #94513 (update Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9399eae34b3e1e5526e28c18d78d10b37afdb221", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9399eae34b3e1e5526e28c18d78d10b37afdb221"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a280de64fb34378174fa33b6866a7ee920ceb8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a280de64fb34378174fa33b6866a7ee920ceb8d", "html_url": "https://github.com/rust-lang/rust/commit/2a280de64fb34378174fa33b6866a7ee920ceb8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a280de64fb34378174fa33b6866a7ee920ceb8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39a3b527674c1c8d2b9d3edc0cfae67abe6b3ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a3b527674c1c8d2b9d3edc0cfae67abe6b3ecb", "html_url": "https://github.com/rust-lang/rust/commit/39a3b527674c1c8d2b9d3edc0cfae67abe6b3ecb"}, {"sha": "e89ab08f11332f11d8b574b43f11b9d7b3c18346", "url": "https://api.github.com/repos/rust-lang/rust/commits/e89ab08f11332f11d8b574b43f11b9d7b3c18346", "html_url": "https://github.com/rust-lang/rust/commit/e89ab08f11332f11d8b574b43f11b9d7b3c18346"}], "stats": {"total": 1440, "additions": 873, "deletions": 567}, "files": [{"sha": "e8fca6f04ba5b4bfd88afb289186f368d60ffcf5", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1366,7 +1366,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         generics: &Generics,\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n-        // Error if `?Trait` bounds in where clauses don't refer directly to type paramters.\n+        // Error if `?Trait` bounds in where clauses don't refer directly to type parameters.\n         // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n         // these into hir when we lower thee where clauses), but this makes it quite difficult to\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and"}, {"sha": "fa9fe905256f5ac6daf84d49b27ebf43583b238d", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1992,7 +1992,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .find_map(|constraint| {\n                 if let ConstraintCategory::Predicate(predicate_span) = constraint.category {\n                     // We currentl'y doesn't store the `DefId` in the `ConstraintCategory`\n-                    // for perforamnce reasons. The error reporting code used by NLL only\n+                    // for performances reasons. The error reporting code used by NLL only\n                     // uses the span, so this doesn't cause any problems at the moment.\n                     Some(ObligationCauseCode::BindingObligation(\n                         CRATE_DEF_ID.to_def_id(),"}, {"sha": "8574cfae86092660b943a7124afb9f1ebff3547c", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -201,7 +201,7 @@ impl CfgEval<'_, '_> {\n \n         // Re-parse the tokens, setting the `capture_cfg` flag to save extra information\n         // to the captured `AttrAnnotatedTokenStream` (specifically, we capture\n-        // `AttrAnnotatedTokenTree::AttributesData` for all occurences of `#[cfg]` and `#[cfg_attr]`)\n+        // `AttrAnnotatedTokenTree::AttributesData` for all occurrences of `#[cfg]` and `#[cfg_attr]`)\n         let mut parser =\n             rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n         parser.capture_cfg = true;"}, {"sha": "b36645ad37b935056b031fc381db0d4274055749", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -989,7 +989,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n         // ... and otherwise we're processing a `*.dwp` packed dwarf file.\n         //\n-        // We cannot rely on the .o paths in the exectuable because they may have been\n+        // We cannot rely on the .o paths in the executable because they may have been\n         // remapped by --remap-path-prefix and therefore invalid, so we need to provide\n         // the .o/.dwo paths explicitly.\n         SplitDebuginfo::Packed => link_dwarf_object(sess, codegen_results, out_filename),"}, {"sha": "a838787381d3f6f2dc825b22993b213062e45143", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1338,7 +1338,7 @@ impl<'a> Linker for WasmLd<'a> {\n         }\n \n         // LLD will hide these otherwise-internal symbols since it only exports\n-        // symbols explicity passed via the `--export` flags above and hides all\n+        // symbols explicitly passed via the `--export` flags above and hides all\n         // others. Various bits and pieces of tooling use this, so be sure these\n         // symbols make their way out of the linker as well.\n         self.cmd.arg(\"--export=__heap_base\");"}, {"sha": "131eeef4582de6fc35df95d90470cf9881bf48e1", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,7 +7,7 @@ use std::iter::Iterator;\n /// one of two specific implementations.\n ///\n /// Note: For most methods providing custom\n-///       implementation may margianlly\n+///       implementation may marginally\n ///       improve performance by avoiding\n ///       doing Left/Right match on every step\n ///       and doing it only once instead."}, {"sha": "4c93d661fd2fd8b9c4e3e9599fcbe4ee09f53db1", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -50,7 +50,7 @@ impl DefPathTable {\n             // Continuing with colliding DefPathHashes can lead to correctness\n             // issues. We must abort compilation.\n             //\n-            // The likelyhood of such a collision is very small, so actually\n+            // The likelihood of such a collision is very small, so actually\n             // running into one could be indicative of a poor hash function\n             // being used.\n             //"}, {"sha": "d7e88d02595e4d5e7bbf9f4d8c3514b0c9749af1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -166,59 +166,61 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if lifetime_sub.name.is_elided() && lifetime_sup.name.is_elided() {\n                 if let Some(anon_reg) = self.tcx().is_suitable_region(sub) {\n                     let hir_id = self.tcx().hir().local_def_id_to_hir_id(anon_reg.def_id);\n-                    if let hir::Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Fn(_, ref generics, ..),\n-                        ..\n-                    }) = self.tcx().hir().get(hir_id)\n-                    {\n-                        let (suggestion_param_name, introduce_new) = generics\n-                            .params\n-                            .iter()\n-                            .find(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-                            .and_then(|p| self.tcx().sess.source_map().span_to_snippet(p.span).ok())\n-                            .map(|name| (name, false))\n-                            .unwrap_or_else(|| (\"'a\".to_string(), true));\n-\n-                        let mut suggestions = vec![\n-                            if let hir::LifetimeName::Underscore = lifetime_sub.name {\n-                                (lifetime_sub.span, suggestion_param_name.clone())\n-                            } else {\n-                                (\n-                                    lifetime_sub.span.shrink_to_hi(),\n-                                    suggestion_param_name.clone() + \" \",\n-                                )\n-                            },\n-                            if let hir::LifetimeName::Underscore = lifetime_sup.name {\n-                                (lifetime_sup.span, suggestion_param_name.clone())\n-                            } else {\n-                                (\n-                                    lifetime_sup.span.shrink_to_hi(),\n-                                    suggestion_param_name.clone() + \" \",\n-                                )\n-                            },\n-                        ];\n-\n-                        if introduce_new {\n-                            let new_param_suggestion = match &generics.params {\n-                                [] => (generics.span, format!(\"<{}>\", suggestion_param_name)),\n-                                [first, ..] => (\n-                                    first.span.shrink_to_lo(),\n-                                    format!(\"{}, \", suggestion_param_name),\n-                                ),\n-                            };\n-\n-                            suggestions.push(new_param_suggestion);\n-                        }\n-\n-                        err.multipart_suggestion(\n-                            \"consider introducing a named lifetime parameter\",\n-                            suggestions,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        err.note(\n-                            \"each elided lifetime in input position becomes a distinct lifetime\",\n-                        );\n+\n+                    let node = self.tcx().hir().get(hir_id);\n+                    let is_impl = matches!(&node, hir::Node::ImplItem(_));\n+                    let generics = match node {\n+                        hir::Node::Item(&hir::Item {\n+                            kind: hir::ItemKind::Fn(_, ref generics, ..),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n+                        | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n+                        _ => return,\n+                    };\n+\n+                    let (suggestion_param_name, introduce_new) = generics\n+                        .params\n+                        .iter()\n+                        .find(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+                        .and_then(|p| self.tcx().sess.source_map().span_to_snippet(p.span).ok())\n+                        .map(|name| (name, false))\n+                        .unwrap_or_else(|| (\"'a\".to_string(), true));\n+\n+                    let mut suggestions = vec![\n+                        if let hir::LifetimeName::Underscore = lifetime_sub.name {\n+                            (lifetime_sub.span, suggestion_param_name.clone())\n+                        } else {\n+                            (lifetime_sub.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n+                        },\n+                        if let hir::LifetimeName::Underscore = lifetime_sup.name {\n+                            (lifetime_sup.span, suggestion_param_name.clone())\n+                        } else {\n+                            (lifetime_sup.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n+                        },\n+                    ];\n+\n+                    if introduce_new {\n+                        let new_param_suggestion = match &generics.params {\n+                            [] => (generics.span, format!(\"<{}>\", suggestion_param_name)),\n+                            [first, ..] => {\n+                                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+                            }\n+                        };\n+\n+                        suggestions.push(new_param_suggestion);\n+                    }\n+\n+                    let mut sugg = String::from(\"consider introducing a named lifetime parameter\");\n+                    if is_impl {\n+                        sugg.push_str(\" and update trait if needed\");\n                     }\n+                    err.multipart_suggestion(\n+                        sugg.as_str(),\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    err.note(\"each elided lifetime in input position becomes a distinct lifetime\");\n                 }\n             }\n         }"}, {"sha": "ef4b27a15d8b80bb96a010c3c16c263d74c64be0", "filename": "compiler/rustc_mir_transform/src/const_debuginfo.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_debuginfo.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -55,10 +55,8 @@ fn find_optimization_oportunities<'tcx>(body: &Body<'tcx>) -> Vec<(Local, Consta\n \n     let mut locals_to_debuginfo = BitSet::new_empty(body.local_decls.len());\n     for debuginfo in &body.var_debug_info {\n-        if let VarDebugInfoContents::Place(p) = debuginfo.value {\n-            if let Some(l) = p.as_local() {\n-                locals_to_debuginfo.insert(l);\n-            }\n+        if let VarDebugInfoContents::Place(p) = debuginfo.value && let Some(l) = p.as_local() {\n+            locals_to_debuginfo.insert(l);\n         }\n     }\n "}, {"sha": "c5ef1e101460ff7aebbb759a1f0b54bb2b09da79", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -633,24 +633,22 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n         match *operand {\n             Operand::Copy(l) | Operand::Move(l) => {\n-                if let Some(value) = self.get_const(l) {\n-                    if self.should_const_prop(&value) {\n-                        // FIXME(felix91gr): this code only handles `Scalar` cases.\n-                        // For now, we're not handling `ScalarPair` cases because\n-                        // doing so here would require a lot of code duplication.\n-                        // We should hopefully generalize `Operand` handling into a fn,\n-                        // and use it to do const-prop here and everywhere else\n-                        // where it makes sense.\n-                        if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n-                            ScalarMaybeUninit::Scalar(scalar),\n-                        )) = *value\n-                        {\n-                            *operand = self.operand_from_scalar(\n-                                scalar,\n-                                value.layout.ty,\n-                                self.source_info.unwrap().span,\n-                            );\n-                        }\n+                if let Some(value) = self.get_const(l) && self.should_const_prop(&value) {\n+                    // FIXME(felix91gr): this code only handles `Scalar` cases.\n+                    // For now, we're not handling `ScalarPair` cases because\n+                    // doing so here would require a lot of code duplication.\n+                    // We should hopefully generalize `Operand` handling into a fn,\n+                    // and use it to do const-prop here and everywhere else\n+                    // where it makes sense.\n+                    if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n+                        ScalarMaybeUninit::Scalar(scalar),\n+                    )) = *value\n+                    {\n+                        *operand = self.operand_from_scalar(\n+                            scalar,\n+                            value.layout.ty,\n+                            self.source_info.unwrap().span,\n+                        );\n                     }\n                 }\n             }\n@@ -1086,15 +1084,13 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 // This will return None if the above `const_prop` invocation only \"wrote\" a\n                 // type whose creation requires no write. E.g. a generator whose initial state\n                 // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(ref value) = self.get_const(place) {\n-                    if self.should_const_prop(value) {\n-                        trace!(\"replacing {:?} with {:?}\", rval, value);\n-                        self.replace_with_const(rval, value, source_info);\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                        {\n-                            trace!(\"propagated into {:?}\", place);\n-                        }\n+                if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n+                    trace!(\"replacing {:?} with {:?}\", rval, value);\n+                    self.replace_with_const(rval, value, source_info);\n+                    if can_const_prop == ConstPropMode::FullConstProp\n+                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                    {\n+                        trace!(\"propagated into {:?}\", place);\n                     }\n                 }\n                 match can_const_prop {"}, {"sha": "8e28ed2426bbb0fa99083e079c9cc1fd8889eb1a", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -357,14 +357,12 @@ impl DebugCounters {\n         if let Some(counters) = &self.some_counters {\n             if let Some(DebugCounter { counter_kind, some_block_label }) = counters.get(&operand) {\n                 if let CoverageKind::Expression { .. } = counter_kind {\n-                    if let Some(block_label) = some_block_label {\n-                        if debug_options().counter_format.block {\n-                            return format!(\n-                                \"{}:({})\",\n-                                block_label,\n-                                self.format_counter_kind(counter_kind)\n-                            );\n-                        }\n+                    if let Some(label) = some_block_label && debug_options().counter_format.block {\n+                        return format!(\n+                            \"{}:({})\",\n+                            label,\n+                            self.format_counter_kind(counter_kind)\n+                        );\n                     }\n                     return format!(\"({})\", self.format_counter_kind(counter_kind));\n                 }"}, {"sha": "a36ba9300e4ff9bbbd9a97a31664c0aa0ebceee3", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -191,16 +191,13 @@ impl CoverageSpan {\n     /// If the span is part of a macro, and the macro is visible (expands directly to the given\n     /// body_span), returns the macro name symbol.\n     pub fn visible_macro(&self, body_span: Span) -> Option<Symbol> {\n-        if let Some(current_macro) = self.current_macro() {\n-            if self\n-                .expn_span\n-                .parent_callsite()\n-                .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n-                .ctxt()\n-                == body_span.ctxt()\n-            {\n-                return Some(current_macro);\n-            }\n+        if let Some(current_macro) = self.current_macro() && self\n+            .expn_span\n+            .parent_callsite()\n+            .unwrap_or_else(|| bug!(\"macro must have a parent\"))\n+            .ctxt() == body_span.ctxt()\n+        {\n+            return Some(current_macro);\n         }\n         None\n     }\n@@ -584,21 +581,19 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// In either case, no more spans will match the span of `pending_dups`, so\n     /// add the `pending_dups` if they don't overlap `curr`, and clear the list.\n     fn check_pending_dups(&mut self) {\n-        if let Some(dup) = self.pending_dups.last() {\n-            if dup.span != self.prev().span {\n-                debug!(\n-                    \"    SAME spans, but pending_dups are NOT THE SAME, so BCBs matched on \\\n-                    previous iteration, or prev started a new disjoint span\"\n-                );\n-                if dup.span.hi() <= self.curr().span.lo() {\n-                    let pending_dups = self.pending_dups.split_off(0);\n-                    for dup in pending_dups.into_iter() {\n-                        debug!(\"    ...adding at least one pending={:?}\", dup);\n-                        self.push_refined_span(dup);\n-                    }\n-                } else {\n-                    self.pending_dups.clear();\n+        if let Some(dup) = self.pending_dups.last() && dup.span != self.prev().span {\n+            debug!(\n+                \"    SAME spans, but pending_dups are NOT THE SAME, so BCBs matched on \\\n+                previous iteration, or prev started a new disjoint span\"\n+            );\n+            if dup.span.hi() <= self.curr().span.lo() {\n+                let pending_dups = self.pending_dups.split_off(0);\n+                for dup in pending_dups.into_iter() {\n+                    debug!(\"    ...adding at least one pending={:?}\", dup);\n+                    self.push_refined_span(dup);\n                 }\n+            } else {\n+                self.pending_dups.clear();\n             }\n         }\n     }"}, {"sha": "5d0b58e9c53604cf00035359ca4a29c8c24f805f", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -549,14 +549,15 @@ impl<'a> Conflicts<'a> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                if let Some(place) = value.place() {\n-                    if !place.is_indirect() && !dropped_place.is_indirect() {\n-                        self.record_local_conflict(\n-                            place.local,\n-                            dropped_place.local,\n-                            \"DropAndReplace operand overlap\",\n-                        );\n-                    }\n+                if let Some(place) = value.place()\n+                    && !place.is_indirect()\n+                    && !dropped_place.is_indirect()\n+                {\n+                    self.record_local_conflict(\n+                        place.local,\n+                        dropped_place.local,\n+                        \"DropAndReplace operand overlap\",\n+                    );\n                 }\n             }\n             TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n@@ -614,14 +615,15 @@ impl<'a> Conflicts<'a> {\n                             for op in operands {\n                                 match op {\n                                     InlineAsmOperand::In { reg: _, value } => {\n-                                        if let Some(p) = value.place() {\n-                                            if !p.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    p.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(p) = value.place()\n+                                            && !p.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                p.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n                                     }\n                                     InlineAsmOperand::Out {\n@@ -643,24 +645,26 @@ impl<'a> Conflicts<'a> {\n                                         in_value,\n                                         out_place,\n                                     } => {\n-                                        if let Some(place) = in_value.place() {\n-                                            if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    place.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(place) = in_value.place()\n+                                            && !place.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n \n-                                        if let Some(place) = out_place {\n-                                            if !place.is_indirect() && !dest_place.is_indirect() {\n-                                                self.record_local_conflict(\n-                                                    place.local,\n-                                                    dest_place.local,\n-                                                    \"asm! operand overlap\",\n-                                                );\n-                                            }\n+                                        if let Some(place) = out_place\n+                                            && !place.is_indirect()\n+                                            && !dest_place.is_indirect()\n+                                        {\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n                                         }\n                                     }\n                                     InlineAsmOperand::Out { reg: _, late: _, place: None }"}, {"sha": "23e5f0b4f30c3a394de5fab5b0f449b472fd1661", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -724,12 +724,11 @@ impl<'tcx> Inliner<'tcx> {\n         caller_body: &mut Body<'tcx>,\n     ) -> Local {\n         // Reuse the operand if it is a moved temporary.\n-        if let Operand::Move(place) = &arg {\n-            if let Some(local) = place.as_local() {\n-                if caller_body.local_kind(local) == LocalKind::Temp {\n-                    return local;\n-                }\n-            }\n+        if let Operand::Move(place) = &arg\n+            && let Some(local) = place.as_local()\n+            && caller_body.local_kind(local) == LocalKind::Temp\n+        {\n+            return local;\n         }\n \n         // Otherwise, create a temporary for the argument."}, {"sha": "385fcc43496e3695d635d57eac0ff712939defa4", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -77,10 +77,8 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n                     _ => None,\n                 };\n \n-                if let Some(new) = new {\n-                    if self.should_combine(source_info, rvalue) {\n-                        *rvalue = new;\n-                    }\n+                if let Some(new) = new && self.should_combine(source_info, rvalue) {\n+                    *rvalue = new;\n                 }\n             }\n "}, {"sha": "3b2332a6e31422bcfdb5b06b213900ce8aef1fea", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1,16 +1,17 @@\n+#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n-#![feature(option_get_or_insert_default)]\n-#![feature(once_cell)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n+#![feature(option_get_or_insert_default)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "b87220a3aa4f38eafce201c7711025d2d6ad3c5f", "filename": "compiler/rustc_mir_transform/src/required_consts.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Frequired_consts.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -14,10 +14,9 @@ impl<'a, 'tcx> RequiredConstsVisitor<'a, 'tcx> {\n \n impl<'tcx> Visitor<'tcx> for RequiredConstsVisitor<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, _: Location) {\n-        if let Some(ct) = constant.literal.const_for_ty() {\n-            if let ConstKind::Unevaluated(_) = ct.val() {\n-                self.required_consts.push(*constant);\n-            }\n+        let literal = constant.literal;\n+        if let Some(ct) = literal.const_for_ty() && let ConstKind::Unevaluated(_) = ct.val() {\n+            self.required_consts.push(*constant);\n         }\n     }\n }"}, {"sha": "7523b8441013a6a179df8a4b2aa613b1ec86ac0b", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -10,19 +10,20 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n+#![feature(control_flow_enum)]\n+#![feature(crate_visibility_modifier)]\n #![feature(derive_default_enum)]\n+#![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n #![feature(label_break_value)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"512\"] // For rustdoc\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "8e42a41c8cf61eaa99a6f3a0bf785c5c15f50065", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1098,42 +1098,43 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-                if fields.len() == found_args.len() && is_closure {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        found_args\n-                            .iter()\n-                            .map(|arg| match arg {\n-                                ArgKind::Arg(name, _) => name.to_owned(),\n-                                _ => \"_\".to_owned(),\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                        // add type annotations if available\n-                        if found_args.iter().any(|arg| match arg {\n-                            ArgKind::Arg(_, ty) => ty != \"_\",\n-                            _ => false,\n-                        }) {\n-                            format!(\n-                                \": ({})\",\n-                                fields\n-                                    .iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            )\n-                        } else {\n-                            String::new()\n-                        },\n-                    );\n-                    err.span_suggestion_verbose(\n-                        found_span,\n-                        \"change the closure to accept a tuple instead of individual arguments\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..]\n+                && fields.len() == found_args.len()\n+                && is_closure\n+            {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args\n+                        .iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\n+                            \": ({})\",\n+                            fields\n+                                .iter()\n+                                .map(|(_, ty)| ty.to_owned())\n+                                .collect::<Vec<String>>()\n+                                .join(\", \")\n+                        )\n+                    } else {\n+                        String::new()\n+                    },\n+                );\n+                err.span_suggestion_verbose(\n+                    found_span,\n+                    \"change the closure to accept a tuple instead of individual arguments\",\n+                    sugg,\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         }\n \n@@ -2231,16 +2232,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             if obligated_types.iter().any(|ot| ot == &self_ty) {\n                 return true;\n             }\n-            if let ty::Adt(def, substs) = self_ty.kind() {\n-                if let [arg] = &substs[..] {\n-                    if let ty::subst::GenericArgKind::Type(ty) = arg.unpack() {\n-                        if let ty::Adt(inner_def, _) = ty.kind() {\n-                            if inner_def == def {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n+            if let ty::Adt(def, substs) = self_ty.kind()\n+                && let [arg] = &substs[..]\n+                && let ty::subst::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Adt(inner_def, _) = ty.kind()\n+                && inner_def == def\n+            {\n+                return true;\n             }\n         }\n         false"}, {"sha": "7af2ba8b30f87ee351cef7c0e2ff960d00abe81d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -891,23 +891,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                         if let Some(typeck_results) =\n                             self.in_progress_typeck_results.map(|t| t.borrow())\n+                            && let ty = typeck_results.expr_ty_adjusted(base)\n+                            && let ty::FnDef(def_id, _substs) = ty.kind()\n+                            && let Some(hir::Node::Item(hir::Item { span, ident, .. })) =\n+                                hir.get_if_local(*def_id)\n                         {\n-                            let ty = typeck_results.expr_ty_adjusted(base);\n-                            if let ty::FnDef(def_id, _substs) = ty.kind() {\n-                                if let Some(hir::Node::Item(hir::Item { span, ident, .. })) =\n-                                    hir.get_if_local(*def_id)\n-                                {\n-                                    err.span_suggestion_verbose(\n-                                        span.shrink_to_lo(),\n-                                        &format!(\n-                                            \"alternatively, consider making `fn {}` asynchronous\",\n-                                            ident\n-                                        ),\n-                                        \"async \".to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n+                            err.span_suggestion_verbose(\n+                                span.shrink_to_lo(),\n+                                &format!(\n+                                    \"alternatively, consider making `fn {}` asynchronous\",\n+                                    ident\n+                                ),\n+                                \"async \".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n                     }\n                 }\n@@ -1000,34 +997,24 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n-        let is_empty_tuple =\n-            |ty: ty::Binder<'tcx, Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n-\n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n-        if let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n-        })) = node\n+        if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })) = node\n+            && let body = hir.body(*body_id)\n+            && let hir::ExprKind::Block(blk, _) = &body.value.kind\n+            && sig.decl.output.span().overlaps(span)\n+            && blk.expr.is_none()\n+            && *trait_pred.self_ty().skip_binder().kind() == ty::Tuple(ty::List::empty())\n+            // FIXME(estebank): When encountering a method with a trait\n+            // bound not satisfied in the return type with a body that has\n+            // no return, suggest removal of semicolon on last statement.\n+            // Once that is added, close #54771.\n+            && let Some(stmt) = blk.stmts.last()\n+            && let hir::StmtKind::Semi(_) = stmt.kind\n         {\n-            let body = hir.body(*body_id);\n-            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n-                if sig.decl.output.span().overlaps(span)\n-                    && blk.expr.is_none()\n-                    && is_empty_tuple(trait_pred.self_ty())\n-                {\n-                    // FIXME(estebank): When encountering a method with a trait\n-                    // bound not satisfied in the return type with a body that has\n-                    // no return, suggest removal of semicolon on last statement.\n-                    // Once that is added, close #54771.\n-                    if let Some(ref stmt) = blk.stmts.last() {\n-                        if let hir::StmtKind::Semi(_) = stmt.kind {\n-                            let sp = self.tcx.sess.source_map().end_point(stmt.span);\n-                            err.span_label(sp, \"consider removing this semicolon\");\n-                        }\n-                    }\n-                }\n-            }\n+            let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+            err.span_label(sp, \"consider removing this semicolon\");\n         }\n     }\n \n@@ -2481,17 +2468,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n                 if self.predicate_may_hold(&try_obligation)\n                     && impls_future.must_apply_modulo_regions()\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                    && snippet.ends_with('?')\n                 {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        if snippet.ends_with('?') {\n-                            err.span_suggestion_verbose(\n-                                span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n-                                \"consider `await`ing on the `Future`\",\n-                                \".await\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n+                    err.span_suggestion_verbose(\n+                        span.with_hi(span.hi() - BytePos(1)).shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n         }"}, {"sha": "7fbdd3689a7eb5d89fcfc125e26da21d88c5cfe5", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -91,10 +91,8 @@ impl<'tcx> OnUnimplementedDirective {\n                     )\n                 })?;\n             attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |item| {\n-                if let Some(symbol) = item.value_str() {\n-                    if parse_value(symbol).is_err() {\n-                        errored = true;\n-                    }\n+                if let Some(symbol) = item.value_str() && parse_value(symbol).is_err() {\n+                    errored = true;\n                 }\n                 true\n             });\n@@ -232,24 +230,22 @@ impl<'tcx> OnUnimplementedDirective {\n             options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n-            if let Some(ref condition) = command.condition {\n-                if !attr::eval_condition(\n-                    condition,\n-                    &tcx.sess.parse_sess,\n-                    Some(tcx.features()),\n-                    &mut |c| {\n-                        c.ident().map_or(false, |ident| {\n-                            let value = c.value_str().map(|s| {\n-                                OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n-                            });\n+            if let Some(ref condition) = command.condition && !attr::eval_condition(\n+                condition,\n+                &tcx.sess.parse_sess,\n+                Some(tcx.features()),\n+                &mut |c| {\n+                    c.ident().map_or(false, |ident| {\n+                        let value = c.value_str().map(|s| {\n+                            OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n+                        });\n \n-                            options.contains(&(ident.name, value))\n-                        })\n-                    },\n-                ) {\n-                    debug!(\"evaluate: skipping {:?} due to condition\", command);\n-                    continue;\n-                }\n+                        options.contains(&(ident.name, value))\n+                    })\n+                },\n+            ) {\n+                debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                continue;\n             }\n             debug!(\"evaluate: {:?} succeeded\", command);\n             if let Some(ref message_) = command.message {"}, {"sha": "435d709d37e60987cc30676d1fe79b90571edb25", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -43,21 +43,19 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         let c_ty = self.infcx.canonicalize_query(self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = tcx.dropck_outlives(c_ty) {\n-            if result.is_proven() {\n-                if let Ok(InferOk { value, obligations }) =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n-                        self.cause,\n-                        self.param_env,\n-                        &orig_values,\n-                        result,\n-                    )\n-                {\n-                    let ty = self.infcx.resolve_vars_if_possible(ty);\n-                    let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n-                    return InferOk { value: kinds, obligations };\n-                }\n-            }\n+        if let Ok(result) = tcx.dropck_outlives(c_ty)\n+            && result.is_proven()\n+            && let Ok(InferOk { value, obligations }) =\n+                self.infcx.instantiate_query_response_and_region_obligations(\n+                    self.cause,\n+                    self.param_env,\n+                    &orig_values,\n+                    result,\n+                )\n+        {\n+            let ty = self.infcx.resolve_vars_if_possible(ty);\n+            let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n+            return InferOk { value: kinds, obligations };\n         }\n \n         // Errors and ambiuity in dropck occur in two cases:"}, {"sha": "b13646ba1a0c27e4a24154c0836d5acbb5b51349", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -12,50 +12,38 @@ pub(crate) fn update<'tcx, T>(\n     T: TraitEngine<'tcx>,\n {\n     // (*) binder skipped\n-    if let ty::PredicateKind::Trait(predicate) = obligation.predicate.kind().skip_binder() {\n-        if let Some(ty) =\n-            infcx.shallow_resolve(predicate.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n-        {\n-            if infcx\n-                .tcx\n-                .lang_items()\n-                .sized_trait()\n-                .map_or(false, |st| st != predicate.trait_ref.def_id)\n-            {\n-                let new_self_ty = infcx.tcx.types.unit;\n+    if let ty::PredicateKind::Trait(tpred) = obligation.predicate.kind().skip_binder()\n+        && let Some(ty) = infcx.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n+        && infcx.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+    {\n+        let new_self_ty = infcx.tcx.types.unit;\n \n-                let trait_ref = ty::TraitRef {\n-                    substs: infcx\n-                        .tcx\n-                        .mk_substs_trait(new_self_ty, &predicate.trait_ref.substs[1..]),\n-                    ..predicate.trait_ref\n-                };\n+        let trait_ref = ty::TraitRef {\n+            substs: infcx.tcx.mk_substs_trait(new_self_ty, &tpred.trait_ref.substs[1..]),\n+            ..tpred.trait_ref\n+        };\n \n-                // Then contstruct a new obligation with Self = () added\n-                // to the ParamEnv, and see if it holds.\n-                let o = rustc_infer::traits::Obligation::new(\n-                    ObligationCause::dummy(),\n-                    obligation.param_env,\n-                    obligation\n-                        .predicate\n-                        .kind()\n-                        .map_bound(|_| {\n-                            // (*) binder moved here\n-                            ty::PredicateKind::Trait(ty::TraitPredicate {\n-                                trait_ref,\n-                                constness: predicate.constness,\n-                                polarity: predicate.polarity,\n-                            })\n-                        })\n-                        .to_predicate(infcx.tcx),\n-                );\n-                // Don't report overflow errors. Otherwise equivalent to may_hold.\n-                if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) {\n-                    if result.may_apply() {\n-                        engine.relationships().entry(ty).or_default().self_in_trait = true;\n-                    }\n-                }\n-            }\n+        // Then contstruct a new obligation with Self = () added\n+        // to the ParamEnv, and see if it holds.\n+        let o = rustc_infer::traits::Obligation::new(\n+            ObligationCause::dummy(),\n+            obligation.param_env,\n+            obligation\n+                .predicate\n+                .kind()\n+                .map_bound(|_| {\n+                    // (*) binder moved here\n+                    ty::PredicateKind::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        constness: tpred.constness,\n+                        polarity: tpred.polarity,\n+                    })\n+                })\n+                .to_predicate(infcx.tcx),\n+        );\n+        // Don't report overflow errors. Otherwise equivalent to may_hold.\n+        if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) && result.may_apply() {\n+            engine.relationships().entry(ty).or_default().self_in_trait = true;\n         }\n     }\n "}, {"sha": "f3c7642f7a318bb9a2e574510e2862e60558324c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -579,24 +579,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     previous_stack,\n                                     subobligations,\n                                 );\n-                                if let Ok(res) = res {\n-                                    if res == EvaluatedToOk || res == EvaluatedToOkModuloRegions {\n-                                        if let Some(key) =\n-                                            ProjectionCacheKey::from_poly_projection_predicate(\n-                                                self, data,\n-                                            )\n-                                        {\n-                                            // If the result is something that we can cache, then mark this\n-                                            // entry as 'complete'. This will allow us to skip evaluating the\n-                                            // suboligations at all the next time we evaluate the projection\n-                                            // predicate.\n-                                            self.infcx\n-                                                .inner\n-                                                .borrow_mut()\n-                                                .projection_cache()\n-                                                .complete(key, res);\n-                                        }\n-                                    }\n+                                if let Ok(eval_rslt) = res\n+                                    && (eval_rslt == EvaluatedToOk || eval_rslt == EvaluatedToOkModuloRegions)\n+                                    && let Some(key) =\n+                                        ProjectionCacheKey::from_poly_projection_predicate(\n+                                            self, data,\n+                                        )\n+                                {\n+                                    // If the result is something that we can cache, then mark this\n+                                    // entry as 'complete'. This will allow us to skip evaluating the\n+                                    // suboligations at all the next time we evaluate the projection\n+                                    // predicate.\n+                                    self.infcx\n+                                        .inner\n+                                        .borrow_mut()\n+                                        .projection_cache()\n+                                        .complete(key, eval_rslt);\n                                 }\n                                 res\n                             }"}, {"sha": "943f36efc153fb7521f4bf7338239a145cc99f1f", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -224,36 +224,30 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind()) {\n-                if let Some(&impl_item_id) =\n+            if let Some(ty::Projection(projection_ty)) = proj.term.ty().map(|ty| ty.kind())\n+                && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n-                {\n-                    if let Some(impl_item_span) = items\n-                        .iter()\n-                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n-                        .map(fix_span)\n-                    {\n-                        cause.span = impl_item_span;\n-                    }\n-                }\n+                && let Some(impl_item_span) = items\n+                    .iter()\n+                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .map(fix_span)\n+            {\n+                cause.span = impl_item_span;\n             }\n         }\n         ty::PredicateKind::Trait(pred) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind() {\n-                if let Some(&impl_item_id) =\n+            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind()\n+                && let Some(&impl_item_id) =\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n-                {\n-                    if let Some(impl_item_span) = items\n-                        .iter()\n-                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n-                        .map(fix_span)\n-                    {\n-                        cause.span = impl_item_span;\n-                    }\n-                }\n+                && let Some(impl_item_span) = items\n+                    .iter()\n+                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .map(fix_span)\n+            {\n+                cause.span = impl_item_span;\n             }\n         }\n         _ => {}"}, {"sha": "b262a3663b3c146d37066c51eda7d8cf6ac22584", "filename": "library/core/src/ffi/c_char.md", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -2,8 +2,7 @@ Equivalent to C's `char` type.\n \n [C's `char` type] is completely unlike [Rust's `char` type]; while Rust's type represents a unicode scalar value, C's `char` type is just an ordinary integer. On modern architectures this type will always be either [`i8`] or [`u8`], as they use byte-addresses memory with 8-bit bytes.\n \n-C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See [`CStr`] for more information.\n+C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See `CStr` for more information.\n \n [C's `char` type]: https://en.wikipedia.org/wiki/C_data_types#Basic_types\n [Rust's `char` type]: char\n-[`CStr`]: crate::ffi::CStr", "previous_filename": "library/std/src/os/raw/char.md"}, {"sha": "57f4534829ec834a1b69ae377b393adc3dfd0519", "filename": "library/core/src/ffi/c_double.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/double.md"}, {"sha": "61e2abc05189df2e12d7fa1b77894868f3e2d269", "filename": "library/core/src/ffi/c_float.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/float.md"}, {"sha": "8062ff2307a9537ccf9007c982aa5e0eda09135e", "filename": "library/core/src/ffi/c_int.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/int.md"}, {"sha": "cc160783f78b7d5b429f92ac9e8750531ce64063", "filename": "library/core/src/ffi/c_long.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/long.md"}, {"sha": "49c61bd61f4ad71c2c569289b978b182f125c85c", "filename": "library/core/src/ffi/c_longlong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/longlong.md"}, {"sha": "69879c9f17f4d80af70250424ed18558942cdc5c", "filename": "library/core/src/ffi/c_schar.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/schar.md"}, {"sha": "3d1e53d1325f31a12fee0825a30a8e89a2c0c857", "filename": "library/core/src/ffi/c_short.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/short.md"}, {"sha": "b633bb7f8dacf5bf2ca300d0ab0a793acbbc3a49", "filename": "library/core/src/ffi/c_uchar.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/uchar.md"}, {"sha": "f3abea35937abd712a916313955b86932570fb00", "filename": "library/core/src/ffi/c_uint.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/uint.md"}, {"sha": "4ab304e65777326eeef30e4e950e0296bb38881b", "filename": "library/core/src/ffi/c_ulong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/ulong.md"}, {"sha": "a27d70e17537d440fcddae685df71b4e1d6a9fd8", "filename": "library/core/src/ffi/c_ulonglong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/ulonglong.md"}, {"sha": "6928e51b352c82d2a5aa413f20c402f4ff28dca4", "filename": "library/core/src/ffi/c_ushort.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "previous_filename": "library/std/src/os/raw/ushort.md"}, {"sha": "ee7403aa04099ecbfbaca2881efbe9e6dda76499", "filename": "library/core/src/ffi/c_void.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -0,0 +1,16 @@\n+Equivalent to C's `void` type when used as a [pointer].\n+\n+In essence, `*const c_void` is equivalent to C's `const void*`\n+and `*mut c_void` is equivalent to C's `void*`. That said, this is\n+*not* the same as C's `void` return type, which is Rust's `()` type.\n+\n+To model pointers to opaque types in FFI, until `extern type` is\n+stabilized, it is recommended to use a newtype wrapper around an empty\n+byte array. See the [Nomicon] for details.\n+\n+One could use `std::os::raw::c_void` if they want to support old Rust\n+compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n+this definition. For more information, please read [RFC 2521].\n+\n+[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n+[RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md"}, {"sha": "e5255686ff984432a003a619221b323ab06502f8", "filename": "library/core/src/ffi/mod.rs", "status": "renamed", "additions": 145, "deletions": 15, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1,28 +1,157 @@\n+//! Platform-specific types, as defined by C.\n+//!\n+//! Code that interacts via FFI will almost certainly be using the\n+//! base types provided by C, which aren't nearly as nicely defined\n+//! as Rust's primitive types. This module provides types which will\n+//! match those defined by C, so that code that interacts with C will\n+//! refer to the correct types.\n+\n #![stable(feature = \"\", since = \"1.30.0\")]\n #![allow(non_camel_case_types)]\n \n-//! Utilities related to foreign function interface (FFI) bindings.\n-\n use crate::fmt;\n use crate::marker::PhantomData;\n+use crate::num::*;\n use crate::ops::{Deref, DerefMut};\n \n-/// Equivalent to C's `void` type when used as a [pointer].\n-///\n-/// In essence, `*const c_void` is equivalent to C's `const void*`\n-/// and `*mut c_void` is equivalent to C's `void*`. That said, this is\n-/// *not* the same as C's `void` return type, which is Rust's `()` type.\n+macro_rules! type_alias_no_nz {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        #[doc = include_str!($Docfile)]\n+        $( $Cfg )*\n+        #[unstable(feature = \"core_ffi_c\", issue = \"94501\")]\n+        pub type $Alias = $Real;\n+    }\n+}\n+\n+// To verify that the NonZero types in this file's macro invocations correspond\n+//\n+//  perl -n < library/std/src/os/raw/mod.rs -e 'next unless m/type_alias\\!/; die \"$_ ?\" unless m/, (c_\\w+) = (\\w+), NonZero_(\\w+) = NonZero(\\w+)/; die \"$_ ?\" unless $3 eq $1 and $4 eq ucfirst $2'\n+//\n+// NB this does not check that the main c_* types are right.\n+\n+macro_rules! type_alias {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }\n+\n+        #[doc = concat!(\"Type alias for `NonZero` version of [`\", stringify!($Alias), \"`]\")]\n+        #[unstable(feature = \"raw_os_nonzero\", issue = \"82363\")]\n+        $( $Cfg )*\n+        pub type $NZAlias = $NZReal;\n+    }\n+}\n+\n+type_alias! { \"c_char.md\", c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;\n+// Make this type alias appear cfg-dependent so that Clippy does not suggest\n+// replacing `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be removed\n+// after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n+// is fixed.\n+#[cfg(all())]\n+#[doc(cfg(all()))] }\n+type_alias! { \"c_schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n+type_alias! { \"c_uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n+type_alias! { \"c_short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n+type_alias! { \"c_ushort.md\", c_ushort = u16, NonZero_c_ushort = NonZeroU16; }\n+type_alias! { \"c_int.md\", c_int = i32, NonZero_c_int = NonZeroI32; }\n+type_alias! { \"c_uint.md\", c_uint = u32, NonZero_c_uint = NonZeroU32; }\n+type_alias! { \"c_long.md\", c_long = i32, NonZero_c_long = NonZeroI32;\n+#[doc(cfg(all()))]\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"c_ulong.md\", c_ulong = u32, NonZero_c_ulong = NonZeroU32;\n+#[doc(cfg(all()))]\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"c_long.md\", c_long = i64, NonZero_c_long = NonZeroI64;\n+#[doc(cfg(all()))]\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"c_ulong.md\", c_ulong = u64, NonZero_c_ulong = NonZeroU64;\n+#[doc(cfg(all()))]\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"c_longlong.md\", c_longlong = i64, NonZero_c_longlong = NonZeroI64; }\n+type_alias! { \"c_ulonglong.md\", c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }\n+type_alias_no_nz! { \"c_float.md\", c_float = f32; }\n+type_alias_no_nz! { \"c_double.md\", c_double = f64; }\n+\n+/// Equivalent to C's `size_t` type, from `stddef.h` (or `cstddef` for C++).\n ///\n-/// To model pointers to opaque types in FFI, until `extern type` is\n-/// stabilized, it is recommended to use a newtype wrapper around an empty\n-/// byte array. See the [Nomicon] for details.\n+/// This type is currently always [`usize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_size_t = usize;\n+\n+/// Equivalent to C's `ptrdiff_t` type, from `stddef.h` (or `cstddef` for C++).\n ///\n-/// One could use `std::os::raw::c_void` if they want to support old Rust\n-/// compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n-/// this definition. For more information, please read [RFC 2521].\n+/// This type is currently always [`isize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_ptrdiff_t = isize;\n+\n+/// Equivalent to C's `ssize_t` (on POSIX) or `SSIZE_T` (on Windows) type.\n ///\n-/// [Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n-/// [RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md\n+/// This type is currently always [`isize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_ssize_t = isize;\n+\n+mod c_char_definition {\n+    cfg_if! {\n+        // These are the targets on which c_char is unsigned.\n+        if #[cfg(any(\n+            all(\n+                target_os = \"linux\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"hexagon\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"s390x\",\n+                    target_arch = \"riscv64\",\n+                    target_arch = \"riscv32\"\n+                )\n+            ),\n+            all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n+            all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+            all(\n+                target_os = \"freebsd\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"riscv64\"\n+                )\n+            ),\n+            all(\n+                target_os = \"netbsd\",\n+                any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n+            ),\n+            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+            all(\n+                target_os = \"vxworks\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"powerpc\"\n+                )\n+            ),\n+            all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n+        ))] {\n+            pub type c_char = u8;\n+            pub type NonZero_c_char = crate::num::NonZeroU8;\n+        } else {\n+            // On every other target, c_char is signed.\n+            pub type c_char = i8;\n+            pub type NonZero_c_char = crate::num::NonZeroI8;\n+        }\n+    }\n+}\n+\n // N.B., for LLVM to recognize the void pointer type and by extension\n //     functions like malloc(), we need to have it represented as i8* in\n //     LLVM bitcode. The enum used here ensures this and prevents misuse\n@@ -31,6 +160,7 @@ use crate::ops::{Deref, DerefMut};\n //     otherwise and we need at least one variant as otherwise the enum\n //     would be uninhabited and at least dereferencing such pointers would\n //     be UB.\n+#[doc = include_str!(\"c_void.md\")]\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {", "previous_filename": "library/core/src/ffi.rs"}, {"sha": "417ed51c6b6a23063b3a84355397aea07d1cca20", "filename": "library/core/src/internal_macros.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fcore%2Fsrc%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Finternal_macros.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -187,3 +187,96 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n+\n+/// A macro for defining `#[cfg]` if-else statements.\n+///\n+/// `cfg_if` is similar to the `if/elif` C preprocessor macro by allowing definition of a cascade\n+/// of `#[cfg]` cases, emitting the implementation which matches first.\n+///\n+/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code without having to\n+/// rewrite each clause multiple times.\n+///\n+/// # Example\n+///\n+/// ```\n+/// cfg_if! {\n+///     if #[cfg(unix)] {\n+///         fn foo() { /* unix specific functionality */ }\n+///     } else if #[cfg(target_pointer_width = \"32\")] {\n+///         fn foo() { /* non-unix, 32-bit functionality */ }\n+///     } else {\n+///         fn foo() { /* fallback implementation */ }\n+///     }\n+/// }\n+///\n+/// # fn main() {}\n+/// ```\n+// This is a copy of `cfg_if!` from the `cfg_if` crate.\n+// The recursive invocations should use $crate if this is ever exported.\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    (\n+        $(\n+            if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        ) else+\n+        else { $( $e_tokens:tt )* }\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            $(\n+                (( $i_meta ) ( $( $i_tokens )* )) ,\n+            )+\n+            (() ( $( $e_tokens )* )) ,\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        $(\n+            else if #[cfg( $e_meta:meta )] { $( $e_tokens:tt )* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            (( $i_meta ) ( $( $i_tokens )* )) ,\n+            $(\n+                (( $e_meta ) ( $( $e_tokens )* )) ,\n+            )*\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the previous cfgs in a list at the beginning, so they can be\n+    // negated. After the semicolon is all the remaining items.\n+    (@__items ( $( $_:meta , )* ) ; ) => {};\n+    (\n+        @__items ( $( $no:meta , )* ) ;\n+        (( $( $yes:meta )? ) ( $( $tokens:tt )* )) ,\n+        $( $rest:tt , )*\n+    ) => {\n+        // Emit all items within one block, applying an appropriate #[cfg]. The\n+        // #[cfg] will require all `$yes` matchers specified and must also negate\n+        // all previous matchers.\n+        #[cfg(all(\n+            $( $yes , )?\n+            not(any( $( $no ),* ))\n+        ))]\n+        cfg_if! { @__identity $( $tokens )* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$yes` matchers to the list of `$no` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! {\n+            @__items ( $( $no , )* $( $yes , )? ) ;\n+            $( $rest , )*\n+        }\n+    };\n+\n+    // Internal macro to make __apply work out right for different match types,\n+    // because of how macros match/expand stuff.\n+    (@__identity $( $tokens:tt )* ) => {\n+        $( $tokens )*\n+    };\n+}"}, {"sha": "4603b5aae20b05902c1efb4942b37c16ce216e19", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -261,6 +261,7 @@\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]\n #![feature(container_error_extra)]\n+#![feature(core_ffi_c)]\n #![feature(core_intrinsics)]\n #![feature(core_panic)]\n #![feature(custom_test_frameworks)]\n@@ -315,6 +316,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_as_uninit)]\n #![feature(ptr_internals)]\n+#![feature(raw_os_nonzero)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n #![feature(saturating_int_impl)]"}, {"sha": "19d0ffb2e39cbac533ee4016faf2ca6612a5a053", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 21, "deletions": 146, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1,156 +1,31 @@\n-//! Platform-specific types, as defined by C.\n-//!\n-//! Code that interacts via FFI will almost certainly be using the\n-//! base types provided by C, which aren't nearly as nicely defined\n-//! as Rust's primitive types. This module provides types which will\n-//! match those defined by C, so that code that interacts with C will\n-//! refer to the correct types.\n+//! Compatibility module for C platform-specific types. Use [`core::ffi`] instead.\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n #[cfg(test)]\n mod tests;\n \n-use core::num::*;\n-\n-macro_rules! type_alias_no_nz {\n-    {\n-      $Docfile:tt, $Alias:ident = $Real:ty;\n-      $( $Cfg:tt )*\n-    } => {\n-        #[doc = include_str!($Docfile)]\n-        $( $Cfg )*\n+macro_rules! alias_core_ffi {\n+    ($($t:ident)*) => {$(\n         #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-        pub type $Alias = $Real;\n-    }\n-}\n-\n-// To verify that the NonZero types in this file's macro invocations correspond\n-//\n-//  perl -n < library/std/src/os/raw/mod.rs -e 'next unless m/type_alias\\!/; die \"$_ ?\" unless m/, (c_\\w+) = (\\w+), NonZero_(\\w+) = NonZero(\\w+)/; die \"$_ ?\" unless $3 eq $1 and $4 eq ucfirst $2'\n-//\n-// NB this does not check that the main c_* types are right.\n-\n-macro_rules! type_alias {\n-    {\n-      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;\n-      $( $Cfg:tt )*\n-    } => {\n-        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }\n-\n-        #[doc = concat!(\"Type alias for `NonZero` version of [`\", stringify!($Alias), \"`]\")]\n-        #[unstable(feature = \"raw_os_nonzero\", issue = \"82363\")]\n-        $( $Cfg )*\n-        pub type $NZAlias = $NZReal;\n-    }\n+        #[doc = include_str!(concat!(\"../../../../core/src/ffi/\", stringify!($t), \".md\"))]\n+        // Make this type alias appear cfg-dependent so that Clippy does not suggest\n+        // replacing expressions like `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be\n+        // removed after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n+        // is fixed.\n+        #[cfg(all())]\n+        #[doc(cfg(all()))]\n+        pub type $t = core::ffi::$t;\n+    )*}\n }\n \n-type_alias! { \"char.md\", c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;\n-// Make this type alias appear cfg-dependent so that Clippy does not suggest\n-// replacing `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be removed\n-// after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n-// is fixed.\n-#[cfg(all())]\n-#[doc(cfg(all()))] }\n-type_alias! { \"schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n-type_alias! { \"uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n-type_alias! { \"short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n-type_alias! { \"ushort.md\", c_ushort = u16, NonZero_c_ushort = NonZeroU16; }\n-type_alias! { \"int.md\", c_int = i32, NonZero_c_int = NonZeroI32; }\n-type_alias! { \"uint.md\", c_uint = u32, NonZero_c_uint = NonZeroU32; }\n-type_alias! { \"long.md\", c_long = i32, NonZero_c_long = NonZeroI32;\n-#[doc(cfg(all()))]\n-#[cfg(any(target_pointer_width = \"32\", windows))] }\n-type_alias! { \"ulong.md\", c_ulong = u32, NonZero_c_ulong = NonZeroU32;\n-#[doc(cfg(all()))]\n-#[cfg(any(target_pointer_width = \"32\", windows))] }\n-type_alias! { \"long.md\", c_long = i64, NonZero_c_long = NonZeroI64;\n-#[doc(cfg(all()))]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n-type_alias! { \"ulong.md\", c_ulong = u64, NonZero_c_ulong = NonZeroU64;\n-#[doc(cfg(all()))]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n-type_alias! { \"longlong.md\", c_longlong = i64, NonZero_c_longlong = NonZeroI64; }\n-type_alias! { \"ulonglong.md\", c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }\n-type_alias_no_nz! { \"float.md\", c_float = f32; }\n-type_alias_no_nz! { \"double.md\", c_double = f64; }\n-\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-#[doc(no_inline)]\n-pub use core::ffi::c_void;\n-\n-/// Equivalent to C's `size_t` type, from `stddef.h` (or `cstddef` for C++).\n-///\n-/// This type is currently always [`usize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_size_t = usize;\n-\n-/// Equivalent to C's `ptrdiff_t` type, from `stddef.h` (or `cstddef` for C++).\n-///\n-/// This type is currently always [`isize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_ptrdiff_t = isize;\n-\n-/// Equivalent to C's `ssize_t` (on POSIX) or `SSIZE_T` (on Windows) type.\n-///\n-/// This type is currently always [`isize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_ssize_t = isize;\n-\n-mod c_char_definition {\n-    cfg_if::cfg_if! {\n-        // These are the targets on which c_char is unsigned.\n-        if #[cfg(any(\n-            all(\n-                target_os = \"linux\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"hexagon\",\n-                    target_arch = \"powerpc\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"s390x\",\n-                    target_arch = \"riscv64\",\n-                    target_arch = \"riscv32\"\n-                )\n-            ),\n-            all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n-            all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-            all(\n-                target_os = \"freebsd\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"powerpc\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"riscv64\"\n-                )\n-            ),\n-            all(\n-                target_os = \"netbsd\",\n-                any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n-            ),\n-            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-            all(\n-                target_os = \"vxworks\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"powerpc\"\n-                )\n-            ),\n-            all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-        ))] {\n-            pub type c_char = u8;\n-            pub type NonZero_c_char = core::num::NonZeroU8;\n-        } else {\n-            // On every other target, c_char is signed.\n-            pub type c_char = i8;\n-            pub type NonZero_c_char = core::num::NonZeroI8;\n-        }\n-    }\n+alias_core_ffi! {\n+    c_char c_schar c_uchar\n+    c_short c_ushort\n+    c_int c_uint\n+    c_long c_ulong\n+    c_longlong c_ulonglong\n+    c_float\n+    c_double\n+    c_void\n }"}, {"sha": "07a0339c066bc9b23207be9d50e9bc4a73ba9dd2", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -3,11 +3,11 @@ use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n+use core::ffi::NonZero_c_int;\n \n #[cfg(target_os = \"linux\")]\n use crate::os::linux::process::PidFd;"}, {"sha": "bbabdf787d994dce53d3d4f6731508d47f54466d", "filename": "library/std/src/sys/unix/process/process_unsupported.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -3,12 +3,12 @@ use crate::fmt;\n use crate::io;\n use crate::io::ErrorKind;\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::process::process_common::*;\n use crate::sys::unix::unsupported::*;\n+use core::ffi::NonZero_c_int;\n \n use libc::{c_int, pid_t};\n "}, {"sha": "56ed6cfeb6a6b891101b10cdf3677ded11257b64", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -2,11 +2,11 @@ use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n use crate::sys_common::thread;\n+use core::ffi::NonZero_c_int;\n use libc::RTP_ID;\n use libc::{self, c_char, c_int};\n "}, {"sha": "2affd7e75b03082b3f49d2a2f2e4dcb1c9007932", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -5,9 +5,9 @@\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n use crate::mem;\n-use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n+use core::ffi::NonZero_c_ulong;\n \n use libc::{c_void, size_t, wchar_t};\n "}, {"sha": "3f255ed40b8c82a0434088568fbed270dc31bf00", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit 67b768c0b660a069a45f0e5d8ae2f679df1022ab\n+Subproject commit 3f255ed40b8c82a0434088568fbed270dc31bf00"}, {"sha": "c55611dd6c58bdeb52423b5c52fd0f3c93615ba8", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit beea0a3cdc3885375342fd010f9ad658e6a5e09a\n+Subproject commit c55611dd6c58bdeb52423b5c52fd0f3c93615ba8"}, {"sha": "f6d6126fc96ecf4a7f7d22da330df9506293b0d0", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit 90993eeac93dbf9388992de92965f99cf6f29a03\n+Subproject commit f6d6126fc96ecf4a7f7d22da330df9506293b0d0"}, {"sha": "9d289c05fce7254b99c6a0d354d84abb7fd7a032", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit 70fc73a6b908e08e66aa0306856c5211312f6c05\n+Subproject commit 9d289c05fce7254b99c6a0d354d84abb7fd7a032"}, {"sha": "2a928483a20bb306a7399c0468234db90d89afb5", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit 18c0055b8aea49391e8f758a4400097999c9cf1e\n+Subproject commit 2a928483a20bb306a7399c0468234db90d89afb5"}, {"sha": "32f2a5b4e7545318846185198542230170dd8a42", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit 62f58394ba7b203f55ac35ddcc4c0b79578f5706\n+Subproject commit 32f2a5b4e7545318846185198542230170dd8a42"}, {"sha": "5db2d0747c83bb7f9de930dae440fac140f95d75", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -178,7 +178,7 @@ crate fn source_span_for_markdown_range(\n \n     'outer: for (line_no, md_line) in md_lines.enumerate() {\n         loop {\n-            let source_line = src_lines.next().expect(\"could not find markdown in source\");\n+            let source_line = src_lines.next()?;\n             match source_line.find(md_line) {\n                 Some(offset) => {\n                     if line_no == starting_line {"}, {"sha": "14c4c3f30f94a1ba07e5f756113c160e79af3d61", "filename": "src/test/codegen/dst-vtable-align-nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fcodegen%2Fdst-vtable-align-nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fcodegen%2Fdst-vtable-align-nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdst-vtable-align-nonzero.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -24,6 +24,7 @@ pub fn eliminates_runtime_check_when_align_1(\n     x: &Struct<WrapperWithAlign1<dyn Trait>>\n ) -> &WrapperWithAlign1<dyn Trait> {\n     // CHECK: load [[USIZE:i[0-9]+]], {{.+}} !range [[RANGE_META:![0-9]+]]\n+    // CHECK-NOT: llvm.umax\n     // CHECK-NOT: icmp\n     // CHECK-NOT: select\n     // CHECK: ret\n@@ -36,8 +37,7 @@ pub fn does_not_eliminate_runtime_check_when_align_2(\n     x: &Struct<WrapperWithAlign2<dyn Trait>>\n ) -> &WrapperWithAlign2<dyn Trait> {\n     // CHECK: [[X0:%[0-9]+]] = load [[USIZE]], {{.+}} !range [[RANGE_META]]\n-    // CHECK: [[X1:%[0-9]+]] = icmp {{.+}} [[X0]]\n-    // CHECK: [[X2:%[0-9]+]] = select {{.+}} [[X1]]\n+    // CHECK: {{icmp|llvm.umax}}\n     // CHECK: ret\n     &x.dst\n }"}, {"sha": "9d6b52b95a7ab0d2cc317506a6e0c6784858771f", "filename": "src/test/rustdoc-ui/auxiliary/module_macro_doc.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fmodule_macro_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fmodule_macro_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fmodule_macro_doc.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -0,0 +1 @@\n+//! [`long_cat`] is really long"}, {"sha": "0e8472eb24270f41529a7ae8a47991375a5c8ba1", "filename": "src/test/rustdoc-ui/macro-docs.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+macro_rules! m {\n+    () => {\n+        /// A\n+        //~^ WARNING\n+        #[path = \"auxiliary/module_macro_doc.rs\"]\n+        pub mod mymodule;\n+    }\n+}\n+\n+m!();"}, {"sha": "e3cc1731146db725a770a9715cce75626722edcc", "filename": "src/test/rustdoc-ui/macro-docs.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -0,0 +1,20 @@\n+warning: unresolved link to `long_cat`\n+  --> $DIR/macro-docs.rs:5:9\n+   |\n+LL |         /// A\n+   |         ^^^^^\n+...\n+LL | m!();\n+   | ---- in this macro invocation\n+   |\n+   = note: `#[warn(rustdoc::broken_intra_doc_links)]` on by default\n+   = note: the link appears in this line:\n+           \n+           [`long_cat`] is really long\n+            ^^^^^^^^^^\n+   = note: no item named `long_cat` in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   = note: this warning originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: 1 warning emitted\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/rustdoc-ui/macro-docs.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fmacro-docs.stdout?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d"}, {"sha": "943c63667e05f495f387095ab787a6d7082cb634", "filename": "src/test/ui/issues/issue-17728.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17728.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -8,6 +8,12 @@ LL |     fn attemptTraverse(&self, room: &Room, directionStr: &str) -> Result<&R\n ...\n LL |             Some(entry) => Ok(entry),\n    |                            ^^^^^^^^^ ...but data from `room` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     fn attemptTraverse<'a>(&'a self, room: &'a Room, directionStr: &str) -> Result<&Room, &str> {\n+   |                       ++++  ++              ++\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/issue-17728.rs:109:14"}, {"sha": "636904aefb47ed446034959535e261b22d3b93a6", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |   fn foo<'a>(&self, x: &i32) -> &i32 {\n    |                        this parameter and the return type are declared with different lifetimes...\n LL |     x\n    |     ^ ...but data from `x` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |   fn foo<'a>(&'a self, x: &'a i32) -> &i32 {\n+   |               ++           ++\n \n error: aborting due to previous error\n "}, {"sha": "474eadb7f9236ac5ed1bdc516abc305f6d5a1437", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-self-is-anon.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn foo<'a>(&self, x: &Foo) -> &Foo {\n    |                          this parameter and the return type are declared with different lifetimes...\n LL |         if true { x } else { self }\n    |                   ^ ...but data from `x` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn foo<'a>(&'a self, x: &'a Foo) -> &Foo {\n+   |                 ++           ++\n \n error: aborting due to previous error\n "}, {"sha": "68893781dc2913419bef3eb4306a7a54426a35e3", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-using-impl-items.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -5,6 +5,12 @@ LL |     fn foo(x: &mut Vec<&u8>, y: &u8) {\n    |                        ---      --- these two types are declared with different lifetimes...\n LL |         x.push(y);\n    |                ^ ...but data from `y` flows into `x` here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn foo<'a>(x: &mut Vec<&'a u8>, y: &'a u8) {\n+   |           ++++              ++          ++\n \n error: aborting due to previous error\n "}, {"sha": "64a574695105a8559d62f09cf5fddbb953172227", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -5,6 +5,12 @@ LL |     fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n    |                              ----     ----   ^ ...but data from `f` is returned here\n    |                              |\n    |                              this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn a<'a>(self: Pin<&'a Foo>, f: &'a Foo) -> &Foo { f }\n+   |         ++++            ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:8:76\n@@ -13,6 +19,12 @@ LL |     fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self,\n    |                               ----              -----------------          ^ ...but data from `f` is returned here\n    |                               |\n    |                               this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn c<'a>(self: Pin<&'a Self>, f: &'a Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |         ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch.rs:13:58"}, {"sha": "5764ab03c5519b0345a3c12ade27f285886007bf", "filename": "src/test/ui/self/elision/lt-ref-self.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn ref_self(&self, f: &u32) -> &u32 {\n    |                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self.rs:17:9\n@@ -17,6 +23,12 @@ LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self.rs:21:9\n@@ -27,6 +39,12 @@ LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                          this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self.rs:25:9\n@@ -37,6 +55,12 @@ LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                          this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self.rs:29:9\n@@ -47,6 +71,12 @@ LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                   this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                        ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self.rs:33:9\n@@ -57,6 +87,12 @@ LL |     fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_pin_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                    ++++                ++             ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "416719a08e033b0c1425b7c5c1ff5ec17897e35d", "filename": "src/test/ui/self/elision/ref-mut-self.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn ref_self(&mut self, f: &u32) -> &u32 {\n    |                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_self<'a>(&'a mut self, f: &'a u32) -> &u32 {\n+   |                ++++  ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self.rs:17:9\n@@ -17,6 +23,12 @@ LL |     fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n    |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_Self<'a>(self: &'a mut Self, f: &'a u32) -> &u32 {\n+   |                ++++        ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self.rs:21:9\n@@ -27,6 +39,12 @@ LL |     fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n    |                                              this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_ref_Self<'a>(self: Box<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self.rs:25:9\n@@ -37,6 +55,12 @@ LL |     fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n    |                                              this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn pin_ref_Self<'a>(self: Pin<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self.rs:29:9\n@@ -47,6 +71,12 @@ LL |     fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n    |                                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_box_ref_Self<'a>(self: Box<Box<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                        ++++                ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self.rs:33:9\n@@ -57,6 +87,12 @@ LL |     fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n    |                                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_pin_ref_Self<'a>(self: Box<Pin<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                        ++++                ++                 ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "6ca9ab1b2c775fee1248722849e15be6bcd4ede1", "filename": "src/test/ui/self/elision/ref-mut-struct.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n    |                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_Struct<'a>(self: &'a mut Struct, f: &'a u32) -> &u32 {\n+   |                  ++++        ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct.rs:15:9\n@@ -17,6 +23,12 @@ LL |     fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n    |                                                  this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_ref_Struct<'a>(self: Box<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                      ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct.rs:19:9\n@@ -27,6 +39,12 @@ LL |     fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n    |                                                  this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn pin_ref_Struct<'a>(self: Pin<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                      ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct.rs:23:9\n@@ -37,6 +55,12 @@ LL |     fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n    |                                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_box_ref_Struct<'a>(self: Box<Box<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++                   ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct.rs:27:9\n@@ -47,6 +71,12 @@ LL |     fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n    |                                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_pin_ref_Struct<'a>(self: Box<Pin<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++                   ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "955222f765599d2cb1169416d65e8fb970a021d9", "filename": "src/test/ui/self/elision/ref-self.stderr", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn ref_self(&self, f: &u32) -> &u32 {\n    |                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:27:9\n@@ -17,6 +23,12 @@ LL |     fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:31:9\n@@ -27,6 +39,12 @@ LL |     fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                          this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:35:9\n@@ -37,6 +55,12 @@ LL |     fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                          this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                    ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:39:9\n@@ -47,6 +71,12 @@ LL |     fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                   this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                        ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:43:9\n@@ -57,6 +87,12 @@ LL |     fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                                   this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_pin_ref_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                        ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self.rs:47:9\n@@ -67,6 +103,12 @@ LL |     fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn wrap_ref_Self_Self<'a>(self: Wrap<&'a Self, Self>, f: &'a u8) -> &u8 {\n+   |                          ++++             ++                  ++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "c80993fe8c4552f1bff9a0eb35cc4a1cb1bff628", "filename": "src/test/ui/self/elision/ref-struct.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct.stderr?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -7,6 +7,12 @@ LL |     fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n    |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn ref_Struct<'a>(self: &'a Struct, f: &'a u32) -> &u32 {\n+   |                  ++++        ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct.rs:15:9\n@@ -17,6 +23,12 @@ LL |     fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n    |                                              this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_ref_Struct<'a>(self: Box<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                      ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct.rs:19:9\n@@ -27,6 +39,12 @@ LL |     fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n    |                                              this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn pin_ref_Struct<'a>(self: Pin<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                      ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct.rs:23:9\n@@ -37,6 +55,12 @@ LL |     fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n    |                                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_box_ref_Struct<'a>(self: Box<Box<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct.rs:27:9\n@@ -47,6 +71,12 @@ LL |     fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n    |                                                   this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     fn box_pin_Struct<'a>(self: Box<Pin<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                      ++++                ++               ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "c6b3f687d5d9917b626f80a730552a185052ff28", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -1 +1 @@\n-Subproject commit e05a543f74dbdd0580b2bd35ddb7f8e144d9edda\n+Subproject commit c6b3f687d5d9917b626f80a730552a185052ff28"}, {"sha": "f5ff3860afe344ee7f4491771bb71394fb60d886", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a280de64fb34378174fa33b6866a7ee920ceb8d/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=2a280de64fb34378174fa33b6866a7ee920ceb8d", "patch": "@@ -46,7 +46,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n     // pointer regardless of the target architecture. As a result,\n     // we must use `#[cfg(windows)]` to conditionally compile the\n     // correct `VaList` structure for windows.\n-    \"library/core/src/ffi.rs\",\n+    \"library/core/src/ffi/mod.rs\",\n     \"library/std/src/sys/\", // Platform-specific code for std lives here.\n     \"library/std/src/os\",   // Platform-specific public interfaces\n     // Temporary `std` exceptions"}]}