{"sha": "993c1488cc4b0826c3f1076393bf50eef09ba467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5M2MxNDg4Y2M0YjA4MjZjM2YxMDc2MzkzYmY1MGVlZjA5YmE0Njc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-09T15:39:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:21:31Z"}, "message": "add `canonicalize` method to `InferCtxt` [VIC]", "tree": {"sha": "9c2fcbecd875d6120c3a797b8552ed2f5d2155ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c2fcbecd875d6120c3a797b8552ed2f5d2155ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/993c1488cc4b0826c3f1076393bf50eef09ba467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/993c1488cc4b0826c3f1076393bf50eef09ba467", "html_url": "https://github.com/rust-lang/rust/commit/993c1488cc4b0826c3f1076393bf50eef09ba467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/993c1488cc4b0826c3f1076393bf50eef09ba467/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80b4c45ee47833338164c6eb015f421890712863", "url": "https://api.github.com/repos/rust-lang/rust/commits/80b4c45ee47833338164c6eb015f421890712863", "html_url": "https://github.com/rust-lang/rust/commit/80b4c45ee47833338164c6eb015f421890712863"}], "stats": {"total": 1137, "additions": 1121, "deletions": 16}, "files": [{"sha": "ae67d592ba30c73eb7997450268d12cc3eb05f1f", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -19,6 +19,7 @@ use std::cell::RefCell;\n use std::hash as std_hash;\n use std::mem;\n use middle::region;\n+use infer;\n use traits;\n use ty;\n use mir;\n@@ -85,6 +86,9 @@ for ty::RegionKind {\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReCanonical(c) => {\n+                c.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.depth.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n@@ -130,6 +134,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CanonicalVar {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -1229,11 +1243,52 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::UniverseIndex {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.depth().hash_stable(hcx, hasher);\n     }\n }\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n+        variables, value\n+    }\n+);\n+\n+impl_stable_hash_for!(\n+    impl<'tcx> for struct infer::canonical::CanonicalVarValues<'tcx> {\n+        var_values\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::CanonicalVarInfo {\n+    kind\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalVarKind {\n+    Ty(k),\n+    Region\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::CanonicalTyVarKind {\n+    General,\n+    Int,\n+    Float\n+});\n+\n+impl_stable_hash_for!(\n+    impl<'tcx, R> for struct infer::canonical::QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    }\n+);\n+\n+impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n+    region_outlives, ty_outlives\n+});\n+\n+impl_stable_hash_for!(enum infer::canonical::Certainty {\n+    Proven, Ambiguous\n+});"}, {"sha": "c1c7337860e378329618e6919af1bbcd19293d72", "filename": "src/librustc/infer/canonical.rs", "status": "added", "additions": 928, "deletions": 0, "changes": 928, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -0,0 +1,928 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constriants\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+\n+use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::fmt::Debug;\n+use syntax::codemap::Span;\n+use traits::{Obligation, ObligationCause, PredicateObligation};\n+use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n+use ty::subst::{Kind, UnpackedKind};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::CellUsizeExt;\n+\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewriten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Canonical<'gcx, V> {\n+    pub variables: CanonicalVarInfos<'gcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables.\n+///\n+/// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n+/// to get back a `CanonicalVarValues` containing fresh inference\n+/// variables.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// Region variable `'?R`.\n+    Region,\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General,\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResult<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug)]\n+pub struct QueryResult<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResult<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+/// Subset of `RegionConstraintData` produced by trait query.\n+#[derive(Clone, Debug, Default)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub region_outlives: Vec<(Region<'tcx>, Region<'tcx>)>,\n+    pub ty_outlives: Vec<(Ty<'tcx>, Region<'tcx>)>,\n+}\n+\n+/// Trait implemented by values that can be canonicalized. It mainly\n+/// serves to identify the interning table we will use.\n+pub trait Canonicalize<'gcx: 'tcx, 'tcx>: TypeFoldable<'tcx> + Lift<'gcx> {\n+    type Canonicalized: 'gcx + Debug;\n+\n+    /// After a value has been fully canonicalized and lifted, this\n+    /// method will allocate it in a global arena.\n+    fn intern(\n+        gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Creates a substitution S for the canonical value with fresh\n+    /// inference variables and applies it to the canonical value.\n+    /// Returns both the instantiated result *and* the substitution S.\n+    ///\n+    /// This is useful at the start of a query: it basically brings\n+    /// the canonical value \"into scope\" within your new infcx. At the\n+    /// end of processing, the substitution S (once canonicalized)\n+    /// then represents the values that you computed for each of the\n+    /// canonical inputs to your query.\n+    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> (T, CanonicalVarValues<'tcx>)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let canonical_inference_vars =\n+            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+        let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n+        (result, canonical_inference_vars)\n+    }\n+\n+    /// Given the \"infos\" about the canonical variables from some\n+    /// canonical, creates fresh inference variables with the same\n+    /// characteristics. You can then use `substitute` to instantiate\n+    /// the canonical variable with these inference variables.\n+    pub fn fresh_inference_vars_for_canonical_vars(\n+        &self,\n+        span: Span,\n+        variables: &Slice<CanonicalVarInfo>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n+            .iter()\n+            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .collect();\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    /// Given the \"info\" about a canonical variable, creates a fresh\n+    /// inference variable with the same characteristics.\n+    pub fn fresh_inference_var_for_canonical_var(\n+        &self,\n+        span: Span,\n+        cv_info: CanonicalVarInfo,\n+    ) -> Kind<'tcx> {\n+        match cv_info.kind {\n+            CanonicalVarKind::Ty(ty_kind) => {\n+                let ty = match ty_kind {\n+                    CanonicalTyVarKind::General => {\n+                        self.next_ty_var(\n+                            // FIXME(#48696) this handling of universes is not right.\n+                            ty::UniverseIndex::ROOT,\n+                            TypeVariableOrigin::MiscVariable(span),\n+                        )\n+                    }\n+\n+                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n+\n+                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n+                };\n+                Kind::from(ty)\n+            }\n+\n+            CanonicalVarKind::Region => {\n+                Kind::from(self.next_region_var(RegionVariableOrigin::MiscVariable(span)))\n+            }\n+        }\n+    }\n+\n+    /// Given the (canonicalized) result to a canonical query,\n+    /// instantiates the result so it can be used, plugging in the\n+    /// values from the canonical query. (Note that the result may\n+    /// have been ambiguous; you should check the certainty level of\n+    /// the query before applying this function.)\n+    ///\n+    /// It's easiest to explain what is happening here by\n+    /// example. Imagine we start out with the query `?A: Foo<'static,\n+    /// ?B>`. We would canonicalize that by introducing two variables:\n+    ///\n+    ///     ?0: Foo<'?1, ?2>\n+    ///\n+    /// (Note that all regions get replaced with variables always,\n+    /// even \"known\" regions like `'static`.) After canonicalization,\n+    /// we also get back an array with the \"original values\" for each\n+    /// canonicalized variable:\n+    ///\n+    ///     [?A, 'static, ?B]\n+    ///\n+    /// Now we do the query and get back some result R. As part of that\n+    /// result, we'll have an array of values for the canonical inputs.\n+    /// For example, the canonical result might be:\n+    ///\n+    /// ```\n+    /// for<2> {\n+    ///     values = [ Vec<?0>, '1, ?0 ]\n+    ///                    ^^   ^^  ^^ these are variables in the result!\n+    ///     ...\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that this result is itself canonical and may include some\n+    /// variables (in this case, `?0`).\n+    ///\n+    /// What we want to do conceptually is to (a) instantiate each of the\n+    /// canonical variables in the result with a fresh inference variable\n+    /// and then (b) unify the values in the result with the original values.\n+    /// Doing step (a) would yield a result of\n+    ///\n+    /// ```\n+    /// {\n+    ///     values = [ Vec<?C>, '?X, ?C ]\n+    ///                    ^^   ^^^ fresh inference variables in `self`\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// Step (b) would then unify:\n+    ///\n+    /// ```\n+    /// ?A with Vec<?C>\n+    /// 'static with '?X\n+    /// ?B with ?C\n+    /// ```\n+    ///\n+    /// But what we actually do is a mildly optimized variant of\n+    /// that. Rather than eagerly instantiating all of the canonical\n+    /// values in the result with variables, we instead walk the\n+    /// vector of values, looking for cases where the value is just a\n+    /// canonical variable. In our example, `values[2]` is `?C`, so\n+    /// that we means we can deduce that `?C := ?B and `'?X :=\n+    /// 'static`. This gives us a partial set of values. Anything for\n+    /// which we do not find a value, we create an inference variable\n+    /// for. **Then** we unify.\n+    pub fn instantiate_query_result<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        // Every canonical query result includes values for each of\n+        // the inputs to the query. Therefore, we begin by unifying\n+        // these values with the original inputs that were\n+        // canonicalized.\n+        let result_values = &query_result.value.var_values;\n+        assert_eq!(original_values.len(), result_values.len());\n+\n+        // Quickly try to find initial values for the canonical\n+        // variables in the result in terms of the query. We do this\n+        // by iterating down the values that the query gave to each of\n+        // the canonical inputs. If we find that one of those values\n+        // is directly equal to one of the canonical variables in the\n+        // result, then we can type the corresponding value from the\n+        // input. See the example above.\n+        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n+            IndexVec::from_elem_n(None, query_result.variables.len());\n+\n+        // In terms of our example above, we are iterating over pairs like:\n+        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n+        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+            match result_value.unpack() {\n+                UnpackedKind::Type(result_value) => {\n+                    // e.g., here `result_value` might be `?0` in the example above...\n+                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+                UnpackedKind::Lifetime(result_value) => {\n+                    // e.g., here `result_value` might be `'?1` in the example above...\n+                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n+                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Create a result substitution: if we found a value for a\n+        // given variable in the loop above, use that. Otherwise, use\n+        // a fresh inference variable.\n+        let result_subst = &CanonicalVarValues {\n+            var_values: query_result\n+                .variables\n+                .iter()\n+                .enumerate()\n+                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n+                    Some(k) => k,\n+                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n+                })\n+                .collect(),\n+        };\n+\n+        // Apply the result substitution to the query.\n+        let QueryResult {\n+            var_values: query_values,\n+            region_constraints: query_region_constraints,\n+            certainty: _,\n+            value: user_result,\n+        } = query_result.substitute(self.tcx, result_subst);\n+\n+        // Unify the original values for the canonical variables in\n+        // the input with the value found in the query\n+        // post-substitution. Often, but not always, this is a no-op,\n+        // because we already found the mapping in the first step.\n+        let mut obligations =\n+            self.unify_canonical_vars(cause, param_env, original_values, &query_values)?\n+                .into_obligations();\n+\n+        obligations.extend(self.query_region_constraints_into_obligations(\n+            cause,\n+            param_env,\n+            query_region_constraints,\n+        ));\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// Converts the region constraints resulting from a query into an\n+    /// iterator of obligations.\n+    fn query_region_constraints_into_obligations<'a>(\n+        &self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        query_region_constraints: QueryRegionConstraints<'tcx>,\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        let QueryRegionConstraints {\n+            region_outlives,\n+            ty_outlives,\n+        } = query_region_constraints;\n+\n+        let region_obligations = region_outlives.into_iter().map(move |(r1, r2)| {\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n+            )\n+        });\n+\n+        let ty_obligations = ty_outlives.into_iter().map(move |(t1, r2)| {\n+            Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n+            )\n+        });\n+\n+        region_obligations.chain(ty_obligations)\n+    }\n+\n+    /// Given two sets of values for the same set of canonical variables, unify them.\n+    pub fn unify_canonical_vars(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        variables1: &CanonicalVarValues<'tcx>,\n+        variables2: &CanonicalVarValues<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        assert_eq!(variables1.var_values.len(), variables2.var_values.len());\n+        self.commit_if_ok(|_| {\n+            let mut obligations = vec![];\n+            for (value1, value2) in variables1.var_values.iter().zip(&variables2.var_values) {\n+                match (value1.unpack(), value2.unpack()) {\n+                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                    }\n+                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    _ => {\n+                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n+                    }\n+                }\n+            }\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        })\n+    }\n+\n+    /// Canonicalizes a query value `V`. When we canonicalize a query,\n+    /// we not only canonicalize unbound inference variables, but we\n+    /// *also* replace all free regions whatsoever. So for example a\n+    /// query like `T: Trait<'static>` would be canonicalized to\n+    ///\n+    ///     T: Trait<'?0>\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`.\n+    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        self.tcx.sess.perf_stats.queries_canonicalized.increment();\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(true),\n+        )\n+    }\n+\n+    /// Canonicalizes a query *response* `V`. When we canonicalize a\n+    /// query response, we only canonicalize unbound inference\n+    /// variables, and we leave other free regions alone. So,\n+    /// continuing with the example from `canonicalize_query`, if\n+    /// there was an input query `T: Trait<'static>`, it would have\n+    /// been canonicalized to\n+    ///\n+    ///     T: Trait<'?0>\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n+    /// exists only one possible impl of `Trait`, and it looks like\n+    ///\n+    ///     impl<T> Trait<'static> for T { .. }\n+    ///\n+    /// then we would prepare a query result R that (among other\n+    /// things) includes a mapping to `'?0 := 'static`. When\n+    /// canonicalizing this query result R, we would leave this\n+    /// reference to `'static` alone.\n+    pub fn canonicalize_response<V>(\n+        &self,\n+        value: &V,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeAllFreeRegions(false),\n+        )\n+    }\n+}\n+\n+impl<'cx, 'gcx> TyCtxt<'cx, 'gcx, 'gcx> {\n+    /// Canonicalize a value that doesn't have any inference variables\n+    /// or other things (and we know it).\n+    pub fn canonicalize_global<V>(self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'gcx>)\n+    where\n+        V: Canonicalize<'gcx, 'gcx>,\n+    {\n+        Canonicalizer::canonicalize(value, None, self, CanonicalizeAllFreeRegions(false))\n+    }\n+}\n+\n+/// If this flag is true, then all free regions will be replaced with\n+/// a canonical var. This is used to make queries as generic as\n+/// possible. For example, the query `F: Foo<'static>` would be\n+/// canonicalized to `F: Foo<'0>`.\n+struct CanonicalizeAllFreeRegions(bool);\n+\n+struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n+    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    needs_canonical_flags: TypeFlags,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReVar(vid) => {\n+                let r = self.infcx\n+                    .unwrap()\n+                    .borrow_region_constraints()\n+                    .opportunistic_resolve_var(self.tcx, vid);\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Region,\n+                };\n+                debug!(\n+                    \"canonical: region var found with vid {:?}, \\\n+                     opportunistically resolved to {:?}\",\n+                    vid, r\n+                );\n+                let cvar = self.canonical_var(info, Kind::from(r));\n+                self.tcx().mk_region(ty::ReCanonical(cvar))\n+            }\n+\n+            ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReScope(_)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased => {\n+                if self.canonicalize_all_free_regions.0 {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, Kind::from(r));\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n+                bug!(\"canonical region encountered during canonicalization\")\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+\n+            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+\n+            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"encountered a fresh type during canonicalization\")\n+            }\n+\n+            ty::TyInfer(ty::CanonicalTy(_)) => {\n+                bug!(\"encountered a canonical type during canonicalization\")\n+            }\n+\n+            // Replace a `()` that \"would've fallen back\" to `!` with just `()`.\n+            ty::TyTuple(ref tys, true) => {\n+                assert!(tys.is_empty());\n+                self.tcx().mk_nil()\n+            }\n+\n+            ty::TyClosure(..)\n+            | ty::TyGenerator(..)\n+            | ty::TyGeneratorWitness(..)\n+            | ty::TyBool\n+            | ty::TyChar\n+            | ty::TyInt(..)\n+            | ty::TyUint(..)\n+            | ty::TyFloat(..)\n+            | ty::TyAdt(..)\n+            | ty::TyStr\n+            | ty::TyError\n+            | ty::TyArray(..)\n+            | ty::TySlice(..)\n+            | ty::TyRawPtr(..)\n+            | ty::TyRef(..)\n+            | ty::TyFnDef(..)\n+            | ty::TyFnPtr(_)\n+            | ty::TyDynamic(..)\n+            | ty::TyNever\n+            | ty::TyTuple(_, false)\n+            | ty::TyProjection(..)\n+            | ty::TyForeign(..)\n+            | ty::TyParam(..)\n+            | ty::TyAnon(..) => {\n+                if t.flags.intersects(self.needs_canonical_flags) {\n+                    t.super_fold_with(self)\n+                } else {\n+                    t\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+    /// The main `canonicalize` method, shared impl of\n+    /// `canonicalize_query` and `canonicalize_response`.\n+    fn canonicalize<V>(\n+        value: &V,\n+        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n+    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n+    where\n+        V: Canonicalize<'gcx, 'tcx>,\n+    {\n+        debug_assert!(\n+            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            \"canonicalizing a canonical value: {:?}\",\n+            value,\n+        );\n+\n+        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n+            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n+        } else {\n+            TypeFlags::KEEP_IN_LOCAL_TCX\n+        };\n+\n+        let gcx = tcx.global_tcx();\n+\n+        // Fast path: nothing that needs to be canonicalized.\n+        if !value.has_type_flags(needs_canonical_flags) {\n+            let out_value = gcx.lift(value).unwrap();\n+            let canon_value = V::intern(\n+                gcx,\n+                Canonical {\n+                    variables: Slice::empty(),\n+                    value: out_value,\n+                },\n+            );\n+            let values = CanonicalVarValues { var_values: IndexVec::default() };\n+            return (canon_value, values);\n+        }\n+\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            tcx,\n+            canonicalize_all_free_regions,\n+            needs_canonical_flags,\n+            variables: IndexVec::default(),\n+            indices: FxHashMap::default(),\n+            var_values: IndexVec::default(),\n+        };\n+        let out_value = value.fold_with(&mut canonicalizer);\n+\n+        // Once we have canonicalized `out_value`, it should not\n+        // contain anything that ties it to this inference context\n+        // anymore, so it should live in the global arena.\n+        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n+            bug!(\n+                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n+                out_value,\n+                value\n+            )\n+        });\n+\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+\n+        let canonical_value = V::intern(\n+            gcx,\n+            Canonical {\n+                variables: canonical_variables,\n+                value: out_value,\n+            },\n+        );\n+        let canonical_var_values = CanonicalVarValues {\n+            var_values: canonicalizer.var_values,\n+        };\n+        (canonical_value, canonical_var_values)\n+    }\n+\n+    /// Creates a canonical variable replacing `kind` from the input,\n+    /// or returns an existing variable if `kind` has already been\n+    /// seen. `kind` is expected to be an unbound variable (or\n+    /// potentially a free region).\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n+        let Canonicalizer {\n+            indices,\n+            variables,\n+            var_values,\n+            ..\n+        } = self;\n+\n+        indices\n+            .entry(kind)\n+            .or_insert_with(|| {\n+                let cvar1 = variables.push(info);\n+                let cvar2 = var_values.push(kind);\n+                assert_eq!(cvar1, cvar2);\n+                cvar1\n+            })\n+            .clone()\n+    }\n+\n+    /// Given a type variable `ty_var` of the given kind, first check\n+    /// if `ty_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `ty_var`.\n+    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n+        let bound_to = infcx.shallow_resolve(ty_var);\n+        if bound_to != ty_var {\n+            self.fold_ty(bound_to)\n+        } else {\n+            let info = CanonicalVarInfo {\n+                kind: CanonicalVarKind::Ty(ty_kind),\n+            };\n+            let cvar = self.canonical_var(info, Kind::from(ty_var));\n+            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n+        }\n+    }\n+}\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Instantiate the wrapped value, replacing each canonical value\n+    /// with the value given in `var_values`.\n+    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        self.value\n+            .fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+    }\n+}\n+\n+struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    var_values: &'cx CanonicalVarValues<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+                match self.var_values.var_values[c].unpack() {\n+                    UnpackedKind::Type(ty) => ty,\n+                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n+                }\n+            }\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n+            },\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    for <'tcx> {\n+        ::infer::canonical::Certainty,\n+        ::infer::canonical::CanonicalVarInfo,\n+        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+        ::infer::canonical::CanonicalVarKind,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n+        variables,\n+        value,\n+    } where C: TypeFoldable<'tcx>\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n+        self.var_values.iter().cloned()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = Kind<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for CanonicalVarValues<'a> {\n+        type Lifted = CanonicalVarValues<'tcx>;\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for CanonicalVarValues<'tcx> {\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n+        type Lifted = QueryRegionConstraints<'tcx>;\n+        region_outlives, ty_outlives\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    } where R: TypeFoldable<'tcx>,\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n+        type Lifted = QueryResult<'tcx, R::Lifted>;\n+        var_values, region_constraints, certainty, value\n+    } where R: Lift<'tcx>\n+}"}, {"sha": "1c581c44464e72ab7085df3a8f736a95fcaf9f75", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -476,6 +476,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 }\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 span_bug!(\n                     self.span,"}, {"sha": "96c2309882108769634a9f91b1c978a4b9e86b1b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -154,6 +154,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }"}, {"sha": "6074bfd083d46dc82a0f1d8e5080ea8a85d6230e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -114,9 +114,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 self.tcx().types.re_erased\n             }\n \n+            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    \"encountered unexpected region: {:?}\",\n                     r,\n                 );\n             }\n@@ -170,6 +171,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n+            ty::TyInfer(ty::CanonicalTy(..)) =>\n+                bug!(\"encountered canonical ty during freshening\"),\n+\n             ty::TyGenerator(..) |\n             ty::TyBool |\n             ty::TyChar |"}, {"sha": "00b2ac7449f7e9a9ac1e5378296d3c560b25eadb", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -258,6 +258,8 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.region_rels.tcx;\n         match (a, b) {\n+            (&ty::ReCanonical(..), _) |\n+            (_, &ty::ReCanonical(..)) |\n             (&ty::ReClosureBound(..), _) |\n             (_, &ty::ReClosureBound(..)) |\n             (&ReLateBound(..), _) |"}, {"sha": "5127807bf70dc0488613da015be7fe5a496a41a4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -50,6 +50,7 @@ use self::unify_key::ToType;\n \n pub mod anon_types;\n pub mod at;\n+pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -473,6 +474,12 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     }\n }\n \n+impl<'tcx> InferOk<'tcx, ()> {\n+    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n@@ -1644,4 +1651,3 @@ impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n                self.sup_type)\n     }\n }\n-"}, {"sha": "77b3a87c0ed16d50c2fc4a60761d52248015b5d8", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -57,9 +57,9 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n+#![feature(match_default_bindings)]\n #![feature(macro_lifetime_matcher)]\n #![feature(macro_vis_matcher)]\n-#![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(non_exhaustive)]\n #![feature(nonzero)]"}, {"sha": "d8a723e184d2ca3f3d53c005c464434fba1ccbf6", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -119,6 +119,25 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+\n+    (impl<$tcx:lifetime $(, $T:ident)*> for struct $struct_name:path {\n+        $($field:ident),* $(,)*\n+    }) => {\n+        impl<'a, $tcx, $($T,)*> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n+            #[inline]\n+            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n+                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $( $field.hash_stable(__ctx, __hasher));*\n+            }\n+        }\n+    };\n }\n \n #[macro_export]"}, {"sha": "7b4211e487a0eee8134a4e8688a9e0be60c733ce", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -173,6 +173,8 @@ pub struct PerfStats {\n     pub symbol_hash_time: Cell<Duration>,\n     /// The accumulated time spent decoding def path tables from metadata\n     pub decode_def_path_tables_time: Cell<Duration>,\n+    /// Total number of values canonicalized queries constructed.\n+    pub queries_canonicalized: Cell<usize>,\n }\n \n /// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n@@ -858,6 +860,8 @@ impl Session {\n             \"Total time spent decoding DefPath tables:      {}\",\n             duration_to_secs_str(self.perf_stats.decode_def_path_tables_time.get())\n         );\n+        println!(\"Total queries canonicalized:                   {}\",\n+                 self.perf_stats.queries_canonicalized.get());\n     }\n \n     /// We want to know if we're allowed to do an optimization for crate foo from -z fuel=foo=n.\n@@ -1144,6 +1148,7 @@ pub fn build_session_(\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n             decode_def_path_tables_time: Cell::new(Duration::from_secs(0)),\n+            queries_canonicalized: Cell::new(0),\n         },\n         code_stats: RefCell::new(CodeStats::new()),\n         optimization_fuel_crate,"}, {"sha": "f2f54dcedfd6577c3305762dc238149242f6175a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -2083,9 +2083,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n             ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n+            ty::TyInfer(ty::FreshTy(_)) |\n+            ty::TyInfer(ty::FreshIntTy(_)) |\n+            ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2154,9 +2155,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ambiguous\n             }\n \n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n+            ty::TyInfer(ty::FreshTy(_)) |\n+            ty::TyInfer(ty::FreshIntTy(_)) |\n+            ty::TyInfer(ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble builtin bounds of unexpected type: {:?}\",\n                      self_ty);\n             }\n@@ -2195,6 +2197,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyParam(..) |\n             ty::TyForeign(..) |\n             ty::TyProjection(..) |\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |"}, {"sha": "24d3b37f804eed3a00c2c3d7fced48873df38a2c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -23,6 +23,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n use middle::const_val::ConstVal;\n use middle::cstore::{CrateStore, LinkMeta};\n@@ -131,6 +132,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    canonical_var_infos: RefCell<FxHashSet<Interned<'tcx, Slice<CanonicalVarInfo>>>>,\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n@@ -146,6 +148,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             substs: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n+            canonical_var_infos: RefCell::new(FxHashSet()),\n             predicates: RefCell::new(FxHashSet()),\n             const_: RefCell::new(FxHashSet()),\n         }\n@@ -1838,6 +1841,12 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, Slice<CanonicalVarInfo>> {\n+    fn borrow<'a>(&'a self) -> &'a [CanonicalVarInfo] {\n+        &self.0[..]\n+    }\n+}\n+\n impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n         &self.0[..]\n@@ -1970,6 +1979,22 @@ slice_interners!(\n     substs: _intern_substs(Kind)\n );\n \n+// This isn't a perfect fit: CanonicalVarInfo slices are always\n+// allocated in the global arena, so this `intern_method!` macro is\n+// overly general.  But we just return false for the code that checks\n+// whether they belong in the thread-local arena, so no harm done, and\n+// seems better than open-coding the rest.\n+intern_method! {\n+    'tcx,\n+    canonical_var_infos: _intern_canonical_var_infos(\n+        &[CanonicalVarInfo],\n+        alloc_slice,\n+        Deref::deref,\n+        |xs: &[CanonicalVarInfo]| -> &Slice<CanonicalVarInfo> { unsafe { mem::transmute(xs) } },\n+        |_xs: &[CanonicalVarInfo]| -> bool { false }\n+    ) -> Slice<CanonicalVarInfo>\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being\n@@ -2257,6 +2282,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'gcx> {\n+        if ts.len() == 0 {\n+            Slice::empty()\n+        } else {\n+            self.global_tcx()._intern_canonical_var_infos(ts)\n+        }\n+    }\n+\n     pub fn mk_fn_sig<I>(self,\n                         inputs: I,\n                         output: I::Item,"}, {"sha": "8a0253ed2f1156e1a065a0017bfa015b25743af3", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -220,6 +220,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n             ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::TyInfer(ty::CanonicalTy(_)) |\n             ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n             ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n             ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),"}, {"sha": "cae64fd4c95c67ab80cb09dbd97ea76cda8b4831", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -112,8 +112,16 @@ impl FlagComputation {\n                 match infer {\n                     ty::FreshTy(_) |\n                     ty::FreshIntTy(_) |\n-                    ty::FreshFloatTy(_) => {}\n-                    _ => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                    ty::FreshFloatTy(_) |\n+                    ty::CanonicalTy(_) => {\n+                        self.add_flags(TypeFlags::HAS_CANONICAL_VARS);\n+                    }\n+\n+                    ty::TyVar(_) |\n+                    ty::IntVar(_) |\n+                    ty::FloatVar(_) => {\n+                        self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                    }\n                 }\n             }\n "}, {"sha": "93d1585cdc83d785a1b7b07a31d614087aced8a7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -60,7 +60,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n \n use hir;\n \n-pub use self::sty::{Binder, DebruijnIndex};\n+pub use self::sty::{Binder, CanonicalVar, DebruijnIndex};\n pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n@@ -452,6 +452,10 @@ bitflags! {\n         // Currently we can't normalize projections w/ bound regions.\n         const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n \n+        // Set if this includes a \"canonical\" type or region var --\n+        // ought to be true only for the results of canonicalization.\n+        const HAS_CANONICAL_VARS = 1 << 13;\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -470,7 +474,8 @@ bitflags! {\n                                   TypeFlags::HAS_PROJECTION.bits |\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n                                   TypeFlags::HAS_LOCAL_NAMES.bits |\n-                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits;\n+                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n+                                  TypeFlags::HAS_CANONICAL_VARS.bits;\n     }\n }\n "}, {"sha": "109422564c84d31134f594911a4c95138dbaf331", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -1047,6 +1047,9 @@ pub enum RegionKind {\n     /// `ClosureRegionRequirements` that are produced by MIR borrowck.\n     /// See `ClosureRegionRequirements` for more details.\n     ReClosureBound(RegionVid),\n+\n+    /// Canonicalized region, used only when preparing a trait query.\n+    ReCanonical(CanonicalVar),\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n@@ -1091,8 +1094,13 @@ pub enum InferTy {\n     FreshTy(u32),\n     FreshIntTy(u32),\n     FreshFloatTy(u32),\n+\n+    /// Canonicalized type variable, used only when preparing a trait query.\n+    CanonicalTy(CanonicalVar),\n }\n \n+newtype_index!(CanonicalVar);\n+\n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExistentialProjection<'tcx> {\n@@ -1213,6 +1221,10 @@ impl RegionKind {\n             }\n             ty::ReErased => {\n             }\n+            ty::ReCanonical(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_CANONICAL_VARS;\n+            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }"}, {"sha": "a301049fe1c4022da43636eba170082e99629a8b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -40,6 +40,7 @@ const TAG_MASK: usize = 0b11;\n const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n \n+#[derive(Debug)]\n pub enum UnpackedKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),"}, {"sha": "e8ce49d39d299f3f1a13e427b468b0cf2235a952", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -834,6 +834,9 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReCanonical(c) => {\n+                self.hash(c);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 self.hash(db.depth);\n                 self.hash(i);"}, {"sha": "efa53c775ae255380d92631b7fd57ef878f01b72", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -721,6 +721,9 @@ define_print! {\n                 ty::ReEarlyBound(ref data) => {\n                     write!(f, \"{}\", data.name)\n                 }\n+                ty::ReCanonical(_) => {\n+                    write!(f, \"'_\")\n+                }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n                 ty::ReSkolemized(_, br) => {\n@@ -785,6 +788,10 @@ define_print! {\n                     write!(f, \"{:?}\", vid)\n                 }\n \n+                ty::ReCanonical(c) => {\n+                    write!(f, \"'?{}\", c.index())\n+                }\n+\n                 ty::ReSkolemized(id, ref bound_region) => {\n                     write!(f, \"ReSkolemized({:?}, {:?})\", id, bound_region)\n                 }\n@@ -888,6 +895,7 @@ define_print! {\n                     ty::TyVar(_) => write!(f, \"_\"),\n                     ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n                     ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                    ty::CanonicalTy(_) => write!(f, \"_\"),\n                     ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n                     ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n                     ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n@@ -899,6 +907,7 @@ define_print! {\n                 ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::CanonicalTy(v) => write!(f, \"?{:?}\", v.index()),\n                 ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n                 ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n                 ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)"}, {"sha": "a01b3cbf47bee420ae4f8080b725dfb3b97ea11e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -427,6 +427,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             // These cannot exist in borrowck\n             RegionKind::ReVar(..) |\n+            RegionKind::ReCanonical(..) |\n             RegionKind::ReSkolemized(..) |\n             RegionKind::ReClosureBound(..) |\n             RegionKind::ReErased => span_bug!(borrow_span,"}, {"sha": "49234f4ed7fdea35ddf76342525db774d4d1cad3", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n                     ty::ReStatic => self.item_ub,\n \n+                    ty::ReCanonical(_) |\n                     ty::ReEmpty |\n                     ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |"}, {"sha": "459aa9ea488fd808c924ca3ed04540d02e6fdb16", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -23,6 +23,7 @@\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(i128_type)]\n #![feature(from_ref)]\n "}, {"sha": "a5b1a7e57ab4668167dc893fb2bbf003396138d2", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -330,7 +330,7 @@ macro_rules! newtype_index {\n     );\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Hash)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<fn(&I)>"}, {"sha": "f77c22bd895440681a7be3228ca31109f85218ab", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -18,7 +18,9 @@\n #![feature(fs_read_write)]\n #![feature(i128_type)]\n #![feature(libc)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(proc_macro_internals)]\n+#![feature(macro_lifetime_matcher)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(specialization)]"}, {"sha": "84ba13674505f177e6a37a9b55ec25df36ff4bee", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -457,6 +457,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (RegionKind::ReLateBound(_, _), _)\n             | (RegionKind::ReSkolemized(_, _), _)\n             | (RegionKind::ReClosureBound(_), _)\n+            | (RegionKind::ReCanonical(_), _)\n             | (RegionKind::ReErased, _) => {\n                 span_bug!(drop_span, \"region does not make sense in this context\");\n             }"}, {"sha": "953747756517dfb5f3d3bea4df5e5496e12d6f22", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -13,6 +13,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n #![feature(custom_attribute)]\n+#![feature(macro_lifetime_matcher)]\n #![allow(unused_attributes)]\n \n #[macro_use]"}, {"sha": "2a4e92034de844e93c5ff4aa881f7d532d3704c2", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -423,6 +423,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // way early-bound regions do, so we skip them here.\n             }\n \n+            ty::ReCanonical(_) |\n             ty::ReFree(..) |\n             ty::ReClosureBound(..) |\n             ty::ReScope(..) |"}, {"sha": "ff281a53ab7e4b18c383d2a9fe9bcc261868bb5b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/993c1488cc4b0826c3f1076393bf50eef09ba467/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=993c1488cc4b0826c3f1076393bf50eef09ba467", "patch": "@@ -1490,6 +1490,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::ReSkolemized(..) |\n             ty::ReEmpty |\n             ty::ReClosureBound(_) |\n+            ty::ReCanonical(_) |\n             ty::ReErased => None\n         }\n     }"}]}