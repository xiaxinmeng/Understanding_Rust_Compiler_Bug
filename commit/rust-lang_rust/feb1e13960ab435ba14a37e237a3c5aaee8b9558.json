{"sha": "feb1e13960ab435ba14a37e237a3c5aaee8b9558", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYjFlMTM5NjBhYjQzNWJhMTRhMzdlMjM3YTNjNWFhZWU4Yjk1NTg=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-25T21:59:59Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Split `split_grouped_constructor` into smaller functions", "tree": {"sha": "909f202c00b32e695c2948e4ef84f69187f60b2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/909f202c00b32e695c2948e4ef84f69187f60b2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feb1e13960ab435ba14a37e237a3c5aaee8b9558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feb1e13960ab435ba14a37e237a3c5aaee8b9558", "html_url": "https://github.com/rust-lang/rust/commit/feb1e13960ab435ba14a37e237a3c5aaee8b9558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feb1e13960ab435ba14a37e237a3c5aaee8b9558/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f392479de6b003e72f93cb8f9955b3cf4135c2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f392479de6b003e72f93cb8f9955b3cf4135c2cd", "html_url": "https://github.com/rust-lang/rust/commit/f392479de6b003e72f93cb8f9955b3cf4135c2cd"}], "stats": {"total": 674, "additions": 345, "deletions": 329}, "files": [{"sha": "29356cba50efead451e078c5dc0a5e01e8cbf502", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 345, "deletions": 329, "changes": 674, "blob_url": "https://github.com/rust-lang/rust/blob/feb1e13960ab435ba14a37e237a3c5aaee8b9558/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb1e13960ab435ba14a37e237a3c5aaee8b9558/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=feb1e13960ab435ba14a37e237a3c5aaee8b9558", "patch": "@@ -284,7 +284,7 @@\n //!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n //!       to form equivalence classes of subranges of the constructor range for which the behaviour\n //!       of the matrix `P` and new pattern `p` are the same. This is described in more\n-//!       detail in `split_grouped_constructors`.\n+//!       detail in `Constructor::split`.\n //!     + If some constructors are missing from the matrix, it turns out we don't need to do\n //!       anything special (because we know none of the integers are actually wildcards: i.e., we\n //!       can't span wildcards using ranges).\n@@ -409,7 +409,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n         is_my_head_ctor: bool,\n@@ -581,7 +581,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n@@ -832,6 +832,139 @@ impl Slice {\n     fn arity(self) -> u64 {\n         self.pattern_kind().arity()\n     }\n+\n+    /// The exhaustiveness-checking paper does not include any details on\n+    /// checking variable-length slice patterns. However, they are matched\n+    /// by an infinite collection of fixed-length array patterns.\n+    ///\n+    /// Checking the infinite set directly would take an infinite amount\n+    /// of time. However, it turns out that for each finite set of\n+    /// patterns `P`, all sufficiently large array lengths are equivalent:\n+    ///\n+    /// Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+    /// to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+    /// `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+    /// the same subset of `P`.\n+    ///\n+    /// Because of that, each witness for reachability-checking from one\n+    /// of the sufficiently-large lengths can be transformed to an\n+    /// equally-valid witness from any other length, so we only have\n+    /// to check slice lengths from the \"minimal sufficiently-large length\"\n+    /// and below.\n+    ///\n+    /// Note that the fact that there is a *single* `s\u2098` for each `m`\n+    /// not depending on the specific pattern in `P` is important: if\n+    /// you look at the pair of patterns\n+    ///     `[true, ..]`\n+    ///     `[.., false]`\n+    /// Then any slice of length \u22651 that matches one of these two\n+    /// patterns can be trivially turned to a slice of any\n+    /// other length \u22651 that matches them and vice-versa - for\n+    /// but the slice from length 2 `[false, true]` that matches neither\n+    /// of these patterns can't be turned to a slice from length 1 that\n+    /// matches neither of these patterns, so we have to consider\n+    /// slices from length 2 there.\n+    ///\n+    /// Now, to see that that length exists and find it, observe that slice\n+    /// patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+    /// \"variable-length\" patterns (`[_, .., _]`).\n+    ///\n+    /// For fixed-length patterns, all slices with lengths *longer* than\n+    /// the pattern's length have the same outcome (of not matching), so\n+    /// as long as `L` is greater than the pattern's length we can pick\n+    /// any `s\u2098` from that length and get the same result.\n+    ///\n+    /// For variable-length patterns, the situation is more complicated,\n+    /// because as seen above the precise value of `s\u2098` matters.\n+    ///\n+    /// However, for each variable-length pattern `p` with a prefix of length\n+    /// `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+    /// `sl\u209a` elements are examined.\n+    ///\n+    /// Therefore, as long as `L` is positive (to avoid concerns about empty\n+    /// types), all elements after the maximum prefix length and before\n+    /// the maximum suffix length are not examined by any variable-length\n+    /// pattern, and therefore can be added/removed without affecting\n+    /// them - creating equivalent patterns from any sufficiently-large\n+    /// length.\n+    ///\n+    /// Of course, if fixed-length patterns exist, we must be sure\n+    /// that our length is large enough to miss them all, so\n+    /// we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n+    ///\n+    /// for example, with the above pair of patterns, all elements\n+    /// but the first and last can be added/removed, so any\n+    /// witness of length \u22652 (say, `[false, false, true]`) can be\n+    /// turned to a witness from any other length \u22652.\n+    fn split<'p, 'tcx>(\n+        self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        matrix: &Matrix<'p, 'tcx>,\n+    ) -> SmallVec<[Constructor<'tcx>; 1]> {\n+        let (array_len, self_prefix, self_suffix) = match self {\n+            Slice { array_len, kind: VarLen(self_prefix, self_suffix) } => {\n+                (array_len, self_prefix, self_suffix)\n+            }\n+            _ => return smallvec![Slice(self)],\n+        };\n+\n+        let head_ctors =\n+            matrix.heads().filter_map(|pat| pat_constructor(cx.tcx, cx.param_env, pat));\n+\n+        let mut max_prefix_len = self_prefix;\n+        let mut max_suffix_len = self_suffix;\n+        let mut max_fixed_len = 0;\n+\n+        for ctor in head_ctors {\n+            if let Slice(slice) = ctor {\n+                match slice.pattern_kind() {\n+                    FixedLen(len) => {\n+                        max_fixed_len = cmp::max(max_fixed_len, len);\n+                    }\n+                    VarLen(prefix, suffix) => {\n+                        max_prefix_len = cmp::max(max_prefix_len, prefix);\n+                        max_suffix_len = cmp::max(max_suffix_len, suffix);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n+        // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n+        // so that `L = max_prefix_len + max_suffix_len`.\n+        if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n+            // The subtraction can't overflow thanks to the above check.\n+            // The new `max_prefix_len` is also guaranteed to be larger than its previous\n+            // value.\n+            max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n+        }\n+\n+        match array_len {\n+            Some(len) => {\n+                let kind = if max_prefix_len + max_suffix_len < len {\n+                    VarLen(max_prefix_len, max_suffix_len)\n+                } else {\n+                    FixedLen(len)\n+                };\n+                smallvec![Slice(Slice { array_len, kind })]\n+            }\n+            None => {\n+                // `ctor` originally covered the range `(self_prefix +\n+                // self_suffix..infinity)`. We now split it into two: lengths smaller than\n+                // `max_prefix_len + max_suffix_len` are treated independently as\n+                // fixed-lengths slices, and lengths above are captured by a final VarLen\n+                // constructor.\n+                let smaller_lengths =\n+                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLen);\n+                let final_slice = VarLen(max_prefix_len, max_suffix_len);\n+                smaller_lengths\n+                    .chain(Some(final_slice))\n+                    .map(|kind| Slice { array_len, kind })\n+                    .map(Slice)\n+                    .collect()\n+            }\n+        }\n+    }\n }\n \n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n@@ -960,6 +1093,45 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// Some constructors (namely IntRange and Slice) actually stand for a set of actual\n+    /// constructors (integers and fixed-sized slices). When specializing for these\n+    /// constructors, we want to be specialising for the actual underlying constructors.\n+    /// Naively, we would simply return the list of constructors they correspond to. We instead are\n+    /// more clever: if there are constructors that we know will behave the same wrt the current\n+    /// matrix, we keep them grouped. For example, all slices of a sufficiently large length\n+    /// will either be all useful or all non-useful with a given matrix.\n+    ///\n+    /// See the branches for details on how the splitting is done.\n+    ///\n+    /// This function may discard some irrelevant constructors if this preserves behavior and\n+    /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n+    /// matrix, unless all of them are.\n+    ///\n+    /// `hir_id` is `None` when we're evaluating the wildcard pattern. In that case we do not want\n+    /// to lint for overlapping ranges.\n+    fn split<'p>(\n+        self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'tcx>,\n+        matrix: &Matrix<'p, 'tcx>,\n+        hir_id: Option<HirId>,\n+    ) -> SmallVec<[Self; 1]> {\n+        debug!(\"Constructor::split({:#?}, {:#?})\", self, matrix);\n+\n+        match self {\n+            // Fast-track if the range is trivial. In particular, we don't do the overlapping\n+            // ranges check.\n+            IntRange(ctor_range)\n+                if ctor_range.treat_exhaustively(cx.tcx) && !ctor_range.is_singleton() =>\n+            {\n+                ctor_range.split(cx, pcx, matrix, hir_id)\n+            }\n+            Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(cx, matrix),\n+            // Any other constructor can be used unchanged.\n+            _ => smallvec![self],\n+        }\n+    }\n+\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n@@ -1492,7 +1664,7 @@ impl<'tcx> Witness<'tcx> {\n /// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n /// `cx.is_uninhabited()`).\n fn all_constructors<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n     pcx: PatCtxt<'tcx>,\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n@@ -1837,6 +2009,153 @@ impl<'tcx> IntRange<'tcx> {\n         // This is a brand new pattern, so we don't reuse `self.span`.\n         Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n+\n+    /// For exhaustive integer matching, some constructors are grouped within other constructors\n+    /// (namely integer typed values are grouped within ranges). However, when specialising these\n+    /// constructors, we want to be specialising for the underlying constructors (the integers), not\n+    /// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n+    /// mean creating a separate constructor for every single value in the range, which is clearly\n+    /// impractical. However, observe that for some ranges of integers, the specialisation will be\n+    /// identical across all values in that range (i.e., there are equivalence classes of ranges of\n+    /// constructors based on their `U(S(c, P), S(c, p))` outcome). These classes are grouped by\n+    /// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n+    /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n+    /// change.\n+    /// Our solution, therefore, is to split the range constructor into subranges at every single point\n+    /// the group of intersecting patterns changes (using the method described below).\n+    /// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n+    /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n+    /// number of rows in the matrix (i.e., the number of cases in the `match` statement), so we don't\n+    /// need to be worried about matching over gargantuan ranges.\n+    ///\n+    /// Essentially, given the first column of a matrix representing ranges, looking like the following:\n+    ///\n+    /// |------|  |----------| |-------|    ||\n+    ///    |-------| |-------|            |----| ||\n+    ///       |---------|\n+    ///\n+    /// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n+    ///\n+    /// |--|--|||-||||--||---|||-------|  |-|||| ||\n+    ///\n+    /// The logic for determining how to split the ranges is fairly straightforward: we calculate\n+    /// boundaries for each interval range, sort them, then create constructors for each new interval\n+    /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n+    /// merging operation depicted above.)\n+    fn split<'p>(\n+        self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'tcx>,\n+        matrix: &Matrix<'p, 'tcx>,\n+        hir_id: Option<HirId>,\n+    ) -> SmallVec<[Constructor<'tcx>; 1]> {\n+        let ty = pcx.ty;\n+\n+        /// Represents a border between 2 integers. Because the intervals spanning borders\n+        /// must be able to cover every integer, we need to be able to represent\n+        /// 2^128 + 1 such borders.\n+        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+        enum Border {\n+            JustBefore(u128),\n+            AfterMax,\n+        }\n+\n+        // A function for extracting the borders of an integer interval.\n+        fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n+            let (lo, hi) = r.range.into_inner();\n+            let from = Border::JustBefore(lo);\n+            let to = match hi.checked_add(1) {\n+                Some(m) => Border::JustBefore(m),\n+                None => Border::AfterMax,\n+            };\n+            vec![from, to].into_iter()\n+        }\n+\n+        // Collect the span and range of all the intersecting ranges to lint on likely\n+        // incorrect range patterns. (#63987)\n+        let mut overlaps = vec![];\n+        // `borders` is the set of borders between equivalence classes: each equivalence\n+        // class lies between 2 borders.\n+        let row_borders = matrix\n+            .patterns\n+            .iter()\n+            .flat_map(|row| {\n+                IntRange::from_pat(cx.tcx, cx.param_env, row.head()).map(|r| (r, row.len()))\n+            })\n+            .flat_map(|(range, row_len)| {\n+                let intersection = self.intersection(cx.tcx, &range);\n+                let should_lint = self.suspicious_intersection(&range);\n+                if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n+                    // FIXME: for now, only check for overlapping ranges on simple range\n+                    // patterns. Otherwise with the current logic the following is detected\n+                    // as overlapping:\n+                    //   match (10u8, true) {\n+                    //    (0 ..= 125, false) => {}\n+                    //    (126 ..= 255, false) => {}\n+                    //    (0 ..= 255, true) => {}\n+                    //  }\n+                    overlaps.push(range.clone());\n+                }\n+                intersection\n+            })\n+            .flat_map(range_borders);\n+        let self_borders = range_borders(self.clone());\n+        let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n+        borders.sort_unstable();\n+\n+        self.lint_overlapping_patterns(cx.tcx, hir_id, ty, overlaps);\n+\n+        // We're going to iterate through every adjacent pair of borders, making sure that\n+        // each represents an interval of nonnegative length, and convert each such\n+        // interval into a constructor.\n+        borders\n+            .array_windows()\n+            .filter_map(|&pair| match pair {\n+                [Border::JustBefore(n), Border::JustBefore(m)] => {\n+                    if n < m {\n+                        Some(n..=(m - 1))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                [Border::JustBefore(n), Border::AfterMax] => Some(n..=u128::MAX),\n+                [Border::AfterMax, _] => None,\n+            })\n+            .map(|range| IntRange { range, ty, span: pcx.span })\n+            .map(IntRange)\n+            .collect()\n+    }\n+\n+    fn lint_overlapping_patterns(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        hir_id: Option<HirId>,\n+        ty: Ty<'tcx>,\n+        overlaps: Vec<IntRange<'tcx>>,\n+    ) {\n+        if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+            tcx.struct_span_lint_hir(\n+                lint::builtin::OVERLAPPING_PATTERNS,\n+                hir_id,\n+                self.span,\n+                |lint| {\n+                    let mut err = lint.build(\"multiple patterns covering the same range\");\n+                    err.span_label(self.span, \"overlapping patterns\");\n+                    for int_range in overlaps {\n+                        // Use the real type for user display of the ranges:\n+                        err.span_label(\n+                            int_range.span,\n+                            &format!(\n+                                \"this range overlaps on `{}`\",\n+                                IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n+                            ),\n+                        );\n+                    }\n+                    err.emit();\n+                },\n+            );\n+        }\n+    }\n }\n \n /// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -1906,7 +2225,7 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n crate fn is_useful<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n@@ -1993,30 +2312,23 @@ crate fn is_useful<'p, 'tcx>(\n \n     let ret = if let Some(constructor) = pat_constructor(cx.tcx, cx.param_env, v.head()) {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n-        split_grouped_constructors(\n-            cx.tcx,\n-            cx.param_env,\n-            pcx,\n-            vec![constructor],\n-            matrix,\n-            pcx.span,\n-            Some(hir_id),\n-        )\n-        .into_iter()\n-        .map(|c| {\n-            is_useful_specialized(\n-                cx,\n-                matrix,\n-                v,\n-                c,\n-                pcx.ty,\n-                witness_preference,\n-                hir_id,\n-                is_under_guard,\n-            )\n-        })\n-        .find(|result| result.is_useful())\n-        .unwrap_or(NotUseful)\n+        constructor\n+            .split(cx, pcx, matrix, Some(hir_id))\n+            .into_iter()\n+            .map(|c| {\n+                is_useful_specialized(\n+                    cx,\n+                    matrix,\n+                    v,\n+                    c,\n+                    pcx.ty,\n+                    witness_preference,\n+                    hir_id,\n+                    is_under_guard,\n+                )\n+            })\n+            .find(|result| result.is_useful())\n+            .unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n@@ -2045,8 +2357,9 @@ crate fn is_useful<'p, 'tcx>(\n \n         if missing_ctors.is_empty() {\n             let (all_ctors, _) = missing_ctors.into_inner();\n-            split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n+            all_ctors\n                 .into_iter()\n+                .flat_map(|ctor| ctor.split(cx, pcx, matrix, None))\n                 .map(|c| {\n                     is_useful_specialized(\n                         cx,\n@@ -2119,7 +2432,7 @@ crate fn is_useful<'p, 'tcx>(\n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n@@ -2200,303 +2513,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-/// For exhaustive integer matching, some constructors are grouped within other constructors\n-/// (namely integer typed values are grouped within ranges). However, when specialising these\n-/// constructors, we want to be specialising for the underlying constructors (the integers), not\n-/// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n-/// mean creating a separate constructor for every single value in the range, which is clearly\n-/// impractical. However, observe that for some ranges of integers, the specialisation will be\n-/// identical across all values in that range (i.e., there are equivalence classes of ranges of\n-/// constructors based on their `is_useful_specialized` outcome). These classes are grouped by\n-/// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n-/// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n-/// change.\n-/// Our solution, therefore, is to split the range constructor into subranges at every single point\n-/// the group of intersecting patterns changes (using the method described below).\n-/// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n-/// on actual integers. The nice thing about this is that the number of subranges is linear in the\n-/// number of rows in the matrix (i.e., the number of cases in the `match` statement), so we don't\n-/// need to be worried about matching over gargantuan ranges.\n-///\n-/// Essentially, given the first column of a matrix representing ranges, looking like the following:\n-///\n-/// |------|  |----------| |-------|    ||\n-///    |-------| |-------|            |----| ||\n-///       |---------|\n-///\n-/// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n-///\n-/// |--|--|||-||||--||---|||-------|  |-|||| ||\n-///\n-/// The logic for determining how to split the ranges is fairly straightforward: we calculate\n-/// boundaries for each interval range, sort them, then create constructors for each new interval\n-/// between every pair of boundary points. (This essentially sums up to performing the intuitive\n-/// merging operation depicted above.)\n-///\n-/// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n-/// ranges that case.\n-///\n-/// This also splits variable-length slices into fixed-length slices.\n-fn split_grouped_constructors<'p, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    pcx: PatCtxt<'tcx>,\n-    ctors: Vec<Constructor<'tcx>>,\n-    matrix: &Matrix<'p, 'tcx>,\n-    span: Span,\n-    hir_id: Option<HirId>,\n-) -> Vec<Constructor<'tcx>> {\n-    let ty = pcx.ty;\n-    let mut split_ctors = Vec::with_capacity(ctors.len());\n-    debug!(\"split_grouped_constructors({:#?}, {:#?})\", matrix, ctors);\n-\n-    for ctor in ctors.into_iter() {\n-        match ctor {\n-            IntRange(ctor_range) if ctor_range.treat_exhaustively(tcx) => {\n-                // Fast-track if the range is trivial. In particular, don't do the overlapping\n-                // ranges check.\n-                if ctor_range.is_singleton() {\n-                    split_ctors.push(IntRange(ctor_range));\n-                    continue;\n-                }\n-\n-                /// Represents a border between 2 integers. Because the intervals spanning borders\n-                /// must be able to cover every integer, we need to be able to represent\n-                /// 2^128 + 1 such borders.\n-                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-                enum Border {\n-                    JustBefore(u128),\n-                    AfterMax,\n-                }\n-\n-                // A function for extracting the borders of an integer interval.\n-                fn range_borders(r: IntRange<'_>) -> impl Iterator<Item = Border> {\n-                    let (lo, hi) = r.range.into_inner();\n-                    let from = Border::JustBefore(lo);\n-                    let to = match hi.checked_add(1) {\n-                        Some(m) => Border::JustBefore(m),\n-                        None => Border::AfterMax,\n-                    };\n-                    vec![from, to].into_iter()\n-                }\n-\n-                // Collect the span and range of all the intersecting ranges to lint on likely\n-                // incorrect range patterns. (#63987)\n-                let mut overlaps = vec![];\n-                // `borders` is the set of borders between equivalence classes: each equivalence\n-                // class lies between 2 borders.\n-                let row_borders = matrix\n-                    .patterns\n-                    .iter()\n-                    .flat_map(|row| {\n-                        IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))\n-                    })\n-                    .flat_map(|(range, row_len)| {\n-                        let intersection = ctor_range.intersection(tcx, &range);\n-                        let should_lint = ctor_range.suspicious_intersection(&range);\n-                        if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n-                            // FIXME: for now, only check for overlapping ranges on simple range\n-                            // patterns. Otherwise with the current logic the following is detected\n-                            // as overlapping:\n-                            //   match (10u8, true) {\n-                            //    (0 ..= 125, false) => {}\n-                            //    (126 ..= 255, false) => {}\n-                            //    (0 ..= 255, true) => {}\n-                            //  }\n-                            overlaps.push(range.clone());\n-                        }\n-                        intersection\n-                    })\n-                    .flat_map(range_borders);\n-                let ctor_borders = range_borders(ctor_range.clone());\n-                let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n-                borders.sort_unstable();\n-\n-                lint_overlapping_patterns(tcx, hir_id, ctor_range, ty, overlaps);\n-\n-                // We're going to iterate through every adjacent pair of borders, making sure that\n-                // each represents an interval of nonnegative length, and convert each such\n-                // interval into a constructor.\n-                split_ctors.extend(\n-                    borders\n-                        .array_windows()\n-                        .filter_map(|&pair| match pair {\n-                            [Border::JustBefore(n), Border::JustBefore(m)] => {\n-                                if n < m {\n-                                    Some(IntRange { range: n..=(m - 1), ty, span })\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                            [Border::JustBefore(n), Border::AfterMax] => {\n-                                Some(IntRange { range: n..=u128::MAX, ty, span })\n-                            }\n-                            [Border::AfterMax, _] => None,\n-                        })\n-                        .map(IntRange),\n-                );\n-            }\n-            Slice(Slice { array_len, kind: VarLen(self_prefix, self_suffix) }) => {\n-                // The exhaustiveness-checking paper does not include any details on\n-                // checking variable-length slice patterns. However, they are matched\n-                // by an infinite collection of fixed-length array patterns.\n-                //\n-                // Checking the infinite set directly would take an infinite amount\n-                // of time. However, it turns out that for each finite set of\n-                // patterns `P`, all sufficiently large array lengths are equivalent:\n-                //\n-                // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-                // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-                // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-                // the same subset of `P`.\n-                //\n-                // Because of that, each witness for reachability-checking from one\n-                // of the sufficiently-large lengths can be transformed to an\n-                // equally-valid witness from any other length, so we only have\n-                // to check slice lengths from the \"minimal sufficiently-large length\"\n-                // and below.\n-                //\n-                // Note that the fact that there is a *single* `s\u2098` for each `m`\n-                // not depending on the specific pattern in `P` is important: if\n-                // you look at the pair of patterns\n-                //     `[true, ..]`\n-                //     `[.., false]`\n-                // Then any slice of length \u22651 that matches one of these two\n-                // patterns can be trivially turned to a slice of any\n-                // other length \u22651 that matches them and vice-versa - for\n-                // but the slice from length 2 `[false, true]` that matches neither\n-                // of these patterns can't be turned to a slice from length 1 that\n-                // matches neither of these patterns, so we have to consider\n-                // slices from length 2 there.\n-                //\n-                // Now, to see that that length exists and find it, observe that slice\n-                // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-                // \"variable-length\" patterns (`[_, .., _]`).\n-                //\n-                // For fixed-length patterns, all slices with lengths *longer* than\n-                // the pattern's length have the same outcome (of not matching), so\n-                // as long as `L` is greater than the pattern's length we can pick\n-                // any `s\u2098` from that length and get the same result.\n-                //\n-                // For variable-length patterns, the situation is more complicated,\n-                // because as seen above the precise value of `s\u2098` matters.\n-                //\n-                // However, for each variable-length pattern `p` with a prefix of length\n-                // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-                // `sl\u209a` elements are examined.\n-                //\n-                // Therefore, as long as `L` is positive (to avoid concerns about empty\n-                // types), all elements after the maximum prefix length and before\n-                // the maximum suffix length are not examined by any variable-length\n-                // pattern, and therefore can be added/removed without affecting\n-                // them - creating equivalent patterns from any sufficiently-large\n-                // length.\n-                //\n-                // Of course, if fixed-length patterns exist, we must be sure\n-                // that our length is large enough to miss them all, so\n-                // we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n-                //\n-                // for example, with the above pair of patterns, all elements\n-                // but the first and last can be added/removed, so any\n-                // witness of length \u22652 (say, `[false, false, true]`) can be\n-                // turned to a witness from any other length \u22652.\n-\n-                let mut max_prefix_len = self_prefix;\n-                let mut max_suffix_len = self_suffix;\n-                let mut max_fixed_len = 0;\n-\n-                let head_ctors =\n-                    matrix.heads().filter_map(|pat| pat_constructor(tcx, param_env, pat));\n-                for ctor in head_ctors {\n-                    if let Slice(slice) = ctor {\n-                        match slice.pattern_kind() {\n-                            FixedLen(len) => {\n-                                max_fixed_len = cmp::max(max_fixed_len, len);\n-                            }\n-                            VarLen(prefix, suffix) => {\n-                                max_prefix_len = cmp::max(max_prefix_len, prefix);\n-                                max_suffix_len = cmp::max(max_suffix_len, suffix);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n-                // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n-                // so that `L = max_prefix_len + max_suffix_len`.\n-                if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n-                    // The subtraction can't overflow thanks to the above check.\n-                    // The new `max_prefix_len` is also guaranteed to be larger than its previous\n-                    // value.\n-                    max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n-                }\n-\n-                match array_len {\n-                    Some(len) => {\n-                        let kind = if max_prefix_len + max_suffix_len < len {\n-                            VarLen(max_prefix_len, max_suffix_len)\n-                        } else {\n-                            FixedLen(len)\n-                        };\n-                        split_ctors.push(Slice(Slice { array_len, kind }));\n-                    }\n-                    None => {\n-                        // `ctor` originally covered the range `(self_prefix +\n-                        // self_suffix..infinity)`. We now split it into two: lengths smaller than\n-                        // `max_prefix_len + max_suffix_len` are treated independently as\n-                        // fixed-lengths slices, and lengths above are captured by a final VarLen\n-                        // constructor.\n-                        split_ctors.extend(\n-                            (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n-                                .map(|len| Slice(Slice { array_len, kind: FixedLen(len) })),\n-                        );\n-                        split_ctors.push(Slice(Slice {\n-                            array_len,\n-                            kind: VarLen(max_prefix_len, max_suffix_len),\n-                        }));\n-                    }\n-                }\n-            }\n-            // Any other constructor can be used unchanged.\n-            _ => split_ctors.push(ctor),\n-        }\n-    }\n-\n-    debug!(\"split_grouped_constructors(..)={:#?}\", split_ctors);\n-    split_ctors\n-}\n-\n-fn lint_overlapping_patterns<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    hir_id: Option<HirId>,\n-    ctor_range: IntRange<'tcx>,\n-    ty: Ty<'tcx>,\n-    overlaps: Vec<IntRange<'tcx>>,\n-) {\n-    if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n-        tcx.struct_span_lint_hir(\n-            lint::builtin::OVERLAPPING_PATTERNS,\n-            hir_id,\n-            ctor_range.span,\n-            |lint| {\n-                let mut err = lint.build(\"multiple patterns covering the same range\");\n-                err.span_label(ctor_range.span, \"overlapping patterns\");\n-                for int_range in overlaps {\n-                    // Use the real type for user display of the ranges:\n-                    err.span_label(\n-                        int_range.span,\n-                        &format!(\n-                            \"this range overlaps on `{}`\",\n-                            IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n-                        ),\n-                    );\n-                }\n-                err.emit();\n-            },\n-        );\n-    }\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2509,7 +2525,7 @@ fn lint_overlapping_patterns<'tcx>(\n ///\n /// This is roughly the inverse of `Constructor::apply`.\n fn specialize_one_pattern<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,"}]}