{"sha": "134004f74db3b4626bde37cc068d9ae6dedd2d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNDAwNGY3NGRiM2I0NjI2YmRlMzdjYzA2OGQ5YWU2ZGVkZDJkMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T08:42:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T08:42:34Z"}, "message": "Auto merge of #62661 - arielb1:never-reserve, r=nikomatsakis\n\nreserve `impl<T> From<!> for T`\n\nthis is necessary for never-type stabilization.\n\ncc #57012 #35121\n\nI think we wanted a crater run for this @nikomatsakis?\n\nr? @nikomatsakis", "tree": {"sha": "f0c0cd46c057791d6a65b4a1bce470f262ecfee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0c0cd46c057791d6a65b4a1bce470f262ecfee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134004f74db3b4626bde37cc068d9ae6dedd2d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134004f74db3b4626bde37cc068d9ae6dedd2d38", "html_url": "https://github.com/rust-lang/rust/commit/134004f74db3b4626bde37cc068d9ae6dedd2d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134004f74db3b4626bde37cc068d9ae6dedd2d38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc45735f29788924b9fc351d100e5bf3ebdca162", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc45735f29788924b9fc351d100e5bf3ebdca162", "html_url": "https://github.com/rust-lang/rust/commit/dc45735f29788924b9fc351d100e5bf3ebdca162"}, {"sha": "e70724c23bd2bd5cfbbac784d103f2a61a40284f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70724c23bd2bd5cfbbac784d103f2a61a40284f", "html_url": "https://github.com/rust-lang/rust/commit/e70724c23bd2bd5cfbbac784d103f2a61a40284f"}], "stats": {"total": 390, "additions": 339, "deletions": 51}, "files": [{"sha": "3cd2337ee59a579dc8743f28fdfed50b402f598d", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -554,6 +554,18 @@ impl<T> From<T> for T {\n     fn from(t: T) -> T { t }\n }\n \n+/// **Stability note:** This impl does not yet exist, but we are\n+/// \"reserving space\" to add it in the future. See\n+/// [rust-lang/rust#64715][#64715] for details.\n+///\n+/// [#64715]: https://github.com/rust-lang/rust/issues/64715\n+#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n+#[cfg(not(bootstrap))]\n+#[rustc_reservation_impl=\"permitting this impl would forbid us from adding \\\n+`impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n+impl<T> From<!> for T {\n+    fn from(t: !) -> T { t }\n+}\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]"}, {"sha": "38af38b828238660bb884dc621c3856ac9cd4426", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -290,7 +290,7 @@ rustc_queries! {\n         query associated_item(_: DefId) -> ty::AssocItem {}\n \n         query impl_trait_ref(_: DefId) -> Option<ty::TraitRef<'tcx>> {}\n-        query impl_polarity(_: DefId) -> hir::ImplPolarity {}\n+        query impl_polarity(_: DefId) -> ty::ImplPolarity {}\n \n         query issue33140_self_ty(_: DefId) -> Option<ty::Ty<'tcx>> {}\n     }"}, {"sha": "9faf58aee6f924df18f04aa53cff54bf93cffda8", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -321,7 +321,7 @@ impl AutoTraitFinder<'tcx> {\n                     match vtable {\n                         Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) => {\n                             // Blame tidy for the weird bracket placement\n-                            if infcx.tcx.impl_polarity(*impl_def_id) == hir::ImplPolarity::Negative\n+                            if infcx.tcx.impl_polarity(*impl_def_id) == ty::ImplPolarity::Negative\n                             {\n                                 debug!(\"evaluate_nested_obligations: Found explicit negative impl\\\n                                         {:?}, bailing out\", impl_def_id);"}, {"sha": "911ecef802425be027b6effe5849c89dcafe9ee9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -43,6 +43,8 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n+use syntax::attr;\n+use syntax::symbol::sym;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{self, Display};\n@@ -99,6 +101,9 @@ pub enum IntercrateAmbiguityCause {\n         trait_desc: String,\n         self_desc: Option<String>,\n     },\n+    ReservationImpl {\n+        message: String\n+    },\n }\n \n impl IntercrateAmbiguityCause {\n@@ -139,6 +144,11 @@ impl IntercrateAmbiguityCause {\n                     trait_desc, self_desc\n                 )\n             }\n+            &IntercrateAmbiguityCause::ReservationImpl {\n+                ref message\n+            } => {\n+                message.clone()\n+            }\n         }\n     }\n }\n@@ -1326,17 +1336,38 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         (result, dep_node)\n     }\n \n-    // Treat negative impls as unimplemented\n-    fn filter_negative_impls(\n-        &self,\n+    // Treat negative impls as unimplemented, and reservation impls as ambiguity.\n+    fn filter_negative_and_reservation_impls(\n+        &mut self,\n         candidate: SelectionCandidate<'tcx>,\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if let ImplCandidate(def_id) = candidate {\n-            if !self.allow_negative_impls\n-                && self.tcx().impl_polarity(def_id) == hir::ImplPolarity::Negative\n-            {\n-                return Err(Unimplemented);\n-            }\n+            let tcx = self.tcx();\n+            match tcx.impl_polarity(def_id) {\n+                ty::ImplPolarity::Negative if !self.allow_negative_impls => {\n+                    return Err(Unimplemented);\n+                }\n+                ty::ImplPolarity::Reservation => {\n+                    if let Some(intercrate_ambiguity_clauses)\n+                        = &mut self.intercrate_ambiguity_causes\n+                    {\n+                        let attrs = tcx.get_attrs(def_id);\n+                        let attr = attr::find_by_name(&attrs, sym::rustc_reservation_impl);\n+                        let value = attr.and_then(|a| a.value_str());\n+                        if let Some(value) = value {\n+                            debug!(\"filter_negative_and_reservation_impls: \\\n+                                    reservation impl ambiguity on {:?}\", def_id);\n+                            intercrate_ambiguity_clauses.push(\n+                                IntercrateAmbiguityCause::ReservationImpl {\n+                                    message: value.to_string()\n+                                }\n+                            );\n+                        }\n+                    }\n+                    return Ok(None);\n+                }\n+                _ => {}\n+            };\n         }\n         Ok(Some(candidate))\n     }\n@@ -1453,7 +1484,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Instead, we select the right impl now but report `Bar does\n         // not implement Clone`.\n         if candidates.len() == 1 {\n-            return self.filter_negative_impls(candidates.pop().unwrap());\n+            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n@@ -1528,7 +1559,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Just one candidate left.\n-        self.filter_negative_impls(candidates.pop().unwrap().candidate)\n+        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n     }\n \n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n@@ -3728,6 +3759,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n+        if self.intercrate.is_none()\n+            && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n+        {\n+            debug!(\"match_impl: reservation impls only apply in intercrate mode\");\n+            return Err(());\n+        }\n+\n         debug!(\"match_impl: success impl_substs={:?}\", impl_substs);\n         Ok(Normalized {\n             value: impl_substs,"}, {"sha": "bd5ac5e5ab478457c99c664d6b5cb8ca12c8c92e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -167,6 +167,19 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ImplPolarity {\n+    /// `impl Trait for Type`\n+    Positive,\n+    /// `impl !Trait for Type`\n+    Negative,\n+    /// `#[rustc_reservation_impl] impl Trait for Type`\n+    ///\n+    /// This is a \"stability hack\", not a real Rust feature.\n+    /// See #64631 for details.\n+    Reservation,\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct AssocItem {\n     pub def_id: DefId,\n@@ -2911,7 +2924,26 @@ impl<'tcx> TyCtxt<'tcx> {\n             return Some(ImplOverlapKind::Permitted);\n         }\n \n-        let is_legit = if self.features().overlapping_marker_traits {\n+        match (self.impl_polarity(def_id1), self.impl_polarity(def_id2)) {\n+            (ImplPolarity::Reservation, _) |\n+            (_, ImplPolarity::Reservation) => {\n+                // `#[rustc_reservation_impl]` impls don't overlap with anything\n+                debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (reservations)\",\n+                       def_id1, def_id2);\n+                return Some(ImplOverlapKind::Permitted);\n+            }\n+            (ImplPolarity::Positive, ImplPolarity::Negative) |\n+            (ImplPolarity::Negative, ImplPolarity::Positive) => {\n+                // `impl AutoTrait for Type` + `impl !AutoTrait for Type`\n+                debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) - None (differing polarities)\",\n+                       def_id1, def_id2);\n+                return None;\n+            }\n+            (ImplPolarity::Positive, ImplPolarity::Positive) |\n+            (ImplPolarity::Negative, ImplPolarity::Negative) => {}\n+        };\n+\n+        let is_marker_overlap = if self.features().overlapping_marker_traits {\n             let trait1_is_empty = self.impl_trait_ref(def_id1)\n                 .map_or(false, |trait_ref| {\n                     self.associated_item_def_ids(trait_ref.def_id).is_empty()\n@@ -2920,22 +2952,19 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .map_or(false, |trait_ref| {\n                     self.associated_item_def_ids(trait_ref.def_id).is_empty()\n                 });\n-            self.impl_polarity(def_id1) == self.impl_polarity(def_id2)\n-                && trait1_is_empty\n-                && trait2_is_empty\n+            trait1_is_empty && trait2_is_empty\n         } else {\n             let is_marker_impl = |def_id: DefId| -> bool {\n                 let trait_ref = self.impl_trait_ref(def_id);\n                 trait_ref.map_or(false, |tr| self.trait_def(tr.def_id).is_marker)\n             };\n-            self.impl_polarity(def_id1) == self.impl_polarity(def_id2)\n-                && is_marker_impl(def_id1)\n-                && is_marker_impl(def_id2)\n+            is_marker_impl(def_id1) && is_marker_impl(def_id2)\n         };\n \n-        if is_legit {\n-            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted)\",\n-                  def_id1, def_id2);\n+\n+        if is_marker_overlap {\n+            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (marker overlap)\",\n+                   def_id1, def_id2);\n             Some(ImplOverlapKind::Permitted)\n         } else {\n             if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n@@ -3317,7 +3346,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n \n     let is_marker_like =\n-        tcx.impl_polarity(def_id) == hir::ImplPolarity::Positive &&\n+        tcx.impl_polarity(def_id) == ty::ImplPolarity::Positive &&\n         tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n \n     // Check whether these impls would be ok for a marker trait."}, {"sha": "3c6a1c4744696305da2b9e408c7bd41a3f2dd138", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -722,7 +722,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).parent_impl\n     }\n \n-    pub fn get_impl_polarity(&self, id: DefIndex) -> hir::ImplPolarity {\n+    pub fn get_impl_polarity(&self, id: DefIndex) -> ty::ImplPolarity {\n         self.get_impl_data(id).polarity\n     }\n "}, {"sha": "8a68581ff8b14cbc6d67265b71ec66e3b6455629", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -1175,8 +1175,9 @@ impl EncodeContext<'tcx> {\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n-            hir::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+            hir::ItemKind::Impl(_, _, defaultness, ..) => {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n+                let polarity = tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.trait_def(trait_ref.def_id);\n                     trait_def.ancestors(tcx, def_id).nth(1).and_then(|node| {"}, {"sha": "4be70c62035697a93c4ed65df9db1c38d6059ad2", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -328,7 +328,7 @@ pub struct TraitAliasData<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n-    pub polarity: hir::ImplPolarity,\n+    pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n "}, {"sha": "4c30227150fb1850fb371bd24ee1c70aac678ded", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::hir::{self, ImplPolarity};\n+use rustc::hir;\n use rustc::traits::{\n     Clause,\n     Clauses,\n@@ -295,7 +295,7 @@ fn program_clauses_for_trait(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n }\n \n fn program_clauses_for_impl(tcx: TyCtxt<'tcx>, def_id: DefId) -> Clauses<'tcx> {\n-    if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n+    if let ty::ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return List::empty();\n     }\n "}, {"sha": "a5864a32d2c54d8cac2e00140392b8512249cc45", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -94,20 +94,27 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+        hir::ItemKind::Impl(_, _, defaultness, _, ref trait_ref, ref self_ty, _) => {\n             let is_auto = tcx.impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n-                                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+            let polarity = tcx.impl_polarity(def_id);\n             if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n                 tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n             }\n-            if polarity == hir::ImplPolarity::Positive {\n-                check_impl(tcx, item, self_ty, trait_ref);\n-            } else {\n-                // FIXME(#27579): what amount of WF checking do we need for neg impls?\n-                if trait_ref.is_some() && !is_auto {\n-                    span_err!(tcx.sess, item.span, E0192,\n-                              \"negative impls are only allowed for \\\n-                               auto traits (e.g., `Send` and `Sync`)\")\n+            match polarity {\n+                ty::ImplPolarity::Positive => {\n+                    check_impl(tcx, item, self_ty, trait_ref);\n+                }\n+                ty::ImplPolarity::Negative => {\n+                    // FIXME(#27579): what amount of WF checking do we need for neg impls?\n+                    if trait_ref.is_some() && !is_auto {\n+                        span_err!(tcx.sess, item.span, E0192,\n+                                  \"negative impls are only allowed for \\\n+                                   auto traits (e.g., `Send` and `Sync`)\")\n+                    }\n+                }\n+                ty::ImplPolarity::Reservation => {\n+                    // FIXME: what amount of WF checking do we need for reservation impls?\n                 }\n             }\n         }\n@@ -398,16 +405,19 @@ fn check_impl<'tcx>(\n \n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n+                // `#[rustc_reservation_impl]` impls are not real impls and\n+                // therefore don't need to be WF (the trait's `Self: Trait` predicate\n+                // won't hold).\n                 let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(\n                         ast_trait_ref.path.span, &trait_ref);\n                 let obligations =\n                     ty::wf::trait_obligations(fcx,\n-                                                fcx.param_env,\n-                                                fcx.body_id,\n-                                                &trait_ref,\n-                                                ast_trait_ref.path.span);\n+                                              fcx.param_env,\n+                                              fcx.body_id,\n+                                              &trait_ref,\n+                                              ast_trait_ref.path.span);\n                 for obligation in obligations {\n                     fcx.register_predicate(obligation);\n                 }"}, {"sha": "d1643cbb87aba050cb48397608b36c87cd167268", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -1889,10 +1889,30 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     }\n }\n \n-fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> hir::ImplPolarity {\n+fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item(hir_id).node {\n-        hir::ItemKind::Impl(_, polarity, ..) => polarity,\n+    let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n+    let item = tcx.hir().expect_item(hir_id);\n+    match &item.node {\n+        hir::ItemKind::Impl(_, hir::ImplPolarity::Negative, ..) => {\n+            if is_rustc_reservation {\n+                tcx.sess.span_err(item.span, \"reservation impls can't be negative\");\n+            }\n+            ty::ImplPolarity::Negative\n+        }\n+        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, None, _, _) => {\n+            if is_rustc_reservation {\n+                tcx.sess.span_err(item.span, \"reservation impls can't be inherent\");\n+            }\n+            ty::ImplPolarity::Positive\n+        }\n+        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, Some(_tr), _, _) => {\n+            if is_rustc_reservation {\n+                ty::ImplPolarity::Reservation\n+            } else {\n+                ty::ImplPolarity::Positive\n+            }\n+        }\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item),\n     }\n }"}, {"sha": "3972d77385dc8c4f054bae7e52ea6910bb99376f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -3855,11 +3855,13 @@ pub enum ImplPolarity {\n     Negative,\n }\n \n-impl Clean<ImplPolarity> for hir::ImplPolarity {\n+impl Clean<ImplPolarity> for ty::ImplPolarity {\n     fn clean(&self, _: &DocContext<'_>) -> ImplPolarity {\n         match self {\n-            &hir::ImplPolarity::Positive => ImplPolarity::Positive,\n-            &hir::ImplPolarity::Negative => ImplPolarity::Negative,\n+            &ty::ImplPolarity::Positive |\n+            // FIXME: do we want to do something else here?\n+            &ty::ImplPolarity::Reservation => ImplPolarity::Positive,\n+            &ty::ImplPolarity::Negative => ImplPolarity::Negative,\n         }\n     }\n }\n@@ -3891,6 +3893,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n         let items = self.items.iter().map(|ii| ii.clean(cx)).collect::<Vec<_>>();\n+        let def_id = cx.tcx.hir().local_def_id(self.id);\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n@@ -3909,7 +3912,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id),\n+            def_id,\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n@@ -3920,7 +3923,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n                 trait_,\n                 for_: self.for_.clean(cx),\n                 items,\n-                polarity: Some(self.polarity.clean(cx)),\n+                polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n                 synthetic: false,\n                 blanket_impl: None,\n             })"}, {"sha": "d14afc6deaa69b238612282706d518377d1923bc", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -457,7 +457,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n     // Internal attributes, Misc:\n     // ==========================================================================\n-\n     gated!(\n         lang, Normal, template!(NameValueStr: \"name\"), lang_items,\n         \"language items are subject to change\",\n@@ -498,6 +497,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         overflow checking behavior of several libcore functions that are inlined \\\n         across crates and will never be stable\",\n     ),\n+    rustc_attr!(rustc_reservation_impl, Normal, template!(NameValueStr: \"reservation message\"),\n+                \"the `#[rustc_reservation_impl]` attribute is internally used \\\n+                 for reserving for `for<T> From<!> for T` impl\"\n+    ),\n     rustc_attr!(\n         rustc_test_marker, Normal, template!(Word),\n         \"the `#[rustc_test_marker]` attribute is used internally to track tests\","}, {"sha": "32af930ffb88414ebba323bc271e5fbd36caf84c", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -606,6 +606,7 @@ symbols! {\n         rustc_std_internal_symbol,\n         rustc_symbol_name,\n         rustc_synthetic,\n+        rustc_reservation_impl,\n         rustc_test_marker,\n         rustc_then_this_would_need,\n         rustc_variance,"}, {"sha": "9d16015bdc129bd5e0a5c43ccb674ca1727a98e0", "filename": "src/test/ui/never-from-impl-is-reserved.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,12 @@\n+// check that the `for<T> T: From<!>` impl is reserved\n+\n+#![feature(never_type)]\n+\n+pub struct MyFoo;\n+pub trait MyTrait {}\n+\n+impl MyTrait for MyFoo {}\n+// This will conflict with the first impl if we impl `for<T> T: From<!>`.\n+impl<T> MyTrait for T where T: From<!> {} //~ ERROR conflicting implementation\n+\n+fn main() {}"}, {"sha": "8b8d0f4ea73bea6f27ca5e1e6efb48cd9d337e7f", "filename": "src/test/ui/never-from-impl-is-reserved.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever-from-impl-is-reserved.stderr?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,14 @@\n+error[E0119]: conflicting implementations of trait `MyTrait` for type `MyFoo`:\n+  --> $DIR/never-from-impl-is-reserved.rs:10:1\n+   |\n+LL | impl MyTrait for MyFoo {}\n+   | ---------------------- first implementation here\n+LL | // This will conflict with the first impl if we impl `for<T> T: From<!>`.\n+LL | impl<T> MyTrait for T where T: From<!> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyFoo`\n+   |\n+   = note: permitting this impl would forbid us from adding `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "775278c30cd4cbc51efb667ec72a3e143e43cff1", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-coherence-conflict.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,16 @@\n+// compile-fail\n+\n+// check that reservation impls are accounted for in negative reasoning.\n+\n+#![feature(rustc_attrs)]\n+\n+trait MyTrait {}\n+#[rustc_reservation_impl=\"this impl is reserved\"]\n+impl MyTrait for () {}\n+\n+trait OtherTrait {}\n+impl OtherTrait for () {}\n+impl<T: MyTrait> OtherTrait for T {}\n+//~^ ERROR conflicting implementations\n+\n+fn main() {}"}, {"sha": "47e141bd048ebb16e86017ade0a77cf31bfd5494", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-coherence-conflict.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-coherence-conflict.stderr?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,13 @@\n+error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`:\n+  --> $DIR/reservation-impl-coherence-conflict.rs:13:1\n+   |\n+LL | impl OtherTrait for () {}\n+   | ---------------------- first implementation here\n+LL | impl<T: MyTrait> OtherTrait for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+   |\n+   = note: this impl is reserved\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "3391daaabe975a663c62f3f44a8a6ae14f0198b7", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-no-use.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,14 @@\n+// compile-fail\n+\n+// check that reservation impls can't be used as normal impls in positive reasoning.\n+\n+#![feature(rustc_attrs)]\n+\n+trait MyTrait { fn foo(&self); }\n+#[rustc_reservation_impl = \"foo\"]\n+impl MyTrait for () { fn foo(&self) {} }\n+\n+fn main() {\n+    <() as MyTrait>::foo(&());\n+    //~^ ERROR the trait bound `(): MyTrait` is not satisfied\n+}"}, {"sha": "0cd56b978f10c43e3bf1832c43ee78678e37e7af", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-no-use.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-no-use.stderr?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `(): MyTrait` is not satisfied\n+  --> $DIR/reservation-impl-no-use.rs:12:26\n+   |\n+LL | trait MyTrait { fn foo(&self); }\n+   |                 -------------- required by `MyTrait::foo`\n+...\n+LL |     <() as MyTrait>::foo(&());\n+   |                          ^^^ the trait `MyTrait` is not implemented for `()`\n+   |\n+   = help: the following implementations were found:\n+             <() as MyTrait>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f14589ccf846d07e06fb6f6f2262c36602bc1e5e", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-non-lattice-ok.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-non-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-non-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-non-lattice-ok.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,59 @@\n+// build-pass\n+\n+// Check that a reservation impl does not force other impls to follow\n+// a lattice discipline.\n+\n+// Why did we ever want to do this?\n+//\n+// We want to eventually add a `impl<T> From<!> for T` impl. That impl conflicts\n+// with existing impls - at least the `impl<T> From<T> for T` impl. There are\n+// 2 ways we thought of for dealing with that conflict:\n+//\n+// 1. Using specialization and doing some handling for the\n+// overlap. The current thought is to require [\"intersection\n+// impls\"][ii], specialization\", which means providing an\n+// (higher-priority) impl for the intersection of every 2 conflicting\n+// impls that determines what happens in the intersection case. That's\n+// the first thing we thought about - see e.g.\n+// https://github.com/rust-lang/rust/issues/57012#issuecomment-452150775\n+//\n+// 2. The other way is to notice that `impl From<!> for T` is basically a\n+// marker trait since its only method is uninhabited, and allow for \"marker\n+// trait overlap\", where the conflict \"doesn't matter\" because it can't\n+// actually cause any ambiguity.\n+//\n+// Now it turned out lattice specialization doesn't work it, because an\n+// `impl<T> From<T> for Smaht<T>` would require a `impl From<!> for Smaht<!>`,\n+// breaking backwards-compatibility in a fairly painful way. So if we want to\n+// go with a known approach, we should go with a \"marker trait overlap\"-style\n+// approach.\n+//\n+// [ii]: http://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\n+\n+#![feature(rustc_attrs, never_type)]\n+\n+trait MyTrait {}\n+\n+impl MyTrait for ! {}\n+\n+trait MyFrom<T> {\n+    fn my_from(x: T) -> Self;\n+}\n+\n+// Given the \"normal\" impls for From\n+#[rustc_reservation_impl=\"this impl is reserved\"]\n+impl<T> MyFrom<!> for T {\n+    fn my_from(x: !) -> Self { match x {} }\n+}\n+\n+impl<T> MyFrom<T> for T {\n+    fn my_from(x: T) -> Self { x }\n+}\n+\n+// ... we *do* want to allow this common pattern, of `From<!> for MySmaht<T>`\n+struct MySmaht<T>(T);\n+impl<T> MyFrom<T> for MySmaht<T> {\n+    fn my_from(x: T) -> Self { MySmaht(x) }\n+}\n+\n+fn main() {}"}, {"sha": "611c8d8841323b117f0e06a88589817d042bda1a", "filename": "src/test/ui/traits/reservation-impls/reservation-impl-ok.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134004f74db3b4626bde37cc068d9ae6dedd2d38/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impls%2Freservation-impl-ok.rs?ref=134004f74db3b4626bde37cc068d9ae6dedd2d38", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+\n+// rpass test for reservation impls. Not 100% required because `From` uses them,\n+// but still.\n+\n+#![feature(rustc_attrs)]\n+\n+use std::mem;\n+\n+trait MyTrait<S> {\n+    fn foo(&self, s: S) -> usize;\n+}\n+\n+#[rustc_reservation_impl = \"foo\"]\n+impl<T> MyTrait<u64> for T {\n+    fn foo(&self, _x: u64) -> usize { 0 }\n+}\n+\n+// reservation impls don't create coherence conflicts, even with\n+// non-chain overlap.\n+impl<S> MyTrait<S> for u32 {\n+    fn foo(&self, _x: S) -> usize { mem::size_of::<S>() }\n+}\n+\n+fn main() {\n+    // ...and the non-reservation impl gets picked.XS\n+    assert_eq!(0u32.foo(0u64), mem::size_of::<u64>());\n+}"}]}