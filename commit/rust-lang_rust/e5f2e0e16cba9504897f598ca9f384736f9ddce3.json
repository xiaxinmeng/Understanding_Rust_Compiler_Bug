{"sha": "e5f2e0e16cba9504897f598ca9f384736f9ddce3", "node_id": "C_kwDOAAsO6NoAKGU1ZjJlMGUxNmNiYTk1MDQ4OTdmNTk4Y2E5ZjM4NDczNmY5ZGRjZTM", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-28T08:41:49Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-06-30T07:59:21Z"}, "message": "lint: port improper ctypes diagnostics\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "aace9a94d719247c4d1e49797f8b65e6457de036", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aace9a94d719247c4d1e49797f8b65e6457de036"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f2e0e16cba9504897f598ca9f384736f9ddce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f2e0e16cba9504897f598ca9f384736f9ddce3", "html_url": "https://github.com/rust-lang/rust/commit/e5f2e0e16cba9504897f598ca9f384736f9ddce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f2e0e16cba9504897f598ca9f384736f9ddce3/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a9bef4d83a091be25fdf0f1beaade66eec0cd92", "html_url": "https://github.com/rust-lang/rust/commit/7a9bef4d83a091be25fdf0f1beaade66eec0cd92"}], "stats": {"total": 187, "additions": 124, "deletions": 63}, "files": [{"sha": "e9fa3de1b05d7b6aa09402ecc85e4986204e0fc3", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e5f2e0e16cba9504897f598ca9f384736f9ddce3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e5f2e0e16cba9504897f598ca9f384736f9ddce3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=e5f2e0e16cba9504897f598ca9f384736f9ddce3", "patch": "@@ -172,3 +172,61 @@ lint-overflowing-literal = literal out of range for `{$ty}`\n     .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n \n lint-unused-comparisons = comparison is useless due to type limits\n+\n+lint-improper-ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n+    .label = not FFI-safe\n+    .note = the type is defined here\n+\n+lint-improper-ctypes-opaque = opaque types have no C equivalent\n+\n+lint-improper-ctypes-fnptr-reason = this function pointer has Rust-specific calling convention\n+lint-improper-ctypes-fnptr-help = consider using an `extern fn(...) -> ...` function pointer instead\n+\n+lint-improper-ctypes-tuple-reason = tuples have unspecified layout\n+lint-improper-ctypes-tuple-help = consider using a struct instead\n+\n+lint-improper-ctypes-str-reason = string slices have no C equivalent\n+lint-improper-ctypes-str-help = consider using `*const u8` and a length instead\n+\n+lint-improper-ctypes-dyn = trait objects have no C equivalent\n+\n+lint-improper-ctypes-slice-reason = slices have no C equivalent\n+lint-improper-ctypes-slice-help = consider using a raw pointer instead\n+\n+lint-improper-ctypes-128bit = 128-bit integers don't currently have a known stable ABI\n+\n+lint-improper-ctypes-char-reason = the `char` type has no C equivalent\n+lint-improper-ctypes-char-help = consider using `u32` or `libc::wchar_t` instead\n+\n+lint-improper-ctypes-non-exhaustive = this enum is non-exhaustive\n+lint-improper-ctypes-non-exhaustive-variant = this enum has non-exhaustive variants\n+\n+lint-improper-ctypes-enum-repr-reason = enum has no representation hint\n+lint-improper-ctypes-enum-repr-help =\n+    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n+\n+lint-improper-ctypes-struct-fieldless-reason = this struct has no fields\n+lint-improper-ctypes-struct-fieldless-help = consider adding a member to this struct\n+\n+lint-improper-ctypes-union-fieldless-reason = this union has no fields\n+lint-improper-ctypes-union-fieldless-help = consider adding a member to this union\n+\n+lint-improper-ctypes-struct-non-exhaustive = this struct is non-exhaustive\n+lint-improper-ctypes-union-non-exhaustive = this union is non-exhaustive\n+\n+lint-improper-ctypes-struct-layout-reason = this struct has unspecified layout\n+lint-improper-ctypes-struct-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n+\n+lint-improper-ctypes-union-layout-reason = this union has unspecified layout\n+lint-improper-ctypes-union-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n+\n+lint-improper-ctypes-box = box cannot be represented as a single pointer\n+\n+lint-improper-ctypes-enum-phantomdata = this enum contains a PhantomData field\n+\n+lint-improper-ctypes-struct-zst = this struct contains only zero-sized fields\n+\n+lint-improper-ctypes-array-reason = passing raw arrays by value is not FFI-safe\n+lint-improper-ctypes-array-help = consider passing a pointer to the array\n+\n+lint-improper-ctypes-only-phantomdata = composed only of `PhantomData`"}, {"sha": "0b6707645705e62281a2a9e33dff200e40ac4b77", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e5f2e0e16cba9504897f598ca9f384736f9ddce3/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f2e0e16cba9504897f598ca9f384736f9ddce3/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e5f2e0e16cba9504897f598ca9f384736f9ddce3", "patch": "@@ -2,7 +2,7 @@ use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{fluent, Applicability};\n+use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n@@ -664,7 +664,7 @@ struct ImproperCTypesVisitor<'a, 'tcx> {\n enum FfiResult<'tcx> {\n     FfiSafe,\n     FfiPhantom(Ty<'tcx>),\n-    FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n+    FfiUnsafe { ty: Ty<'tcx>, reason: DiagnosticMessage, help: Option<DiagnosticMessage> },\n }\n \n pub(crate) fn nonnull_optimization_guaranteed<'tcx>(\n@@ -824,8 +824,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             self.emit_ffi_unsafe_type_lint(\n                 ty,\n                 sp,\n-                \"passing raw arrays by value is not FFI-safe\",\n-                Some(\"consider passing a pointer to the array\"),\n+                fluent::lint::improper_ctypes_array_reason,\n+                Some(fluent::lint::improper_ctypes_array_help),\n             );\n             true\n         } else {\n@@ -868,11 +868,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             } else {\n                 // All fields are ZSTs; this means that the type should behave\n                 // like (), which is FFI-unsafe\n-                FfiUnsafe {\n-                    ty,\n-                    reason: \"this struct contains only zero-sized fields\".into(),\n-                    help: None,\n-                }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_struct_zst, help: None }\n             }\n         } else {\n             // We can't completely trust repr(C) markings; make sure the fields are\n@@ -886,7 +882,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     FfiPhantom(..) if def.is_enum() => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"this enum contains a PhantomData field\".into(),\n+                            reason: fluent::lint::improper_ctypes_enum_phantomdata,\n                             help: None,\n                         };\n                     }\n@@ -922,7 +918,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     } else {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"box cannot be represented as a single pointer\".to_string(),\n+                            reason: fluent::lint::improper_ctypes_box,\n                             help: None,\n                         };\n                     }\n@@ -932,17 +928,19 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n-                        let kind = if def.is_struct() { \"struct\" } else { \"union\" };\n-\n                         if !def.repr().c() && !def.repr().transparent() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} has unspecified layout\", kind),\n-                                help: Some(format!(\n-                                    \"consider adding a `#[repr(C)]` or \\\n-                                             `#[repr(transparent)]` attribute to this {}\",\n-                                    kind\n-                                )),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_layout_reason\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_layout_reason\n+                                },\n+                                help: if def.is_struct() {\n+                                    Some(fluent::lint::improper_ctypes_struct_layout_help)\n+                                } else {\n+                                    Some(fluent::lint::improper_ctypes_union_layout_help)\n+                                },\n                             };\n                         }\n \n@@ -951,16 +949,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if is_non_exhaustive && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} is non-exhaustive\", kind),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_non_exhaustive\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_non_exhaustive\n+                                },\n                                 help: None,\n                             };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} has no fields\", kind),\n-                                help: Some(format!(\"consider adding a member to this {}\", kind)),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_fieldless_reason\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_fieldless_reason\n+                                },\n+                                help: if def.is_struct() {\n+                                    Some(fluent::lint::improper_ctypes_struct_fieldless_help)\n+                                } else {\n+                                    Some(fluent::lint::improper_ctypes_union_fieldless_help)\n+                                },\n                             };\n                         }\n \n@@ -980,21 +990,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"enum has no representation hint\".into(),\n-                                    help: Some(\n-                                        \"consider adding a `#[repr(C)]`, \\\n-                                                `#[repr(transparent)]`, or integer `#[repr(...)]` \\\n-                                                attribute to this enum\"\n-                                            .into(),\n-                                    ),\n+                                    reason: fluent::lint::improper_ctypes_enum_repr_reason,\n+                                    help: Some(fluent::lint::improper_ctypes_enum_repr_help),\n                                 };\n                             }\n                         }\n \n                         if def.is_variant_list_non_exhaustive() && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this enum is non-exhaustive\".into(),\n+                                reason: fluent::lint::improper_ctypes_non_exhaustive,\n                                 help: None,\n                             };\n                         }\n@@ -1005,7 +1010,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"this enum has non-exhaustive variants\".into(),\n+                                    reason: fluent::lint::improper_ctypes_non_exhaustive_variant,\n                                     help: None,\n                                 };\n                             }\n@@ -1023,39 +1028,37 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: \"the `char` type has no C equivalent\".into(),\n-                help: Some(\"consider using `u32` or `libc::wchar_t` instead\".into()),\n+                reason: fluent::lint::improper_ctypes_char_reason,\n+                help: Some(fluent::lint::improper_ctypes_char_help),\n             },\n \n-            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => FfiUnsafe {\n-                ty,\n-                reason: \"128-bit integers don't currently have a known stable ABI\".into(),\n-                help: None,\n-            },\n+            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => {\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_128bit, help: None }\n+            }\n \n             // Primitive types with a stable representation.\n             ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: \"slices have no C equivalent\".into(),\n-                help: Some(\"consider using a raw pointer instead\".into()),\n+                reason: fluent::lint::improper_ctypes_slice_reason,\n+                help: Some(fluent::lint::improper_ctypes_slice_help),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\".into(), help: None }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_dyn, help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: \"string slices have no C equivalent\".into(),\n-                help: Some(\"consider using `*const u8` and a length instead\".into()),\n+                reason: fluent::lint::improper_ctypes_str_reason,\n+                help: Some(fluent::lint::improper_ctypes_str_help),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: \"tuples have unspecified layout\".into(),\n-                help: Some(\"consider using a struct instead\".into()),\n+                reason: fluent::lint::improper_ctypes_tuple_reason,\n+                help: Some(fluent::lint::improper_ctypes_tuple_help),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n@@ -1086,12 +1089,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if self.is_internal_abi(sig.abi()) {\n                     return FfiUnsafe {\n                         ty,\n-                        reason: \"this function pointer has Rust-specific calling convention\".into(),\n-                        help: Some(\n-                            \"consider using an `extern fn(...) -> ...` \\\n-                                    function pointer instead\"\n-                                .into(),\n-                        ),\n+                        reason: fluent::lint::improper_ctypes_fnptr_reason,\n+                        help: Some(fluent::lint::improper_ctypes_fnptr_help),\n                     };\n                 }\n \n@@ -1122,7 +1121,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n             ty::Opaque(..) => {\n-                FfiUnsafe { ty, reason: \"opaque types have no C equivalent\".into(), help: None }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n@@ -1148,8 +1147,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         sp: Span,\n-        note: &str,\n-        help: Option<&str>,\n+        note: DiagnosticMessage,\n+        help: Option<DiagnosticMessage>,\n     ) {\n         let lint = match self.mode {\n             CItemKind::Declaration => IMPROPER_CTYPES,\n@@ -1161,18 +1160,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n-            let mut diag = lint.build(&format!(\n-                \"`extern` {} uses type `{}`, which is not FFI-safe\",\n-                item_description, ty\n-            ));\n-            diag.span_label(sp, \"not FFI-safe\");\n+            let mut diag = lint.build(fluent::lint::improper_ctypes);\n+            diag.set_arg(\"ty\", ty);\n+            diag.set_arg(\"desc\", item_description);\n+            diag.span_label(sp, fluent::lint::label);\n             if let Some(help) = help {\n                 diag.help(help);\n             }\n             diag.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    diag.span_note(sp, \"the type is defined here\");\n+                    diag.span_note(sp, fluent::lint::note);\n                 }\n             }\n             diag.emit();\n@@ -1209,7 +1207,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let Some(ty) = ty.visit_with(&mut ProhibitOpaqueTypes { cx: self.cx }).break_value() {\n-            self.emit_ffi_unsafe_type_lint(ty, sp, \"opaque types have no C equivalent\", None);\n+            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint::improper_ctypes_opaque, None);\n             true\n         } else {\n             false\n@@ -1251,13 +1249,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n+                self.emit_ffi_unsafe_type_lint(\n+                    ty,\n+                    sp,\n+                    fluent::lint::improper_ctypes_only_phantomdata,\n+                    None,\n+                );\n             }\n             // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n             // argument, which after substitution, is `()`, then this branch can be hit.\n             FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => {}\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n+                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n         }\n     }"}]}