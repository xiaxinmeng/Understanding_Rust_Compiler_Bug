{"sha": "60bd3f96779dbe6bd206dae09395e9af7d580552", "node_id": "C_kwDOAAsO6NoAKDYwYmQzZjk2Nzc5ZGJlNmJkMjA2ZGFlMDkzOTVlOWFmN2Q1ODA1NTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T22:39:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T22:39:05Z"}, "message": "Auto merge of #102700 - oli-obk:0xDEAD_TAIT, r=compiler-errors\n\nCheck hidden types in dead code\n\nfixes #99490\n\nr? `@compiler-errors`\n\nbest reviewed commit by commit", "tree": {"sha": "f0013545a9fca748f834d445b77d2778534210ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0013545a9fca748f834d445b77d2778534210ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60bd3f96779dbe6bd206dae09395e9af7d580552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60bd3f96779dbe6bd206dae09395e9af7d580552", "html_url": "https://github.com/rust-lang/rust/commit/60bd3f96779dbe6bd206dae09395e9af7d580552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60bd3f96779dbe6bd206dae09395e9af7d580552/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b3ede3f7bc502eba7bbd202b4b9312d812adcd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b3ede3f7bc502eba7bbd202b4b9312d812adcd7", "html_url": "https://github.com/rust-lang/rust/commit/6b3ede3f7bc502eba7bbd202b4b9312d812adcd7"}, {"sha": "3c8b46cab91b312fe148ae4ce576fa5a2c13e6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c8b46cab91b312fe148ae4ce576fa5a2c13e6b3", "html_url": "https://github.com/rust-lang/rust/commit/3c8b46cab91b312fe148ae4ce576fa5a2c13e6b3"}], "stats": {"total": 706, "additions": 387, "deletions": 319}, "files": [{"sha": "56987edd1b6e387b40926b1df873502f1d7b2b22", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 248, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -2,12 +2,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n@@ -16,8 +14,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n-use crate::session_diagnostics::ConstNotUsedTraitAlias;\n-\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -229,31 +225,9 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            opaque_type_key,\n-            map,\n-            instantiated_ty.ty,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n+        let definition_ty = instantiated_ty\n+            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n+            .ty;\n \n         if !check_opaque_type_parameter_valid(\n             self.tcx,\n@@ -269,6 +243,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let OpaqueTyOrigin::TyAlias = origin else {\n             return definition_ty;\n         };\n+        let def_id = opaque_type_key.def_id;\n         // This logic duplicates most of `check_opaque_meets_bounds`.\n         // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n         let param_env = self.tcx.param_env(def_id);\n@@ -284,6 +259,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             .to_predicate(infcx.tcx);\n         let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n+\n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n         match infcx.register_hidden_type(\n@@ -424,221 +401,3 @@ fn check_opaque_type_parameter_valid(\n     }\n     true\n }\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    key: ty::OpaqueTypeKey<'tcx>,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    do_not_error: bool,\n-\n-    /// initially `Some`, set to `None` once error has been reported\n-    hidden_ty: Option<Ty<'tcx>>,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        key: ty::OpaqueTypeKey<'tcx>,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        hidden_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Self {\n-        Self { tcx, key, map, do_not_error: false, hidden_ty: Some(hidden_ty), span }\n-    }\n-\n-    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        self.do_not_error = true;\n-        let kind = kind.fold_with(self);\n-        self.do_not_error = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n-\n-            ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        let generics = self.tcx().generics_of(self.key.def_id);\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.do_not_error => self.tcx.lifetimes.re_static,\n-            None if generics.parent.is_some() => {\n-                if let Some(hidden_ty) = self.hidden_ty.take() {\n-                    unexpected_hidden_region_diagnostic(\n-                        self.tcx,\n-                        self.tcx.def_span(self.key.def_id),\n-                        hidden_ty,\n-                        r,\n-                        self.key,\n-                    )\n-                    .emit();\n-                }\n-                self.tcx.lifetimes.re_static\n-            }\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n-                            ct: ct.to_string(),\n-                            span: self.span,\n-                        });\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}"}, {"sha": "ff667896eb1076244981405606ffa01ee5cc3141", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -52,15 +52,6 @@ pub(crate) struct VarNeedNotMut {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(borrowck::const_not_used_in_type_alias)]\n-pub(crate) struct ConstNotUsedTraitAlias {\n-    pub ct: String,\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(borrowck::var_cannot_escape_closure)]\n #[note]"}, {"sha": "e3e4a934ab5630db01dd969e32bb594fb2bb9e84", "filename": "compiler/rustc_hir_analysis/src/check/writeback.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -536,33 +536,36 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let opaque_types =\n             self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n         for (opaque_type_key, decl) in opaque_types {\n-            let hidden_type = match decl.origin {\n-                hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_) => {\n-                    let ty = self.resolve(decl.hidden_type.ty, &decl.hidden_type.span);\n-                    struct RecursionChecker {\n-                        def_id: LocalDefId,\n-                    }\n-                    impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n-                        type BreakTy = ();\n-                        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                            if let ty::Opaque(def_id, _) = *t.kind() {\n-                                if def_id == self.def_id.to_def_id() {\n-                                    return ControlFlow::Break(());\n-                                }\n-                            }\n-                            t.super_visit_with(self)\n+            let hidden_type = self.resolve(decl.hidden_type, &decl.hidden_type.span);\n+            let opaque_type_key = self.resolve(opaque_type_key, &decl.hidden_type.span);\n+\n+            struct RecursionChecker {\n+                def_id: LocalDefId,\n+            }\n+            impl<'tcx> ty::TypeVisitor<'tcx> for RecursionChecker {\n+                type BreakTy = ();\n+                fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                    if let ty::Opaque(def_id, _) = *t.kind() {\n+                        if def_id == self.def_id.to_def_id() {\n+                            return ControlFlow::Break(());\n                         }\n                     }\n-                    if ty\n-                        .visit_with(&mut RecursionChecker { def_id: opaque_type_key.def_id })\n-                        .is_break()\n-                    {\n-                        return;\n-                    }\n-                    Some(ty)\n+                    t.super_visit_with(self)\n                 }\n-                hir::OpaqueTyOrigin::TyAlias => None,\n-            };\n+            }\n+            if hidden_type\n+                .visit_with(&mut RecursionChecker { def_id: opaque_type_key.def_id })\n+                .is_break()\n+            {\n+                continue;\n+            }\n+\n+            let hidden_type = hidden_type.remap_generic_params_to_declaration_params(\n+                opaque_type_key,\n+                self.fcx.infcx.tcx,\n+                true,\n+            );\n+\n             self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n         }\n     }"}, {"sha": "32f359a81581916e050cc41c88cdb1efd561cd86", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -565,6 +565,11 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         /// checked against it (we also carry the span of that first\n         /// type).\n         found: Option<ty::OpaqueHiddenType<'tcx>>,\n+\n+        /// In the presence of dead code, typeck may figure out a hidden type\n+        /// while borrowck will now. We collect these cases here and check at\n+        /// the end that we actually found a type that matches (modulo regions).\n+        typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n     }\n \n     impl ConstraintLocator<'_> {\n@@ -591,18 +596,23 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error() });\n                 return;\n             }\n-            if !tables.concrete_opaque_types.contains_key(&self.def_id) {\n+            let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n                 debug!(\"no constraints in typeck results\");\n                 return;\n+            };\n+            if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n+                self.typeck_types.push(typeck_hidden_ty);\n             }\n+\n             // Use borrowck to get the type with unerased regions.\n             let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n             debug!(?concrete_opaque_types);\n             if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n                 debug!(?concrete_type, \"found constraint\");\n-                if let Some(prev) = self.found {\n-                    if concrete_type.ty != prev.ty && !(concrete_type, prev).references_error() {\n+                if let Some(prev) = &mut self.found {\n+                    if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n                         prev.report_mismatch(&concrete_type, self.tcx);\n+                        prev.ty = self.tcx.ty_error();\n                     }\n                 } else {\n                     self.found = Some(concrete_type);\n@@ -649,7 +659,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id: def_id, tcx, found: None };\n+    let mut locator = ConstraintLocator { def_id: def_id, tcx, found: None, typeck_types: vec![] };\n \n     debug!(?scope);\n \n@@ -679,16 +689,26 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         }\n     }\n \n-    match locator.found {\n-        Some(hidden) => hidden.ty,\n-        None => {\n-            tcx.sess.emit_err(UnconstrainedOpaqueType {\n-                span: tcx.def_span(def_id),\n-                name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n-            });\n-            tcx.ty_error()\n+    let Some(hidden) = locator.found else {\n+        tcx.sess.emit_err(UnconstrainedOpaqueType {\n+            span: tcx.def_span(def_id),\n+            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+        });\n+        return tcx.ty_error();\n+    };\n+\n+    // Only check against typeck if we didn't already error\n+    if !hidden.ty.references_error() {\n+        for concrete_type in locator.typeck_types {\n+            if tcx.erase_regions(concrete_type.ty) != tcx.erase_regions(hidden.ty)\n+                && !(concrete_type, hidden).references_error()\n+            {\n+                hidden.report_mismatch(&concrete_type, tcx);\n+            }\n         }\n     }\n+\n+    hidden.ty\n }\n \n fn find_opaque_ty_constraints_for_rpit(\n@@ -789,20 +809,15 @@ fn find_opaque_ty_constraints_for_rpit(\n             // the `concrete_opaque_types` table.\n             tcx.ty_error()\n         } else {\n-            table\n-                .concrete_opaque_types\n-                .get(&def_id)\n-                .copied()\n-                .unwrap_or_else(|| {\n-                    // We failed to resolve the opaque type or it\n-                    // resolves to itself. We interpret this as the\n-                    // no values of the hidden type ever being constructed,\n-                    // so we can just make the hidden type be `!`.\n-                    // For backwards compatibility reasons, we fall back to\n-                    // `()` until we the diverging default is changed.\n-                    Some(tcx.mk_diverging_default())\n-                })\n-                .expect(\"RPIT always have a hidden type from typeck\")\n+            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+                // We failed to resolve the opaque type or it\n+                // resolves to itself. We interpret this as the\n+                // no values of the hidden type ever being constructed,\n+                // so we can just make the hidden type be `!`.\n+                // For backwards compatibility reasons, we fall back to\n+                // `()` until we the diverging default is changed.\n+                tcx.mk_diverging_default()\n+            })\n         }\n     })\n }"}, {"sha": "8a9160d246640eaa04b5369fed7e32c6a9117768", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -539,12 +539,10 @@ pub struct TypeckResults<'tcx> {\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n \n     /// All the opaque types that have hidden types set\n-    /// by this function. For return-position-impl-trait we also store the\n-    /// type here, so that mir-borrowck can figure out hidden types,\n+    /// by this function. We also store the\n+    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n     /// even if they are only set in dead code (which doesn't show up in MIR).\n-    /// For type-alias-impl-trait, this map is only used to prevent query cycles,\n-    /// so the hidden types are all `None`.\n-    pub concrete_opaque_types: VecMap<LocalDefId, Option<Ty<'tcx>>>,\n+    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "ffade628e53b5f645ce1fb93dc4810f55ef441ef", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -511,3 +511,11 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck::const_not_used_in_type_alias)]\n+pub(super) struct ConstNotUsedTraitAlias {\n+    pub ct: String,\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "0d7d4054bb3cd2dc343d444ae7b39aa23ad9a7e9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -131,6 +131,7 @@ mod generics;\n mod impls_ty;\n mod instance;\n mod list;\n+mod opaque_types;\n mod parameterized;\n mod rvalue_scopes;\n mod structural_impls;\n@@ -1300,6 +1301,34 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n             sub: sub_diag,\n         });\n     }\n+\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n+    pub fn remap_generic_params_to_declaration_params(\n+        self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+        // typeck errors have subpar spans for opaque types, so delay error reporting until borrowck.\n+        ignore_errors: bool,\n+    ) -> Self {\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use substs to build up a reverse map from regions to their\n+        // identity mappings. This is necessary because of `impl\n+        // Trait` lifetimes are computed by replacing existing\n+        // lifetimes with 'static and remapping only those used in the\n+        // `impl Trait` return type, resulting in the parameters\n+        // shifting.\n+        let id_substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        debug!(?id_substs);\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n+        debug!(\"map = {:#?}\", map);\n+\n+        // Convert the type from the function into a type valid outside\n+        // the function, by replacing invalid regions with 'static,\n+        // after producing an error for each of them.\n+        self.fold_with(&mut opaque_types::ReverseMapper::new(tcx, map, self.span, ignore_errors))\n+    }\n }\n \n /// The \"placeholder index\" fully defines a placeholder region, type, or const. Placeholders are"}, {"sha": "b05c6310929b521b35070434325a90078d4d1bf7", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -0,0 +1,218 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::Span;\n+\n+/// Converts generic params of a TypeFoldable from one\n+/// item's generics to another. Usually from a function's generics\n+/// list to the opaque type's own generics.\n+pub(super) struct ReverseMapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+    /// see call sites to fold_kind_no_missing_regions_error\n+    /// for an explanation of this field.\n+    do_not_error: bool,\n+\n+    /// We do not want to emit any errors in typeck because\n+    /// the spans in typeck are subpar at the moment.\n+    /// Borrowck will do the same work again (this time with\n+    /// lifetime information) and thus report better errors.\n+    ignore_errors: bool,\n+\n+    /// Span of function being checked.\n+    span: Span,\n+}\n+\n+impl<'tcx> ReverseMapper<'tcx> {\n+    pub(super) fn new(\n+        tcx: TyCtxt<'tcx>,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n+        span: Span,\n+        ignore_errors: bool,\n+    ) -> Self {\n+        Self { tcx, map, do_not_error: false, ignore_errors, span }\n+    }\n+\n+    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        self.do_not_error = true;\n+        let kind = kind.fold_with(self);\n+        self.do_not_error = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n+        assert!(!self.do_not_error);\n+        kind.fold_with(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaration.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n+\n+            ty::RePlaceholder(_) | ty::ReVar(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n+        }\n+\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.do_not_error => self.tcx.lifetimes.re_static,\n+            None => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        self.span,\n+                        format!(\n+                            \"lifetime `{}` is part of concrete type but not used in \\\n+                                 parameter list of the `impl Trait` type alias\",\n+                            r\n+                        ),\n+                    )\n+                    .emit();\n+\n+                self.tcx().lifetimes.re_static\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match *ty.kind() {\n+            ty::Closure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an opaque type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n+                //\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during codegen.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_no_missing_regions_error(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_closure(def_id, substs)\n+            }\n+\n+            ty::Generator(def_id, substs, movability) => {\n+                let generics = self.tcx.generics_of(def_id);\n+                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+                    if index < generics.parent_count {\n+                        // Accommodate missing regions in the parent kinds...\n+                        self.fold_kind_no_missing_regions_error(kind)\n+                    } else {\n+                        // ...but not elsewhere.\n+                        self.fold_kind_normally(kind)\n+                    }\n+                }));\n+\n+                self.tcx.mk_generator(def_id, substs, movability)\n+            }\n+\n+            ty::Param(param) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list; replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Type(t1)) => t1,\n+                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        debug!(?param, ?self.map);\n+                        if !self.ignore_errors {\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(\n+                                    self.span,\n+                                    &format!(\n+                                        \"type parameter `{}` is part of concrete type but not \\\n+                                          used in parameter list for the `impl Trait` type alias\",\n+                                        ty\n+                                    ),\n+                                )\n+                                .emit();\n+                        }\n+\n+                        self.tcx().ty_error()\n+                    }\n+                }\n+            }\n+\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        trace!(\"checking const {:?}\", ct);\n+        // Find a const parameter\n+        match ct.kind() {\n+            ty::ConstKind::Param(..) => {\n+                // Look it up in the substitution list.\n+                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n+                    // Found it in the substitution list, replace with the parameter from the\n+                    // opaque type.\n+                    Some(GenericArgKind::Const(c1)) => c1,\n+                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n+                    None => {\n+                        if !self.ignore_errors {\n+                            self.tcx.sess.emit_err(ty::ConstNotUsedTraitAlias {\n+                                ct: ct.to_string(),\n+                                span: self.span,\n+                            });\n+                        }\n+\n+                        self.tcx().const_error(ct.ty())\n+                    }\n+                }\n+            }\n+\n+            _ => ct,\n+        }\n+    }\n+}"}, {"sha": "3ff949fbb3f808b5f6d7d20236f68aa09a24892f", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -323,7 +323,7 @@ pub fn change_return_impl_trait() -> impl Clone {\n #[cfg(not(any(cfail1,cfail4)))]\n #[rustc_clean(cfg = \"cfail2\")]\n #[rustc_clean(cfg = \"cfail3\")]\n-#[rustc_clean(cfg = \"cfail5\")]\n+#[rustc_clean(cfg = \"cfail5\", except = \"typeck\")]\n #[rustc_clean(cfg = \"cfail6\")]\n pub fn change_return_impl_trait() -> impl  Copy {\n     0u32"}, {"sha": "6c4aa35679d5bc9f57abb1df07a1ace6a64f70d7", "filename": "src/test/ui/impl-trait/issues/issue-86800.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86800.stderr?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -1,3 +1,11 @@\n+error: unconstrained opaque type\n+  --> $DIR/issue-86800.rs:33:34\n+   |\n+LL | type TransactionFuture<'__, O> = impl '__ + Future<Output = TransactionResult<O>>;\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = \n+\n \n stack backtrace:\n \n@@ -12,8 +20,7 @@ error: internal compiler error: unexpected panic\n \n \n query stack during panic:\n-#0 [mir_borrowck] borrow-checking `execute_transaction_fut`\n-#1 [type_of] computing type of `TransactionFuture::{opaque#0}`\n-#2 [check_mod_item_types] checking item types in top-level module\n-#3 [analysis] running analysis passes on this crate\n+#0 [type_of] computing type of `TransactionFuture::{opaque#0}`\n+#1 [check_mod_item_types] checking item types in top-level module\n+#2 [analysis] running analysis passes on this crate\n end of query stack"}, {"sha": "0b8157fe33dd74281d5086f8b836c3ca738eee5a", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -1,5 +1,5 @@\n #![feature(type_alias_impl_trait)]\n-// check-pass\n+\n fn main() {}\n \n // two definitions with different types\n@@ -9,7 +9,7 @@ fn foo() -> Foo {\n     \"\"\n }\n \n-fn bar() -> Foo {\n+fn bar() -> Foo { //~ ERROR: concrete type differs from previous defining opaque type use\n     panic!()\n }\n "}, {"sha": "09dadb0afcef5d4461222cceaec8f356e391ac7f", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -0,0 +1,14 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type.rs:12:13\n+   |\n+LL | fn bar() -> Foo {\n+   |             ^^^ expected `&'static str`, got `()`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type.rs:9:5\n+   |\n+LL |     \"\"\n+   |     ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "bc827a8f2113a2cc0c3ee35bf86c714d87e0020b", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type3.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.rs?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -0,0 +1,12 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait = impl Sized;\n+\n+struct One;\n+fn one() -> Tait { One }\n+\n+struct Two<T>(T);\n+fn two() -> Tait { Two::<()>(todo!()) }\n+//~^ ERROR concrete type differs from previous defining opaque type use\n+\n+fn main() {}"}, {"sha": "146a57cbb7e056c6e7a7ea246ae289f51f696bb4", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60bd3f96779dbe6bd206dae09395e9af7d580552/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type3.stderr?ref=60bd3f96779dbe6bd206dae09395e9af7d580552", "patch": "@@ -0,0 +1,14 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type3.rs:9:13\n+   |\n+LL | fn two() -> Tait { Two::<()>(todo!()) }\n+   |             ^^^^ expected `One`, got `Two<()>`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type3.rs:6:20\n+   |\n+LL | fn one() -> Tait { One }\n+   |                    ^^^\n+\n+error: aborting due to previous error\n+"}]}