{"sha": "c67fc2e4c5cf062725458108042dd89d618bd8de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2N2ZjMmU0YzVjZjA2MjcyNTQ1ODEwODA0MmRkODlkNjE4YmQ4ZGU=", "commit": {"author": {"name": "miguel raz", "email": "miguelraz@gmail.com", "date": "2021-01-25T23:58:29Z"}, "committer": {"name": "miguel raz", "email": "miguelraz@gmail.com", "date": "2021-02-03T00:59:22Z"}, "message": "Add guards/tests for div,rem overflow cases", "tree": {"sha": "6be10309a4885b75245b6143db780cffc366a1e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6be10309a4885b75245b6143db780cffc366a1e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c67fc2e4c5cf062725458108042dd89d618bd8de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c67fc2e4c5cf062725458108042dd89d618bd8de", "html_url": "https://github.com/rust-lang/rust/commit/c67fc2e4c5cf062725458108042dd89d618bd8de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c67fc2e4c5cf062725458108042dd89d618bd8de/comments", "author": {"login": "miguelraz", "id": 13056181, "node_id": "MDQ6VXNlcjEzMDU2MTgx", "avatar_url": "https://avatars.githubusercontent.com/u/13056181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelraz", "html_url": "https://github.com/miguelraz", "followers_url": "https://api.github.com/users/miguelraz/followers", "following_url": "https://api.github.com/users/miguelraz/following{/other_user}", "gists_url": "https://api.github.com/users/miguelraz/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelraz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelraz/subscriptions", "organizations_url": "https://api.github.com/users/miguelraz/orgs", "repos_url": "https://api.github.com/users/miguelraz/repos", "events_url": "https://api.github.com/users/miguelraz/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelraz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "miguelraz", "id": 13056181, "node_id": "MDQ6VXNlcjEzMDU2MTgx", "avatar_url": "https://avatars.githubusercontent.com/u/13056181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelraz", "html_url": "https://github.com/miguelraz", "followers_url": "https://api.github.com/users/miguelraz/followers", "following_url": "https://api.github.com/users/miguelraz/following{/other_user}", "gists_url": "https://api.github.com/users/miguelraz/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelraz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelraz/subscriptions", "organizations_url": "https://api.github.com/users/miguelraz/orgs", "repos_url": "https://api.github.com/users/miguelraz/repos", "events_url": "https://api.github.com/users/miguelraz/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelraz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b931c15c0b9fad90b8020ea5a5ad54eef7519edf", "html_url": "https://github.com/rust-lang/rust/commit/b931c15c0b9fad90b8020ea5a5ad54eef7519edf"}], "stats": {"total": 86, "additions": 84, "deletions": 2}, "files": [{"sha": "51e97757c54e58818e1e60bac1d9c16fa04718be", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c67fc2e4c5cf062725458108042dd89d618bd8de/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67fc2e4c5cf062725458108042dd89d618bd8de/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=c67fc2e4c5cf062725458108042dd89d618bd8de", "patch": "@@ -283,13 +283,20 @@ macro_rules! impl_unsigned_int_ops {\n \n                         #[inline]\n                         fn div(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if AsRef::<[$scalar]>::as_ref(&rhs)\n+                            if rhs.as_slice()\n                                 .iter()\n                                 .any(|x| *x == 0)\n                             {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n+\n+                            // Guards for div(MIN, -1),\n+                            // this check only applies to signed ints\n+                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n+                                    .zip(rhs.as_slice().iter())\n+                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                                panic!(\"attempt to divide with overflow\");\n+                            }\n                             unsafe { crate::intrinsics::simd_div(self, rhs) }\n                         }\n                     }\n@@ -304,6 +311,11 @@ macro_rules! impl_unsigned_int_ops {\n                             if rhs == 0 {\n                                 panic!(\"attempt to divide by zero\");\n                             }\n+                            if <$scalar>::MIN != 0 &&\n+                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                rhs == -1 as _ {\n+                                    panic!(\"attempt to divide with overflow\");\n+                            }\n                             let rhs = Self::splat(rhs);\n                             unsafe { crate::intrinsics::simd_div(self, rhs) }\n                         }\n@@ -353,6 +365,14 @@ macro_rules! impl_unsigned_int_ops {\n                             {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n+\n+                            // Guards for rem(MIN, -1)\n+                            // this branch applies the check only to signed ints\n+                            if <$scalar>::MIN != 0 && self.as_slice().iter()\n+                                    .zip(rhs.as_slice().iter())\n+                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                                panic!(\"attempt to calculate the remainder with overflow\");\n+                            }\n                             unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                         }\n                     }\n@@ -367,6 +387,11 @@ macro_rules! impl_unsigned_int_ops {\n                             if rhs == 0 {\n                                 panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                             }\n+                            if <$scalar>::MIN != 0 &&\n+                                self.as_slice().iter().any(|x| *x == <$scalar>::MIN) &&\n+                                rhs == -1 as _ {\n+                                    panic!(\"attempt to calculate the remainder with overflow\");\n+                            }\n                             let rhs = Self::splat(rhs);\n                             unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                         }"}, {"sha": "43c75c6a9c4940af174c1457014456313c63903f", "filename": "crates/core_simd/tests/ops_impl/int_macros.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c67fc2e4c5cf062725458108042dd89d618bd8de/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c67fc2e4c5cf062725458108042dd89d618bd8de/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fint_macros.rs?ref=c67fc2e4c5cf062725458108042dd89d618bd8de", "patch": "@@ -228,6 +228,39 @@ macro_rules! int_tests {\n                 assert_biteq!(a, expected);\n             }\n \n+            #[test]\n+            #[should_panic]\n+            fn div_min_panics() {\n+                let a = from_slice(&vec![$scalar::MIN; 64]);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn div_by_all_zeros_panics() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![0 ; 64]);\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn div_by_one_zero_panics() {\n+                let a = from_slice(&A);\n+                let mut b = from_slice(&B);\n+                b[0] = 0 as _;\n+                let _ = a / b;\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn div_min_neg_one_no_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a / b;\n+            }\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn rem() {\n@@ -275,6 +308,30 @@ macro_rules! int_tests {\n                 assert_biteq!(a, expected);\n             }\n \n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn rem_min_neg_one_no_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![-1; 64]);\n+                let _ = a % b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn rem_min_panic() {\n+                let a = from_slice(&vec![$scalar::MIN; 64]);\n+                let b = from_slice(&vec![-1 ; 64]);\n+                let _ = a % b;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn rem_min_zero_panic() {\n+                let a = from_slice(&A);\n+                let b = from_slice(&vec![0 ; 64]);\n+                let _ = a % b;\n+            }\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn bitand() {"}]}