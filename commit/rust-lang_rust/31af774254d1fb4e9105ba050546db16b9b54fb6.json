{"sha": "31af774254d1fb4e9105ba050546db16b9b54fb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYWY3NzQyNTRkMWZiNGU5MTA1YmEwNTA1NDZkYjE2YjliNTRmYjY=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-21T14:34:06Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-21T14:39:51Z"}, "message": "Refactor how builtins are resolved\n\nThis fixes autocompletion suggesting e.g. self::usize.", "tree": {"sha": "587c84243cf6f4db8fa9d403f50178afab7ffe4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/587c84243cf6f4db8fa9d403f50178afab7ffe4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31af774254d1fb4e9105ba050546db16b9b54fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31af774254d1fb4e9105ba050546db16b9b54fb6", "html_url": "https://github.com/rust-lang/rust/commit/31af774254d1fb4e9105ba050546db16b9b54fb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31af774254d1fb4e9105ba050546db16b9b54fb6/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3037c2631ecb55996b676ce2c18b9df1858abaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3037c2631ecb55996b676ce2c18b9df1858abaa", "html_url": "https://github.com/rust-lang/rust/commit/e3037c2631ecb55996b676ce2c18b9df1858abaa"}], "stats": {"total": 123, "additions": 55, "deletions": 68}, "files": [{"sha": "5e943b780ad8fdc59ac209ebef5598cf85103612", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=31af774254d1fb4e9105ba050546db16b9b54fb6", "patch": "@@ -30,7 +30,7 @@ pub struct ItemScope {\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n }\n \n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n+pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n         .map(|(name, ty)| (name.clone(), PerNs::types(ty.clone().into(), Visibility::Public)))\n@@ -40,9 +40,9 @@ static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n /// Shadow mode for builtin type which can be shadowed by module.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub(crate) enum BuiltinShadowMode {\n-    // Prefer Module\n+    /// Prefer user-defined modules (or other types) over builtins.\n     Module,\n-    // Prefer Other Types\n+    /// Prefer builtins over user-defined modules (but not other types).\n     Other,\n }\n \n@@ -51,7 +51,7 @@ pub(crate) enum BuiltinShadowMode {\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n         //FIXME: shadowing\n-        self.visible.iter().chain(BUILTIN_SCOPE.iter()).map(|(n, def)| (n, *def))\n+        self.visible.iter().map(|(n, def)| (n, *def))\n     }\n \n     pub fn entries_without_primitives<'a>(\n@@ -79,29 +79,8 @@ impl ItemScope {\n     }\n \n     /// Get a name from current module scope, legacy macros are not included\n-    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> PerNs {\n-        match shadow {\n-            BuiltinShadowMode::Module => self\n-                .visible\n-                .get(name)\n-                .or_else(|| BUILTIN_SCOPE.get(name))\n-                .copied()\n-                .unwrap_or_else(PerNs::none),\n-            BuiltinShadowMode::Other => {\n-                let item = self.visible.get(name).copied();\n-                if let Some(def) = item {\n-                    if let Some(ModuleDefId::ModuleId(_)) = def.take_types() {\n-                        return BUILTIN_SCOPE\n-                            .get(name)\n-                            .copied()\n-                            .or(item)\n-                            .unwrap_or_else(PerNs::none);\n-                    }\n-                }\n-\n-                item.or_else(|| BUILTIN_SCOPE.get(name).copied()).unwrap_or_else(PerNs::none)\n-            }\n-        }\n+    pub(crate) fn get(&self, name: &Name) -> PerNs {\n+        self.visible.get(name).copied().unwrap_or_else(PerNs::none)\n     }\n \n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {"}, {"sha": "c058e70aa3a80d30f164c91fc493f87e39f3a281", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=31af774254d1fb4e9105ba050546db16b9b54fb6", "patch": "@@ -18,6 +18,7 @@ use test_utils::tested_by;\n \n use crate::{\n     db::DefDatabase,\n+    item_scope::BUILTIN_SCOPE,\n     nameres::{BuiltinShadowMode, CrateDefMap},\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n@@ -103,15 +104,6 @@ impl CrateDefMap {\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n-        // if it is not the last segment, we prefer the module to the builtin\n-        let prefer_module = |index| {\n-            if index == path.segments.len() - 1 {\n-                shadow\n-            } else {\n-                BuiltinShadowMode::Module\n-            }\n-        };\n-\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n             PathKind::DollarCrate(krate) => {\n@@ -140,20 +132,29 @@ impl CrateDefMap {\n                 if self.edition == Edition::Edition2015\n                     && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n             {\n-                let (idx, segment) = match segments.next() {\n+                let (_, segment) = match segments.next() {\n                     Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment, prefer_module(idx))\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment)\n             }\n             PathKind::Plain => {\n-                let (idx, segment) = match segments.next() {\n+                let (_, segment) = match segments.next() {\n                     Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n+                // The first segment may be a builtin type. If the path has more\n+                // than one segment, we first try resolving it as a module\n+                // anyway.\n+                // FIXME: If the next segment doesn't resolve in the module and\n+                // BuiltinShadowMode wasn't Module, then we need to try\n+                // resolving it as a builtin.\n+                let prefer_module =\n+                    if path.segments.len() == 1 { shadow } else { BuiltinShadowMode::Module };\n+\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment, prefer_module(idx))\n+                self.resolve_name_in_module(db, original_module, &segment, prefer_module)\n             }\n             PathKind::Super(lvl) => {\n                 let m = successors(Some(original_module), |m| self.modules[*m].parent)\n@@ -216,7 +217,7 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    self[module.local_id].scope.get(&segment, prefer_module(i))\n+                    self[module.local_id].scope.get(&segment)\n                 }\n                 ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n                     // enum variant\n@@ -275,33 +276,35 @@ impl CrateDefMap {\n             .scope\n             .get_legacy_macro(name)\n             .map_or_else(PerNs::none, |m| PerNs::macros(m, Visibility::Public));\n-        let from_scope = self[module].scope.get(name, shadow);\n+        let from_scope = self[module].scope.get(name);\n+        let from_builtin = BUILTIN_SCOPE.get(name).copied().unwrap_or_else(PerNs::none);\n+        let from_scope_or_builtin = match shadow {\n+            BuiltinShadowMode::Module => from_scope.or(from_builtin),\n+            BuiltinShadowMode::Other => {\n+                if let Some(ModuleDefId::ModuleId(_)) = from_scope.take_types() {\n+                    from_builtin.or(from_scope)\n+                } else {\n+                    from_scope.or(from_builtin)\n+                }\n+            }\n+        };\n         let from_extern_prelude = self\n             .extern_prelude\n             .get(name)\n             .map_or(PerNs::none(), |&it| PerNs::types(it, Visibility::Public));\n-        let from_prelude = self.resolve_in_prelude(db, name, shadow);\n+        let from_prelude = self.resolve_in_prelude(db, name);\n \n-        from_legacy_macro.or(from_scope).or(from_extern_prelude).or(from_prelude)\n+        from_legacy_macro.or(from_scope_or_builtin).or(from_extern_prelude).or(from_prelude)\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(\n-        &self,\n-        name: &Name,\n-        shadow: BuiltinShadowMode,\n-    ) -> PerNs {\n-        let from_crate_root = self[self.root].scope.get(name, shadow);\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs {\n+        let from_crate_root = self[self.root].scope.get(name);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    fn resolve_in_prelude(\n-        &self,\n-        db: &impl DefDatabase,\n-        name: &Name,\n-        shadow: BuiltinShadowMode,\n-    ) -> PerNs {\n+    fn resolve_in_prelude(&self, db: &impl DefDatabase, name: &Name) -> PerNs {\n         if let Some(prelude) = self.prelude {\n             let keep;\n             let def_map = if prelude.krate == self.krate {\n@@ -311,7 +314,7 @@ impl CrateDefMap {\n                 keep = db.crate_def_map(prelude.krate);\n                 &keep\n             };\n-            def_map[prelude.local_id].scope.get(name, shadow)\n+            def_map[prelude.local_id].scope.get(name)\n         } else {\n             PerNs::none()\n         }"}, {"sha": "9dd4fa555c1d4d7b81f22b35ad1e916812774a40", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=31af774254d1fb4e9105ba050546db16b9b54fb6", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    item_scope::BuiltinShadowMode,\n+    item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n@@ -193,7 +193,7 @@ impl Resolver {\n                     return Some((res, idx));\n                 }\n                 Scope::LocalItemsScope(body) => {\n-                    let def = body.item_scope.get(first_name, BuiltinShadowMode::Other);\n+                    let def = body.item_scope.get(first_name);\n                     if let Some(res) = to_type_ns(def) {\n                         return Some((res, None));\n                     }\n@@ -335,8 +335,10 @@ impl Resolver {\n                     };\n                 }\n                 Scope::LocalItemsScope(body) => {\n-                    let def = body.item_scope.get(first_name, BuiltinShadowMode::Other);\n-                    if let Some(res) = to_value_ns(def) {\n+                    // we don't bother looking in the builtin scope here because there are no builtin values\n+                    let def = to_value_ns(body.item_scope.get(first_name));\n+\n+                    if let Some(res) = def {\n                         return Some(ResolveValueResult::ValueNs(res));\n                     }\n                 }\n@@ -476,6 +478,9 @@ impl Scope {\n                 m.crate_def_map.extern_prelude.iter().for_each(|(name, &def)| {\n                     f(name.clone(), ScopeDef::PerNs(PerNs::types(def, Visibility::Public)));\n                 });\n+                BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n+                    f(name.clone(), ScopeDef::PerNs(def));\n+                });\n                 if let Some(prelude) = m.crate_def_map.prelude {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n                     prelude_def_map[prelude.local_id].scope.entries().for_each(|(name, def)| {"}, {"sha": "2d7f09a6c02be2923e3c1ed51daefe58c02dc320", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=31af774254d1fb4e9105ba050546db16b9b54fb6", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! Completion of paths, including when writing a single name.\n \n use hir::{Adt, PathResolution, ScopeDef};\n use ra_syntax::AstNode;\n@@ -20,10 +20,6 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n             let module_scope = module.scope(ctx.db);\n             for (name, def) in module_scope {\n                 if ctx.use_item_syntax.is_some() {\n-                    if let hir::ScopeDef::ModuleDef(hir::ModuleDef::BuiltinType(..)) = def {\n-                        tested_by!(dont_complete_primitive_in_use);\n-                        continue;\n-                    }\n                     if let ScopeDef::Unknown = def {\n                         if let Some(name_ref) = ctx.name_ref_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_string().as_str() {\n@@ -125,11 +121,16 @@ mod tests {\n \n     #[test]\n     fn dont_complete_primitive_in_use() {\n-        covers!(dont_complete_primitive_in_use);\n         let completions = do_completion(r\"use self::<|>;\", CompletionKind::BuiltinType);\n         assert!(completions.is_empty());\n     }\n \n+    #[test]\n+    fn dont_complete_primitive_in_module_scope() {\n+        let completions = do_completion(r\"fn foo() { self::<|> }\", CompletionKind::BuiltinType);\n+        assert!(completions.is_empty());\n+    }\n+\n     #[test]\n     fn completes_primitives() {\n         let completions ="}, {"sha": "bcb67e3737c9bb68e5f0267af7f993ce4dbb3fd5", "filename": "crates/ra_ide/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31af774254d1fb4e9105ba050546db16b9b54fb6/crates%2Fra_ide%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmarks.rs?ref=31af774254d1fb4e9105ba050546db16b9b54fb6", "patch": "@@ -10,6 +10,5 @@ test_utils::marks!(\n     goto_def_for_field_init_shorthand\n     call_info_bad_offset\n     dont_complete_current_use\n-    dont_complete_primitive_in_use\n     test_resolve_parent_module_on_module_decl\n );"}]}