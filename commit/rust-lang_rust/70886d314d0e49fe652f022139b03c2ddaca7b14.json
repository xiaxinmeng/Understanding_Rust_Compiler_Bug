{"sha": "70886d314d0e49fe652f022139b03c2ddaca7b14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwODg2ZDMxNGQwZTQ5ZmU2NTJmMDIyMTM5YjAzYzJkZGFjYTdiMTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-01T01:29:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-07T20:05:41Z"}, "message": "libstd: Implement a thread pool. r=brson", "tree": {"sha": "e216a7dc258c1b2ef9569c4cafa17469362d7288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e216a7dc258c1b2ef9569c4cafa17469362d7288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70886d314d0e49fe652f022139b03c2ddaca7b14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70886d314d0e49fe652f022139b03c2ddaca7b14", "html_url": "https://github.com/rust-lang/rust/commit/70886d314d0e49fe652f022139b03c2ddaca7b14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70886d314d0e49fe652f022139b03c2ddaca7b14/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c88c969b3e20e5aa2c36aee2e5154afd9a383517", "url": "https://api.github.com/repos/rust-lang/rust/commits/c88c969b3e20e5aa2c36aee2e5154afd9a383517", "html_url": "https://github.com/rust-lang/rust/commit/c88c969b3e20e5aa2c36aee2e5154afd9a383517"}], "stats": {"total": 86, "additions": 86, "deletions": 0}, "files": [{"sha": "85c0ffa3e24604bd395e91ff59bb2da013941dc8", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70886d314d0e49fe652f022139b03c2ddaca7b14/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/70886d314d0e49fe652f022139b03c2ddaca7b14/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=70886d314d0e49fe652f022139b03c2ddaca7b14", "patch": "@@ -54,6 +54,7 @@ pub mod sync;\n pub mod arc;\n pub mod comm;\n pub mod future;\n+pub mod thread_pool;\n \n // Collections\n "}, {"sha": "4bded2093d0fccb520f875706f2c60ca6c0c6ff6", "filename": "src/libstd/thread_pool.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/70886d314d0e49fe652f022139b03c2ddaca7b14/src%2Flibstd%2Fthread_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70886d314d0e49fe652f022139b03c2ddaca7b14/src%2Flibstd%2Fthread_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_pool.rs?ref=70886d314d0e49fe652f022139b03c2ddaca7b14", "patch": "@@ -0,0 +1,85 @@\n+/// A thread pool abstraction. Useful for achieving predictable CPU\n+/// parallelism.\n+\n+use pipes::{Chan, Port};\n+use task::{SchedMode, SingleThreaded};\n+\n+enum Msg<T> {\n+    Execute(~fn(&T)),\n+    Quit\n+}\n+\n+pub struct ThreadPool<T> {\n+    channels: ~[Chan<Msg<T>>],\n+    mut next_index: uint,\n+\n+    drop {\n+        for self.channels.each |channel| {\n+            channel.send(Quit);\n+        }\n+    }\n+}\n+\n+pub impl<T> ThreadPool<T> {\n+    /// Spawns a new thread pool with `n_tasks` tasks. If the `sched_mode`\n+    /// is None, the tasks run on this scheduler; otherwise, they run on a\n+    /// new scheduler with the given mode. The provided `init_fn_factory`\n+    /// returns a function which, given the index of the task, should return\n+    /// local data to be kept around in that task.\n+    static fn new(n_tasks: uint,\n+                  opt_sched_mode: Option<SchedMode>,\n+                  init_fn_factory: ~fn() -> ~fn(uint) -> T) -> ThreadPool<T> {\n+        assert n_tasks >= 1;\n+\n+        let channels = do vec::from_fn(n_tasks) |i| {\n+            let (chan, port) = pipes::stream::<Msg<T>>();\n+            let init_fn = init_fn_factory();\n+\n+            let task_body: ~fn() = |move port, move init_fn| {\n+                let local_data = init_fn(i);\n+                loop {\n+                    match port.recv() {\n+                        Execute(move f) => f(&local_data),\n+                        Quit => break\n+                    }\n+                }\n+            };\n+\n+            // Start the task.\n+            match opt_sched_mode {\n+                None => {\n+                    // Run on this scheduler.\n+                    task::spawn(move task_body);\n+                }\n+                Some(sched_mode) => {\n+                    task::task().sched_mode(sched_mode).spawn(move task_body);\n+                }\n+            }\n+\n+            move chan\n+        };\n+\n+        return ThreadPool { channels: move channels, next_index: 0 };\n+    }\n+\n+    /// Executes the function `f` on a thread in the pool. The function\n+    /// receives a reference to the local data returned by the `init_fn`.\n+    fn execute(&self, f: ~fn(&T)) {\n+        self.channels[self.next_index].send(Execute(move f));\n+        self.next_index += 1;\n+        if self.next_index == self.channels.len() { self.next_index = 0; }\n+    }\n+}\n+\n+#[test]\n+fn test_thread_pool() {\n+    let f: ~fn() -> ~fn(uint) -> uint = || {\n+        let g: ~fn(uint) -> uint = |i| i;\n+        move g\n+    };\n+    let pool = ThreadPool::new(4, Some(SingleThreaded), move f);\n+    for 8.times {\n+        pool.execute(|i| io::println(fmt!(\"Hello from thread %u!\", *i)));\n+    }\n+}\n+"}]}