{"sha": "081caf5bb8e22102ba517c7484dafcf65705c681", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MWNhZjViYjhlMjIxMDJiYTUxN2M3NDg0ZGFmY2Y2NTcwNWM2ODE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T10:38:58Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T12:05:56Z"}, "message": "Do not check for self-assign unless dest is initialized\n\nAlso, give copy_val and move_val a more sane return type.", "tree": {"sha": "9fbdba0b076df6e422573f8724ad696526f6f420", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fbdba0b076df6e422573f8724ad696526f6f420"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081caf5bb8e22102ba517c7484dafcf65705c681", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081caf5bb8e22102ba517c7484dafcf65705c681", "html_url": "https://github.com/rust-lang/rust/commit/081caf5bb8e22102ba517c7484dafcf65705c681", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081caf5bb8e22102ba517c7484dafcf65705c681/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c930af74d5ad02cee4a540b0d0a91b12b3d6e58c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c930af74d5ad02cee4a540b0d0a91b12b3d6e58c", "html_url": "https://github.com/rust-lang/rust/commit/c930af74d5ad02cee4a540b0d0a91b12b3d6e58c"}], "stats": {"total": 185, "additions": 92, "deletions": 93}, "files": [{"sha": "6707480f9c5856e3c63838d5ead351e81935bfd3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/081caf5bb8e22102ba517c7484dafcf65705c681/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081caf5bb8e22102ba517c7484dafcf65705c681/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=081caf5bb8e22102ba517c7484dafcf65705c681", "patch": "@@ -2086,7 +2086,6 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   copy_helper(make_copy_glue),\n                                   ti.ty_params, \"copy\");\n-                \n               }\n             }\n         }\n@@ -2319,8 +2318,34 @@ fn duplicate_heap_parts_if_necessary(cx: &@block_ctxt, vptr: ValueRef,\n \n tag copy_action { INIT; DROP_EXISTING; }\n \n+// These are the types that are passed by pointer.\n+fn type_is_structural_or_param(tcx: &ty::ctxt, t: ty::t) -> bool {\n+    if ty::type_is_structural(tcx, t) { ret true; }\n+    alt ty::struct(tcx, t) {\n+      ty::ty_param(_, _) { ret true; }\n+      _ { ret false; }\n+    }\n+}\n+\n fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n-            src: ValueRef, t: &ty::t) -> result {\n+            src: ValueRef, t: &ty::t) -> @block_ctxt {\n+    if type_is_structural_or_param(bcx_ccx(cx).tcx, t) &&\n+       action == DROP_EXISTING {\n+        let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n+        let next_cx = new_sub_block_ctxt(cx, \"next\");\n+        let self_assigning =\n+            cx.build.ICmp(lib::llvm::LLVMIntNE,\n+                          cx.build.PointerCast(dst, val_ty(src)), src);\n+        cx.build.CondBr(self_assigning, do_copy_cx.llbb, next_cx.llbb);\n+        do_copy_cx = copy_val_no_check(do_copy_cx, action, dst, src, t);\n+        do_copy_cx.build.Br(next_cx.llbb);\n+        ret next_cx;\n+    }\n+    ret copy_val_no_check(cx, action, dst, src, t);\n+}\n+\n+fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n+                     src: ValueRef, t: &ty::t) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     // FIXME this is just a clunky stopgap. we should do proper checking in an\n     // earlier pass.\n@@ -2329,36 +2354,26 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     }\n \n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n-        ret rslt(cx, cx.build.Store(src, dst));\n+        cx.build.Store(src, dst);\n+        ret cx;\n     } else if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) {\n-        ret rslt(cx, C_nil());\n+        ret cx;\n     } else if ty::type_is_boxed(ccx.tcx, t) {\n-        let bcx;\n-        if action == DROP_EXISTING {\n-            bcx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n-        } else { bcx = cx; }\n+        let bcx = if action == DROP_EXISTING {\n+            drop_ty(cx, cx.build.Load(dst), t).bcx\n+        } else { cx };\n         bcx = take_ty(bcx, src, t).bcx;\n-        ret rslt(bcx, bcx.build.Store(src, dst));\n-    } else if ty::type_is_structural(ccx.tcx, t) ||\n-                  ty::type_has_dynamic_size(ccx.tcx, t) {\n-        // Check for self-assignment.\n-        let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n-        let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let self_assigning =\n-            cx.build.ICmp(lib::llvm::LLVMIntNE,\n-                          cx.build.PointerCast(dst, val_ty(src)), src);\n-        cx.build.CondBr(self_assigning, do_copy_cx.llbb, next_cx.llbb);\n-\n-        if action == DROP_EXISTING {\n-            do_copy_cx = drop_ty(do_copy_cx, dst, t).bcx;\n-        }\n-        do_copy_cx = memmove_ty(do_copy_cx, dst, src, t).bcx;\n-        do_copy_cx = take_ty(do_copy_cx, dst, t).bcx;\n-        do_copy_cx.build.Br(next_cx.llbb);\n-\n-        ret rslt(next_cx, C_nil());\n-    }\n-    ccx.sess.bug(\"unexpected type in trans::copy_val: \" +\n+        bcx.build.Store(src, dst);\n+        ret bcx;\n+    } else if type_is_structural_or_param(ccx.tcx, t) {\n+        let bcx = if action == DROP_EXISTING {\n+            drop_ty(cx, dst, t).bcx\n+        } else { cx };\n+        bcx = memmove_ty(bcx, dst, src, t).bcx;\n+        bcx = take_ty(bcx, dst, t).bcx;\n+        ret bcx;\n+    }\n+    ccx.sess.bug(\"unexpected type in trans::copy_val_no_check: \" +\n                      ty_to_str(ccx.tcx, t));\n }\n \n@@ -2368,47 +2383,46 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n // FIXME: We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n // doesn't need to be dropped.\n-// FIXME: This can return only a block_ctxt, not a result.\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-            src: &lval_result, t: &ty::t) -> result {\n+            src: &lval_result, t: &ty::t) -> @block_ctxt {\n     let src_val = src.res.val;\n     if ty::type_is_scalar(bcx_tcx(cx), t) ||\n            ty::type_is_native(bcx_tcx(cx), t) {\n         if src.is_mem { src_val = cx.build.Load(src_val); }\n         cx.build.Store(src_val, dst);\n-        ret rslt(cx, C_nil());\n+        ret cx;\n     } else if ty::type_is_nil(bcx_tcx(cx), t) ||\n                   ty::type_is_bot(bcx_tcx(cx), t) {\n-        ret rslt(cx, C_nil());\n+        ret cx;\n     } else if ty::type_is_unique(bcx_tcx(cx), t) ||\n                   ty::type_is_boxed(bcx_tcx(cx), t) {\n         if src.is_mem { src_val = cx.build.Load(src_val); }\n         if action == DROP_EXISTING {\n             cx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n         }\n         cx.build.Store(src_val, dst);\n-        if src.is_mem { ret zero_alloca(cx, src.res.val, t); }\n+        if src.is_mem { ret zero_alloca(cx, src.res.val, t).bcx; }\n \n         // If we're here, it must be a temporary.\n         revoke_clean(cx, src_val);\n-        ret rslt(cx, C_nil());\n+        ret cx;\n     } else if ty::type_is_structural(bcx_tcx(cx), t) ||\n                   ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t).bcx; }\n         cx = memmove_ty(cx, dst, src_val, t).bcx;\n         if src.is_mem {\n-            ret zero_alloca(cx, src_val, t);\n+            ret zero_alloca(cx, src_val, t).bcx;\n         } else { // Temporary value\n             revoke_clean(cx, src_val);\n-            ret rslt(cx, C_nil());\n+            ret cx;\n         }\n     }\n     bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n                              ty_to_str(bcx_tcx(cx), t));\n }\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-                    src: &lval_result, t: &ty::t) -> result {\n+                    src: &lval_result, t: &ty::t) -> @block_ctxt {\n \n     // Lvals in memory are not temporaries. Copy them.\n     if src.is_mem {\n@@ -2560,8 +2574,8 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n             let llety = T_ptr(type_of(bcx_ccx(sub.bcx), e.span, e_ty));\n             body = sub.bcx.build.PointerCast(body, llety);\n         }\n-        let res = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n-        ret rslt(res.bcx, sub.box);\n+        let bcx = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n+        ret rslt(bcx, sub.box);\n       }\n       ast::deref. {\n         bcx_ccx(cx).sess.bug(\"deref expressions should have been \\\n@@ -2901,10 +2915,8 @@ mod ivec {\n         let copy_src =\n             load_if_immediate(copy_loop_body_cx, copy_src_ptr, unit_ty);\n \n-        rs =\n-            copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src,\n-                     unit_ty);\n-        let post_copy_cx = rs.bcx;\n+        let post_copy_cx = copy_val\n+            (copy_loop_body_cx, INIT, copy_dest_ptr, copy_src, unit_ty);\n         // Increment both pointers.\n         if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n             // We have to increment by the dynamically-computed size.\n@@ -3104,10 +3116,8 @@ mod ivec {\n                                  rhs_copy_cx.llbb);\n         let dest_ptr_lhs_copy = lhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         let lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n-        rs =\n-            copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy, lhs_val,\n-                     unit_ty);\n-        lhs_do_copy_cx = rs.bcx;\n+        lhs_do_copy_cx = copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy,\n+                                  lhs_val, unit_ty);\n \n         // Increment both pointers.\n         if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n@@ -3133,10 +3143,8 @@ mod ivec {\n                                  next_cx.llbb);\n         let dest_ptr_rhs_copy = rhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         let rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n-        rs =\n-            copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy, rhs_val,\n-                     unit_ty);\n-        rhs_do_copy_cx = rs.bcx;\n+        rhs_do_copy_cx = copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy,\n+                                  rhs_val, unit_ty);\n \n         // Increment both pointers.\n         if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n@@ -3227,8 +3235,8 @@ fn trans_evec_add(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef, rhs: ValueRef)\n    -> result {\n     let r = alloc_ty(cx, t);\n     let tmp = r.val;\n-    r = copy_val(r.bcx, INIT, tmp, lhs, t);\n-    let bcx = trans_evec_append(r.bcx, t, tmp, rhs).bcx;\n+    let bcx = copy_val(r.bcx, INIT, tmp, lhs, t);\n+    let bcx = trans_evec_append(bcx, t, tmp, rhs).bcx;\n     tmp = load_if_immediate(bcx, tmp, t);\n     add_clean_temp(cx, tmp, t);\n     ret rslt(bcx, tmp);\n@@ -3486,10 +3494,10 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n                                       outer_next_cx, \"for loop scope\");\n         cx.build.Br(scope_cx.llbb);\n         let local_res = alloc_local(scope_cx, local);\n-        let loc_r = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n+        let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n         add_clean(scope_cx, local_res.val, t);\n         let bcx =\n-            trans_alt::bind_irrefutable_pat(loc_r.bcx, local.node.pat,\n+            trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n                                             local_res.val, cx.fcx.lllocals,\n                                             false);\n         bcx = trans_block(bcx, body, return).bcx;\n@@ -3587,8 +3595,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n             GEP_tup_like(bcx, bindings_ty, bindings.val, [0, i as int]);\n         bcx = bound.bcx;\n         if copying {\n-            bcx =\n-                move_val_if_temp(bcx, INIT, bound.val, lv, bound_tys[i]).bcx;\n+            bcx = move_val_if_temp(bcx, INIT, bound.val, lv, bound_tys[i]);\n         } else { bcx.build.Store(lv.res.val, bound.val); }\n         i += 1u;\n     }\n@@ -4548,7 +4555,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             // Do nothing for temporaries, just give them to callee\n         } else if ty::type_is_structural(ccx.tcx, e_ty) {\n             let dst = alloc_ty(bcx, e_ty);\n-            bcx = copy_val(dst.bcx, INIT, dst.val, val, e_ty).bcx;\n+            bcx = copy_val(dst.bcx, INIT, dst.val, val, e_ty);\n             val = dst.val;\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n@@ -4797,7 +4804,7 @@ fn trans_tup(cx: &@block_ctxt, elts: &[@ast::expr], id: ast::node_id) ->\n         let src = trans_lval(bcx, e);\n         bcx = src.res.bcx;\n         let dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n-        bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty).bcx;\n+        bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty);\n         i += 1;\n     }\n     ret rslt(bcx, tup_val);\n@@ -4891,7 +4898,7 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n         } else {\n             lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n         }\n-        bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty).bcx;\n+        bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n         i += 1u;\n     }\n     ret rslt(bcx, llvecptr);\n@@ -4926,19 +4933,16 @@ fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n             if str::eq(f.node.ident, tf.ident) {\n                 expr_provided = true;\n                 let lv = trans_lval(bcx, f.node.expr);\n-                bcx =\n-                    move_val_if_temp(lv.res.bcx, INIT, dst_res.val, lv,\n-                                     e_ty).bcx;\n+                bcx = move_val_if_temp(lv.res.bcx, INIT, dst_res.val,\n+                                       lv, e_ty);\n                 break;\n             }\n         }\n         if !expr_provided {\n             let src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n             src_res =\n                 rslt(src_res.bcx, load_if_immediate(bcx, src_res.val, e_ty));\n-            bcx =\n-                copy_val(src_res.bcx, INIT, dst_res.val, src_res.val,\n-                         e_ty).bcx;\n+            bcx = copy_val(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty);\n         }\n         i += 1;\n     }\n@@ -5023,10 +5027,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n         // FIXME: calculate copy init-ness in typestate.\n \n-        let move_res =\n-            move_val(rhs_res.res.bcx, DROP_EXISTING, lhs_res.res.val, rhs_res,\n-                     t);\n-        ret rslt(move_res.bcx, C_nil());\n+        let bcx = move_val(rhs_res.res.bcx, DROP_EXISTING, lhs_res.res.val,\n+                           rhs_res, t);\n+        ret rslt(bcx, C_nil());\n       }\n       ast::expr_assign(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n@@ -5035,10 +5038,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let rhs = trans_lval(lhs_res.res.bcx, src);\n         let t = ty::expr_ty(bcx_tcx(cx), src);\n         // FIXME: calculate copy init-ness in typestate.\n-        let copy_res =\n-            move_val_if_temp(rhs.res.bcx, DROP_EXISTING, lhs_res.res.val, rhs,\n-                             t);\n-        ret rslt(copy_res.bcx, C_nil());\n+        let bcx = move_val_if_temp(rhs.res.bcx, DROP_EXISTING,\n+                                   lhs_res.res.val, rhs, t);\n+        ret rslt(bcx, C_nil());\n       }\n       ast::expr_swap(dst, src) {\n         let lhs_res = trans_lval(cx, dst);\n@@ -5083,10 +5085,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n             trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t);\n         // FIXME: calculate copy init-ness in typestate.\n         // This is always a temporary, so can always be safely moved\n-        let move_res =\n-            move_val(v.bcx, DROP_EXISTING, lhs_res.res.val,\n-                     lval_val(v.bcx, v.val), t);\n-        ret rslt(move_res.bcx, C_nil());\n+        let bcx = move_val(v.bcx, DROP_EXISTING, lhs_res.res.val,\n+                           lval_val(v.bcx, v.val), t);\n+        ret rslt(bcx, C_nil());\n       }\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n       ast::expr_call(f, args) {\n@@ -5425,9 +5426,9 @@ fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n               _ { false }\n             };\n         if is_local {\n-            bcx = move_val(bcx, INIT, cx.fcx.llretptr, lv, t).bcx;\n+            bcx = move_val(bcx, INIT, cx.fcx.llretptr, lv, t);\n         } else {\n-            bcx = move_val_if_temp(bcx, INIT, cx.fcx.llretptr, lv, t).bcx;\n+            bcx = move_val_if_temp(bcx, INIT, cx.fcx.llretptr, lv, t);\n         }\n       }\n       _ {\n@@ -5476,11 +5477,11 @@ fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n             // the value.\n             ty = node_id_type(bcx_ccx(bcx), init.expr.id);\n             let sub = trans_lval(bcx, init.expr);\n-            bcx = move_val_if_temp(sub.res.bcx, INIT, llptr, sub, ty).bcx;\n+            bcx = move_val_if_temp(sub.res.bcx, INIT, llptr, sub, ty);\n           }\n           ast::init_move. {\n             let sub = trans_lval(bcx, init.expr);\n-            bcx = move_val(sub.res.bcx, INIT, llptr, sub, ty).bcx;\n+            bcx = move_val(sub.res.bcx, INIT, llptr, sub, ty);\n           }\n         }\n       }\n@@ -5750,7 +5751,7 @@ fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n                 // The output method is to save the value at target,\n                 // and we didn't pass it to the recursive trans_expr\n                 // call.\n-                bcx = move_val_if_temp(bcx, INIT, target, lv, r_ty).bcx;\n+                bcx = move_val_if_temp(bcx, INIT, target, lv, r_ty);\n                 r = rslt(bcx, C_nil());\n               }\n               return. { }\n@@ -6134,7 +6135,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n \n     let dst = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n     bcx = dst.bcx;\n-    bcx = copy_val(bcx, INIT, dst.val, arg, arg_t).bcx;\n+    bcx = copy_val(bcx, INIT, dst.val, arg, arg_t);\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n     bcx.build.Store(C_int(1), flag.val);\n@@ -6223,8 +6224,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                ty::type_has_dynamic_size(cx.ccx.tcx, arg_ty) {\n             llargval = llargptr;\n         } else { llargval = bcx.build.Load(llargptr); }\n-        rslt = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n-        bcx = rslt.bcx;\n+        bcx = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n         i += 1u;\n     }\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));"}, {"sha": "643cba56d7e0dd2d25655ea636ef04d80d89b779", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/081caf5bb8e22102ba517c7484dafcf65705c681/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081caf5bb8e22102ba517c7484dafcf65705c681/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=081caf5bb8e22102ba517c7484dafcf65705c681", "patch": "@@ -156,7 +156,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n             let capture =\n                 GEP_tup_like(bcx, typarams_ty, body_typarams.val, [0, i]);\n             bcx = capture.bcx;\n-            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n+            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty);\n             i += 1;\n         }\n \n@@ -174,7 +174,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                 let field =\n                     GEP_tup_like(bcx, fields_ty, body_fields.val, [0, i]);\n                 bcx = field.bcx;\n-                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys[i].ty).bcx;\n+                bcx = copy_val(bcx, INIT, field.val, arg, arg_tys[i].ty);\n                 i += 1;\n               }\n               none. {\n@@ -345,7 +345,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             bcx = field.bcx;\n             bcx =\n                 copy_val(bcx, INIT, field.val, additional_field_vals[i].val,\n-                         additional_field_tys[i]).bcx;\n+                         additional_field_tys[i]);\n             i += 1;\n         }\n \n@@ -363,9 +363,8 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n                 GEP_tup_like(bcx, body_ty, body,\n                              [0, abi::obj_body_elt_inner_obj]);\n             bcx = body_inner_obj.bcx;\n-            bcx =\n-                copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n-                         inner_obj_ty).bcx;\n+            bcx = copy_val(bcx, INIT, body_inner_obj.val, inner_obj_val.val,\n+                           inner_obj_ty);\n           }\n         }\n "}]}