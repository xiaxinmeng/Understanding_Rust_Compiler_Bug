{"sha": "ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMGZjZGQ2MzAwZTliNWQ3OGQ3Yjg2YTFiZGMyZTg0OWY2OGY5MzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T19:10:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T19:10:53Z"}, "message": "rustc: Create a unification context", "tree": {"sha": "59e1d5dd503beac5ecd7e97b8f2cad5a783900b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59e1d5dd503beac5ecd7e97b8f2cad5a783900b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935", "html_url": "https://github.com/rust-lang/rust/commit/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "html_url": "https://github.com/rust-lang/rust/commit/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b"}], "stats": {"total": 174, "additions": 75, "deletions": 99}, "files": [{"sha": "0140e5e8d5ade230d0f6058c59fe9358f88c3aa0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 75, "deletions": 99, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ef0fcdd6300e9b5d78d7b86a1bdc2e849f68f935", "patch": "@@ -1552,9 +1552,10 @@ mod Unify {\n         ures_err(type_err, @ty.t, @ty.t);\n     }\n \n-    type var_bindings = rec(UFind.ufind sets,\n-                            hashmap[int,uint] var_ids,\n-                            mutable vec[mutable vec[@t]] types);\n+    type ctxt = rec(UFind.ufind sets,\n+                    hashmap[int,uint] var_ids,\n+                    mutable vec[mutable vec[@t]] types,\n+                    unify_handler handler);\n \n     // Wraps the given type in an appropriate cname.\n     //\n@@ -1592,10 +1593,9 @@ mod Unify {\n         fn_common_res_ok(vec[arg], @t);\n     }\n \n-    fn unify_fn_common(&var_bindings bindings,\n+    fn unify_fn_common(@ctxt cx,\n                        @ty.t expected,\n                        @ty.t actual,\n-                       &unify_handler handler,\n                        vec[arg] expected_inputs, @t expected_output,\n                        vec[arg] actual_inputs, @t actual_output)\n         -> fn_common_res {\n@@ -1622,15 +1622,11 @@ mod Unify {\n                 result_mode = ast.val;\n             }\n \n-            auto result = unify_step(bindings,\n-                                     actual_input.ty,\n-                                     expected_input.ty,\n-                                     handler);\n+            auto result = unify_step(cx, actual_input.ty, expected_input.ty);\n \n             alt (result) {\n                 case (ures_ok(?rty)) {\n-                    result_ins += vec(rec(mode=result_mode,\n-                                          ty=rty));\n+                    result_ins += vec(rec(mode=result_mode, ty=rty));\n                 }\n \n                 case (_) {\n@@ -1642,10 +1638,7 @@ mod Unify {\n         }\n \n         // Check the output.\n-        auto result = unify_step(bindings,\n-                                 expected_output,\n-                                 actual_output,\n-                                 handler);\n+        auto result = unify_step(cx, expected_output, actual_output);\n         alt (result) {\n             case (ures_ok(?rty)) {\n                 ret fn_common_res_ok(result_ins, rty);\n@@ -1657,21 +1650,20 @@ mod Unify {\n         }\n     }\n \n-    fn unify_fn(&var_bindings bindings,\n+    fn unify_fn(@ctxt cx,\n                 ast.proto e_proto,\n                 ast.proto a_proto,\n                 @ty.t expected,\n                 @ty.t actual,\n-                &unify_handler handler,\n                 vec[arg] expected_inputs, @t expected_output,\n                 vec[arg] actual_inputs, @t actual_output)\n         -> result {\n \n         if (e_proto != a_proto) {\n             ret ures_err(terr_mismatch, expected, actual);\n         }\n-        auto t = unify_fn_common(bindings, expected, actual,\n-                                 handler, expected_inputs, expected_output,\n+        auto t = unify_fn_common(cx, expected, actual,\n+                                 expected_inputs, expected_output,\n                                  actual_inputs, actual_output);\n         alt (t) {\n             case (fn_common_res_err(?r)) {\n@@ -1684,21 +1676,20 @@ mod Unify {\n         }\n     }\n \n-    fn unify_native_fn(&var_bindings bindings,\n+    fn unify_native_fn(@ctxt cx,\n                        ast.native_abi e_abi,\n                        ast.native_abi a_abi,\n                        @ty.t expected,\n                        @ty.t actual,\n-                       &unify_handler handler,\n                        vec[arg] expected_inputs, @t expected_output,\n                        vec[arg] actual_inputs, @t actual_output)\n         -> result {\n         if (e_abi != a_abi) {\n             ret ures_err(terr_mismatch, expected, actual);\n         }\n \n-        auto t = unify_fn_common(bindings, expected, actual,\n-                                 handler, expected_inputs, expected_output,\n+        auto t = unify_fn_common(cx, expected, actual,\n+                                 expected_inputs, expected_output,\n                                  actual_inputs, actual_output);\n         alt (t) {\n             case (fn_common_res_err(?r)) {\n@@ -1711,10 +1702,9 @@ mod Unify {\n         }\n     }\n \n-    fn unify_obj(&var_bindings bindings,\n+    fn unify_obj(@ctxt cx,\n                  @ty.t expected,\n                  @ty.t actual,\n-                 &unify_handler handler,\n                  vec[method] expected_meths,\n                  vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n@@ -1733,9 +1723,9 @@ mod Unify {\n           ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n                        expected, actual);\n         }\n-        auto r = unify_fn(bindings,\n+        auto r = unify_fn(cx,\n                           e_meth.proto, a_meth.proto,\n-                          expected, actual, handler,\n+                          expected, actual,\n                           e_meth.inputs, e_meth.output,\n                           a_meth.inputs, a_meth.output);\n         alt (r) {\n@@ -1758,20 +1748,19 @@ mod Unify {\n       ret ures_ok(t);\n     }\n \n-    fn get_or_create_set(&var_bindings bindings, int id) -> uint {\n+    fn get_or_create_set(@ctxt cx, int id) -> uint {\n         auto set_num;\n-        alt (bindings.var_ids.find(id)) {\n+        alt (cx.var_ids.find(id)) {\n         case (none[uint]) {\n-            set_num = UFind.make_set(bindings.sets);\n-            bindings.var_ids.insert(id, set_num);\n+            set_num = UFind.make_set(cx.sets);\n+            cx.var_ids.insert(id, set_num);\n         }\n         case (some[uint](?n)) { set_num = n; }\n         }\n         ret set_num;\n     }\n \n-    fn unify_step(&var_bindings bindings, @ty.t expected, @ty.t actual,\n-                  &unify_handler handler) -> result {\n+    fn unify_step(@ctxt cx, @ty.t expected, @ty.t actual) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -1782,44 +1771,40 @@ mod Unify {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n-                auto actual_n = get_or_create_set(bindings, actual_id);\n+                auto actual_n = get_or_create_set(cx, actual_id);\n                 alt (expected.struct) {\n                     case (ty.ty_var(?expected_id)) {\n-                        auto expected_n = get_or_create_set(bindings,\n-                                                            expected_id);\n-                        UFind.union(bindings.sets, expected_n, actual_n);\n+                        auto expected_n = get_or_create_set(cx, expected_id);\n+                        UFind.union(cx.sets, expected_n, actual_n);\n                     }\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = _vec.len[mutable vec[@t]](bindings.types);\n+                        auto vlen = _vec.len[mutable vec[@t]](cx.types);\n                         if (actual_n < vlen) {\n-                            bindings.types.(actual_n) += vec(expected);\n+                            cx.types.(actual_n) += vec(expected);\n                         } else {\n                             check (actual_n == vlen);\n-                            bindings.types += vec(mutable vec(expected));\n+                            cx.types += vec(mutable vec(expected));\n                         }\n                     }\n                 }\n                 ret ures_ok(actual);\n             }\n             case (ty.ty_local(?actual_id)) {\n                 auto result_ty;\n-                alt (handler.resolve_local(actual_id)) {\n+                alt (cx.handler.resolve_local(actual_id)) {\n                     case (none[@ty.t]) { result_ty = expected; }\n                     case (some[@ty.t](?actual_ty)) {\n-                        auto result = unify_step(bindings,\n-                                                 expected,\n-                                                 actual_ty,\n-                                                 handler);\n+                        auto result = unify_step(cx, expected, actual_ty);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n                             case (_) { ret result; }\n                         }\n                     }\n                 }\n \n-                handler.record_local(actual_id, result_ty);\n+                cx.handler.record_local(actual_id, result_ty);\n                 ret ures_ok(result_ty);\n             }\n             case (ty.ty_bound_param(?actual_id)) {\n@@ -1830,7 +1815,7 @@ mod Unify {\n                     }\n \n                     case (_) {\n-                        ret handler.record_param(actual_id, expected);\n+                        ret cx.handler.record_param(actual_id, expected);\n                     }\n                 }\n             }\n@@ -1867,10 +1852,9 @@ mod Unify {\n                             auto expected_tp = expected_tps.(i);\n                             auto actual_tp = actual_tps.(i);\n \n-                            auto result = unify_step(bindings,\n+                            auto result = unify_step(cx,\n                                                      expected_tp,\n-                                                     actual_tp,\n-                                                     handler);\n+                                                     actual_tp);\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n@@ -1904,10 +1888,9 @@ mod Unify {\n                             case (some[ast.mutability](?m)) { mut = m; }\n                         }\n \n-                        auto result = unify_step(bindings,\n+                        auto result = unify_step(cx,\n                                                  expected_mt.ty,\n-                                                 actual_mt.ty,\n-                                                 handler);\n+                                                 actual_mt.ty);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n@@ -1937,10 +1920,9 @@ mod Unify {\n                             case (some[ast.mutability](?m)) { mut = m; }\n                         }\n \n-                        auto result = unify_step(bindings,\n+                        auto result = unify_step(cx,\n                                                  expected_mt.ty,\n-                                                 actual_mt.ty,\n-                                                 handler);\n+                                                 actual_mt.ty);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 auto mt = rec(ty=result_sub, mut=mut);\n@@ -1961,10 +1943,9 @@ mod Unify {\n             case (ty.ty_port(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty.ty_port(?actual_sub)) {\n-                        auto result = unify_step(bindings,\n+                        auto result = unify_step(cx,\n                                                  expected_sub,\n-                                                 actual_sub,\n-                                                 handler);\n+                                                 actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(mk_port(result_sub));\n@@ -1984,10 +1965,9 @@ mod Unify {\n             case (ty.ty_chan(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty.ty_chan(?actual_sub)) {\n-                        auto result = unify_step(bindings,\n+                        auto result = unify_step(cx,\n                                                  expected_sub,\n-                                                 actual_sub,\n-                                                 handler);\n+                                                 actual_sub);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n                                 ret ures_ok(mk_chan(result_sub));\n@@ -2033,10 +2013,9 @@ mod Unify {\n                                 case (some[ast.mutability](?m)) { mut = m; }\n                             }\n \n-                            auto result = unify_step(bindings,\n+                            auto result = unify_step(cx,\n                                                      expected_elem.ty,\n-                                                     actual_elem.ty,\n-                                                     handler);\n+                                                     actual_elem.ty);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n@@ -2096,10 +2075,9 @@ mod Unify {\n                                 ret ures_err(err, expected, actual);\n                             }\n \n-                            auto result = unify_step(bindings,\n+                            auto result = unify_step(cx,\n                                                      expected_field.mt.ty,\n-                                                     actual_field.mt.ty,\n-                                                     handler);\n+                                                     actual_field.mt.ty);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n                                     auto mt = rec(ty=rty, mut=mut);\n@@ -2127,8 +2105,8 @@ mod Unify {\n             case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n                 alt (actual.struct) {\n                     case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n-                        ret unify_fn(bindings, ep, ap,\n-                                     expected, actual, handler,\n+                        ret unify_fn(cx, ep, ap,\n+                                     expected, actual,\n                                      expected_inputs, expected_output,\n                                      actual_inputs, actual_output);\n                     }\n@@ -2144,8 +2122,8 @@ mod Unify {\n                 alt (actual.struct) {\n                     case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n                                           ?actual_output)) {\n-                        ret unify_native_fn(bindings, e_abi, a_abi,\n-                                            expected, actual, handler,\n+                        ret unify_native_fn(cx, e_abi, a_abi,\n+                                            expected, actual,\n                                             expected_inputs, expected_output,\n                                             actual_inputs, actual_output);\n                     }\n@@ -2158,7 +2136,7 @@ mod Unify {\n             case (ty.ty_obj(?expected_meths)) {\n                 alt (actual.struct) {\n                     case (ty.ty_obj(?actual_meths)) {\n-                        ret unify_obj(bindings, expected, actual, handler,\n+                        ret unify_obj(cx, expected, actual,\n                                       expected_meths, actual_meths);\n                     }\n                     case (_) {\n@@ -2169,39 +2147,36 @@ mod Unify {\n \n             case (ty.ty_var(?expected_id)) {\n                 // Add a binding.\n-                auto expected_n = get_or_create_set(bindings, expected_id);\n-                auto vlen = _vec.len[mutable vec[@t]](bindings.types);\n+                auto expected_n = get_or_create_set(cx, expected_id);\n+                auto vlen = _vec.len[mutable vec[@t]](cx.types);\n                 if (expected_n < vlen) {\n-                    bindings.types.(expected_n) += vec(actual);\n+                    cx.types.(expected_n) += vec(actual);\n                 } else {\n                     check (expected_n == vlen);\n-                    bindings.types += vec(mutable vec(actual));\n+                    cx.types += vec(mutable vec(actual));\n                 }\n                 ret ures_ok(expected);\n             }\n \n             case (ty.ty_local(?expected_id)) {\n                 auto result_ty;\n-                alt (handler.resolve_local(expected_id)) {\n+                alt (cx.handler.resolve_local(expected_id)) {\n                     case (none[@ty.t]) { result_ty = actual; }\n                     case (some[@ty.t](?expected_ty)) {\n-                        auto result = unify_step(bindings,\n-                                                 expected_ty,\n-                                                 actual,\n-                                                 handler);\n+                        auto result = unify_step(cx, expected_ty, actual);\n                         alt (result) {\n                             case (ures_ok(?rty)) { result_ty = rty; }\n                             case (_) { ret result; }\n                         }\n                     }\n                 }\n \n-                handler.record_local(expected_id, result_ty);\n+                cx.handler.record_local(expected_id, result_ty);\n                 ret ures_ok(result_ty);\n             }\n \n             case (ty.ty_bound_param(?expected_id)) {\n-                ret handler.record_param(expected_id, actual);\n+                ret cx.handler.record_param(expected_id, actual);\n             }\n         }\n \n@@ -2210,13 +2185,13 @@ mod Unify {\n     }\n \n     // Performs type binding substitution.\n-    fn substitute(var_bindings bindings, vec[@t] set_types, @t typ) -> @t {\n-        fn substituter(var_bindings bindings, vec[@t] types, @t typ) -> @t {\n+    fn substitute(@ctxt cx, vec[@t] set_types, @t typ) -> @t {\n+        fn substituter(@ctxt cx, vec[@t] types, @t typ) -> @t {\n             alt (typ.struct) {\n                 case (ty_var(?id)) {\n-                    alt (bindings.var_ids.find(id)) {\n+                    alt (cx.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n-                            auto root = UFind.find(bindings.sets, n);\n+                            auto root = UFind.find(cx.sets, n);\n                             ret types.(root);\n                         }\n                         case (none[uint]) { ret typ; }\n@@ -2226,24 +2201,24 @@ mod Unify {\n             }\n         }\n \n-        auto f = bind substituter(bindings, set_types, _);\n+        auto f = bind substituter(cx, set_types, _);\n         ret fold_ty(f, typ);\n     }\n \n-    fn unify_sets(&var_bindings bindings) -> vec[@t] {\n+    fn unify_sets(@ctxt cx) -> vec[@t] {\n         let vec[@t] throwaway = vec();\n         let vec[mutable vec[@t]] set_types = vec(mutable throwaway);\n         _vec.pop[mutable vec[@t]](set_types);   // FIXME: botch\n \n-        for (UFind.node node in bindings.sets.nodes) {\n+        for (UFind.node node in cx.sets.nodes) {\n             let vec[@t] v = vec();\n             set_types += vec(mutable v);\n         }\n \n         auto i = 0u;\n         while (i < _vec.len[mutable vec[@t]](set_types)) {\n-            auto root = UFind.find(bindings.sets, i);\n-            set_types.(root) += bindings.types.(i);\n+            auto root = UFind.find(cx.sets, i);\n+            set_types.(root) += cx.types.(i);\n             i += 1u;\n         }\n \n@@ -2266,15 +2241,16 @@ mod Unify {\n         let vec[mutable vec[@t]] types = vec(mutable throwaway);\n         _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n \n-        auto bindings = rec(sets=UFind.make(),\n-                            var_ids=common.new_int_hash[uint](),\n-                            mutable types=types);\n+        auto cx = @rec(sets=UFind.make(),\n+                       var_ids=common.new_int_hash[uint](),\n+                       mutable types=types,\n+                       handler=handler);\n \n-        auto ures = unify_step(bindings, expected, actual, handler);\n+        auto ures = unify_step(cx, expected, actual);\n         alt (ures) {\n         case (ures_ok(?t)) {\n-            auto set_types = unify_sets(bindings);\n-            auto t2 = substitute(bindings, set_types, t);\n+            auto set_types = unify_sets(cx);\n+            auto t2 = substitute(cx, set_types, t);\n             ret ures_ok(t2);\n         }\n         case (_) { ret ures; }"}]}