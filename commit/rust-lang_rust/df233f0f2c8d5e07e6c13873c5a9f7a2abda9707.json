{"sha": "df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMjMzZjBmMmM4ZDVlMDdlNmMxMzg3M2M1YTlmN2EyYWJkYTk3MDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-07T12:01:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T11:06:30Z"}, "message": "stop using `borrows` for anything but iterating over live data", "tree": {"sha": "8b9da7cf487e7ba37b6047f1ecc1b9671bb0550e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b9da7cf487e7ba37b6047f1ecc1b9671bb0550e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "html_url": "https://github.com/rust-lang/rust/commit/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4005a2bc9adeb5a19b04bd4354e22e9e75a7072", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4005a2bc9adeb5a19b04bd4354e22e9e75a7072", "html_url": "https://github.com/rust-lang/rust/commit/d4005a2bc9adeb5a19b04bd4354e22e9e75a7072"}], "stats": {"total": 113, "additions": 56, "deletions": 57}, "files": [{"sha": "c2d7d68923dd9aa2588e3cc1c4f431e0af1a60ac", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "patch": "@@ -18,6 +18,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n use std::hash::Hash;\n+use std::ops::Index;\n use syntax_pos::Span;\n \n crate struct BorrowSet<'tcx> {\n@@ -49,6 +50,14 @@ crate struct BorrowSet<'tcx> {\n     crate region_span_map: FxHashMap<RegionKind, Span>,\n }\n \n+impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n+    type Output = BorrowData<'tcx>;\n+\n+    fn index(&self, index: BorrowIndex) -> &BorrowData<'tcx> {\n+        &self.borrows[index]\n+    }\n+}\n+\n #[derive(Debug)]\n crate struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n@@ -124,6 +133,13 @@ impl<'tcx> BorrowSet<'tcx> {\n             region_span_map: visitor.region_span_map,\n         }\n     }\n+\n+    crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n+        self.activation_map\n+            .get(&location)\n+            .map(|activations| &activations[..])\n+            .unwrap_or(&[])\n+    }\n }\n \n struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {"}, {"sha": "340ff5e17876798c814a77ab70f8566fb05feebc", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "patch": "@@ -20,7 +20,7 @@ use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n use super::borrow_set::BorrowData;\n \n-use dataflow::{Borrows, FlowAtLocation, MovingOutStatements};\n+use dataflow::{FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -391,10 +391,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &Borrows<'cx, 'gcx, 'tcx>\n     ) {\n-        let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.scope_tree();\n+        let end_span = self.opt_region_end_span(&borrow.region);\n+        let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n         let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();"}, {"sha": "23682bdee66891095c4eccb3590d4e90abeb1597", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "patch": "@@ -29,7 +29,6 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use std::rc::Rc;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use dataflow::{do_dataflow, DebugFormatted};\n@@ -237,7 +236,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n-        node_id: id,\n+        mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n         movable_generator,\n@@ -250,6 +249,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx,\n         nonlexical_cause_info: None,\n+        borrow_set,\n         dominators,\n     };\n \n@@ -270,7 +270,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     mir: &'cx Mir<'tcx>,\n-    node_id: ast::NodeId,\n+    mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n     movable_generator: bool,\n@@ -303,6 +303,11 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n     nonlexical_cause_info: Option<RegionCausalInfo>,\n+\n+    /// The set of borrows extracted from the MIR\n+    borrow_set: Rc<BorrowSet<'tcx>>,\n+\n+    /// Dominators for MIR\n     dominators: Dominators<BasicBlock>,\n }\n \n@@ -544,11 +549,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n-                    let domain = flow_state.borrows.operator();\n-                    let data = domain.borrows();\n+                    let borrow_set = self.borrow_set.clone();\n                     flow_state.borrows.with_iter_outgoing(|borrows| {\n                         for i in borrows {\n-                            let borrow = &data[i];\n+                            let borrow = &borrow_set[i];\n                             self.check_for_local_borrow(borrow, span);\n                         }\n                     });\n@@ -560,13 +564,12 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // Often, the storage will already have been killed by an explicit\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n-                let domain = flow_state.borrows.operator();\n-                let data = domain.borrows();\n+                let borrow_set = self.borrow_set.clone();\n                 flow_state.borrows.with_iter_outgoing(|borrows| {\n                     for i in borrows {\n-                        let borrow = &data[i];\n+                        let borrow = &borrow_set[i];\n                         let context = ContextKind::StorageDead.new(loc);\n-                        self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n+                        self.check_for_invalidation_at_exit(context, borrow, span);\n                     }\n                 });\n             }\n@@ -894,10 +897,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             this.report_use_while_mutably_borrowed(context, place_span, borrow)\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            let end_issued_loan_span = flow_state\n-                                .borrows\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n+                            let end_issued_loan_span = this.opt_region_end_span(&borrow.region);\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n@@ -936,10 +936,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            let end_issued_loan_span = flow_state\n-                                .borrows\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n+                            let end_issued_loan_span = this.opt_region_end_span(&borrow.region);\n \n                             error_reported = true;\n                             this.report_conflicting_borrow(\n@@ -956,7 +953,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 context,\n                                 borrow,\n                                 place_span.1,\n-                                flow_state.borrows.operator(),\n                             );\n                         }\n                         WriteKind::Mutate => {\n@@ -1158,7 +1154,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n-        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n@@ -1211,7 +1206,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 context,\n                 borrow,\n                 span,\n-                flow_state.borrows.operator(),\n             )\n         }\n     }\n@@ -1266,9 +1260,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow.\n-        let borrows = flow_state.borrows.operator();\n-        for &borrow_index in borrows.activations_at_location(location) {\n-            let borrow = &borrows.borrows()[borrow_index];\n+        let borrow_set = self.borrow_set.clone();\n+        for &borrow_index in borrow_set.activations_at_location(location) {\n+            let borrow = &borrow_set[borrow_index];\n \n             // only mutable borrows should be 2-phase\n             assert!(match borrow.kind {\n@@ -1838,6 +1832,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, return region span if it exists and\n+    /// span for end of the function if it doesn't exist.\n+    pub(crate) fn opt_region_end_span(&self, region: &ty::Region<'tcx>) -> Option<Span> {\n+        match self.nonlexical_regioncx {\n+            Some(_) => None,\n+            None => {\n+                match self.borrow_set.region_span_map.get(region) {\n+                    Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n+                    None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n+                }\n+            }\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -2238,13 +2248,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n-        let data = flow_state.borrows.operator().borrows();\n-\n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n         let mut iter_incoming = flow_state.borrows.iter_incoming();\n+        let borrow_set = self.borrow_set.clone();\n         while let Some(i) = iter_incoming.next() {\n-            let borrowed = &data[i];\n+            let borrowed = &borrow_set[i];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 debug!("}, {"sha": "55c38dc89f6363f1ef8cff0d7df200670e3efb13", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df233f0f2c8d5e07e6c13873c5a9f7a2abda9707/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=df233f0f2c8d5e07e6c13873c5a9f7a2abda9707", "patch": "@@ -16,7 +16,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n-use rustc::ty::{Region, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n \n@@ -30,8 +30,6 @@ pub use dataflow::indexes::BorrowIndex;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n \n-use syntax_pos::Span;\n-\n use std::rc::Rc;\n \n /// `Borrows` stores the data used in the analyses that track the flow\n@@ -77,22 +75,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.borrow_set.region_span_map.get(region) {\n-                    Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n-                    None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n-                }\n-            }\n-        }\n-    }\n-\n     crate fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrow_set.borrows }\n \n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n@@ -136,13 +118,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             sets.kill_all(borrow_indexes);\n         }\n     }\n-\n-    crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n-        self.borrow_set.activation_map\n-            .get(&location)\n-            .map(|activations| &activations[..])\n-            .unwrap_or(&[])\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {"}]}