{"sha": "88192785233d0fed6cc8702e3067f02208e62a14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MTkyNzg1MjMzZDBmZWQ2Y2M4NzAyZTMwNjdmMDIyMDhlNjJhMTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-27T11:02:31Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:44Z"}, "message": "async-llvm(22): mw invokes mad html skillz to produce graphical LLVM timing reports.", "tree": {"sha": "af427d5cdfe3e45a652fe0ddf10dd794ecf1ab0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af427d5cdfe3e45a652fe0ddf10dd794ecf1ab0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88192785233d0fed6cc8702e3067f02208e62a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88192785233d0fed6cc8702e3067f02208e62a14", "html_url": "https://github.com/rust-lang/rust/commit/88192785233d0fed6cc8702e3067f02208e62a14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88192785233d0fed6cc8702e3067f02208e62a14/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1480be37795bd25b7d7cedf9e1ef5caf985fe38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1480be37795bd25b7d7cedf9e1ef5caf985fe38c", "html_url": "https://github.com/rust-lang/rust/commit/1480be37795bd25b7d7cedf9e1ef5caf985fe38c"}], "stats": {"total": 224, "additions": 224, "deletions": 0}, "files": [{"sha": "4a9fbbe6f157d53d72585b6b43ca9f926e4ac5c6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=88192785233d0fed6cc8702e3067f02208e62a14", "patch": "@@ -1059,6 +1059,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n+    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "a3845cf0e8e7e3fa61c64febc8235281e30b7803", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=88192785233d0fed6cc8702e3067f02208e62a14", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n+use time_graph::{self, TimeGraph};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n@@ -342,6 +343,9 @@ pub struct CodegenContext {\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n     coordinator_send: Sender<Message>,\n+    // A reference to the TimeGraph so we can register timings. None means that\n+    // measuring is disabled.\n+    time_graph: Option<TimeGraph>,\n }\n \n impl CodegenContext {\n@@ -662,6 +666,7 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n \n pub fn start_async_translation(sess: &Session,\n                                crate_output: &OutputFilenames,\n+                               time_graph: Option<TimeGraph>,\n                                crate_name: Symbol,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n@@ -768,6 +773,7 @@ pub fn start_async_translation(sess: &Session,\n                                                   coordinator_send.clone(),\n                                                   coordinator_receive,\n                                                   client,\n+                                                  time_graph.clone(),\n                                                   exported_symbols.clone());\n     OngoingCrateTranslation {\n         crate_name,\n@@ -783,6 +789,7 @@ pub fn start_async_translation(sess: &Session,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n \n+        time_graph,\n         output_filenames: crate_output.clone(),\n         coordinator_send,\n         shared_emitter_main,\n@@ -1084,6 +1091,7 @@ fn start_executing_work(sess: &Session,\n                         coordinator_send: Sender<Message>,\n                         coordinator_receive: Receiver<Message>,\n                         jobserver: Client,\n+                        time_graph: Option<TimeGraph>,\n                         exported_symbols: Arc<ExportedSymbols>)\n                         -> thread::JoinHandle<CompiledModules> {\n     // First up, convert our jobserver into a helper thread so we can use normal\n@@ -1123,6 +1131,7 @@ fn start_executing_work(sess: &Session,\n         incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n         coordinator_send: coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n+        time_graph,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1295,10 +1304,22 @@ fn start_executing_work(sess: &Session,\n     })\n }\n \n+pub const TRANS_WORKER_ID: usize = ::std::usize::MAX;\n+pub const TRANS_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(TRANS_WORKER_ID);\n+pub const TRANS_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n+const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n+\n fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n     let depth = time_depth();\n \n     thread::spawn(move || {\n+        let _timing_guard = cgcx.time_graph\n+                                .as_ref()\n+                                .map(|tg| tg.start(time_graph::TimelineId(cgcx.worker),\n+                                                   LLVM_WORK_PACKAGE_KIND));\n         set_time_depth(depth);\n \n         // Set up a destructor which will fire off a message that we're done as\n@@ -1555,6 +1576,7 @@ pub struct OngoingCrateTranslation {\n     metadata_module_config: ModuleConfig,\n     allocator_module_config: ModuleConfig,\n \n+    time_graph: Option<TimeGraph>,\n     coordinator_send: Sender<Message>,\n     shared_emitter_main: SharedEmitterMain,\n     future: thread::JoinHandle<CompiledModules>,\n@@ -1567,6 +1589,10 @@ impl OngoingCrateTranslation {\n \n         sess.abort_if_errors();\n \n+        if let Some(time_graph) = self.time_graph {\n+            time_graph.dump(&format!(\"{}-timings\", self.crate_name));\n+        }\n+\n         copy_module_artifacts_into_incr_comp_cache(sess,\n                                                    &compiled_modules,\n                                                    &self.output_filenames);"}, {"sha": "0b82ac71c33d3657d26a055625071c275cbd5496", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=88192785233d0fed6cc8702e3067f02208e62a14", "patch": "@@ -69,6 +69,7 @@ use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_names_test;\n+use time_graph;\n use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n@@ -956,6 +957,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n+    let time_graph = if tcx.sess.opts.debugging_opts.trans_time_graph {\n+        Some(time_graph::TimeGraph::new())\n+    } else {\n+        None\n+    };\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n@@ -965,6 +971,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let ongoing_translation = write::start_async_translation(\n             tcx.sess,\n             output_filenames,\n+            time_graph.clone(),\n             tcx.crate_name(LOCAL_CRATE),\n             link_meta,\n             metadata,\n@@ -1015,6 +1022,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ongoing_translation = write::start_async_translation(\n         tcx.sess,\n         output_filenames,\n+        time_graph.clone(),\n         tcx.crate_name(LOCAL_CRATE),\n         link_meta,\n         metadata,\n@@ -1033,6 +1041,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for cgu in codegen_units.into_iter() {\n         ongoing_translation.check_for_errors(tcx.sess);\n+\n+        let _timing_guard = time_graph\n+            .as_ref()\n+            .map(|time_graph| time_graph.start(write::TRANS_WORKER_TIMELINE,\n+                                               write::TRANS_WORK_PACKAGE_KIND));\n+\n         let dep_node = cgu.work_product_dep_node();\n         let ((stats, module), _) =\n             tcx.dep_graph.with_task(dep_node,"}, {"sha": "83835cb794abf09a50944e278ab13746c62ab30b", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=88192785233d0fed6cc8702e3067f02208e62a14", "patch": "@@ -125,6 +125,7 @@ mod mir;\n mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n+mod time_graph;\n mod trans_item;\n mod tvec;\n mod type_;"}, {"sha": "e0ebe8a0933f128407f5ae79c640d7beb8729a50", "filename": "src/librustc_trans/time_graph.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88192785233d0fed6cc8702e3067f02208e62a14/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=88192785233d0fed6cc8702e3067f02208e62a14", "patch": "@@ -0,0 +1,181 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::marker::PhantomData;\n+use std::sync::{Arc, Mutex};\n+use std::time::Instant;\n+use std::io::prelude::*;\n+use std::fs::File;\n+\n+const OUTPUT_WIDTH_IN_PX: u64 = 1000;\n+const TIME_LINE_HEIGHT_IN_PX: u64 = 7;\n+const TIME_LINE_HEIGHT_STRIDE_IN_PX: usize = 10;\n+\n+#[derive(Clone)]\n+struct Timing {\n+    start: Instant,\n+    end: Instant,\n+    work_package_kind: WorkPackageKind,\n+}\n+\n+#[derive(Clone, Copy, Hash, Eq, PartialEq, Debug)]\n+pub struct TimelineId(pub usize);\n+\n+#[derive(Clone)]\n+struct PerThread {\n+    timings: Vec<Timing>,\n+    open_work_package: Option<(Instant, WorkPackageKind)>,\n+}\n+\n+#[derive(Clone)]\n+pub struct TimeGraph {\n+    data: Arc<Mutex<HashMap<TimelineId, PerThread>>>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct WorkPackageKind(pub &'static [&'static str]);\n+\n+pub struct RaiiToken {\n+    graph: TimeGraph,\n+    timeline: TimelineId,\n+    // The token must not be Send:\n+    _marker: PhantomData<*const ()>\n+}\n+\n+\n+impl Drop for RaiiToken {\n+    fn drop(&mut self) {\n+        self.graph.end(self.timeline);\n+    }\n+}\n+\n+impl TimeGraph {\n+    pub fn new() -> TimeGraph {\n+        TimeGraph {\n+            data: Arc::new(Mutex::new(HashMap::new()))\n+        }\n+    }\n+\n+    pub fn start(&self,\n+                 timeline: TimelineId,\n+                 work_package_kind: WorkPackageKind) -> RaiiToken {\n+        {\n+            let mut table = self.data.lock().unwrap();\n+\n+            let mut data = table.entry(timeline).or_insert(PerThread {\n+                timings: Vec::new(),\n+                open_work_package: None,\n+            });\n+\n+            assert!(data.open_work_package.is_none());\n+            data.open_work_package = Some((Instant::now(), work_package_kind));\n+        }\n+\n+        RaiiToken {\n+            graph: self.clone(),\n+            timeline,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    fn end(&self, timeline: TimelineId) {\n+        let end = Instant::now();\n+\n+        let mut table = self.data.lock().unwrap();\n+        let mut data = table.get_mut(&timeline).unwrap();\n+\n+        if let Some((start, work_package_kind)) = data.open_work_package {\n+            data.timings.push(Timing {\n+                start,\n+                end,\n+                work_package_kind,\n+            });\n+        } else {\n+            bug!(\"end timing without start?\")\n+        }\n+\n+        data.open_work_package = None;\n+    }\n+\n+    pub fn dump(&self, output_filename: &str) {\n+        let table = self.data.lock().unwrap();\n+\n+        for data in table.values() {\n+            assert!(data.open_work_package.is_none());\n+        }\n+\n+        let mut timelines: Vec<PerThread> =\n+            table.values().map(|data| data.clone()).collect();\n+\n+        timelines.sort_by_key(|timeline| timeline.timings[0].start);\n+\n+        let earliest_instant = timelines[0].timings[0].start;\n+        let latest_instant = timelines.iter()\n+                                       .map(|timeline| timeline.timings\n+                                                               .last()\n+                                                               .unwrap()\n+                                                               .end)\n+                                       .max()\n+                                       .unwrap();\n+        let max_distance = distance(earliest_instant, latest_instant);\n+\n+        let mut file = File::create(format!(\"{}.html\", output_filename)).unwrap();\n+\n+        writeln!(file, \"<html>\").unwrap();\n+        writeln!(file, \"<head></head>\").unwrap();\n+        writeln!(file, \"<body>\").unwrap();\n+\n+        let mut color = 0;\n+\n+        for (line_index, timeline) in timelines.iter().enumerate() {\n+            let line_top = line_index * TIME_LINE_HEIGHT_STRIDE_IN_PX;\n+\n+            for span in &timeline.timings {\n+                let start = distance(earliest_instant, span.start);\n+                let end = distance(earliest_instant, span.end);\n+\n+                let start = normalize(start, max_distance, OUTPUT_WIDTH_IN_PX);\n+                let end = normalize(end, max_distance, OUTPUT_WIDTH_IN_PX);\n+\n+                let colors = span.work_package_kind.0;\n+\n+                writeln!(file, \"<div style='position:absolute; \\\n+                                            top:{}px; \\\n+                                            left:{}px; \\\n+                                            width:{}px; \\\n+                                            height:{}px; \\\n+                                            background:{};'></div>\",\n+                    line_top,\n+                    start,\n+                    end - start,\n+                    TIME_LINE_HEIGHT_IN_PX,\n+                    colors[color % colors.len()]\n+                    ).unwrap();\n+\n+                color += 1;\n+            }\n+        }\n+\n+        writeln!(file, \"</body>\").unwrap();\n+        writeln!(file, \"</html>\").unwrap();\n+    }\n+}\n+\n+fn distance(zero: Instant, x: Instant) -> u64 {\n+\n+    let duration = x.duration_since(zero);\n+    (duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64) // / div\n+}\n+\n+fn normalize(distance: u64, max: u64, max_pixels: u64) -> u64 {\n+    (max_pixels * distance) / max\n+}\n+"}]}